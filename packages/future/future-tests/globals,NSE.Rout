
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:04:39.576] plan(): Setting new future strategy stack:
[18:04:39.577] List of future strategies:
[18:04:39.577] 1. sequential:
[18:04:39.577]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.577]    - tweaked: FALSE
[18:04:39.577]    - call: future::plan("sequential")
[18:04:39.600] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals w/ non-standard evaluation (NSE) ...")
*** Globals w/ non-standard evaluation (NSE) ...
> 
> data <- data.frame(x = 1:5, y = 1:5)
> v0 <- subset(data, x < 3)$y
> 
> for (strategy in supportedStrategies()) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- Strategy: %s ...", strategy))
+   
+   plan(strategy)
+ 
+   ## Assert option is passed on to future
+   options(future.globals.onMissing = "error")
+   opt1 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt1, "error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   opt2 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt2, "ignore"))
+ 
+   options(future.globals.onMissing = "error")
+   res <- try({ v1 %<-% subset(data, x < 3)$y }, silent = TRUE)
+   stopifnot(inherits(res, "try-error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   v2 %<-% subset(data, x < 3)$y
+   stopifnot(identical(v2, v0))
+ 
+   ## Nested futures (requires option is passed on to future)
+   plan(list(sequential, strategy))
+   options(future.globals.onMissing = "ignore")
+   v3 %<-% {
+     a %<-% subset(data, x < 3)$y
+     a
+   } %lazy% TRUE
+   stopifnot(identical(v3, v0))
+ 
+   message(sprintf("- Strategy: %s ... DONE", strategy))
+ }
- Strategy: sequential ...
[18:04:39.661] plan(): Setting new future strategy stack:
[18:04:39.661] List of future strategies:
[18:04:39.661] 1. sequential:
[18:04:39.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.661]    - tweaked: FALSE
[18:04:39.661]    - call: plan(strategy)
[18:04:39.689] plan(): nbrOfWorkers() = 1
[18:04:39.692] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:39.693] Searching for globals...
[18:04:39.699] - globals found: [1] ‘getOption’
[18:04:39.699] Searching for globals ... DONE
[18:04:39.700] Resolving globals: FALSE
[18:04:39.701] 
[18:04:39.701] 
[18:04:39.701] getGlobalsAndPackages() ... DONE
[18:04:39.702] run() for ‘Future’ ...
[18:04:39.702] - state: ‘created’
[18:04:39.703] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:39.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:39.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:39.704]   - Field: ‘label’
[18:04:39.704]   - Field: ‘local’
[18:04:39.705]   - Field: ‘owner’
[18:04:39.705]   - Field: ‘envir’
[18:04:39.705]   - Field: ‘packages’
[18:04:39.705]   - Field: ‘gc’
[18:04:39.705]   - Field: ‘conditions’
[18:04:39.706]   - Field: ‘expr’
[18:04:39.706]   - Field: ‘uuid’
[18:04:39.706]   - Field: ‘seed’
[18:04:39.706]   - Field: ‘version’
[18:04:39.706]   - Field: ‘result’
[18:04:39.707]   - Field: ‘asynchronous’
[18:04:39.707]   - Field: ‘calls’
[18:04:39.707]   - Field: ‘globals’
[18:04:39.707]   - Field: ‘stdout’
[18:04:39.707]   - Field: ‘earlySignal’
[18:04:39.708]   - Field: ‘lazy’
[18:04:39.708]   - Field: ‘state’
[18:04:39.708] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:39.708] - Launch lazy future ...
[18:04:39.710] Packages needed by the future expression (n = 0): <none>
[18:04:39.710] Packages needed by future strategies (n = 0): <none>
[18:04:39.711] {
[18:04:39.711]     {
[18:04:39.711]         {
[18:04:39.711]             ...future.startTime <- base::Sys.time()
[18:04:39.711]             {
[18:04:39.711]                 {
[18:04:39.711]                   {
[18:04:39.711]                     base::local({
[18:04:39.711]                       has_future <- base::requireNamespace("future", 
[18:04:39.711]                         quietly = TRUE)
[18:04:39.711]                       if (has_future) {
[18:04:39.711]                         ns <- base::getNamespace("future")
[18:04:39.711]                         version <- ns[[".package"]][["version"]]
[18:04:39.711]                         if (is.null(version)) 
[18:04:39.711]                           version <- utils::packageVersion("future")
[18:04:39.711]                       }
[18:04:39.711]                       else {
[18:04:39.711]                         version <- NULL
[18:04:39.711]                       }
[18:04:39.711]                       if (!has_future || version < "1.8.0") {
[18:04:39.711]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:39.711]                           "", base::R.version$version.string), 
[18:04:39.711]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:39.711]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:39.711]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:39.711]                             "release", "version")], collapse = " "), 
[18:04:39.711]                           hostname = base::Sys.info()[["nodename"]])
[18:04:39.711]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:39.711]                           info)
[18:04:39.711]                         info <- base::paste(info, collapse = "; ")
[18:04:39.711]                         if (!has_future) {
[18:04:39.711]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:39.711]                             info)
[18:04:39.711]                         }
[18:04:39.711]                         else {
[18:04:39.711]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:39.711]                             info, version)
[18:04:39.711]                         }
[18:04:39.711]                         base::stop(msg)
[18:04:39.711]                       }
[18:04:39.711]                     })
[18:04:39.711]                   }
[18:04:39.711]                   ...future.strategy.old <- future::plan("list")
[18:04:39.711]                   options(future.plan = NULL)
[18:04:39.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:39.711]                 }
[18:04:39.711]                 ...future.workdir <- getwd()
[18:04:39.711]             }
[18:04:39.711]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:39.711]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:39.711]         }
[18:04:39.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:39.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:39.711]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:39.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:39.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:39.711]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:39.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:39.711]             base::names(...future.oldOptions))
[18:04:39.711]     }
[18:04:39.711]     if (FALSE) {
[18:04:39.711]     }
[18:04:39.711]     else {
[18:04:39.711]         if (TRUE) {
[18:04:39.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:39.711]                 open = "w")
[18:04:39.711]         }
[18:04:39.711]         else {
[18:04:39.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:39.711]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:39.711]         }
[18:04:39.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:39.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:39.711]             base::sink(type = "output", split = FALSE)
[18:04:39.711]             base::close(...future.stdout)
[18:04:39.711]         }, add = TRUE)
[18:04:39.711]     }
[18:04:39.711]     ...future.frame <- base::sys.nframe()
[18:04:39.711]     ...future.conditions <- base::list()
[18:04:39.711]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:39.711]     if (FALSE) {
[18:04:39.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:39.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:39.711]     }
[18:04:39.711]     ...future.result <- base::tryCatch({
[18:04:39.711]         base::withCallingHandlers({
[18:04:39.711]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[18:04:39.711]             future::FutureResult(value = ...future.value$value, 
[18:04:39.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.711]                   ...future.rng), globalenv = if (FALSE) 
[18:04:39.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:39.711]                     ...future.globalenv.names))
[18:04:39.711]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:39.711]         }, condition = base::local({
[18:04:39.711]             c <- base::c
[18:04:39.711]             inherits <- base::inherits
[18:04:39.711]             invokeRestart <- base::invokeRestart
[18:04:39.711]             length <- base::length
[18:04:39.711]             list <- base::list
[18:04:39.711]             seq.int <- base::seq.int
[18:04:39.711]             signalCondition <- base::signalCondition
[18:04:39.711]             sys.calls <- base::sys.calls
[18:04:39.711]             `[[` <- base::`[[`
[18:04:39.711]             `+` <- base::`+`
[18:04:39.711]             `<<-` <- base::`<<-`
[18:04:39.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:39.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:39.711]                   3L)]
[18:04:39.711]             }
[18:04:39.711]             function(cond) {
[18:04:39.711]                 is_error <- inherits(cond, "error")
[18:04:39.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:39.711]                   NULL)
[18:04:39.711]                 if (is_error) {
[18:04:39.711]                   sessionInformation <- function() {
[18:04:39.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:39.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:39.711]                       search = base::search(), system = base::Sys.info())
[18:04:39.711]                   }
[18:04:39.711]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:39.711]                     cond$call), session = sessionInformation(), 
[18:04:39.711]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:39.711]                   signalCondition(cond)
[18:04:39.711]                 }
[18:04:39.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:39.711]                 "immediateCondition"))) {
[18:04:39.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:39.711]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:39.711]                   if (TRUE && !signal) {
[18:04:39.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.711]                     {
[18:04:39.711]                       inherits <- base::inherits
[18:04:39.711]                       invokeRestart <- base::invokeRestart
[18:04:39.711]                       is.null <- base::is.null
[18:04:39.711]                       muffled <- FALSE
[18:04:39.711]                       if (inherits(cond, "message")) {
[18:04:39.711]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.711]                         if (muffled) 
[18:04:39.711]                           invokeRestart("muffleMessage")
[18:04:39.711]                       }
[18:04:39.711]                       else if (inherits(cond, "warning")) {
[18:04:39.711]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.711]                         if (muffled) 
[18:04:39.711]                           invokeRestart("muffleWarning")
[18:04:39.711]                       }
[18:04:39.711]                       else if (inherits(cond, "condition")) {
[18:04:39.711]                         if (!is.null(pattern)) {
[18:04:39.711]                           computeRestarts <- base::computeRestarts
[18:04:39.711]                           grepl <- base::grepl
[18:04:39.711]                           restarts <- computeRestarts(cond)
[18:04:39.711]                           for (restart in restarts) {
[18:04:39.711]                             name <- restart$name
[18:04:39.711]                             if (is.null(name)) 
[18:04:39.711]                               next
[18:04:39.711]                             if (!grepl(pattern, name)) 
[18:04:39.711]                               next
[18:04:39.711]                             invokeRestart(restart)
[18:04:39.711]                             muffled <- TRUE
[18:04:39.711]                             break
[18:04:39.711]                           }
[18:04:39.711]                         }
[18:04:39.711]                       }
[18:04:39.711]                       invisible(muffled)
[18:04:39.711]                     }
[18:04:39.711]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.711]                   }
[18:04:39.711]                 }
[18:04:39.711]                 else {
[18:04:39.711]                   if (TRUE) {
[18:04:39.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.711]                     {
[18:04:39.711]                       inherits <- base::inherits
[18:04:39.711]                       invokeRestart <- base::invokeRestart
[18:04:39.711]                       is.null <- base::is.null
[18:04:39.711]                       muffled <- FALSE
[18:04:39.711]                       if (inherits(cond, "message")) {
[18:04:39.711]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.711]                         if (muffled) 
[18:04:39.711]                           invokeRestart("muffleMessage")
[18:04:39.711]                       }
[18:04:39.711]                       else if (inherits(cond, "warning")) {
[18:04:39.711]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.711]                         if (muffled) 
[18:04:39.711]                           invokeRestart("muffleWarning")
[18:04:39.711]                       }
[18:04:39.711]                       else if (inherits(cond, "condition")) {
[18:04:39.711]                         if (!is.null(pattern)) {
[18:04:39.711]                           computeRestarts <- base::computeRestarts
[18:04:39.711]                           grepl <- base::grepl
[18:04:39.711]                           restarts <- computeRestarts(cond)
[18:04:39.711]                           for (restart in restarts) {
[18:04:39.711]                             name <- restart$name
[18:04:39.711]                             if (is.null(name)) 
[18:04:39.711]                               next
[18:04:39.711]                             if (!grepl(pattern, name)) 
[18:04:39.711]                               next
[18:04:39.711]                             invokeRestart(restart)
[18:04:39.711]                             muffled <- TRUE
[18:04:39.711]                             break
[18:04:39.711]                           }
[18:04:39.711]                         }
[18:04:39.711]                       }
[18:04:39.711]                       invisible(muffled)
[18:04:39.711]                     }
[18:04:39.711]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.711]                   }
[18:04:39.711]                 }
[18:04:39.711]             }
[18:04:39.711]         }))
[18:04:39.711]     }, error = function(ex) {
[18:04:39.711]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:39.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.711]                 ...future.rng), started = ...future.startTime, 
[18:04:39.711]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:39.711]             version = "1.8"), class = "FutureResult")
[18:04:39.711]     }, finally = {
[18:04:39.711]         if (!identical(...future.workdir, getwd())) 
[18:04:39.711]             setwd(...future.workdir)
[18:04:39.711]         {
[18:04:39.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:39.711]                 ...future.oldOptions$nwarnings <- NULL
[18:04:39.711]             }
[18:04:39.711]             base::options(...future.oldOptions)
[18:04:39.711]             if (.Platform$OS.type == "windows") {
[18:04:39.711]                 old_names <- names(...future.oldEnvVars)
[18:04:39.711]                 envs <- base::Sys.getenv()
[18:04:39.711]                 names <- names(envs)
[18:04:39.711]                 common <- intersect(names, old_names)
[18:04:39.711]                 added <- setdiff(names, old_names)
[18:04:39.711]                 removed <- setdiff(old_names, names)
[18:04:39.711]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:39.711]                   envs[common]]
[18:04:39.711]                 NAMES <- toupper(changed)
[18:04:39.711]                 args <- list()
[18:04:39.711]                 for (kk in seq_along(NAMES)) {
[18:04:39.711]                   name <- changed[[kk]]
[18:04:39.711]                   NAME <- NAMES[[kk]]
[18:04:39.711]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.711]                     next
[18:04:39.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.711]                 }
[18:04:39.711]                 NAMES <- toupper(added)
[18:04:39.711]                 for (kk in seq_along(NAMES)) {
[18:04:39.711]                   name <- added[[kk]]
[18:04:39.711]                   NAME <- NAMES[[kk]]
[18:04:39.711]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.711]                     next
[18:04:39.711]                   args[[name]] <- ""
[18:04:39.711]                 }
[18:04:39.711]                 NAMES <- toupper(removed)
[18:04:39.711]                 for (kk in seq_along(NAMES)) {
[18:04:39.711]                   name <- removed[[kk]]
[18:04:39.711]                   NAME <- NAMES[[kk]]
[18:04:39.711]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.711]                     next
[18:04:39.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.711]                 }
[18:04:39.711]                 if (length(args) > 0) 
[18:04:39.711]                   base::do.call(base::Sys.setenv, args = args)
[18:04:39.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:39.711]             }
[18:04:39.711]             else {
[18:04:39.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:39.711]             }
[18:04:39.711]             {
[18:04:39.711]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:39.711]                   0L) {
[18:04:39.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:39.711]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:39.711]                   base::options(opts)
[18:04:39.711]                 }
[18:04:39.711]                 {
[18:04:39.711]                   {
[18:04:39.711]                     NULL
[18:04:39.711]                     RNGkind("Mersenne-Twister")
[18:04:39.711]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:39.711]                       inherits = FALSE)
[18:04:39.711]                   }
[18:04:39.711]                   options(future.plan = NULL)
[18:04:39.711]                   if (is.na(NA_character_)) 
[18:04:39.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:39.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:39.711]                     .init = FALSE)
[18:04:39.711]                 }
[18:04:39.711]             }
[18:04:39.711]         }
[18:04:39.711]     })
[18:04:39.711]     if (TRUE) {
[18:04:39.711]         base::sink(type = "output", split = FALSE)
[18:04:39.711]         if (TRUE) {
[18:04:39.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:39.711]         }
[18:04:39.711]         else {
[18:04:39.711]             ...future.result["stdout"] <- base::list(NULL)
[18:04:39.711]         }
[18:04:39.711]         base::close(...future.stdout)
[18:04:39.711]         ...future.stdout <- NULL
[18:04:39.711]     }
[18:04:39.711]     ...future.result$conditions <- ...future.conditions
[18:04:39.711]     ...future.result$finished <- base::Sys.time()
[18:04:39.711]     ...future.result
[18:04:39.711] }
[18:04:39.715] plan(): Setting new future strategy stack:
[18:04:39.716] List of future strategies:
[18:04:39.716] 1. sequential:
[18:04:39.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.716]    - tweaked: FALSE
[18:04:39.716]    - call: NULL
[18:04:39.717] plan(): nbrOfWorkers() = 1
[18:04:39.719] plan(): Setting new future strategy stack:
[18:04:39.719] List of future strategies:
[18:04:39.719] 1. sequential:
[18:04:39.719]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.719]    - tweaked: FALSE
[18:04:39.719]    - call: plan(strategy)
[18:04:39.720] plan(): nbrOfWorkers() = 1
[18:04:39.721] SequentialFuture started (and completed)
[18:04:39.721] - Launch lazy future ... done
[18:04:39.722] run() for ‘SequentialFuture’ ... done
[18:04:39.723] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:39.724] Searching for globals...
[18:04:39.725] - globals found: [1] ‘getOption’
[18:04:39.725] Searching for globals ... DONE
[18:04:39.725] Resolving globals: FALSE
[18:04:39.726] 
[18:04:39.726] 
[18:04:39.726] getGlobalsAndPackages() ... DONE
[18:04:39.727] run() for ‘Future’ ...
[18:04:39.727] - state: ‘created’
[18:04:39.727] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:39.728] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:39.728] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:39.728]   - Field: ‘label’
[18:04:39.728]   - Field: ‘local’
[18:04:39.729]   - Field: ‘owner’
[18:04:39.729]   - Field: ‘envir’
[18:04:39.729]   - Field: ‘packages’
[18:04:39.729]   - Field: ‘gc’
[18:04:39.730]   - Field: ‘conditions’
[18:04:39.730]   - Field: ‘expr’
[18:04:39.730]   - Field: ‘uuid’
[18:04:39.730]   - Field: ‘seed’
[18:04:39.730]   - Field: ‘version’
[18:04:39.730]   - Field: ‘result’
[18:04:39.731]   - Field: ‘asynchronous’
[18:04:39.731]   - Field: ‘calls’
[18:04:39.731]   - Field: ‘globals’
[18:04:39.731]   - Field: ‘stdout’
[18:04:39.731]   - Field: ‘earlySignal’
[18:04:39.732]   - Field: ‘lazy’
[18:04:39.732]   - Field: ‘state’
[18:04:39.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:39.732] - Launch lazy future ...
[18:04:39.733] Packages needed by the future expression (n = 0): <none>
[18:04:39.733] Packages needed by future strategies (n = 0): <none>
[18:04:39.734] {
[18:04:39.734]     {
[18:04:39.734]         {
[18:04:39.734]             ...future.startTime <- base::Sys.time()
[18:04:39.734]             {
[18:04:39.734]                 {
[18:04:39.734]                   {
[18:04:39.734]                     base::local({
[18:04:39.734]                       has_future <- base::requireNamespace("future", 
[18:04:39.734]                         quietly = TRUE)
[18:04:39.734]                       if (has_future) {
[18:04:39.734]                         ns <- base::getNamespace("future")
[18:04:39.734]                         version <- ns[[".package"]][["version"]]
[18:04:39.734]                         if (is.null(version)) 
[18:04:39.734]                           version <- utils::packageVersion("future")
[18:04:39.734]                       }
[18:04:39.734]                       else {
[18:04:39.734]                         version <- NULL
[18:04:39.734]                       }
[18:04:39.734]                       if (!has_future || version < "1.8.0") {
[18:04:39.734]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:39.734]                           "", base::R.version$version.string), 
[18:04:39.734]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:39.734]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:39.734]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:39.734]                             "release", "version")], collapse = " "), 
[18:04:39.734]                           hostname = base::Sys.info()[["nodename"]])
[18:04:39.734]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:39.734]                           info)
[18:04:39.734]                         info <- base::paste(info, collapse = "; ")
[18:04:39.734]                         if (!has_future) {
[18:04:39.734]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:39.734]                             info)
[18:04:39.734]                         }
[18:04:39.734]                         else {
[18:04:39.734]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:39.734]                             info, version)
[18:04:39.734]                         }
[18:04:39.734]                         base::stop(msg)
[18:04:39.734]                       }
[18:04:39.734]                     })
[18:04:39.734]                   }
[18:04:39.734]                   ...future.strategy.old <- future::plan("list")
[18:04:39.734]                   options(future.plan = NULL)
[18:04:39.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:39.734]                 }
[18:04:39.734]                 ...future.workdir <- getwd()
[18:04:39.734]             }
[18:04:39.734]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:39.734]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:39.734]         }
[18:04:39.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:39.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:39.734]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:39.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:39.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:39.734]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:39.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:39.734]             base::names(...future.oldOptions))
[18:04:39.734]     }
[18:04:39.734]     if (FALSE) {
[18:04:39.734]     }
[18:04:39.734]     else {
[18:04:39.734]         if (TRUE) {
[18:04:39.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:39.734]                 open = "w")
[18:04:39.734]         }
[18:04:39.734]         else {
[18:04:39.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:39.734]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:39.734]         }
[18:04:39.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:39.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:39.734]             base::sink(type = "output", split = FALSE)
[18:04:39.734]             base::close(...future.stdout)
[18:04:39.734]         }, add = TRUE)
[18:04:39.734]     }
[18:04:39.734]     ...future.frame <- base::sys.nframe()
[18:04:39.734]     ...future.conditions <- base::list()
[18:04:39.734]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:39.734]     if (FALSE) {
[18:04:39.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:39.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:39.734]     }
[18:04:39.734]     ...future.result <- base::tryCatch({
[18:04:39.734]         base::withCallingHandlers({
[18:04:39.734]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[18:04:39.734]             future::FutureResult(value = ...future.value$value, 
[18:04:39.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.734]                   ...future.rng), globalenv = if (FALSE) 
[18:04:39.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:39.734]                     ...future.globalenv.names))
[18:04:39.734]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:39.734]         }, condition = base::local({
[18:04:39.734]             c <- base::c
[18:04:39.734]             inherits <- base::inherits
[18:04:39.734]             invokeRestart <- base::invokeRestart
[18:04:39.734]             length <- base::length
[18:04:39.734]             list <- base::list
[18:04:39.734]             seq.int <- base::seq.int
[18:04:39.734]             signalCondition <- base::signalCondition
[18:04:39.734]             sys.calls <- base::sys.calls
[18:04:39.734]             `[[` <- base::`[[`
[18:04:39.734]             `+` <- base::`+`
[18:04:39.734]             `<<-` <- base::`<<-`
[18:04:39.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:39.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:39.734]                   3L)]
[18:04:39.734]             }
[18:04:39.734]             function(cond) {
[18:04:39.734]                 is_error <- inherits(cond, "error")
[18:04:39.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:39.734]                   NULL)
[18:04:39.734]                 if (is_error) {
[18:04:39.734]                   sessionInformation <- function() {
[18:04:39.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:39.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:39.734]                       search = base::search(), system = base::Sys.info())
[18:04:39.734]                   }
[18:04:39.734]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:39.734]                     cond$call), session = sessionInformation(), 
[18:04:39.734]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:39.734]                   signalCondition(cond)
[18:04:39.734]                 }
[18:04:39.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:39.734]                 "immediateCondition"))) {
[18:04:39.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:39.734]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:39.734]                   if (TRUE && !signal) {
[18:04:39.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.734]                     {
[18:04:39.734]                       inherits <- base::inherits
[18:04:39.734]                       invokeRestart <- base::invokeRestart
[18:04:39.734]                       is.null <- base::is.null
[18:04:39.734]                       muffled <- FALSE
[18:04:39.734]                       if (inherits(cond, "message")) {
[18:04:39.734]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.734]                         if (muffled) 
[18:04:39.734]                           invokeRestart("muffleMessage")
[18:04:39.734]                       }
[18:04:39.734]                       else if (inherits(cond, "warning")) {
[18:04:39.734]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.734]                         if (muffled) 
[18:04:39.734]                           invokeRestart("muffleWarning")
[18:04:39.734]                       }
[18:04:39.734]                       else if (inherits(cond, "condition")) {
[18:04:39.734]                         if (!is.null(pattern)) {
[18:04:39.734]                           computeRestarts <- base::computeRestarts
[18:04:39.734]                           grepl <- base::grepl
[18:04:39.734]                           restarts <- computeRestarts(cond)
[18:04:39.734]                           for (restart in restarts) {
[18:04:39.734]                             name <- restart$name
[18:04:39.734]                             if (is.null(name)) 
[18:04:39.734]                               next
[18:04:39.734]                             if (!grepl(pattern, name)) 
[18:04:39.734]                               next
[18:04:39.734]                             invokeRestart(restart)
[18:04:39.734]                             muffled <- TRUE
[18:04:39.734]                             break
[18:04:39.734]                           }
[18:04:39.734]                         }
[18:04:39.734]                       }
[18:04:39.734]                       invisible(muffled)
[18:04:39.734]                     }
[18:04:39.734]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.734]                   }
[18:04:39.734]                 }
[18:04:39.734]                 else {
[18:04:39.734]                   if (TRUE) {
[18:04:39.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.734]                     {
[18:04:39.734]                       inherits <- base::inherits
[18:04:39.734]                       invokeRestart <- base::invokeRestart
[18:04:39.734]                       is.null <- base::is.null
[18:04:39.734]                       muffled <- FALSE
[18:04:39.734]                       if (inherits(cond, "message")) {
[18:04:39.734]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.734]                         if (muffled) 
[18:04:39.734]                           invokeRestart("muffleMessage")
[18:04:39.734]                       }
[18:04:39.734]                       else if (inherits(cond, "warning")) {
[18:04:39.734]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.734]                         if (muffled) 
[18:04:39.734]                           invokeRestart("muffleWarning")
[18:04:39.734]                       }
[18:04:39.734]                       else if (inherits(cond, "condition")) {
[18:04:39.734]                         if (!is.null(pattern)) {
[18:04:39.734]                           computeRestarts <- base::computeRestarts
[18:04:39.734]                           grepl <- base::grepl
[18:04:39.734]                           restarts <- computeRestarts(cond)
[18:04:39.734]                           for (restart in restarts) {
[18:04:39.734]                             name <- restart$name
[18:04:39.734]                             if (is.null(name)) 
[18:04:39.734]                               next
[18:04:39.734]                             if (!grepl(pattern, name)) 
[18:04:39.734]                               next
[18:04:39.734]                             invokeRestart(restart)
[18:04:39.734]                             muffled <- TRUE
[18:04:39.734]                             break
[18:04:39.734]                           }
[18:04:39.734]                         }
[18:04:39.734]                       }
[18:04:39.734]                       invisible(muffled)
[18:04:39.734]                     }
[18:04:39.734]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.734]                   }
[18:04:39.734]                 }
[18:04:39.734]             }
[18:04:39.734]         }))
[18:04:39.734]     }, error = function(ex) {
[18:04:39.734]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:39.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.734]                 ...future.rng), started = ...future.startTime, 
[18:04:39.734]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:39.734]             version = "1.8"), class = "FutureResult")
[18:04:39.734]     }, finally = {
[18:04:39.734]         if (!identical(...future.workdir, getwd())) 
[18:04:39.734]             setwd(...future.workdir)
[18:04:39.734]         {
[18:04:39.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:39.734]                 ...future.oldOptions$nwarnings <- NULL
[18:04:39.734]             }
[18:04:39.734]             base::options(...future.oldOptions)
[18:04:39.734]             if (.Platform$OS.type == "windows") {
[18:04:39.734]                 old_names <- names(...future.oldEnvVars)
[18:04:39.734]                 envs <- base::Sys.getenv()
[18:04:39.734]                 names <- names(envs)
[18:04:39.734]                 common <- intersect(names, old_names)
[18:04:39.734]                 added <- setdiff(names, old_names)
[18:04:39.734]                 removed <- setdiff(old_names, names)
[18:04:39.734]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:39.734]                   envs[common]]
[18:04:39.734]                 NAMES <- toupper(changed)
[18:04:39.734]                 args <- list()
[18:04:39.734]                 for (kk in seq_along(NAMES)) {
[18:04:39.734]                   name <- changed[[kk]]
[18:04:39.734]                   NAME <- NAMES[[kk]]
[18:04:39.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.734]                     next
[18:04:39.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.734]                 }
[18:04:39.734]                 NAMES <- toupper(added)
[18:04:39.734]                 for (kk in seq_along(NAMES)) {
[18:04:39.734]                   name <- added[[kk]]
[18:04:39.734]                   NAME <- NAMES[[kk]]
[18:04:39.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.734]                     next
[18:04:39.734]                   args[[name]] <- ""
[18:04:39.734]                 }
[18:04:39.734]                 NAMES <- toupper(removed)
[18:04:39.734]                 for (kk in seq_along(NAMES)) {
[18:04:39.734]                   name <- removed[[kk]]
[18:04:39.734]                   NAME <- NAMES[[kk]]
[18:04:39.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.734]                     next
[18:04:39.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.734]                 }
[18:04:39.734]                 if (length(args) > 0) 
[18:04:39.734]                   base::do.call(base::Sys.setenv, args = args)
[18:04:39.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:39.734]             }
[18:04:39.734]             else {
[18:04:39.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:39.734]             }
[18:04:39.734]             {
[18:04:39.734]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:39.734]                   0L) {
[18:04:39.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:39.734]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:39.734]                   base::options(opts)
[18:04:39.734]                 }
[18:04:39.734]                 {
[18:04:39.734]                   {
[18:04:39.734]                     NULL
[18:04:39.734]                     RNGkind("Mersenne-Twister")
[18:04:39.734]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:39.734]                       inherits = FALSE)
[18:04:39.734]                   }
[18:04:39.734]                   options(future.plan = NULL)
[18:04:39.734]                   if (is.na(NA_character_)) 
[18:04:39.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:39.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:39.734]                     .init = FALSE)
[18:04:39.734]                 }
[18:04:39.734]             }
[18:04:39.734]         }
[18:04:39.734]     })
[18:04:39.734]     if (TRUE) {
[18:04:39.734]         base::sink(type = "output", split = FALSE)
[18:04:39.734]         if (TRUE) {
[18:04:39.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:39.734]         }
[18:04:39.734]         else {
[18:04:39.734]             ...future.result["stdout"] <- base::list(NULL)
[18:04:39.734]         }
[18:04:39.734]         base::close(...future.stdout)
[18:04:39.734]         ...future.stdout <- NULL
[18:04:39.734]     }
[18:04:39.734]     ...future.result$conditions <- ...future.conditions
[18:04:39.734]     ...future.result$finished <- base::Sys.time()
[18:04:39.734]     ...future.result
[18:04:39.734] }
[18:04:39.737] plan(): Setting new future strategy stack:
[18:04:39.737] List of future strategies:
[18:04:39.737] 1. sequential:
[18:04:39.737]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.737]    - tweaked: FALSE
[18:04:39.737]    - call: NULL
[18:04:39.738] plan(): nbrOfWorkers() = 1
[18:04:39.740] plan(): Setting new future strategy stack:
[18:04:39.740] List of future strategies:
[18:04:39.740] 1. sequential:
[18:04:39.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.740]    - tweaked: FALSE
[18:04:39.740]    - call: plan(strategy)
[18:04:39.741] plan(): nbrOfWorkers() = 1
[18:04:39.741] SequentialFuture started (and completed)
[18:04:39.742] - Launch lazy future ... done
[18:04:39.742] run() for ‘SequentialFuture’ ... done
[18:04:39.742] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:39.743] Searching for globals...
[18:04:39.746] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:39.746] Searching for globals...
[18:04:39.748] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[18:04:39.748] Searching for globals ... DONE
[18:04:39.748] Resolving globals: FALSE
[18:04:39.750] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:39.751] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:39.751] - globals: [1] ‘data’
[18:04:39.752] 
[18:04:39.752] getGlobalsAndPackages() ... DONE
[18:04:39.752] run() for ‘Future’ ...
[18:04:39.752] - state: ‘created’
[18:04:39.753] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:39.753] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:39.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:39.754]   - Field: ‘label’
[18:04:39.754]   - Field: ‘local’
[18:04:39.754]   - Field: ‘owner’
[18:04:39.754]   - Field: ‘envir’
[18:04:39.754]   - Field: ‘packages’
[18:04:39.755]   - Field: ‘gc’
[18:04:39.755]   - Field: ‘conditions’
[18:04:39.755]   - Field: ‘expr’
[18:04:39.755]   - Field: ‘uuid’
[18:04:39.755]   - Field: ‘seed’
[18:04:39.756]   - Field: ‘version’
[18:04:39.756]   - Field: ‘result’
[18:04:39.756]   - Field: ‘asynchronous’
[18:04:39.760]   - Field: ‘calls’
[18:04:39.760]   - Field: ‘globals’
[18:04:39.760]   - Field: ‘stdout’
[18:04:39.760]   - Field: ‘earlySignal’
[18:04:39.761]   - Field: ‘lazy’
[18:04:39.761]   - Field: ‘state’
[18:04:39.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:39.761] - Launch lazy future ...
[18:04:39.762] Packages needed by the future expression (n = 0): <none>
[18:04:39.762] Packages needed by future strategies (n = 0): <none>
[18:04:39.763] {
[18:04:39.763]     {
[18:04:39.763]         {
[18:04:39.763]             ...future.startTime <- base::Sys.time()
[18:04:39.763]             {
[18:04:39.763]                 {
[18:04:39.763]                   {
[18:04:39.763]                     base::local({
[18:04:39.763]                       has_future <- base::requireNamespace("future", 
[18:04:39.763]                         quietly = TRUE)
[18:04:39.763]                       if (has_future) {
[18:04:39.763]                         ns <- base::getNamespace("future")
[18:04:39.763]                         version <- ns[[".package"]][["version"]]
[18:04:39.763]                         if (is.null(version)) 
[18:04:39.763]                           version <- utils::packageVersion("future")
[18:04:39.763]                       }
[18:04:39.763]                       else {
[18:04:39.763]                         version <- NULL
[18:04:39.763]                       }
[18:04:39.763]                       if (!has_future || version < "1.8.0") {
[18:04:39.763]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:39.763]                           "", base::R.version$version.string), 
[18:04:39.763]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:39.763]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:39.763]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:39.763]                             "release", "version")], collapse = " "), 
[18:04:39.763]                           hostname = base::Sys.info()[["nodename"]])
[18:04:39.763]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:39.763]                           info)
[18:04:39.763]                         info <- base::paste(info, collapse = "; ")
[18:04:39.763]                         if (!has_future) {
[18:04:39.763]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:39.763]                             info)
[18:04:39.763]                         }
[18:04:39.763]                         else {
[18:04:39.763]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:39.763]                             info, version)
[18:04:39.763]                         }
[18:04:39.763]                         base::stop(msg)
[18:04:39.763]                       }
[18:04:39.763]                     })
[18:04:39.763]                   }
[18:04:39.763]                   ...future.strategy.old <- future::plan("list")
[18:04:39.763]                   options(future.plan = NULL)
[18:04:39.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:39.763]                 }
[18:04:39.763]                 ...future.workdir <- getwd()
[18:04:39.763]             }
[18:04:39.763]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:39.763]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:39.763]         }
[18:04:39.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:39.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:39.763]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:39.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:39.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:39.763]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:39.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:39.763]             base::names(...future.oldOptions))
[18:04:39.763]     }
[18:04:39.763]     if (FALSE) {
[18:04:39.763]     }
[18:04:39.763]     else {
[18:04:39.763]         if (TRUE) {
[18:04:39.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:39.763]                 open = "w")
[18:04:39.763]         }
[18:04:39.763]         else {
[18:04:39.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:39.763]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:39.763]         }
[18:04:39.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:39.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:39.763]             base::sink(type = "output", split = FALSE)
[18:04:39.763]             base::close(...future.stdout)
[18:04:39.763]         }, add = TRUE)
[18:04:39.763]     }
[18:04:39.763]     ...future.frame <- base::sys.nframe()
[18:04:39.763]     ...future.conditions <- base::list()
[18:04:39.763]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:39.763]     if (FALSE) {
[18:04:39.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:39.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:39.763]     }
[18:04:39.763]     ...future.result <- base::tryCatch({
[18:04:39.763]         base::withCallingHandlers({
[18:04:39.763]             ...future.value <- base::withVisible(base::local(subset(data, 
[18:04:39.763]                 x < 3)$y))
[18:04:39.763]             future::FutureResult(value = ...future.value$value, 
[18:04:39.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.763]                   ...future.rng), globalenv = if (FALSE) 
[18:04:39.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:39.763]                     ...future.globalenv.names))
[18:04:39.763]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:39.763]         }, condition = base::local({
[18:04:39.763]             c <- base::c
[18:04:39.763]             inherits <- base::inherits
[18:04:39.763]             invokeRestart <- base::invokeRestart
[18:04:39.763]             length <- base::length
[18:04:39.763]             list <- base::list
[18:04:39.763]             seq.int <- base::seq.int
[18:04:39.763]             signalCondition <- base::signalCondition
[18:04:39.763]             sys.calls <- base::sys.calls
[18:04:39.763]             `[[` <- base::`[[`
[18:04:39.763]             `+` <- base::`+`
[18:04:39.763]             `<<-` <- base::`<<-`
[18:04:39.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:39.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:39.763]                   3L)]
[18:04:39.763]             }
[18:04:39.763]             function(cond) {
[18:04:39.763]                 is_error <- inherits(cond, "error")
[18:04:39.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:39.763]                   NULL)
[18:04:39.763]                 if (is_error) {
[18:04:39.763]                   sessionInformation <- function() {
[18:04:39.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:39.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:39.763]                       search = base::search(), system = base::Sys.info())
[18:04:39.763]                   }
[18:04:39.763]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:39.763]                     cond$call), session = sessionInformation(), 
[18:04:39.763]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:39.763]                   signalCondition(cond)
[18:04:39.763]                 }
[18:04:39.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:39.763]                 "immediateCondition"))) {
[18:04:39.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:39.763]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:39.763]                   if (TRUE && !signal) {
[18:04:39.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.763]                     {
[18:04:39.763]                       inherits <- base::inherits
[18:04:39.763]                       invokeRestart <- base::invokeRestart
[18:04:39.763]                       is.null <- base::is.null
[18:04:39.763]                       muffled <- FALSE
[18:04:39.763]                       if (inherits(cond, "message")) {
[18:04:39.763]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.763]                         if (muffled) 
[18:04:39.763]                           invokeRestart("muffleMessage")
[18:04:39.763]                       }
[18:04:39.763]                       else if (inherits(cond, "warning")) {
[18:04:39.763]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.763]                         if (muffled) 
[18:04:39.763]                           invokeRestart("muffleWarning")
[18:04:39.763]                       }
[18:04:39.763]                       else if (inherits(cond, "condition")) {
[18:04:39.763]                         if (!is.null(pattern)) {
[18:04:39.763]                           computeRestarts <- base::computeRestarts
[18:04:39.763]                           grepl <- base::grepl
[18:04:39.763]                           restarts <- computeRestarts(cond)
[18:04:39.763]                           for (restart in restarts) {
[18:04:39.763]                             name <- restart$name
[18:04:39.763]                             if (is.null(name)) 
[18:04:39.763]                               next
[18:04:39.763]                             if (!grepl(pattern, name)) 
[18:04:39.763]                               next
[18:04:39.763]                             invokeRestart(restart)
[18:04:39.763]                             muffled <- TRUE
[18:04:39.763]                             break
[18:04:39.763]                           }
[18:04:39.763]                         }
[18:04:39.763]                       }
[18:04:39.763]                       invisible(muffled)
[18:04:39.763]                     }
[18:04:39.763]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.763]                   }
[18:04:39.763]                 }
[18:04:39.763]                 else {
[18:04:39.763]                   if (TRUE) {
[18:04:39.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.763]                     {
[18:04:39.763]                       inherits <- base::inherits
[18:04:39.763]                       invokeRestart <- base::invokeRestart
[18:04:39.763]                       is.null <- base::is.null
[18:04:39.763]                       muffled <- FALSE
[18:04:39.763]                       if (inherits(cond, "message")) {
[18:04:39.763]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.763]                         if (muffled) 
[18:04:39.763]                           invokeRestart("muffleMessage")
[18:04:39.763]                       }
[18:04:39.763]                       else if (inherits(cond, "warning")) {
[18:04:39.763]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.763]                         if (muffled) 
[18:04:39.763]                           invokeRestart("muffleWarning")
[18:04:39.763]                       }
[18:04:39.763]                       else if (inherits(cond, "condition")) {
[18:04:39.763]                         if (!is.null(pattern)) {
[18:04:39.763]                           computeRestarts <- base::computeRestarts
[18:04:39.763]                           grepl <- base::grepl
[18:04:39.763]                           restarts <- computeRestarts(cond)
[18:04:39.763]                           for (restart in restarts) {
[18:04:39.763]                             name <- restart$name
[18:04:39.763]                             if (is.null(name)) 
[18:04:39.763]                               next
[18:04:39.763]                             if (!grepl(pattern, name)) 
[18:04:39.763]                               next
[18:04:39.763]                             invokeRestart(restart)
[18:04:39.763]                             muffled <- TRUE
[18:04:39.763]                             break
[18:04:39.763]                           }
[18:04:39.763]                         }
[18:04:39.763]                       }
[18:04:39.763]                       invisible(muffled)
[18:04:39.763]                     }
[18:04:39.763]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.763]                   }
[18:04:39.763]                 }
[18:04:39.763]             }
[18:04:39.763]         }))
[18:04:39.763]     }, error = function(ex) {
[18:04:39.763]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:39.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.763]                 ...future.rng), started = ...future.startTime, 
[18:04:39.763]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:39.763]             version = "1.8"), class = "FutureResult")
[18:04:39.763]     }, finally = {
[18:04:39.763]         if (!identical(...future.workdir, getwd())) 
[18:04:39.763]             setwd(...future.workdir)
[18:04:39.763]         {
[18:04:39.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:39.763]                 ...future.oldOptions$nwarnings <- NULL
[18:04:39.763]             }
[18:04:39.763]             base::options(...future.oldOptions)
[18:04:39.763]             if (.Platform$OS.type == "windows") {
[18:04:39.763]                 old_names <- names(...future.oldEnvVars)
[18:04:39.763]                 envs <- base::Sys.getenv()
[18:04:39.763]                 names <- names(envs)
[18:04:39.763]                 common <- intersect(names, old_names)
[18:04:39.763]                 added <- setdiff(names, old_names)
[18:04:39.763]                 removed <- setdiff(old_names, names)
[18:04:39.763]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:39.763]                   envs[common]]
[18:04:39.763]                 NAMES <- toupper(changed)
[18:04:39.763]                 args <- list()
[18:04:39.763]                 for (kk in seq_along(NAMES)) {
[18:04:39.763]                   name <- changed[[kk]]
[18:04:39.763]                   NAME <- NAMES[[kk]]
[18:04:39.763]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.763]                     next
[18:04:39.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.763]                 }
[18:04:39.763]                 NAMES <- toupper(added)
[18:04:39.763]                 for (kk in seq_along(NAMES)) {
[18:04:39.763]                   name <- added[[kk]]
[18:04:39.763]                   NAME <- NAMES[[kk]]
[18:04:39.763]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.763]                     next
[18:04:39.763]                   args[[name]] <- ""
[18:04:39.763]                 }
[18:04:39.763]                 NAMES <- toupper(removed)
[18:04:39.763]                 for (kk in seq_along(NAMES)) {
[18:04:39.763]                   name <- removed[[kk]]
[18:04:39.763]                   NAME <- NAMES[[kk]]
[18:04:39.763]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.763]                     next
[18:04:39.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.763]                 }
[18:04:39.763]                 if (length(args) > 0) 
[18:04:39.763]                   base::do.call(base::Sys.setenv, args = args)
[18:04:39.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:39.763]             }
[18:04:39.763]             else {
[18:04:39.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:39.763]             }
[18:04:39.763]             {
[18:04:39.763]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:39.763]                   0L) {
[18:04:39.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:39.763]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:39.763]                   base::options(opts)
[18:04:39.763]                 }
[18:04:39.763]                 {
[18:04:39.763]                   {
[18:04:39.763]                     NULL
[18:04:39.763]                     RNGkind("Mersenne-Twister")
[18:04:39.763]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:39.763]                       inherits = FALSE)
[18:04:39.763]                   }
[18:04:39.763]                   options(future.plan = NULL)
[18:04:39.763]                   if (is.na(NA_character_)) 
[18:04:39.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:39.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:39.763]                     .init = FALSE)
[18:04:39.763]                 }
[18:04:39.763]             }
[18:04:39.763]         }
[18:04:39.763]     })
[18:04:39.763]     if (TRUE) {
[18:04:39.763]         base::sink(type = "output", split = FALSE)
[18:04:39.763]         if (TRUE) {
[18:04:39.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:39.763]         }
[18:04:39.763]         else {
[18:04:39.763]             ...future.result["stdout"] <- base::list(NULL)
[18:04:39.763]         }
[18:04:39.763]         base::close(...future.stdout)
[18:04:39.763]         ...future.stdout <- NULL
[18:04:39.763]     }
[18:04:39.763]     ...future.result$conditions <- ...future.conditions
[18:04:39.763]     ...future.result$finished <- base::Sys.time()
[18:04:39.763]     ...future.result
[18:04:39.763] }
[18:04:39.766] assign_globals() ...
[18:04:39.766] List of 1
[18:04:39.766]  $ data:'data.frame':	5 obs. of  2 variables:
[18:04:39.766]   ..$ x: int [1:5] 1 2 3 4 5
[18:04:39.766]   ..$ y: int [1:5] 1 2 3 4 5
[18:04:39.766]  - attr(*, "where")=List of 1
[18:04:39.766]   ..$ data:<environment: R_EmptyEnv> 
[18:04:39.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:39.766]  - attr(*, "resolved")= logi FALSE
[18:04:39.766]  - attr(*, "total_size")= num 160
[18:04:39.766]  - attr(*, "already-done")= logi TRUE
[18:04:39.776] - copied ‘data’ to environment
[18:04:39.776] assign_globals() ... done
[18:04:39.777] plan(): Setting new future strategy stack:
[18:04:39.777] List of future strategies:
[18:04:39.777] 1. sequential:
[18:04:39.777]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.777]    - tweaked: FALSE
[18:04:39.777]    - call: NULL
[18:04:39.778] plan(): nbrOfWorkers() = 1
[18:04:39.779] plan(): Setting new future strategy stack:
[18:04:39.780] List of future strategies:
[18:04:39.780] 1. sequential:
[18:04:39.780]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.780]    - tweaked: FALSE
[18:04:39.780]    - call: plan(strategy)
[18:04:39.780] plan(): nbrOfWorkers() = 1
[18:04:39.781] SequentialFuture started (and completed)
[18:04:39.781] - Launch lazy future ... done
[18:04:39.781] run() for ‘SequentialFuture’ ... done
[18:04:39.782] plan(): Setting new future strategy stack:
[18:04:39.782] List of future strategies:
[18:04:39.782] 1. sequential:
[18:04:39.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.782]    - tweaked: FALSE
[18:04:39.782]    - call: plan(list(sequential, strategy))
[18:04:39.782] 2. sequential:
[18:04:39.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.782]    - tweaked: FALSE
[18:04:39.782]    - call: plan(list(sequential, strategy))
[18:04:39.783] plan(): nbrOfWorkers() = 1
[18:04:39.784] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:39.784] Searching for globals...
[18:04:39.795] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[18:04:39.795] Searching for globals ... DONE
[18:04:39.795] Resolving globals: FALSE
[18:04:39.796] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:39.797] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:39.797] - globals: [1] ‘data’
[18:04:39.798] - packages: [1] ‘future’
[18:04:39.798] getGlobalsAndPackages() ... DONE
[18:04:39.798] run() for ‘Future’ ...
[18:04:39.799] - state: ‘created’
[18:04:39.799] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:39.799] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:39.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:39.800]   - Field: ‘label’
[18:04:39.800]   - Field: ‘local’
[18:04:39.800]   - Field: ‘owner’
[18:04:39.800]   - Field: ‘envir’
[18:04:39.801]   - Field: ‘packages’
[18:04:39.801]   - Field: ‘gc’
[18:04:39.801]   - Field: ‘conditions’
[18:04:39.801]   - Field: ‘expr’
[18:04:39.801]   - Field: ‘uuid’
[18:04:39.802]   - Field: ‘seed’
[18:04:39.802]   - Field: ‘version’
[18:04:39.802]   - Field: ‘result’
[18:04:39.802]   - Field: ‘asynchronous’
[18:04:39.802]   - Field: ‘calls’
[18:04:39.803]   - Field: ‘globals’
[18:04:39.803]   - Field: ‘stdout’
[18:04:39.803]   - Field: ‘earlySignal’
[18:04:39.803]   - Field: ‘lazy’
[18:04:39.803]   - Field: ‘state’
[18:04:39.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:39.804] - Launch lazy future ...
[18:04:39.804] Packages needed by the future expression (n = 1): ‘future’
[18:04:39.804] Packages needed by future strategies (n = 1): ‘future’
[18:04:39.805] {
[18:04:39.805]     {
[18:04:39.805]         {
[18:04:39.805]             ...future.startTime <- base::Sys.time()
[18:04:39.805]             {
[18:04:39.805]                 {
[18:04:39.805]                   {
[18:04:39.805]                     {
[18:04:39.805]                       base::local({
[18:04:39.805]                         has_future <- base::requireNamespace("future", 
[18:04:39.805]                           quietly = TRUE)
[18:04:39.805]                         if (has_future) {
[18:04:39.805]                           ns <- base::getNamespace("future")
[18:04:39.805]                           version <- ns[[".package"]][["version"]]
[18:04:39.805]                           if (is.null(version)) 
[18:04:39.805]                             version <- utils::packageVersion("future")
[18:04:39.805]                         }
[18:04:39.805]                         else {
[18:04:39.805]                           version <- NULL
[18:04:39.805]                         }
[18:04:39.805]                         if (!has_future || version < "1.8.0") {
[18:04:39.805]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:39.805]                             "", base::R.version$version.string), 
[18:04:39.805]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:39.805]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:39.805]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:39.805]                               "release", "version")], collapse = " "), 
[18:04:39.805]                             hostname = base::Sys.info()[["nodename"]])
[18:04:39.805]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:39.805]                             info)
[18:04:39.805]                           info <- base::paste(info, collapse = "; ")
[18:04:39.805]                           if (!has_future) {
[18:04:39.805]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:39.805]                               info)
[18:04:39.805]                           }
[18:04:39.805]                           else {
[18:04:39.805]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:39.805]                               info, version)
[18:04:39.805]                           }
[18:04:39.805]                           base::stop(msg)
[18:04:39.805]                         }
[18:04:39.805]                       })
[18:04:39.805]                     }
[18:04:39.805]                     base::local({
[18:04:39.805]                       for (pkg in "future") {
[18:04:39.805]                         base::loadNamespace(pkg)
[18:04:39.805]                         base::library(pkg, character.only = TRUE)
[18:04:39.805]                       }
[18:04:39.805]                     })
[18:04:39.805]                   }
[18:04:39.805]                   ...future.strategy.old <- future::plan("list")
[18:04:39.805]                   options(future.plan = NULL)
[18:04:39.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.805]                   future::plan(list(function (..., envir = parent.frame()) 
[18:04:39.805]                   {
[18:04:39.805]                     future <- SequentialFuture(..., envir = envir)
[18:04:39.805]                     if (!future$lazy) 
[18:04:39.805]                       future <- run(future)
[18:04:39.805]                     invisible(future)
[18:04:39.805]                   }), .cleanup = FALSE, .init = FALSE)
[18:04:39.805]                 }
[18:04:39.805]                 ...future.workdir <- getwd()
[18:04:39.805]             }
[18:04:39.805]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:39.805]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:39.805]         }
[18:04:39.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:39.805]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:39.805]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:39.805]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:39.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:39.805]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:39.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:39.805]             base::names(...future.oldOptions))
[18:04:39.805]     }
[18:04:39.805]     if (FALSE) {
[18:04:39.805]     }
[18:04:39.805]     else {
[18:04:39.805]         if (TRUE) {
[18:04:39.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:39.805]                 open = "w")
[18:04:39.805]         }
[18:04:39.805]         else {
[18:04:39.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:39.805]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:39.805]         }
[18:04:39.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:39.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:39.805]             base::sink(type = "output", split = FALSE)
[18:04:39.805]             base::close(...future.stdout)
[18:04:39.805]         }, add = TRUE)
[18:04:39.805]     }
[18:04:39.805]     ...future.frame <- base::sys.nframe()
[18:04:39.805]     ...future.conditions <- base::list()
[18:04:39.805]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:39.805]     if (FALSE) {
[18:04:39.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:39.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:39.805]     }
[18:04:39.805]     ...future.result <- base::tryCatch({
[18:04:39.805]         base::withCallingHandlers({
[18:04:39.805]             ...future.value <- base::withVisible(base::local({
[18:04:39.805]                 a %<-% subset(data, x < 3)$y
[18:04:39.805]                 a
[18:04:39.805]             }))
[18:04:39.805]             future::FutureResult(value = ...future.value$value, 
[18:04:39.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.805]                   ...future.rng), globalenv = if (FALSE) 
[18:04:39.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:39.805]                     ...future.globalenv.names))
[18:04:39.805]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:39.805]         }, condition = base::local({
[18:04:39.805]             c <- base::c
[18:04:39.805]             inherits <- base::inherits
[18:04:39.805]             invokeRestart <- base::invokeRestart
[18:04:39.805]             length <- base::length
[18:04:39.805]             list <- base::list
[18:04:39.805]             seq.int <- base::seq.int
[18:04:39.805]             signalCondition <- base::signalCondition
[18:04:39.805]             sys.calls <- base::sys.calls
[18:04:39.805]             `[[` <- base::`[[`
[18:04:39.805]             `+` <- base::`+`
[18:04:39.805]             `<<-` <- base::`<<-`
[18:04:39.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:39.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:39.805]                   3L)]
[18:04:39.805]             }
[18:04:39.805]             function(cond) {
[18:04:39.805]                 is_error <- inherits(cond, "error")
[18:04:39.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:39.805]                   NULL)
[18:04:39.805]                 if (is_error) {
[18:04:39.805]                   sessionInformation <- function() {
[18:04:39.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:39.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:39.805]                       search = base::search(), system = base::Sys.info())
[18:04:39.805]                   }
[18:04:39.805]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:39.805]                     cond$call), session = sessionInformation(), 
[18:04:39.805]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:39.805]                   signalCondition(cond)
[18:04:39.805]                 }
[18:04:39.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:39.805]                 "immediateCondition"))) {
[18:04:39.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:39.805]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:39.805]                   if (TRUE && !signal) {
[18:04:39.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.805]                     {
[18:04:39.805]                       inherits <- base::inherits
[18:04:39.805]                       invokeRestart <- base::invokeRestart
[18:04:39.805]                       is.null <- base::is.null
[18:04:39.805]                       muffled <- FALSE
[18:04:39.805]                       if (inherits(cond, "message")) {
[18:04:39.805]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.805]                         if (muffled) 
[18:04:39.805]                           invokeRestart("muffleMessage")
[18:04:39.805]                       }
[18:04:39.805]                       else if (inherits(cond, "warning")) {
[18:04:39.805]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.805]                         if (muffled) 
[18:04:39.805]                           invokeRestart("muffleWarning")
[18:04:39.805]                       }
[18:04:39.805]                       else if (inherits(cond, "condition")) {
[18:04:39.805]                         if (!is.null(pattern)) {
[18:04:39.805]                           computeRestarts <- base::computeRestarts
[18:04:39.805]                           grepl <- base::grepl
[18:04:39.805]                           restarts <- computeRestarts(cond)
[18:04:39.805]                           for (restart in restarts) {
[18:04:39.805]                             name <- restart$name
[18:04:39.805]                             if (is.null(name)) 
[18:04:39.805]                               next
[18:04:39.805]                             if (!grepl(pattern, name)) 
[18:04:39.805]                               next
[18:04:39.805]                             invokeRestart(restart)
[18:04:39.805]                             muffled <- TRUE
[18:04:39.805]                             break
[18:04:39.805]                           }
[18:04:39.805]                         }
[18:04:39.805]                       }
[18:04:39.805]                       invisible(muffled)
[18:04:39.805]                     }
[18:04:39.805]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.805]                   }
[18:04:39.805]                 }
[18:04:39.805]                 else {
[18:04:39.805]                   if (TRUE) {
[18:04:39.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.805]                     {
[18:04:39.805]                       inherits <- base::inherits
[18:04:39.805]                       invokeRestart <- base::invokeRestart
[18:04:39.805]                       is.null <- base::is.null
[18:04:39.805]                       muffled <- FALSE
[18:04:39.805]                       if (inherits(cond, "message")) {
[18:04:39.805]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.805]                         if (muffled) 
[18:04:39.805]                           invokeRestart("muffleMessage")
[18:04:39.805]                       }
[18:04:39.805]                       else if (inherits(cond, "warning")) {
[18:04:39.805]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.805]                         if (muffled) 
[18:04:39.805]                           invokeRestart("muffleWarning")
[18:04:39.805]                       }
[18:04:39.805]                       else if (inherits(cond, "condition")) {
[18:04:39.805]                         if (!is.null(pattern)) {
[18:04:39.805]                           computeRestarts <- base::computeRestarts
[18:04:39.805]                           grepl <- base::grepl
[18:04:39.805]                           restarts <- computeRestarts(cond)
[18:04:39.805]                           for (restart in restarts) {
[18:04:39.805]                             name <- restart$name
[18:04:39.805]                             if (is.null(name)) 
[18:04:39.805]                               next
[18:04:39.805]                             if (!grepl(pattern, name)) 
[18:04:39.805]                               next
[18:04:39.805]                             invokeRestart(restart)
[18:04:39.805]                             muffled <- TRUE
[18:04:39.805]                             break
[18:04:39.805]                           }
[18:04:39.805]                         }
[18:04:39.805]                       }
[18:04:39.805]                       invisible(muffled)
[18:04:39.805]                     }
[18:04:39.805]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.805]                   }
[18:04:39.805]                 }
[18:04:39.805]             }
[18:04:39.805]         }))
[18:04:39.805]     }, error = function(ex) {
[18:04:39.805]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:39.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.805]                 ...future.rng), started = ...future.startTime, 
[18:04:39.805]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:39.805]             version = "1.8"), class = "FutureResult")
[18:04:39.805]     }, finally = {
[18:04:39.805]         if (!identical(...future.workdir, getwd())) 
[18:04:39.805]             setwd(...future.workdir)
[18:04:39.805]         {
[18:04:39.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:39.805]                 ...future.oldOptions$nwarnings <- NULL
[18:04:39.805]             }
[18:04:39.805]             base::options(...future.oldOptions)
[18:04:39.805]             if (.Platform$OS.type == "windows") {
[18:04:39.805]                 old_names <- names(...future.oldEnvVars)
[18:04:39.805]                 envs <- base::Sys.getenv()
[18:04:39.805]                 names <- names(envs)
[18:04:39.805]                 common <- intersect(names, old_names)
[18:04:39.805]                 added <- setdiff(names, old_names)
[18:04:39.805]                 removed <- setdiff(old_names, names)
[18:04:39.805]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:39.805]                   envs[common]]
[18:04:39.805]                 NAMES <- toupper(changed)
[18:04:39.805]                 args <- list()
[18:04:39.805]                 for (kk in seq_along(NAMES)) {
[18:04:39.805]                   name <- changed[[kk]]
[18:04:39.805]                   NAME <- NAMES[[kk]]
[18:04:39.805]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.805]                     next
[18:04:39.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.805]                 }
[18:04:39.805]                 NAMES <- toupper(added)
[18:04:39.805]                 for (kk in seq_along(NAMES)) {
[18:04:39.805]                   name <- added[[kk]]
[18:04:39.805]                   NAME <- NAMES[[kk]]
[18:04:39.805]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.805]                     next
[18:04:39.805]                   args[[name]] <- ""
[18:04:39.805]                 }
[18:04:39.805]                 NAMES <- toupper(removed)
[18:04:39.805]                 for (kk in seq_along(NAMES)) {
[18:04:39.805]                   name <- removed[[kk]]
[18:04:39.805]                   NAME <- NAMES[[kk]]
[18:04:39.805]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.805]                     next
[18:04:39.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.805]                 }
[18:04:39.805]                 if (length(args) > 0) 
[18:04:39.805]                   base::do.call(base::Sys.setenv, args = args)
[18:04:39.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:39.805]             }
[18:04:39.805]             else {
[18:04:39.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:39.805]             }
[18:04:39.805]             {
[18:04:39.805]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:39.805]                   0L) {
[18:04:39.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:39.805]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:39.805]                   base::options(opts)
[18:04:39.805]                 }
[18:04:39.805]                 {
[18:04:39.805]                   {
[18:04:39.805]                     NULL
[18:04:39.805]                     RNGkind("Mersenne-Twister")
[18:04:39.805]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:39.805]                       inherits = FALSE)
[18:04:39.805]                   }
[18:04:39.805]                   options(future.plan = NULL)
[18:04:39.805]                   if (is.na(NA_character_)) 
[18:04:39.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:39.805]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:39.805]                     .init = FALSE)
[18:04:39.805]                 }
[18:04:39.805]             }
[18:04:39.805]         }
[18:04:39.805]     })
[18:04:39.805]     if (TRUE) {
[18:04:39.805]         base::sink(type = "output", split = FALSE)
[18:04:39.805]         if (TRUE) {
[18:04:39.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:39.805]         }
[18:04:39.805]         else {
[18:04:39.805]             ...future.result["stdout"] <- base::list(NULL)
[18:04:39.805]         }
[18:04:39.805]         base::close(...future.stdout)
[18:04:39.805]         ...future.stdout <- NULL
[18:04:39.805]     }
[18:04:39.805]     ...future.result$conditions <- ...future.conditions
[18:04:39.805]     ...future.result$finished <- base::Sys.time()
[18:04:39.805]     ...future.result
[18:04:39.805] }
[18:04:39.809] assign_globals() ...
[18:04:39.809] List of 1
[18:04:39.809]  $ data:'data.frame':	5 obs. of  2 variables:
[18:04:39.809]   ..$ x: int [1:5] 1 2 3 4 5
[18:04:39.809]   ..$ y: int [1:5] 1 2 3 4 5
[18:04:39.809]  - attr(*, "where")=List of 1
[18:04:39.809]   ..$ data:<environment: R_EmptyEnv> 
[18:04:39.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:39.809]  - attr(*, "resolved")= logi FALSE
[18:04:39.809]  - attr(*, "total_size")= num 160
[18:04:39.809]  - attr(*, "already-done")= logi TRUE
[18:04:39.815] - copied ‘data’ to environment
[18:04:39.815] assign_globals() ... done
[18:04:39.816] plan(): Setting new future strategy stack:
[18:04:39.816] List of future strategies:
[18:04:39.816] 1. sequential:
[18:04:39.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.816]    - tweaked: FALSE
[18:04:39.816]    - call: plan(list(sequential, strategy))
[18:04:39.817] plan(): nbrOfWorkers() = 1
[18:04:39.882] plan(): Setting new future strategy stack:
[18:04:39.882] List of future strategies:
[18:04:39.882] 1. sequential:
[18:04:39.882]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.882]    - tweaked: FALSE
[18:04:39.882]    - call: plan(list(sequential, strategy))
[18:04:39.882] 2. sequential:
[18:04:39.882]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.882]    - tweaked: FALSE
[18:04:39.882]    - call: plan(list(sequential, strategy))
[18:04:39.884] plan(): nbrOfWorkers() = 1
[18:04:39.884] SequentialFuture started (and completed)
[18:04:39.884] signalConditions() ...
[18:04:39.884]  - include = ‘immediateCondition’
[18:04:39.885]  - exclude = 
[18:04:39.885]  - resignal = FALSE
[18:04:39.885]  - Number of conditions: 53
[18:04:39.885] signalConditions() ... done
[18:04:39.885] - Launch lazy future ... done
[18:04:39.886] run() for ‘SequentialFuture’ ... done
[18:04:39.886] signalConditions() ...
[18:04:39.886]  - include = ‘immediateCondition’
[18:04:39.886]  - exclude = 
[18:04:39.886]  - resignal = FALSE
[18:04:39.887]  - Number of conditions: 53
[18:04:39.887] signalConditions() ... done
[18:04:39.887] Future state: ‘finished’
[18:04:39.887] signalConditions() ...
[18:04:39.888]  - include = ‘condition’
[18:04:39.888]  - exclude = ‘immediateCondition’
[18:04:39.888]  - resignal = TRUE
[18:04:39.888]  - Number of conditions: 53
[18:04:39.888]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.818] getGlobalsAndPackages() ...
[18:04:39.889]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:39.889]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.850] Searching for globals...
[18:04:39.889]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.852] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[18:04:39.889]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.852] Searching for globals ... DONE
[18:04:39.890]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.853] Resolving globals: FALSE
[18:04:39.890]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.854] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:39.890]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.854] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:39.891]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.855] - globals: [1] ‘data’
[18:04:39.891]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.855] 
[18:04:39.891]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.855] getGlobalsAndPackages() ... DONE
[18:04:39.891]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.856] run() for ‘Future’ ...
[18:04:39.892]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.856] - state: ‘created’
[18:04:39.892]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.856] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:39.892]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.857] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:39.892]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.857] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:39.893]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.857]   - Field: ‘label’
[18:04:39.893]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.857]   - Field: ‘local’
[18:04:39.893]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.858]   - Field: ‘owner’
[18:04:39.894]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.858]   - Field: ‘envir’
[18:04:39.894]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.858]   - Field: ‘packages’
[18:04:39.894]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.858]   - Field: ‘gc’
[18:04:39.894]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.859]   - Field: ‘conditions’
[18:04:39.895]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.859]   - Field: ‘expr’
[18:04:39.895]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.859]   - Field: ‘uuid’
[18:04:39.895]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.859]   - Field: ‘seed’
[18:04:39.896]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.860]   - Field: ‘version’
[18:04:39.896]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.860]   - Field: ‘result’
[18:04:39.896]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.860]   - Field: ‘asynchronous’
[18:04:39.896]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.860]   - Field: ‘calls’
[18:04:39.897]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.860]   - Field: ‘globals’
[18:04:39.897]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.861]   - Field: ‘stdout’
[18:04:39.897]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.861]   - Field: ‘earlySignal’
[18:04:39.897]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.861]   - Field: ‘lazy’
[18:04:39.898]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.861]   - Field: ‘state’
[18:04:39.898]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:39.898]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.862] - Launch lazy future ...
[18:04:39.899]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.862] Packages needed by the future expression (n = 0): <none>
[18:04:39.899]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.863] Packages needed by future strategies (n = 0): <none>
[18:04:39.899]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.863] {
[18:04:39.863]     {
[18:04:39.863]         {
[18:04:39.863]             ...future.startTime <- base::Sys.time()
[18:04:39.863]             {
[18:04:39.863]                 {
[18:04:39.863]                   {
[18:04:39.863]                     base::local({
[18:04:39.863]                       has_future <- base::requireNamespace("future", 
[18:04:39.863]                         quietly = TRUE)
[18:04:39.863]                       if (has_future) {
[18:04:39.863]                         ns <- base::getNamespace("future")
[18:04:39.863]                         version <- ns[[".package"]][["version"]]
[18:04:39.863]                         if (is.null(version)) 
[18:04:39.863]                           version <- utils::packageVersion("future")
[18:04:39.863]                       }
[18:04:39.863]                       else {
[18:04:39.863]                         version <- NULL
[18:04:39.863]                       }
[18:04:39.863]                       if (!has_future || version < "1.8.0") {
[18:04:39.863]                         info <- base::c(r_version = base::gsub("R version ", 
[18:04:39.863]                           "", base::R.version$version.string), 
[18:04:39.863]                           platform = base::sprintf("%s (%s-bit)", 
[18:04:39.863]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:39.863]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:39.863]                             "release", "version")], collapse = " "), 
[18:04:39.863]                           hostname = base::Sys.info()[["nodename"]])
[18:04:39.863]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:04:39.863]                           info)
[18:04:39.863]                         info <- base::paste(info, collapse = "; ")
[18:04:39.863]                         if (!has_future) {
[18:04:39.863]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:39.863]                             info)
[18:04:39.863]                         }
[18:04:39.863]                         else {
[18:04:39.863]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:39.863]                             info, version)
[18:04:39.863]                         }
[18:04:39.863]                         base::stop(msg)
[18:04:39.863]                       }
[18:04:39.863]                     })
[18:04:39.863]                   }
[18:04:39.863]                   ...future.strategy.old <- future::plan("list")
[18:04:39.863]                   options(future.plan = NULL)
[18:04:39.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:39.863]                 }
[18:04:39.863]                 ...future.workdir <- getwd()
[18:04:39.863]             }
[18:04:39.863]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:39.863]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:39.863]         }
[18:04:39.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:39.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:39.863]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:39.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:39.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:39.863]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:39.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:39.863]             base::names(...future.oldOptions))
[18:04:39.863]     }
[18:04:39.863]     if (FALSE) {
[18:04:39.863]     }
[18:04:39.863]     else {
[18:04:39.863]         if (TRUE) {
[18:04:39.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:39.863]                 open = "w")
[18:04:39.863]         }
[18:04:39.863]         else {
[18:04:39.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:39.863]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:39.863]         }
[18:04:39.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:39.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:39.863]             base::sink(type = "output", split = FALSE)
[18:04:39.863]             base::close(...future.stdout)
[18:04:39.863]         }, add = TRUE)
[18:04:39.863]     }
[18:04:39.863]     ...future.frame <- base::sys.nframe()
[18:04:39.863]     ...future.conditions <- base::list()
[18:04:39.863]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:39.863]     if (FALSE) {
[18:04:39.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:39.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:39.863]     }
[18:04:39.863]     ...future.result <- base::tryCatch({
[18:04:39.863]         base::withCallingHandlers({
[18:04:39.863]             ...future.value <- base::withVisible(base::local(subset(data, 
[18:04:39.863]                 x < 3)$y))
[18:04:39.863]             future::FutureResult(value = ...future.value$value, 
[18:04:39.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.863]                   ...future.rng), globalenv = if (FALSE) 
[18:04:39.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:39.863]                     ...future.globalenv.names))
[18:04:39.863]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:39.863]         }, condition = base::local({
[18:04:39.863]             c <- base::c
[18:04:39.863]             inherits <- base::inherits
[18:04:39.863]             invokeRestart <- base::invokeRestart
[18:04:39.863]             length <- base::length
[18:04:39.863]             list <- base::list
[18:04:39.863]             seq.int <- base::seq.int
[18:04:39.863]             signalCondition <- base::signalCondition
[18:04:39.863]             sys.calls <- base::sys.calls
[18:04:39.863]             `[[` <- base::`[[`
[18:04:39.863]             `+` <- base::`+`
[18:04:39.863]             `<<-` <- base::`<<-`
[18:04:39.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:39.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:39.863]                   3L)]
[18:04:39.863]             }
[18:04:39.863]             function(cond) {
[18:04:39.863]                 is_error <- inherits(cond, "error")
[18:04:39.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:39.863]                   NULL)
[18:04:39.863]                 if (is_error) {
[18:04:39.863]                   sessionInformation <- function() {
[18:04:39.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:39.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:39.863]                       search = base::search(), system = base::Sys.info())
[18:04:39.863]                   }
[18:04:39.863]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:39.863]                     cond$call), session = sessionInformation(), 
[18:04:39.863]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:39.863]                   signalCondition(cond)
[18:04:39.863]                 }
[18:04:39.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:39.863]                 "immediateCondition"))) {
[18:04:39.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:39.863]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:39.863]                   if (TRUE && !signal) {
[18:04:39.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.863]                     {
[18:04:39.863]                       inherits <- base::inherits
[18:04:39.863]                       invokeRestart <- base::invokeRestart
[18:04:39.863]                       is.null <- base::is.null
[18:04:39.863]                       muffled <- FALSE
[18:04:39.863]                       if (inherits(cond, "message")) {
[18:04:39.863]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.863]                         if (muffled) 
[18:04:39.863]                           invokeRestart("muffleMessage")
[18:04:39.863]                       }
[18:04:39.863]                       else if (inherits(cond, "warning")) {
[18:04:39.863]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.863]                         if (muffled) 
[18:04:39.863]                           invokeRestart("muffleWarning")
[18:04:39.863]                       }
[18:04:39.863]                       else if (inherits(cond, "condition")) {
[18:04:39.863]                         if (!is.null(pattern)) {
[18:04:39.863]                           computeRestarts <- base::computeRestarts
[18:04:39.863]                           grepl <- base::grepl
[18:04:39.863]                           restarts <- computeRestarts(cond)
[18:04:39.863]                           for (restart in restarts) {
[18:04:39.863]                             name <- restart$name
[18:04:39.863]                             if (is.null(name)) 
[18:04:39.863]                               next
[18:04:39.863]                             if (!grepl(pattern, name)) 
[18:04:39.863]                               next
[18:04:39.863]                             invokeRestart(restart)
[18:04:39.863]                             muffled <- TRUE
[18:04:39.863]                             break
[18:04:39.863]                           }
[18:04:39.863]                         }
[18:04:39.863]                       }
[18:04:39.863]                       invisible(muffled)
[18:04:39.863]                     }
[18:04:39.863]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.863]                   }
[18:04:39.863]                 }
[18:04:39.863]                 else {
[18:04:39.863]                   if (TRUE) {
[18:04:39.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.863]                     {
[18:04:39.863]                       inherits <- base::inherits
[18:04:39.863]                       invokeRestart <- base::invokeRestart
[18:04:39.863]                       is.null <- base::is.null
[18:04:39.863]                       muffled <- FALSE
[18:04:39.863]                       if (inherits(cond, "message")) {
[18:04:39.863]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.863]                         if (muffled) 
[18:04:39.863]                           invokeRestart("muffleMessage")
[18:04:39.863]                       }
[18:04:39.863]                       else if (inherits(cond, "warning")) {
[18:04:39.863]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.863]                         if (muffled) 
[18:04:39.863]                           invokeRestart("muffleWarning")
[18:04:39.863]                       }
[18:04:39.863]                       else if (inherits(cond, "condition")) {
[18:04:39.863]                         if (!is.null(pattern)) {
[18:04:39.863]                           computeRestarts <- base::computeRestarts
[18:04:39.863]                           grepl <- base::grepl
[18:04:39.863]                           restarts <- computeRestarts(cond)
[18:04:39.863]                           for (restart in restarts) {
[18:04:39.863]                             name <- restart$name
[18:04:39.863]                             if (is.null(name)) 
[18:04:39.863]                               next
[18:04:39.863]                             if (!grepl(pattern, name)) 
[18:04:39.863]                               next
[18:04:39.863]                             invokeRestart(restart)
[18:04:39.863]                             muffled <- TRUE
[18:04:39.863]                             break
[18:04:39.863]                           }
[18:04:39.863]                         }
[18:04:39.863]                       }
[18:04:39.863]                       invisible(muffled)
[18:04:39.863]                     }
[18:04:39.863]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.863]                   }
[18:04:39.863]                 }
[18:04:39.863]             }
[18:04:39.863]         }))
[18:04:39.863]     }, error = function(ex) {
[18:04:39.863]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:39.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.863]                 ...future.rng), started = ...future.startTime, 
[18:04:39.863]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:39.863]             version = "1.8"), class = "FutureResult")
[18:04:39.863]     }, finally = {
[18:04:39.863]         if (!identical(...future.workdir, getwd())) 
[18:04:39.863]             setwd(...future.workdir)
[18:04:39.863]         {
[18:04:39.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:39.863]                 ...future.oldOptions$nwarnings <- NULL
[18:04:39.863]             }
[18:04:39.863]             base::options(...future.oldOptions)
[18:04:39.863]             if (.Platform$OS.type == "windows") {
[18:04:39.863]                 old_names <- names(...future.oldEnvVars)
[18:04:39.863]                 envs <- base::Sys.getenv()
[18:04:39.863]                 names <- names(envs)
[18:04:39.863]                 common <- intersect(names, old_names)
[18:04:39.863]                 added <- setdiff(names, old_names)
[18:04:39.863]                 removed <- setdiff(old_names, names)
[18:04:39.863]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:39.863]                   envs[common]]
[18:04:39.863]                 NAMES <- toupper(changed)
[18:04:39.863]                 args <- list()
[18:04:39.863]                 for (kk in seq_along(NAMES)) {
[18:04:39.863]                   name <- changed[[kk]]
[18:04:39.863]                   NAME <- NAMES[[kk]]
[18:04:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.863]                     next
[18:04:39.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.863]                 }
[18:04:39.863]                 NAMES <- toupper(added)
[18:04:39.863]                 for (kk in seq_along(NAMES)) {
[18:04:39.863]                   name <- added[[kk]]
[18:04:39.863]                   NAME <- NAMES[[kk]]
[18:04:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.863]                     next
[18:04:39.863]                   args[[name]] <- ""
[18:04:39.863]                 }
[18:04:39.863]                 NAMES <- toupper(removed)
[18:04:39.863]                 for (kk in seq_along(NAMES)) {
[18:04:39.863]                   name <- removed[[kk]]
[18:04:39.863]                   NAME <- NAMES[[kk]]
[18:04:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.863]                     next
[18:04:39.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.863]                 }
[18:04:39.863]                 if (length(args) > 0) 
[18:04:39.863]                   base::do.call(base::Sys.setenv, args = args)
[18:04:39.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:39.863]             }
[18:04:39.863]             else {
[18:04:39.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:39.863]             }
[18:04:39.863]             {
[18:04:39.863]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:39.863]                   0L) {
[18:04:39.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:39.863]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:39.863]                   base::options(opts)
[18:04:39.863]                 }
[18:04:39.863]                 {
[18:04:39.863]                   {
[18:04:39.863]                     NULL
[18:04:39.863]                     RNGkind("Mersenne-Twister")
[18:04:39.863]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:39.863]                       inherits = FALSE)
[18:04:39.863]                   }
[18:04:39.863]                   options(future.plan = NULL)
[18:04:39.863]                   if (is.na(NA_character_)) 
[18:04:39.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:39.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:39.863]                     .init = FALSE)
[18:04:39.863]                 }
[18:04:39.863]             }
[18:04:39.863]         }
[18:04:39.863]     })
[18:04:39.863]     if (TRUE) {
[18:04:39.863]         base::sink(type = "output", split = FALSE)
[18:04:39.863]         if (TRUE) {
[18:04:39.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:39.863]         }
[18:04:39.863]         else {
[18:04:39.863]             ...future.result["stdout"] <- base::list(NULL)
[18:04:39.863]         }
[18:04:39.863]         base::close(...future.stdout)
[18:04:39.863]         ...future.stdout <- NULL
[18:04:39.863]     }
[18:04:39.863]     ...future.result$conditions <- ...future.conditions
[18:04:39.863]     ...future.result$finished <- base::Sys.time()
[18:04:39.863]     ...future.result
[18:04:39.863] }
[18:04:39.899]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.866] assign_globals() ...
[18:04:39.900]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.867] List of 1
[18:04:39.867]  $ data:'data.frame':	5 obs. of  2 variables:
[18:04:39.867]   ..$ x: int [1:5] 1 2 3 4 5
[18:04:39.867]   ..$ y: int [1:5] 1 2 3 4 5
[18:04:39.867]  - attr(*, "where")=List of 1
[18:04:39.867]   ..$ data:<environment: R_EmptyEnv> 
[18:04:39.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:39.867]  - attr(*, "resolved")= logi FALSE
[18:04:39.867]  - attr(*, "total_size")= num 160
[18:04:39.867]  - attr(*, "already-done")= logi TRUE
[18:04:39.900]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.875] - copied ‘data’ to environment
[18:04:39.900]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.876] assign_globals() ... done
[18:04:39.901]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.876] plan(): Setting new future strategy stack:
[18:04:39.901]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.876] List of future strategies:
[18:04:39.876] 1. sequential:
[18:04:39.876]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.876]    - tweaked: FALSE
[18:04:39.876]    - call: NULL
[18:04:39.901]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.877] plan(): nbrOfWorkers() = 1
[18:04:39.901]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.879] plan(): Setting new future strategy stack:
[18:04:39.902]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.879] List of future strategies:
[18:04:39.879] 1. sequential:
[18:04:39.879]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.879]    - tweaked: FALSE
[18:04:39.879]    - call: plan(list(sequential, strategy))
[18:04:39.902]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.880] plan(): nbrOfWorkers() = 1
[18:04:39.902]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.881] SequentialFuture started (and completed)
[18:04:39.903]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.881] - Launch lazy future ... done
[18:04:39.903]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:39.881] run() for ‘SequentialFuture’ ... done
[18:04:39.903] signalConditions() ... done
- Strategy: sequential ... DONE
- Strategy: multicore ...
[18:04:39.904] plan(): Setting new future strategy stack:
[18:04:39.904] List of future strategies:
[18:04:39.904] 1. multicore:
[18:04:39.904]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:39.904]    - tweaked: FALSE
[18:04:39.904]    - call: plan(strategy)
[18:04:39.911] plan(): nbrOfWorkers() = 2
[18:04:39.911] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:39.912] Searching for globals...
[18:04:39.913] - globals found: [1] ‘getOption’
[18:04:39.913] Searching for globals ... DONE
[18:04:39.913] Resolving globals: FALSE
[18:04:39.914] 
[18:04:39.914] 
[18:04:39.914] getGlobalsAndPackages() ... DONE
[18:04:39.915] run() for ‘Future’ ...
[18:04:39.915] - state: ‘created’
[18:04:39.915] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:39.923] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:39.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:39.923]   - Field: ‘label’
[18:04:39.923]   - Field: ‘local’
[18:04:39.924]   - Field: ‘owner’
[18:04:39.924]   - Field: ‘envir’
[18:04:39.924]   - Field: ‘workers’
[18:04:39.924]   - Field: ‘packages’
[18:04:39.925]   - Field: ‘gc’
[18:04:39.925]   - Field: ‘job’
[18:04:39.925]   - Field: ‘conditions’
[18:04:39.925]   - Field: ‘expr’
[18:04:39.926]   - Field: ‘uuid’
[18:04:39.926]   - Field: ‘seed’
[18:04:39.926]   - Field: ‘version’
[18:04:39.926]   - Field: ‘result’
[18:04:39.927]   - Field: ‘asynchronous’
[18:04:39.927]   - Field: ‘calls’
[18:04:39.927]   - Field: ‘globals’
[18:04:39.927]   - Field: ‘stdout’
[18:04:39.927]   - Field: ‘earlySignal’
[18:04:39.928]   - Field: ‘lazy’
[18:04:39.928]   - Field: ‘state’
[18:04:39.928] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:39.928] - Launch lazy future ...
[18:04:39.937] Packages needed by the future expression (n = 0): <none>
[18:04:39.937] Packages needed by future strategies (n = 0): <none>
[18:04:39.938] {
[18:04:39.938]     {
[18:04:39.938]         {
[18:04:39.938]             ...future.startTime <- base::Sys.time()
[18:04:39.938]             {
[18:04:39.938]                 {
[18:04:39.938]                   {
[18:04:39.938]                     {
[18:04:39.938]                       base::local({
[18:04:39.938]                         has_future <- base::requireNamespace("future", 
[18:04:39.938]                           quietly = TRUE)
[18:04:39.938]                         if (has_future) {
[18:04:39.938]                           ns <- base::getNamespace("future")
[18:04:39.938]                           version <- ns[[".package"]][["version"]]
[18:04:39.938]                           if (is.null(version)) 
[18:04:39.938]                             version <- utils::packageVersion("future")
[18:04:39.938]                         }
[18:04:39.938]                         else {
[18:04:39.938]                           version <- NULL
[18:04:39.938]                         }
[18:04:39.938]                         if (!has_future || version < "1.8.0") {
[18:04:39.938]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:39.938]                             "", base::R.version$version.string), 
[18:04:39.938]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:39.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:39.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:39.938]                               "release", "version")], collapse = " "), 
[18:04:39.938]                             hostname = base::Sys.info()[["nodename"]])
[18:04:39.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:39.938]                             info)
[18:04:39.938]                           info <- base::paste(info, collapse = "; ")
[18:04:39.938]                           if (!has_future) {
[18:04:39.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:39.938]                               info)
[18:04:39.938]                           }
[18:04:39.938]                           else {
[18:04:39.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:39.938]                               info, version)
[18:04:39.938]                           }
[18:04:39.938]                           base::stop(msg)
[18:04:39.938]                         }
[18:04:39.938]                       })
[18:04:39.938]                     }
[18:04:39.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:39.938]                     base::options(mc.cores = 1L)
[18:04:39.938]                   }
[18:04:39.938]                   ...future.strategy.old <- future::plan("list")
[18:04:39.938]                   options(future.plan = NULL)
[18:04:39.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:39.938]                 }
[18:04:39.938]                 ...future.workdir <- getwd()
[18:04:39.938]             }
[18:04:39.938]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:39.938]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:39.938]         }
[18:04:39.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:39.938]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:39.938]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:39.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:39.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:39.938]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:39.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:39.938]             base::names(...future.oldOptions))
[18:04:39.938]     }
[18:04:39.938]     if (FALSE) {
[18:04:39.938]     }
[18:04:39.938]     else {
[18:04:39.938]         if (TRUE) {
[18:04:39.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:39.938]                 open = "w")
[18:04:39.938]         }
[18:04:39.938]         else {
[18:04:39.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:39.938]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:39.938]         }
[18:04:39.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:39.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:39.938]             base::sink(type = "output", split = FALSE)
[18:04:39.938]             base::close(...future.stdout)
[18:04:39.938]         }, add = TRUE)
[18:04:39.938]     }
[18:04:39.938]     ...future.frame <- base::sys.nframe()
[18:04:39.938]     ...future.conditions <- base::list()
[18:04:39.938]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:39.938]     if (FALSE) {
[18:04:39.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:39.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:39.938]     }
[18:04:39.938]     ...future.result <- base::tryCatch({
[18:04:39.938]         base::withCallingHandlers({
[18:04:39.938]             ...future.value <- base::withVisible(base::local({
[18:04:39.938]                 withCallingHandlers({
[18:04:39.938]                   getOption("future.globals.onMissing")
[18:04:39.938]                 }, immediateCondition = function(cond) {
[18:04:39.938]                   save_rds <- function (object, pathname, ...) 
[18:04:39.938]                   {
[18:04:39.938]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:39.938]                     if (file_test("-f", pathname_tmp)) {
[18:04:39.938]                       fi_tmp <- file.info(pathname_tmp)
[18:04:39.938]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:39.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:39.938]                         fi_tmp[["mtime"]])
[18:04:39.938]                     }
[18:04:39.938]                     tryCatch({
[18:04:39.938]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:39.938]                     }, error = function(ex) {
[18:04:39.938]                       msg <- conditionMessage(ex)
[18:04:39.938]                       fi_tmp <- file.info(pathname_tmp)
[18:04:39.938]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:39.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:39.938]                         fi_tmp[["mtime"]], msg)
[18:04:39.938]                       ex$message <- msg
[18:04:39.938]                       stop(ex)
[18:04:39.938]                     })
[18:04:39.938]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:39.938]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:39.938]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:39.938]                       fi_tmp <- file.info(pathname_tmp)
[18:04:39.938]                       fi <- file.info(pathname)
[18:04:39.938]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:39.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:39.938]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:39.938]                         fi[["size"]], fi[["mtime"]])
[18:04:39.938]                       stop(msg)
[18:04:39.938]                     }
[18:04:39.938]                     invisible(pathname)
[18:04:39.938]                   }
[18:04:39.938]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:39.938]                     rootPath = tempdir()) 
[18:04:39.938]                   {
[18:04:39.938]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:39.938]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:39.938]                       tmpdir = path, fileext = ".rds")
[18:04:39.938]                     save_rds(obj, file)
[18:04:39.938]                   }
[18:04:39.938]                   saveImmediateCondition(cond, path = "/tmp/RtmpmRLBA8/.future/immediateConditions")
[18:04:39.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.938]                   {
[18:04:39.938]                     inherits <- base::inherits
[18:04:39.938]                     invokeRestart <- base::invokeRestart
[18:04:39.938]                     is.null <- base::is.null
[18:04:39.938]                     muffled <- FALSE
[18:04:39.938]                     if (inherits(cond, "message")) {
[18:04:39.938]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:39.938]                       if (muffled) 
[18:04:39.938]                         invokeRestart("muffleMessage")
[18:04:39.938]                     }
[18:04:39.938]                     else if (inherits(cond, "warning")) {
[18:04:39.938]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:39.938]                       if (muffled) 
[18:04:39.938]                         invokeRestart("muffleWarning")
[18:04:39.938]                     }
[18:04:39.938]                     else if (inherits(cond, "condition")) {
[18:04:39.938]                       if (!is.null(pattern)) {
[18:04:39.938]                         computeRestarts <- base::computeRestarts
[18:04:39.938]                         grepl <- base::grepl
[18:04:39.938]                         restarts <- computeRestarts(cond)
[18:04:39.938]                         for (restart in restarts) {
[18:04:39.938]                           name <- restart$name
[18:04:39.938]                           if (is.null(name)) 
[18:04:39.938]                             next
[18:04:39.938]                           if (!grepl(pattern, name)) 
[18:04:39.938]                             next
[18:04:39.938]                           invokeRestart(restart)
[18:04:39.938]                           muffled <- TRUE
[18:04:39.938]                           break
[18:04:39.938]                         }
[18:04:39.938]                       }
[18:04:39.938]                     }
[18:04:39.938]                     invisible(muffled)
[18:04:39.938]                   }
[18:04:39.938]                   muffleCondition(cond)
[18:04:39.938]                 })
[18:04:39.938]             }))
[18:04:39.938]             future::FutureResult(value = ...future.value$value, 
[18:04:39.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.938]                   ...future.rng), globalenv = if (FALSE) 
[18:04:39.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:39.938]                     ...future.globalenv.names))
[18:04:39.938]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:39.938]         }, condition = base::local({
[18:04:39.938]             c <- base::c
[18:04:39.938]             inherits <- base::inherits
[18:04:39.938]             invokeRestart <- base::invokeRestart
[18:04:39.938]             length <- base::length
[18:04:39.938]             list <- base::list
[18:04:39.938]             seq.int <- base::seq.int
[18:04:39.938]             signalCondition <- base::signalCondition
[18:04:39.938]             sys.calls <- base::sys.calls
[18:04:39.938]             `[[` <- base::`[[`
[18:04:39.938]             `+` <- base::`+`
[18:04:39.938]             `<<-` <- base::`<<-`
[18:04:39.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:39.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:39.938]                   3L)]
[18:04:39.938]             }
[18:04:39.938]             function(cond) {
[18:04:39.938]                 is_error <- inherits(cond, "error")
[18:04:39.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:39.938]                   NULL)
[18:04:39.938]                 if (is_error) {
[18:04:39.938]                   sessionInformation <- function() {
[18:04:39.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:39.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:39.938]                       search = base::search(), system = base::Sys.info())
[18:04:39.938]                   }
[18:04:39.938]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:39.938]                     cond$call), session = sessionInformation(), 
[18:04:39.938]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:39.938]                   signalCondition(cond)
[18:04:39.938]                 }
[18:04:39.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:39.938]                 "immediateCondition"))) {
[18:04:39.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:39.938]                   ...future.conditions[[length(...future.conditions) + 
[18:04:39.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:39.938]                   if (TRUE && !signal) {
[18:04:39.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.938]                     {
[18:04:39.938]                       inherits <- base::inherits
[18:04:39.938]                       invokeRestart <- base::invokeRestart
[18:04:39.938]                       is.null <- base::is.null
[18:04:39.938]                       muffled <- FALSE
[18:04:39.938]                       if (inherits(cond, "message")) {
[18:04:39.938]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.938]                         if (muffled) 
[18:04:39.938]                           invokeRestart("muffleMessage")
[18:04:39.938]                       }
[18:04:39.938]                       else if (inherits(cond, "warning")) {
[18:04:39.938]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.938]                         if (muffled) 
[18:04:39.938]                           invokeRestart("muffleWarning")
[18:04:39.938]                       }
[18:04:39.938]                       else if (inherits(cond, "condition")) {
[18:04:39.938]                         if (!is.null(pattern)) {
[18:04:39.938]                           computeRestarts <- base::computeRestarts
[18:04:39.938]                           grepl <- base::grepl
[18:04:39.938]                           restarts <- computeRestarts(cond)
[18:04:39.938]                           for (restart in restarts) {
[18:04:39.938]                             name <- restart$name
[18:04:39.938]                             if (is.null(name)) 
[18:04:39.938]                               next
[18:04:39.938]                             if (!grepl(pattern, name)) 
[18:04:39.938]                               next
[18:04:39.938]                             invokeRestart(restart)
[18:04:39.938]                             muffled <- TRUE
[18:04:39.938]                             break
[18:04:39.938]                           }
[18:04:39.938]                         }
[18:04:39.938]                       }
[18:04:39.938]                       invisible(muffled)
[18:04:39.938]                     }
[18:04:39.938]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.938]                   }
[18:04:39.938]                 }
[18:04:39.938]                 else {
[18:04:39.938]                   if (TRUE) {
[18:04:39.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:39.938]                     {
[18:04:39.938]                       inherits <- base::inherits
[18:04:39.938]                       invokeRestart <- base::invokeRestart
[18:04:39.938]                       is.null <- base::is.null
[18:04:39.938]                       muffled <- FALSE
[18:04:39.938]                       if (inherits(cond, "message")) {
[18:04:39.938]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:39.938]                         if (muffled) 
[18:04:39.938]                           invokeRestart("muffleMessage")
[18:04:39.938]                       }
[18:04:39.938]                       else if (inherits(cond, "warning")) {
[18:04:39.938]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:39.938]                         if (muffled) 
[18:04:39.938]                           invokeRestart("muffleWarning")
[18:04:39.938]                       }
[18:04:39.938]                       else if (inherits(cond, "condition")) {
[18:04:39.938]                         if (!is.null(pattern)) {
[18:04:39.938]                           computeRestarts <- base::computeRestarts
[18:04:39.938]                           grepl <- base::grepl
[18:04:39.938]                           restarts <- computeRestarts(cond)
[18:04:39.938]                           for (restart in restarts) {
[18:04:39.938]                             name <- restart$name
[18:04:39.938]                             if (is.null(name)) 
[18:04:39.938]                               next
[18:04:39.938]                             if (!grepl(pattern, name)) 
[18:04:39.938]                               next
[18:04:39.938]                             invokeRestart(restart)
[18:04:39.938]                             muffled <- TRUE
[18:04:39.938]                             break
[18:04:39.938]                           }
[18:04:39.938]                         }
[18:04:39.938]                       }
[18:04:39.938]                       invisible(muffled)
[18:04:39.938]                     }
[18:04:39.938]                     muffleCondition(cond, pattern = "^muffle")
[18:04:39.938]                   }
[18:04:39.938]                 }
[18:04:39.938]             }
[18:04:39.938]         }))
[18:04:39.938]     }, error = function(ex) {
[18:04:39.938]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:39.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:39.938]                 ...future.rng), started = ...future.startTime, 
[18:04:39.938]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:39.938]             version = "1.8"), class = "FutureResult")
[18:04:39.938]     }, finally = {
[18:04:39.938]         if (!identical(...future.workdir, getwd())) 
[18:04:39.938]             setwd(...future.workdir)
[18:04:39.938]         {
[18:04:39.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:39.938]                 ...future.oldOptions$nwarnings <- NULL
[18:04:39.938]             }
[18:04:39.938]             base::options(...future.oldOptions)
[18:04:39.938]             if (.Platform$OS.type == "windows") {
[18:04:39.938]                 old_names <- names(...future.oldEnvVars)
[18:04:39.938]                 envs <- base::Sys.getenv()
[18:04:39.938]                 names <- names(envs)
[18:04:39.938]                 common <- intersect(names, old_names)
[18:04:39.938]                 added <- setdiff(names, old_names)
[18:04:39.938]                 removed <- setdiff(old_names, names)
[18:04:39.938]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:39.938]                   envs[common]]
[18:04:39.938]                 NAMES <- toupper(changed)
[18:04:39.938]                 args <- list()
[18:04:39.938]                 for (kk in seq_along(NAMES)) {
[18:04:39.938]                   name <- changed[[kk]]
[18:04:39.938]                   NAME <- NAMES[[kk]]
[18:04:39.938]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.938]                     next
[18:04:39.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.938]                 }
[18:04:39.938]                 NAMES <- toupper(added)
[18:04:39.938]                 for (kk in seq_along(NAMES)) {
[18:04:39.938]                   name <- added[[kk]]
[18:04:39.938]                   NAME <- NAMES[[kk]]
[18:04:39.938]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.938]                     next
[18:04:39.938]                   args[[name]] <- ""
[18:04:39.938]                 }
[18:04:39.938]                 NAMES <- toupper(removed)
[18:04:39.938]                 for (kk in seq_along(NAMES)) {
[18:04:39.938]                   name <- removed[[kk]]
[18:04:39.938]                   NAME <- NAMES[[kk]]
[18:04:39.938]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:39.938]                     next
[18:04:39.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:39.938]                 }
[18:04:39.938]                 if (length(args) > 0) 
[18:04:39.938]                   base::do.call(base::Sys.setenv, args = args)
[18:04:39.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:39.938]             }
[18:04:39.938]             else {
[18:04:39.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:39.938]             }
[18:04:39.938]             {
[18:04:39.938]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:39.938]                   0L) {
[18:04:39.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:39.938]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:39.938]                   base::options(opts)
[18:04:39.938]                 }
[18:04:39.938]                 {
[18:04:39.938]                   {
[18:04:39.938]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:39.938]                     NULL
[18:04:39.938]                   }
[18:04:39.938]                   options(future.plan = NULL)
[18:04:39.938]                   if (is.na(NA_character_)) 
[18:04:39.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:39.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:39.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:39.938]                     .init = FALSE)
[18:04:39.938]                 }
[18:04:39.938]             }
[18:04:39.938]         }
[18:04:39.938]     })
[18:04:39.938]     if (TRUE) {
[18:04:39.938]         base::sink(type = "output", split = FALSE)
[18:04:39.938]         if (TRUE) {
[18:04:39.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:39.938]         }
[18:04:39.938]         else {
[18:04:39.938]             ...future.result["stdout"] <- base::list(NULL)
[18:04:39.938]         }
[18:04:39.938]         base::close(...future.stdout)
[18:04:39.938]         ...future.stdout <- NULL
[18:04:39.938]     }
[18:04:39.938]     ...future.result$conditions <- ...future.conditions
[18:04:39.938]     ...future.result$finished <- base::Sys.time()
[18:04:39.938]     ...future.result
[18:04:39.938] }
[18:04:39.946] requestCore(): workers = 2
[18:04:39.967] MulticoreFuture started
[18:04:39.968] - Launch lazy future ... done
[18:04:39.969] run() for ‘MulticoreFuture’ ... done
[18:04:39.971] result() for MulticoreFuture ...
[18:04:39.971] plan(): Setting new future strategy stack:
[18:04:39.971] List of future strategies:
[18:04:39.971] 1. sequential:
[18:04:39.971]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:39.971]    - tweaked: FALSE
[18:04:39.971]    - call: NULL
[18:04:39.976] plan(): nbrOfWorkers() = 1
[18:04:39.979] plan(): Setting new future strategy stack:
[18:04:39.980] List of future strategies:
[18:04:39.980] 1. multicore:
[18:04:39.980]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:39.980]    - tweaked: FALSE
[18:04:39.980]    - call: plan(strategy)
[18:04:39.990] plan(): nbrOfWorkers() = 2
[18:04:40.003] result() for MulticoreFuture ...
[18:04:40.003] result() for MulticoreFuture ... done
[18:04:40.003] result() for MulticoreFuture ... done
[18:04:40.004] result() for MulticoreFuture ...
[18:04:40.004] result() for MulticoreFuture ... done
[18:04:40.005] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:40.005] Searching for globals...
[18:04:40.006] - globals found: [1] ‘getOption’
[18:04:40.007] Searching for globals ... DONE
[18:04:40.007] Resolving globals: FALSE
[18:04:40.008] 
[18:04:40.008] 
[18:04:40.008] getGlobalsAndPackages() ... DONE
[18:04:40.009] run() for ‘Future’ ...
[18:04:40.009] - state: ‘created’
[18:04:40.009] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:40.016] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:40.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:40.017]   - Field: ‘label’
[18:04:40.017]   - Field: ‘local’
[18:04:40.017]   - Field: ‘owner’
[18:04:40.017]   - Field: ‘envir’
[18:04:40.018]   - Field: ‘workers’
[18:04:40.018]   - Field: ‘packages’
[18:04:40.018]   - Field: ‘gc’
[18:04:40.018]   - Field: ‘job’
[18:04:40.018]   - Field: ‘conditions’
[18:04:40.019]   - Field: ‘expr’
[18:04:40.019]   - Field: ‘uuid’
[18:04:40.019]   - Field: ‘seed’
[18:04:40.019]   - Field: ‘version’
[18:04:40.020]   - Field: ‘result’
[18:04:40.020]   - Field: ‘asynchronous’
[18:04:40.020]   - Field: ‘calls’
[18:04:40.020]   - Field: ‘globals’
[18:04:40.021]   - Field: ‘stdout’
[18:04:40.021]   - Field: ‘earlySignal’
[18:04:40.021]   - Field: ‘lazy’
[18:04:40.021]   - Field: ‘state’
[18:04:40.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:40.022] - Launch lazy future ...
[18:04:40.022] Packages needed by the future expression (n = 0): <none>
[18:04:40.023] Packages needed by future strategies (n = 0): <none>
[18:04:40.024] {
[18:04:40.024]     {
[18:04:40.024]         {
[18:04:40.024]             ...future.startTime <- base::Sys.time()
[18:04:40.024]             {
[18:04:40.024]                 {
[18:04:40.024]                   {
[18:04:40.024]                     {
[18:04:40.024]                       base::local({
[18:04:40.024]                         has_future <- base::requireNamespace("future", 
[18:04:40.024]                           quietly = TRUE)
[18:04:40.024]                         if (has_future) {
[18:04:40.024]                           ns <- base::getNamespace("future")
[18:04:40.024]                           version <- ns[[".package"]][["version"]]
[18:04:40.024]                           if (is.null(version)) 
[18:04:40.024]                             version <- utils::packageVersion("future")
[18:04:40.024]                         }
[18:04:40.024]                         else {
[18:04:40.024]                           version <- NULL
[18:04:40.024]                         }
[18:04:40.024]                         if (!has_future || version < "1.8.0") {
[18:04:40.024]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:40.024]                             "", base::R.version$version.string), 
[18:04:40.024]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:40.024]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:40.024]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:40.024]                               "release", "version")], collapse = " "), 
[18:04:40.024]                             hostname = base::Sys.info()[["nodename"]])
[18:04:40.024]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:40.024]                             info)
[18:04:40.024]                           info <- base::paste(info, collapse = "; ")
[18:04:40.024]                           if (!has_future) {
[18:04:40.024]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:40.024]                               info)
[18:04:40.024]                           }
[18:04:40.024]                           else {
[18:04:40.024]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:40.024]                               info, version)
[18:04:40.024]                           }
[18:04:40.024]                           base::stop(msg)
[18:04:40.024]                         }
[18:04:40.024]                       })
[18:04:40.024]                     }
[18:04:40.024]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:40.024]                     base::options(mc.cores = 1L)
[18:04:40.024]                   }
[18:04:40.024]                   ...future.strategy.old <- future::plan("list")
[18:04:40.024]                   options(future.plan = NULL)
[18:04:40.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:40.024]                 }
[18:04:40.024]                 ...future.workdir <- getwd()
[18:04:40.024]             }
[18:04:40.024]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:40.024]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:40.024]         }
[18:04:40.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:40.024]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:40.024]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:40.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:40.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:40.024]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:40.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:40.024]             base::names(...future.oldOptions))
[18:04:40.024]     }
[18:04:40.024]     if (FALSE) {
[18:04:40.024]     }
[18:04:40.024]     else {
[18:04:40.024]         if (TRUE) {
[18:04:40.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:40.024]                 open = "w")
[18:04:40.024]         }
[18:04:40.024]         else {
[18:04:40.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:40.024]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:40.024]         }
[18:04:40.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:40.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:40.024]             base::sink(type = "output", split = FALSE)
[18:04:40.024]             base::close(...future.stdout)
[18:04:40.024]         }, add = TRUE)
[18:04:40.024]     }
[18:04:40.024]     ...future.frame <- base::sys.nframe()
[18:04:40.024]     ...future.conditions <- base::list()
[18:04:40.024]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:40.024]     if (FALSE) {
[18:04:40.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:40.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:40.024]     }
[18:04:40.024]     ...future.result <- base::tryCatch({
[18:04:40.024]         base::withCallingHandlers({
[18:04:40.024]             ...future.value <- base::withVisible(base::local({
[18:04:40.024]                 withCallingHandlers({
[18:04:40.024]                   getOption("future.globals.onMissing")
[18:04:40.024]                 }, immediateCondition = function(cond) {
[18:04:40.024]                   save_rds <- function (object, pathname, ...) 
[18:04:40.024]                   {
[18:04:40.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:40.024]                     if (file_test("-f", pathname_tmp)) {
[18:04:40.024]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:40.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.024]                         fi_tmp[["mtime"]])
[18:04:40.024]                     }
[18:04:40.024]                     tryCatch({
[18:04:40.024]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:40.024]                     }, error = function(ex) {
[18:04:40.024]                       msg <- conditionMessage(ex)
[18:04:40.024]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:40.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.024]                         fi_tmp[["mtime"]], msg)
[18:04:40.024]                       ex$message <- msg
[18:04:40.024]                       stop(ex)
[18:04:40.024]                     })
[18:04:40.024]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:40.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:40.024]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:40.024]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.024]                       fi <- file.info(pathname)
[18:04:40.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:40.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:40.024]                         fi[["size"]], fi[["mtime"]])
[18:04:40.024]                       stop(msg)
[18:04:40.024]                     }
[18:04:40.024]                     invisible(pathname)
[18:04:40.024]                   }
[18:04:40.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:40.024]                     rootPath = tempdir()) 
[18:04:40.024]                   {
[18:04:40.024]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:40.024]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:40.024]                       tmpdir = path, fileext = ".rds")
[18:04:40.024]                     save_rds(obj, file)
[18:04:40.024]                   }
[18:04:40.024]                   saveImmediateCondition(cond, path = "/tmp/RtmpmRLBA8/.future/immediateConditions")
[18:04:40.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.024]                   {
[18:04:40.024]                     inherits <- base::inherits
[18:04:40.024]                     invokeRestart <- base::invokeRestart
[18:04:40.024]                     is.null <- base::is.null
[18:04:40.024]                     muffled <- FALSE
[18:04:40.024]                     if (inherits(cond, "message")) {
[18:04:40.024]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:40.024]                       if (muffled) 
[18:04:40.024]                         invokeRestart("muffleMessage")
[18:04:40.024]                     }
[18:04:40.024]                     else if (inherits(cond, "warning")) {
[18:04:40.024]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:40.024]                       if (muffled) 
[18:04:40.024]                         invokeRestart("muffleWarning")
[18:04:40.024]                     }
[18:04:40.024]                     else if (inherits(cond, "condition")) {
[18:04:40.024]                       if (!is.null(pattern)) {
[18:04:40.024]                         computeRestarts <- base::computeRestarts
[18:04:40.024]                         grepl <- base::grepl
[18:04:40.024]                         restarts <- computeRestarts(cond)
[18:04:40.024]                         for (restart in restarts) {
[18:04:40.024]                           name <- restart$name
[18:04:40.024]                           if (is.null(name)) 
[18:04:40.024]                             next
[18:04:40.024]                           if (!grepl(pattern, name)) 
[18:04:40.024]                             next
[18:04:40.024]                           invokeRestart(restart)
[18:04:40.024]                           muffled <- TRUE
[18:04:40.024]                           break
[18:04:40.024]                         }
[18:04:40.024]                       }
[18:04:40.024]                     }
[18:04:40.024]                     invisible(muffled)
[18:04:40.024]                   }
[18:04:40.024]                   muffleCondition(cond)
[18:04:40.024]                 })
[18:04:40.024]             }))
[18:04:40.024]             future::FutureResult(value = ...future.value$value, 
[18:04:40.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.024]                   ...future.rng), globalenv = if (FALSE) 
[18:04:40.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:40.024]                     ...future.globalenv.names))
[18:04:40.024]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:40.024]         }, condition = base::local({
[18:04:40.024]             c <- base::c
[18:04:40.024]             inherits <- base::inherits
[18:04:40.024]             invokeRestart <- base::invokeRestart
[18:04:40.024]             length <- base::length
[18:04:40.024]             list <- base::list
[18:04:40.024]             seq.int <- base::seq.int
[18:04:40.024]             signalCondition <- base::signalCondition
[18:04:40.024]             sys.calls <- base::sys.calls
[18:04:40.024]             `[[` <- base::`[[`
[18:04:40.024]             `+` <- base::`+`
[18:04:40.024]             `<<-` <- base::`<<-`
[18:04:40.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:40.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:40.024]                   3L)]
[18:04:40.024]             }
[18:04:40.024]             function(cond) {
[18:04:40.024]                 is_error <- inherits(cond, "error")
[18:04:40.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:40.024]                   NULL)
[18:04:40.024]                 if (is_error) {
[18:04:40.024]                   sessionInformation <- function() {
[18:04:40.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:40.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:40.024]                       search = base::search(), system = base::Sys.info())
[18:04:40.024]                   }
[18:04:40.024]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:40.024]                     cond$call), session = sessionInformation(), 
[18:04:40.024]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:40.024]                   signalCondition(cond)
[18:04:40.024]                 }
[18:04:40.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:40.024]                 "immediateCondition"))) {
[18:04:40.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:40.024]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:40.024]                   if (TRUE && !signal) {
[18:04:40.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.024]                     {
[18:04:40.024]                       inherits <- base::inherits
[18:04:40.024]                       invokeRestart <- base::invokeRestart
[18:04:40.024]                       is.null <- base::is.null
[18:04:40.024]                       muffled <- FALSE
[18:04:40.024]                       if (inherits(cond, "message")) {
[18:04:40.024]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.024]                         if (muffled) 
[18:04:40.024]                           invokeRestart("muffleMessage")
[18:04:40.024]                       }
[18:04:40.024]                       else if (inherits(cond, "warning")) {
[18:04:40.024]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.024]                         if (muffled) 
[18:04:40.024]                           invokeRestart("muffleWarning")
[18:04:40.024]                       }
[18:04:40.024]                       else if (inherits(cond, "condition")) {
[18:04:40.024]                         if (!is.null(pattern)) {
[18:04:40.024]                           computeRestarts <- base::computeRestarts
[18:04:40.024]                           grepl <- base::grepl
[18:04:40.024]                           restarts <- computeRestarts(cond)
[18:04:40.024]                           for (restart in restarts) {
[18:04:40.024]                             name <- restart$name
[18:04:40.024]                             if (is.null(name)) 
[18:04:40.024]                               next
[18:04:40.024]                             if (!grepl(pattern, name)) 
[18:04:40.024]                               next
[18:04:40.024]                             invokeRestart(restart)
[18:04:40.024]                             muffled <- TRUE
[18:04:40.024]                             break
[18:04:40.024]                           }
[18:04:40.024]                         }
[18:04:40.024]                       }
[18:04:40.024]                       invisible(muffled)
[18:04:40.024]                     }
[18:04:40.024]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.024]                   }
[18:04:40.024]                 }
[18:04:40.024]                 else {
[18:04:40.024]                   if (TRUE) {
[18:04:40.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.024]                     {
[18:04:40.024]                       inherits <- base::inherits
[18:04:40.024]                       invokeRestart <- base::invokeRestart
[18:04:40.024]                       is.null <- base::is.null
[18:04:40.024]                       muffled <- FALSE
[18:04:40.024]                       if (inherits(cond, "message")) {
[18:04:40.024]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.024]                         if (muffled) 
[18:04:40.024]                           invokeRestart("muffleMessage")
[18:04:40.024]                       }
[18:04:40.024]                       else if (inherits(cond, "warning")) {
[18:04:40.024]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.024]                         if (muffled) 
[18:04:40.024]                           invokeRestart("muffleWarning")
[18:04:40.024]                       }
[18:04:40.024]                       else if (inherits(cond, "condition")) {
[18:04:40.024]                         if (!is.null(pattern)) {
[18:04:40.024]                           computeRestarts <- base::computeRestarts
[18:04:40.024]                           grepl <- base::grepl
[18:04:40.024]                           restarts <- computeRestarts(cond)
[18:04:40.024]                           for (restart in restarts) {
[18:04:40.024]                             name <- restart$name
[18:04:40.024]                             if (is.null(name)) 
[18:04:40.024]                               next
[18:04:40.024]                             if (!grepl(pattern, name)) 
[18:04:40.024]                               next
[18:04:40.024]                             invokeRestart(restart)
[18:04:40.024]                             muffled <- TRUE
[18:04:40.024]                             break
[18:04:40.024]                           }
[18:04:40.024]                         }
[18:04:40.024]                       }
[18:04:40.024]                       invisible(muffled)
[18:04:40.024]                     }
[18:04:40.024]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.024]                   }
[18:04:40.024]                 }
[18:04:40.024]             }
[18:04:40.024]         }))
[18:04:40.024]     }, error = function(ex) {
[18:04:40.024]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:40.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.024]                 ...future.rng), started = ...future.startTime, 
[18:04:40.024]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:40.024]             version = "1.8"), class = "FutureResult")
[18:04:40.024]     }, finally = {
[18:04:40.024]         if (!identical(...future.workdir, getwd())) 
[18:04:40.024]             setwd(...future.workdir)
[18:04:40.024]         {
[18:04:40.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:40.024]                 ...future.oldOptions$nwarnings <- NULL
[18:04:40.024]             }
[18:04:40.024]             base::options(...future.oldOptions)
[18:04:40.024]             if (.Platform$OS.type == "windows") {
[18:04:40.024]                 old_names <- names(...future.oldEnvVars)
[18:04:40.024]                 envs <- base::Sys.getenv()
[18:04:40.024]                 names <- names(envs)
[18:04:40.024]                 common <- intersect(names, old_names)
[18:04:40.024]                 added <- setdiff(names, old_names)
[18:04:40.024]                 removed <- setdiff(old_names, names)
[18:04:40.024]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:40.024]                   envs[common]]
[18:04:40.024]                 NAMES <- toupper(changed)
[18:04:40.024]                 args <- list()
[18:04:40.024]                 for (kk in seq_along(NAMES)) {
[18:04:40.024]                   name <- changed[[kk]]
[18:04:40.024]                   NAME <- NAMES[[kk]]
[18:04:40.024]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.024]                     next
[18:04:40.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.024]                 }
[18:04:40.024]                 NAMES <- toupper(added)
[18:04:40.024]                 for (kk in seq_along(NAMES)) {
[18:04:40.024]                   name <- added[[kk]]
[18:04:40.024]                   NAME <- NAMES[[kk]]
[18:04:40.024]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.024]                     next
[18:04:40.024]                   args[[name]] <- ""
[18:04:40.024]                 }
[18:04:40.024]                 NAMES <- toupper(removed)
[18:04:40.024]                 for (kk in seq_along(NAMES)) {
[18:04:40.024]                   name <- removed[[kk]]
[18:04:40.024]                   NAME <- NAMES[[kk]]
[18:04:40.024]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.024]                     next
[18:04:40.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.024]                 }
[18:04:40.024]                 if (length(args) > 0) 
[18:04:40.024]                   base::do.call(base::Sys.setenv, args = args)
[18:04:40.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:40.024]             }
[18:04:40.024]             else {
[18:04:40.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:40.024]             }
[18:04:40.024]             {
[18:04:40.024]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:40.024]                   0L) {
[18:04:40.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:40.024]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:40.024]                   base::options(opts)
[18:04:40.024]                 }
[18:04:40.024]                 {
[18:04:40.024]                   {
[18:04:40.024]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:40.024]                     NULL
[18:04:40.024]                   }
[18:04:40.024]                   options(future.plan = NULL)
[18:04:40.024]                   if (is.na(NA_character_)) 
[18:04:40.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:40.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:40.024]                     .init = FALSE)
[18:04:40.024]                 }
[18:04:40.024]             }
[18:04:40.024]         }
[18:04:40.024]     })
[18:04:40.024]     if (TRUE) {
[18:04:40.024]         base::sink(type = "output", split = FALSE)
[18:04:40.024]         if (TRUE) {
[18:04:40.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:40.024]         }
[18:04:40.024]         else {
[18:04:40.024]             ...future.result["stdout"] <- base::list(NULL)
[18:04:40.024]         }
[18:04:40.024]         base::close(...future.stdout)
[18:04:40.024]         ...future.stdout <- NULL
[18:04:40.024]     }
[18:04:40.024]     ...future.result$conditions <- ...future.conditions
[18:04:40.024]     ...future.result$finished <- base::Sys.time()
[18:04:40.024]     ...future.result
[18:04:40.024] }
[18:04:40.028] requestCore(): workers = 2
[18:04:40.031] MulticoreFuture started
[18:04:40.032] - Launch lazy future ... done
[18:04:40.032] run() for ‘MulticoreFuture’ ... done
[18:04:40.033] result() for MulticoreFuture ...
[18:04:40.033] plan(): Setting new future strategy stack:
[18:04:40.034] List of future strategies:
[18:04:40.034] 1. sequential:
[18:04:40.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:40.034]    - tweaked: FALSE
[18:04:40.034]    - call: NULL
[18:04:40.036] plan(): nbrOfWorkers() = 1
[18:04:40.040] plan(): Setting new future strategy stack:
[18:04:40.040] List of future strategies:
[18:04:40.040] 1. multicore:
[18:04:40.040]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:40.040]    - tweaked: FALSE
[18:04:40.040]    - call: plan(strategy)
[18:04:40.049] plan(): nbrOfWorkers() = 2
[18:04:40.053] result() for MulticoreFuture ...
[18:04:40.053] result() for MulticoreFuture ... done
[18:04:40.054] result() for MulticoreFuture ... done
[18:04:40.054] result() for MulticoreFuture ...
[18:04:40.054] result() for MulticoreFuture ... done
[18:04:40.056] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:40.057] Searching for globals...
[18:04:40.060] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:40.061] Searching for globals...
[18:04:40.063] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[18:04:40.063] Searching for globals ... DONE
[18:04:40.064] Resolving globals: FALSE
[18:04:40.065] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:40.066] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:40.066] - globals: [1] ‘data’
[18:04:40.067] 
[18:04:40.067] getGlobalsAndPackages() ... DONE
[18:04:40.068] run() for ‘Future’ ...
[18:04:40.068] - state: ‘created’
[18:04:40.068] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:40.075] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:40.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:40.076]   - Field: ‘label’
[18:04:40.076]   - Field: ‘local’
[18:04:40.076]   - Field: ‘owner’
[18:04:40.076]   - Field: ‘envir’
[18:04:40.077]   - Field: ‘workers’
[18:04:40.077]   - Field: ‘packages’
[18:04:40.077]   - Field: ‘gc’
[18:04:40.077]   - Field: ‘job’
[18:04:40.078]   - Field: ‘conditions’
[18:04:40.078]   - Field: ‘expr’
[18:04:40.078]   - Field: ‘uuid’
[18:04:40.078]   - Field: ‘seed’
[18:04:40.079]   - Field: ‘version’
[18:04:40.079]   - Field: ‘result’
[18:04:40.079]   - Field: ‘asynchronous’
[18:04:40.079]   - Field: ‘calls’
[18:04:40.079]   - Field: ‘globals’
[18:04:40.080]   - Field: ‘stdout’
[18:04:40.080]   - Field: ‘earlySignal’
[18:04:40.080]   - Field: ‘lazy’
[18:04:40.080]   - Field: ‘state’
[18:04:40.081] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:40.081] - Launch lazy future ...
[18:04:40.082] Packages needed by the future expression (n = 0): <none>
[18:04:40.082] Packages needed by future strategies (n = 0): <none>
[18:04:40.083] {
[18:04:40.083]     {
[18:04:40.083]         {
[18:04:40.083]             ...future.startTime <- base::Sys.time()
[18:04:40.083]             {
[18:04:40.083]                 {
[18:04:40.083]                   {
[18:04:40.083]                     {
[18:04:40.083]                       base::local({
[18:04:40.083]                         has_future <- base::requireNamespace("future", 
[18:04:40.083]                           quietly = TRUE)
[18:04:40.083]                         if (has_future) {
[18:04:40.083]                           ns <- base::getNamespace("future")
[18:04:40.083]                           version <- ns[[".package"]][["version"]]
[18:04:40.083]                           if (is.null(version)) 
[18:04:40.083]                             version <- utils::packageVersion("future")
[18:04:40.083]                         }
[18:04:40.083]                         else {
[18:04:40.083]                           version <- NULL
[18:04:40.083]                         }
[18:04:40.083]                         if (!has_future || version < "1.8.0") {
[18:04:40.083]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:40.083]                             "", base::R.version$version.string), 
[18:04:40.083]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:40.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:40.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:40.083]                               "release", "version")], collapse = " "), 
[18:04:40.083]                             hostname = base::Sys.info()[["nodename"]])
[18:04:40.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:40.083]                             info)
[18:04:40.083]                           info <- base::paste(info, collapse = "; ")
[18:04:40.083]                           if (!has_future) {
[18:04:40.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:40.083]                               info)
[18:04:40.083]                           }
[18:04:40.083]                           else {
[18:04:40.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:40.083]                               info, version)
[18:04:40.083]                           }
[18:04:40.083]                           base::stop(msg)
[18:04:40.083]                         }
[18:04:40.083]                       })
[18:04:40.083]                     }
[18:04:40.083]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:40.083]                     base::options(mc.cores = 1L)
[18:04:40.083]                   }
[18:04:40.083]                   ...future.strategy.old <- future::plan("list")
[18:04:40.083]                   options(future.plan = NULL)
[18:04:40.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:40.083]                 }
[18:04:40.083]                 ...future.workdir <- getwd()
[18:04:40.083]             }
[18:04:40.083]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:40.083]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:40.083]         }
[18:04:40.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:40.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:40.083]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:40.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:40.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:40.083]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:40.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:40.083]             base::names(...future.oldOptions))
[18:04:40.083]     }
[18:04:40.083]     if (FALSE) {
[18:04:40.083]     }
[18:04:40.083]     else {
[18:04:40.083]         if (TRUE) {
[18:04:40.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:40.083]                 open = "w")
[18:04:40.083]         }
[18:04:40.083]         else {
[18:04:40.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:40.083]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:40.083]         }
[18:04:40.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:40.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:40.083]             base::sink(type = "output", split = FALSE)
[18:04:40.083]             base::close(...future.stdout)
[18:04:40.083]         }, add = TRUE)
[18:04:40.083]     }
[18:04:40.083]     ...future.frame <- base::sys.nframe()
[18:04:40.083]     ...future.conditions <- base::list()
[18:04:40.083]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:40.083]     if (FALSE) {
[18:04:40.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:40.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:40.083]     }
[18:04:40.083]     ...future.result <- base::tryCatch({
[18:04:40.083]         base::withCallingHandlers({
[18:04:40.083]             ...future.value <- base::withVisible(base::local({
[18:04:40.083]                 withCallingHandlers({
[18:04:40.083]                   subset(data, x < 3)$y
[18:04:40.083]                 }, immediateCondition = function(cond) {
[18:04:40.083]                   save_rds <- function (object, pathname, ...) 
[18:04:40.083]                   {
[18:04:40.083]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:40.083]                     if (file_test("-f", pathname_tmp)) {
[18:04:40.083]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.083]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:40.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.083]                         fi_tmp[["mtime"]])
[18:04:40.083]                     }
[18:04:40.083]                     tryCatch({
[18:04:40.083]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:40.083]                     }, error = function(ex) {
[18:04:40.083]                       msg <- conditionMessage(ex)
[18:04:40.083]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.083]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:40.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.083]                         fi_tmp[["mtime"]], msg)
[18:04:40.083]                       ex$message <- msg
[18:04:40.083]                       stop(ex)
[18:04:40.083]                     })
[18:04:40.083]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:40.083]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:40.083]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:40.083]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.083]                       fi <- file.info(pathname)
[18:04:40.083]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:40.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.083]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:40.083]                         fi[["size"]], fi[["mtime"]])
[18:04:40.083]                       stop(msg)
[18:04:40.083]                     }
[18:04:40.083]                     invisible(pathname)
[18:04:40.083]                   }
[18:04:40.083]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:40.083]                     rootPath = tempdir()) 
[18:04:40.083]                   {
[18:04:40.083]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:40.083]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:40.083]                       tmpdir = path, fileext = ".rds")
[18:04:40.083]                     save_rds(obj, file)
[18:04:40.083]                   }
[18:04:40.083]                   saveImmediateCondition(cond, path = "/tmp/RtmpmRLBA8/.future/immediateConditions")
[18:04:40.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.083]                   {
[18:04:40.083]                     inherits <- base::inherits
[18:04:40.083]                     invokeRestart <- base::invokeRestart
[18:04:40.083]                     is.null <- base::is.null
[18:04:40.083]                     muffled <- FALSE
[18:04:40.083]                     if (inherits(cond, "message")) {
[18:04:40.083]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:40.083]                       if (muffled) 
[18:04:40.083]                         invokeRestart("muffleMessage")
[18:04:40.083]                     }
[18:04:40.083]                     else if (inherits(cond, "warning")) {
[18:04:40.083]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:40.083]                       if (muffled) 
[18:04:40.083]                         invokeRestart("muffleWarning")
[18:04:40.083]                     }
[18:04:40.083]                     else if (inherits(cond, "condition")) {
[18:04:40.083]                       if (!is.null(pattern)) {
[18:04:40.083]                         computeRestarts <- base::computeRestarts
[18:04:40.083]                         grepl <- base::grepl
[18:04:40.083]                         restarts <- computeRestarts(cond)
[18:04:40.083]                         for (restart in restarts) {
[18:04:40.083]                           name <- restart$name
[18:04:40.083]                           if (is.null(name)) 
[18:04:40.083]                             next
[18:04:40.083]                           if (!grepl(pattern, name)) 
[18:04:40.083]                             next
[18:04:40.083]                           invokeRestart(restart)
[18:04:40.083]                           muffled <- TRUE
[18:04:40.083]                           break
[18:04:40.083]                         }
[18:04:40.083]                       }
[18:04:40.083]                     }
[18:04:40.083]                     invisible(muffled)
[18:04:40.083]                   }
[18:04:40.083]                   muffleCondition(cond)
[18:04:40.083]                 })
[18:04:40.083]             }))
[18:04:40.083]             future::FutureResult(value = ...future.value$value, 
[18:04:40.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.083]                   ...future.rng), globalenv = if (FALSE) 
[18:04:40.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:40.083]                     ...future.globalenv.names))
[18:04:40.083]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:40.083]         }, condition = base::local({
[18:04:40.083]             c <- base::c
[18:04:40.083]             inherits <- base::inherits
[18:04:40.083]             invokeRestart <- base::invokeRestart
[18:04:40.083]             length <- base::length
[18:04:40.083]             list <- base::list
[18:04:40.083]             seq.int <- base::seq.int
[18:04:40.083]             signalCondition <- base::signalCondition
[18:04:40.083]             sys.calls <- base::sys.calls
[18:04:40.083]             `[[` <- base::`[[`
[18:04:40.083]             `+` <- base::`+`
[18:04:40.083]             `<<-` <- base::`<<-`
[18:04:40.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:40.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:40.083]                   3L)]
[18:04:40.083]             }
[18:04:40.083]             function(cond) {
[18:04:40.083]                 is_error <- inherits(cond, "error")
[18:04:40.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:40.083]                   NULL)
[18:04:40.083]                 if (is_error) {
[18:04:40.083]                   sessionInformation <- function() {
[18:04:40.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:40.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:40.083]                       search = base::search(), system = base::Sys.info())
[18:04:40.083]                   }
[18:04:40.083]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:40.083]                     cond$call), session = sessionInformation(), 
[18:04:40.083]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:40.083]                   signalCondition(cond)
[18:04:40.083]                 }
[18:04:40.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:40.083]                 "immediateCondition"))) {
[18:04:40.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:40.083]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:40.083]                   if (TRUE && !signal) {
[18:04:40.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.083]                     {
[18:04:40.083]                       inherits <- base::inherits
[18:04:40.083]                       invokeRestart <- base::invokeRestart
[18:04:40.083]                       is.null <- base::is.null
[18:04:40.083]                       muffled <- FALSE
[18:04:40.083]                       if (inherits(cond, "message")) {
[18:04:40.083]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.083]                         if (muffled) 
[18:04:40.083]                           invokeRestart("muffleMessage")
[18:04:40.083]                       }
[18:04:40.083]                       else if (inherits(cond, "warning")) {
[18:04:40.083]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.083]                         if (muffled) 
[18:04:40.083]                           invokeRestart("muffleWarning")
[18:04:40.083]                       }
[18:04:40.083]                       else if (inherits(cond, "condition")) {
[18:04:40.083]                         if (!is.null(pattern)) {
[18:04:40.083]                           computeRestarts <- base::computeRestarts
[18:04:40.083]                           grepl <- base::grepl
[18:04:40.083]                           restarts <- computeRestarts(cond)
[18:04:40.083]                           for (restart in restarts) {
[18:04:40.083]                             name <- restart$name
[18:04:40.083]                             if (is.null(name)) 
[18:04:40.083]                               next
[18:04:40.083]                             if (!grepl(pattern, name)) 
[18:04:40.083]                               next
[18:04:40.083]                             invokeRestart(restart)
[18:04:40.083]                             muffled <- TRUE
[18:04:40.083]                             break
[18:04:40.083]                           }
[18:04:40.083]                         }
[18:04:40.083]                       }
[18:04:40.083]                       invisible(muffled)
[18:04:40.083]                     }
[18:04:40.083]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.083]                   }
[18:04:40.083]                 }
[18:04:40.083]                 else {
[18:04:40.083]                   if (TRUE) {
[18:04:40.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.083]                     {
[18:04:40.083]                       inherits <- base::inherits
[18:04:40.083]                       invokeRestart <- base::invokeRestart
[18:04:40.083]                       is.null <- base::is.null
[18:04:40.083]                       muffled <- FALSE
[18:04:40.083]                       if (inherits(cond, "message")) {
[18:04:40.083]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.083]                         if (muffled) 
[18:04:40.083]                           invokeRestart("muffleMessage")
[18:04:40.083]                       }
[18:04:40.083]                       else if (inherits(cond, "warning")) {
[18:04:40.083]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.083]                         if (muffled) 
[18:04:40.083]                           invokeRestart("muffleWarning")
[18:04:40.083]                       }
[18:04:40.083]                       else if (inherits(cond, "condition")) {
[18:04:40.083]                         if (!is.null(pattern)) {
[18:04:40.083]                           computeRestarts <- base::computeRestarts
[18:04:40.083]                           grepl <- base::grepl
[18:04:40.083]                           restarts <- computeRestarts(cond)
[18:04:40.083]                           for (restart in restarts) {
[18:04:40.083]                             name <- restart$name
[18:04:40.083]                             if (is.null(name)) 
[18:04:40.083]                               next
[18:04:40.083]                             if (!grepl(pattern, name)) 
[18:04:40.083]                               next
[18:04:40.083]                             invokeRestart(restart)
[18:04:40.083]                             muffled <- TRUE
[18:04:40.083]                             break
[18:04:40.083]                           }
[18:04:40.083]                         }
[18:04:40.083]                       }
[18:04:40.083]                       invisible(muffled)
[18:04:40.083]                     }
[18:04:40.083]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.083]                   }
[18:04:40.083]                 }
[18:04:40.083]             }
[18:04:40.083]         }))
[18:04:40.083]     }, error = function(ex) {
[18:04:40.083]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:40.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.083]                 ...future.rng), started = ...future.startTime, 
[18:04:40.083]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:40.083]             version = "1.8"), class = "FutureResult")
[18:04:40.083]     }, finally = {
[18:04:40.083]         if (!identical(...future.workdir, getwd())) 
[18:04:40.083]             setwd(...future.workdir)
[18:04:40.083]         {
[18:04:40.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:40.083]                 ...future.oldOptions$nwarnings <- NULL
[18:04:40.083]             }
[18:04:40.083]             base::options(...future.oldOptions)
[18:04:40.083]             if (.Platform$OS.type == "windows") {
[18:04:40.083]                 old_names <- names(...future.oldEnvVars)
[18:04:40.083]                 envs <- base::Sys.getenv()
[18:04:40.083]                 names <- names(envs)
[18:04:40.083]                 common <- intersect(names, old_names)
[18:04:40.083]                 added <- setdiff(names, old_names)
[18:04:40.083]                 removed <- setdiff(old_names, names)
[18:04:40.083]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:40.083]                   envs[common]]
[18:04:40.083]                 NAMES <- toupper(changed)
[18:04:40.083]                 args <- list()
[18:04:40.083]                 for (kk in seq_along(NAMES)) {
[18:04:40.083]                   name <- changed[[kk]]
[18:04:40.083]                   NAME <- NAMES[[kk]]
[18:04:40.083]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.083]                     next
[18:04:40.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.083]                 }
[18:04:40.083]                 NAMES <- toupper(added)
[18:04:40.083]                 for (kk in seq_along(NAMES)) {
[18:04:40.083]                   name <- added[[kk]]
[18:04:40.083]                   NAME <- NAMES[[kk]]
[18:04:40.083]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.083]                     next
[18:04:40.083]                   args[[name]] <- ""
[18:04:40.083]                 }
[18:04:40.083]                 NAMES <- toupper(removed)
[18:04:40.083]                 for (kk in seq_along(NAMES)) {
[18:04:40.083]                   name <- removed[[kk]]
[18:04:40.083]                   NAME <- NAMES[[kk]]
[18:04:40.083]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.083]                     next
[18:04:40.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.083]                 }
[18:04:40.083]                 if (length(args) > 0) 
[18:04:40.083]                   base::do.call(base::Sys.setenv, args = args)
[18:04:40.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:40.083]             }
[18:04:40.083]             else {
[18:04:40.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:40.083]             }
[18:04:40.083]             {
[18:04:40.083]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:40.083]                   0L) {
[18:04:40.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:40.083]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:40.083]                   base::options(opts)
[18:04:40.083]                 }
[18:04:40.083]                 {
[18:04:40.083]                   {
[18:04:40.083]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:40.083]                     NULL
[18:04:40.083]                   }
[18:04:40.083]                   options(future.plan = NULL)
[18:04:40.083]                   if (is.na(NA_character_)) 
[18:04:40.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:40.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:40.083]                     .init = FALSE)
[18:04:40.083]                 }
[18:04:40.083]             }
[18:04:40.083]         }
[18:04:40.083]     })
[18:04:40.083]     if (TRUE) {
[18:04:40.083]         base::sink(type = "output", split = FALSE)
[18:04:40.083]         if (TRUE) {
[18:04:40.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:40.083]         }
[18:04:40.083]         else {
[18:04:40.083]             ...future.result["stdout"] <- base::list(NULL)
[18:04:40.083]         }
[18:04:40.083]         base::close(...future.stdout)
[18:04:40.083]         ...future.stdout <- NULL
[18:04:40.083]     }
[18:04:40.083]     ...future.result$conditions <- ...future.conditions
[18:04:40.083]     ...future.result$finished <- base::Sys.time()
[18:04:40.083]     ...future.result
[18:04:40.083] }
[18:04:40.088] assign_globals() ...
[18:04:40.088] List of 1
[18:04:40.088]  $ data:'data.frame':	5 obs. of  2 variables:
[18:04:40.088]   ..$ x: int [1:5] 1 2 3 4 5
[18:04:40.088]   ..$ y: int [1:5] 1 2 3 4 5
[18:04:40.088]  - attr(*, "where")=List of 1
[18:04:40.088]   ..$ data:<environment: R_EmptyEnv> 
[18:04:40.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:40.088]  - attr(*, "resolved")= logi FALSE
[18:04:40.088]  - attr(*, "total_size")= num 160
[18:04:40.088]  - attr(*, "already-done")= logi TRUE
[18:04:40.098] - copied ‘data’ to environment
[18:04:40.099] assign_globals() ... done
[18:04:40.099] requestCore(): workers = 2
[18:04:40.102] MulticoreFuture started
[18:04:40.103] - Launch lazy future ... done
[18:04:40.104] run() for ‘MulticoreFuture’ ... done
[18:04:40.104] plan(): Setting new future strategy stack:
[18:04:40.105] result() for MulticoreFuture ...
[18:04:40.105] List of future strategies:
[18:04:40.105] 1. sequential:
[18:04:40.105]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:40.105]    - tweaked: FALSE
[18:04:40.105]    - call: NULL
[18:04:40.108] plan(): nbrOfWorkers() = 1
[18:04:40.113] plan(): Setting new future strategy stack:
[18:04:40.113] List of future strategies:
[18:04:40.113] 1. multicore:
[18:04:40.113]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:40.113]    - tweaked: FALSE
[18:04:40.113]    - call: plan(strategy)
[18:04:40.122] plan(): nbrOfWorkers() = 2
[18:04:40.124] result() for MulticoreFuture ...
[18:04:40.124] result() for MulticoreFuture ... done
[18:04:40.125] result() for MulticoreFuture ... done
[18:04:40.125] result() for MulticoreFuture ...
[18:04:40.125] result() for MulticoreFuture ... done
[18:04:40.126] plan(): Setting new future strategy stack:
[18:04:40.126] List of future strategies:
[18:04:40.126] 1. sequential:
[18:04:40.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:40.126]    - tweaked: FALSE
[18:04:40.126]    - call: plan(list(sequential, strategy))
[18:04:40.126] 2. multicore:
[18:04:40.126]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:40.126]    - tweaked: FALSE
[18:04:40.126]    - call: plan(list(sequential, strategy))
[18:04:40.128] plan(): nbrOfWorkers() = 1
[18:04:40.129] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:40.129] Searching for globals...
[18:04:40.137] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[18:04:40.138] Searching for globals ... DONE
[18:04:40.138] Resolving globals: FALSE
[18:04:40.139] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:40.140] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:40.141] - globals: [1] ‘data’
[18:04:40.141] - packages: [1] ‘future’
[18:04:40.141] getGlobalsAndPackages() ... DONE
[18:04:40.142] run() for ‘Future’ ...
[18:04:40.142] - state: ‘created’
[18:04:40.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:40.143] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:40.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:40.144]   - Field: ‘label’
[18:04:40.144]   - Field: ‘local’
[18:04:40.144]   - Field: ‘owner’
[18:04:40.144]   - Field: ‘envir’
[18:04:40.145]   - Field: ‘packages’
[18:04:40.145]   - Field: ‘gc’
[18:04:40.145]   - Field: ‘conditions’
[18:04:40.145]   - Field: ‘expr’
[18:04:40.145]   - Field: ‘uuid’
[18:04:40.146]   - Field: ‘seed’
[18:04:40.146]   - Field: ‘version’
[18:04:40.146]   - Field: ‘result’
[18:04:40.146]   - Field: ‘asynchronous’
[18:04:40.147]   - Field: ‘calls’
[18:04:40.147]   - Field: ‘globals’
[18:04:40.147]   - Field: ‘stdout’
[18:04:40.147]   - Field: ‘earlySignal’
[18:04:40.147]   - Field: ‘lazy’
[18:04:40.148]   - Field: ‘state’
[18:04:40.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:40.148] - Launch lazy future ...
[18:04:40.149] Packages needed by the future expression (n = 1): ‘future’
[18:04:40.149] Packages needed by future strategies (n = 1): ‘future’
[18:04:40.150] {
[18:04:40.150]     {
[18:04:40.150]         {
[18:04:40.150]             ...future.startTime <- base::Sys.time()
[18:04:40.150]             {
[18:04:40.150]                 {
[18:04:40.150]                   {
[18:04:40.150]                     {
[18:04:40.150]                       base::local({
[18:04:40.150]                         has_future <- base::requireNamespace("future", 
[18:04:40.150]                           quietly = TRUE)
[18:04:40.150]                         if (has_future) {
[18:04:40.150]                           ns <- base::getNamespace("future")
[18:04:40.150]                           version <- ns[[".package"]][["version"]]
[18:04:40.150]                           if (is.null(version)) 
[18:04:40.150]                             version <- utils::packageVersion("future")
[18:04:40.150]                         }
[18:04:40.150]                         else {
[18:04:40.150]                           version <- NULL
[18:04:40.150]                         }
[18:04:40.150]                         if (!has_future || version < "1.8.0") {
[18:04:40.150]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:40.150]                             "", base::R.version$version.string), 
[18:04:40.150]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:40.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:40.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:40.150]                               "release", "version")], collapse = " "), 
[18:04:40.150]                             hostname = base::Sys.info()[["nodename"]])
[18:04:40.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:40.150]                             info)
[18:04:40.150]                           info <- base::paste(info, collapse = "; ")
[18:04:40.150]                           if (!has_future) {
[18:04:40.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:40.150]                               info)
[18:04:40.150]                           }
[18:04:40.150]                           else {
[18:04:40.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:40.150]                               info, version)
[18:04:40.150]                           }
[18:04:40.150]                           base::stop(msg)
[18:04:40.150]                         }
[18:04:40.150]                       })
[18:04:40.150]                     }
[18:04:40.150]                     base::local({
[18:04:40.150]                       for (pkg in "future") {
[18:04:40.150]                         base::loadNamespace(pkg)
[18:04:40.150]                         base::library(pkg, character.only = TRUE)
[18:04:40.150]                       }
[18:04:40.150]                     })
[18:04:40.150]                   }
[18:04:40.150]                   ...future.strategy.old <- future::plan("list")
[18:04:40.150]                   options(future.plan = NULL)
[18:04:40.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.150]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[18:04:40.150]                     envir = parent.frame()) 
[18:04:40.150]                   {
[18:04:40.150]                     default_workers <- missing(workers)
[18:04:40.150]                     if (is.function(workers)) 
[18:04:40.150]                       workers <- workers()
[18:04:40.150]                     workers <- structure(as.integer(workers), 
[18:04:40.150]                       class = class(workers))
[18:04:40.150]                     stop_if_not(is.finite(workers), workers >= 
[18:04:40.150]                       1L)
[18:04:40.150]                     if ((workers == 1L && !inherits(workers, 
[18:04:40.150]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[18:04:40.150]                       if (default_workers) 
[18:04:40.150]                         supportsMulticore(warn = TRUE)
[18:04:40.150]                       return(sequential(..., envir = envir))
[18:04:40.150]                     }
[18:04:40.150]                     oopts <- options(mc.cores = workers)
[18:04:40.150]                     on.exit(options(oopts))
[18:04:40.150]                     future <- MulticoreFuture(..., workers = workers, 
[18:04:40.150]                       envir = envir)
[18:04:40.150]                     if (!future$lazy) 
[18:04:40.150]                       future <- run(future)
[18:04:40.150]                     invisible(future)
[18:04:40.150]                   }), .cleanup = FALSE, .init = FALSE)
[18:04:40.150]                 }
[18:04:40.150]                 ...future.workdir <- getwd()
[18:04:40.150]             }
[18:04:40.150]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:40.150]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:40.150]         }
[18:04:40.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:40.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:40.150]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:40.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:40.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:40.150]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:40.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:40.150]             base::names(...future.oldOptions))
[18:04:40.150]     }
[18:04:40.150]     if (FALSE) {
[18:04:40.150]     }
[18:04:40.150]     else {
[18:04:40.150]         if (TRUE) {
[18:04:40.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:40.150]                 open = "w")
[18:04:40.150]         }
[18:04:40.150]         else {
[18:04:40.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:40.150]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:40.150]         }
[18:04:40.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:40.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:40.150]             base::sink(type = "output", split = FALSE)
[18:04:40.150]             base::close(...future.stdout)
[18:04:40.150]         }, add = TRUE)
[18:04:40.150]     }
[18:04:40.150]     ...future.frame <- base::sys.nframe()
[18:04:40.150]     ...future.conditions <- base::list()
[18:04:40.150]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:40.150]     if (FALSE) {
[18:04:40.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:40.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:40.150]     }
[18:04:40.150]     ...future.result <- base::tryCatch({
[18:04:40.150]         base::withCallingHandlers({
[18:04:40.150]             ...future.value <- base::withVisible(base::local({
[18:04:40.150]                 a %<-% subset(data, x < 3)$y
[18:04:40.150]                 a
[18:04:40.150]             }))
[18:04:40.150]             future::FutureResult(value = ...future.value$value, 
[18:04:40.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.150]                   ...future.rng), globalenv = if (FALSE) 
[18:04:40.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:40.150]                     ...future.globalenv.names))
[18:04:40.150]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:40.150]         }, condition = base::local({
[18:04:40.150]             c <- base::c
[18:04:40.150]             inherits <- base::inherits
[18:04:40.150]             invokeRestart <- base::invokeRestart
[18:04:40.150]             length <- base::length
[18:04:40.150]             list <- base::list
[18:04:40.150]             seq.int <- base::seq.int
[18:04:40.150]             signalCondition <- base::signalCondition
[18:04:40.150]             sys.calls <- base::sys.calls
[18:04:40.150]             `[[` <- base::`[[`
[18:04:40.150]             `+` <- base::`+`
[18:04:40.150]             `<<-` <- base::`<<-`
[18:04:40.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:40.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:40.150]                   3L)]
[18:04:40.150]             }
[18:04:40.150]             function(cond) {
[18:04:40.150]                 is_error <- inherits(cond, "error")
[18:04:40.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:40.150]                   NULL)
[18:04:40.150]                 if (is_error) {
[18:04:40.150]                   sessionInformation <- function() {
[18:04:40.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:40.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:40.150]                       search = base::search(), system = base::Sys.info())
[18:04:40.150]                   }
[18:04:40.150]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:40.150]                     cond$call), session = sessionInformation(), 
[18:04:40.150]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:40.150]                   signalCondition(cond)
[18:04:40.150]                 }
[18:04:40.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:40.150]                 "immediateCondition"))) {
[18:04:40.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:40.150]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:40.150]                   if (TRUE && !signal) {
[18:04:40.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.150]                     {
[18:04:40.150]                       inherits <- base::inherits
[18:04:40.150]                       invokeRestart <- base::invokeRestart
[18:04:40.150]                       is.null <- base::is.null
[18:04:40.150]                       muffled <- FALSE
[18:04:40.150]                       if (inherits(cond, "message")) {
[18:04:40.150]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.150]                         if (muffled) 
[18:04:40.150]                           invokeRestart("muffleMessage")
[18:04:40.150]                       }
[18:04:40.150]                       else if (inherits(cond, "warning")) {
[18:04:40.150]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.150]                         if (muffled) 
[18:04:40.150]                           invokeRestart("muffleWarning")
[18:04:40.150]                       }
[18:04:40.150]                       else if (inherits(cond, "condition")) {
[18:04:40.150]                         if (!is.null(pattern)) {
[18:04:40.150]                           computeRestarts <- base::computeRestarts
[18:04:40.150]                           grepl <- base::grepl
[18:04:40.150]                           restarts <- computeRestarts(cond)
[18:04:40.150]                           for (restart in restarts) {
[18:04:40.150]                             name <- restart$name
[18:04:40.150]                             if (is.null(name)) 
[18:04:40.150]                               next
[18:04:40.150]                             if (!grepl(pattern, name)) 
[18:04:40.150]                               next
[18:04:40.150]                             invokeRestart(restart)
[18:04:40.150]                             muffled <- TRUE
[18:04:40.150]                             break
[18:04:40.150]                           }
[18:04:40.150]                         }
[18:04:40.150]                       }
[18:04:40.150]                       invisible(muffled)
[18:04:40.150]                     }
[18:04:40.150]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.150]                   }
[18:04:40.150]                 }
[18:04:40.150]                 else {
[18:04:40.150]                   if (TRUE) {
[18:04:40.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.150]                     {
[18:04:40.150]                       inherits <- base::inherits
[18:04:40.150]                       invokeRestart <- base::invokeRestart
[18:04:40.150]                       is.null <- base::is.null
[18:04:40.150]                       muffled <- FALSE
[18:04:40.150]                       if (inherits(cond, "message")) {
[18:04:40.150]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.150]                         if (muffled) 
[18:04:40.150]                           invokeRestart("muffleMessage")
[18:04:40.150]                       }
[18:04:40.150]                       else if (inherits(cond, "warning")) {
[18:04:40.150]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.150]                         if (muffled) 
[18:04:40.150]                           invokeRestart("muffleWarning")
[18:04:40.150]                       }
[18:04:40.150]                       else if (inherits(cond, "condition")) {
[18:04:40.150]                         if (!is.null(pattern)) {
[18:04:40.150]                           computeRestarts <- base::computeRestarts
[18:04:40.150]                           grepl <- base::grepl
[18:04:40.150]                           restarts <- computeRestarts(cond)
[18:04:40.150]                           for (restart in restarts) {
[18:04:40.150]                             name <- restart$name
[18:04:40.150]                             if (is.null(name)) 
[18:04:40.150]                               next
[18:04:40.150]                             if (!grepl(pattern, name)) 
[18:04:40.150]                               next
[18:04:40.150]                             invokeRestart(restart)
[18:04:40.150]                             muffled <- TRUE
[18:04:40.150]                             break
[18:04:40.150]                           }
[18:04:40.150]                         }
[18:04:40.150]                       }
[18:04:40.150]                       invisible(muffled)
[18:04:40.150]                     }
[18:04:40.150]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.150]                   }
[18:04:40.150]                 }
[18:04:40.150]             }
[18:04:40.150]         }))
[18:04:40.150]     }, error = function(ex) {
[18:04:40.150]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:40.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.150]                 ...future.rng), started = ...future.startTime, 
[18:04:40.150]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:40.150]             version = "1.8"), class = "FutureResult")
[18:04:40.150]     }, finally = {
[18:04:40.150]         if (!identical(...future.workdir, getwd())) 
[18:04:40.150]             setwd(...future.workdir)
[18:04:40.150]         {
[18:04:40.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:40.150]                 ...future.oldOptions$nwarnings <- NULL
[18:04:40.150]             }
[18:04:40.150]             base::options(...future.oldOptions)
[18:04:40.150]             if (.Platform$OS.type == "windows") {
[18:04:40.150]                 old_names <- names(...future.oldEnvVars)
[18:04:40.150]                 envs <- base::Sys.getenv()
[18:04:40.150]                 names <- names(envs)
[18:04:40.150]                 common <- intersect(names, old_names)
[18:04:40.150]                 added <- setdiff(names, old_names)
[18:04:40.150]                 removed <- setdiff(old_names, names)
[18:04:40.150]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:40.150]                   envs[common]]
[18:04:40.150]                 NAMES <- toupper(changed)
[18:04:40.150]                 args <- list()
[18:04:40.150]                 for (kk in seq_along(NAMES)) {
[18:04:40.150]                   name <- changed[[kk]]
[18:04:40.150]                   NAME <- NAMES[[kk]]
[18:04:40.150]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.150]                     next
[18:04:40.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.150]                 }
[18:04:40.150]                 NAMES <- toupper(added)
[18:04:40.150]                 for (kk in seq_along(NAMES)) {
[18:04:40.150]                   name <- added[[kk]]
[18:04:40.150]                   NAME <- NAMES[[kk]]
[18:04:40.150]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.150]                     next
[18:04:40.150]                   args[[name]] <- ""
[18:04:40.150]                 }
[18:04:40.150]                 NAMES <- toupper(removed)
[18:04:40.150]                 for (kk in seq_along(NAMES)) {
[18:04:40.150]                   name <- removed[[kk]]
[18:04:40.150]                   NAME <- NAMES[[kk]]
[18:04:40.150]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.150]                     next
[18:04:40.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.150]                 }
[18:04:40.150]                 if (length(args) > 0) 
[18:04:40.150]                   base::do.call(base::Sys.setenv, args = args)
[18:04:40.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:40.150]             }
[18:04:40.150]             else {
[18:04:40.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:40.150]             }
[18:04:40.150]             {
[18:04:40.150]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:40.150]                   0L) {
[18:04:40.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:40.150]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:40.150]                   base::options(opts)
[18:04:40.150]                 }
[18:04:40.150]                 {
[18:04:40.150]                   {
[18:04:40.150]                     NULL
[18:04:40.150]                     RNGkind("Mersenne-Twister")
[18:04:40.150]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:40.150]                       inherits = FALSE)
[18:04:40.150]                   }
[18:04:40.150]                   options(future.plan = NULL)
[18:04:40.150]                   if (is.na(NA_character_)) 
[18:04:40.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:40.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:40.150]                     .init = FALSE)
[18:04:40.150]                 }
[18:04:40.150]             }
[18:04:40.150]         }
[18:04:40.150]     })
[18:04:40.150]     if (TRUE) {
[18:04:40.150]         base::sink(type = "output", split = FALSE)
[18:04:40.150]         if (TRUE) {
[18:04:40.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:40.150]         }
[18:04:40.150]         else {
[18:04:40.150]             ...future.result["stdout"] <- base::list(NULL)
[18:04:40.150]         }
[18:04:40.150]         base::close(...future.stdout)
[18:04:40.150]         ...future.stdout <- NULL
[18:04:40.150]     }
[18:04:40.150]     ...future.result$conditions <- ...future.conditions
[18:04:40.150]     ...future.result$finished <- base::Sys.time()
[18:04:40.150]     ...future.result
[18:04:40.150] }
[18:04:40.154] assign_globals() ...
[18:04:40.154] List of 1
[18:04:40.154]  $ data:'data.frame':	5 obs. of  2 variables:
[18:04:40.154]   ..$ x: int [1:5] 1 2 3 4 5
[18:04:40.154]   ..$ y: int [1:5] 1 2 3 4 5
[18:04:40.154]  - attr(*, "where")=List of 1
[18:04:40.154]   ..$ data:<environment: R_EmptyEnv> 
[18:04:40.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:40.154]  - attr(*, "resolved")= logi FALSE
[18:04:40.154]  - attr(*, "total_size")= num 160
[18:04:40.154]  - attr(*, "already-done")= logi TRUE
[18:04:40.162] - copied ‘data’ to environment
[18:04:40.162] assign_globals() ... done
[18:04:40.163] plan(): Setting new future strategy stack:
[18:04:40.163] List of future strategies:
[18:04:40.163] 1. multicore:
[18:04:40.163]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:40.163]    - tweaked: FALSE
[18:04:40.163]    - call: plan(list(sequential, strategy))
[18:04:40.170] plan(): nbrOfWorkers() = 2
[18:04:40.269] plan(): Setting new future strategy stack:
[18:04:40.269] List of future strategies:
[18:04:40.269] 1. sequential:
[18:04:40.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:40.269]    - tweaked: FALSE
[18:04:40.269]    - call: plan(list(sequential, strategy))
[18:04:40.269] 2. multicore:
[18:04:40.269]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:04:40.269]    - tweaked: FALSE
[18:04:40.269]    - call: plan(list(sequential, strategy))
[18:04:40.271] plan(): nbrOfWorkers() = 1
[18:04:40.271] SequentialFuture started (and completed)
[18:04:40.272] signalConditions() ...
[18:04:40.272]  - include = ‘immediateCondition’
[18:04:40.272]  - exclude = 
[18:04:40.272]  - resignal = FALSE
[18:04:40.273]  - Number of conditions: 56
[18:04:40.273] signalConditions() ... done
[18:04:40.273] - Launch lazy future ... done
[18:04:40.274] run() for ‘SequentialFuture’ ... done
[18:04:40.274] signalConditions() ...
[18:04:40.274]  - include = ‘immediateCondition’
[18:04:40.274]  - exclude = 
[18:04:40.275]  - resignal = FALSE
[18:04:40.275]  - Number of conditions: 56
[18:04:40.275] signalConditions() ... done
[18:04:40.276] Future state: ‘finished’
[18:04:40.276] signalConditions() ...
[18:04:40.276]  - include = ‘condition’
[18:04:40.276]  - exclude = ‘immediateCondition’
[18:04:40.277]  - resignal = TRUE
[18:04:40.277]  - Number of conditions: 56
[18:04:40.277]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.171] getGlobalsAndPackages() ...
[18:04:40.277]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:40.278]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.204] Searching for globals...
[18:04:40.278]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.207] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[18:04:40.278]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.207] Searching for globals ... DONE
[18:04:40.279]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.207] Resolving globals: FALSE
[18:04:40.279]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.208] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:40.280]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.209] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:40.280]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.209] - globals: [1] ‘data’
[18:04:40.280]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.209] 
[18:04:40.281]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.210] getGlobalsAndPackages() ... DONE
[18:04:40.281]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.210] run() for ‘Future’ ...
[18:04:40.281]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.210] - state: ‘created’
[18:04:40.282]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.211] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:04:40.282]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.217] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:40.282]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:04:40.283]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.218]   - Field: ‘label’
[18:04:40.283]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.218]   - Field: ‘local’
[18:04:40.283]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.218]   - Field: ‘owner’
[18:04:40.284]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.219]   - Field: ‘envir’
[18:04:40.284]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.219]   - Field: ‘workers’
[18:04:40.285]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.219]   - Field: ‘packages’
[18:04:40.285]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.219]   - Field: ‘gc’
[18:04:40.285]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.220]   - Field: ‘job’
[18:04:40.286]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.220]   - Field: ‘conditions’
[18:04:40.286]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.220]   - Field: ‘expr’
[18:04:40.287]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.220]   - Field: ‘uuid’
[18:04:40.287]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.220]   - Field: ‘seed’
[18:04:40.287]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.221]   - Field: ‘version’
[18:04:40.288]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.221]   - Field: ‘result’
[18:04:40.288]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.221]   - Field: ‘asynchronous’
[18:04:40.288]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.221]   - Field: ‘calls’
[18:04:40.289]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.222]   - Field: ‘globals’
[18:04:40.289]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.222]   - Field: ‘stdout’
[18:04:40.289]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.222]   - Field: ‘earlySignal’
[18:04:40.290]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.222]   - Field: ‘lazy’
[18:04:40.290]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.223]   - Field: ‘state’
[18:04:40.290]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.223] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:04:40.291]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.223] - Launch lazy future ...
[18:04:40.291]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.224] Packages needed by the future expression (n = 0): <none>
[18:04:40.291]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.224] Packages needed by future strategies (n = 0): <none>
[18:04:40.292]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.225] {
[18:04:40.225]     {
[18:04:40.225]         {
[18:04:40.225]             ...future.startTime <- base::Sys.time()
[18:04:40.225]             {
[18:04:40.225]                 {
[18:04:40.225]                   {
[18:04:40.225]                     {
[18:04:40.225]                       base::local({
[18:04:40.225]                         has_future <- base::requireNamespace("future", 
[18:04:40.225]                           quietly = TRUE)
[18:04:40.225]                         if (has_future) {
[18:04:40.225]                           ns <- base::getNamespace("future")
[18:04:40.225]                           version <- ns[[".package"]][["version"]]
[18:04:40.225]                           if (is.null(version)) 
[18:04:40.225]                             version <- utils::packageVersion("future")
[18:04:40.225]                         }
[18:04:40.225]                         else {
[18:04:40.225]                           version <- NULL
[18:04:40.225]                         }
[18:04:40.225]                         if (!has_future || version < "1.8.0") {
[18:04:40.225]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:40.225]                             "", base::R.version$version.string), 
[18:04:40.225]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:40.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:40.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:40.225]                               "release", "version")], collapse = " "), 
[18:04:40.225]                             hostname = base::Sys.info()[["nodename"]])
[18:04:40.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:40.225]                             info)
[18:04:40.225]                           info <- base::paste(info, collapse = "; ")
[18:04:40.225]                           if (!has_future) {
[18:04:40.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:40.225]                               info)
[18:04:40.225]                           }
[18:04:40.225]                           else {
[18:04:40.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:40.225]                               info, version)
[18:04:40.225]                           }
[18:04:40.225]                           base::stop(msg)
[18:04:40.225]                         }
[18:04:40.225]                       })
[18:04:40.225]                     }
[18:04:40.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:40.225]                     base::options(mc.cores = 1L)
[18:04:40.225]                   }
[18:04:40.225]                   ...future.strategy.old <- future::plan("list")
[18:04:40.225]                   options(future.plan = NULL)
[18:04:40.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:40.225]                 }
[18:04:40.225]                 ...future.workdir <- getwd()
[18:04:40.225]             }
[18:04:40.225]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:40.225]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:40.225]         }
[18:04:40.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:40.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:40.225]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:40.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:40.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:40.225]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:40.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:40.225]             base::names(...future.oldOptions))
[18:04:40.225]     }
[18:04:40.225]     if (FALSE) {
[18:04:40.225]     }
[18:04:40.225]     else {
[18:04:40.225]         if (TRUE) {
[18:04:40.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:40.225]                 open = "w")
[18:04:40.225]         }
[18:04:40.225]         else {
[18:04:40.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:40.225]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:40.225]         }
[18:04:40.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:40.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:40.225]             base::sink(type = "output", split = FALSE)
[18:04:40.225]             base::close(...future.stdout)
[18:04:40.225]         }, add = TRUE)
[18:04:40.225]     }
[18:04:40.225]     ...future.frame <- base::sys.nframe()
[18:04:40.225]     ...future.conditions <- base::list()
[18:04:40.225]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:40.225]     if (FALSE) {
[18:04:40.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:40.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:40.225]     }
[18:04:40.225]     ...future.result <- base::tryCatch({
[18:04:40.225]         base::withCallingHandlers({
[18:04:40.225]             ...future.value <- base::withVisible(base::local({
[18:04:40.225]                 withCallingHandlers({
[18:04:40.225]                   subset(data, x < 3)$y
[18:04:40.225]                 }, immediateCondition = function(cond) {
[18:04:40.225]                   save_rds <- function (object, pathname, ...) 
[18:04:40.225]                   {
[18:04:40.225]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:04:40.225]                     if (file_test("-f", pathname_tmp)) {
[18:04:40.225]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.225]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:04:40.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.225]                         fi_tmp[["mtime"]])
[18:04:40.225]                     }
[18:04:40.225]                     tryCatch({
[18:04:40.225]                       saveRDS(object, file = pathname_tmp, ...)
[18:04:40.225]                     }, error = function(ex) {
[18:04:40.225]                       msg <- conditionMessage(ex)
[18:04:40.225]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.225]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:04:40.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.225]                         fi_tmp[["mtime"]], msg)
[18:04:40.225]                       ex$message <- msg
[18:04:40.225]                       stop(ex)
[18:04:40.225]                     })
[18:04:40.225]                     stopifnot(file_test("-f", pathname_tmp))
[18:04:40.225]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:04:40.225]                     if (!res || file_test("-f", pathname_tmp)) {
[18:04:40.225]                       fi_tmp <- file.info(pathname_tmp)
[18:04:40.225]                       fi <- file.info(pathname)
[18:04:40.225]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:04:40.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:04:40.225]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:04:40.225]                         fi[["size"]], fi[["mtime"]])
[18:04:40.225]                       stop(msg)
[18:04:40.225]                     }
[18:04:40.225]                     invisible(pathname)
[18:04:40.225]                   }
[18:04:40.225]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:04:40.225]                     rootPath = tempdir()) 
[18:04:40.225]                   {
[18:04:40.225]                     obj <- list(time = Sys.time(), condition = cond)
[18:04:40.225]                     file <- tempfile(pattern = class(cond)[1], 
[18:04:40.225]                       tmpdir = path, fileext = ".rds")
[18:04:40.225]                     save_rds(obj, file)
[18:04:40.225]                   }
[18:04:40.225]                   saveImmediateCondition(cond, path = "/tmp/RtmpmRLBA8/.future/immediateConditions")
[18:04:40.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.225]                   {
[18:04:40.225]                     inherits <- base::inherits
[18:04:40.225]                     invokeRestart <- base::invokeRestart
[18:04:40.225]                     is.null <- base::is.null
[18:04:40.225]                     muffled <- FALSE
[18:04:40.225]                     if (inherits(cond, "message")) {
[18:04:40.225]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:40.225]                       if (muffled) 
[18:04:40.225]                         invokeRestart("muffleMessage")
[18:04:40.225]                     }
[18:04:40.225]                     else if (inherits(cond, "warning")) {
[18:04:40.225]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:40.225]                       if (muffled) 
[18:04:40.225]                         invokeRestart("muffleWarning")
[18:04:40.225]                     }
[18:04:40.225]                     else if (inherits(cond, "condition")) {
[18:04:40.225]                       if (!is.null(pattern)) {
[18:04:40.225]                         computeRestarts <- base::computeRestarts
[18:04:40.225]                         grepl <- base::grepl
[18:04:40.225]                         restarts <- computeRestarts(cond)
[18:04:40.225]                         for (restart in restarts) {
[18:04:40.225]                           name <- restart$name
[18:04:40.225]                           if (is.null(name)) 
[18:04:40.225]                             next
[18:04:40.225]                           if (!grepl(pattern, name)) 
[18:04:40.225]                             next
[18:04:40.225]                           invokeRestart(restart)
[18:04:40.225]                           muffled <- TRUE
[18:04:40.225]                           break
[18:04:40.225]                         }
[18:04:40.225]                       }
[18:04:40.225]                     }
[18:04:40.225]                     invisible(muffled)
[18:04:40.225]                   }
[18:04:40.225]                   muffleCondition(cond)
[18:04:40.225]                 })
[18:04:40.225]             }))
[18:04:40.225]             future::FutureResult(value = ...future.value$value, 
[18:04:40.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.225]                   ...future.rng), globalenv = if (FALSE) 
[18:04:40.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:40.225]                     ...future.globalenv.names))
[18:04:40.225]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:40.225]         }, condition = base::local({
[18:04:40.225]             c <- base::c
[18:04:40.225]             inherits <- base::inherits
[18:04:40.225]             invokeRestart <- base::invokeRestart
[18:04:40.225]             length <- base::length
[18:04:40.225]             list <- base::list
[18:04:40.225]             seq.int <- base::seq.int
[18:04:40.225]             signalCondition <- base::signalCondition
[18:04:40.225]             sys.calls <- base::sys.calls
[18:04:40.225]             `[[` <- base::`[[`
[18:04:40.225]             `+` <- base::`+`
[18:04:40.225]             `<<-` <- base::`<<-`
[18:04:40.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:40.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:40.225]                   3L)]
[18:04:40.225]             }
[18:04:40.225]             function(cond) {
[18:04:40.225]                 is_error <- inherits(cond, "error")
[18:04:40.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:40.225]                   NULL)
[18:04:40.225]                 if (is_error) {
[18:04:40.225]                   sessionInformation <- function() {
[18:04:40.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:40.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:40.225]                       search = base::search(), system = base::Sys.info())
[18:04:40.225]                   }
[18:04:40.225]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:40.225]                     cond$call), session = sessionInformation(), 
[18:04:40.225]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:40.225]                   signalCondition(cond)
[18:04:40.225]                 }
[18:04:40.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:40.225]                 "immediateCondition"))) {
[18:04:40.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:40.225]                   ...future.conditions[[length(...future.conditions) + 
[18:04:40.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:40.225]                   if (TRUE && !signal) {
[18:04:40.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.225]                     {
[18:04:40.225]                       inherits <- base::inherits
[18:04:40.225]                       invokeRestart <- base::invokeRestart
[18:04:40.225]                       is.null <- base::is.null
[18:04:40.225]                       muffled <- FALSE
[18:04:40.225]                       if (inherits(cond, "message")) {
[18:04:40.225]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.225]                         if (muffled) 
[18:04:40.225]                           invokeRestart("muffleMessage")
[18:04:40.225]                       }
[18:04:40.225]                       else if (inherits(cond, "warning")) {
[18:04:40.225]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.225]                         if (muffled) 
[18:04:40.225]                           invokeRestart("muffleWarning")
[18:04:40.225]                       }
[18:04:40.225]                       else if (inherits(cond, "condition")) {
[18:04:40.225]                         if (!is.null(pattern)) {
[18:04:40.225]                           computeRestarts <- base::computeRestarts
[18:04:40.225]                           grepl <- base::grepl
[18:04:40.225]                           restarts <- computeRestarts(cond)
[18:04:40.225]                           for (restart in restarts) {
[18:04:40.225]                             name <- restart$name
[18:04:40.225]                             if (is.null(name)) 
[18:04:40.225]                               next
[18:04:40.225]                             if (!grepl(pattern, name)) 
[18:04:40.225]                               next
[18:04:40.225]                             invokeRestart(restart)
[18:04:40.225]                             muffled <- TRUE
[18:04:40.225]                             break
[18:04:40.225]                           }
[18:04:40.225]                         }
[18:04:40.225]                       }
[18:04:40.225]                       invisible(muffled)
[18:04:40.225]                     }
[18:04:40.225]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.225]                   }
[18:04:40.225]                 }
[18:04:40.225]                 else {
[18:04:40.225]                   if (TRUE) {
[18:04:40.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:40.225]                     {
[18:04:40.225]                       inherits <- base::inherits
[18:04:40.225]                       invokeRestart <- base::invokeRestart
[18:04:40.225]                       is.null <- base::is.null
[18:04:40.225]                       muffled <- FALSE
[18:04:40.225]                       if (inherits(cond, "message")) {
[18:04:40.225]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:40.225]                         if (muffled) 
[18:04:40.225]                           invokeRestart("muffleMessage")
[18:04:40.225]                       }
[18:04:40.225]                       else if (inherits(cond, "warning")) {
[18:04:40.225]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:40.225]                         if (muffled) 
[18:04:40.225]                           invokeRestart("muffleWarning")
[18:04:40.225]                       }
[18:04:40.225]                       else if (inherits(cond, "condition")) {
[18:04:40.225]                         if (!is.null(pattern)) {
[18:04:40.225]                           computeRestarts <- base::computeRestarts
[18:04:40.225]                           grepl <- base::grepl
[18:04:40.225]                           restarts <- computeRestarts(cond)
[18:04:40.225]                           for (restart in restarts) {
[18:04:40.225]                             name <- restart$name
[18:04:40.225]                             if (is.null(name)) 
[18:04:40.225]                               next
[18:04:40.225]                             if (!grepl(pattern, name)) 
[18:04:40.225]                               next
[18:04:40.225]                             invokeRestart(restart)
[18:04:40.225]                             muffled <- TRUE
[18:04:40.225]                             break
[18:04:40.225]                           }
[18:04:40.225]                         }
[18:04:40.225]                       }
[18:04:40.225]                       invisible(muffled)
[18:04:40.225]                     }
[18:04:40.225]                     muffleCondition(cond, pattern = "^muffle")
[18:04:40.225]                   }
[18:04:40.225]                 }
[18:04:40.225]             }
[18:04:40.225]         }))
[18:04:40.225]     }, error = function(ex) {
[18:04:40.225]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:40.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:40.225]                 ...future.rng), started = ...future.startTime, 
[18:04:40.225]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:40.225]             version = "1.8"), class = "FutureResult")
[18:04:40.225]     }, finally = {
[18:04:40.225]         if (!identical(...future.workdir, getwd())) 
[18:04:40.225]             setwd(...future.workdir)
[18:04:40.225]         {
[18:04:40.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:40.225]                 ...future.oldOptions$nwarnings <- NULL
[18:04:40.225]             }
[18:04:40.225]             base::options(...future.oldOptions)
[18:04:40.225]             if (.Platform$OS.type == "windows") {
[18:04:40.225]                 old_names <- names(...future.oldEnvVars)
[18:04:40.225]                 envs <- base::Sys.getenv()
[18:04:40.225]                 names <- names(envs)
[18:04:40.225]                 common <- intersect(names, old_names)
[18:04:40.225]                 added <- setdiff(names, old_names)
[18:04:40.225]                 removed <- setdiff(old_names, names)
[18:04:40.225]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:40.225]                   envs[common]]
[18:04:40.225]                 NAMES <- toupper(changed)
[18:04:40.225]                 args <- list()
[18:04:40.225]                 for (kk in seq_along(NAMES)) {
[18:04:40.225]                   name <- changed[[kk]]
[18:04:40.225]                   NAME <- NAMES[[kk]]
[18:04:40.225]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.225]                     next
[18:04:40.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.225]                 }
[18:04:40.225]                 NAMES <- toupper(added)
[18:04:40.225]                 for (kk in seq_along(NAMES)) {
[18:04:40.225]                   name <- added[[kk]]
[18:04:40.225]                   NAME <- NAMES[[kk]]
[18:04:40.225]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.225]                     next
[18:04:40.225]                   args[[name]] <- ""
[18:04:40.225]                 }
[18:04:40.225]                 NAMES <- toupper(removed)
[18:04:40.225]                 for (kk in seq_along(NAMES)) {
[18:04:40.225]                   name <- removed[[kk]]
[18:04:40.225]                   NAME <- NAMES[[kk]]
[18:04:40.225]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:40.225]                     next
[18:04:40.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:40.225]                 }
[18:04:40.225]                 if (length(args) > 0) 
[18:04:40.225]                   base::do.call(base::Sys.setenv, args = args)
[18:04:40.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:40.225]             }
[18:04:40.225]             else {
[18:04:40.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:40.225]             }
[18:04:40.225]             {
[18:04:40.225]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:40.225]                   0L) {
[18:04:40.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:40.225]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:40.225]                   base::options(opts)
[18:04:40.225]                 }
[18:04:40.225]                 {
[18:04:40.225]                   {
[18:04:40.225]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:40.225]                     NULL
[18:04:40.225]                   }
[18:04:40.225]                   options(future.plan = NULL)
[18:04:40.225]                   if (is.na(NA_character_)) 
[18:04:40.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:40.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:40.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:40.225]                     .init = FALSE)
[18:04:40.225]                 }
[18:04:40.225]             }
[18:04:40.225]         }
[18:04:40.225]     })
[18:04:40.225]     if (TRUE) {
[18:04:40.225]         base::sink(type = "output", split = FALSE)
[18:04:40.225]         if (TRUE) {
[18:04:40.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:40.225]         }
[18:04:40.225]         else {
[18:04:40.225]             ...future.result["stdout"] <- base::list(NULL)
[18:04:40.225]         }
[18:04:40.225]         base::close(...future.stdout)
[18:04:40.225]         ...future.stdout <- NULL
[18:04:40.225]     }
[18:04:40.225]     ...future.result$conditions <- ...future.conditions
[18:04:40.225]     ...future.result$finished <- base::Sys.time()
[18:04:40.225]     ...future.result
[18:04:40.225] }
[18:04:40.292]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.229] assign_globals() ...
[18:04:40.292]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.229] List of 1
[18:04:40.229]  $ data:'data.frame':	5 obs. of  2 variables:
[18:04:40.229]   ..$ x: int [1:5] 1 2 3 4 5
[18:04:40.229]   ..$ y: int [1:5] 1 2 3 4 5
[18:04:40.229]  - attr(*, "where")=List of 1
[18:04:40.229]   ..$ data:<environment: R_EmptyEnv> 
[18:04:40.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:40.229]  - attr(*, "resolved")= logi FALSE
[18:04:40.229]  - attr(*, "total_size")= num 160
[18:04:40.229]  - attr(*, "already-done")= logi TRUE
[18:04:40.293]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.238] - copied ‘data’ to environment
[18:04:40.293]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.238] assign_globals() ... done
[18:04:40.294]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.239] requestCore(): workers = 2
[18:04:40.294]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.242] MulticoreFuture started
[18:04:40.294]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.243] - Launch lazy future ... done
[18:04:40.295]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.244] run() for ‘MulticoreFuture’ ... done
[18:04:40.295]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.245] result() for MulticoreFuture ...
[18:04:40.295]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.266] result() for MulticoreFuture ...
[18:04:40.296]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.266] result() for MulticoreFuture ... done
[18:04:40.296]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.267] result() for MulticoreFuture ... done
[18:04:40.296]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.267] result() for MulticoreFuture ...
[18:04:40.297]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:40.268] result() for MulticoreFuture ... done
[18:04:40.297] signalConditions() ... done
- Strategy: multicore ... DONE
- Strategy: multisession ...
[18:04:40.298] plan(): Setting new future strategy stack:
[18:04:40.298] List of future strategies:
[18:04:40.298] 1. multisession:
[18:04:40.298]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:40.298]    - tweaked: FALSE
[18:04:40.298]    - call: plan(strategy)
[18:04:40.299] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:04:40.299] multisession:
[18:04:40.299] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:40.299] - tweaked: FALSE
[18:04:40.299] - call: plan(strategy)
[18:04:40.310] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:40.310] Not searching for globals
[18:04:40.311] - globals: [0] <none>
[18:04:40.311] getGlobalsAndPackages() ... DONE
[18:04:40.312] [local output] makeClusterPSOCK() ...
[18:04:40.374] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:40.376] [local output] Base port: 11589
[18:04:40.377] [local output] Getting setup options for 2 cluster nodes ...
[18:04:40.377] [local output]  - Node 1 of 2 ...
[18:04:40.378] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:40.379] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpmRLBA8/worker.rank=1.parallelly.parent=323968.4f1806d5df356.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpmRLBA8/worker.rank=1.parallelly.parent=323968.4f1806d5df356.pid")'’
[18:04:40.635] - Possible to infer worker's PID: TRUE
[18:04:40.636] [local output] Rscript port: 11589

[18:04:40.637] [local output]  - Node 2 of 2 ...
[18:04:40.637] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:40.638] [local output] Rscript port: 11589

[18:04:40.639] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:40.639] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:40.640] [local output] Setting up PSOCK nodes in parallel
[18:04:40.641] List of 36
[18:04:40.641]  $ worker          : chr "localhost"
[18:04:40.641]   ..- attr(*, "localhost")= logi TRUE
[18:04:40.641]  $ master          : chr "localhost"
[18:04:40.641]  $ port            : int 11589
[18:04:40.641]  $ connectTimeout  : num 120
[18:04:40.641]  $ timeout         : num 2592000
[18:04:40.641]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:40.641]  $ homogeneous     : logi TRUE
[18:04:40.641]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:40.641]  $ rscript_envs    : NULL
[18:04:40.641]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:40.641]  $ rscript_startup : NULL
[18:04:40.641]  $ rscript_sh      : chr "sh"
[18:04:40.641]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:40.641]  $ methods         : logi TRUE
[18:04:40.641]  $ socketOptions   : chr "no-delay"
[18:04:40.641]  $ useXDR          : logi FALSE
[18:04:40.641]  $ outfile         : chr "/dev/null"
[18:04:40.641]  $ renice          : int NA
[18:04:40.641]  $ rshcmd          : NULL
[18:04:40.641]  $ user            : chr(0) 
[18:04:40.641]  $ revtunnel       : logi FALSE
[18:04:40.641]  $ rshlogfile      : NULL
[18:04:40.641]  $ rshopts         : chr(0) 
[18:04:40.641]  $ rank            : int 1
[18:04:40.641]  $ manual          : logi FALSE
[18:04:40.641]  $ dryrun          : logi FALSE
[18:04:40.641]  $ quiet           : logi FALSE
[18:04:40.641]  $ setup_strategy  : chr "parallel"
[18:04:40.641]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:40.641]  $ pidfile         : chr "/tmp/RtmpmRLBA8/worker.rank=1.parallelly.parent=323968.4f1806d5df356.pid"
[18:04:40.641]  $ rshcmd_label    : NULL
[18:04:40.641]  $ rsh_call        : NULL
[18:04:40.641]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:40.641]  $ localMachine    : logi TRUE
[18:04:40.641]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:40.641]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:40.641]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:40.641]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:40.641]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:40.641]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:40.641]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:40.641]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:40.641]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:40.641]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:40.641]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:40.641]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:40.641]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:40.641]  $ arguments       :List of 28
[18:04:40.641]   ..$ worker          : chr "localhost"
[18:04:40.641]   ..$ master          : NULL
[18:04:40.641]   ..$ port            : int 11589
[18:04:40.641]   ..$ connectTimeout  : num 120
[18:04:40.641]   ..$ timeout         : num 2592000
[18:04:40.641]   ..$ rscript         : NULL
[18:04:40.641]   ..$ homogeneous     : NULL
[18:04:40.641]   ..$ rscript_args    : NULL
[18:04:40.641]   ..$ rscript_envs    : NULL
[18:04:40.641]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:40.641]   ..$ rscript_startup : NULL
[18:04:40.641]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:40.641]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:40.641]   ..$ methods         : logi TRUE
[18:04:40.641]   ..$ socketOptions   : chr "no-delay"
[18:04:40.641]   ..$ useXDR          : logi FALSE
[18:04:40.641]   ..$ outfile         : chr "/dev/null"
[18:04:40.641]   ..$ renice          : int NA
[18:04:40.641]   ..$ rshcmd          : NULL
[18:04:40.641]   ..$ user            : NULL
[18:04:40.641]   ..$ revtunnel       : logi NA
[18:04:40.641]   ..$ rshlogfile      : NULL
[18:04:40.641]   ..$ rshopts         : NULL
[18:04:40.641]   ..$ rank            : int 1
[18:04:40.641]   ..$ manual          : logi FALSE
[18:04:40.641]   ..$ dryrun          : logi FALSE
[18:04:40.641]   ..$ quiet           : logi FALSE
[18:04:40.641]   ..$ setup_strategy  : chr "parallel"
[18:04:40.641]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:40.674] [local output] System call to launch all workers:
[18:04:40.674] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpmRLBA8/worker.rank=1.parallelly.parent=323968.4f1806d5df356.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11589 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:40.674] [local output] Starting PSOCK main server
[18:04:40.683] [local output] Workers launched
[18:04:40.683] [local output] Waiting for workers to connect back
[18:04:40.683]  - [local output] 0 workers out of 2 ready
[18:04:41.041]  - [local output] 0 workers out of 2 ready
[18:04:41.042]  - [local output] 1 workers out of 2 ready
[18:04:41.042]  - [local output] 2 workers out of 2 ready
[18:04:41.042] [local output] Launching of workers completed
[18:04:41.043] [local output] Collecting session information from workers
[18:04:41.044] [local output]  - Worker #1 of 2
[18:04:41.046] [local output]  - Worker #2 of 2
[18:04:41.046] [local output] makeClusterPSOCK() ... done
[18:04:41.067] Packages needed by the future expression (n = 0): <none>
[18:04:41.067] Packages needed by future strategies (n = 0): <none>
[18:04:41.068] {
[18:04:41.068]     {
[18:04:41.068]         {
[18:04:41.068]             ...future.startTime <- base::Sys.time()
[18:04:41.068]             {
[18:04:41.068]                 {
[18:04:41.068]                   {
[18:04:41.068]                     {
[18:04:41.068]                       base::local({
[18:04:41.068]                         has_future <- base::requireNamespace("future", 
[18:04:41.068]                           quietly = TRUE)
[18:04:41.068]                         if (has_future) {
[18:04:41.068]                           ns <- base::getNamespace("future")
[18:04:41.068]                           version <- ns[[".package"]][["version"]]
[18:04:41.068]                           if (is.null(version)) 
[18:04:41.068]                             version <- utils::packageVersion("future")
[18:04:41.068]                         }
[18:04:41.068]                         else {
[18:04:41.068]                           version <- NULL
[18:04:41.068]                         }
[18:04:41.068]                         if (!has_future || version < "1.8.0") {
[18:04:41.068]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:41.068]                             "", base::R.version$version.string), 
[18:04:41.068]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:41.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:41.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:41.068]                               "release", "version")], collapse = " "), 
[18:04:41.068]                             hostname = base::Sys.info()[["nodename"]])
[18:04:41.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:41.068]                             info)
[18:04:41.068]                           info <- base::paste(info, collapse = "; ")
[18:04:41.068]                           if (!has_future) {
[18:04:41.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:41.068]                               info)
[18:04:41.068]                           }
[18:04:41.068]                           else {
[18:04:41.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:41.068]                               info, version)
[18:04:41.068]                           }
[18:04:41.068]                           base::stop(msg)
[18:04:41.068]                         }
[18:04:41.068]                       })
[18:04:41.068]                     }
[18:04:41.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:41.068]                     base::options(mc.cores = 1L)
[18:04:41.068]                   }
[18:04:41.068]                   ...future.strategy.old <- future::plan("list")
[18:04:41.068]                   options(future.plan = NULL)
[18:04:41.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:41.068]                 }
[18:04:41.068]                 ...future.workdir <- getwd()
[18:04:41.068]             }
[18:04:41.068]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:41.068]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:41.068]         }
[18:04:41.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:41.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:41.068]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:41.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:41.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:41.068]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:41.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:41.068]             base::names(...future.oldOptions))
[18:04:41.068]     }
[18:04:41.068]     if (FALSE) {
[18:04:41.068]     }
[18:04:41.068]     else {
[18:04:41.068]         if (TRUE) {
[18:04:41.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:41.068]                 open = "w")
[18:04:41.068]         }
[18:04:41.068]         else {
[18:04:41.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:41.068]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:41.068]         }
[18:04:41.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:41.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:41.068]             base::sink(type = "output", split = FALSE)
[18:04:41.068]             base::close(...future.stdout)
[18:04:41.068]         }, add = TRUE)
[18:04:41.068]     }
[18:04:41.068]     ...future.frame <- base::sys.nframe()
[18:04:41.068]     ...future.conditions <- base::list()
[18:04:41.068]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:41.068]     if (FALSE) {
[18:04:41.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:41.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:41.068]     }
[18:04:41.068]     ...future.result <- base::tryCatch({
[18:04:41.068]         base::withCallingHandlers({
[18:04:41.068]             ...future.value <- base::withVisible(base::local({
[18:04:41.068]                 ...future.makeSendCondition <- base::local({
[18:04:41.068]                   sendCondition <- NULL
[18:04:41.068]                   function(frame = 1L) {
[18:04:41.068]                     if (is.function(sendCondition)) 
[18:04:41.068]                       return(sendCondition)
[18:04:41.068]                     ns <- getNamespace("parallel")
[18:04:41.068]                     if (exists("sendData", mode = "function", 
[18:04:41.068]                       envir = ns)) {
[18:04:41.068]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:41.068]                         envir = ns)
[18:04:41.068]                       envir <- sys.frame(frame)
[18:04:41.068]                       master <- NULL
[18:04:41.068]                       while (!identical(envir, .GlobalEnv) && 
[18:04:41.068]                         !identical(envir, emptyenv())) {
[18:04:41.068]                         if (exists("master", mode = "list", envir = envir, 
[18:04:41.068]                           inherits = FALSE)) {
[18:04:41.068]                           master <- get("master", mode = "list", 
[18:04:41.068]                             envir = envir, inherits = FALSE)
[18:04:41.068]                           if (inherits(master, c("SOCKnode", 
[18:04:41.068]                             "SOCK0node"))) {
[18:04:41.068]                             sendCondition <<- function(cond) {
[18:04:41.068]                               data <- list(type = "VALUE", value = cond, 
[18:04:41.068]                                 success = TRUE)
[18:04:41.068]                               parallel_sendData(master, data)
[18:04:41.068]                             }
[18:04:41.068]                             return(sendCondition)
[18:04:41.068]                           }
[18:04:41.068]                         }
[18:04:41.068]                         frame <- frame + 1L
[18:04:41.068]                         envir <- sys.frame(frame)
[18:04:41.068]                       }
[18:04:41.068]                     }
[18:04:41.068]                     sendCondition <<- function(cond) NULL
[18:04:41.068]                   }
[18:04:41.068]                 })
[18:04:41.068]                 withCallingHandlers({
[18:04:41.068]                   NA
[18:04:41.068]                 }, immediateCondition = function(cond) {
[18:04:41.068]                   sendCondition <- ...future.makeSendCondition()
[18:04:41.068]                   sendCondition(cond)
[18:04:41.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.068]                   {
[18:04:41.068]                     inherits <- base::inherits
[18:04:41.068]                     invokeRestart <- base::invokeRestart
[18:04:41.068]                     is.null <- base::is.null
[18:04:41.068]                     muffled <- FALSE
[18:04:41.068]                     if (inherits(cond, "message")) {
[18:04:41.068]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:41.068]                       if (muffled) 
[18:04:41.068]                         invokeRestart("muffleMessage")
[18:04:41.068]                     }
[18:04:41.068]                     else if (inherits(cond, "warning")) {
[18:04:41.068]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:41.068]                       if (muffled) 
[18:04:41.068]                         invokeRestart("muffleWarning")
[18:04:41.068]                     }
[18:04:41.068]                     else if (inherits(cond, "condition")) {
[18:04:41.068]                       if (!is.null(pattern)) {
[18:04:41.068]                         computeRestarts <- base::computeRestarts
[18:04:41.068]                         grepl <- base::grepl
[18:04:41.068]                         restarts <- computeRestarts(cond)
[18:04:41.068]                         for (restart in restarts) {
[18:04:41.068]                           name <- restart$name
[18:04:41.068]                           if (is.null(name)) 
[18:04:41.068]                             next
[18:04:41.068]                           if (!grepl(pattern, name)) 
[18:04:41.068]                             next
[18:04:41.068]                           invokeRestart(restart)
[18:04:41.068]                           muffled <- TRUE
[18:04:41.068]                           break
[18:04:41.068]                         }
[18:04:41.068]                       }
[18:04:41.068]                     }
[18:04:41.068]                     invisible(muffled)
[18:04:41.068]                   }
[18:04:41.068]                   muffleCondition(cond)
[18:04:41.068]                 })
[18:04:41.068]             }))
[18:04:41.068]             future::FutureResult(value = ...future.value$value, 
[18:04:41.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.068]                   ...future.rng), globalenv = if (FALSE) 
[18:04:41.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:41.068]                     ...future.globalenv.names))
[18:04:41.068]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:41.068]         }, condition = base::local({
[18:04:41.068]             c <- base::c
[18:04:41.068]             inherits <- base::inherits
[18:04:41.068]             invokeRestart <- base::invokeRestart
[18:04:41.068]             length <- base::length
[18:04:41.068]             list <- base::list
[18:04:41.068]             seq.int <- base::seq.int
[18:04:41.068]             signalCondition <- base::signalCondition
[18:04:41.068]             sys.calls <- base::sys.calls
[18:04:41.068]             `[[` <- base::`[[`
[18:04:41.068]             `+` <- base::`+`
[18:04:41.068]             `<<-` <- base::`<<-`
[18:04:41.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:41.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:41.068]                   3L)]
[18:04:41.068]             }
[18:04:41.068]             function(cond) {
[18:04:41.068]                 is_error <- inherits(cond, "error")
[18:04:41.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:41.068]                   NULL)
[18:04:41.068]                 if (is_error) {
[18:04:41.068]                   sessionInformation <- function() {
[18:04:41.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:41.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:41.068]                       search = base::search(), system = base::Sys.info())
[18:04:41.068]                   }
[18:04:41.068]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:41.068]                     cond$call), session = sessionInformation(), 
[18:04:41.068]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:41.068]                   signalCondition(cond)
[18:04:41.068]                 }
[18:04:41.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:41.068]                 "immediateCondition"))) {
[18:04:41.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:41.068]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:41.068]                   if (TRUE && !signal) {
[18:04:41.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.068]                     {
[18:04:41.068]                       inherits <- base::inherits
[18:04:41.068]                       invokeRestart <- base::invokeRestart
[18:04:41.068]                       is.null <- base::is.null
[18:04:41.068]                       muffled <- FALSE
[18:04:41.068]                       if (inherits(cond, "message")) {
[18:04:41.068]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.068]                         if (muffled) 
[18:04:41.068]                           invokeRestart("muffleMessage")
[18:04:41.068]                       }
[18:04:41.068]                       else if (inherits(cond, "warning")) {
[18:04:41.068]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.068]                         if (muffled) 
[18:04:41.068]                           invokeRestart("muffleWarning")
[18:04:41.068]                       }
[18:04:41.068]                       else if (inherits(cond, "condition")) {
[18:04:41.068]                         if (!is.null(pattern)) {
[18:04:41.068]                           computeRestarts <- base::computeRestarts
[18:04:41.068]                           grepl <- base::grepl
[18:04:41.068]                           restarts <- computeRestarts(cond)
[18:04:41.068]                           for (restart in restarts) {
[18:04:41.068]                             name <- restart$name
[18:04:41.068]                             if (is.null(name)) 
[18:04:41.068]                               next
[18:04:41.068]                             if (!grepl(pattern, name)) 
[18:04:41.068]                               next
[18:04:41.068]                             invokeRestart(restart)
[18:04:41.068]                             muffled <- TRUE
[18:04:41.068]                             break
[18:04:41.068]                           }
[18:04:41.068]                         }
[18:04:41.068]                       }
[18:04:41.068]                       invisible(muffled)
[18:04:41.068]                     }
[18:04:41.068]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.068]                   }
[18:04:41.068]                 }
[18:04:41.068]                 else {
[18:04:41.068]                   if (TRUE) {
[18:04:41.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.068]                     {
[18:04:41.068]                       inherits <- base::inherits
[18:04:41.068]                       invokeRestart <- base::invokeRestart
[18:04:41.068]                       is.null <- base::is.null
[18:04:41.068]                       muffled <- FALSE
[18:04:41.068]                       if (inherits(cond, "message")) {
[18:04:41.068]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.068]                         if (muffled) 
[18:04:41.068]                           invokeRestart("muffleMessage")
[18:04:41.068]                       }
[18:04:41.068]                       else if (inherits(cond, "warning")) {
[18:04:41.068]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.068]                         if (muffled) 
[18:04:41.068]                           invokeRestart("muffleWarning")
[18:04:41.068]                       }
[18:04:41.068]                       else if (inherits(cond, "condition")) {
[18:04:41.068]                         if (!is.null(pattern)) {
[18:04:41.068]                           computeRestarts <- base::computeRestarts
[18:04:41.068]                           grepl <- base::grepl
[18:04:41.068]                           restarts <- computeRestarts(cond)
[18:04:41.068]                           for (restart in restarts) {
[18:04:41.068]                             name <- restart$name
[18:04:41.068]                             if (is.null(name)) 
[18:04:41.068]                               next
[18:04:41.068]                             if (!grepl(pattern, name)) 
[18:04:41.068]                               next
[18:04:41.068]                             invokeRestart(restart)
[18:04:41.068]                             muffled <- TRUE
[18:04:41.068]                             break
[18:04:41.068]                           }
[18:04:41.068]                         }
[18:04:41.068]                       }
[18:04:41.068]                       invisible(muffled)
[18:04:41.068]                     }
[18:04:41.068]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.068]                   }
[18:04:41.068]                 }
[18:04:41.068]             }
[18:04:41.068]         }))
[18:04:41.068]     }, error = function(ex) {
[18:04:41.068]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:41.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.068]                 ...future.rng), started = ...future.startTime, 
[18:04:41.068]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:41.068]             version = "1.8"), class = "FutureResult")
[18:04:41.068]     }, finally = {
[18:04:41.068]         if (!identical(...future.workdir, getwd())) 
[18:04:41.068]             setwd(...future.workdir)
[18:04:41.068]         {
[18:04:41.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:41.068]                 ...future.oldOptions$nwarnings <- NULL
[18:04:41.068]             }
[18:04:41.068]             base::options(...future.oldOptions)
[18:04:41.068]             if (.Platform$OS.type == "windows") {
[18:04:41.068]                 old_names <- names(...future.oldEnvVars)
[18:04:41.068]                 envs <- base::Sys.getenv()
[18:04:41.068]                 names <- names(envs)
[18:04:41.068]                 common <- intersect(names, old_names)
[18:04:41.068]                 added <- setdiff(names, old_names)
[18:04:41.068]                 removed <- setdiff(old_names, names)
[18:04:41.068]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:41.068]                   envs[common]]
[18:04:41.068]                 NAMES <- toupper(changed)
[18:04:41.068]                 args <- list()
[18:04:41.068]                 for (kk in seq_along(NAMES)) {
[18:04:41.068]                   name <- changed[[kk]]
[18:04:41.068]                   NAME <- NAMES[[kk]]
[18:04:41.068]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.068]                     next
[18:04:41.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.068]                 }
[18:04:41.068]                 NAMES <- toupper(added)
[18:04:41.068]                 for (kk in seq_along(NAMES)) {
[18:04:41.068]                   name <- added[[kk]]
[18:04:41.068]                   NAME <- NAMES[[kk]]
[18:04:41.068]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.068]                     next
[18:04:41.068]                   args[[name]] <- ""
[18:04:41.068]                 }
[18:04:41.068]                 NAMES <- toupper(removed)
[18:04:41.068]                 for (kk in seq_along(NAMES)) {
[18:04:41.068]                   name <- removed[[kk]]
[18:04:41.068]                   NAME <- NAMES[[kk]]
[18:04:41.068]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.068]                     next
[18:04:41.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.068]                 }
[18:04:41.068]                 if (length(args) > 0) 
[18:04:41.068]                   base::do.call(base::Sys.setenv, args = args)
[18:04:41.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:41.068]             }
[18:04:41.068]             else {
[18:04:41.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:41.068]             }
[18:04:41.068]             {
[18:04:41.068]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:41.068]                   0L) {
[18:04:41.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:41.068]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:41.068]                   base::options(opts)
[18:04:41.068]                 }
[18:04:41.068]                 {
[18:04:41.068]                   {
[18:04:41.068]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:41.068]                     NULL
[18:04:41.068]                   }
[18:04:41.068]                   options(future.plan = NULL)
[18:04:41.068]                   if (is.na(NA_character_)) 
[18:04:41.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:41.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:41.068]                     .init = FALSE)
[18:04:41.068]                 }
[18:04:41.068]             }
[18:04:41.068]         }
[18:04:41.068]     })
[18:04:41.068]     if (TRUE) {
[18:04:41.068]         base::sink(type = "output", split = FALSE)
[18:04:41.068]         if (TRUE) {
[18:04:41.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:41.068]         }
[18:04:41.068]         else {
[18:04:41.068]             ...future.result["stdout"] <- base::list(NULL)
[18:04:41.068]         }
[18:04:41.068]         base::close(...future.stdout)
[18:04:41.068]         ...future.stdout <- NULL
[18:04:41.068]     }
[18:04:41.068]     ...future.result$conditions <- ...future.conditions
[18:04:41.068]     ...future.result$finished <- base::Sys.time()
[18:04:41.068]     ...future.result
[18:04:41.068] }
[18:04:41.169] MultisessionFuture started
[18:04:41.170] result() for ClusterFuture ...
[18:04:41.170] receiveMessageFromWorker() for ClusterFuture ...
[18:04:41.171] - Validating connection of MultisessionFuture
[18:04:41.233] - received message: FutureResult
[18:04:41.234] - Received FutureResult
[18:04:41.234] - Erased future from FutureRegistry
[18:04:41.235] result() for ClusterFuture ...
[18:04:41.235] - result already collected: FutureResult
[18:04:41.235] result() for ClusterFuture ... done
[18:04:41.236] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:41.236] result() for ClusterFuture ... done
[18:04:41.236] result() for ClusterFuture ...
[18:04:41.237] - result already collected: FutureResult
[18:04:41.237] result() for ClusterFuture ... done
[18:04:41.237] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:04:41.245] plan(): nbrOfWorkers() = 2
[18:04:41.246] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:41.247] Searching for globals...
[18:04:41.248] - globals found: [1] ‘getOption’
[18:04:41.249] Searching for globals ... DONE
[18:04:41.249] Resolving globals: FALSE
[18:04:41.250] 
[18:04:41.250] 
[18:04:41.250] getGlobalsAndPackages() ... DONE
[18:04:41.251] run() for ‘Future’ ...
[18:04:41.251] - state: ‘created’
[18:04:41.252] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:41.281] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:41.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:41.282]   - Field: ‘node’
[18:04:41.282]   - Field: ‘label’
[18:04:41.282]   - Field: ‘local’
[18:04:41.283]   - Field: ‘owner’
[18:04:41.283]   - Field: ‘envir’
[18:04:41.283]   - Field: ‘workers’
[18:04:41.283]   - Field: ‘packages’
[18:04:41.284]   - Field: ‘gc’
[18:04:41.284]   - Field: ‘conditions’
[18:04:41.284]   - Field: ‘persistent’
[18:04:41.284]   - Field: ‘expr’
[18:04:41.285]   - Field: ‘uuid’
[18:04:41.285]   - Field: ‘seed’
[18:04:41.285]   - Field: ‘version’
[18:04:41.285]   - Field: ‘result’
[18:04:41.286]   - Field: ‘asynchronous’
[18:04:41.286]   - Field: ‘calls’
[18:04:41.286]   - Field: ‘globals’
[18:04:41.287]   - Field: ‘stdout’
[18:04:41.287]   - Field: ‘earlySignal’
[18:04:41.287]   - Field: ‘lazy’
[18:04:41.287]   - Field: ‘state’
[18:04:41.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:41.288] - Launch lazy future ...
[18:04:41.289] Packages needed by the future expression (n = 0): <none>
[18:04:41.289] Packages needed by future strategies (n = 0): <none>
[18:04:41.290] {
[18:04:41.290]     {
[18:04:41.290]         {
[18:04:41.290]             ...future.startTime <- base::Sys.time()
[18:04:41.290]             {
[18:04:41.290]                 {
[18:04:41.290]                   {
[18:04:41.290]                     {
[18:04:41.290]                       base::local({
[18:04:41.290]                         has_future <- base::requireNamespace("future", 
[18:04:41.290]                           quietly = TRUE)
[18:04:41.290]                         if (has_future) {
[18:04:41.290]                           ns <- base::getNamespace("future")
[18:04:41.290]                           version <- ns[[".package"]][["version"]]
[18:04:41.290]                           if (is.null(version)) 
[18:04:41.290]                             version <- utils::packageVersion("future")
[18:04:41.290]                         }
[18:04:41.290]                         else {
[18:04:41.290]                           version <- NULL
[18:04:41.290]                         }
[18:04:41.290]                         if (!has_future || version < "1.8.0") {
[18:04:41.290]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:41.290]                             "", base::R.version$version.string), 
[18:04:41.290]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:41.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:41.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:41.290]                               "release", "version")], collapse = " "), 
[18:04:41.290]                             hostname = base::Sys.info()[["nodename"]])
[18:04:41.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:41.290]                             info)
[18:04:41.290]                           info <- base::paste(info, collapse = "; ")
[18:04:41.290]                           if (!has_future) {
[18:04:41.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:41.290]                               info)
[18:04:41.290]                           }
[18:04:41.290]                           else {
[18:04:41.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:41.290]                               info, version)
[18:04:41.290]                           }
[18:04:41.290]                           base::stop(msg)
[18:04:41.290]                         }
[18:04:41.290]                       })
[18:04:41.290]                     }
[18:04:41.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:41.290]                     base::options(mc.cores = 1L)
[18:04:41.290]                   }
[18:04:41.290]                   ...future.strategy.old <- future::plan("list")
[18:04:41.290]                   options(future.plan = NULL)
[18:04:41.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:41.290]                 }
[18:04:41.290]                 ...future.workdir <- getwd()
[18:04:41.290]             }
[18:04:41.290]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:41.290]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:41.290]         }
[18:04:41.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[18:04:41.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:41.290]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[18:04:41.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:41.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:41.290]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:41.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:41.290]             base::names(...future.oldOptions))
[18:04:41.290]     }
[18:04:41.290]     if (FALSE) {
[18:04:41.290]     }
[18:04:41.290]     else {
[18:04:41.290]         if (TRUE) {
[18:04:41.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:41.290]                 open = "w")
[18:04:41.290]         }
[18:04:41.290]         else {
[18:04:41.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:41.290]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:41.290]         }
[18:04:41.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:41.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:41.290]             base::sink(type = "output", split = FALSE)
[18:04:41.290]             base::close(...future.stdout)
[18:04:41.290]         }, add = TRUE)
[18:04:41.290]     }
[18:04:41.290]     ...future.frame <- base::sys.nframe()
[18:04:41.290]     ...future.conditions <- base::list()
[18:04:41.290]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:41.290]     if (FALSE) {
[18:04:41.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:41.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:41.290]     }
[18:04:41.290]     ...future.result <- base::tryCatch({
[18:04:41.290]         base::withCallingHandlers({
[18:04:41.290]             ...future.value <- base::withVisible(base::local({
[18:04:41.290]                 ...future.makeSendCondition <- base::local({
[18:04:41.290]                   sendCondition <- NULL
[18:04:41.290]                   function(frame = 1L) {
[18:04:41.290]                     if (is.function(sendCondition)) 
[18:04:41.290]                       return(sendCondition)
[18:04:41.290]                     ns <- getNamespace("parallel")
[18:04:41.290]                     if (exists("sendData", mode = "function", 
[18:04:41.290]                       envir = ns)) {
[18:04:41.290]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:41.290]                         envir = ns)
[18:04:41.290]                       envir <- sys.frame(frame)
[18:04:41.290]                       master <- NULL
[18:04:41.290]                       while (!identical(envir, .GlobalEnv) && 
[18:04:41.290]                         !identical(envir, emptyenv())) {
[18:04:41.290]                         if (exists("master", mode = "list", envir = envir, 
[18:04:41.290]                           inherits = FALSE)) {
[18:04:41.290]                           master <- get("master", mode = "list", 
[18:04:41.290]                             envir = envir, inherits = FALSE)
[18:04:41.290]                           if (inherits(master, c("SOCKnode", 
[18:04:41.290]                             "SOCK0node"))) {
[18:04:41.290]                             sendCondition <<- function(cond) {
[18:04:41.290]                               data <- list(type = "VALUE", value = cond, 
[18:04:41.290]                                 success = TRUE)
[18:04:41.290]                               parallel_sendData(master, data)
[18:04:41.290]                             }
[18:04:41.290]                             return(sendCondition)
[18:04:41.290]                           }
[18:04:41.290]                         }
[18:04:41.290]                         frame <- frame + 1L
[18:04:41.290]                         envir <- sys.frame(frame)
[18:04:41.290]                       }
[18:04:41.290]                     }
[18:04:41.290]                     sendCondition <<- function(cond) NULL
[18:04:41.290]                   }
[18:04:41.290]                 })
[18:04:41.290]                 withCallingHandlers({
[18:04:41.290]                   getOption("future.globals.onMissing")
[18:04:41.290]                 }, immediateCondition = function(cond) {
[18:04:41.290]                   sendCondition <- ...future.makeSendCondition()
[18:04:41.290]                   sendCondition(cond)
[18:04:41.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.290]                   {
[18:04:41.290]                     inherits <- base::inherits
[18:04:41.290]                     invokeRestart <- base::invokeRestart
[18:04:41.290]                     is.null <- base::is.null
[18:04:41.290]                     muffled <- FALSE
[18:04:41.290]                     if (inherits(cond, "message")) {
[18:04:41.290]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:41.290]                       if (muffled) 
[18:04:41.290]                         invokeRestart("muffleMessage")
[18:04:41.290]                     }
[18:04:41.290]                     else if (inherits(cond, "warning")) {
[18:04:41.290]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:41.290]                       if (muffled) 
[18:04:41.290]                         invokeRestart("muffleWarning")
[18:04:41.290]                     }
[18:04:41.290]                     else if (inherits(cond, "condition")) {
[18:04:41.290]                       if (!is.null(pattern)) {
[18:04:41.290]                         computeRestarts <- base::computeRestarts
[18:04:41.290]                         grepl <- base::grepl
[18:04:41.290]                         restarts <- computeRestarts(cond)
[18:04:41.290]                         for (restart in restarts) {
[18:04:41.290]                           name <- restart$name
[18:04:41.290]                           if (is.null(name)) 
[18:04:41.290]                             next
[18:04:41.290]                           if (!grepl(pattern, name)) 
[18:04:41.290]                             next
[18:04:41.290]                           invokeRestart(restart)
[18:04:41.290]                           muffled <- TRUE
[18:04:41.290]                           break
[18:04:41.290]                         }
[18:04:41.290]                       }
[18:04:41.290]                     }
[18:04:41.290]                     invisible(muffled)
[18:04:41.290]                   }
[18:04:41.290]                   muffleCondition(cond)
[18:04:41.290]                 })
[18:04:41.290]             }))
[18:04:41.290]             future::FutureResult(value = ...future.value$value, 
[18:04:41.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.290]                   ...future.rng), globalenv = if (FALSE) 
[18:04:41.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:41.290]                     ...future.globalenv.names))
[18:04:41.290]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:41.290]         }, condition = base::local({
[18:04:41.290]             c <- base::c
[18:04:41.290]             inherits <- base::inherits
[18:04:41.290]             invokeRestart <- base::invokeRestart
[18:04:41.290]             length <- base::length
[18:04:41.290]             list <- base::list
[18:04:41.290]             seq.int <- base::seq.int
[18:04:41.290]             signalCondition <- base::signalCondition
[18:04:41.290]             sys.calls <- base::sys.calls
[18:04:41.290]             `[[` <- base::`[[`
[18:04:41.290]             `+` <- base::`+`
[18:04:41.290]             `<<-` <- base::`<<-`
[18:04:41.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:41.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:41.290]                   3L)]
[18:04:41.290]             }
[18:04:41.290]             function(cond) {
[18:04:41.290]                 is_error <- inherits(cond, "error")
[18:04:41.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:41.290]                   NULL)
[18:04:41.290]                 if (is_error) {
[18:04:41.290]                   sessionInformation <- function() {
[18:04:41.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:41.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:41.290]                       search = base::search(), system = base::Sys.info())
[18:04:41.290]                   }
[18:04:41.290]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:41.290]                     cond$call), session = sessionInformation(), 
[18:04:41.290]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:41.290]                   signalCondition(cond)
[18:04:41.290]                 }
[18:04:41.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:41.290]                 "immediateCondition"))) {
[18:04:41.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:41.290]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:41.290]                   if (TRUE && !signal) {
[18:04:41.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.290]                     {
[18:04:41.290]                       inherits <- base::inherits
[18:04:41.290]                       invokeRestart <- base::invokeRestart
[18:04:41.290]                       is.null <- base::is.null
[18:04:41.290]                       muffled <- FALSE
[18:04:41.290]                       if (inherits(cond, "message")) {
[18:04:41.290]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.290]                         if (muffled) 
[18:04:41.290]                           invokeRestart("muffleMessage")
[18:04:41.290]                       }
[18:04:41.290]                       else if (inherits(cond, "warning")) {
[18:04:41.290]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.290]                         if (muffled) 
[18:04:41.290]                           invokeRestart("muffleWarning")
[18:04:41.290]                       }
[18:04:41.290]                       else if (inherits(cond, "condition")) {
[18:04:41.290]                         if (!is.null(pattern)) {
[18:04:41.290]                           computeRestarts <- base::computeRestarts
[18:04:41.290]                           grepl <- base::grepl
[18:04:41.290]                           restarts <- computeRestarts(cond)
[18:04:41.290]                           for (restart in restarts) {
[18:04:41.290]                             name <- restart$name
[18:04:41.290]                             if (is.null(name)) 
[18:04:41.290]                               next
[18:04:41.290]                             if (!grepl(pattern, name)) 
[18:04:41.290]                               next
[18:04:41.290]                             invokeRestart(restart)
[18:04:41.290]                             muffled <- TRUE
[18:04:41.290]                             break
[18:04:41.290]                           }
[18:04:41.290]                         }
[18:04:41.290]                       }
[18:04:41.290]                       invisible(muffled)
[18:04:41.290]                     }
[18:04:41.290]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.290]                   }
[18:04:41.290]                 }
[18:04:41.290]                 else {
[18:04:41.290]                   if (TRUE) {
[18:04:41.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.290]                     {
[18:04:41.290]                       inherits <- base::inherits
[18:04:41.290]                       invokeRestart <- base::invokeRestart
[18:04:41.290]                       is.null <- base::is.null
[18:04:41.290]                       muffled <- FALSE
[18:04:41.290]                       if (inherits(cond, "message")) {
[18:04:41.290]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.290]                         if (muffled) 
[18:04:41.290]                           invokeRestart("muffleMessage")
[18:04:41.290]                       }
[18:04:41.290]                       else if (inherits(cond, "warning")) {
[18:04:41.290]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.290]                         if (muffled) 
[18:04:41.290]                           invokeRestart("muffleWarning")
[18:04:41.290]                       }
[18:04:41.290]                       else if (inherits(cond, "condition")) {
[18:04:41.290]                         if (!is.null(pattern)) {
[18:04:41.290]                           computeRestarts <- base::computeRestarts
[18:04:41.290]                           grepl <- base::grepl
[18:04:41.290]                           restarts <- computeRestarts(cond)
[18:04:41.290]                           for (restart in restarts) {
[18:04:41.290]                             name <- restart$name
[18:04:41.290]                             if (is.null(name)) 
[18:04:41.290]                               next
[18:04:41.290]                             if (!grepl(pattern, name)) 
[18:04:41.290]                               next
[18:04:41.290]                             invokeRestart(restart)
[18:04:41.290]                             muffled <- TRUE
[18:04:41.290]                             break
[18:04:41.290]                           }
[18:04:41.290]                         }
[18:04:41.290]                       }
[18:04:41.290]                       invisible(muffled)
[18:04:41.290]                     }
[18:04:41.290]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.290]                   }
[18:04:41.290]                 }
[18:04:41.290]             }
[18:04:41.290]         }))
[18:04:41.290]     }, error = function(ex) {
[18:04:41.290]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:41.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.290]                 ...future.rng), started = ...future.startTime, 
[18:04:41.290]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:41.290]             version = "1.8"), class = "FutureResult")
[18:04:41.290]     }, finally = {
[18:04:41.290]         if (!identical(...future.workdir, getwd())) 
[18:04:41.290]             setwd(...future.workdir)
[18:04:41.290]         {
[18:04:41.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:41.290]                 ...future.oldOptions$nwarnings <- NULL
[18:04:41.290]             }
[18:04:41.290]             base::options(...future.oldOptions)
[18:04:41.290]             if (.Platform$OS.type == "windows") {
[18:04:41.290]                 old_names <- names(...future.oldEnvVars)
[18:04:41.290]                 envs <- base::Sys.getenv()
[18:04:41.290]                 names <- names(envs)
[18:04:41.290]                 common <- intersect(names, old_names)
[18:04:41.290]                 added <- setdiff(names, old_names)
[18:04:41.290]                 removed <- setdiff(old_names, names)
[18:04:41.290]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:41.290]                   envs[common]]
[18:04:41.290]                 NAMES <- toupper(changed)
[18:04:41.290]                 args <- list()
[18:04:41.290]                 for (kk in seq_along(NAMES)) {
[18:04:41.290]                   name <- changed[[kk]]
[18:04:41.290]                   NAME <- NAMES[[kk]]
[18:04:41.290]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.290]                     next
[18:04:41.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.290]                 }
[18:04:41.290]                 NAMES <- toupper(added)
[18:04:41.290]                 for (kk in seq_along(NAMES)) {
[18:04:41.290]                   name <- added[[kk]]
[18:04:41.290]                   NAME <- NAMES[[kk]]
[18:04:41.290]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.290]                     next
[18:04:41.290]                   args[[name]] <- ""
[18:04:41.290]                 }
[18:04:41.290]                 NAMES <- toupper(removed)
[18:04:41.290]                 for (kk in seq_along(NAMES)) {
[18:04:41.290]                   name <- removed[[kk]]
[18:04:41.290]                   NAME <- NAMES[[kk]]
[18:04:41.290]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.290]                     next
[18:04:41.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.290]                 }
[18:04:41.290]                 if (length(args) > 0) 
[18:04:41.290]                   base::do.call(base::Sys.setenv, args = args)
[18:04:41.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:41.290]             }
[18:04:41.290]             else {
[18:04:41.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:41.290]             }
[18:04:41.290]             {
[18:04:41.290]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:41.290]                   0L) {
[18:04:41.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:41.290]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:41.290]                   base::options(opts)
[18:04:41.290]                 }
[18:04:41.290]                 {
[18:04:41.290]                   {
[18:04:41.290]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:41.290]                     NULL
[18:04:41.290]                   }
[18:04:41.290]                   options(future.plan = NULL)
[18:04:41.290]                   if (is.na(NA_character_)) 
[18:04:41.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:41.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:41.290]                     .init = FALSE)
[18:04:41.290]                 }
[18:04:41.290]             }
[18:04:41.290]         }
[18:04:41.290]     })
[18:04:41.290]     if (TRUE) {
[18:04:41.290]         base::sink(type = "output", split = FALSE)
[18:04:41.290]         if (TRUE) {
[18:04:41.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:41.290]         }
[18:04:41.290]         else {
[18:04:41.290]             ...future.result["stdout"] <- base::list(NULL)
[18:04:41.290]         }
[18:04:41.290]         base::close(...future.stdout)
[18:04:41.290]         ...future.stdout <- NULL
[18:04:41.290]     }
[18:04:41.290]     ...future.result$conditions <- ...future.conditions
[18:04:41.290]     ...future.result$finished <- base::Sys.time()
[18:04:41.290]     ...future.result
[18:04:41.290] }
[18:04:41.297] MultisessionFuture started
[18:04:41.297] - Launch lazy future ... done
[18:04:41.298] run() for ‘MultisessionFuture’ ... done
[18:04:41.298] result() for ClusterFuture ...
[18:04:41.298] receiveMessageFromWorker() for ClusterFuture ...
[18:04:41.299] - Validating connection of MultisessionFuture
[18:04:41.343] - received message: FutureResult
[18:04:41.343] - Received FutureResult
[18:04:41.344] - Erased future from FutureRegistry
[18:04:41.344] result() for ClusterFuture ...
[18:04:41.344] - result already collected: FutureResult
[18:04:41.345] result() for ClusterFuture ... done
[18:04:41.345] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:41.345] result() for ClusterFuture ... done
[18:04:41.345] result() for ClusterFuture ...
[18:04:41.346] - result already collected: FutureResult
[18:04:41.346] result() for ClusterFuture ... done
[18:04:41.347] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:41.347] Searching for globals...
[18:04:41.348] - globals found: [1] ‘getOption’
[18:04:41.349] Searching for globals ... DONE
[18:04:41.349] Resolving globals: FALSE
[18:04:41.350] 
[18:04:41.350] 
[18:04:41.350] getGlobalsAndPackages() ... DONE
[18:04:41.351] run() for ‘Future’ ...
[18:04:41.351] - state: ‘created’
[18:04:41.351] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:41.378] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:41.378] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:41.378]   - Field: ‘node’
[18:04:41.379]   - Field: ‘label’
[18:04:41.379]   - Field: ‘local’
[18:04:41.379]   - Field: ‘owner’
[18:04:41.379]   - Field: ‘envir’
[18:04:41.379]   - Field: ‘workers’
[18:04:41.380]   - Field: ‘packages’
[18:04:41.380]   - Field: ‘gc’
[18:04:41.380]   - Field: ‘conditions’
[18:04:41.380]   - Field: ‘persistent’
[18:04:41.381]   - Field: ‘expr’
[18:04:41.381]   - Field: ‘uuid’
[18:04:41.381]   - Field: ‘seed’
[18:04:41.381]   - Field: ‘version’
[18:04:41.381]   - Field: ‘result’
[18:04:41.382]   - Field: ‘asynchronous’
[18:04:41.382]   - Field: ‘calls’
[18:04:41.382]   - Field: ‘globals’
[18:04:41.382]   - Field: ‘stdout’
[18:04:41.383]   - Field: ‘earlySignal’
[18:04:41.383]   - Field: ‘lazy’
[18:04:41.383]   - Field: ‘state’
[18:04:41.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:41.384] - Launch lazy future ...
[18:04:41.384] Packages needed by the future expression (n = 0): <none>
[18:04:41.384] Packages needed by future strategies (n = 0): <none>
[18:04:41.385] {
[18:04:41.385]     {
[18:04:41.385]         {
[18:04:41.385]             ...future.startTime <- base::Sys.time()
[18:04:41.385]             {
[18:04:41.385]                 {
[18:04:41.385]                   {
[18:04:41.385]                     {
[18:04:41.385]                       base::local({
[18:04:41.385]                         has_future <- base::requireNamespace("future", 
[18:04:41.385]                           quietly = TRUE)
[18:04:41.385]                         if (has_future) {
[18:04:41.385]                           ns <- base::getNamespace("future")
[18:04:41.385]                           version <- ns[[".package"]][["version"]]
[18:04:41.385]                           if (is.null(version)) 
[18:04:41.385]                             version <- utils::packageVersion("future")
[18:04:41.385]                         }
[18:04:41.385]                         else {
[18:04:41.385]                           version <- NULL
[18:04:41.385]                         }
[18:04:41.385]                         if (!has_future || version < "1.8.0") {
[18:04:41.385]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:41.385]                             "", base::R.version$version.string), 
[18:04:41.385]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:41.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:41.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:41.385]                               "release", "version")], collapse = " "), 
[18:04:41.385]                             hostname = base::Sys.info()[["nodename"]])
[18:04:41.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:41.385]                             info)
[18:04:41.385]                           info <- base::paste(info, collapse = "; ")
[18:04:41.385]                           if (!has_future) {
[18:04:41.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:41.385]                               info)
[18:04:41.385]                           }
[18:04:41.385]                           else {
[18:04:41.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:41.385]                               info, version)
[18:04:41.385]                           }
[18:04:41.385]                           base::stop(msg)
[18:04:41.385]                         }
[18:04:41.385]                       })
[18:04:41.385]                     }
[18:04:41.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:41.385]                     base::options(mc.cores = 1L)
[18:04:41.385]                   }
[18:04:41.385]                   ...future.strategy.old <- future::plan("list")
[18:04:41.385]                   options(future.plan = NULL)
[18:04:41.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:41.385]                 }
[18:04:41.385]                 ...future.workdir <- getwd()
[18:04:41.385]             }
[18:04:41.385]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:41.385]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:41.385]         }
[18:04:41.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:41.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:41.385]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:41.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:41.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:41.385]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:41.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:41.385]             base::names(...future.oldOptions))
[18:04:41.385]     }
[18:04:41.385]     if (FALSE) {
[18:04:41.385]     }
[18:04:41.385]     else {
[18:04:41.385]         if (TRUE) {
[18:04:41.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:41.385]                 open = "w")
[18:04:41.385]         }
[18:04:41.385]         else {
[18:04:41.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:41.385]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:41.385]         }
[18:04:41.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:41.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:41.385]             base::sink(type = "output", split = FALSE)
[18:04:41.385]             base::close(...future.stdout)
[18:04:41.385]         }, add = TRUE)
[18:04:41.385]     }
[18:04:41.385]     ...future.frame <- base::sys.nframe()
[18:04:41.385]     ...future.conditions <- base::list()
[18:04:41.385]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:41.385]     if (FALSE) {
[18:04:41.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:41.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:41.385]     }
[18:04:41.385]     ...future.result <- base::tryCatch({
[18:04:41.385]         base::withCallingHandlers({
[18:04:41.385]             ...future.value <- base::withVisible(base::local({
[18:04:41.385]                 ...future.makeSendCondition <- base::local({
[18:04:41.385]                   sendCondition <- NULL
[18:04:41.385]                   function(frame = 1L) {
[18:04:41.385]                     if (is.function(sendCondition)) 
[18:04:41.385]                       return(sendCondition)
[18:04:41.385]                     ns <- getNamespace("parallel")
[18:04:41.385]                     if (exists("sendData", mode = "function", 
[18:04:41.385]                       envir = ns)) {
[18:04:41.385]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:41.385]                         envir = ns)
[18:04:41.385]                       envir <- sys.frame(frame)
[18:04:41.385]                       master <- NULL
[18:04:41.385]                       while (!identical(envir, .GlobalEnv) && 
[18:04:41.385]                         !identical(envir, emptyenv())) {
[18:04:41.385]                         if (exists("master", mode = "list", envir = envir, 
[18:04:41.385]                           inherits = FALSE)) {
[18:04:41.385]                           master <- get("master", mode = "list", 
[18:04:41.385]                             envir = envir, inherits = FALSE)
[18:04:41.385]                           if (inherits(master, c("SOCKnode", 
[18:04:41.385]                             "SOCK0node"))) {
[18:04:41.385]                             sendCondition <<- function(cond) {
[18:04:41.385]                               data <- list(type = "VALUE", value = cond, 
[18:04:41.385]                                 success = TRUE)
[18:04:41.385]                               parallel_sendData(master, data)
[18:04:41.385]                             }
[18:04:41.385]                             return(sendCondition)
[18:04:41.385]                           }
[18:04:41.385]                         }
[18:04:41.385]                         frame <- frame + 1L
[18:04:41.385]                         envir <- sys.frame(frame)
[18:04:41.385]                       }
[18:04:41.385]                     }
[18:04:41.385]                     sendCondition <<- function(cond) NULL
[18:04:41.385]                   }
[18:04:41.385]                 })
[18:04:41.385]                 withCallingHandlers({
[18:04:41.385]                   getOption("future.globals.onMissing")
[18:04:41.385]                 }, immediateCondition = function(cond) {
[18:04:41.385]                   sendCondition <- ...future.makeSendCondition()
[18:04:41.385]                   sendCondition(cond)
[18:04:41.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.385]                   {
[18:04:41.385]                     inherits <- base::inherits
[18:04:41.385]                     invokeRestart <- base::invokeRestart
[18:04:41.385]                     is.null <- base::is.null
[18:04:41.385]                     muffled <- FALSE
[18:04:41.385]                     if (inherits(cond, "message")) {
[18:04:41.385]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:41.385]                       if (muffled) 
[18:04:41.385]                         invokeRestart("muffleMessage")
[18:04:41.385]                     }
[18:04:41.385]                     else if (inherits(cond, "warning")) {
[18:04:41.385]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:41.385]                       if (muffled) 
[18:04:41.385]                         invokeRestart("muffleWarning")
[18:04:41.385]                     }
[18:04:41.385]                     else if (inherits(cond, "condition")) {
[18:04:41.385]                       if (!is.null(pattern)) {
[18:04:41.385]                         computeRestarts <- base::computeRestarts
[18:04:41.385]                         grepl <- base::grepl
[18:04:41.385]                         restarts <- computeRestarts(cond)
[18:04:41.385]                         for (restart in restarts) {
[18:04:41.385]                           name <- restart$name
[18:04:41.385]                           if (is.null(name)) 
[18:04:41.385]                             next
[18:04:41.385]                           if (!grepl(pattern, name)) 
[18:04:41.385]                             next
[18:04:41.385]                           invokeRestart(restart)
[18:04:41.385]                           muffled <- TRUE
[18:04:41.385]                           break
[18:04:41.385]                         }
[18:04:41.385]                       }
[18:04:41.385]                     }
[18:04:41.385]                     invisible(muffled)
[18:04:41.385]                   }
[18:04:41.385]                   muffleCondition(cond)
[18:04:41.385]                 })
[18:04:41.385]             }))
[18:04:41.385]             future::FutureResult(value = ...future.value$value, 
[18:04:41.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.385]                   ...future.rng), globalenv = if (FALSE) 
[18:04:41.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:41.385]                     ...future.globalenv.names))
[18:04:41.385]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:41.385]         }, condition = base::local({
[18:04:41.385]             c <- base::c
[18:04:41.385]             inherits <- base::inherits
[18:04:41.385]             invokeRestart <- base::invokeRestart
[18:04:41.385]             length <- base::length
[18:04:41.385]             list <- base::list
[18:04:41.385]             seq.int <- base::seq.int
[18:04:41.385]             signalCondition <- base::signalCondition
[18:04:41.385]             sys.calls <- base::sys.calls
[18:04:41.385]             `[[` <- base::`[[`
[18:04:41.385]             `+` <- base::`+`
[18:04:41.385]             `<<-` <- base::`<<-`
[18:04:41.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:41.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:41.385]                   3L)]
[18:04:41.385]             }
[18:04:41.385]             function(cond) {
[18:04:41.385]                 is_error <- inherits(cond, "error")
[18:04:41.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:41.385]                   NULL)
[18:04:41.385]                 if (is_error) {
[18:04:41.385]                   sessionInformation <- function() {
[18:04:41.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:41.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:41.385]                       search = base::search(), system = base::Sys.info())
[18:04:41.385]                   }
[18:04:41.385]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:41.385]                     cond$call), session = sessionInformation(), 
[18:04:41.385]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:41.385]                   signalCondition(cond)
[18:04:41.385]                 }
[18:04:41.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:41.385]                 "immediateCondition"))) {
[18:04:41.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:41.385]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:41.385]                   if (TRUE && !signal) {
[18:04:41.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.385]                     {
[18:04:41.385]                       inherits <- base::inherits
[18:04:41.385]                       invokeRestart <- base::invokeRestart
[18:04:41.385]                       is.null <- base::is.null
[18:04:41.385]                       muffled <- FALSE
[18:04:41.385]                       if (inherits(cond, "message")) {
[18:04:41.385]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.385]                         if (muffled) 
[18:04:41.385]                           invokeRestart("muffleMessage")
[18:04:41.385]                       }
[18:04:41.385]                       else if (inherits(cond, "warning")) {
[18:04:41.385]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.385]                         if (muffled) 
[18:04:41.385]                           invokeRestart("muffleWarning")
[18:04:41.385]                       }
[18:04:41.385]                       else if (inherits(cond, "condition")) {
[18:04:41.385]                         if (!is.null(pattern)) {
[18:04:41.385]                           computeRestarts <- base::computeRestarts
[18:04:41.385]                           grepl <- base::grepl
[18:04:41.385]                           restarts <- computeRestarts(cond)
[18:04:41.385]                           for (restart in restarts) {
[18:04:41.385]                             name <- restart$name
[18:04:41.385]                             if (is.null(name)) 
[18:04:41.385]                               next
[18:04:41.385]                             if (!grepl(pattern, name)) 
[18:04:41.385]                               next
[18:04:41.385]                             invokeRestart(restart)
[18:04:41.385]                             muffled <- TRUE
[18:04:41.385]                             break
[18:04:41.385]                           }
[18:04:41.385]                         }
[18:04:41.385]                       }
[18:04:41.385]                       invisible(muffled)
[18:04:41.385]                     }
[18:04:41.385]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.385]                   }
[18:04:41.385]                 }
[18:04:41.385]                 else {
[18:04:41.385]                   if (TRUE) {
[18:04:41.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.385]                     {
[18:04:41.385]                       inherits <- base::inherits
[18:04:41.385]                       invokeRestart <- base::invokeRestart
[18:04:41.385]                       is.null <- base::is.null
[18:04:41.385]                       muffled <- FALSE
[18:04:41.385]                       if (inherits(cond, "message")) {
[18:04:41.385]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.385]                         if (muffled) 
[18:04:41.385]                           invokeRestart("muffleMessage")
[18:04:41.385]                       }
[18:04:41.385]                       else if (inherits(cond, "warning")) {
[18:04:41.385]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.385]                         if (muffled) 
[18:04:41.385]                           invokeRestart("muffleWarning")
[18:04:41.385]                       }
[18:04:41.385]                       else if (inherits(cond, "condition")) {
[18:04:41.385]                         if (!is.null(pattern)) {
[18:04:41.385]                           computeRestarts <- base::computeRestarts
[18:04:41.385]                           grepl <- base::grepl
[18:04:41.385]                           restarts <- computeRestarts(cond)
[18:04:41.385]                           for (restart in restarts) {
[18:04:41.385]                             name <- restart$name
[18:04:41.385]                             if (is.null(name)) 
[18:04:41.385]                               next
[18:04:41.385]                             if (!grepl(pattern, name)) 
[18:04:41.385]                               next
[18:04:41.385]                             invokeRestart(restart)
[18:04:41.385]                             muffled <- TRUE
[18:04:41.385]                             break
[18:04:41.385]                           }
[18:04:41.385]                         }
[18:04:41.385]                       }
[18:04:41.385]                       invisible(muffled)
[18:04:41.385]                     }
[18:04:41.385]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.385]                   }
[18:04:41.385]                 }
[18:04:41.385]             }
[18:04:41.385]         }))
[18:04:41.385]     }, error = function(ex) {
[18:04:41.385]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:41.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.385]                 ...future.rng), started = ...future.startTime, 
[18:04:41.385]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:41.385]             version = "1.8"), class = "FutureResult")
[18:04:41.385]     }, finally = {
[18:04:41.385]         if (!identical(...future.workdir, getwd())) 
[18:04:41.385]             setwd(...future.workdir)
[18:04:41.385]         {
[18:04:41.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:41.385]                 ...future.oldOptions$nwarnings <- NULL
[18:04:41.385]             }
[18:04:41.385]             base::options(...future.oldOptions)
[18:04:41.385]             if (.Platform$OS.type == "windows") {
[18:04:41.385]                 old_names <- names(...future.oldEnvVars)
[18:04:41.385]                 envs <- base::Sys.getenv()
[18:04:41.385]                 names <- names(envs)
[18:04:41.385]                 common <- intersect(names, old_names)
[18:04:41.385]                 added <- setdiff(names, old_names)
[18:04:41.385]                 removed <- setdiff(old_names, names)
[18:04:41.385]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:41.385]                   envs[common]]
[18:04:41.385]                 NAMES <- toupper(changed)
[18:04:41.385]                 args <- list()
[18:04:41.385]                 for (kk in seq_along(NAMES)) {
[18:04:41.385]                   name <- changed[[kk]]
[18:04:41.385]                   NAME <- NAMES[[kk]]
[18:04:41.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.385]                     next
[18:04:41.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.385]                 }
[18:04:41.385]                 NAMES <- toupper(added)
[18:04:41.385]                 for (kk in seq_along(NAMES)) {
[18:04:41.385]                   name <- added[[kk]]
[18:04:41.385]                   NAME <- NAMES[[kk]]
[18:04:41.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.385]                     next
[18:04:41.385]                   args[[name]] <- ""
[18:04:41.385]                 }
[18:04:41.385]                 NAMES <- toupper(removed)
[18:04:41.385]                 for (kk in seq_along(NAMES)) {
[18:04:41.385]                   name <- removed[[kk]]
[18:04:41.385]                   NAME <- NAMES[[kk]]
[18:04:41.385]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.385]                     next
[18:04:41.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.385]                 }
[18:04:41.385]                 if (length(args) > 0) 
[18:04:41.385]                   base::do.call(base::Sys.setenv, args = args)
[18:04:41.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:41.385]             }
[18:04:41.385]             else {
[18:04:41.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:41.385]             }
[18:04:41.385]             {
[18:04:41.385]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:41.385]                   0L) {
[18:04:41.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:41.385]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:41.385]                   base::options(opts)
[18:04:41.385]                 }
[18:04:41.385]                 {
[18:04:41.385]                   {
[18:04:41.385]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:41.385]                     NULL
[18:04:41.385]                   }
[18:04:41.385]                   options(future.plan = NULL)
[18:04:41.385]                   if (is.na(NA_character_)) 
[18:04:41.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:41.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:41.385]                     .init = FALSE)
[18:04:41.385]                 }
[18:04:41.385]             }
[18:04:41.385]         }
[18:04:41.385]     })
[18:04:41.385]     if (TRUE) {
[18:04:41.385]         base::sink(type = "output", split = FALSE)
[18:04:41.385]         if (TRUE) {
[18:04:41.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:41.385]         }
[18:04:41.385]         else {
[18:04:41.385]             ...future.result["stdout"] <- base::list(NULL)
[18:04:41.385]         }
[18:04:41.385]         base::close(...future.stdout)
[18:04:41.385]         ...future.stdout <- NULL
[18:04:41.385]     }
[18:04:41.385]     ...future.result$conditions <- ...future.conditions
[18:04:41.385]     ...future.result$finished <- base::Sys.time()
[18:04:41.385]     ...future.result
[18:04:41.385] }
[18:04:41.392] MultisessionFuture started
[18:04:41.392] - Launch lazy future ... done
[18:04:41.392] run() for ‘MultisessionFuture’ ... done
[18:04:41.393] result() for ClusterFuture ...
[18:04:41.393] receiveMessageFromWorker() for ClusterFuture ...
[18:04:41.393] - Validating connection of MultisessionFuture
[18:04:41.442] - received message: FutureResult
[18:04:41.442] - Received FutureResult
[18:04:41.443] - Erased future from FutureRegistry
[18:04:41.443] result() for ClusterFuture ...
[18:04:41.443] - result already collected: FutureResult
[18:04:41.443] result() for ClusterFuture ... done
[18:04:41.444] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:41.444] result() for ClusterFuture ... done
[18:04:41.444] result() for ClusterFuture ...
[18:04:41.445] - result already collected: FutureResult
[18:04:41.445] result() for ClusterFuture ... done
[18:04:41.446] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[18:04:41.446] Searching for globals...
[18:04:41.449] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:41.450] Searching for globals...
[18:04:41.452] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[18:04:41.453] Searching for globals ... DONE
[18:04:41.453] Resolving globals: FALSE
[18:04:41.454] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:41.455] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:41.455] - globals: [1] ‘data’
[18:04:41.456] 
[18:04:41.456] getGlobalsAndPackages() ... DONE
[18:04:41.457] run() for ‘Future’ ...
[18:04:41.457] - state: ‘created’
[18:04:41.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:41.483] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:41.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:41.483]   - Field: ‘node’
[18:04:41.483]   - Field: ‘label’
[18:04:41.484]   - Field: ‘local’
[18:04:41.484]   - Field: ‘owner’
[18:04:41.484]   - Field: ‘envir’
[18:04:41.484]   - Field: ‘workers’
[18:04:41.484]   - Field: ‘packages’
[18:04:41.485]   - Field: ‘gc’
[18:04:41.485]   - Field: ‘conditions’
[18:04:41.485]   - Field: ‘persistent’
[18:04:41.485]   - Field: ‘expr’
[18:04:41.486]   - Field: ‘uuid’
[18:04:41.486]   - Field: ‘seed’
[18:04:41.486]   - Field: ‘version’
[18:04:41.486]   - Field: ‘result’
[18:04:41.487]   - Field: ‘asynchronous’
[18:04:41.487]   - Field: ‘calls’
[18:04:41.487]   - Field: ‘globals’
[18:04:41.487]   - Field: ‘stdout’
[18:04:41.487]   - Field: ‘earlySignal’
[18:04:41.488]   - Field: ‘lazy’
[18:04:41.488]   - Field: ‘state’
[18:04:41.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:41.488] - Launch lazy future ...
[18:04:41.489] Packages needed by the future expression (n = 0): <none>
[18:04:41.489] Packages needed by future strategies (n = 0): <none>
[18:04:41.490] {
[18:04:41.490]     {
[18:04:41.490]         {
[18:04:41.490]             ...future.startTime <- base::Sys.time()
[18:04:41.490]             {
[18:04:41.490]                 {
[18:04:41.490]                   {
[18:04:41.490]                     {
[18:04:41.490]                       base::local({
[18:04:41.490]                         has_future <- base::requireNamespace("future", 
[18:04:41.490]                           quietly = TRUE)
[18:04:41.490]                         if (has_future) {
[18:04:41.490]                           ns <- base::getNamespace("future")
[18:04:41.490]                           version <- ns[[".package"]][["version"]]
[18:04:41.490]                           if (is.null(version)) 
[18:04:41.490]                             version <- utils::packageVersion("future")
[18:04:41.490]                         }
[18:04:41.490]                         else {
[18:04:41.490]                           version <- NULL
[18:04:41.490]                         }
[18:04:41.490]                         if (!has_future || version < "1.8.0") {
[18:04:41.490]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:41.490]                             "", base::R.version$version.string), 
[18:04:41.490]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:41.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:41.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:41.490]                               "release", "version")], collapse = " "), 
[18:04:41.490]                             hostname = base::Sys.info()[["nodename"]])
[18:04:41.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:41.490]                             info)
[18:04:41.490]                           info <- base::paste(info, collapse = "; ")
[18:04:41.490]                           if (!has_future) {
[18:04:41.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:41.490]                               info)
[18:04:41.490]                           }
[18:04:41.490]                           else {
[18:04:41.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:41.490]                               info, version)
[18:04:41.490]                           }
[18:04:41.490]                           base::stop(msg)
[18:04:41.490]                         }
[18:04:41.490]                       })
[18:04:41.490]                     }
[18:04:41.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:41.490]                     base::options(mc.cores = 1L)
[18:04:41.490]                   }
[18:04:41.490]                   ...future.strategy.old <- future::plan("list")
[18:04:41.490]                   options(future.plan = NULL)
[18:04:41.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:41.490]                 }
[18:04:41.490]                 ...future.workdir <- getwd()
[18:04:41.490]             }
[18:04:41.490]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:41.490]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:41.490]         }
[18:04:41.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:41.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:41.490]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:41.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:41.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:41.490]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:41.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:41.490]             base::names(...future.oldOptions))
[18:04:41.490]     }
[18:04:41.490]     if (FALSE) {
[18:04:41.490]     }
[18:04:41.490]     else {
[18:04:41.490]         if (TRUE) {
[18:04:41.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:41.490]                 open = "w")
[18:04:41.490]         }
[18:04:41.490]         else {
[18:04:41.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:41.490]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:41.490]         }
[18:04:41.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:41.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:41.490]             base::sink(type = "output", split = FALSE)
[18:04:41.490]             base::close(...future.stdout)
[18:04:41.490]         }, add = TRUE)
[18:04:41.490]     }
[18:04:41.490]     ...future.frame <- base::sys.nframe()
[18:04:41.490]     ...future.conditions <- base::list()
[18:04:41.490]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:41.490]     if (FALSE) {
[18:04:41.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:41.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:41.490]     }
[18:04:41.490]     ...future.result <- base::tryCatch({
[18:04:41.490]         base::withCallingHandlers({
[18:04:41.490]             ...future.value <- base::withVisible(base::local({
[18:04:41.490]                 ...future.makeSendCondition <- base::local({
[18:04:41.490]                   sendCondition <- NULL
[18:04:41.490]                   function(frame = 1L) {
[18:04:41.490]                     if (is.function(sendCondition)) 
[18:04:41.490]                       return(sendCondition)
[18:04:41.490]                     ns <- getNamespace("parallel")
[18:04:41.490]                     if (exists("sendData", mode = "function", 
[18:04:41.490]                       envir = ns)) {
[18:04:41.490]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:41.490]                         envir = ns)
[18:04:41.490]                       envir <- sys.frame(frame)
[18:04:41.490]                       master <- NULL
[18:04:41.490]                       while (!identical(envir, .GlobalEnv) && 
[18:04:41.490]                         !identical(envir, emptyenv())) {
[18:04:41.490]                         if (exists("master", mode = "list", envir = envir, 
[18:04:41.490]                           inherits = FALSE)) {
[18:04:41.490]                           master <- get("master", mode = "list", 
[18:04:41.490]                             envir = envir, inherits = FALSE)
[18:04:41.490]                           if (inherits(master, c("SOCKnode", 
[18:04:41.490]                             "SOCK0node"))) {
[18:04:41.490]                             sendCondition <<- function(cond) {
[18:04:41.490]                               data <- list(type = "VALUE", value = cond, 
[18:04:41.490]                                 success = TRUE)
[18:04:41.490]                               parallel_sendData(master, data)
[18:04:41.490]                             }
[18:04:41.490]                             return(sendCondition)
[18:04:41.490]                           }
[18:04:41.490]                         }
[18:04:41.490]                         frame <- frame + 1L
[18:04:41.490]                         envir <- sys.frame(frame)
[18:04:41.490]                       }
[18:04:41.490]                     }
[18:04:41.490]                     sendCondition <<- function(cond) NULL
[18:04:41.490]                   }
[18:04:41.490]                 })
[18:04:41.490]                 withCallingHandlers({
[18:04:41.490]                   subset(data, x < 3)$y
[18:04:41.490]                 }, immediateCondition = function(cond) {
[18:04:41.490]                   sendCondition <- ...future.makeSendCondition()
[18:04:41.490]                   sendCondition(cond)
[18:04:41.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.490]                   {
[18:04:41.490]                     inherits <- base::inherits
[18:04:41.490]                     invokeRestart <- base::invokeRestart
[18:04:41.490]                     is.null <- base::is.null
[18:04:41.490]                     muffled <- FALSE
[18:04:41.490]                     if (inherits(cond, "message")) {
[18:04:41.490]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:41.490]                       if (muffled) 
[18:04:41.490]                         invokeRestart("muffleMessage")
[18:04:41.490]                     }
[18:04:41.490]                     else if (inherits(cond, "warning")) {
[18:04:41.490]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:41.490]                       if (muffled) 
[18:04:41.490]                         invokeRestart("muffleWarning")
[18:04:41.490]                     }
[18:04:41.490]                     else if (inherits(cond, "condition")) {
[18:04:41.490]                       if (!is.null(pattern)) {
[18:04:41.490]                         computeRestarts <- base::computeRestarts
[18:04:41.490]                         grepl <- base::grepl
[18:04:41.490]                         restarts <- computeRestarts(cond)
[18:04:41.490]                         for (restart in restarts) {
[18:04:41.490]                           name <- restart$name
[18:04:41.490]                           if (is.null(name)) 
[18:04:41.490]                             next
[18:04:41.490]                           if (!grepl(pattern, name)) 
[18:04:41.490]                             next
[18:04:41.490]                           invokeRestart(restart)
[18:04:41.490]                           muffled <- TRUE
[18:04:41.490]                           break
[18:04:41.490]                         }
[18:04:41.490]                       }
[18:04:41.490]                     }
[18:04:41.490]                     invisible(muffled)
[18:04:41.490]                   }
[18:04:41.490]                   muffleCondition(cond)
[18:04:41.490]                 })
[18:04:41.490]             }))
[18:04:41.490]             future::FutureResult(value = ...future.value$value, 
[18:04:41.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.490]                   ...future.rng), globalenv = if (FALSE) 
[18:04:41.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:41.490]                     ...future.globalenv.names))
[18:04:41.490]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:41.490]         }, condition = base::local({
[18:04:41.490]             c <- base::c
[18:04:41.490]             inherits <- base::inherits
[18:04:41.490]             invokeRestart <- base::invokeRestart
[18:04:41.490]             length <- base::length
[18:04:41.490]             list <- base::list
[18:04:41.490]             seq.int <- base::seq.int
[18:04:41.490]             signalCondition <- base::signalCondition
[18:04:41.490]             sys.calls <- base::sys.calls
[18:04:41.490]             `[[` <- base::`[[`
[18:04:41.490]             `+` <- base::`+`
[18:04:41.490]             `<<-` <- base::`<<-`
[18:04:41.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:41.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:41.490]                   3L)]
[18:04:41.490]             }
[18:04:41.490]             function(cond) {
[18:04:41.490]                 is_error <- inherits(cond, "error")
[18:04:41.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:41.490]                   NULL)
[18:04:41.490]                 if (is_error) {
[18:04:41.490]                   sessionInformation <- function() {
[18:04:41.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:41.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:41.490]                       search = base::search(), system = base::Sys.info())
[18:04:41.490]                   }
[18:04:41.490]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:41.490]                     cond$call), session = sessionInformation(), 
[18:04:41.490]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:41.490]                   signalCondition(cond)
[18:04:41.490]                 }
[18:04:41.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:41.490]                 "immediateCondition"))) {
[18:04:41.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:41.490]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:41.490]                   if (TRUE && !signal) {
[18:04:41.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.490]                     {
[18:04:41.490]                       inherits <- base::inherits
[18:04:41.490]                       invokeRestart <- base::invokeRestart
[18:04:41.490]                       is.null <- base::is.null
[18:04:41.490]                       muffled <- FALSE
[18:04:41.490]                       if (inherits(cond, "message")) {
[18:04:41.490]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.490]                         if (muffled) 
[18:04:41.490]                           invokeRestart("muffleMessage")
[18:04:41.490]                       }
[18:04:41.490]                       else if (inherits(cond, "warning")) {
[18:04:41.490]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.490]                         if (muffled) 
[18:04:41.490]                           invokeRestart("muffleWarning")
[18:04:41.490]                       }
[18:04:41.490]                       else if (inherits(cond, "condition")) {
[18:04:41.490]                         if (!is.null(pattern)) {
[18:04:41.490]                           computeRestarts <- base::computeRestarts
[18:04:41.490]                           grepl <- base::grepl
[18:04:41.490]                           restarts <- computeRestarts(cond)
[18:04:41.490]                           for (restart in restarts) {
[18:04:41.490]                             name <- restart$name
[18:04:41.490]                             if (is.null(name)) 
[18:04:41.490]                               next
[18:04:41.490]                             if (!grepl(pattern, name)) 
[18:04:41.490]                               next
[18:04:41.490]                             invokeRestart(restart)
[18:04:41.490]                             muffled <- TRUE
[18:04:41.490]                             break
[18:04:41.490]                           }
[18:04:41.490]                         }
[18:04:41.490]                       }
[18:04:41.490]                       invisible(muffled)
[18:04:41.490]                     }
[18:04:41.490]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.490]                   }
[18:04:41.490]                 }
[18:04:41.490]                 else {
[18:04:41.490]                   if (TRUE) {
[18:04:41.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.490]                     {
[18:04:41.490]                       inherits <- base::inherits
[18:04:41.490]                       invokeRestart <- base::invokeRestart
[18:04:41.490]                       is.null <- base::is.null
[18:04:41.490]                       muffled <- FALSE
[18:04:41.490]                       if (inherits(cond, "message")) {
[18:04:41.490]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.490]                         if (muffled) 
[18:04:41.490]                           invokeRestart("muffleMessage")
[18:04:41.490]                       }
[18:04:41.490]                       else if (inherits(cond, "warning")) {
[18:04:41.490]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.490]                         if (muffled) 
[18:04:41.490]                           invokeRestart("muffleWarning")
[18:04:41.490]                       }
[18:04:41.490]                       else if (inherits(cond, "condition")) {
[18:04:41.490]                         if (!is.null(pattern)) {
[18:04:41.490]                           computeRestarts <- base::computeRestarts
[18:04:41.490]                           grepl <- base::grepl
[18:04:41.490]                           restarts <- computeRestarts(cond)
[18:04:41.490]                           for (restart in restarts) {
[18:04:41.490]                             name <- restart$name
[18:04:41.490]                             if (is.null(name)) 
[18:04:41.490]                               next
[18:04:41.490]                             if (!grepl(pattern, name)) 
[18:04:41.490]                               next
[18:04:41.490]                             invokeRestart(restart)
[18:04:41.490]                             muffled <- TRUE
[18:04:41.490]                             break
[18:04:41.490]                           }
[18:04:41.490]                         }
[18:04:41.490]                       }
[18:04:41.490]                       invisible(muffled)
[18:04:41.490]                     }
[18:04:41.490]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.490]                   }
[18:04:41.490]                 }
[18:04:41.490]             }
[18:04:41.490]         }))
[18:04:41.490]     }, error = function(ex) {
[18:04:41.490]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:41.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.490]                 ...future.rng), started = ...future.startTime, 
[18:04:41.490]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:41.490]             version = "1.8"), class = "FutureResult")
[18:04:41.490]     }, finally = {
[18:04:41.490]         if (!identical(...future.workdir, getwd())) 
[18:04:41.490]             setwd(...future.workdir)
[18:04:41.490]         {
[18:04:41.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:41.490]                 ...future.oldOptions$nwarnings <- NULL
[18:04:41.490]             }
[18:04:41.490]             base::options(...future.oldOptions)
[18:04:41.490]             if (.Platform$OS.type == "windows") {
[18:04:41.490]                 old_names <- names(...future.oldEnvVars)
[18:04:41.490]                 envs <- base::Sys.getenv()
[18:04:41.490]                 names <- names(envs)
[18:04:41.490]                 common <- intersect(names, old_names)
[18:04:41.490]                 added <- setdiff(names, old_names)
[18:04:41.490]                 removed <- setdiff(old_names, names)
[18:04:41.490]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:41.490]                   envs[common]]
[18:04:41.490]                 NAMES <- toupper(changed)
[18:04:41.490]                 args <- list()
[18:04:41.490]                 for (kk in seq_along(NAMES)) {
[18:04:41.490]                   name <- changed[[kk]]
[18:04:41.490]                   NAME <- NAMES[[kk]]
[18:04:41.490]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.490]                     next
[18:04:41.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.490]                 }
[18:04:41.490]                 NAMES <- toupper(added)
[18:04:41.490]                 for (kk in seq_along(NAMES)) {
[18:04:41.490]                   name <- added[[kk]]
[18:04:41.490]                   NAME <- NAMES[[kk]]
[18:04:41.490]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.490]                     next
[18:04:41.490]                   args[[name]] <- ""
[18:04:41.490]                 }
[18:04:41.490]                 NAMES <- toupper(removed)
[18:04:41.490]                 for (kk in seq_along(NAMES)) {
[18:04:41.490]                   name <- removed[[kk]]
[18:04:41.490]                   NAME <- NAMES[[kk]]
[18:04:41.490]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.490]                     next
[18:04:41.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.490]                 }
[18:04:41.490]                 if (length(args) > 0) 
[18:04:41.490]                   base::do.call(base::Sys.setenv, args = args)
[18:04:41.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:41.490]             }
[18:04:41.490]             else {
[18:04:41.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:41.490]             }
[18:04:41.490]             {
[18:04:41.490]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:41.490]                   0L) {
[18:04:41.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:41.490]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:41.490]                   base::options(opts)
[18:04:41.490]                 }
[18:04:41.490]                 {
[18:04:41.490]                   {
[18:04:41.490]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:41.490]                     NULL
[18:04:41.490]                   }
[18:04:41.490]                   options(future.plan = NULL)
[18:04:41.490]                   if (is.na(NA_character_)) 
[18:04:41.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:41.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:41.490]                     .init = FALSE)
[18:04:41.490]                 }
[18:04:41.490]             }
[18:04:41.490]         }
[18:04:41.490]     })
[18:04:41.490]     if (TRUE) {
[18:04:41.490]         base::sink(type = "output", split = FALSE)
[18:04:41.490]         if (TRUE) {
[18:04:41.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:41.490]         }
[18:04:41.490]         else {
[18:04:41.490]             ...future.result["stdout"] <- base::list(NULL)
[18:04:41.490]         }
[18:04:41.490]         base::close(...future.stdout)
[18:04:41.490]         ...future.stdout <- NULL
[18:04:41.490]     }
[18:04:41.490]     ...future.result$conditions <- ...future.conditions
[18:04:41.490]     ...future.result$finished <- base::Sys.time()
[18:04:41.490]     ...future.result
[18:04:41.490] }
[18:04:41.496] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[18:04:41.497] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[18:04:41.498] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[18:04:41.498] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[18:04:41.499] MultisessionFuture started
[18:04:41.499] - Launch lazy future ... done
[18:04:41.500] run() for ‘MultisessionFuture’ ... done
[18:04:41.500] result() for ClusterFuture ...
[18:04:41.500] receiveMessageFromWorker() for ClusterFuture ...
[18:04:41.501] - Validating connection of MultisessionFuture
[18:04:41.544] - received message: FutureResult
[18:04:41.544] - Received FutureResult
[18:04:41.545] - Erased future from FutureRegistry
[18:04:41.545] result() for ClusterFuture ...
[18:04:41.545] - result already collected: FutureResult
[18:04:41.545] result() for ClusterFuture ... done
[18:04:41.546] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:41.546] result() for ClusterFuture ... done
[18:04:41.546] result() for ClusterFuture ...
[18:04:41.546] - result already collected: FutureResult
[18:04:41.547] result() for ClusterFuture ... done
[18:04:41.547] plan(): Setting new future strategy stack:
[18:04:41.547] List of future strategies:
[18:04:41.547] 1. sequential:
[18:04:41.547]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:41.547]    - tweaked: FALSE
[18:04:41.547]    - call: plan(list(sequential, strategy))
[18:04:41.547] 2. multisession:
[18:04:41.547]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:41.547]    - tweaked: FALSE
[18:04:41.547]    - call: plan(list(sequential, strategy))
[18:04:41.552] plan(): nbrOfWorkers() = 1
[18:04:41.553] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:41.553] Searching for globals...
[18:04:41.566] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[18:04:41.566] Searching for globals ... DONE
[18:04:41.566] Resolving globals: FALSE
[18:04:41.567] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:41.568] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:41.568] - globals: [1] ‘data’
[18:04:41.569] - packages: [1] ‘future’
[18:04:41.569] getGlobalsAndPackages() ... DONE
[18:04:41.569] run() for ‘Future’ ...
[18:04:41.570] - state: ‘created’
[18:04:41.570] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:04:41.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:04:41.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:04:41.571]   - Field: ‘label’
[18:04:41.571]   - Field: ‘local’
[18:04:41.574]   - Field: ‘owner’
[18:04:41.574]   - Field: ‘envir’
[18:04:41.574]   - Field: ‘packages’
[18:04:41.575]   - Field: ‘gc’
[18:04:41.575]   - Field: ‘conditions’
[18:04:41.575]   - Field: ‘expr’
[18:04:41.575]   - Field: ‘uuid’
[18:04:41.575]   - Field: ‘seed’
[18:04:41.576]   - Field: ‘version’
[18:04:41.576]   - Field: ‘result’
[18:04:41.576]   - Field: ‘asynchronous’
[18:04:41.576]   - Field: ‘calls’
[18:04:41.577]   - Field: ‘globals’
[18:04:41.577]   - Field: ‘stdout’
[18:04:41.577]   - Field: ‘earlySignal’
[18:04:41.577]   - Field: ‘lazy’
[18:04:41.577]   - Field: ‘state’
[18:04:41.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:04:41.578] - Launch lazy future ...
[18:04:41.579] Packages needed by the future expression (n = 1): ‘future’
[18:04:41.580] Packages needed by future strategies (n = 1): ‘future’
[18:04:41.581] {
[18:04:41.581]     {
[18:04:41.581]         {
[18:04:41.581]             ...future.startTime <- base::Sys.time()
[18:04:41.581]             {
[18:04:41.581]                 {
[18:04:41.581]                   {
[18:04:41.581]                     {
[18:04:41.581]                       base::local({
[18:04:41.581]                         has_future <- base::requireNamespace("future", 
[18:04:41.581]                           quietly = TRUE)
[18:04:41.581]                         if (has_future) {
[18:04:41.581]                           ns <- base::getNamespace("future")
[18:04:41.581]                           version <- ns[[".package"]][["version"]]
[18:04:41.581]                           if (is.null(version)) 
[18:04:41.581]                             version <- utils::packageVersion("future")
[18:04:41.581]                         }
[18:04:41.581]                         else {
[18:04:41.581]                           version <- NULL
[18:04:41.581]                         }
[18:04:41.581]                         if (!has_future || version < "1.8.0") {
[18:04:41.581]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:41.581]                             "", base::R.version$version.string), 
[18:04:41.581]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:41.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:41.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:41.581]                               "release", "version")], collapse = " "), 
[18:04:41.581]                             hostname = base::Sys.info()[["nodename"]])
[18:04:41.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:41.581]                             info)
[18:04:41.581]                           info <- base::paste(info, collapse = "; ")
[18:04:41.581]                           if (!has_future) {
[18:04:41.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:41.581]                               info)
[18:04:41.581]                           }
[18:04:41.581]                           else {
[18:04:41.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:41.581]                               info, version)
[18:04:41.581]                           }
[18:04:41.581]                           base::stop(msg)
[18:04:41.581]                         }
[18:04:41.581]                       })
[18:04:41.581]                     }
[18:04:41.581]                     base::local({
[18:04:41.581]                       for (pkg in "future") {
[18:04:41.581]                         base::loadNamespace(pkg)
[18:04:41.581]                         base::library(pkg, character.only = TRUE)
[18:04:41.581]                       }
[18:04:41.581]                     })
[18:04:41.581]                   }
[18:04:41.581]                   ...future.strategy.old <- future::plan("list")
[18:04:41.581]                   options(future.plan = NULL)
[18:04:41.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.581]                   future::plan(list(function (..., workers = availableCores(), 
[18:04:41.581]                     lazy = FALSE, rscript_libs = .libPaths(), 
[18:04:41.581]                     envir = parent.frame()) 
[18:04:41.581]                   {
[18:04:41.581]                     if (is.function(workers)) 
[18:04:41.581]                       workers <- workers()
[18:04:41.581]                     workers <- structure(as.integer(workers), 
[18:04:41.581]                       class = class(workers))
[18:04:41.581]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[18:04:41.581]                       workers >= 1)
[18:04:41.581]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[18:04:41.581]                       return(sequential(..., lazy = TRUE, envir = envir))
[18:04:41.581]                     }
[18:04:41.581]                     future <- MultisessionFuture(..., workers = workers, 
[18:04:41.581]                       lazy = lazy, rscript_libs = rscript_libs, 
[18:04:41.581]                       envir = envir)
[18:04:41.581]                     if (!future$lazy) 
[18:04:41.581]                       future <- run(future)
[18:04:41.581]                     invisible(future)
[18:04:41.581]                   }), .cleanup = FALSE, .init = FALSE)
[18:04:41.581]                 }
[18:04:41.581]                 ...future.workdir <- getwd()
[18:04:41.581]             }
[18:04:41.581]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:41.581]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:41.581]         }
[18:04:41.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:41.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:41.581]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:41.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:41.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:41.581]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:41.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:41.581]             base::names(...future.oldOptions))
[18:04:41.581]     }
[18:04:41.581]     if (FALSE) {
[18:04:41.581]     }
[18:04:41.581]     else {
[18:04:41.581]         if (TRUE) {
[18:04:41.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:41.581]                 open = "w")
[18:04:41.581]         }
[18:04:41.581]         else {
[18:04:41.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:41.581]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:41.581]         }
[18:04:41.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:41.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:41.581]             base::sink(type = "output", split = FALSE)
[18:04:41.581]             base::close(...future.stdout)
[18:04:41.581]         }, add = TRUE)
[18:04:41.581]     }
[18:04:41.581]     ...future.frame <- base::sys.nframe()
[18:04:41.581]     ...future.conditions <- base::list()
[18:04:41.581]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:41.581]     if (FALSE) {
[18:04:41.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:41.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:41.581]     }
[18:04:41.581]     ...future.result <- base::tryCatch({
[18:04:41.581]         base::withCallingHandlers({
[18:04:41.581]             ...future.value <- base::withVisible(base::local({
[18:04:41.581]                 a %<-% subset(data, x < 3)$y
[18:04:41.581]                 a
[18:04:41.581]             }))
[18:04:41.581]             future::FutureResult(value = ...future.value$value, 
[18:04:41.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.581]                   ...future.rng), globalenv = if (FALSE) 
[18:04:41.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:41.581]                     ...future.globalenv.names))
[18:04:41.581]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:41.581]         }, condition = base::local({
[18:04:41.581]             c <- base::c
[18:04:41.581]             inherits <- base::inherits
[18:04:41.581]             invokeRestart <- base::invokeRestart
[18:04:41.581]             length <- base::length
[18:04:41.581]             list <- base::list
[18:04:41.581]             seq.int <- base::seq.int
[18:04:41.581]             signalCondition <- base::signalCondition
[18:04:41.581]             sys.calls <- base::sys.calls
[18:04:41.581]             `[[` <- base::`[[`
[18:04:41.581]             `+` <- base::`+`
[18:04:41.581]             `<<-` <- base::`<<-`
[18:04:41.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:41.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:41.581]                   3L)]
[18:04:41.581]             }
[18:04:41.581]             function(cond) {
[18:04:41.581]                 is_error <- inherits(cond, "error")
[18:04:41.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:41.581]                   NULL)
[18:04:41.581]                 if (is_error) {
[18:04:41.581]                   sessionInformation <- function() {
[18:04:41.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:41.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:41.581]                       search = base::search(), system = base::Sys.info())
[18:04:41.581]                   }
[18:04:41.581]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:41.581]                     cond$call), session = sessionInformation(), 
[18:04:41.581]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:41.581]                   signalCondition(cond)
[18:04:41.581]                 }
[18:04:41.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:41.581]                 "immediateCondition"))) {
[18:04:41.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:41.581]                   ...future.conditions[[length(...future.conditions) + 
[18:04:41.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:41.581]                   if (TRUE && !signal) {
[18:04:41.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.581]                     {
[18:04:41.581]                       inherits <- base::inherits
[18:04:41.581]                       invokeRestart <- base::invokeRestart
[18:04:41.581]                       is.null <- base::is.null
[18:04:41.581]                       muffled <- FALSE
[18:04:41.581]                       if (inherits(cond, "message")) {
[18:04:41.581]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.581]                         if (muffled) 
[18:04:41.581]                           invokeRestart("muffleMessage")
[18:04:41.581]                       }
[18:04:41.581]                       else if (inherits(cond, "warning")) {
[18:04:41.581]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.581]                         if (muffled) 
[18:04:41.581]                           invokeRestart("muffleWarning")
[18:04:41.581]                       }
[18:04:41.581]                       else if (inherits(cond, "condition")) {
[18:04:41.581]                         if (!is.null(pattern)) {
[18:04:41.581]                           computeRestarts <- base::computeRestarts
[18:04:41.581]                           grepl <- base::grepl
[18:04:41.581]                           restarts <- computeRestarts(cond)
[18:04:41.581]                           for (restart in restarts) {
[18:04:41.581]                             name <- restart$name
[18:04:41.581]                             if (is.null(name)) 
[18:04:41.581]                               next
[18:04:41.581]                             if (!grepl(pattern, name)) 
[18:04:41.581]                               next
[18:04:41.581]                             invokeRestart(restart)
[18:04:41.581]                             muffled <- TRUE
[18:04:41.581]                             break
[18:04:41.581]                           }
[18:04:41.581]                         }
[18:04:41.581]                       }
[18:04:41.581]                       invisible(muffled)
[18:04:41.581]                     }
[18:04:41.581]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.581]                   }
[18:04:41.581]                 }
[18:04:41.581]                 else {
[18:04:41.581]                   if (TRUE) {
[18:04:41.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:41.581]                     {
[18:04:41.581]                       inherits <- base::inherits
[18:04:41.581]                       invokeRestart <- base::invokeRestart
[18:04:41.581]                       is.null <- base::is.null
[18:04:41.581]                       muffled <- FALSE
[18:04:41.581]                       if (inherits(cond, "message")) {
[18:04:41.581]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:41.581]                         if (muffled) 
[18:04:41.581]                           invokeRestart("muffleMessage")
[18:04:41.581]                       }
[18:04:41.581]                       else if (inherits(cond, "warning")) {
[18:04:41.581]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:41.581]                         if (muffled) 
[18:04:41.581]                           invokeRestart("muffleWarning")
[18:04:41.581]                       }
[18:04:41.581]                       else if (inherits(cond, "condition")) {
[18:04:41.581]                         if (!is.null(pattern)) {
[18:04:41.581]                           computeRestarts <- base::computeRestarts
[18:04:41.581]                           grepl <- base::grepl
[18:04:41.581]                           restarts <- computeRestarts(cond)
[18:04:41.581]                           for (restart in restarts) {
[18:04:41.581]                             name <- restart$name
[18:04:41.581]                             if (is.null(name)) 
[18:04:41.581]                               next
[18:04:41.581]                             if (!grepl(pattern, name)) 
[18:04:41.581]                               next
[18:04:41.581]                             invokeRestart(restart)
[18:04:41.581]                             muffled <- TRUE
[18:04:41.581]                             break
[18:04:41.581]                           }
[18:04:41.581]                         }
[18:04:41.581]                       }
[18:04:41.581]                       invisible(muffled)
[18:04:41.581]                     }
[18:04:41.581]                     muffleCondition(cond, pattern = "^muffle")
[18:04:41.581]                   }
[18:04:41.581]                 }
[18:04:41.581]             }
[18:04:41.581]         }))
[18:04:41.581]     }, error = function(ex) {
[18:04:41.581]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:41.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:41.581]                 ...future.rng), started = ...future.startTime, 
[18:04:41.581]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:41.581]             version = "1.8"), class = "FutureResult")
[18:04:41.581]     }, finally = {
[18:04:41.581]         if (!identical(...future.workdir, getwd())) 
[18:04:41.581]             setwd(...future.workdir)
[18:04:41.581]         {
[18:04:41.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:41.581]                 ...future.oldOptions$nwarnings <- NULL
[18:04:41.581]             }
[18:04:41.581]             base::options(...future.oldOptions)
[18:04:41.581]             if (.Platform$OS.type == "windows") {
[18:04:41.581]                 old_names <- names(...future.oldEnvVars)
[18:04:41.581]                 envs <- base::Sys.getenv()
[18:04:41.581]                 names <- names(envs)
[18:04:41.581]                 common <- intersect(names, old_names)
[18:04:41.581]                 added <- setdiff(names, old_names)
[18:04:41.581]                 removed <- setdiff(old_names, names)
[18:04:41.581]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:41.581]                   envs[common]]
[18:04:41.581]                 NAMES <- toupper(changed)
[18:04:41.581]                 args <- list()
[18:04:41.581]                 for (kk in seq_along(NAMES)) {
[18:04:41.581]                   name <- changed[[kk]]
[18:04:41.581]                   NAME <- NAMES[[kk]]
[18:04:41.581]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.581]                     next
[18:04:41.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.581]                 }
[18:04:41.581]                 NAMES <- toupper(added)
[18:04:41.581]                 for (kk in seq_along(NAMES)) {
[18:04:41.581]                   name <- added[[kk]]
[18:04:41.581]                   NAME <- NAMES[[kk]]
[18:04:41.581]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.581]                     next
[18:04:41.581]                   args[[name]] <- ""
[18:04:41.581]                 }
[18:04:41.581]                 NAMES <- toupper(removed)
[18:04:41.581]                 for (kk in seq_along(NAMES)) {
[18:04:41.581]                   name <- removed[[kk]]
[18:04:41.581]                   NAME <- NAMES[[kk]]
[18:04:41.581]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:41.581]                     next
[18:04:41.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:41.581]                 }
[18:04:41.581]                 if (length(args) > 0) 
[18:04:41.581]                   base::do.call(base::Sys.setenv, args = args)
[18:04:41.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:41.581]             }
[18:04:41.581]             else {
[18:04:41.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:41.581]             }
[18:04:41.581]             {
[18:04:41.581]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:41.581]                   0L) {
[18:04:41.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:41.581]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:41.581]                   base::options(opts)
[18:04:41.581]                 }
[18:04:41.581]                 {
[18:04:41.581]                   {
[18:04:41.581]                     NULL
[18:04:41.581]                     RNGkind("Mersenne-Twister")
[18:04:41.581]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:04:41.581]                       inherits = FALSE)
[18:04:41.581]                   }
[18:04:41.581]                   options(future.plan = NULL)
[18:04:41.581]                   if (is.na(NA_character_)) 
[18:04:41.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:41.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:41.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:41.581]                     .init = FALSE)
[18:04:41.581]                 }
[18:04:41.581]             }
[18:04:41.581]         }
[18:04:41.581]     })
[18:04:41.581]     if (TRUE) {
[18:04:41.581]         base::sink(type = "output", split = FALSE)
[18:04:41.581]         if (TRUE) {
[18:04:41.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:41.581]         }
[18:04:41.581]         else {
[18:04:41.581]             ...future.result["stdout"] <- base::list(NULL)
[18:04:41.581]         }
[18:04:41.581]         base::close(...future.stdout)
[18:04:41.581]         ...future.stdout <- NULL
[18:04:41.581]     }
[18:04:41.581]     ...future.result$conditions <- ...future.conditions
[18:04:41.581]     ...future.result$finished <- base::Sys.time()
[18:04:41.581]     ...future.result
[18:04:41.581] }
[18:04:41.585] assign_globals() ...
[18:04:41.585] List of 1
[18:04:41.585]  $ data:'data.frame':	5 obs. of  2 variables:
[18:04:41.585]   ..$ x: int [1:5] 1 2 3 4 5
[18:04:41.585]   ..$ y: int [1:5] 1 2 3 4 5
[18:04:41.585]  - attr(*, "where")=List of 1
[18:04:41.585]   ..$ data:<environment: R_EmptyEnv> 
[18:04:41.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:04:41.585]  - attr(*, "resolved")= logi FALSE
[18:04:41.585]  - attr(*, "total_size")= num 160
[18:04:41.585]  - attr(*, "already-done")= logi TRUE
[18:04:41.592] - copied ‘data’ to environment
[18:04:41.592] assign_globals() ... done
[18:04:41.593] plan(): Setting new future strategy stack:
[18:04:41.593] List of future strategies:
[18:04:41.593] 1. multisession:
[18:04:41.593]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:41.593]    - tweaked: FALSE
[18:04:41.593]    - call: plan(list(sequential, strategy))
[18:04:41.599] plan(): nbrOfWorkers() = 2
[18:04:42.295] plan(): Setting new future strategy stack:
[18:04:42.296] List of future strategies:
[18:04:42.296] 1. sequential:
[18:04:42.296]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:42.296]    - tweaked: FALSE
[18:04:42.296]    - call: plan(list(sequential, strategy))
[18:04:42.296] 2. multisession:
[18:04:42.296]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:04:42.296]    - tweaked: FALSE
[18:04:42.296]    - call: plan(list(sequential, strategy))
[18:04:42.298] plan(): nbrOfWorkers() = 1
[18:04:42.299] SequentialFuture started (and completed)
[18:04:42.299] signalConditions() ...
[18:04:42.300]  - include = ‘immediateCondition’
[18:04:42.300]  - exclude = 
[18:04:42.300]  - resignal = FALSE
[18:04:42.301]  - Number of conditions: 93
[18:04:42.301] signalConditions() ... done
[18:04:42.301] - Launch lazy future ... done
[18:04:42.302] run() for ‘SequentialFuture’ ... done
[18:04:42.302] signalConditions() ...
[18:04:42.302]  - include = ‘immediateCondition’
[18:04:42.303]  - exclude = 
[18:04:42.303]  - resignal = FALSE
[18:04:42.303]  - Number of conditions: 93
[18:04:42.304] signalConditions() ... done
[18:04:42.304] Future state: ‘finished’
[18:04:42.305] signalConditions() ...
[18:04:42.305]  - include = ‘condition’
[18:04:42.305]  - exclude = ‘immediateCondition’
[18:04:42.306]  - resignal = TRUE
[18:04:42.306]  - Number of conditions: 93
[18:04:42.306]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.600] getGlobalsAndPackages() ...
[18:04:42.307]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[18:04:42.307]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.630] Searching for globals...
[18:04:42.308]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.632] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[18:04:42.308]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.632] Searching for globals ... DONE
[18:04:42.309]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.633] Resolving globals: FALSE
[18:04:42.309]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.634] The total size of the 1 globals is 160 bytes (160 bytes)
[18:04:42.309]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.635] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 160 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (160 bytes of class ‘list’)
[18:04:42.310]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.635] - globals: [1] ‘data’
[18:04:42.310]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.635] 
[18:04:42.311]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.635] getGlobalsAndPackages() ... DONE
[18:04:42.311]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.636] run() for ‘Future’ ...
[18:04:42.312]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.636] - state: ‘created’
[18:04:42.312]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.636] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:04:42.313]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.642] [local output] makeClusterPSOCK() ...
[18:04:42.313]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.653] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:04:42.314]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.655] [local output] Base port: 11564
[18:04:42.315]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.655] [local output] Getting setup options for 2 cluster nodes ...
[18:04:42.315]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.655] [local output]  - Node 1 of 2 ...
[18:04:42.315]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.656] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:42.316]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.657] [local output] Rscript port: 11564

[18:04:42.316]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.658] [local output]  - Node 2 of 2 ...
[18:04:42.316]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.659] [local output] localMachine=TRUE => revtunnel=FALSE

[18:04:42.317]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.660] [local output] Rscript port: 11564

[18:04:42.317]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.661] [local output] Getting setup options for 2 cluster nodes ... done
[18:04:42.317]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.661] [local output]  - Parallel setup requested for some PSOCK nodes
[18:04:42.317]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.662] [local output] Setting up PSOCK nodes in parallel
[18:04:42.318]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.662] List of 36
[18:04:41.662]  $ worker          : chr "localhost"
[18:04:41.662]   ..- attr(*, "localhost")= logi TRUE
[18:04:41.662]  $ master          : chr "localhost"
[18:04:41.662]  $ port            : int 11564
[18:04:41.662]  $ connectTimeout  : num 120
[18:04:41.662]  $ timeout         : num 2592000
[18:04:41.662]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:04:41.662]  $ homogeneous     : logi TRUE
[18:04:41.662]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:04:41.662]  $ rscript_envs    : NULL
[18:04:41.662]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:41.662]  $ rscript_startup : NULL
[18:04:41.662]  $ rscript_sh      : chr "sh"
[18:04:41.662]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:41.662]  $ methods         : logi TRUE
[18:04:41.662]  $ socketOptions   : chr "no-delay"
[18:04:41.662]  $ useXDR          : logi FALSE
[18:04:41.662]  $ outfile         : chr "/dev/null"
[18:04:41.662]  $ renice          : int NA
[18:04:41.662]  $ rshcmd          : NULL
[18:04:41.662]  $ user            : chr(0) 
[18:04:41.662]  $ revtunnel       : logi FALSE
[18:04:41.662]  $ rshlogfile      : NULL
[18:04:41.662]  $ rshopts         : chr(0) 
[18:04:41.662]  $ rank            : int 1
[18:04:41.662]  $ manual          : logi FALSE
[18:04:41.662]  $ dryrun          : logi FALSE
[18:04:41.662]  $ quiet           : logi FALSE
[18:04:41.662]  $ setup_strategy  : chr "parallel"
[18:04:41.662]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:41.662]  $ pidfile         : chr "/tmp/RtmpmRLBA8/worker.rank=1.parallelly.parent=323968.4f18037a21b36.pid"
[18:04:41.662]  $ rshcmd_label    : NULL
[18:04:41.662]  $ rsh_call        : NULL
[18:04:41.662]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:04:41.662]  $ localMachine    : logi TRUE
[18:04:41.662]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:04:41.662]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:04:41.662]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:04:41.662]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:04:41.662]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:04:41.662]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:04:41.662]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:04:41.662]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:04:41.662]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:04:41.662]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:04:41.662]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:04:41.662]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:04:41.662]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:04:41.662]  $ arguments       :List of 28
[18:04:41.662]   ..$ worker          : chr "localhost"
[18:04:41.662]   ..$ master          : NULL
[18:04:41.662]   ..$ port            : int 11564
[18:04:41.662]   ..$ connectTimeout  : num 120
[18:04:41.662]   ..$ timeout         : num 2592000
[18:04:41.662]   ..$ rscript         : NULL
[18:04:41.662]   ..$ homogeneous     : NULL
[18:04:41.662]   ..$ rscript_args    : NULL
[18:04:41.662]   ..$ rscript_envs    : NULL
[18:04:41.662]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:04:41.662]   ..$ rscript_startup : NULL
[18:04:41.662]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:04:41.662]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:04:41.662]   ..$ methods         : logi TRUE
[18:04:41.662]   ..$ socketOptions   : chr "no-delay"
[18:04:41.662]   ..$ useXDR          : logi FALSE
[18:04:41.662]   ..$ outfile         : chr "/dev/null"
[18:04:41.662]   ..$ renice          : int NA
[18:04:41.662]   ..$ rshcmd          : NULL
[18:04:41.662]   ..$ user            : NULL
[18:04:41.662]   ..$ revtunnel       : logi NA
[18:04:41.662]   ..$ rshlogfile      : NULL
[18:04:41.662]   ..$ rshopts         : NULL
[18:04:41.662]   ..$ rank            : int 1
[18:04:41.662]   ..$ manual          : logi FALSE
[18:04:41.662]   ..$ dryrun          : logi FALSE
[18:04:41.662]   ..$ quiet           : logi FALSE
[18:04:41.662]   ..$ setup_strategy  : chr "parallel"
[18:04:41.662]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:04:42.318]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.700] [local output] System call to launch all workers:
[18:04:42.318]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.701] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpmRLBA8/worker.rank=1.parallelly.parent=323968.4f18037a21b36.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11564 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:04:42.319]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.701] [local output] Starting PSOCK main server
[18:04:42.319]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.703] [local output] Workers launched
[18:04:42.319]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.703] [local output] Waiting for workers to connect back
[18:04:42.319]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:41.703]  - [local output] 0 workers out of 2 ready
[18:04:42.320]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.015]  - [local output] 0 workers out of 2 ready
[18:04:42.320]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.017]  - [local output] 1 workers out of 2 ready
[18:04:42.320]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.051]  - [local output] 1 workers out of 2 ready
[18:04:42.321]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.052]  - [local output] 2 workers out of 2 ready
[18:04:42.321]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.052] [local output] Launching of workers completed
[18:04:42.322]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.053] [local output] Collecting session information from workers
[18:04:42.322]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.054] [local output]  - Worker #1 of 2
[18:04:42.323]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.055] [local output]  - Worker #2 of 2
[18:04:42.323]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.055] [local output] makeClusterPSOCK() ... done
[18:04:42.324]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.073] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:04:42.324]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:04:42.325]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.074]   - Field: ‘node’
[18:04:42.325]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.074]   - Field: ‘label’
[18:04:42.326]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.075]   - Field: ‘local’
[18:04:42.327]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.075]   - Field: ‘owner’
[18:04:42.328]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.075]   - Field: ‘envir’
[18:04:42.328]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.075]   - Field: ‘workers’
[18:04:42.328]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.076]   - Field: ‘packages’
[18:04:42.329]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.076]   - Field: ‘gc’
[18:04:42.329]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.076]   - Field: ‘conditions’
[18:04:42.329]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.076]   - Field: ‘persistent’
[18:04:42.330]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.076]   - Field: ‘expr’
[18:04:42.330]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.077]   - Field: ‘uuid’
[18:04:42.330]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.077]   - Field: ‘seed’
[18:04:42.330]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.077]   - Field: ‘version’
[18:04:42.331]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.077]   - Field: ‘result’
[18:04:42.331]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.078]   - Field: ‘asynchronous’
[18:04:42.331]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.078]   - Field: ‘calls’
[18:04:42.332]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.078]   - Field: ‘globals’
[18:04:42.332]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.078]   - Field: ‘stdout’
[18:04:42.332]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.079]   - Field: ‘earlySignal’
[18:04:42.333]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.079]   - Field: ‘lazy’
[18:04:42.333]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.079]   - Field: ‘state’
[18:04:42.333]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.079] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:04:42.333]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.080] - Launch lazy future ...
[18:04:42.334]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.080] Packages needed by the future expression (n = 0): <none>
[18:04:42.334]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.080] Packages needed by future strategies (n = 0): <none>
[18:04:42.334]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.081] {
[18:04:42.081]     {
[18:04:42.081]         {
[18:04:42.081]             ...future.startTime <- base::Sys.time()
[18:04:42.081]             {
[18:04:42.081]                 {
[18:04:42.081]                   {
[18:04:42.081]                     {
[18:04:42.081]                       base::local({
[18:04:42.081]                         has_future <- base::requireNamespace("future", 
[18:04:42.081]                           quietly = TRUE)
[18:04:42.081]                         if (has_future) {
[18:04:42.081]                           ns <- base::getNamespace("future")
[18:04:42.081]                           version <- ns[[".package"]][["version"]]
[18:04:42.081]                           if (is.null(version)) 
[18:04:42.081]                             version <- utils::packageVersion("future")
[18:04:42.081]                         }
[18:04:42.081]                         else {
[18:04:42.081]                           version <- NULL
[18:04:42.081]                         }
[18:04:42.081]                         if (!has_future || version < "1.8.0") {
[18:04:42.081]                           info <- base::c(r_version = base::gsub("R version ", 
[18:04:42.081]                             "", base::R.version$version.string), 
[18:04:42.081]                             platform = base::sprintf("%s (%s-bit)", 
[18:04:42.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:04:42.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:04:42.081]                               "release", "version")], collapse = " "), 
[18:04:42.081]                             hostname = base::Sys.info()[["nodename"]])
[18:04:42.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:04:42.081]                             info)
[18:04:42.081]                           info <- base::paste(info, collapse = "; ")
[18:04:42.081]                           if (!has_future) {
[18:04:42.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:04:42.081]                               info)
[18:04:42.081]                           }
[18:04:42.081]                           else {
[18:04:42.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:04:42.081]                               info, version)
[18:04:42.081]                           }
[18:04:42.081]                           base::stop(msg)
[18:04:42.081]                         }
[18:04:42.081]                       })
[18:04:42.081]                     }
[18:04:42.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:04:42.081]                     base::options(mc.cores = 1L)
[18:04:42.081]                   }
[18:04:42.081]                   ...future.strategy.old <- future::plan("list")
[18:04:42.081]                   options(future.plan = NULL)
[18:04:42.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:04:42.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:04:42.081]                 }
[18:04:42.081]                 ...future.workdir <- getwd()
[18:04:42.081]             }
[18:04:42.081]             ...future.oldOptions <- base::as.list(base::.Options)
[18:04:42.081]             ...future.oldEnvVars <- base::Sys.getenv()
[18:04:42.081]         }
[18:04:42.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[18:04:42.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:04:42.081]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[18:04:42.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:04:42.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:04:42.081]             future.stdout.windows.reencode = NULL, width = 80L)
[18:04:42.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:04:42.081]             base::names(...future.oldOptions))
[18:04:42.081]     }
[18:04:42.081]     if (FALSE) {
[18:04:42.081]     }
[18:04:42.081]     else {
[18:04:42.081]         if (TRUE) {
[18:04:42.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:04:42.081]                 open = "w")
[18:04:42.081]         }
[18:04:42.081]         else {
[18:04:42.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:04:42.081]                 windows = "NUL", "/dev/null"), open = "w")
[18:04:42.081]         }
[18:04:42.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:04:42.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:04:42.081]             base::sink(type = "output", split = FALSE)
[18:04:42.081]             base::close(...future.stdout)
[18:04:42.081]         }, add = TRUE)
[18:04:42.081]     }
[18:04:42.081]     ...future.frame <- base::sys.nframe()
[18:04:42.081]     ...future.conditions <- base::list()
[18:04:42.081]     ...future.rng <- base::globalenv()$.Random.seed
[18:04:42.081]     if (FALSE) {
[18:04:42.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:04:42.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:04:42.081]     }
[18:04:42.081]     ...future.result <- base::tryCatch({
[18:04:42.081]         base::withCallingHandlers({
[18:04:42.081]             ...future.value <- base::withVisible(base::local({
[18:04:42.081]                 ...future.makeSendCondition <- base::local({
[18:04:42.081]                   sendCondition <- NULL
[18:04:42.081]                   function(frame = 1L) {
[18:04:42.081]                     if (is.function(sendCondition)) 
[18:04:42.081]                       return(sendCondition)
[18:04:42.081]                     ns <- getNamespace("parallel")
[18:04:42.081]                     if (exists("sendData", mode = "function", 
[18:04:42.081]                       envir = ns)) {
[18:04:42.081]                       parallel_sendData <- get("sendData", mode = "function", 
[18:04:42.081]                         envir = ns)
[18:04:42.081]                       envir <- sys.frame(frame)
[18:04:42.081]                       master <- NULL
[18:04:42.081]                       while (!identical(envir, .GlobalEnv) && 
[18:04:42.081]                         !identical(envir, emptyenv())) {
[18:04:42.081]                         if (exists("master", mode = "list", envir = envir, 
[18:04:42.081]                           inherits = FALSE)) {
[18:04:42.081]                           master <- get("master", mode = "list", 
[18:04:42.081]                             envir = envir, inherits = FALSE)
[18:04:42.081]                           if (inherits(master, c("SOCKnode", 
[18:04:42.081]                             "SOCK0node"))) {
[18:04:42.081]                             sendCondition <<- function(cond) {
[18:04:42.081]                               data <- list(type = "VALUE", value = cond, 
[18:04:42.081]                                 success = TRUE)
[18:04:42.081]                               parallel_sendData(master, data)
[18:04:42.081]                             }
[18:04:42.081]                             return(sendCondition)
[18:04:42.081]                           }
[18:04:42.081]                         }
[18:04:42.081]                         frame <- frame + 1L
[18:04:42.081]                         envir <- sys.frame(frame)
[18:04:42.081]                       }
[18:04:42.081]                     }
[18:04:42.081]                     sendCondition <<- function(cond) NULL
[18:04:42.081]                   }
[18:04:42.081]                 })
[18:04:42.081]                 withCallingHandlers({
[18:04:42.081]                   subset(data, x < 3)$y
[18:04:42.081]                 }, immediateCondition = function(cond) {
[18:04:42.081]                   sendCondition <- ...future.makeSendCondition()
[18:04:42.081]                   sendCondition(cond)
[18:04:42.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:42.081]                   {
[18:04:42.081]                     inherits <- base::inherits
[18:04:42.081]                     invokeRestart <- base::invokeRestart
[18:04:42.081]                     is.null <- base::is.null
[18:04:42.081]                     muffled <- FALSE
[18:04:42.081]                     if (inherits(cond, "message")) {
[18:04:42.081]                       muffled <- grepl(pattern, "muffleMessage")
[18:04:42.081]                       if (muffled) 
[18:04:42.081]                         invokeRestart("muffleMessage")
[18:04:42.081]                     }
[18:04:42.081]                     else if (inherits(cond, "warning")) {
[18:04:42.081]                       muffled <- grepl(pattern, "muffleWarning")
[18:04:42.081]                       if (muffled) 
[18:04:42.081]                         invokeRestart("muffleWarning")
[18:04:42.081]                     }
[18:04:42.081]                     else if (inherits(cond, "condition")) {
[18:04:42.081]                       if (!is.null(pattern)) {
[18:04:42.081]                         computeRestarts <- base::computeRestarts
[18:04:42.081]                         grepl <- base::grepl
[18:04:42.081]                         restarts <- computeRestarts(cond)
[18:04:42.081]                         for (restart in restarts) {
[18:04:42.081]                           name <- restart$name
[18:04:42.081]                           if (is.null(name)) 
[18:04:42.081]                             next
[18:04:42.081]                           if (!grepl(pattern, name)) 
[18:04:42.081]                             next
[18:04:42.081]                           invokeRestart(restart)
[18:04:42.081]                           muffled <- TRUE
[18:04:42.081]                           break
[18:04:42.081]                         }
[18:04:42.081]                       }
[18:04:42.081]                     }
[18:04:42.081]                     invisible(muffled)
[18:04:42.081]                   }
[18:04:42.081]                   muffleCondition(cond)
[18:04:42.081]                 })
[18:04:42.081]             }))
[18:04:42.081]             future::FutureResult(value = ...future.value$value, 
[18:04:42.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:42.081]                   ...future.rng), globalenv = if (FALSE) 
[18:04:42.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:04:42.081]                     ...future.globalenv.names))
[18:04:42.081]                 else NULL, started = ...future.startTime, version = "1.8")
[18:04:42.081]         }, condition = base::local({
[18:04:42.081]             c <- base::c
[18:04:42.081]             inherits <- base::inherits
[18:04:42.081]             invokeRestart <- base::invokeRestart
[18:04:42.081]             length <- base::length
[18:04:42.081]             list <- base::list
[18:04:42.081]             seq.int <- base::seq.int
[18:04:42.081]             signalCondition <- base::signalCondition
[18:04:42.081]             sys.calls <- base::sys.calls
[18:04:42.081]             `[[` <- base::`[[`
[18:04:42.081]             `+` <- base::`+`
[18:04:42.081]             `<<-` <- base::`<<-`
[18:04:42.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:04:42.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:04:42.081]                   3L)]
[18:04:42.081]             }
[18:04:42.081]             function(cond) {
[18:04:42.081]                 is_error <- inherits(cond, "error")
[18:04:42.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:04:42.081]                   NULL)
[18:04:42.081]                 if (is_error) {
[18:04:42.081]                   sessionInformation <- function() {
[18:04:42.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:04:42.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:04:42.081]                       search = base::search(), system = base::Sys.info())
[18:04:42.081]                   }
[18:04:42.081]                   ...future.conditions[[length(...future.conditions) + 
[18:04:42.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:04:42.081]                     cond$call), session = sessionInformation(), 
[18:04:42.081]                     timestamp = base::Sys.time(), signaled = 0L)
[18:04:42.081]                   signalCondition(cond)
[18:04:42.081]                 }
[18:04:42.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:04:42.081]                 "immediateCondition"))) {
[18:04:42.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:04:42.081]                   ...future.conditions[[length(...future.conditions) + 
[18:04:42.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:04:42.081]                   if (TRUE && !signal) {
[18:04:42.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:42.081]                     {
[18:04:42.081]                       inherits <- base::inherits
[18:04:42.081]                       invokeRestart <- base::invokeRestart
[18:04:42.081]                       is.null <- base::is.null
[18:04:42.081]                       muffled <- FALSE
[18:04:42.081]                       if (inherits(cond, "message")) {
[18:04:42.081]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:42.081]                         if (muffled) 
[18:04:42.081]                           invokeRestart("muffleMessage")
[18:04:42.081]                       }
[18:04:42.081]                       else if (inherits(cond, "warning")) {
[18:04:42.081]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:42.081]                         if (muffled) 
[18:04:42.081]                           invokeRestart("muffleWarning")
[18:04:42.081]                       }
[18:04:42.081]                       else if (inherits(cond, "condition")) {
[18:04:42.081]                         if (!is.null(pattern)) {
[18:04:42.081]                           computeRestarts <- base::computeRestarts
[18:04:42.081]                           grepl <- base::grepl
[18:04:42.081]                           restarts <- computeRestarts(cond)
[18:04:42.081]                           for (restart in restarts) {
[18:04:42.081]                             name <- restart$name
[18:04:42.081]                             if (is.null(name)) 
[18:04:42.081]                               next
[18:04:42.081]                             if (!grepl(pattern, name)) 
[18:04:42.081]                               next
[18:04:42.081]                             invokeRestart(restart)
[18:04:42.081]                             muffled <- TRUE
[18:04:42.081]                             break
[18:04:42.081]                           }
[18:04:42.081]                         }
[18:04:42.081]                       }
[18:04:42.081]                       invisible(muffled)
[18:04:42.081]                     }
[18:04:42.081]                     muffleCondition(cond, pattern = "^muffle")
[18:04:42.081]                   }
[18:04:42.081]                 }
[18:04:42.081]                 else {
[18:04:42.081]                   if (TRUE) {
[18:04:42.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:04:42.081]                     {
[18:04:42.081]                       inherits <- base::inherits
[18:04:42.081]                       invokeRestart <- base::invokeRestart
[18:04:42.081]                       is.null <- base::is.null
[18:04:42.081]                       muffled <- FALSE
[18:04:42.081]                       if (inherits(cond, "message")) {
[18:04:42.081]                         muffled <- grepl(pattern, "muffleMessage")
[18:04:42.081]                         if (muffled) 
[18:04:42.081]                           invokeRestart("muffleMessage")
[18:04:42.081]                       }
[18:04:42.081]                       else if (inherits(cond, "warning")) {
[18:04:42.081]                         muffled <- grepl(pattern, "muffleWarning")
[18:04:42.081]                         if (muffled) 
[18:04:42.081]                           invokeRestart("muffleWarning")
[18:04:42.081]                       }
[18:04:42.081]                       else if (inherits(cond, "condition")) {
[18:04:42.081]                         if (!is.null(pattern)) {
[18:04:42.081]                           computeRestarts <- base::computeRestarts
[18:04:42.081]                           grepl <- base::grepl
[18:04:42.081]                           restarts <- computeRestarts(cond)
[18:04:42.081]                           for (restart in restarts) {
[18:04:42.081]                             name <- restart$name
[18:04:42.081]                             if (is.null(name)) 
[18:04:42.081]                               next
[18:04:42.081]                             if (!grepl(pattern, name)) 
[18:04:42.081]                               next
[18:04:42.081]                             invokeRestart(restart)
[18:04:42.081]                             muffled <- TRUE
[18:04:42.081]                             break
[18:04:42.081]                           }
[18:04:42.081]                         }
[18:04:42.081]                       }
[18:04:42.081]                       invisible(muffled)
[18:04:42.081]                     }
[18:04:42.081]                     muffleCondition(cond, pattern = "^muffle")
[18:04:42.081]                   }
[18:04:42.081]                 }
[18:04:42.081]             }
[18:04:42.081]         }))
[18:04:42.081]     }, error = function(ex) {
[18:04:42.081]         base::structure(base::list(value = NULL, visible = NULL, 
[18:04:42.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:04:42.081]                 ...future.rng), started = ...future.startTime, 
[18:04:42.081]             finished = Sys.time(), session_uuid = NA_character_, 
[18:04:42.081]             version = "1.8"), class = "FutureResult")
[18:04:42.081]     }, finally = {
[18:04:42.081]         if (!identical(...future.workdir, getwd())) 
[18:04:42.081]             setwd(...future.workdir)
[18:04:42.081]         {
[18:04:42.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:04:42.081]                 ...future.oldOptions$nwarnings <- NULL
[18:04:42.081]             }
[18:04:42.081]             base::options(...future.oldOptions)
[18:04:42.081]             if (.Platform$OS.type == "windows") {
[18:04:42.081]                 old_names <- names(...future.oldEnvVars)
[18:04:42.081]                 envs <- base::Sys.getenv()
[18:04:42.081]                 names <- names(envs)
[18:04:42.081]                 common <- intersect(names, old_names)
[18:04:42.081]                 added <- setdiff(names, old_names)
[18:04:42.081]                 removed <- setdiff(old_names, names)
[18:04:42.081]                 changed <- common[...future.oldEnvVars[common] != 
[18:04:42.081]                   envs[common]]
[18:04:42.081]                 NAMES <- toupper(changed)
[18:04:42.081]                 args <- list()
[18:04:42.081]                 for (kk in seq_along(NAMES)) {
[18:04:42.081]                   name <- changed[[kk]]
[18:04:42.081]                   NAME <- NAMES[[kk]]
[18:04:42.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:42.081]                     next
[18:04:42.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:42.081]                 }
[18:04:42.081]                 NAMES <- toupper(added)
[18:04:42.081]                 for (kk in seq_along(NAMES)) {
[18:04:42.081]                   name <- added[[kk]]
[18:04:42.081]                   NAME <- NAMES[[kk]]
[18:04:42.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:42.081]                     next
[18:04:42.081]                   args[[name]] <- ""
[18:04:42.081]                 }
[18:04:42.081]                 NAMES <- toupper(removed)
[18:04:42.081]                 for (kk in seq_along(NAMES)) {
[18:04:42.081]                   name <- removed[[kk]]
[18:04:42.081]                   NAME <- NAMES[[kk]]
[18:04:42.081]                   if (name != NAME && is.element(NAME, old_names)) 
[18:04:42.081]                     next
[18:04:42.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:04:42.081]                 }
[18:04:42.081]                 if (length(args) > 0) 
[18:04:42.081]                   base::do.call(base::Sys.setenv, args = args)
[18:04:42.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:04:42.081]             }
[18:04:42.081]             else {
[18:04:42.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:04:42.081]             }
[18:04:42.081]             {
[18:04:42.081]                 if (base::length(...future.futureOptionsAdded) > 
[18:04:42.081]                   0L) {
[18:04:42.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:04:42.081]                   base::names(opts) <- ...future.futureOptionsAdded
[18:04:42.081]                   base::options(opts)
[18:04:42.081]                 }
[18:04:42.081]                 {
[18:04:42.081]                   {
[18:04:42.081]                     base::options(mc.cores = ...future.mc.cores.old)
[18:04:42.081]                     NULL
[18:04:42.081]                   }
[18:04:42.081]                   options(future.plan = NULL)
[18:04:42.081]                   if (is.na(NA_character_)) 
[18:04:42.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:04:42.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:04:42.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:04:42.081]                     .init = FALSE)
[18:04:42.081]                 }
[18:04:42.081]             }
[18:04:42.081]         }
[18:04:42.081]     })
[18:04:42.081]     if (TRUE) {
[18:04:42.081]         base::sink(type = "output", split = FALSE)
[18:04:42.081]         if (TRUE) {
[18:04:42.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:04:42.081]         }
[18:04:42.081]         else {
[18:04:42.081]             ...future.result["stdout"] <- base::list(NULL)
[18:04:42.081]         }
[18:04:42.081]         base::close(...future.stdout)
[18:04:42.081]         ...future.stdout <- NULL
[18:04:42.081]     }
[18:04:42.081]     ...future.result$conditions <- ...future.conditions
[18:04:42.081]     ...future.result$finished <- base::Sys.time()
[18:04:42.081]     ...future.result
[18:04:42.081] }
[18:04:42.335]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.178] Exporting 1 global objects (160 bytes) to cluster node #1 ...
[18:04:42.335]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.179] Exporting ‘data’ (160 bytes) to cluster node #1 ...
[18:04:42.335]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.180] Exporting ‘data’ (160 bytes) to cluster node #1 ... DONE
[18:04:42.335]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.180] Exporting 1 global objects (160 bytes) to cluster node #1 ... DONE
[18:04:42.336]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.181] MultisessionFuture started
[18:04:42.336]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.182] - Launch lazy future ... done
[18:04:42.336]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.182] run() for ‘MultisessionFuture’ ... done
[18:04:42.336]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.183] result() for ClusterFuture ...
[18:04:42.337]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.183] receiveMessageFromWorker() for ClusterFuture ...
[18:04:42.337]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.183] - Validating connection of MultisessionFuture
[18:04:42.337]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.286] - received message: FutureResult
[18:04:42.338]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.287] - Received FutureResult
[18:04:42.338]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.288] - Erased future from FutureRegistry
[18:04:42.338]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.291] result() for ClusterFuture ...
[18:04:42.338]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.292] - result already collected: FutureResult
[18:04:42.339]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.292] result() for ClusterFuture ... done
[18:04:42.339]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.293] receiveMessageFromWorker() for ClusterFuture ... done
[18:04:42.339]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.293] result() for ClusterFuture ... done
[18:04:42.340]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.293] result() for ClusterFuture ...
[18:04:42.340]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.294] - result already collected: FutureResult
[18:04:42.340]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[18:04:42.294] result() for ClusterFuture ... done
[18:04:42.341] signalConditions() ... done
- Strategy: multisession ... DONE
> 
> 
> message("*** Globals w/ non-standard evaluation (NSE) ... DONE")
*** Globals w/ non-standard evaluation (NSE) ... DONE
> 
> source("incl/end.R")
[18:04:42.342] plan(): Setting new future strategy stack:
[18:04:42.343] List of future strategies:
[18:04:42.343] 1. FutureStrategy:
[18:04:42.343]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:04:42.343]    - tweaked: FALSE
[18:04:42.343]    - call: future::plan(oplan)
[18:04:42.345] plan(): nbrOfWorkers() = 1
> 
