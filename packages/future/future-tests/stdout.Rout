
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:48:37.854] plan(): Setting new future strategy stack:
[17:48:37.855] List of future strategies:
[17:48:37.855] 1. sequential:
[17:48:37.855]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.855]    - tweaked: FALSE
[17:48:37.855]    - call: future::plan("sequential")
[17:48:37.866] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[17:48:37.915] plan(): Setting new future strategy stack:
[17:48:37.915] List of future strategies:
[17:48:37.915] 1. sequential:
[17:48:37.915]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.915]    - tweaked: FALSE
[17:48:37.915]    - call: plan(strategy)
[17:48:37.926] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[17:48:37.926] getGlobalsAndPackages() ...
[17:48:37.927] Searching for globals...
[17:48:37.936] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:37.936] Searching for globals ... DONE
[17:48:37.937] Resolving globals: FALSE
[17:48:37.937] 
[17:48:37.937] - packages: [1] ‘utils’
[17:48:37.937] getGlobalsAndPackages() ... DONE
[17:48:37.938] run() for ‘Future’ ...
[17:48:37.938] - state: ‘created’
[17:48:37.938] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:37.939] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:37.939] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:37.939]   - Field: ‘label’
[17:48:37.939]   - Field: ‘local’
[17:48:37.939]   - Field: ‘owner’
[17:48:37.939]   - Field: ‘envir’
[17:48:37.939]   - Field: ‘packages’
[17:48:37.939]   - Field: ‘gc’
[17:48:37.939]   - Field: ‘conditions’
[17:48:37.940]   - Field: ‘expr’
[17:48:37.940]   - Field: ‘uuid’
[17:48:37.940]   - Field: ‘seed’
[17:48:37.940]   - Field: ‘version’
[17:48:37.940]   - Field: ‘result’
[17:48:37.940]   - Field: ‘asynchronous’
[17:48:37.940]   - Field: ‘calls’
[17:48:37.940]   - Field: ‘globals’
[17:48:37.940]   - Field: ‘stdout’
[17:48:37.940]   - Field: ‘earlySignal’
[17:48:37.940]   - Field: ‘lazy’
[17:48:37.941]   - Field: ‘state’
[17:48:37.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:37.941] - Launch lazy future ...
[17:48:37.941] Packages needed by the future expression (n = 1): ‘utils’
[17:48:37.942] Packages needed by future strategies (n = 0): <none>
[17:48:37.942] {
[17:48:37.942]     {
[17:48:37.942]         {
[17:48:37.942]             ...future.startTime <- base::Sys.time()
[17:48:37.942]             {
[17:48:37.942]                 {
[17:48:37.942]                   {
[17:48:37.942]                     {
[17:48:37.942]                       base::local({
[17:48:37.942]                         has_future <- base::requireNamespace("future", 
[17:48:37.942]                           quietly = TRUE)
[17:48:37.942]                         if (has_future) {
[17:48:37.942]                           ns <- base::getNamespace("future")
[17:48:37.942]                           version <- ns[[".package"]][["version"]]
[17:48:37.942]                           if (is.null(version)) 
[17:48:37.942]                             version <- utils::packageVersion("future")
[17:48:37.942]                         }
[17:48:37.942]                         else {
[17:48:37.942]                           version <- NULL
[17:48:37.942]                         }
[17:48:37.942]                         if (!has_future || version < "1.8.0") {
[17:48:37.942]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:37.942]                             "", base::R.version$version.string), 
[17:48:37.942]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:37.942]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:37.942]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:37.942]                               "release", "version")], collapse = " "), 
[17:48:37.942]                             hostname = base::Sys.info()[["nodename"]])
[17:48:37.942]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:37.942]                             info)
[17:48:37.942]                           info <- base::paste(info, collapse = "; ")
[17:48:37.942]                           if (!has_future) {
[17:48:37.942]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:37.942]                               info)
[17:48:37.942]                           }
[17:48:37.942]                           else {
[17:48:37.942]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:37.942]                               info, version)
[17:48:37.942]                           }
[17:48:37.942]                           base::stop(msg)
[17:48:37.942]                         }
[17:48:37.942]                       })
[17:48:37.942]                     }
[17:48:37.942]                     base::local({
[17:48:37.942]                       for (pkg in "utils") {
[17:48:37.942]                         base::loadNamespace(pkg)
[17:48:37.942]                         base::library(pkg, character.only = TRUE)
[17:48:37.942]                       }
[17:48:37.942]                     })
[17:48:37.942]                   }
[17:48:37.942]                   ...future.strategy.old <- future::plan("list")
[17:48:37.942]                   options(future.plan = NULL)
[17:48:37.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:37.942]                 }
[17:48:37.942]                 ...future.workdir <- getwd()
[17:48:37.942]             }
[17:48:37.942]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:37.942]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:37.942]         }
[17:48:37.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:37.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:37.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:37.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:37.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:37.942]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:37.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:37.942]             base::names(...future.oldOptions))
[17:48:37.942]     }
[17:48:37.942]     if (FALSE) {
[17:48:37.942]     }
[17:48:37.942]     else {
[17:48:37.942]         if (TRUE) {
[17:48:37.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:37.942]                 open = "w")
[17:48:37.942]         }
[17:48:37.942]         else {
[17:48:37.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:37.942]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:37.942]         }
[17:48:37.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:37.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:37.942]             base::sink(type = "output", split = FALSE)
[17:48:37.942]             base::close(...future.stdout)
[17:48:37.942]         }, add = TRUE)
[17:48:37.942]     }
[17:48:37.942]     ...future.frame <- base::sys.nframe()
[17:48:37.942]     ...future.conditions <- base::list()
[17:48:37.942]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:37.942]     if (FALSE) {
[17:48:37.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:37.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:37.942]     }
[17:48:37.942]     ...future.result <- base::tryCatch({
[17:48:37.942]         base::withCallingHandlers({
[17:48:37.942]             ...future.value <- base::withVisible(base::local({
[17:48:37.942]                 print(1:50)
[17:48:37.942]                 str(1:50)
[17:48:37.942]                 cat(letters, sep = "-")
[17:48:37.942]                 cat(1:6, collapse = "\n")
[17:48:37.942]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:37.942]                 42L
[17:48:37.942]             }))
[17:48:37.942]             future::FutureResult(value = ...future.value$value, 
[17:48:37.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.942]                   ...future.rng), globalenv = if (FALSE) 
[17:48:37.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:37.942]                     ...future.globalenv.names))
[17:48:37.942]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:37.942]         }, condition = base::local({
[17:48:37.942]             c <- base::c
[17:48:37.942]             inherits <- base::inherits
[17:48:37.942]             invokeRestart <- base::invokeRestart
[17:48:37.942]             length <- base::length
[17:48:37.942]             list <- base::list
[17:48:37.942]             seq.int <- base::seq.int
[17:48:37.942]             signalCondition <- base::signalCondition
[17:48:37.942]             sys.calls <- base::sys.calls
[17:48:37.942]             `[[` <- base::`[[`
[17:48:37.942]             `+` <- base::`+`
[17:48:37.942]             `<<-` <- base::`<<-`
[17:48:37.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:37.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:37.942]                   3L)]
[17:48:37.942]             }
[17:48:37.942]             function(cond) {
[17:48:37.942]                 is_error <- inherits(cond, "error")
[17:48:37.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:37.942]                   NULL)
[17:48:37.942]                 if (is_error) {
[17:48:37.942]                   sessionInformation <- function() {
[17:48:37.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:37.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:37.942]                       search = base::search(), system = base::Sys.info())
[17:48:37.942]                   }
[17:48:37.942]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:37.942]                     cond$call), session = sessionInformation(), 
[17:48:37.942]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:37.942]                   signalCondition(cond)
[17:48:37.942]                 }
[17:48:37.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:37.942]                 "immediateCondition"))) {
[17:48:37.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:37.942]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:37.942]                   if (TRUE && !signal) {
[17:48:37.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.942]                     {
[17:48:37.942]                       inherits <- base::inherits
[17:48:37.942]                       invokeRestart <- base::invokeRestart
[17:48:37.942]                       is.null <- base::is.null
[17:48:37.942]                       muffled <- FALSE
[17:48:37.942]                       if (inherits(cond, "message")) {
[17:48:37.942]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.942]                         if (muffled) 
[17:48:37.942]                           invokeRestart("muffleMessage")
[17:48:37.942]                       }
[17:48:37.942]                       else if (inherits(cond, "warning")) {
[17:48:37.942]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.942]                         if (muffled) 
[17:48:37.942]                           invokeRestart("muffleWarning")
[17:48:37.942]                       }
[17:48:37.942]                       else if (inherits(cond, "condition")) {
[17:48:37.942]                         if (!is.null(pattern)) {
[17:48:37.942]                           computeRestarts <- base::computeRestarts
[17:48:37.942]                           grepl <- base::grepl
[17:48:37.942]                           restarts <- computeRestarts(cond)
[17:48:37.942]                           for (restart in restarts) {
[17:48:37.942]                             name <- restart$name
[17:48:37.942]                             if (is.null(name)) 
[17:48:37.942]                               next
[17:48:37.942]                             if (!grepl(pattern, name)) 
[17:48:37.942]                               next
[17:48:37.942]                             invokeRestart(restart)
[17:48:37.942]                             muffled <- TRUE
[17:48:37.942]                             break
[17:48:37.942]                           }
[17:48:37.942]                         }
[17:48:37.942]                       }
[17:48:37.942]                       invisible(muffled)
[17:48:37.942]                     }
[17:48:37.942]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.942]                   }
[17:48:37.942]                 }
[17:48:37.942]                 else {
[17:48:37.942]                   if (TRUE) {
[17:48:37.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.942]                     {
[17:48:37.942]                       inherits <- base::inherits
[17:48:37.942]                       invokeRestart <- base::invokeRestart
[17:48:37.942]                       is.null <- base::is.null
[17:48:37.942]                       muffled <- FALSE
[17:48:37.942]                       if (inherits(cond, "message")) {
[17:48:37.942]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.942]                         if (muffled) 
[17:48:37.942]                           invokeRestart("muffleMessage")
[17:48:37.942]                       }
[17:48:37.942]                       else if (inherits(cond, "warning")) {
[17:48:37.942]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.942]                         if (muffled) 
[17:48:37.942]                           invokeRestart("muffleWarning")
[17:48:37.942]                       }
[17:48:37.942]                       else if (inherits(cond, "condition")) {
[17:48:37.942]                         if (!is.null(pattern)) {
[17:48:37.942]                           computeRestarts <- base::computeRestarts
[17:48:37.942]                           grepl <- base::grepl
[17:48:37.942]                           restarts <- computeRestarts(cond)
[17:48:37.942]                           for (restart in restarts) {
[17:48:37.942]                             name <- restart$name
[17:48:37.942]                             if (is.null(name)) 
[17:48:37.942]                               next
[17:48:37.942]                             if (!grepl(pattern, name)) 
[17:48:37.942]                               next
[17:48:37.942]                             invokeRestart(restart)
[17:48:37.942]                             muffled <- TRUE
[17:48:37.942]                             break
[17:48:37.942]                           }
[17:48:37.942]                         }
[17:48:37.942]                       }
[17:48:37.942]                       invisible(muffled)
[17:48:37.942]                     }
[17:48:37.942]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.942]                   }
[17:48:37.942]                 }
[17:48:37.942]             }
[17:48:37.942]         }))
[17:48:37.942]     }, error = function(ex) {
[17:48:37.942]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:37.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.942]                 ...future.rng), started = ...future.startTime, 
[17:48:37.942]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:37.942]             version = "1.8"), class = "FutureResult")
[17:48:37.942]     }, finally = {
[17:48:37.942]         if (!identical(...future.workdir, getwd())) 
[17:48:37.942]             setwd(...future.workdir)
[17:48:37.942]         {
[17:48:37.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:37.942]                 ...future.oldOptions$nwarnings <- NULL
[17:48:37.942]             }
[17:48:37.942]             base::options(...future.oldOptions)
[17:48:37.942]             if (.Platform$OS.type == "windows") {
[17:48:37.942]                 old_names <- names(...future.oldEnvVars)
[17:48:37.942]                 envs <- base::Sys.getenv()
[17:48:37.942]                 names <- names(envs)
[17:48:37.942]                 common <- intersect(names, old_names)
[17:48:37.942]                 added <- setdiff(names, old_names)
[17:48:37.942]                 removed <- setdiff(old_names, names)
[17:48:37.942]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:37.942]                   envs[common]]
[17:48:37.942]                 NAMES <- toupper(changed)
[17:48:37.942]                 args <- list()
[17:48:37.942]                 for (kk in seq_along(NAMES)) {
[17:48:37.942]                   name <- changed[[kk]]
[17:48:37.942]                   NAME <- NAMES[[kk]]
[17:48:37.942]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.942]                     next
[17:48:37.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.942]                 }
[17:48:37.942]                 NAMES <- toupper(added)
[17:48:37.942]                 for (kk in seq_along(NAMES)) {
[17:48:37.942]                   name <- added[[kk]]
[17:48:37.942]                   NAME <- NAMES[[kk]]
[17:48:37.942]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.942]                     next
[17:48:37.942]                   args[[name]] <- ""
[17:48:37.942]                 }
[17:48:37.942]                 NAMES <- toupper(removed)
[17:48:37.942]                 for (kk in seq_along(NAMES)) {
[17:48:37.942]                   name <- removed[[kk]]
[17:48:37.942]                   NAME <- NAMES[[kk]]
[17:48:37.942]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.942]                     next
[17:48:37.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.942]                 }
[17:48:37.942]                 if (length(args) > 0) 
[17:48:37.942]                   base::do.call(base::Sys.setenv, args = args)
[17:48:37.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:37.942]             }
[17:48:37.942]             else {
[17:48:37.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:37.942]             }
[17:48:37.942]             {
[17:48:37.942]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:37.942]                   0L) {
[17:48:37.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:37.942]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:37.942]                   base::options(opts)
[17:48:37.942]                 }
[17:48:37.942]                 {
[17:48:37.942]                   {
[17:48:37.942]                     NULL
[17:48:37.942]                     RNGkind("Mersenne-Twister")
[17:48:37.942]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:37.942]                       inherits = FALSE)
[17:48:37.942]                   }
[17:48:37.942]                   options(future.plan = NULL)
[17:48:37.942]                   if (is.na(NA_character_)) 
[17:48:37.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:37.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:37.942]                     .init = FALSE)
[17:48:37.942]                 }
[17:48:37.942]             }
[17:48:37.942]         }
[17:48:37.942]     })
[17:48:37.942]     if (TRUE) {
[17:48:37.942]         base::sink(type = "output", split = FALSE)
[17:48:37.942]         if (TRUE) {
[17:48:37.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:37.942]         }
[17:48:37.942]         else {
[17:48:37.942]             ...future.result["stdout"] <- base::list(NULL)
[17:48:37.942]         }
[17:48:37.942]         base::close(...future.stdout)
[17:48:37.942]         ...future.stdout <- NULL
[17:48:37.942]     }
[17:48:37.942]     ...future.result$conditions <- ...future.conditions
[17:48:37.942]     ...future.result$finished <- base::Sys.time()
[17:48:37.942]     ...future.result
[17:48:37.942] }
[17:48:37.944] plan(): Setting new future strategy stack:
[17:48:37.945] List of future strategies:
[17:48:37.945] 1. sequential:
[17:48:37.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.945]    - tweaked: FALSE
[17:48:37.945]    - call: NULL
[17:48:37.945] plan(): nbrOfWorkers() = 1
[17:48:37.947] plan(): Setting new future strategy stack:
[17:48:37.947] List of future strategies:
[17:48:37.947] 1. sequential:
[17:48:37.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.947]    - tweaked: FALSE
[17:48:37.947]    - call: plan(strategy)
[17:48:37.947] plan(): nbrOfWorkers() = 1
[17:48:37.947] SequentialFuture started (and completed)
[17:48:37.948] - Launch lazy future ... done
[17:48:37.948] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:37"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:37"
 $ session_uuid: chr "e8c0a985-8f6b-11fa-b01a-2a5b4e1437a9"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50428
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:37"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.00334239 secs (started 2024-11-22 17:48:37.944607)
version: 1.8
[17:48:37.958] getGlobalsAndPackages() ...
[17:48:37.958] Searching for globals...
[17:48:37.960] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:37.961] Searching for globals ... DONE
[17:48:37.961] Resolving globals: FALSE
[17:48:37.961] 
[17:48:37.961] - packages: [1] ‘utils’
[17:48:37.961] getGlobalsAndPackages() ... DONE
[17:48:37.962] run() for ‘Future’ ...
[17:48:37.962] - state: ‘created’
[17:48:37.962] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:37.962] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:37.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:37.962]   - Field: ‘label’
[17:48:37.962]   - Field: ‘local’
[17:48:37.962]   - Field: ‘owner’
[17:48:37.962]   - Field: ‘envir’
[17:48:37.963]   - Field: ‘packages’
[17:48:37.963]   - Field: ‘gc’
[17:48:37.963]   - Field: ‘conditions’
[17:48:37.963]   - Field: ‘expr’
[17:48:37.963]   - Field: ‘uuid’
[17:48:37.963]   - Field: ‘seed’
[17:48:37.963]   - Field: ‘version’
[17:48:37.963]   - Field: ‘result’
[17:48:37.963]   - Field: ‘asynchronous’
[17:48:37.963]   - Field: ‘calls’
[17:48:37.963]   - Field: ‘globals’
[17:48:37.964]   - Field: ‘stdout’
[17:48:37.964]   - Field: ‘earlySignal’
[17:48:37.964]   - Field: ‘lazy’
[17:48:37.964]   - Field: ‘state’
[17:48:37.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:37.964] - Launch lazy future ...
[17:48:37.964] Packages needed by the future expression (n = 1): ‘utils’
[17:48:37.966] Packages needed by future strategies (n = 0): <none>
[17:48:37.967] {
[17:48:37.967]     {
[17:48:37.967]         {
[17:48:37.967]             ...future.startTime <- base::Sys.time()
[17:48:37.967]             {
[17:48:37.967]                 {
[17:48:37.967]                   {
[17:48:37.967]                     {
[17:48:37.967]                       base::local({
[17:48:37.967]                         has_future <- base::requireNamespace("future", 
[17:48:37.967]                           quietly = TRUE)
[17:48:37.967]                         if (has_future) {
[17:48:37.967]                           ns <- base::getNamespace("future")
[17:48:37.967]                           version <- ns[[".package"]][["version"]]
[17:48:37.967]                           if (is.null(version)) 
[17:48:37.967]                             version <- utils::packageVersion("future")
[17:48:37.967]                         }
[17:48:37.967]                         else {
[17:48:37.967]                           version <- NULL
[17:48:37.967]                         }
[17:48:37.967]                         if (!has_future || version < "1.8.0") {
[17:48:37.967]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:37.967]                             "", base::R.version$version.string), 
[17:48:37.967]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:37.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:37.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:37.967]                               "release", "version")], collapse = " "), 
[17:48:37.967]                             hostname = base::Sys.info()[["nodename"]])
[17:48:37.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:37.967]                             info)
[17:48:37.967]                           info <- base::paste(info, collapse = "; ")
[17:48:37.967]                           if (!has_future) {
[17:48:37.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:37.967]                               info)
[17:48:37.967]                           }
[17:48:37.967]                           else {
[17:48:37.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:37.967]                               info, version)
[17:48:37.967]                           }
[17:48:37.967]                           base::stop(msg)
[17:48:37.967]                         }
[17:48:37.967]                       })
[17:48:37.967]                     }
[17:48:37.967]                     base::local({
[17:48:37.967]                       for (pkg in "utils") {
[17:48:37.967]                         base::loadNamespace(pkg)
[17:48:37.967]                         base::library(pkg, character.only = TRUE)
[17:48:37.967]                       }
[17:48:37.967]                     })
[17:48:37.967]                   }
[17:48:37.967]                   ...future.strategy.old <- future::plan("list")
[17:48:37.967]                   options(future.plan = NULL)
[17:48:37.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:37.967]                 }
[17:48:37.967]                 ...future.workdir <- getwd()
[17:48:37.967]             }
[17:48:37.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:37.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:37.967]         }
[17:48:37.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:37.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:37.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:37.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:37.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:37.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:37.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:37.967]             base::names(...future.oldOptions))
[17:48:37.967]     }
[17:48:37.967]     if (FALSE) {
[17:48:37.967]     }
[17:48:37.967]     else {
[17:48:37.967]         if (TRUE) {
[17:48:37.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:37.967]                 open = "w")
[17:48:37.967]         }
[17:48:37.967]         else {
[17:48:37.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:37.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:37.967]         }
[17:48:37.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:37.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:37.967]             base::sink(type = "output", split = FALSE)
[17:48:37.967]             base::close(...future.stdout)
[17:48:37.967]         }, add = TRUE)
[17:48:37.967]     }
[17:48:37.967]     ...future.frame <- base::sys.nframe()
[17:48:37.967]     ...future.conditions <- base::list()
[17:48:37.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:37.967]     if (FALSE) {
[17:48:37.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:37.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:37.967]     }
[17:48:37.967]     ...future.result <- base::tryCatch({
[17:48:37.967]         base::withCallingHandlers({
[17:48:37.967]             ...future.value <- base::withVisible(base::local({
[17:48:37.967]                 print(1:50)
[17:48:37.967]                 str(1:50)
[17:48:37.967]                 cat(letters, sep = "-")
[17:48:37.967]                 cat(1:6, collapse = "\n")
[17:48:37.967]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:37.967]                 42L
[17:48:37.967]             }))
[17:48:37.967]             future::FutureResult(value = ...future.value$value, 
[17:48:37.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.967]                   ...future.rng), globalenv = if (FALSE) 
[17:48:37.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:37.967]                     ...future.globalenv.names))
[17:48:37.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:37.967]         }, condition = base::local({
[17:48:37.967]             c <- base::c
[17:48:37.967]             inherits <- base::inherits
[17:48:37.967]             invokeRestart <- base::invokeRestart
[17:48:37.967]             length <- base::length
[17:48:37.967]             list <- base::list
[17:48:37.967]             seq.int <- base::seq.int
[17:48:37.967]             signalCondition <- base::signalCondition
[17:48:37.967]             sys.calls <- base::sys.calls
[17:48:37.967]             `[[` <- base::`[[`
[17:48:37.967]             `+` <- base::`+`
[17:48:37.967]             `<<-` <- base::`<<-`
[17:48:37.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:37.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:37.967]                   3L)]
[17:48:37.967]             }
[17:48:37.967]             function(cond) {
[17:48:37.967]                 is_error <- inherits(cond, "error")
[17:48:37.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:37.967]                   NULL)
[17:48:37.967]                 if (is_error) {
[17:48:37.967]                   sessionInformation <- function() {
[17:48:37.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:37.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:37.967]                       search = base::search(), system = base::Sys.info())
[17:48:37.967]                   }
[17:48:37.967]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:37.967]                     cond$call), session = sessionInformation(), 
[17:48:37.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:37.967]                   signalCondition(cond)
[17:48:37.967]                 }
[17:48:37.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:37.967]                 "immediateCondition"))) {
[17:48:37.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:37.967]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:37.967]                   if (TRUE && !signal) {
[17:48:37.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.967]                     {
[17:48:37.967]                       inherits <- base::inherits
[17:48:37.967]                       invokeRestart <- base::invokeRestart
[17:48:37.967]                       is.null <- base::is.null
[17:48:37.967]                       muffled <- FALSE
[17:48:37.967]                       if (inherits(cond, "message")) {
[17:48:37.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.967]                         if (muffled) 
[17:48:37.967]                           invokeRestart("muffleMessage")
[17:48:37.967]                       }
[17:48:37.967]                       else if (inherits(cond, "warning")) {
[17:48:37.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.967]                         if (muffled) 
[17:48:37.967]                           invokeRestart("muffleWarning")
[17:48:37.967]                       }
[17:48:37.967]                       else if (inherits(cond, "condition")) {
[17:48:37.967]                         if (!is.null(pattern)) {
[17:48:37.967]                           computeRestarts <- base::computeRestarts
[17:48:37.967]                           grepl <- base::grepl
[17:48:37.967]                           restarts <- computeRestarts(cond)
[17:48:37.967]                           for (restart in restarts) {
[17:48:37.967]                             name <- restart$name
[17:48:37.967]                             if (is.null(name)) 
[17:48:37.967]                               next
[17:48:37.967]                             if (!grepl(pattern, name)) 
[17:48:37.967]                               next
[17:48:37.967]                             invokeRestart(restart)
[17:48:37.967]                             muffled <- TRUE
[17:48:37.967]                             break
[17:48:37.967]                           }
[17:48:37.967]                         }
[17:48:37.967]                       }
[17:48:37.967]                       invisible(muffled)
[17:48:37.967]                     }
[17:48:37.967]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.967]                   }
[17:48:37.967]                 }
[17:48:37.967]                 else {
[17:48:37.967]                   if (TRUE) {
[17:48:37.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.967]                     {
[17:48:37.967]                       inherits <- base::inherits
[17:48:37.967]                       invokeRestart <- base::invokeRestart
[17:48:37.967]                       is.null <- base::is.null
[17:48:37.967]                       muffled <- FALSE
[17:48:37.967]                       if (inherits(cond, "message")) {
[17:48:37.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.967]                         if (muffled) 
[17:48:37.967]                           invokeRestart("muffleMessage")
[17:48:37.967]                       }
[17:48:37.967]                       else if (inherits(cond, "warning")) {
[17:48:37.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.967]                         if (muffled) 
[17:48:37.967]                           invokeRestart("muffleWarning")
[17:48:37.967]                       }
[17:48:37.967]                       else if (inherits(cond, "condition")) {
[17:48:37.967]                         if (!is.null(pattern)) {
[17:48:37.967]                           computeRestarts <- base::computeRestarts
[17:48:37.967]                           grepl <- base::grepl
[17:48:37.967]                           restarts <- computeRestarts(cond)
[17:48:37.967]                           for (restart in restarts) {
[17:48:37.967]                             name <- restart$name
[17:48:37.967]                             if (is.null(name)) 
[17:48:37.967]                               next
[17:48:37.967]                             if (!grepl(pattern, name)) 
[17:48:37.967]                               next
[17:48:37.967]                             invokeRestart(restart)
[17:48:37.967]                             muffled <- TRUE
[17:48:37.967]                             break
[17:48:37.967]                           }
[17:48:37.967]                         }
[17:48:37.967]                       }
[17:48:37.967]                       invisible(muffled)
[17:48:37.967]                     }
[17:48:37.967]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.967]                   }
[17:48:37.967]                 }
[17:48:37.967]             }
[17:48:37.967]         }))
[17:48:37.967]     }, error = function(ex) {
[17:48:37.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:37.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.967]                 ...future.rng), started = ...future.startTime, 
[17:48:37.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:37.967]             version = "1.8"), class = "FutureResult")
[17:48:37.967]     }, finally = {
[17:48:37.967]         if (!identical(...future.workdir, getwd())) 
[17:48:37.967]             setwd(...future.workdir)
[17:48:37.967]         {
[17:48:37.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:37.967]                 ...future.oldOptions$nwarnings <- NULL
[17:48:37.967]             }
[17:48:37.967]             base::options(...future.oldOptions)
[17:48:37.967]             if (.Platform$OS.type == "windows") {
[17:48:37.967]                 old_names <- names(...future.oldEnvVars)
[17:48:37.967]                 envs <- base::Sys.getenv()
[17:48:37.967]                 names <- names(envs)
[17:48:37.967]                 common <- intersect(names, old_names)
[17:48:37.967]                 added <- setdiff(names, old_names)
[17:48:37.967]                 removed <- setdiff(old_names, names)
[17:48:37.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:37.967]                   envs[common]]
[17:48:37.967]                 NAMES <- toupper(changed)
[17:48:37.967]                 args <- list()
[17:48:37.967]                 for (kk in seq_along(NAMES)) {
[17:48:37.967]                   name <- changed[[kk]]
[17:48:37.967]                   NAME <- NAMES[[kk]]
[17:48:37.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.967]                     next
[17:48:37.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.967]                 }
[17:48:37.967]                 NAMES <- toupper(added)
[17:48:37.967]                 for (kk in seq_along(NAMES)) {
[17:48:37.967]                   name <- added[[kk]]
[17:48:37.967]                   NAME <- NAMES[[kk]]
[17:48:37.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.967]                     next
[17:48:37.967]                   args[[name]] <- ""
[17:48:37.967]                 }
[17:48:37.967]                 NAMES <- toupper(removed)
[17:48:37.967]                 for (kk in seq_along(NAMES)) {
[17:48:37.967]                   name <- removed[[kk]]
[17:48:37.967]                   NAME <- NAMES[[kk]]
[17:48:37.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.967]                     next
[17:48:37.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.967]                 }
[17:48:37.967]                 if (length(args) > 0) 
[17:48:37.967]                   base::do.call(base::Sys.setenv, args = args)
[17:48:37.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:37.967]             }
[17:48:37.967]             else {
[17:48:37.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:37.967]             }
[17:48:37.967]             {
[17:48:37.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:37.967]                   0L) {
[17:48:37.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:37.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:37.967]                   base::options(opts)
[17:48:37.967]                 }
[17:48:37.967]                 {
[17:48:37.967]                   {
[17:48:37.967]                     NULL
[17:48:37.967]                     RNGkind("Mersenne-Twister")
[17:48:37.967]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:37.967]                       inherits = FALSE)
[17:48:37.967]                   }
[17:48:37.967]                   options(future.plan = NULL)
[17:48:37.967]                   if (is.na(NA_character_)) 
[17:48:37.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:37.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:37.967]                     .init = FALSE)
[17:48:37.967]                 }
[17:48:37.967]             }
[17:48:37.967]         }
[17:48:37.967]     })
[17:48:37.967]     if (TRUE) {
[17:48:37.967]         base::sink(type = "output", split = FALSE)
[17:48:37.967]         if (TRUE) {
[17:48:37.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:37.967]         }
[17:48:37.967]         else {
[17:48:37.967]             ...future.result["stdout"] <- base::list(NULL)
[17:48:37.967]         }
[17:48:37.967]         base::close(...future.stdout)
[17:48:37.967]         ...future.stdout <- NULL
[17:48:37.967]     }
[17:48:37.967]     ...future.result$conditions <- ...future.conditions
[17:48:37.967]     ...future.result$finished <- base::Sys.time()
[17:48:37.967]     ...future.result
[17:48:37.967] }
[17:48:37.969] plan(): Setting new future strategy stack:
[17:48:37.969] List of future strategies:
[17:48:37.969] 1. sequential:
[17:48:37.969]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.969]    - tweaked: FALSE
[17:48:37.969]    - call: NULL
[17:48:37.969] plan(): nbrOfWorkers() = 1
[17:48:37.970] plan(): Setting new future strategy stack:
[17:48:37.970] List of future strategies:
[17:48:37.970] 1. sequential:
[17:48:37.970]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.970]    - tweaked: FALSE
[17:48:37.970]    - call: plan(strategy)
[17:48:37.971] plan(): nbrOfWorkers() = 1
[17:48:37.971] SequentialFuture started (and completed)
[17:48:37.971] - Launch lazy future ... done
[17:48:37.971] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:48:37.972] getGlobalsAndPackages() ...
[17:48:37.972] Searching for globals...
[17:48:37.972] - globals found: [1] ‘print’
[17:48:37.973] Searching for globals ... DONE
[17:48:37.973] Resolving globals: FALSE
[17:48:37.973] 
[17:48:37.973] 
[17:48:37.973] getGlobalsAndPackages() ... DONE
[17:48:37.973] run() for ‘Future’ ...
[17:48:37.973] - state: ‘created’
[17:48:37.973] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:37.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:37.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:37.974]   - Field: ‘label’
[17:48:37.974]   - Field: ‘local’
[17:48:37.974]   - Field: ‘owner’
[17:48:37.974]   - Field: ‘envir’
[17:48:37.974]   - Field: ‘packages’
[17:48:37.974]   - Field: ‘gc’
[17:48:37.974]   - Field: ‘conditions’
[17:48:37.975]   - Field: ‘expr’
[17:48:37.975]   - Field: ‘uuid’
[17:48:37.975]   - Field: ‘seed’
[17:48:37.975]   - Field: ‘version’
[17:48:37.975]   - Field: ‘result’
[17:48:37.975]   - Field: ‘asynchronous’
[17:48:37.975]   - Field: ‘calls’
[17:48:37.975]   - Field: ‘globals’
[17:48:37.975]   - Field: ‘stdout’
[17:48:37.975]   - Field: ‘earlySignal’
[17:48:37.975]   - Field: ‘lazy’
[17:48:37.976]   - Field: ‘state’
[17:48:37.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:37.976] - Launch lazy future ...
[17:48:37.976] Packages needed by the future expression (n = 0): <none>
[17:48:37.976] Packages needed by future strategies (n = 0): <none>
[17:48:37.976] {
[17:48:37.976]     {
[17:48:37.976]         {
[17:48:37.976]             ...future.startTime <- base::Sys.time()
[17:48:37.976]             {
[17:48:37.976]                 {
[17:48:37.976]                   {
[17:48:37.976]                     base::local({
[17:48:37.976]                       has_future <- base::requireNamespace("future", 
[17:48:37.976]                         quietly = TRUE)
[17:48:37.976]                       if (has_future) {
[17:48:37.976]                         ns <- base::getNamespace("future")
[17:48:37.976]                         version <- ns[[".package"]][["version"]]
[17:48:37.976]                         if (is.null(version)) 
[17:48:37.976]                           version <- utils::packageVersion("future")
[17:48:37.976]                       }
[17:48:37.976]                       else {
[17:48:37.976]                         version <- NULL
[17:48:37.976]                       }
[17:48:37.976]                       if (!has_future || version < "1.8.0") {
[17:48:37.976]                         info <- base::c(r_version = base::gsub("R version ", 
[17:48:37.976]                           "", base::R.version$version.string), 
[17:48:37.976]                           platform = base::sprintf("%s (%s-bit)", 
[17:48:37.976]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:37.976]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:37.976]                             "release", "version")], collapse = " "), 
[17:48:37.976]                           hostname = base::Sys.info()[["nodename"]])
[17:48:37.976]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:48:37.976]                           info)
[17:48:37.976]                         info <- base::paste(info, collapse = "; ")
[17:48:37.976]                         if (!has_future) {
[17:48:37.976]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:37.976]                             info)
[17:48:37.976]                         }
[17:48:37.976]                         else {
[17:48:37.976]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:37.976]                             info, version)
[17:48:37.976]                         }
[17:48:37.976]                         base::stop(msg)
[17:48:37.976]                       }
[17:48:37.976]                     })
[17:48:37.976]                   }
[17:48:37.976]                   ...future.strategy.old <- future::plan("list")
[17:48:37.976]                   options(future.plan = NULL)
[17:48:37.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:37.976]                 }
[17:48:37.976]                 ...future.workdir <- getwd()
[17:48:37.976]             }
[17:48:37.976]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:37.976]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:37.976]         }
[17:48:37.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:37.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:37.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:37.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:37.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:37.976]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:37.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:37.976]             base::names(...future.oldOptions))
[17:48:37.976]     }
[17:48:37.976]     if (FALSE) {
[17:48:37.976]     }
[17:48:37.976]     else {
[17:48:37.976]         if (TRUE) {
[17:48:37.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:37.976]                 open = "w")
[17:48:37.976]         }
[17:48:37.976]         else {
[17:48:37.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:37.976]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:37.976]         }
[17:48:37.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:37.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:37.976]             base::sink(type = "output", split = FALSE)
[17:48:37.976]             base::close(...future.stdout)
[17:48:37.976]         }, add = TRUE)
[17:48:37.976]     }
[17:48:37.976]     ...future.frame <- base::sys.nframe()
[17:48:37.976]     ...future.conditions <- base::list()
[17:48:37.976]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:37.976]     if (FALSE) {
[17:48:37.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:37.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:37.976]     }
[17:48:37.976]     ...future.result <- base::tryCatch({
[17:48:37.976]         base::withCallingHandlers({
[17:48:37.976]             ...future.value <- base::withVisible(base::local(print(42)))
[17:48:37.976]             future::FutureResult(value = ...future.value$value, 
[17:48:37.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.976]                   ...future.rng), globalenv = if (FALSE) 
[17:48:37.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:37.976]                     ...future.globalenv.names))
[17:48:37.976]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:37.976]         }, condition = base::local({
[17:48:37.976]             c <- base::c
[17:48:37.976]             inherits <- base::inherits
[17:48:37.976]             invokeRestart <- base::invokeRestart
[17:48:37.976]             length <- base::length
[17:48:37.976]             list <- base::list
[17:48:37.976]             seq.int <- base::seq.int
[17:48:37.976]             signalCondition <- base::signalCondition
[17:48:37.976]             sys.calls <- base::sys.calls
[17:48:37.976]             `[[` <- base::`[[`
[17:48:37.976]             `+` <- base::`+`
[17:48:37.976]             `<<-` <- base::`<<-`
[17:48:37.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:37.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:37.976]                   3L)]
[17:48:37.976]             }
[17:48:37.976]             function(cond) {
[17:48:37.976]                 is_error <- inherits(cond, "error")
[17:48:37.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:37.976]                   NULL)
[17:48:37.976]                 if (is_error) {
[17:48:37.976]                   sessionInformation <- function() {
[17:48:37.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:37.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:37.976]                       search = base::search(), system = base::Sys.info())
[17:48:37.976]                   }
[17:48:37.976]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:37.976]                     cond$call), session = sessionInformation(), 
[17:48:37.976]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:37.976]                   signalCondition(cond)
[17:48:37.976]                 }
[17:48:37.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:37.976]                 "immediateCondition"))) {
[17:48:37.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:37.976]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:37.976]                   if (TRUE && !signal) {
[17:48:37.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.976]                     {
[17:48:37.976]                       inherits <- base::inherits
[17:48:37.976]                       invokeRestart <- base::invokeRestart
[17:48:37.976]                       is.null <- base::is.null
[17:48:37.976]                       muffled <- FALSE
[17:48:37.976]                       if (inherits(cond, "message")) {
[17:48:37.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.976]                         if (muffled) 
[17:48:37.976]                           invokeRestart("muffleMessage")
[17:48:37.976]                       }
[17:48:37.976]                       else if (inherits(cond, "warning")) {
[17:48:37.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.976]                         if (muffled) 
[17:48:37.976]                           invokeRestart("muffleWarning")
[17:48:37.976]                       }
[17:48:37.976]                       else if (inherits(cond, "condition")) {
[17:48:37.976]                         if (!is.null(pattern)) {
[17:48:37.976]                           computeRestarts <- base::computeRestarts
[17:48:37.976]                           grepl <- base::grepl
[17:48:37.976]                           restarts <- computeRestarts(cond)
[17:48:37.976]                           for (restart in restarts) {
[17:48:37.976]                             name <- restart$name
[17:48:37.976]                             if (is.null(name)) 
[17:48:37.976]                               next
[17:48:37.976]                             if (!grepl(pattern, name)) 
[17:48:37.976]                               next
[17:48:37.976]                             invokeRestart(restart)
[17:48:37.976]                             muffled <- TRUE
[17:48:37.976]                             break
[17:48:37.976]                           }
[17:48:37.976]                         }
[17:48:37.976]                       }
[17:48:37.976]                       invisible(muffled)
[17:48:37.976]                     }
[17:48:37.976]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.976]                   }
[17:48:37.976]                 }
[17:48:37.976]                 else {
[17:48:37.976]                   if (TRUE) {
[17:48:37.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.976]                     {
[17:48:37.976]                       inherits <- base::inherits
[17:48:37.976]                       invokeRestart <- base::invokeRestart
[17:48:37.976]                       is.null <- base::is.null
[17:48:37.976]                       muffled <- FALSE
[17:48:37.976]                       if (inherits(cond, "message")) {
[17:48:37.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.976]                         if (muffled) 
[17:48:37.976]                           invokeRestart("muffleMessage")
[17:48:37.976]                       }
[17:48:37.976]                       else if (inherits(cond, "warning")) {
[17:48:37.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.976]                         if (muffled) 
[17:48:37.976]                           invokeRestart("muffleWarning")
[17:48:37.976]                       }
[17:48:37.976]                       else if (inherits(cond, "condition")) {
[17:48:37.976]                         if (!is.null(pattern)) {
[17:48:37.976]                           computeRestarts <- base::computeRestarts
[17:48:37.976]                           grepl <- base::grepl
[17:48:37.976]                           restarts <- computeRestarts(cond)
[17:48:37.976]                           for (restart in restarts) {
[17:48:37.976]                             name <- restart$name
[17:48:37.976]                             if (is.null(name)) 
[17:48:37.976]                               next
[17:48:37.976]                             if (!grepl(pattern, name)) 
[17:48:37.976]                               next
[17:48:37.976]                             invokeRestart(restart)
[17:48:37.976]                             muffled <- TRUE
[17:48:37.976]                             break
[17:48:37.976]                           }
[17:48:37.976]                         }
[17:48:37.976]                       }
[17:48:37.976]                       invisible(muffled)
[17:48:37.976]                     }
[17:48:37.976]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.976]                   }
[17:48:37.976]                 }
[17:48:37.976]             }
[17:48:37.976]         }))
[17:48:37.976]     }, error = function(ex) {
[17:48:37.976]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:37.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.976]                 ...future.rng), started = ...future.startTime, 
[17:48:37.976]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:37.976]             version = "1.8"), class = "FutureResult")
[17:48:37.976]     }, finally = {
[17:48:37.976]         if (!identical(...future.workdir, getwd())) 
[17:48:37.976]             setwd(...future.workdir)
[17:48:37.976]         {
[17:48:37.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:37.976]                 ...future.oldOptions$nwarnings <- NULL
[17:48:37.976]             }
[17:48:37.976]             base::options(...future.oldOptions)
[17:48:37.976]             if (.Platform$OS.type == "windows") {
[17:48:37.976]                 old_names <- names(...future.oldEnvVars)
[17:48:37.976]                 envs <- base::Sys.getenv()
[17:48:37.976]                 names <- names(envs)
[17:48:37.976]                 common <- intersect(names, old_names)
[17:48:37.976]                 added <- setdiff(names, old_names)
[17:48:37.976]                 removed <- setdiff(old_names, names)
[17:48:37.976]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:37.976]                   envs[common]]
[17:48:37.976]                 NAMES <- toupper(changed)
[17:48:37.976]                 args <- list()
[17:48:37.976]                 for (kk in seq_along(NAMES)) {
[17:48:37.976]                   name <- changed[[kk]]
[17:48:37.976]                   NAME <- NAMES[[kk]]
[17:48:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.976]                     next
[17:48:37.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.976]                 }
[17:48:37.976]                 NAMES <- toupper(added)
[17:48:37.976]                 for (kk in seq_along(NAMES)) {
[17:48:37.976]                   name <- added[[kk]]
[17:48:37.976]                   NAME <- NAMES[[kk]]
[17:48:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.976]                     next
[17:48:37.976]                   args[[name]] <- ""
[17:48:37.976]                 }
[17:48:37.976]                 NAMES <- toupper(removed)
[17:48:37.976]                 for (kk in seq_along(NAMES)) {
[17:48:37.976]                   name <- removed[[kk]]
[17:48:37.976]                   NAME <- NAMES[[kk]]
[17:48:37.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.976]                     next
[17:48:37.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.976]                 }
[17:48:37.976]                 if (length(args) > 0) 
[17:48:37.976]                   base::do.call(base::Sys.setenv, args = args)
[17:48:37.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:37.976]             }
[17:48:37.976]             else {
[17:48:37.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:37.976]             }
[17:48:37.976]             {
[17:48:37.976]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:37.976]                   0L) {
[17:48:37.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:37.976]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:37.976]                   base::options(opts)
[17:48:37.976]                 }
[17:48:37.976]                 {
[17:48:37.976]                   {
[17:48:37.976]                     NULL
[17:48:37.976]                     RNGkind("Mersenne-Twister")
[17:48:37.976]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:37.976]                       inherits = FALSE)
[17:48:37.976]                   }
[17:48:37.976]                   options(future.plan = NULL)
[17:48:37.976]                   if (is.na(NA_character_)) 
[17:48:37.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:37.976]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:37.976]                     .init = FALSE)
[17:48:37.976]                 }
[17:48:37.976]             }
[17:48:37.976]         }
[17:48:37.976]     })
[17:48:37.976]     if (TRUE) {
[17:48:37.976]         base::sink(type = "output", split = FALSE)
[17:48:37.976]         if (TRUE) {
[17:48:37.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:37.976]         }
[17:48:37.976]         else {
[17:48:37.976]             ...future.result["stdout"] <- base::list(NULL)
[17:48:37.976]         }
[17:48:37.976]         base::close(...future.stdout)
[17:48:37.976]         ...future.stdout <- NULL
[17:48:37.976]     }
[17:48:37.976]     ...future.result$conditions <- ...future.conditions
[17:48:37.976]     ...future.result$finished <- base::Sys.time()
[17:48:37.976]     ...future.result
[17:48:37.976] }
[17:48:37.978] plan(): Setting new future strategy stack:
[17:48:37.978] List of future strategies:
[17:48:37.978] 1. sequential:
[17:48:37.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.978]    - tweaked: FALSE
[17:48:37.978]    - call: NULL
[17:48:37.979] plan(): nbrOfWorkers() = 1
[17:48:37.979] plan(): Setting new future strategy stack:
[17:48:37.979] List of future strategies:
[17:48:37.979] 1. sequential:
[17:48:37.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.979]    - tweaked: FALSE
[17:48:37.979]    - call: plan(strategy)
[17:48:37.980] plan(): nbrOfWorkers() = 1
[17:48:37.980] SequentialFuture started (and completed)
[17:48:37.980] - Launch lazy future ... done
[17:48:37.980] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[17:48:37.980] getGlobalsAndPackages() ...
[17:48:37.980] Searching for globals...
[17:48:37.983] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:37.983] Searching for globals ... DONE
[17:48:37.983] Resolving globals: FALSE
[17:48:37.984] 
[17:48:37.984] - packages: [1] ‘utils’
[17:48:37.984] getGlobalsAndPackages() ... DONE
[17:48:37.984] run() for ‘Future’ ...
[17:48:37.984] - state: ‘created’
[17:48:37.984] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:37.985] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:37.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:37.985]   - Field: ‘label’
[17:48:37.985]   - Field: ‘local’
[17:48:37.985]   - Field: ‘owner’
[17:48:37.985]   - Field: ‘envir’
[17:48:37.985]   - Field: ‘packages’
[17:48:37.985]   - Field: ‘gc’
[17:48:37.985]   - Field: ‘conditions’
[17:48:37.985]   - Field: ‘expr’
[17:48:37.986]   - Field: ‘uuid’
[17:48:37.986]   - Field: ‘seed’
[17:48:37.986]   - Field: ‘version’
[17:48:37.986]   - Field: ‘result’
[17:48:37.986]   - Field: ‘asynchronous’
[17:48:37.986]   - Field: ‘calls’
[17:48:37.986]   - Field: ‘globals’
[17:48:37.986]   - Field: ‘stdout’
[17:48:37.986]   - Field: ‘earlySignal’
[17:48:37.986]   - Field: ‘lazy’
[17:48:37.986]   - Field: ‘state’
[17:48:37.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:37.987] - Launch lazy future ...
[17:48:37.987] Packages needed by the future expression (n = 1): ‘utils’
[17:48:37.987] Packages needed by future strategies (n = 0): <none>
[17:48:37.987] {
[17:48:37.987]     {
[17:48:37.987]         {
[17:48:37.987]             ...future.startTime <- base::Sys.time()
[17:48:37.987]             {
[17:48:37.987]                 {
[17:48:37.987]                   {
[17:48:37.987]                     {
[17:48:37.987]                       base::local({
[17:48:37.987]                         has_future <- base::requireNamespace("future", 
[17:48:37.987]                           quietly = TRUE)
[17:48:37.987]                         if (has_future) {
[17:48:37.987]                           ns <- base::getNamespace("future")
[17:48:37.987]                           version <- ns[[".package"]][["version"]]
[17:48:37.987]                           if (is.null(version)) 
[17:48:37.987]                             version <- utils::packageVersion("future")
[17:48:37.987]                         }
[17:48:37.987]                         else {
[17:48:37.987]                           version <- NULL
[17:48:37.987]                         }
[17:48:37.987]                         if (!has_future || version < "1.8.0") {
[17:48:37.987]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:37.987]                             "", base::R.version$version.string), 
[17:48:37.987]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:37.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:37.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:37.987]                               "release", "version")], collapse = " "), 
[17:48:37.987]                             hostname = base::Sys.info()[["nodename"]])
[17:48:37.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:37.987]                             info)
[17:48:37.987]                           info <- base::paste(info, collapse = "; ")
[17:48:37.987]                           if (!has_future) {
[17:48:37.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:37.987]                               info)
[17:48:37.987]                           }
[17:48:37.987]                           else {
[17:48:37.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:37.987]                               info, version)
[17:48:37.987]                           }
[17:48:37.987]                           base::stop(msg)
[17:48:37.987]                         }
[17:48:37.987]                       })
[17:48:37.987]                     }
[17:48:37.987]                     base::local({
[17:48:37.987]                       for (pkg in "utils") {
[17:48:37.987]                         base::loadNamespace(pkg)
[17:48:37.987]                         base::library(pkg, character.only = TRUE)
[17:48:37.987]                       }
[17:48:37.987]                     })
[17:48:37.987]                   }
[17:48:37.987]                   ...future.strategy.old <- future::plan("list")
[17:48:37.987]                   options(future.plan = NULL)
[17:48:37.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:37.987]                 }
[17:48:37.987]                 ...future.workdir <- getwd()
[17:48:37.987]             }
[17:48:37.987]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:37.987]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:37.987]         }
[17:48:37.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:37.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:37.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:37.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:37.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:37.987]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:37.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:37.987]             base::names(...future.oldOptions))
[17:48:37.987]     }
[17:48:37.987]     if (FALSE) {
[17:48:37.987]     }
[17:48:37.987]     else {
[17:48:37.987]         if (FALSE) {
[17:48:37.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:37.987]                 open = "w")
[17:48:37.987]         }
[17:48:37.987]         else {
[17:48:37.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:37.987]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:37.987]         }
[17:48:37.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:37.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:37.987]             base::sink(type = "output", split = FALSE)
[17:48:37.987]             base::close(...future.stdout)
[17:48:37.987]         }, add = TRUE)
[17:48:37.987]     }
[17:48:37.987]     ...future.frame <- base::sys.nframe()
[17:48:37.987]     ...future.conditions <- base::list()
[17:48:37.987]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:37.987]     if (FALSE) {
[17:48:37.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:37.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:37.987]     }
[17:48:37.987]     ...future.result <- base::tryCatch({
[17:48:37.987]         base::withCallingHandlers({
[17:48:37.987]             ...future.value <- base::withVisible(base::local({
[17:48:37.987]                 print(1:50)
[17:48:37.987]                 str(1:50)
[17:48:37.987]                 cat(letters, sep = "-")
[17:48:37.987]                 cat(1:6, collapse = "\n")
[17:48:37.987]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:37.987]                 42L
[17:48:37.987]             }))
[17:48:37.987]             future::FutureResult(value = ...future.value$value, 
[17:48:37.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.987]                   ...future.rng), globalenv = if (FALSE) 
[17:48:37.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:37.987]                     ...future.globalenv.names))
[17:48:37.987]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:37.987]         }, condition = base::local({
[17:48:37.987]             c <- base::c
[17:48:37.987]             inherits <- base::inherits
[17:48:37.987]             invokeRestart <- base::invokeRestart
[17:48:37.987]             length <- base::length
[17:48:37.987]             list <- base::list
[17:48:37.987]             seq.int <- base::seq.int
[17:48:37.987]             signalCondition <- base::signalCondition
[17:48:37.987]             sys.calls <- base::sys.calls
[17:48:37.987]             `[[` <- base::`[[`
[17:48:37.987]             `+` <- base::`+`
[17:48:37.987]             `<<-` <- base::`<<-`
[17:48:37.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:37.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:37.987]                   3L)]
[17:48:37.987]             }
[17:48:37.987]             function(cond) {
[17:48:37.987]                 is_error <- inherits(cond, "error")
[17:48:37.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:37.987]                   NULL)
[17:48:37.987]                 if (is_error) {
[17:48:37.987]                   sessionInformation <- function() {
[17:48:37.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:37.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:37.987]                       search = base::search(), system = base::Sys.info())
[17:48:37.987]                   }
[17:48:37.987]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:37.987]                     cond$call), session = sessionInformation(), 
[17:48:37.987]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:37.987]                   signalCondition(cond)
[17:48:37.987]                 }
[17:48:37.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:37.987]                 "immediateCondition"))) {
[17:48:37.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:37.987]                   ...future.conditions[[length(...future.conditions) + 
[17:48:37.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:37.987]                   if (TRUE && !signal) {
[17:48:37.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.987]                     {
[17:48:37.987]                       inherits <- base::inherits
[17:48:37.987]                       invokeRestart <- base::invokeRestart
[17:48:37.987]                       is.null <- base::is.null
[17:48:37.987]                       muffled <- FALSE
[17:48:37.987]                       if (inherits(cond, "message")) {
[17:48:37.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.987]                         if (muffled) 
[17:48:37.987]                           invokeRestart("muffleMessage")
[17:48:37.987]                       }
[17:48:37.987]                       else if (inherits(cond, "warning")) {
[17:48:37.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.987]                         if (muffled) 
[17:48:37.987]                           invokeRestart("muffleWarning")
[17:48:37.987]                       }
[17:48:37.987]                       else if (inherits(cond, "condition")) {
[17:48:37.987]                         if (!is.null(pattern)) {
[17:48:37.987]                           computeRestarts <- base::computeRestarts
[17:48:37.987]                           grepl <- base::grepl
[17:48:37.987]                           restarts <- computeRestarts(cond)
[17:48:37.987]                           for (restart in restarts) {
[17:48:37.987]                             name <- restart$name
[17:48:37.987]                             if (is.null(name)) 
[17:48:37.987]                               next
[17:48:37.987]                             if (!grepl(pattern, name)) 
[17:48:37.987]                               next
[17:48:37.987]                             invokeRestart(restart)
[17:48:37.987]                             muffled <- TRUE
[17:48:37.987]                             break
[17:48:37.987]                           }
[17:48:37.987]                         }
[17:48:37.987]                       }
[17:48:37.987]                       invisible(muffled)
[17:48:37.987]                     }
[17:48:37.987]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.987]                   }
[17:48:37.987]                 }
[17:48:37.987]                 else {
[17:48:37.987]                   if (TRUE) {
[17:48:37.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:37.987]                     {
[17:48:37.987]                       inherits <- base::inherits
[17:48:37.987]                       invokeRestart <- base::invokeRestart
[17:48:37.987]                       is.null <- base::is.null
[17:48:37.987]                       muffled <- FALSE
[17:48:37.987]                       if (inherits(cond, "message")) {
[17:48:37.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:37.987]                         if (muffled) 
[17:48:37.987]                           invokeRestart("muffleMessage")
[17:48:37.987]                       }
[17:48:37.987]                       else if (inherits(cond, "warning")) {
[17:48:37.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:37.987]                         if (muffled) 
[17:48:37.987]                           invokeRestart("muffleWarning")
[17:48:37.987]                       }
[17:48:37.987]                       else if (inherits(cond, "condition")) {
[17:48:37.987]                         if (!is.null(pattern)) {
[17:48:37.987]                           computeRestarts <- base::computeRestarts
[17:48:37.987]                           grepl <- base::grepl
[17:48:37.987]                           restarts <- computeRestarts(cond)
[17:48:37.987]                           for (restart in restarts) {
[17:48:37.987]                             name <- restart$name
[17:48:37.987]                             if (is.null(name)) 
[17:48:37.987]                               next
[17:48:37.987]                             if (!grepl(pattern, name)) 
[17:48:37.987]                               next
[17:48:37.987]                             invokeRestart(restart)
[17:48:37.987]                             muffled <- TRUE
[17:48:37.987]                             break
[17:48:37.987]                           }
[17:48:37.987]                         }
[17:48:37.987]                       }
[17:48:37.987]                       invisible(muffled)
[17:48:37.987]                     }
[17:48:37.987]                     muffleCondition(cond, pattern = "^muffle")
[17:48:37.987]                   }
[17:48:37.987]                 }
[17:48:37.987]             }
[17:48:37.987]         }))
[17:48:37.987]     }, error = function(ex) {
[17:48:37.987]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:37.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:37.987]                 ...future.rng), started = ...future.startTime, 
[17:48:37.987]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:37.987]             version = "1.8"), class = "FutureResult")
[17:48:37.987]     }, finally = {
[17:48:37.987]         if (!identical(...future.workdir, getwd())) 
[17:48:37.987]             setwd(...future.workdir)
[17:48:37.987]         {
[17:48:37.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:37.987]                 ...future.oldOptions$nwarnings <- NULL
[17:48:37.987]             }
[17:48:37.987]             base::options(...future.oldOptions)
[17:48:37.987]             if (.Platform$OS.type == "windows") {
[17:48:37.987]                 old_names <- names(...future.oldEnvVars)
[17:48:37.987]                 envs <- base::Sys.getenv()
[17:48:37.987]                 names <- names(envs)
[17:48:37.987]                 common <- intersect(names, old_names)
[17:48:37.987]                 added <- setdiff(names, old_names)
[17:48:37.987]                 removed <- setdiff(old_names, names)
[17:48:37.987]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:37.987]                   envs[common]]
[17:48:37.987]                 NAMES <- toupper(changed)
[17:48:37.987]                 args <- list()
[17:48:37.987]                 for (kk in seq_along(NAMES)) {
[17:48:37.987]                   name <- changed[[kk]]
[17:48:37.987]                   NAME <- NAMES[[kk]]
[17:48:37.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.987]                     next
[17:48:37.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.987]                 }
[17:48:37.987]                 NAMES <- toupper(added)
[17:48:37.987]                 for (kk in seq_along(NAMES)) {
[17:48:37.987]                   name <- added[[kk]]
[17:48:37.987]                   NAME <- NAMES[[kk]]
[17:48:37.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.987]                     next
[17:48:37.987]                   args[[name]] <- ""
[17:48:37.987]                 }
[17:48:37.987]                 NAMES <- toupper(removed)
[17:48:37.987]                 for (kk in seq_along(NAMES)) {
[17:48:37.987]                   name <- removed[[kk]]
[17:48:37.987]                   NAME <- NAMES[[kk]]
[17:48:37.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:37.987]                     next
[17:48:37.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:37.987]                 }
[17:48:37.987]                 if (length(args) > 0) 
[17:48:37.987]                   base::do.call(base::Sys.setenv, args = args)
[17:48:37.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:37.987]             }
[17:48:37.987]             else {
[17:48:37.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:37.987]             }
[17:48:37.987]             {
[17:48:37.987]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:37.987]                   0L) {
[17:48:37.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:37.987]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:37.987]                   base::options(opts)
[17:48:37.987]                 }
[17:48:37.987]                 {
[17:48:37.987]                   {
[17:48:37.987]                     NULL
[17:48:37.987]                     RNGkind("Mersenne-Twister")
[17:48:37.987]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:37.987]                       inherits = FALSE)
[17:48:37.987]                   }
[17:48:37.987]                   options(future.plan = NULL)
[17:48:37.987]                   if (is.na(NA_character_)) 
[17:48:37.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:37.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:37.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:37.987]                     .init = FALSE)
[17:48:37.987]                 }
[17:48:37.987]             }
[17:48:37.987]         }
[17:48:37.987]     })
[17:48:37.987]     if (TRUE) {
[17:48:37.987]         base::sink(type = "output", split = FALSE)
[17:48:37.987]         if (FALSE) {
[17:48:37.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:37.987]         }
[17:48:37.987]         else {
[17:48:37.987]             ...future.result["stdout"] <- base::list(NULL)
[17:48:37.987]         }
[17:48:37.987]         base::close(...future.stdout)
[17:48:37.987]         ...future.stdout <- NULL
[17:48:37.987]     }
[17:48:37.987]     ...future.result$conditions <- ...future.conditions
[17:48:37.987]     ...future.result$finished <- base::Sys.time()
[17:48:37.987]     ...future.result
[17:48:37.987] }
[17:48:37.989] plan(): Setting new future strategy stack:
[17:48:37.989] List of future strategies:
[17:48:37.989] 1. sequential:
[17:48:37.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.989]    - tweaked: FALSE
[17:48:37.989]    - call: NULL
[17:48:37.990] plan(): nbrOfWorkers() = 1
[17:48:37.991] plan(): Setting new future strategy stack:
[17:48:37.991] List of future strategies:
[17:48:37.991] 1. sequential:
[17:48:37.991]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:37.991]    - tweaked: FALSE
[17:48:37.991]    - call: plan(strategy)
[17:48:37.992] plan(): nbrOfWorkers() = 1
[17:48:37.992] SequentialFuture started (and completed)
[17:48:37.992] - Launch lazy future ... done
[17:48:37.992] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:37"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:37"
 $ session_uuid: chr "e8c0a985-8f6b-11fa-b01a-2a5b4e1437a9"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50428
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:37"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:38.001] getGlobalsAndPackages() ...
[17:48:38.001] Searching for globals...
[17:48:38.004] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.004] Searching for globals ... DONE
[17:48:38.004] Resolving globals: FALSE
[17:48:38.004] 
[17:48:38.004] - packages: [1] ‘utils’
[17:48:38.004] getGlobalsAndPackages() ... DONE
[17:48:38.005] run() for ‘Future’ ...
[17:48:38.005] - state: ‘created’
[17:48:38.005] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:38.005] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:38.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:38.005]   - Field: ‘label’
[17:48:38.005]   - Field: ‘local’
[17:48:38.006]   - Field: ‘owner’
[17:48:38.006]   - Field: ‘envir’
[17:48:38.006]   - Field: ‘packages’
[17:48:38.006]   - Field: ‘gc’
[17:48:38.006]   - Field: ‘conditions’
[17:48:38.006]   - Field: ‘expr’
[17:48:38.006]   - Field: ‘uuid’
[17:48:38.006]   - Field: ‘seed’
[17:48:38.006]   - Field: ‘version’
[17:48:38.006]   - Field: ‘result’
[17:48:38.006]   - Field: ‘asynchronous’
[17:48:38.006]   - Field: ‘calls’
[17:48:38.007]   - Field: ‘globals’
[17:48:38.007]   - Field: ‘stdout’
[17:48:38.007]   - Field: ‘earlySignal’
[17:48:38.007]   - Field: ‘lazy’
[17:48:38.007]   - Field: ‘state’
[17:48:38.007] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:38.007] - Launch lazy future ...
[17:48:38.007] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.007] Packages needed by future strategies (n = 0): <none>
[17:48:38.008] {
[17:48:38.008]     {
[17:48:38.008]         {
[17:48:38.008]             ...future.startTime <- base::Sys.time()
[17:48:38.008]             {
[17:48:38.008]                 {
[17:48:38.008]                   {
[17:48:38.008]                     {
[17:48:38.008]                       base::local({
[17:48:38.008]                         has_future <- base::requireNamespace("future", 
[17:48:38.008]                           quietly = TRUE)
[17:48:38.008]                         if (has_future) {
[17:48:38.008]                           ns <- base::getNamespace("future")
[17:48:38.008]                           version <- ns[[".package"]][["version"]]
[17:48:38.008]                           if (is.null(version)) 
[17:48:38.008]                             version <- utils::packageVersion("future")
[17:48:38.008]                         }
[17:48:38.008]                         else {
[17:48:38.008]                           version <- NULL
[17:48:38.008]                         }
[17:48:38.008]                         if (!has_future || version < "1.8.0") {
[17:48:38.008]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.008]                             "", base::R.version$version.string), 
[17:48:38.008]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:38.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.008]                               "release", "version")], collapse = " "), 
[17:48:38.008]                             hostname = base::Sys.info()[["nodename"]])
[17:48:38.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.008]                             info)
[17:48:38.008]                           info <- base::paste(info, collapse = "; ")
[17:48:38.008]                           if (!has_future) {
[17:48:38.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.008]                               info)
[17:48:38.008]                           }
[17:48:38.008]                           else {
[17:48:38.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.008]                               info, version)
[17:48:38.008]                           }
[17:48:38.008]                           base::stop(msg)
[17:48:38.008]                         }
[17:48:38.008]                       })
[17:48:38.008]                     }
[17:48:38.008]                     base::local({
[17:48:38.008]                       for (pkg in "utils") {
[17:48:38.008]                         base::loadNamespace(pkg)
[17:48:38.008]                         base::library(pkg, character.only = TRUE)
[17:48:38.008]                       }
[17:48:38.008]                     })
[17:48:38.008]                   }
[17:48:38.008]                   ...future.strategy.old <- future::plan("list")
[17:48:38.008]                   options(future.plan = NULL)
[17:48:38.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.008]                 }
[17:48:38.008]                 ...future.workdir <- getwd()
[17:48:38.008]             }
[17:48:38.008]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.008]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.008]         }
[17:48:38.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.008]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.008]             base::names(...future.oldOptions))
[17:48:38.008]     }
[17:48:38.008]     if (FALSE) {
[17:48:38.008]     }
[17:48:38.008]     else {
[17:48:38.008]         if (FALSE) {
[17:48:38.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.008]                 open = "w")
[17:48:38.008]         }
[17:48:38.008]         else {
[17:48:38.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.008]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.008]         }
[17:48:38.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.008]             base::sink(type = "output", split = FALSE)
[17:48:38.008]             base::close(...future.stdout)
[17:48:38.008]         }, add = TRUE)
[17:48:38.008]     }
[17:48:38.008]     ...future.frame <- base::sys.nframe()
[17:48:38.008]     ...future.conditions <- base::list()
[17:48:38.008]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.008]     if (FALSE) {
[17:48:38.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.008]     }
[17:48:38.008]     ...future.result <- base::tryCatch({
[17:48:38.008]         base::withCallingHandlers({
[17:48:38.008]             ...future.value <- base::withVisible(base::local({
[17:48:38.008]                 print(1:50)
[17:48:38.008]                 str(1:50)
[17:48:38.008]                 cat(letters, sep = "-")
[17:48:38.008]                 cat(1:6, collapse = "\n")
[17:48:38.008]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.008]                 42L
[17:48:38.008]             }))
[17:48:38.008]             future::FutureResult(value = ...future.value$value, 
[17:48:38.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.008]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.008]                     ...future.globalenv.names))
[17:48:38.008]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.008]         }, condition = base::local({
[17:48:38.008]             c <- base::c
[17:48:38.008]             inherits <- base::inherits
[17:48:38.008]             invokeRestart <- base::invokeRestart
[17:48:38.008]             length <- base::length
[17:48:38.008]             list <- base::list
[17:48:38.008]             seq.int <- base::seq.int
[17:48:38.008]             signalCondition <- base::signalCondition
[17:48:38.008]             sys.calls <- base::sys.calls
[17:48:38.008]             `[[` <- base::`[[`
[17:48:38.008]             `+` <- base::`+`
[17:48:38.008]             `<<-` <- base::`<<-`
[17:48:38.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.008]                   3L)]
[17:48:38.008]             }
[17:48:38.008]             function(cond) {
[17:48:38.008]                 is_error <- inherits(cond, "error")
[17:48:38.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.008]                   NULL)
[17:48:38.008]                 if (is_error) {
[17:48:38.008]                   sessionInformation <- function() {
[17:48:38.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.008]                       search = base::search(), system = base::Sys.info())
[17:48:38.008]                   }
[17:48:38.008]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.008]                     cond$call), session = sessionInformation(), 
[17:48:38.008]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.008]                   signalCondition(cond)
[17:48:38.008]                 }
[17:48:38.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.008]                 "immediateCondition"))) {
[17:48:38.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.008]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.008]                   if (TRUE && !signal) {
[17:48:38.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.008]                     {
[17:48:38.008]                       inherits <- base::inherits
[17:48:38.008]                       invokeRestart <- base::invokeRestart
[17:48:38.008]                       is.null <- base::is.null
[17:48:38.008]                       muffled <- FALSE
[17:48:38.008]                       if (inherits(cond, "message")) {
[17:48:38.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.008]                         if (muffled) 
[17:48:38.008]                           invokeRestart("muffleMessage")
[17:48:38.008]                       }
[17:48:38.008]                       else if (inherits(cond, "warning")) {
[17:48:38.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.008]                         if (muffled) 
[17:48:38.008]                           invokeRestart("muffleWarning")
[17:48:38.008]                       }
[17:48:38.008]                       else if (inherits(cond, "condition")) {
[17:48:38.008]                         if (!is.null(pattern)) {
[17:48:38.008]                           computeRestarts <- base::computeRestarts
[17:48:38.008]                           grepl <- base::grepl
[17:48:38.008]                           restarts <- computeRestarts(cond)
[17:48:38.008]                           for (restart in restarts) {
[17:48:38.008]                             name <- restart$name
[17:48:38.008]                             if (is.null(name)) 
[17:48:38.008]                               next
[17:48:38.008]                             if (!grepl(pattern, name)) 
[17:48:38.008]                               next
[17:48:38.008]                             invokeRestart(restart)
[17:48:38.008]                             muffled <- TRUE
[17:48:38.008]                             break
[17:48:38.008]                           }
[17:48:38.008]                         }
[17:48:38.008]                       }
[17:48:38.008]                       invisible(muffled)
[17:48:38.008]                     }
[17:48:38.008]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.008]                   }
[17:48:38.008]                 }
[17:48:38.008]                 else {
[17:48:38.008]                   if (TRUE) {
[17:48:38.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.008]                     {
[17:48:38.008]                       inherits <- base::inherits
[17:48:38.008]                       invokeRestart <- base::invokeRestart
[17:48:38.008]                       is.null <- base::is.null
[17:48:38.008]                       muffled <- FALSE
[17:48:38.008]                       if (inherits(cond, "message")) {
[17:48:38.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.008]                         if (muffled) 
[17:48:38.008]                           invokeRestart("muffleMessage")
[17:48:38.008]                       }
[17:48:38.008]                       else if (inherits(cond, "warning")) {
[17:48:38.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.008]                         if (muffled) 
[17:48:38.008]                           invokeRestart("muffleWarning")
[17:48:38.008]                       }
[17:48:38.008]                       else if (inherits(cond, "condition")) {
[17:48:38.008]                         if (!is.null(pattern)) {
[17:48:38.008]                           computeRestarts <- base::computeRestarts
[17:48:38.008]                           grepl <- base::grepl
[17:48:38.008]                           restarts <- computeRestarts(cond)
[17:48:38.008]                           for (restart in restarts) {
[17:48:38.008]                             name <- restart$name
[17:48:38.008]                             if (is.null(name)) 
[17:48:38.008]                               next
[17:48:38.008]                             if (!grepl(pattern, name)) 
[17:48:38.008]                               next
[17:48:38.008]                             invokeRestart(restart)
[17:48:38.008]                             muffled <- TRUE
[17:48:38.008]                             break
[17:48:38.008]                           }
[17:48:38.008]                         }
[17:48:38.008]                       }
[17:48:38.008]                       invisible(muffled)
[17:48:38.008]                     }
[17:48:38.008]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.008]                   }
[17:48:38.008]                 }
[17:48:38.008]             }
[17:48:38.008]         }))
[17:48:38.008]     }, error = function(ex) {
[17:48:38.008]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.008]                 ...future.rng), started = ...future.startTime, 
[17:48:38.008]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.008]             version = "1.8"), class = "FutureResult")
[17:48:38.008]     }, finally = {
[17:48:38.008]         if (!identical(...future.workdir, getwd())) 
[17:48:38.008]             setwd(...future.workdir)
[17:48:38.008]         {
[17:48:38.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.008]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.008]             }
[17:48:38.008]             base::options(...future.oldOptions)
[17:48:38.008]             if (.Platform$OS.type == "windows") {
[17:48:38.008]                 old_names <- names(...future.oldEnvVars)
[17:48:38.008]                 envs <- base::Sys.getenv()
[17:48:38.008]                 names <- names(envs)
[17:48:38.008]                 common <- intersect(names, old_names)
[17:48:38.008]                 added <- setdiff(names, old_names)
[17:48:38.008]                 removed <- setdiff(old_names, names)
[17:48:38.008]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.008]                   envs[common]]
[17:48:38.008]                 NAMES <- toupper(changed)
[17:48:38.008]                 args <- list()
[17:48:38.008]                 for (kk in seq_along(NAMES)) {
[17:48:38.008]                   name <- changed[[kk]]
[17:48:38.008]                   NAME <- NAMES[[kk]]
[17:48:38.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.008]                     next
[17:48:38.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.008]                 }
[17:48:38.008]                 NAMES <- toupper(added)
[17:48:38.008]                 for (kk in seq_along(NAMES)) {
[17:48:38.008]                   name <- added[[kk]]
[17:48:38.008]                   NAME <- NAMES[[kk]]
[17:48:38.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.008]                     next
[17:48:38.008]                   args[[name]] <- ""
[17:48:38.008]                 }
[17:48:38.008]                 NAMES <- toupper(removed)
[17:48:38.008]                 for (kk in seq_along(NAMES)) {
[17:48:38.008]                   name <- removed[[kk]]
[17:48:38.008]                   NAME <- NAMES[[kk]]
[17:48:38.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.008]                     next
[17:48:38.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.008]                 }
[17:48:38.008]                 if (length(args) > 0) 
[17:48:38.008]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.008]             }
[17:48:38.008]             else {
[17:48:38.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.008]             }
[17:48:38.008]             {
[17:48:38.008]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.008]                   0L) {
[17:48:38.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.008]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.008]                   base::options(opts)
[17:48:38.008]                 }
[17:48:38.008]                 {
[17:48:38.008]                   {
[17:48:38.008]                     NULL
[17:48:38.008]                     RNGkind("Mersenne-Twister")
[17:48:38.008]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:38.008]                       inherits = FALSE)
[17:48:38.008]                   }
[17:48:38.008]                   options(future.plan = NULL)
[17:48:38.008]                   if (is.na(NA_character_)) 
[17:48:38.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.008]                     .init = FALSE)
[17:48:38.008]                 }
[17:48:38.008]             }
[17:48:38.008]         }
[17:48:38.008]     })
[17:48:38.008]     if (TRUE) {
[17:48:38.008]         base::sink(type = "output", split = FALSE)
[17:48:38.008]         if (FALSE) {
[17:48:38.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.008]         }
[17:48:38.008]         else {
[17:48:38.008]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.008]         }
[17:48:38.008]         base::close(...future.stdout)
[17:48:38.008]         ...future.stdout <- NULL
[17:48:38.008]     }
[17:48:38.008]     ...future.result$conditions <- ...future.conditions
[17:48:38.008]     ...future.result$finished <- base::Sys.time()
[17:48:38.008]     ...future.result
[17:48:38.008] }
[17:48:38.010] plan(): Setting new future strategy stack:
[17:48:38.010] List of future strategies:
[17:48:38.010] 1. sequential:
[17:48:38.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.010]    - tweaked: FALSE
[17:48:38.010]    - call: NULL
[17:48:38.010] plan(): nbrOfWorkers() = 1
[17:48:38.012] plan(): Setting new future strategy stack:
[17:48:38.012] List of future strategies:
[17:48:38.012] 1. sequential:
[17:48:38.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.012]    - tweaked: FALSE
[17:48:38.012]    - call: plan(strategy)
[17:48:38.012] plan(): nbrOfWorkers() = 1
[17:48:38.012] SequentialFuture started (and completed)
[17:48:38.012] - Launch lazy future ... done
[17:48:38.012] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[17:48:38.013] getGlobalsAndPackages() ...
[17:48:38.013] Searching for globals...
[17:48:38.013] - globals found: [1] ‘print’
[17:48:38.013] Searching for globals ... DONE
[17:48:38.014] Resolving globals: FALSE
[17:48:38.014] 
[17:48:38.014] 
[17:48:38.014] getGlobalsAndPackages() ... DONE
[17:48:38.014] run() for ‘Future’ ...
[17:48:38.014] - state: ‘created’
[17:48:38.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:38.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:38.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:38.015]   - Field: ‘label’
[17:48:38.015]   - Field: ‘local’
[17:48:38.015]   - Field: ‘owner’
[17:48:38.015]   - Field: ‘envir’
[17:48:38.015]   - Field: ‘packages’
[17:48:38.015]   - Field: ‘gc’
[17:48:38.015]   - Field: ‘conditions’
[17:48:38.015]   - Field: ‘expr’
[17:48:38.016]   - Field: ‘uuid’
[17:48:38.016]   - Field: ‘seed’
[17:48:38.016]   - Field: ‘version’
[17:48:38.016]   - Field: ‘result’
[17:48:38.016]   - Field: ‘asynchronous’
[17:48:38.016]   - Field: ‘calls’
[17:48:38.016]   - Field: ‘globals’
[17:48:38.016]   - Field: ‘stdout’
[17:48:38.016]   - Field: ‘earlySignal’
[17:48:38.016]   - Field: ‘lazy’
[17:48:38.016]   - Field: ‘state’
[17:48:38.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:38.017] - Launch lazy future ...
[17:48:38.017] Packages needed by the future expression (n = 0): <none>
[17:48:38.017] Packages needed by future strategies (n = 0): <none>
[17:48:38.017] {
[17:48:38.017]     {
[17:48:38.017]         {
[17:48:38.017]             ...future.startTime <- base::Sys.time()
[17:48:38.017]             {
[17:48:38.017]                 {
[17:48:38.017]                   {
[17:48:38.017]                     base::local({
[17:48:38.017]                       has_future <- base::requireNamespace("future", 
[17:48:38.017]                         quietly = TRUE)
[17:48:38.017]                       if (has_future) {
[17:48:38.017]                         ns <- base::getNamespace("future")
[17:48:38.017]                         version <- ns[[".package"]][["version"]]
[17:48:38.017]                         if (is.null(version)) 
[17:48:38.017]                           version <- utils::packageVersion("future")
[17:48:38.017]                       }
[17:48:38.017]                       else {
[17:48:38.017]                         version <- NULL
[17:48:38.017]                       }
[17:48:38.017]                       if (!has_future || version < "1.8.0") {
[17:48:38.017]                         info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.017]                           "", base::R.version$version.string), 
[17:48:38.017]                           platform = base::sprintf("%s (%s-bit)", 
[17:48:38.017]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.017]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.017]                             "release", "version")], collapse = " "), 
[17:48:38.017]                           hostname = base::Sys.info()[["nodename"]])
[17:48:38.017]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.017]                           info)
[17:48:38.017]                         info <- base::paste(info, collapse = "; ")
[17:48:38.017]                         if (!has_future) {
[17:48:38.017]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.017]                             info)
[17:48:38.017]                         }
[17:48:38.017]                         else {
[17:48:38.017]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.017]                             info, version)
[17:48:38.017]                         }
[17:48:38.017]                         base::stop(msg)
[17:48:38.017]                       }
[17:48:38.017]                     })
[17:48:38.017]                   }
[17:48:38.017]                   ...future.strategy.old <- future::plan("list")
[17:48:38.017]                   options(future.plan = NULL)
[17:48:38.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.017]                 }
[17:48:38.017]                 ...future.workdir <- getwd()
[17:48:38.017]             }
[17:48:38.017]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.017]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.017]         }
[17:48:38.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.017]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.017]             base::names(...future.oldOptions))
[17:48:38.017]     }
[17:48:38.017]     if (FALSE) {
[17:48:38.017]     }
[17:48:38.017]     else {
[17:48:38.017]         if (TRUE) {
[17:48:38.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.017]                 open = "w")
[17:48:38.017]         }
[17:48:38.017]         else {
[17:48:38.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.017]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.017]         }
[17:48:38.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.017]             base::sink(type = "output", split = FALSE)
[17:48:38.017]             base::close(...future.stdout)
[17:48:38.017]         }, add = TRUE)
[17:48:38.017]     }
[17:48:38.017]     ...future.frame <- base::sys.nframe()
[17:48:38.017]     ...future.conditions <- base::list()
[17:48:38.017]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.017]     if (FALSE) {
[17:48:38.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.017]     }
[17:48:38.017]     ...future.result <- base::tryCatch({
[17:48:38.017]         base::withCallingHandlers({
[17:48:38.017]             ...future.value <- base::withVisible(base::local(print(42)))
[17:48:38.017]             future::FutureResult(value = ...future.value$value, 
[17:48:38.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.017]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.017]                     ...future.globalenv.names))
[17:48:38.017]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.017]         }, condition = base::local({
[17:48:38.017]             c <- base::c
[17:48:38.017]             inherits <- base::inherits
[17:48:38.017]             invokeRestart <- base::invokeRestart
[17:48:38.017]             length <- base::length
[17:48:38.017]             list <- base::list
[17:48:38.017]             seq.int <- base::seq.int
[17:48:38.017]             signalCondition <- base::signalCondition
[17:48:38.017]             sys.calls <- base::sys.calls
[17:48:38.017]             `[[` <- base::`[[`
[17:48:38.017]             `+` <- base::`+`
[17:48:38.017]             `<<-` <- base::`<<-`
[17:48:38.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.017]                   3L)]
[17:48:38.017]             }
[17:48:38.017]             function(cond) {
[17:48:38.017]                 is_error <- inherits(cond, "error")
[17:48:38.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.017]                   NULL)
[17:48:38.017]                 if (is_error) {
[17:48:38.017]                   sessionInformation <- function() {
[17:48:38.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.017]                       search = base::search(), system = base::Sys.info())
[17:48:38.017]                   }
[17:48:38.017]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.017]                     cond$call), session = sessionInformation(), 
[17:48:38.017]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.017]                   signalCondition(cond)
[17:48:38.017]                 }
[17:48:38.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.017]                 "immediateCondition"))) {
[17:48:38.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.017]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.017]                   if (TRUE && !signal) {
[17:48:38.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.017]                     {
[17:48:38.017]                       inherits <- base::inherits
[17:48:38.017]                       invokeRestart <- base::invokeRestart
[17:48:38.017]                       is.null <- base::is.null
[17:48:38.017]                       muffled <- FALSE
[17:48:38.017]                       if (inherits(cond, "message")) {
[17:48:38.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.017]                         if (muffled) 
[17:48:38.017]                           invokeRestart("muffleMessage")
[17:48:38.017]                       }
[17:48:38.017]                       else if (inherits(cond, "warning")) {
[17:48:38.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.017]                         if (muffled) 
[17:48:38.017]                           invokeRestart("muffleWarning")
[17:48:38.017]                       }
[17:48:38.017]                       else if (inherits(cond, "condition")) {
[17:48:38.017]                         if (!is.null(pattern)) {
[17:48:38.017]                           computeRestarts <- base::computeRestarts
[17:48:38.017]                           grepl <- base::grepl
[17:48:38.017]                           restarts <- computeRestarts(cond)
[17:48:38.017]                           for (restart in restarts) {
[17:48:38.017]                             name <- restart$name
[17:48:38.017]                             if (is.null(name)) 
[17:48:38.017]                               next
[17:48:38.017]                             if (!grepl(pattern, name)) 
[17:48:38.017]                               next
[17:48:38.017]                             invokeRestart(restart)
[17:48:38.017]                             muffled <- TRUE
[17:48:38.017]                             break
[17:48:38.017]                           }
[17:48:38.017]                         }
[17:48:38.017]                       }
[17:48:38.017]                       invisible(muffled)
[17:48:38.017]                     }
[17:48:38.017]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.017]                   }
[17:48:38.017]                 }
[17:48:38.017]                 else {
[17:48:38.017]                   if (TRUE) {
[17:48:38.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.017]                     {
[17:48:38.017]                       inherits <- base::inherits
[17:48:38.017]                       invokeRestart <- base::invokeRestart
[17:48:38.017]                       is.null <- base::is.null
[17:48:38.017]                       muffled <- FALSE
[17:48:38.017]                       if (inherits(cond, "message")) {
[17:48:38.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.017]                         if (muffled) 
[17:48:38.017]                           invokeRestart("muffleMessage")
[17:48:38.017]                       }
[17:48:38.017]                       else if (inherits(cond, "warning")) {
[17:48:38.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.017]                         if (muffled) 
[17:48:38.017]                           invokeRestart("muffleWarning")
[17:48:38.017]                       }
[17:48:38.017]                       else if (inherits(cond, "condition")) {
[17:48:38.017]                         if (!is.null(pattern)) {
[17:48:38.017]                           computeRestarts <- base::computeRestarts
[17:48:38.017]                           grepl <- base::grepl
[17:48:38.017]                           restarts <- computeRestarts(cond)
[17:48:38.017]                           for (restart in restarts) {
[17:48:38.017]                             name <- restart$name
[17:48:38.017]                             if (is.null(name)) 
[17:48:38.017]                               next
[17:48:38.017]                             if (!grepl(pattern, name)) 
[17:48:38.017]                               next
[17:48:38.017]                             invokeRestart(restart)
[17:48:38.017]                             muffled <- TRUE
[17:48:38.017]                             break
[17:48:38.017]                           }
[17:48:38.017]                         }
[17:48:38.017]                       }
[17:48:38.017]                       invisible(muffled)
[17:48:38.017]                     }
[17:48:38.017]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.017]                   }
[17:48:38.017]                 }
[17:48:38.017]             }
[17:48:38.017]         }))
[17:48:38.017]     }, error = function(ex) {
[17:48:38.017]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.017]                 ...future.rng), started = ...future.startTime, 
[17:48:38.017]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.017]             version = "1.8"), class = "FutureResult")
[17:48:38.017]     }, finally = {
[17:48:38.017]         if (!identical(...future.workdir, getwd())) 
[17:48:38.017]             setwd(...future.workdir)
[17:48:38.017]         {
[17:48:38.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.017]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.017]             }
[17:48:38.017]             base::options(...future.oldOptions)
[17:48:38.017]             if (.Platform$OS.type == "windows") {
[17:48:38.017]                 old_names <- names(...future.oldEnvVars)
[17:48:38.017]                 envs <- base::Sys.getenv()
[17:48:38.017]                 names <- names(envs)
[17:48:38.017]                 common <- intersect(names, old_names)
[17:48:38.017]                 added <- setdiff(names, old_names)
[17:48:38.017]                 removed <- setdiff(old_names, names)
[17:48:38.017]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.017]                   envs[common]]
[17:48:38.017]                 NAMES <- toupper(changed)
[17:48:38.017]                 args <- list()
[17:48:38.017]                 for (kk in seq_along(NAMES)) {
[17:48:38.017]                   name <- changed[[kk]]
[17:48:38.017]                   NAME <- NAMES[[kk]]
[17:48:38.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.017]                     next
[17:48:38.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.017]                 }
[17:48:38.017]                 NAMES <- toupper(added)
[17:48:38.017]                 for (kk in seq_along(NAMES)) {
[17:48:38.017]                   name <- added[[kk]]
[17:48:38.017]                   NAME <- NAMES[[kk]]
[17:48:38.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.017]                     next
[17:48:38.017]                   args[[name]] <- ""
[17:48:38.017]                 }
[17:48:38.017]                 NAMES <- toupper(removed)
[17:48:38.017]                 for (kk in seq_along(NAMES)) {
[17:48:38.017]                   name <- removed[[kk]]
[17:48:38.017]                   NAME <- NAMES[[kk]]
[17:48:38.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.017]                     next
[17:48:38.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.017]                 }
[17:48:38.017]                 if (length(args) > 0) 
[17:48:38.017]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.017]             }
[17:48:38.017]             else {
[17:48:38.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.017]             }
[17:48:38.017]             {
[17:48:38.017]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.017]                   0L) {
[17:48:38.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.017]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.017]                   base::options(opts)
[17:48:38.017]                 }
[17:48:38.017]                 {
[17:48:38.017]                   {
[17:48:38.017]                     NULL
[17:48:38.017]                     RNGkind("Mersenne-Twister")
[17:48:38.017]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:38.017]                       inherits = FALSE)
[17:48:38.017]                   }
[17:48:38.017]                   options(future.plan = NULL)
[17:48:38.017]                   if (is.na(NA_character_)) 
[17:48:38.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.017]                     .init = FALSE)
[17:48:38.017]                 }
[17:48:38.017]             }
[17:48:38.017]         }
[17:48:38.017]     })
[17:48:38.017]     if (TRUE) {
[17:48:38.017]         base::sink(type = "output", split = FALSE)
[17:48:38.017]         if (TRUE) {
[17:48:38.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.017]         }
[17:48:38.017]         else {
[17:48:38.017]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.017]         }
[17:48:38.017]         base::close(...future.stdout)
[17:48:38.017]         ...future.stdout <- NULL
[17:48:38.017]     }
[17:48:38.017]     ...future.result$conditions <- ...future.conditions
[17:48:38.017]     ...future.result$finished <- base::Sys.time()
[17:48:38.017]     ...future.result
[17:48:38.017] }
[17:48:38.019] plan(): Setting new future strategy stack:
[17:48:38.019] List of future strategies:
[17:48:38.019] 1. sequential:
[17:48:38.019]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.019]    - tweaked: FALSE
[17:48:38.019]    - call: NULL
[17:48:38.019] plan(): nbrOfWorkers() = 1
[17:48:38.020] plan(): Setting new future strategy stack:
[17:48:38.020] List of future strategies:
[17:48:38.020] 1. sequential:
[17:48:38.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.020]    - tweaked: FALSE
[17:48:38.020]    - call: plan(strategy)
[17:48:38.021] plan(): nbrOfWorkers() = 1
[17:48:38.021] SequentialFuture started (and completed)
[17:48:38.021] - Launch lazy future ... done
[17:48:38.021] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[17:48:38.021] getGlobalsAndPackages() ...
[17:48:38.021] Searching for globals...
[17:48:38.025] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.025] Searching for globals ... DONE
[17:48:38.026] Resolving globals: FALSE
[17:48:38.026] 
[17:48:38.026] - packages: [1] ‘utils’
[17:48:38.026] getGlobalsAndPackages() ... DONE
[17:48:38.026] run() for ‘Future’ ...
[17:48:38.027] - state: ‘created’
[17:48:38.027] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:38.027] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:38.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:38.027]   - Field: ‘label’
[17:48:38.027]   - Field: ‘local’
[17:48:38.027]   - Field: ‘owner’
[17:48:38.027]   - Field: ‘envir’
[17:48:38.027]   - Field: ‘packages’
[17:48:38.028]   - Field: ‘gc’
[17:48:38.028]   - Field: ‘conditions’
[17:48:38.028]   - Field: ‘expr’
[17:48:38.028]   - Field: ‘uuid’
[17:48:38.028]   - Field: ‘seed’
[17:48:38.028]   - Field: ‘version’
[17:48:38.028]   - Field: ‘result’
[17:48:38.028]   - Field: ‘asynchronous’
[17:48:38.028]   - Field: ‘calls’
[17:48:38.028]   - Field: ‘globals’
[17:48:38.028]   - Field: ‘stdout’
[17:48:38.029]   - Field: ‘earlySignal’
[17:48:38.029]   - Field: ‘lazy’
[17:48:38.029]   - Field: ‘state’
[17:48:38.029] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:38.029] - Launch lazy future ...
[17:48:38.029] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.029] Packages needed by future strategies (n = 0): <none>
[17:48:38.030] {
[17:48:38.030]     {
[17:48:38.030]         {
[17:48:38.030]             ...future.startTime <- base::Sys.time()
[17:48:38.030]             {
[17:48:38.030]                 {
[17:48:38.030]                   {
[17:48:38.030]                     {
[17:48:38.030]                       base::local({
[17:48:38.030]                         has_future <- base::requireNamespace("future", 
[17:48:38.030]                           quietly = TRUE)
[17:48:38.030]                         if (has_future) {
[17:48:38.030]                           ns <- base::getNamespace("future")
[17:48:38.030]                           version <- ns[[".package"]][["version"]]
[17:48:38.030]                           if (is.null(version)) 
[17:48:38.030]                             version <- utils::packageVersion("future")
[17:48:38.030]                         }
[17:48:38.030]                         else {
[17:48:38.030]                           version <- NULL
[17:48:38.030]                         }
[17:48:38.030]                         if (!has_future || version < "1.8.0") {
[17:48:38.030]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.030]                             "", base::R.version$version.string), 
[17:48:38.030]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:38.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.030]                               "release", "version")], collapse = " "), 
[17:48:38.030]                             hostname = base::Sys.info()[["nodename"]])
[17:48:38.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.030]                             info)
[17:48:38.030]                           info <- base::paste(info, collapse = "; ")
[17:48:38.030]                           if (!has_future) {
[17:48:38.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.030]                               info)
[17:48:38.030]                           }
[17:48:38.030]                           else {
[17:48:38.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.030]                               info, version)
[17:48:38.030]                           }
[17:48:38.030]                           base::stop(msg)
[17:48:38.030]                         }
[17:48:38.030]                       })
[17:48:38.030]                     }
[17:48:38.030]                     base::local({
[17:48:38.030]                       for (pkg in "utils") {
[17:48:38.030]                         base::loadNamespace(pkg)
[17:48:38.030]                         base::library(pkg, character.only = TRUE)
[17:48:38.030]                       }
[17:48:38.030]                     })
[17:48:38.030]                   }
[17:48:38.030]                   ...future.strategy.old <- future::plan("list")
[17:48:38.030]                   options(future.plan = NULL)
[17:48:38.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.030]                 }
[17:48:38.030]                 ...future.workdir <- getwd()
[17:48:38.030]             }
[17:48:38.030]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.030]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.030]         }
[17:48:38.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.030]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.030]             base::names(...future.oldOptions))
[17:48:38.030]     }
[17:48:38.030]     if (TRUE) {
[17:48:38.030]     }
[17:48:38.030]     else {
[17:48:38.030]         if (NA) {
[17:48:38.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.030]                 open = "w")
[17:48:38.030]         }
[17:48:38.030]         else {
[17:48:38.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.030]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.030]         }
[17:48:38.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.030]             base::sink(type = "output", split = FALSE)
[17:48:38.030]             base::close(...future.stdout)
[17:48:38.030]         }, add = TRUE)
[17:48:38.030]     }
[17:48:38.030]     ...future.frame <- base::sys.nframe()
[17:48:38.030]     ...future.conditions <- base::list()
[17:48:38.030]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.030]     if (FALSE) {
[17:48:38.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.030]     }
[17:48:38.030]     ...future.result <- base::tryCatch({
[17:48:38.030]         base::withCallingHandlers({
[17:48:38.030]             ...future.value <- base::withVisible(base::local({
[17:48:38.030]                 print(1:50)
[17:48:38.030]                 str(1:50)
[17:48:38.030]                 cat(letters, sep = "-")
[17:48:38.030]                 cat(1:6, collapse = "\n")
[17:48:38.030]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.030]                 42L
[17:48:38.030]             }))
[17:48:38.030]             future::FutureResult(value = ...future.value$value, 
[17:48:38.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.030]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.030]                     ...future.globalenv.names))
[17:48:38.030]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.030]         }, condition = base::local({
[17:48:38.030]             c <- base::c
[17:48:38.030]             inherits <- base::inherits
[17:48:38.030]             invokeRestart <- base::invokeRestart
[17:48:38.030]             length <- base::length
[17:48:38.030]             list <- base::list
[17:48:38.030]             seq.int <- base::seq.int
[17:48:38.030]             signalCondition <- base::signalCondition
[17:48:38.030]             sys.calls <- base::sys.calls
[17:48:38.030]             `[[` <- base::`[[`
[17:48:38.030]             `+` <- base::`+`
[17:48:38.030]             `<<-` <- base::`<<-`
[17:48:38.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.030]                   3L)]
[17:48:38.030]             }
[17:48:38.030]             function(cond) {
[17:48:38.030]                 is_error <- inherits(cond, "error")
[17:48:38.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.030]                   NULL)
[17:48:38.030]                 if (is_error) {
[17:48:38.030]                   sessionInformation <- function() {
[17:48:38.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.030]                       search = base::search(), system = base::Sys.info())
[17:48:38.030]                   }
[17:48:38.030]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.030]                     cond$call), session = sessionInformation(), 
[17:48:38.030]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.030]                   signalCondition(cond)
[17:48:38.030]                 }
[17:48:38.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.030]                 "immediateCondition"))) {
[17:48:38.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.030]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.030]                   if (TRUE && !signal) {
[17:48:38.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.030]                     {
[17:48:38.030]                       inherits <- base::inherits
[17:48:38.030]                       invokeRestart <- base::invokeRestart
[17:48:38.030]                       is.null <- base::is.null
[17:48:38.030]                       muffled <- FALSE
[17:48:38.030]                       if (inherits(cond, "message")) {
[17:48:38.030]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.030]                         if (muffled) 
[17:48:38.030]                           invokeRestart("muffleMessage")
[17:48:38.030]                       }
[17:48:38.030]                       else if (inherits(cond, "warning")) {
[17:48:38.030]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.030]                         if (muffled) 
[17:48:38.030]                           invokeRestart("muffleWarning")
[17:48:38.030]                       }
[17:48:38.030]                       else if (inherits(cond, "condition")) {
[17:48:38.030]                         if (!is.null(pattern)) {
[17:48:38.030]                           computeRestarts <- base::computeRestarts
[17:48:38.030]                           grepl <- base::grepl
[17:48:38.030]                           restarts <- computeRestarts(cond)
[17:48:38.030]                           for (restart in restarts) {
[17:48:38.030]                             name <- restart$name
[17:48:38.030]                             if (is.null(name)) 
[17:48:38.030]                               next
[17:48:38.030]                             if (!grepl(pattern, name)) 
[17:48:38.030]                               next
[17:48:38.030]                             invokeRestart(restart)
[17:48:38.030]                             muffled <- TRUE
[17:48:38.030]                             break
[17:48:38.030]                           }
[17:48:38.030]                         }
[17:48:38.030]                       }
[17:48:38.030]                       invisible(muffled)
[17:48:38.030]                     }
[17:48:38.030]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.030]                   }
[17:48:38.030]                 }
[17:48:38.030]                 else {
[17:48:38.030]                   if (TRUE) {
[17:48:38.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.030]                     {
[17:48:38.030]                       inherits <- base::inherits
[17:48:38.030]                       invokeRestart <- base::invokeRestart
[17:48:38.030]                       is.null <- base::is.null
[17:48:38.030]                       muffled <- FALSE
[17:48:38.030]                       if (inherits(cond, "message")) {
[17:48:38.030]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.030]                         if (muffled) 
[17:48:38.030]                           invokeRestart("muffleMessage")
[17:48:38.030]                       }
[17:48:38.030]                       else if (inherits(cond, "warning")) {
[17:48:38.030]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.030]                         if (muffled) 
[17:48:38.030]                           invokeRestart("muffleWarning")
[17:48:38.030]                       }
[17:48:38.030]                       else if (inherits(cond, "condition")) {
[17:48:38.030]                         if (!is.null(pattern)) {
[17:48:38.030]                           computeRestarts <- base::computeRestarts
[17:48:38.030]                           grepl <- base::grepl
[17:48:38.030]                           restarts <- computeRestarts(cond)
[17:48:38.030]                           for (restart in restarts) {
[17:48:38.030]                             name <- restart$name
[17:48:38.030]                             if (is.null(name)) 
[17:48:38.030]                               next
[17:48:38.030]                             if (!grepl(pattern, name)) 
[17:48:38.030]                               next
[17:48:38.030]                             invokeRestart(restart)
[17:48:38.030]                             muffled <- TRUE
[17:48:38.030]                             break
[17:48:38.030]                           }
[17:48:38.030]                         }
[17:48:38.030]                       }
[17:48:38.030]                       invisible(muffled)
[17:48:38.030]                     }
[17:48:38.030]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.030]                   }
[17:48:38.030]                 }
[17:48:38.030]             }
[17:48:38.030]         }))
[17:48:38.030]     }, error = function(ex) {
[17:48:38.030]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.030]                 ...future.rng), started = ...future.startTime, 
[17:48:38.030]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.030]             version = "1.8"), class = "FutureResult")
[17:48:38.030]     }, finally = {
[17:48:38.030]         if (!identical(...future.workdir, getwd())) 
[17:48:38.030]             setwd(...future.workdir)
[17:48:38.030]         {
[17:48:38.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.030]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.030]             }
[17:48:38.030]             base::options(...future.oldOptions)
[17:48:38.030]             if (.Platform$OS.type == "windows") {
[17:48:38.030]                 old_names <- names(...future.oldEnvVars)
[17:48:38.030]                 envs <- base::Sys.getenv()
[17:48:38.030]                 names <- names(envs)
[17:48:38.030]                 common <- intersect(names, old_names)
[17:48:38.030]                 added <- setdiff(names, old_names)
[17:48:38.030]                 removed <- setdiff(old_names, names)
[17:48:38.030]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.030]                   envs[common]]
[17:48:38.030]                 NAMES <- toupper(changed)
[17:48:38.030]                 args <- list()
[17:48:38.030]                 for (kk in seq_along(NAMES)) {
[17:48:38.030]                   name <- changed[[kk]]
[17:48:38.030]                   NAME <- NAMES[[kk]]
[17:48:38.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.030]                     next
[17:48:38.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.030]                 }
[17:48:38.030]                 NAMES <- toupper(added)
[17:48:38.030]                 for (kk in seq_along(NAMES)) {
[17:48:38.030]                   name <- added[[kk]]
[17:48:38.030]                   NAME <- NAMES[[kk]]
[17:48:38.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.030]                     next
[17:48:38.030]                   args[[name]] <- ""
[17:48:38.030]                 }
[17:48:38.030]                 NAMES <- toupper(removed)
[17:48:38.030]                 for (kk in seq_along(NAMES)) {
[17:48:38.030]                   name <- removed[[kk]]
[17:48:38.030]                   NAME <- NAMES[[kk]]
[17:48:38.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.030]                     next
[17:48:38.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.030]                 }
[17:48:38.030]                 if (length(args) > 0) 
[17:48:38.030]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.030]             }
[17:48:38.030]             else {
[17:48:38.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.030]             }
[17:48:38.030]             {
[17:48:38.030]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.030]                   0L) {
[17:48:38.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.030]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.030]                   base::options(opts)
[17:48:38.030]                 }
[17:48:38.030]                 {
[17:48:38.030]                   {
[17:48:38.030]                     NULL
[17:48:38.030]                     RNGkind("Mersenne-Twister")
[17:48:38.030]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:38.030]                       inherits = FALSE)
[17:48:38.030]                   }
[17:48:38.030]                   options(future.plan = NULL)
[17:48:38.030]                   if (is.na(NA_character_)) 
[17:48:38.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.030]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.030]                     .init = FALSE)
[17:48:38.030]                 }
[17:48:38.030]             }
[17:48:38.030]         }
[17:48:38.030]     })
[17:48:38.030]     if (FALSE) {
[17:48:38.030]         base::sink(type = "output", split = FALSE)
[17:48:38.030]         if (NA) {
[17:48:38.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.030]         }
[17:48:38.030]         else {
[17:48:38.030]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.030]         }
[17:48:38.030]         base::close(...future.stdout)
[17:48:38.030]         ...future.stdout <- NULL
[17:48:38.030]     }
[17:48:38.030]     ...future.result$conditions <- ...future.conditions
[17:48:38.030]     ...future.result$finished <- base::Sys.time()
[17:48:38.030]     ...future.result
[17:48:38.030] }
[17:48:38.032] plan(): Setting new future strategy stack:
[17:48:38.032] List of future strategies:
[17:48:38.032] 1. sequential:
[17:48:38.032]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.032]    - tweaked: FALSE
[17:48:38.032]    - call: NULL
[17:48:38.032] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:48:38.034] plan(): Setting new future strategy stack:
[17:48:38.034] List of future strategies:
[17:48:38.034] 1. sequential:
[17:48:38.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.034]    - tweaked: FALSE
[17:48:38.034]    - call: plan(strategy)
[17:48:38.034] plan(): nbrOfWorkers() = 1
[17:48:38.034] SequentialFuture started (and completed)
[17:48:38.034] - Launch lazy future ... done
[17:48:38.034] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ session_uuid: chr "e8c0a985-8f6b-11fa-b01a-2a5b4e1437a9"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50428
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:37"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:38.042] getGlobalsAndPackages() ...
[17:48:38.042] Searching for globals...
[17:48:38.045] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.045] Searching for globals ... DONE
[17:48:38.045] Resolving globals: FALSE
[17:48:38.045] 
[17:48:38.045] - packages: [1] ‘utils’
[17:48:38.046] getGlobalsAndPackages() ... DONE
[17:48:38.046] run() for ‘Future’ ...
[17:48:38.046] - state: ‘created’
[17:48:38.046] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:38.046] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:38.046] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:38.047]   - Field: ‘label’
[17:48:38.047]   - Field: ‘local’
[17:48:38.047]   - Field: ‘owner’
[17:48:38.047]   - Field: ‘envir’
[17:48:38.047]   - Field: ‘packages’
[17:48:38.047]   - Field: ‘gc’
[17:48:38.047]   - Field: ‘conditions’
[17:48:38.047]   - Field: ‘expr’
[17:48:38.047]   - Field: ‘uuid’
[17:48:38.047]   - Field: ‘seed’
[17:48:38.047]   - Field: ‘version’
[17:48:38.047]   - Field: ‘result’
[17:48:38.048]   - Field: ‘asynchronous’
[17:48:38.048]   - Field: ‘calls’
[17:48:38.048]   - Field: ‘globals’
[17:48:38.048]   - Field: ‘stdout’
[17:48:38.048]   - Field: ‘earlySignal’
[17:48:38.048]   - Field: ‘lazy’
[17:48:38.049]   - Field: ‘state’
[17:48:38.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:38.050] - Launch lazy future ...
[17:48:38.050] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.050] Packages needed by future strategies (n = 0): <none>
[17:48:38.050] {
[17:48:38.050]     {
[17:48:38.050]         {
[17:48:38.050]             ...future.startTime <- base::Sys.time()
[17:48:38.050]             {
[17:48:38.050]                 {
[17:48:38.050]                   {
[17:48:38.050]                     {
[17:48:38.050]                       base::local({
[17:48:38.050]                         has_future <- base::requireNamespace("future", 
[17:48:38.050]                           quietly = TRUE)
[17:48:38.050]                         if (has_future) {
[17:48:38.050]                           ns <- base::getNamespace("future")
[17:48:38.050]                           version <- ns[[".package"]][["version"]]
[17:48:38.050]                           if (is.null(version)) 
[17:48:38.050]                             version <- utils::packageVersion("future")
[17:48:38.050]                         }
[17:48:38.050]                         else {
[17:48:38.050]                           version <- NULL
[17:48:38.050]                         }
[17:48:38.050]                         if (!has_future || version < "1.8.0") {
[17:48:38.050]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.050]                             "", base::R.version$version.string), 
[17:48:38.050]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:38.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.050]                               "release", "version")], collapse = " "), 
[17:48:38.050]                             hostname = base::Sys.info()[["nodename"]])
[17:48:38.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.050]                             info)
[17:48:38.050]                           info <- base::paste(info, collapse = "; ")
[17:48:38.050]                           if (!has_future) {
[17:48:38.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.050]                               info)
[17:48:38.050]                           }
[17:48:38.050]                           else {
[17:48:38.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.050]                               info, version)
[17:48:38.050]                           }
[17:48:38.050]                           base::stop(msg)
[17:48:38.050]                         }
[17:48:38.050]                       })
[17:48:38.050]                     }
[17:48:38.050]                     base::local({
[17:48:38.050]                       for (pkg in "utils") {
[17:48:38.050]                         base::loadNamespace(pkg)
[17:48:38.050]                         base::library(pkg, character.only = TRUE)
[17:48:38.050]                       }
[17:48:38.050]                     })
[17:48:38.050]                   }
[17:48:38.050]                   ...future.strategy.old <- future::plan("list")
[17:48:38.050]                   options(future.plan = NULL)
[17:48:38.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.050]                 }
[17:48:38.050]                 ...future.workdir <- getwd()
[17:48:38.050]             }
[17:48:38.050]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.050]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.050]         }
[17:48:38.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.050]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.050]             base::names(...future.oldOptions))
[17:48:38.050]     }
[17:48:38.050]     if (TRUE) {
[17:48:38.050]     }
[17:48:38.050]     else {
[17:48:38.050]         if (NA) {
[17:48:38.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.050]                 open = "w")
[17:48:38.050]         }
[17:48:38.050]         else {
[17:48:38.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.050]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.050]         }
[17:48:38.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.050]             base::sink(type = "output", split = FALSE)
[17:48:38.050]             base::close(...future.stdout)
[17:48:38.050]         }, add = TRUE)
[17:48:38.050]     }
[17:48:38.050]     ...future.frame <- base::sys.nframe()
[17:48:38.050]     ...future.conditions <- base::list()
[17:48:38.050]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.050]     if (FALSE) {
[17:48:38.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.050]     }
[17:48:38.050]     ...future.result <- base::tryCatch({
[17:48:38.050]         base::withCallingHandlers({
[17:48:38.050]             ...future.value <- base::withVisible(base::local({
[17:48:38.050]                 print(1:50)
[17:48:38.050]                 str(1:50)
[17:48:38.050]                 cat(letters, sep = "-")
[17:48:38.050]                 cat(1:6, collapse = "\n")
[17:48:38.050]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.050]                 42L
[17:48:38.050]             }))
[17:48:38.050]             future::FutureResult(value = ...future.value$value, 
[17:48:38.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.050]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.050]                     ...future.globalenv.names))
[17:48:38.050]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.050]         }, condition = base::local({
[17:48:38.050]             c <- base::c
[17:48:38.050]             inherits <- base::inherits
[17:48:38.050]             invokeRestart <- base::invokeRestart
[17:48:38.050]             length <- base::length
[17:48:38.050]             list <- base::list
[17:48:38.050]             seq.int <- base::seq.int
[17:48:38.050]             signalCondition <- base::signalCondition
[17:48:38.050]             sys.calls <- base::sys.calls
[17:48:38.050]             `[[` <- base::`[[`
[17:48:38.050]             `+` <- base::`+`
[17:48:38.050]             `<<-` <- base::`<<-`
[17:48:38.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.050]                   3L)]
[17:48:38.050]             }
[17:48:38.050]             function(cond) {
[17:48:38.050]                 is_error <- inherits(cond, "error")
[17:48:38.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.050]                   NULL)
[17:48:38.050]                 if (is_error) {
[17:48:38.050]                   sessionInformation <- function() {
[17:48:38.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.050]                       search = base::search(), system = base::Sys.info())
[17:48:38.050]                   }
[17:48:38.050]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.050]                     cond$call), session = sessionInformation(), 
[17:48:38.050]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.050]                   signalCondition(cond)
[17:48:38.050]                 }
[17:48:38.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.050]                 "immediateCondition"))) {
[17:48:38.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.050]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.050]                   if (TRUE && !signal) {
[17:48:38.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.050]                     {
[17:48:38.050]                       inherits <- base::inherits
[17:48:38.050]                       invokeRestart <- base::invokeRestart
[17:48:38.050]                       is.null <- base::is.null
[17:48:38.050]                       muffled <- FALSE
[17:48:38.050]                       if (inherits(cond, "message")) {
[17:48:38.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.050]                         if (muffled) 
[17:48:38.050]                           invokeRestart("muffleMessage")
[17:48:38.050]                       }
[17:48:38.050]                       else if (inherits(cond, "warning")) {
[17:48:38.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.050]                         if (muffled) 
[17:48:38.050]                           invokeRestart("muffleWarning")
[17:48:38.050]                       }
[17:48:38.050]                       else if (inherits(cond, "condition")) {
[17:48:38.050]                         if (!is.null(pattern)) {
[17:48:38.050]                           computeRestarts <- base::computeRestarts
[17:48:38.050]                           grepl <- base::grepl
[17:48:38.050]                           restarts <- computeRestarts(cond)
[17:48:38.050]                           for (restart in restarts) {
[17:48:38.050]                             name <- restart$name
[17:48:38.050]                             if (is.null(name)) 
[17:48:38.050]                               next
[17:48:38.050]                             if (!grepl(pattern, name)) 
[17:48:38.050]                               next
[17:48:38.050]                             invokeRestart(restart)
[17:48:38.050]                             muffled <- TRUE
[17:48:38.050]                             break
[17:48:38.050]                           }
[17:48:38.050]                         }
[17:48:38.050]                       }
[17:48:38.050]                       invisible(muffled)
[17:48:38.050]                     }
[17:48:38.050]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.050]                   }
[17:48:38.050]                 }
[17:48:38.050]                 else {
[17:48:38.050]                   if (TRUE) {
[17:48:38.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.050]                     {
[17:48:38.050]                       inherits <- base::inherits
[17:48:38.050]                       invokeRestart <- base::invokeRestart
[17:48:38.050]                       is.null <- base::is.null
[17:48:38.050]                       muffled <- FALSE
[17:48:38.050]                       if (inherits(cond, "message")) {
[17:48:38.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.050]                         if (muffled) 
[17:48:38.050]                           invokeRestart("muffleMessage")
[17:48:38.050]                       }
[17:48:38.050]                       else if (inherits(cond, "warning")) {
[17:48:38.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.050]                         if (muffled) 
[17:48:38.050]                           invokeRestart("muffleWarning")
[17:48:38.050]                       }
[17:48:38.050]                       else if (inherits(cond, "condition")) {
[17:48:38.050]                         if (!is.null(pattern)) {
[17:48:38.050]                           computeRestarts <- base::computeRestarts
[17:48:38.050]                           grepl <- base::grepl
[17:48:38.050]                           restarts <- computeRestarts(cond)
[17:48:38.050]                           for (restart in restarts) {
[17:48:38.050]                             name <- restart$name
[17:48:38.050]                             if (is.null(name)) 
[17:48:38.050]                               next
[17:48:38.050]                             if (!grepl(pattern, name)) 
[17:48:38.050]                               next
[17:48:38.050]                             invokeRestart(restart)
[17:48:38.050]                             muffled <- TRUE
[17:48:38.050]                             break
[17:48:38.050]                           }
[17:48:38.050]                         }
[17:48:38.050]                       }
[17:48:38.050]                       invisible(muffled)
[17:48:38.050]                     }
[17:48:38.050]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.050]                   }
[17:48:38.050]                 }
[17:48:38.050]             }
[17:48:38.050]         }))
[17:48:38.050]     }, error = function(ex) {
[17:48:38.050]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.050]                 ...future.rng), started = ...future.startTime, 
[17:48:38.050]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.050]             version = "1.8"), class = "FutureResult")
[17:48:38.050]     }, finally = {
[17:48:38.050]         if (!identical(...future.workdir, getwd())) 
[17:48:38.050]             setwd(...future.workdir)
[17:48:38.050]         {
[17:48:38.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.050]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.050]             }
[17:48:38.050]             base::options(...future.oldOptions)
[17:48:38.050]             if (.Platform$OS.type == "windows") {
[17:48:38.050]                 old_names <- names(...future.oldEnvVars)
[17:48:38.050]                 envs <- base::Sys.getenv()
[17:48:38.050]                 names <- names(envs)
[17:48:38.050]                 common <- intersect(names, old_names)
[17:48:38.050]                 added <- setdiff(names, old_names)
[17:48:38.050]                 removed <- setdiff(old_names, names)
[17:48:38.050]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.050]                   envs[common]]
[17:48:38.050]                 NAMES <- toupper(changed)
[17:48:38.050]                 args <- list()
[17:48:38.050]                 for (kk in seq_along(NAMES)) {
[17:48:38.050]                   name <- changed[[kk]]
[17:48:38.050]                   NAME <- NAMES[[kk]]
[17:48:38.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.050]                     next
[17:48:38.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.050]                 }
[17:48:38.050]                 NAMES <- toupper(added)
[17:48:38.050]                 for (kk in seq_along(NAMES)) {
[17:48:38.050]                   name <- added[[kk]]
[17:48:38.050]                   NAME <- NAMES[[kk]]
[17:48:38.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.050]                     next
[17:48:38.050]                   args[[name]] <- ""
[17:48:38.050]                 }
[17:48:38.050]                 NAMES <- toupper(removed)
[17:48:38.050]                 for (kk in seq_along(NAMES)) {
[17:48:38.050]                   name <- removed[[kk]]
[17:48:38.050]                   NAME <- NAMES[[kk]]
[17:48:38.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.050]                     next
[17:48:38.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.050]                 }
[17:48:38.050]                 if (length(args) > 0) 
[17:48:38.050]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.050]             }
[17:48:38.050]             else {
[17:48:38.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.050]             }
[17:48:38.050]             {
[17:48:38.050]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.050]                   0L) {
[17:48:38.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.050]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.050]                   base::options(opts)
[17:48:38.050]                 }
[17:48:38.050]                 {
[17:48:38.050]                   {
[17:48:38.050]                     NULL
[17:48:38.050]                     RNGkind("Mersenne-Twister")
[17:48:38.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:38.050]                       inherits = FALSE)
[17:48:38.050]                   }
[17:48:38.050]                   options(future.plan = NULL)
[17:48:38.050]                   if (is.na(NA_character_)) 
[17:48:38.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.050]                     .init = FALSE)
[17:48:38.050]                 }
[17:48:38.050]             }
[17:48:38.050]         }
[17:48:38.050]     })
[17:48:38.050]     if (FALSE) {
[17:48:38.050]         base::sink(type = "output", split = FALSE)
[17:48:38.050]         if (NA) {
[17:48:38.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.050]         }
[17:48:38.050]         else {
[17:48:38.050]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.050]         }
[17:48:38.050]         base::close(...future.stdout)
[17:48:38.050]         ...future.stdout <- NULL
[17:48:38.050]     }
[17:48:38.050]     ...future.result$conditions <- ...future.conditions
[17:48:38.050]     ...future.result$finished <- base::Sys.time()
[17:48:38.050]     ...future.result
[17:48:38.050] }
[17:48:38.052] plan(): Setting new future strategy stack:
[17:48:38.052] List of future strategies:
[17:48:38.052] 1. sequential:
[17:48:38.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.052]    - tweaked: FALSE
[17:48:38.052]    - call: NULL
[17:48:38.053] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:48:38.054] plan(): Setting new future strategy stack:
[17:48:38.055] List of future strategies:
[17:48:38.055] 1. sequential:
[17:48:38.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.055]    - tweaked: FALSE
[17:48:38.055]    - call: plan(strategy)
[17:48:38.055] plan(): nbrOfWorkers() = 1
[17:48:38.055] SequentialFuture started (and completed)
[17:48:38.055] - Launch lazy future ... done
[17:48:38.055] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[17:48:38.056] getGlobalsAndPackages() ...
[17:48:38.056] Searching for globals...
[17:48:38.056] - globals found: [1] ‘print’
[17:48:38.056] Searching for globals ... DONE
[17:48:38.056] Resolving globals: FALSE
[17:48:38.057] 
[17:48:38.057] 
[17:48:38.057] getGlobalsAndPackages() ... DONE
[17:48:38.057] run() for ‘Future’ ...
[17:48:38.057] - state: ‘created’
[17:48:38.057] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:48:38.058] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:48:38.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:48:38.058]   - Field: ‘label’
[17:48:38.058]   - Field: ‘local’
[17:48:38.058]   - Field: ‘owner’
[17:48:38.058]   - Field: ‘envir’
[17:48:38.058]   - Field: ‘packages’
[17:48:38.058]   - Field: ‘gc’
[17:48:38.058]   - Field: ‘conditions’
[17:48:38.058]   - Field: ‘expr’
[17:48:38.058]   - Field: ‘uuid’
[17:48:38.059]   - Field: ‘seed’
[17:48:38.059]   - Field: ‘version’
[17:48:38.059]   - Field: ‘result’
[17:48:38.059]   - Field: ‘asynchronous’
[17:48:38.059]   - Field: ‘calls’
[17:48:38.059]   - Field: ‘globals’
[17:48:38.059]   - Field: ‘stdout’
[17:48:38.059]   - Field: ‘earlySignal’
[17:48:38.059]   - Field: ‘lazy’
[17:48:38.059]   - Field: ‘state’
[17:48:38.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:48:38.060] - Launch lazy future ...
[17:48:38.060] Packages needed by the future expression (n = 0): <none>
[17:48:38.060] Packages needed by future strategies (n = 0): <none>
[17:48:38.060] {
[17:48:38.060]     {
[17:48:38.060]         {
[17:48:38.060]             ...future.startTime <- base::Sys.time()
[17:48:38.060]             {
[17:48:38.060]                 {
[17:48:38.060]                   {
[17:48:38.060]                     base::local({
[17:48:38.060]                       has_future <- base::requireNamespace("future", 
[17:48:38.060]                         quietly = TRUE)
[17:48:38.060]                       if (has_future) {
[17:48:38.060]                         ns <- base::getNamespace("future")
[17:48:38.060]                         version <- ns[[".package"]][["version"]]
[17:48:38.060]                         if (is.null(version)) 
[17:48:38.060]                           version <- utils::packageVersion("future")
[17:48:38.060]                       }
[17:48:38.060]                       else {
[17:48:38.060]                         version <- NULL
[17:48:38.060]                       }
[17:48:38.060]                       if (!has_future || version < "1.8.0") {
[17:48:38.060]                         info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.060]                           "", base::R.version$version.string), 
[17:48:38.060]                           platform = base::sprintf("%s (%s-bit)", 
[17:48:38.060]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.060]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.060]                             "release", "version")], collapse = " "), 
[17:48:38.060]                           hostname = base::Sys.info()[["nodename"]])
[17:48:38.060]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.060]                           info)
[17:48:38.060]                         info <- base::paste(info, collapse = "; ")
[17:48:38.060]                         if (!has_future) {
[17:48:38.060]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.060]                             info)
[17:48:38.060]                         }
[17:48:38.060]                         else {
[17:48:38.060]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.060]                             info, version)
[17:48:38.060]                         }
[17:48:38.060]                         base::stop(msg)
[17:48:38.060]                       }
[17:48:38.060]                     })
[17:48:38.060]                   }
[17:48:38.060]                   ...future.strategy.old <- future::plan("list")
[17:48:38.060]                   options(future.plan = NULL)
[17:48:38.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.060]                 }
[17:48:38.060]                 ...future.workdir <- getwd()
[17:48:38.060]             }
[17:48:38.060]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.060]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.060]         }
[17:48:38.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.060]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.060]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.060]             base::names(...future.oldOptions))
[17:48:38.060]     }
[17:48:38.060]     if (FALSE) {
[17:48:38.060]     }
[17:48:38.060]     else {
[17:48:38.060]         if (TRUE) {
[17:48:38.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.060]                 open = "w")
[17:48:38.060]         }
[17:48:38.060]         else {
[17:48:38.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.060]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.060]         }
[17:48:38.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.060]             base::sink(type = "output", split = FALSE)
[17:48:38.060]             base::close(...future.stdout)
[17:48:38.060]         }, add = TRUE)
[17:48:38.060]     }
[17:48:38.060]     ...future.frame <- base::sys.nframe()
[17:48:38.060]     ...future.conditions <- base::list()
[17:48:38.060]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.060]     if (FALSE) {
[17:48:38.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.060]     }
[17:48:38.060]     ...future.result <- base::tryCatch({
[17:48:38.060]         base::withCallingHandlers({
[17:48:38.060]             ...future.value <- base::withVisible(base::local(print(42)))
[17:48:38.060]             future::FutureResult(value = ...future.value$value, 
[17:48:38.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.060]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.060]                     ...future.globalenv.names))
[17:48:38.060]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.060]         }, condition = base::local({
[17:48:38.060]             c <- base::c
[17:48:38.060]             inherits <- base::inherits
[17:48:38.060]             invokeRestart <- base::invokeRestart
[17:48:38.060]             length <- base::length
[17:48:38.060]             list <- base::list
[17:48:38.060]             seq.int <- base::seq.int
[17:48:38.060]             signalCondition <- base::signalCondition
[17:48:38.060]             sys.calls <- base::sys.calls
[17:48:38.060]             `[[` <- base::`[[`
[17:48:38.060]             `+` <- base::`+`
[17:48:38.060]             `<<-` <- base::`<<-`
[17:48:38.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.060]                   3L)]
[17:48:38.060]             }
[17:48:38.060]             function(cond) {
[17:48:38.060]                 is_error <- inherits(cond, "error")
[17:48:38.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.060]                   NULL)
[17:48:38.060]                 if (is_error) {
[17:48:38.060]                   sessionInformation <- function() {
[17:48:38.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.060]                       search = base::search(), system = base::Sys.info())
[17:48:38.060]                   }
[17:48:38.060]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.060]                     cond$call), session = sessionInformation(), 
[17:48:38.060]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.060]                   signalCondition(cond)
[17:48:38.060]                 }
[17:48:38.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.060]                 "immediateCondition"))) {
[17:48:38.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.060]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.060]                   if (TRUE && !signal) {
[17:48:38.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.060]                     {
[17:48:38.060]                       inherits <- base::inherits
[17:48:38.060]                       invokeRestart <- base::invokeRestart
[17:48:38.060]                       is.null <- base::is.null
[17:48:38.060]                       muffled <- FALSE
[17:48:38.060]                       if (inherits(cond, "message")) {
[17:48:38.060]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.060]                         if (muffled) 
[17:48:38.060]                           invokeRestart("muffleMessage")
[17:48:38.060]                       }
[17:48:38.060]                       else if (inherits(cond, "warning")) {
[17:48:38.060]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.060]                         if (muffled) 
[17:48:38.060]                           invokeRestart("muffleWarning")
[17:48:38.060]                       }
[17:48:38.060]                       else if (inherits(cond, "condition")) {
[17:48:38.060]                         if (!is.null(pattern)) {
[17:48:38.060]                           computeRestarts <- base::computeRestarts
[17:48:38.060]                           grepl <- base::grepl
[17:48:38.060]                           restarts <- computeRestarts(cond)
[17:48:38.060]                           for (restart in restarts) {
[17:48:38.060]                             name <- restart$name
[17:48:38.060]                             if (is.null(name)) 
[17:48:38.060]                               next
[17:48:38.060]                             if (!grepl(pattern, name)) 
[17:48:38.060]                               next
[17:48:38.060]                             invokeRestart(restart)
[17:48:38.060]                             muffled <- TRUE
[17:48:38.060]                             break
[17:48:38.060]                           }
[17:48:38.060]                         }
[17:48:38.060]                       }
[17:48:38.060]                       invisible(muffled)
[17:48:38.060]                     }
[17:48:38.060]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.060]                   }
[17:48:38.060]                 }
[17:48:38.060]                 else {
[17:48:38.060]                   if (TRUE) {
[17:48:38.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.060]                     {
[17:48:38.060]                       inherits <- base::inherits
[17:48:38.060]                       invokeRestart <- base::invokeRestart
[17:48:38.060]                       is.null <- base::is.null
[17:48:38.060]                       muffled <- FALSE
[17:48:38.060]                       if (inherits(cond, "message")) {
[17:48:38.060]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.060]                         if (muffled) 
[17:48:38.060]                           invokeRestart("muffleMessage")
[17:48:38.060]                       }
[17:48:38.060]                       else if (inherits(cond, "warning")) {
[17:48:38.060]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.060]                         if (muffled) 
[17:48:38.060]                           invokeRestart("muffleWarning")
[17:48:38.060]                       }
[17:48:38.060]                       else if (inherits(cond, "condition")) {
[17:48:38.060]                         if (!is.null(pattern)) {
[17:48:38.060]                           computeRestarts <- base::computeRestarts
[17:48:38.060]                           grepl <- base::grepl
[17:48:38.060]                           restarts <- computeRestarts(cond)
[17:48:38.060]                           for (restart in restarts) {
[17:48:38.060]                             name <- restart$name
[17:48:38.060]                             if (is.null(name)) 
[17:48:38.060]                               next
[17:48:38.060]                             if (!grepl(pattern, name)) 
[17:48:38.060]                               next
[17:48:38.060]                             invokeRestart(restart)
[17:48:38.060]                             muffled <- TRUE
[17:48:38.060]                             break
[17:48:38.060]                           }
[17:48:38.060]                         }
[17:48:38.060]                       }
[17:48:38.060]                       invisible(muffled)
[17:48:38.060]                     }
[17:48:38.060]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.060]                   }
[17:48:38.060]                 }
[17:48:38.060]             }
[17:48:38.060]         }))
[17:48:38.060]     }, error = function(ex) {
[17:48:38.060]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.060]                 ...future.rng), started = ...future.startTime, 
[17:48:38.060]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.060]             version = "1.8"), class = "FutureResult")
[17:48:38.060]     }, finally = {
[17:48:38.060]         if (!identical(...future.workdir, getwd())) 
[17:48:38.060]             setwd(...future.workdir)
[17:48:38.060]         {
[17:48:38.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.060]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.060]             }
[17:48:38.060]             base::options(...future.oldOptions)
[17:48:38.060]             if (.Platform$OS.type == "windows") {
[17:48:38.060]                 old_names <- names(...future.oldEnvVars)
[17:48:38.060]                 envs <- base::Sys.getenv()
[17:48:38.060]                 names <- names(envs)
[17:48:38.060]                 common <- intersect(names, old_names)
[17:48:38.060]                 added <- setdiff(names, old_names)
[17:48:38.060]                 removed <- setdiff(old_names, names)
[17:48:38.060]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.060]                   envs[common]]
[17:48:38.060]                 NAMES <- toupper(changed)
[17:48:38.060]                 args <- list()
[17:48:38.060]                 for (kk in seq_along(NAMES)) {
[17:48:38.060]                   name <- changed[[kk]]
[17:48:38.060]                   NAME <- NAMES[[kk]]
[17:48:38.060]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.060]                     next
[17:48:38.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.060]                 }
[17:48:38.060]                 NAMES <- toupper(added)
[17:48:38.060]                 for (kk in seq_along(NAMES)) {
[17:48:38.060]                   name <- added[[kk]]
[17:48:38.060]                   NAME <- NAMES[[kk]]
[17:48:38.060]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.060]                     next
[17:48:38.060]                   args[[name]] <- ""
[17:48:38.060]                 }
[17:48:38.060]                 NAMES <- toupper(removed)
[17:48:38.060]                 for (kk in seq_along(NAMES)) {
[17:48:38.060]                   name <- removed[[kk]]
[17:48:38.060]                   NAME <- NAMES[[kk]]
[17:48:38.060]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.060]                     next
[17:48:38.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.060]                 }
[17:48:38.060]                 if (length(args) > 0) 
[17:48:38.060]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.060]             }
[17:48:38.060]             else {
[17:48:38.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.060]             }
[17:48:38.060]             {
[17:48:38.060]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.060]                   0L) {
[17:48:38.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.060]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.060]                   base::options(opts)
[17:48:38.060]                 }
[17:48:38.060]                 {
[17:48:38.060]                   {
[17:48:38.060]                     NULL
[17:48:38.060]                     RNGkind("Mersenne-Twister")
[17:48:38.060]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:48:38.060]                       inherits = FALSE)
[17:48:38.060]                   }
[17:48:38.060]                   options(future.plan = NULL)
[17:48:38.060]                   if (is.na(NA_character_)) 
[17:48:38.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.060]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.060]                     .init = FALSE)
[17:48:38.060]                 }
[17:48:38.060]             }
[17:48:38.060]         }
[17:48:38.060]     })
[17:48:38.060]     if (TRUE) {
[17:48:38.060]         base::sink(type = "output", split = FALSE)
[17:48:38.060]         if (TRUE) {
[17:48:38.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.060]         }
[17:48:38.060]         else {
[17:48:38.060]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.060]         }
[17:48:38.060]         base::close(...future.stdout)
[17:48:38.060]         ...future.stdout <- NULL
[17:48:38.060]     }
[17:48:38.060]     ...future.result$conditions <- ...future.conditions
[17:48:38.060]     ...future.result$finished <- base::Sys.time()
[17:48:38.060]     ...future.result
[17:48:38.060] }
[17:48:38.062] plan(): Setting new future strategy stack:
[17:48:38.062] List of future strategies:
[17:48:38.062] 1. sequential:
[17:48:38.062]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.062]    - tweaked: FALSE
[17:48:38.062]    - call: NULL
[17:48:38.062] plan(): nbrOfWorkers() = 1
[17:48:38.063] plan(): Setting new future strategy stack:
[17:48:38.063] List of future strategies:
[17:48:38.063] 1. sequential:
[17:48:38.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.063]    - tweaked: FALSE
[17:48:38.063]    - call: plan(strategy)
[17:48:38.064] plan(): nbrOfWorkers() = 1
[17:48:38.064] SequentialFuture started (and completed)
[17:48:38.064] - Launch lazy future ... done
[17:48:38.064] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[17:48:38.069] plan(): Setting new future strategy stack:
[17:48:38.069] List of future strategies:
[17:48:38.069] 1. multicore:
[17:48:38.069]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.069]    - tweaked: FALSE
[17:48:38.069]    - call: plan(strategy)
[17:48:38.073] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[17:48:38.073] getGlobalsAndPackages() ...
[17:48:38.073] Searching for globals...
[17:48:38.076] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.076] Searching for globals ... DONE
[17:48:38.076] Resolving globals: FALSE
[17:48:38.077] 
[17:48:38.077] - packages: [1] ‘utils’
[17:48:38.077] getGlobalsAndPackages() ... DONE
[17:48:38.077] run() for ‘Future’ ...
[17:48:38.077] - state: ‘created’
[17:48:38.078] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.083] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.083] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.083]   - Field: ‘label’
[17:48:38.083]   - Field: ‘local’
[17:48:38.083]   - Field: ‘owner’
[17:48:38.083]   - Field: ‘envir’
[17:48:38.084]   - Field: ‘workers’
[17:48:38.084]   - Field: ‘packages’
[17:48:38.084]   - Field: ‘gc’
[17:48:38.084]   - Field: ‘job’
[17:48:38.084]   - Field: ‘conditions’
[17:48:38.084]   - Field: ‘expr’
[17:48:38.084]   - Field: ‘uuid’
[17:48:38.084]   - Field: ‘seed’
[17:48:38.084]   - Field: ‘version’
[17:48:38.084]   - Field: ‘result’
[17:48:38.084]   - Field: ‘asynchronous’
[17:48:38.085]   - Field: ‘calls’
[17:48:38.085]   - Field: ‘globals’
[17:48:38.085]   - Field: ‘stdout’
[17:48:38.085]   - Field: ‘earlySignal’
[17:48:38.085]   - Field: ‘lazy’
[17:48:38.085]   - Field: ‘state’
[17:48:38.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.085] - Launch lazy future ...
[17:48:38.086] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.086] Packages needed by future strategies (n = 0): <none>
[17:48:38.087] {
[17:48:38.087]     {
[17:48:38.087]         {
[17:48:38.087]             ...future.startTime <- base::Sys.time()
[17:48:38.087]             {
[17:48:38.087]                 {
[17:48:38.087]                   {
[17:48:38.087]                     {
[17:48:38.087]                       {
[17:48:38.087]                         base::local({
[17:48:38.087]                           has_future <- base::requireNamespace("future", 
[17:48:38.087]                             quietly = TRUE)
[17:48:38.087]                           if (has_future) {
[17:48:38.087]                             ns <- base::getNamespace("future")
[17:48:38.087]                             version <- ns[[".package"]][["version"]]
[17:48:38.087]                             if (is.null(version)) 
[17:48:38.087]                               version <- utils::packageVersion("future")
[17:48:38.087]                           }
[17:48:38.087]                           else {
[17:48:38.087]                             version <- NULL
[17:48:38.087]                           }
[17:48:38.087]                           if (!has_future || version < "1.8.0") {
[17:48:38.087]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.087]                               "", base::R.version$version.string), 
[17:48:38.087]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:38.087]                                 base::R.version$platform, 8 * 
[17:48:38.087]                                   base::.Machine$sizeof.pointer), 
[17:48:38.087]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.087]                                 "release", "version")], collapse = " "), 
[17:48:38.087]                               hostname = base::Sys.info()[["nodename"]])
[17:48:38.087]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.087]                               info)
[17:48:38.087]                             info <- base::paste(info, collapse = "; ")
[17:48:38.087]                             if (!has_future) {
[17:48:38.087]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.087]                                 info)
[17:48:38.087]                             }
[17:48:38.087]                             else {
[17:48:38.087]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.087]                                 info, version)
[17:48:38.087]                             }
[17:48:38.087]                             base::stop(msg)
[17:48:38.087]                           }
[17:48:38.087]                         })
[17:48:38.087]                       }
[17:48:38.087]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.087]                       base::options(mc.cores = 1L)
[17:48:38.087]                     }
[17:48:38.087]                     base::local({
[17:48:38.087]                       for (pkg in "utils") {
[17:48:38.087]                         base::loadNamespace(pkg)
[17:48:38.087]                         base::library(pkg, character.only = TRUE)
[17:48:38.087]                       }
[17:48:38.087]                     })
[17:48:38.087]                   }
[17:48:38.087]                   ...future.strategy.old <- future::plan("list")
[17:48:38.087]                   options(future.plan = NULL)
[17:48:38.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.087]                 }
[17:48:38.087]                 ...future.workdir <- getwd()
[17:48:38.087]             }
[17:48:38.087]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.087]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.087]         }
[17:48:38.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.087]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.087]             base::names(...future.oldOptions))
[17:48:38.087]     }
[17:48:38.087]     if (FALSE) {
[17:48:38.087]     }
[17:48:38.087]     else {
[17:48:38.087]         if (TRUE) {
[17:48:38.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.087]                 open = "w")
[17:48:38.087]         }
[17:48:38.087]         else {
[17:48:38.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.087]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.087]         }
[17:48:38.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.087]             base::sink(type = "output", split = FALSE)
[17:48:38.087]             base::close(...future.stdout)
[17:48:38.087]         }, add = TRUE)
[17:48:38.087]     }
[17:48:38.087]     ...future.frame <- base::sys.nframe()
[17:48:38.087]     ...future.conditions <- base::list()
[17:48:38.087]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.087]     if (FALSE) {
[17:48:38.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.087]     }
[17:48:38.087]     ...future.result <- base::tryCatch({
[17:48:38.087]         base::withCallingHandlers({
[17:48:38.087]             ...future.value <- base::withVisible(base::local({
[17:48:38.087]                 withCallingHandlers({
[17:48:38.087]                   {
[17:48:38.087]                     print(1:50)
[17:48:38.087]                     str(1:50)
[17:48:38.087]                     cat(letters, sep = "-")
[17:48:38.087]                     cat(1:6, collapse = "\n")
[17:48:38.087]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.087]                     42L
[17:48:38.087]                   }
[17:48:38.087]                 }, immediateCondition = function(cond) {
[17:48:38.087]                   save_rds <- function (object, pathname, ...) 
[17:48:38.087]                   {
[17:48:38.087]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.087]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.087]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.087]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.087]                         fi_tmp[["mtime"]])
[17:48:38.087]                     }
[17:48:38.087]                     tryCatch({
[17:48:38.087]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.087]                     }, error = function(ex) {
[17:48:38.087]                       msg <- conditionMessage(ex)
[17:48:38.087]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.087]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.087]                         fi_tmp[["mtime"]], msg)
[17:48:38.087]                       ex$message <- msg
[17:48:38.087]                       stop(ex)
[17:48:38.087]                     })
[17:48:38.087]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.087]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.087]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.087]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.087]                       fi <- file.info(pathname)
[17:48:38.087]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.087]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.087]                         fi[["size"]], fi[["mtime"]])
[17:48:38.087]                       stop(msg)
[17:48:38.087]                     }
[17:48:38.087]                     invisible(pathname)
[17:48:38.087]                   }
[17:48:38.087]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.087]                     rootPath = tempdir()) 
[17:48:38.087]                   {
[17:48:38.087]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.087]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.087]                       tmpdir = path, fileext = ".rds")
[17:48:38.087]                     save_rds(obj, file)
[17:48:38.087]                   }
[17:48:38.087]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.087]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.087]                   {
[17:48:38.087]                     inherits <- base::inherits
[17:48:38.087]                     invokeRestart <- base::invokeRestart
[17:48:38.087]                     is.null <- base::is.null
[17:48:38.087]                     muffled <- FALSE
[17:48:38.087]                     if (inherits(cond, "message")) {
[17:48:38.087]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.087]                       if (muffled) 
[17:48:38.087]                         invokeRestart("muffleMessage")
[17:48:38.087]                     }
[17:48:38.087]                     else if (inherits(cond, "warning")) {
[17:48:38.087]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.087]                       if (muffled) 
[17:48:38.087]                         invokeRestart("muffleWarning")
[17:48:38.087]                     }
[17:48:38.087]                     else if (inherits(cond, "condition")) {
[17:48:38.087]                       if (!is.null(pattern)) {
[17:48:38.087]                         computeRestarts <- base::computeRestarts
[17:48:38.087]                         grepl <- base::grepl
[17:48:38.087]                         restarts <- computeRestarts(cond)
[17:48:38.087]                         for (restart in restarts) {
[17:48:38.087]                           name <- restart$name
[17:48:38.087]                           if (is.null(name)) 
[17:48:38.087]                             next
[17:48:38.087]                           if (!grepl(pattern, name)) 
[17:48:38.087]                             next
[17:48:38.087]                           invokeRestart(restart)
[17:48:38.087]                           muffled <- TRUE
[17:48:38.087]                           break
[17:48:38.087]                         }
[17:48:38.087]                       }
[17:48:38.087]                     }
[17:48:38.087]                     invisible(muffled)
[17:48:38.087]                   }
[17:48:38.087]                   muffleCondition(cond)
[17:48:38.087]                 })
[17:48:38.087]             }))
[17:48:38.087]             future::FutureResult(value = ...future.value$value, 
[17:48:38.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.087]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.087]                     ...future.globalenv.names))
[17:48:38.087]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.087]         }, condition = base::local({
[17:48:38.087]             c <- base::c
[17:48:38.087]             inherits <- base::inherits
[17:48:38.087]             invokeRestart <- base::invokeRestart
[17:48:38.087]             length <- base::length
[17:48:38.087]             list <- base::list
[17:48:38.087]             seq.int <- base::seq.int
[17:48:38.087]             signalCondition <- base::signalCondition
[17:48:38.087]             sys.calls <- base::sys.calls
[17:48:38.087]             `[[` <- base::`[[`
[17:48:38.087]             `+` <- base::`+`
[17:48:38.087]             `<<-` <- base::`<<-`
[17:48:38.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.087]                   3L)]
[17:48:38.087]             }
[17:48:38.087]             function(cond) {
[17:48:38.087]                 is_error <- inherits(cond, "error")
[17:48:38.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.087]                   NULL)
[17:48:38.087]                 if (is_error) {
[17:48:38.087]                   sessionInformation <- function() {
[17:48:38.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.087]                       search = base::search(), system = base::Sys.info())
[17:48:38.087]                   }
[17:48:38.087]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.087]                     cond$call), session = sessionInformation(), 
[17:48:38.087]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.087]                   signalCondition(cond)
[17:48:38.087]                 }
[17:48:38.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.087]                 "immediateCondition"))) {
[17:48:38.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.087]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.087]                   if (TRUE && !signal) {
[17:48:38.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.087]                     {
[17:48:38.087]                       inherits <- base::inherits
[17:48:38.087]                       invokeRestart <- base::invokeRestart
[17:48:38.087]                       is.null <- base::is.null
[17:48:38.087]                       muffled <- FALSE
[17:48:38.087]                       if (inherits(cond, "message")) {
[17:48:38.087]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.087]                         if (muffled) 
[17:48:38.087]                           invokeRestart("muffleMessage")
[17:48:38.087]                       }
[17:48:38.087]                       else if (inherits(cond, "warning")) {
[17:48:38.087]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.087]                         if (muffled) 
[17:48:38.087]                           invokeRestart("muffleWarning")
[17:48:38.087]                       }
[17:48:38.087]                       else if (inherits(cond, "condition")) {
[17:48:38.087]                         if (!is.null(pattern)) {
[17:48:38.087]                           computeRestarts <- base::computeRestarts
[17:48:38.087]                           grepl <- base::grepl
[17:48:38.087]                           restarts <- computeRestarts(cond)
[17:48:38.087]                           for (restart in restarts) {
[17:48:38.087]                             name <- restart$name
[17:48:38.087]                             if (is.null(name)) 
[17:48:38.087]                               next
[17:48:38.087]                             if (!grepl(pattern, name)) 
[17:48:38.087]                               next
[17:48:38.087]                             invokeRestart(restart)
[17:48:38.087]                             muffled <- TRUE
[17:48:38.087]                             break
[17:48:38.087]                           }
[17:48:38.087]                         }
[17:48:38.087]                       }
[17:48:38.087]                       invisible(muffled)
[17:48:38.087]                     }
[17:48:38.087]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.087]                   }
[17:48:38.087]                 }
[17:48:38.087]                 else {
[17:48:38.087]                   if (TRUE) {
[17:48:38.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.087]                     {
[17:48:38.087]                       inherits <- base::inherits
[17:48:38.087]                       invokeRestart <- base::invokeRestart
[17:48:38.087]                       is.null <- base::is.null
[17:48:38.087]                       muffled <- FALSE
[17:48:38.087]                       if (inherits(cond, "message")) {
[17:48:38.087]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.087]                         if (muffled) 
[17:48:38.087]                           invokeRestart("muffleMessage")
[17:48:38.087]                       }
[17:48:38.087]                       else if (inherits(cond, "warning")) {
[17:48:38.087]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.087]                         if (muffled) 
[17:48:38.087]                           invokeRestart("muffleWarning")
[17:48:38.087]                       }
[17:48:38.087]                       else if (inherits(cond, "condition")) {
[17:48:38.087]                         if (!is.null(pattern)) {
[17:48:38.087]                           computeRestarts <- base::computeRestarts
[17:48:38.087]                           grepl <- base::grepl
[17:48:38.087]                           restarts <- computeRestarts(cond)
[17:48:38.087]                           for (restart in restarts) {
[17:48:38.087]                             name <- restart$name
[17:48:38.087]                             if (is.null(name)) 
[17:48:38.087]                               next
[17:48:38.087]                             if (!grepl(pattern, name)) 
[17:48:38.087]                               next
[17:48:38.087]                             invokeRestart(restart)
[17:48:38.087]                             muffled <- TRUE
[17:48:38.087]                             break
[17:48:38.087]                           }
[17:48:38.087]                         }
[17:48:38.087]                       }
[17:48:38.087]                       invisible(muffled)
[17:48:38.087]                     }
[17:48:38.087]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.087]                   }
[17:48:38.087]                 }
[17:48:38.087]             }
[17:48:38.087]         }))
[17:48:38.087]     }, error = function(ex) {
[17:48:38.087]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.087]                 ...future.rng), started = ...future.startTime, 
[17:48:38.087]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.087]             version = "1.8"), class = "FutureResult")
[17:48:38.087]     }, finally = {
[17:48:38.087]         if (!identical(...future.workdir, getwd())) 
[17:48:38.087]             setwd(...future.workdir)
[17:48:38.087]         {
[17:48:38.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.087]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.087]             }
[17:48:38.087]             base::options(...future.oldOptions)
[17:48:38.087]             if (.Platform$OS.type == "windows") {
[17:48:38.087]                 old_names <- names(...future.oldEnvVars)
[17:48:38.087]                 envs <- base::Sys.getenv()
[17:48:38.087]                 names <- names(envs)
[17:48:38.087]                 common <- intersect(names, old_names)
[17:48:38.087]                 added <- setdiff(names, old_names)
[17:48:38.087]                 removed <- setdiff(old_names, names)
[17:48:38.087]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.087]                   envs[common]]
[17:48:38.087]                 NAMES <- toupper(changed)
[17:48:38.087]                 args <- list()
[17:48:38.087]                 for (kk in seq_along(NAMES)) {
[17:48:38.087]                   name <- changed[[kk]]
[17:48:38.087]                   NAME <- NAMES[[kk]]
[17:48:38.087]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.087]                     next
[17:48:38.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.087]                 }
[17:48:38.087]                 NAMES <- toupper(added)
[17:48:38.087]                 for (kk in seq_along(NAMES)) {
[17:48:38.087]                   name <- added[[kk]]
[17:48:38.087]                   NAME <- NAMES[[kk]]
[17:48:38.087]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.087]                     next
[17:48:38.087]                   args[[name]] <- ""
[17:48:38.087]                 }
[17:48:38.087]                 NAMES <- toupper(removed)
[17:48:38.087]                 for (kk in seq_along(NAMES)) {
[17:48:38.087]                   name <- removed[[kk]]
[17:48:38.087]                   NAME <- NAMES[[kk]]
[17:48:38.087]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.087]                     next
[17:48:38.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.087]                 }
[17:48:38.087]                 if (length(args) > 0) 
[17:48:38.087]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.087]             }
[17:48:38.087]             else {
[17:48:38.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.087]             }
[17:48:38.087]             {
[17:48:38.087]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.087]                   0L) {
[17:48:38.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.087]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.087]                   base::options(opts)
[17:48:38.087]                 }
[17:48:38.087]                 {
[17:48:38.087]                   {
[17:48:38.087]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.087]                     NULL
[17:48:38.087]                   }
[17:48:38.087]                   options(future.plan = NULL)
[17:48:38.087]                   if (is.na(NA_character_)) 
[17:48:38.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.087]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.087]                     .init = FALSE)
[17:48:38.087]                 }
[17:48:38.087]             }
[17:48:38.087]         }
[17:48:38.087]     })
[17:48:38.087]     if (TRUE) {
[17:48:38.087]         base::sink(type = "output", split = FALSE)
[17:48:38.087]         if (TRUE) {
[17:48:38.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.087]         }
[17:48:38.087]         else {
[17:48:38.087]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.087]         }
[17:48:38.087]         base::close(...future.stdout)
[17:48:38.087]         ...future.stdout <- NULL
[17:48:38.087]     }
[17:48:38.087]     ...future.result$conditions <- ...future.conditions
[17:48:38.087]     ...future.result$finished <- base::Sys.time()
[17:48:38.087]     ...future.result
[17:48:38.087] }
[17:48:38.089] requestCore(): workers = 2
[17:48:38.092] MulticoreFuture started
[17:48:38.092] - Launch lazy future ... done
[17:48:38.093] run() for ‘MulticoreFuture’ ... done
[17:48:38.093] plan(): Setting new future strategy stack:
[17:48:38.094] result() for MulticoreFuture ...
[17:48:38.093] List of future strategies:
[17:48:38.093] 1. sequential:
[17:48:38.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.093]    - tweaked: FALSE
[17:48:38.093]    - call: NULL
[17:48:38.094] plan(): nbrOfWorkers() = 1
[17:48:38.098] plan(): Setting new future strategy stack:
[17:48:38.098] List of future strategies:
[17:48:38.098] 1. multicore:
[17:48:38.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.098]    - tweaked: FALSE
[17:48:38.098]    - call: plan(strategy)
[17:48:38.103] plan(): nbrOfWorkers() = 2
[17:48:38.108] result() for MulticoreFuture ...
[17:48:38.108] result() for MulticoreFuture ... done
[17:48:38.108] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ session_uuid: chr "c9765b3f-0a5e-7bf3-58cb-cd9824004cde"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50452
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:38"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:38.117] result() for MulticoreFuture ...
[17:48:38.117] result() for MulticoreFuture ... done
[17:48:38.117] result() for MulticoreFuture ...
[17:48:38.118] result() for MulticoreFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.01120687 secs (started 2024-11-22 17:48:38.092488)
version: 1.8
[17:48:38.118] getGlobalsAndPackages() ...
[17:48:38.118] Searching for globals...
[17:48:38.122] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.122] Searching for globals ... DONE
[17:48:38.122] Resolving globals: FALSE
[17:48:38.123] 
[17:48:38.123] - packages: [1] ‘utils’
[17:48:38.123] getGlobalsAndPackages() ... DONE
[17:48:38.124] run() for ‘Future’ ...
[17:48:38.124] - state: ‘created’
[17:48:38.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.128] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.128]   - Field: ‘label’
[17:48:38.128]   - Field: ‘local’
[17:48:38.128]   - Field: ‘owner’
[17:48:38.128]   - Field: ‘envir’
[17:48:38.128]   - Field: ‘workers’
[17:48:38.129]   - Field: ‘packages’
[17:48:38.129]   - Field: ‘gc’
[17:48:38.131]   - Field: ‘job’
[17:48:38.131]   - Field: ‘conditions’
[17:48:38.132]   - Field: ‘expr’
[17:48:38.132]   - Field: ‘uuid’
[17:48:38.132]   - Field: ‘seed’
[17:48:38.132]   - Field: ‘version’
[17:48:38.132]   - Field: ‘result’
[17:48:38.132]   - Field: ‘asynchronous’
[17:48:38.132]   - Field: ‘calls’
[17:48:38.132]   - Field: ‘globals’
[17:48:38.132]   - Field: ‘stdout’
[17:48:38.133]   - Field: ‘earlySignal’
[17:48:38.133]   - Field: ‘lazy’
[17:48:38.133]   - Field: ‘state’
[17:48:38.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.133] - Launch lazy future ...
[17:48:38.133] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.134] Packages needed by future strategies (n = 0): <none>
[17:48:38.134] {
[17:48:38.134]     {
[17:48:38.134]         {
[17:48:38.134]             ...future.startTime <- base::Sys.time()
[17:48:38.134]             {
[17:48:38.134]                 {
[17:48:38.134]                   {
[17:48:38.134]                     {
[17:48:38.134]                       {
[17:48:38.134]                         base::local({
[17:48:38.134]                           has_future <- base::requireNamespace("future", 
[17:48:38.134]                             quietly = TRUE)
[17:48:38.134]                           if (has_future) {
[17:48:38.134]                             ns <- base::getNamespace("future")
[17:48:38.134]                             version <- ns[[".package"]][["version"]]
[17:48:38.134]                             if (is.null(version)) 
[17:48:38.134]                               version <- utils::packageVersion("future")
[17:48:38.134]                           }
[17:48:38.134]                           else {
[17:48:38.134]                             version <- NULL
[17:48:38.134]                           }
[17:48:38.134]                           if (!has_future || version < "1.8.0") {
[17:48:38.134]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.134]                               "", base::R.version$version.string), 
[17:48:38.134]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:38.134]                                 base::R.version$platform, 8 * 
[17:48:38.134]                                   base::.Machine$sizeof.pointer), 
[17:48:38.134]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.134]                                 "release", "version")], collapse = " "), 
[17:48:38.134]                               hostname = base::Sys.info()[["nodename"]])
[17:48:38.134]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.134]                               info)
[17:48:38.134]                             info <- base::paste(info, collapse = "; ")
[17:48:38.134]                             if (!has_future) {
[17:48:38.134]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.134]                                 info)
[17:48:38.134]                             }
[17:48:38.134]                             else {
[17:48:38.134]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.134]                                 info, version)
[17:48:38.134]                             }
[17:48:38.134]                             base::stop(msg)
[17:48:38.134]                           }
[17:48:38.134]                         })
[17:48:38.134]                       }
[17:48:38.134]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.134]                       base::options(mc.cores = 1L)
[17:48:38.134]                     }
[17:48:38.134]                     base::local({
[17:48:38.134]                       for (pkg in "utils") {
[17:48:38.134]                         base::loadNamespace(pkg)
[17:48:38.134]                         base::library(pkg, character.only = TRUE)
[17:48:38.134]                       }
[17:48:38.134]                     })
[17:48:38.134]                   }
[17:48:38.134]                   ...future.strategy.old <- future::plan("list")
[17:48:38.134]                   options(future.plan = NULL)
[17:48:38.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.134]                 }
[17:48:38.134]                 ...future.workdir <- getwd()
[17:48:38.134]             }
[17:48:38.134]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.134]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.134]         }
[17:48:38.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.134]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.134]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.134]             base::names(...future.oldOptions))
[17:48:38.134]     }
[17:48:38.134]     if (FALSE) {
[17:48:38.134]     }
[17:48:38.134]     else {
[17:48:38.134]         if (TRUE) {
[17:48:38.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.134]                 open = "w")
[17:48:38.134]         }
[17:48:38.134]         else {
[17:48:38.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.134]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.134]         }
[17:48:38.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.134]             base::sink(type = "output", split = FALSE)
[17:48:38.134]             base::close(...future.stdout)
[17:48:38.134]         }, add = TRUE)
[17:48:38.134]     }
[17:48:38.134]     ...future.frame <- base::sys.nframe()
[17:48:38.134]     ...future.conditions <- base::list()
[17:48:38.134]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.134]     if (FALSE) {
[17:48:38.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.134]     }
[17:48:38.134]     ...future.result <- base::tryCatch({
[17:48:38.134]         base::withCallingHandlers({
[17:48:38.134]             ...future.value <- base::withVisible(base::local({
[17:48:38.134]                 withCallingHandlers({
[17:48:38.134]                   {
[17:48:38.134]                     print(1:50)
[17:48:38.134]                     str(1:50)
[17:48:38.134]                     cat(letters, sep = "-")
[17:48:38.134]                     cat(1:6, collapse = "\n")
[17:48:38.134]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.134]                     42L
[17:48:38.134]                   }
[17:48:38.134]                 }, immediateCondition = function(cond) {
[17:48:38.134]                   save_rds <- function (object, pathname, ...) 
[17:48:38.134]                   {
[17:48:38.134]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.134]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.134]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.134]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.134]                         fi_tmp[["mtime"]])
[17:48:38.134]                     }
[17:48:38.134]                     tryCatch({
[17:48:38.134]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.134]                     }, error = function(ex) {
[17:48:38.134]                       msg <- conditionMessage(ex)
[17:48:38.134]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.134]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.134]                         fi_tmp[["mtime"]], msg)
[17:48:38.134]                       ex$message <- msg
[17:48:38.134]                       stop(ex)
[17:48:38.134]                     })
[17:48:38.134]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.134]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.134]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.134]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.134]                       fi <- file.info(pathname)
[17:48:38.134]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.134]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.134]                         fi[["size"]], fi[["mtime"]])
[17:48:38.134]                       stop(msg)
[17:48:38.134]                     }
[17:48:38.134]                     invisible(pathname)
[17:48:38.134]                   }
[17:48:38.134]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.134]                     rootPath = tempdir()) 
[17:48:38.134]                   {
[17:48:38.134]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.134]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.134]                       tmpdir = path, fileext = ".rds")
[17:48:38.134]                     save_rds(obj, file)
[17:48:38.134]                   }
[17:48:38.134]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.134]                   {
[17:48:38.134]                     inherits <- base::inherits
[17:48:38.134]                     invokeRestart <- base::invokeRestart
[17:48:38.134]                     is.null <- base::is.null
[17:48:38.134]                     muffled <- FALSE
[17:48:38.134]                     if (inherits(cond, "message")) {
[17:48:38.134]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.134]                       if (muffled) 
[17:48:38.134]                         invokeRestart("muffleMessage")
[17:48:38.134]                     }
[17:48:38.134]                     else if (inherits(cond, "warning")) {
[17:48:38.134]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.134]                       if (muffled) 
[17:48:38.134]                         invokeRestart("muffleWarning")
[17:48:38.134]                     }
[17:48:38.134]                     else if (inherits(cond, "condition")) {
[17:48:38.134]                       if (!is.null(pattern)) {
[17:48:38.134]                         computeRestarts <- base::computeRestarts
[17:48:38.134]                         grepl <- base::grepl
[17:48:38.134]                         restarts <- computeRestarts(cond)
[17:48:38.134]                         for (restart in restarts) {
[17:48:38.134]                           name <- restart$name
[17:48:38.134]                           if (is.null(name)) 
[17:48:38.134]                             next
[17:48:38.134]                           if (!grepl(pattern, name)) 
[17:48:38.134]                             next
[17:48:38.134]                           invokeRestart(restart)
[17:48:38.134]                           muffled <- TRUE
[17:48:38.134]                           break
[17:48:38.134]                         }
[17:48:38.134]                       }
[17:48:38.134]                     }
[17:48:38.134]                     invisible(muffled)
[17:48:38.134]                   }
[17:48:38.134]                   muffleCondition(cond)
[17:48:38.134]                 })
[17:48:38.134]             }))
[17:48:38.134]             future::FutureResult(value = ...future.value$value, 
[17:48:38.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.134]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.134]                     ...future.globalenv.names))
[17:48:38.134]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.134]         }, condition = base::local({
[17:48:38.134]             c <- base::c
[17:48:38.134]             inherits <- base::inherits
[17:48:38.134]             invokeRestart <- base::invokeRestart
[17:48:38.134]             length <- base::length
[17:48:38.134]             list <- base::list
[17:48:38.134]             seq.int <- base::seq.int
[17:48:38.134]             signalCondition <- base::signalCondition
[17:48:38.134]             sys.calls <- base::sys.calls
[17:48:38.134]             `[[` <- base::`[[`
[17:48:38.134]             `+` <- base::`+`
[17:48:38.134]             `<<-` <- base::`<<-`
[17:48:38.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.134]                   3L)]
[17:48:38.134]             }
[17:48:38.134]             function(cond) {
[17:48:38.134]                 is_error <- inherits(cond, "error")
[17:48:38.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.134]                   NULL)
[17:48:38.134]                 if (is_error) {
[17:48:38.134]                   sessionInformation <- function() {
[17:48:38.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.134]                       search = base::search(), system = base::Sys.info())
[17:48:38.134]                   }
[17:48:38.134]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.134]                     cond$call), session = sessionInformation(), 
[17:48:38.134]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.134]                   signalCondition(cond)
[17:48:38.134]                 }
[17:48:38.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.134]                 "immediateCondition"))) {
[17:48:38.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.134]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.134]                   if (TRUE && !signal) {
[17:48:38.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.134]                     {
[17:48:38.134]                       inherits <- base::inherits
[17:48:38.134]                       invokeRestart <- base::invokeRestart
[17:48:38.134]                       is.null <- base::is.null
[17:48:38.134]                       muffled <- FALSE
[17:48:38.134]                       if (inherits(cond, "message")) {
[17:48:38.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.134]                         if (muffled) 
[17:48:38.134]                           invokeRestart("muffleMessage")
[17:48:38.134]                       }
[17:48:38.134]                       else if (inherits(cond, "warning")) {
[17:48:38.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.134]                         if (muffled) 
[17:48:38.134]                           invokeRestart("muffleWarning")
[17:48:38.134]                       }
[17:48:38.134]                       else if (inherits(cond, "condition")) {
[17:48:38.134]                         if (!is.null(pattern)) {
[17:48:38.134]                           computeRestarts <- base::computeRestarts
[17:48:38.134]                           grepl <- base::grepl
[17:48:38.134]                           restarts <- computeRestarts(cond)
[17:48:38.134]                           for (restart in restarts) {
[17:48:38.134]                             name <- restart$name
[17:48:38.134]                             if (is.null(name)) 
[17:48:38.134]                               next
[17:48:38.134]                             if (!grepl(pattern, name)) 
[17:48:38.134]                               next
[17:48:38.134]                             invokeRestart(restart)
[17:48:38.134]                             muffled <- TRUE
[17:48:38.134]                             break
[17:48:38.134]                           }
[17:48:38.134]                         }
[17:48:38.134]                       }
[17:48:38.134]                       invisible(muffled)
[17:48:38.134]                     }
[17:48:38.134]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.134]                   }
[17:48:38.134]                 }
[17:48:38.134]                 else {
[17:48:38.134]                   if (TRUE) {
[17:48:38.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.134]                     {
[17:48:38.134]                       inherits <- base::inherits
[17:48:38.134]                       invokeRestart <- base::invokeRestart
[17:48:38.134]                       is.null <- base::is.null
[17:48:38.134]                       muffled <- FALSE
[17:48:38.134]                       if (inherits(cond, "message")) {
[17:48:38.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.134]                         if (muffled) 
[17:48:38.134]                           invokeRestart("muffleMessage")
[17:48:38.134]                       }
[17:48:38.134]                       else if (inherits(cond, "warning")) {
[17:48:38.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.134]                         if (muffled) 
[17:48:38.134]                           invokeRestart("muffleWarning")
[17:48:38.134]                       }
[17:48:38.134]                       else if (inherits(cond, "condition")) {
[17:48:38.134]                         if (!is.null(pattern)) {
[17:48:38.134]                           computeRestarts <- base::computeRestarts
[17:48:38.134]                           grepl <- base::grepl
[17:48:38.134]                           restarts <- computeRestarts(cond)
[17:48:38.134]                           for (restart in restarts) {
[17:48:38.134]                             name <- restart$name
[17:48:38.134]                             if (is.null(name)) 
[17:48:38.134]                               next
[17:48:38.134]                             if (!grepl(pattern, name)) 
[17:48:38.134]                               next
[17:48:38.134]                             invokeRestart(restart)
[17:48:38.134]                             muffled <- TRUE
[17:48:38.134]                             break
[17:48:38.134]                           }
[17:48:38.134]                         }
[17:48:38.134]                       }
[17:48:38.134]                       invisible(muffled)
[17:48:38.134]                     }
[17:48:38.134]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.134]                   }
[17:48:38.134]                 }
[17:48:38.134]             }
[17:48:38.134]         }))
[17:48:38.134]     }, error = function(ex) {
[17:48:38.134]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.134]                 ...future.rng), started = ...future.startTime, 
[17:48:38.134]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.134]             version = "1.8"), class = "FutureResult")
[17:48:38.134]     }, finally = {
[17:48:38.134]         if (!identical(...future.workdir, getwd())) 
[17:48:38.134]             setwd(...future.workdir)
[17:48:38.134]         {
[17:48:38.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.134]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.134]             }
[17:48:38.134]             base::options(...future.oldOptions)
[17:48:38.134]             if (.Platform$OS.type == "windows") {
[17:48:38.134]                 old_names <- names(...future.oldEnvVars)
[17:48:38.134]                 envs <- base::Sys.getenv()
[17:48:38.134]                 names <- names(envs)
[17:48:38.134]                 common <- intersect(names, old_names)
[17:48:38.134]                 added <- setdiff(names, old_names)
[17:48:38.134]                 removed <- setdiff(old_names, names)
[17:48:38.134]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.134]                   envs[common]]
[17:48:38.134]                 NAMES <- toupper(changed)
[17:48:38.134]                 args <- list()
[17:48:38.134]                 for (kk in seq_along(NAMES)) {
[17:48:38.134]                   name <- changed[[kk]]
[17:48:38.134]                   NAME <- NAMES[[kk]]
[17:48:38.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.134]                     next
[17:48:38.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.134]                 }
[17:48:38.134]                 NAMES <- toupper(added)
[17:48:38.134]                 for (kk in seq_along(NAMES)) {
[17:48:38.134]                   name <- added[[kk]]
[17:48:38.134]                   NAME <- NAMES[[kk]]
[17:48:38.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.134]                     next
[17:48:38.134]                   args[[name]] <- ""
[17:48:38.134]                 }
[17:48:38.134]                 NAMES <- toupper(removed)
[17:48:38.134]                 for (kk in seq_along(NAMES)) {
[17:48:38.134]                   name <- removed[[kk]]
[17:48:38.134]                   NAME <- NAMES[[kk]]
[17:48:38.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.134]                     next
[17:48:38.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.134]                 }
[17:48:38.134]                 if (length(args) > 0) 
[17:48:38.134]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.134]             }
[17:48:38.134]             else {
[17:48:38.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.134]             }
[17:48:38.134]             {
[17:48:38.134]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.134]                   0L) {
[17:48:38.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.134]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.134]                   base::options(opts)
[17:48:38.134]                 }
[17:48:38.134]                 {
[17:48:38.134]                   {
[17:48:38.134]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.134]                     NULL
[17:48:38.134]                   }
[17:48:38.134]                   options(future.plan = NULL)
[17:48:38.134]                   if (is.na(NA_character_)) 
[17:48:38.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.134]                     .init = FALSE)
[17:48:38.134]                 }
[17:48:38.134]             }
[17:48:38.134]         }
[17:48:38.134]     })
[17:48:38.134]     if (TRUE) {
[17:48:38.134]         base::sink(type = "output", split = FALSE)
[17:48:38.134]         if (TRUE) {
[17:48:38.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.134]         }
[17:48:38.134]         else {
[17:48:38.134]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.134]         }
[17:48:38.134]         base::close(...future.stdout)
[17:48:38.134]         ...future.stdout <- NULL
[17:48:38.134]     }
[17:48:38.134]     ...future.result$conditions <- ...future.conditions
[17:48:38.134]     ...future.result$finished <- base::Sys.time()
[17:48:38.134]     ...future.result
[17:48:38.134] }
[17:48:38.137] requestCore(): workers = 2
[17:48:38.139] MulticoreFuture started
[17:48:38.139] - Launch lazy future ... done
[17:48:38.140] run() for ‘MulticoreFuture’ ... done
[17:48:38.141] result() for MulticoreFuture ...
[17:48:38.141] plan(): Setting new future strategy stack:
[17:48:38.141] List of future strategies:
[17:48:38.141] 1. sequential:
[17:48:38.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.141]    - tweaked: FALSE
[17:48:38.141]    - call: NULL
[17:48:38.142] plan(): nbrOfWorkers() = 1
[17:48:38.146] plan(): Setting new future strategy stack:
[17:48:38.146] List of future strategies:
[17:48:38.146] 1. multicore:
[17:48:38.146]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.146]    - tweaked: FALSE
[17:48:38.146]    - call: plan(strategy)
[17:48:38.151] plan(): nbrOfWorkers() = 2
[17:48:38.152] result() for MulticoreFuture ...
[17:48:38.152] result() for MulticoreFuture ... done
[17:48:38.152] result() for MulticoreFuture ... done
[17:48:38.153] result() for MulticoreFuture ...
[17:48:38.153] result() for MulticoreFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:48:38.153] getGlobalsAndPackages() ...
[17:48:38.153] Searching for globals...
[17:48:38.154] - globals found: [1] ‘print’
[17:48:38.154] Searching for globals ... DONE
[17:48:38.155] Resolving globals: FALSE
[17:48:38.155] 
[17:48:38.155] 
[17:48:38.155] getGlobalsAndPackages() ... DONE
[17:48:38.156] run() for ‘Future’ ...
[17:48:38.156] - state: ‘created’
[17:48:38.156] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.160]   - Field: ‘label’
[17:48:38.160]   - Field: ‘local’
[17:48:38.160]   - Field: ‘owner’
[17:48:38.161]   - Field: ‘envir’
[17:48:38.161]   - Field: ‘workers’
[17:48:38.161]   - Field: ‘packages’
[17:48:38.161]   - Field: ‘gc’
[17:48:38.161]   - Field: ‘job’
[17:48:38.161]   - Field: ‘conditions’
[17:48:38.161]   - Field: ‘expr’
[17:48:38.161]   - Field: ‘uuid’
[17:48:38.161]   - Field: ‘seed’
[17:48:38.162]   - Field: ‘version’
[17:48:38.162]   - Field: ‘result’
[17:48:38.162]   - Field: ‘asynchronous’
[17:48:38.162]   - Field: ‘calls’
[17:48:38.162]   - Field: ‘globals’
[17:48:38.162]   - Field: ‘stdout’
[17:48:38.162]   - Field: ‘earlySignal’
[17:48:38.162]   - Field: ‘lazy’
[17:48:38.162]   - Field: ‘state’
[17:48:38.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.163] - Launch lazy future ...
[17:48:38.163] Packages needed by the future expression (n = 0): <none>
[17:48:38.163] Packages needed by future strategies (n = 0): <none>
[17:48:38.164] {
[17:48:38.164]     {
[17:48:38.164]         {
[17:48:38.164]             ...future.startTime <- base::Sys.time()
[17:48:38.164]             {
[17:48:38.164]                 {
[17:48:38.164]                   {
[17:48:38.164]                     {
[17:48:38.164]                       base::local({
[17:48:38.164]                         has_future <- base::requireNamespace("future", 
[17:48:38.164]                           quietly = TRUE)
[17:48:38.164]                         if (has_future) {
[17:48:38.164]                           ns <- base::getNamespace("future")
[17:48:38.164]                           version <- ns[[".package"]][["version"]]
[17:48:38.164]                           if (is.null(version)) 
[17:48:38.164]                             version <- utils::packageVersion("future")
[17:48:38.164]                         }
[17:48:38.164]                         else {
[17:48:38.164]                           version <- NULL
[17:48:38.164]                         }
[17:48:38.164]                         if (!has_future || version < "1.8.0") {
[17:48:38.164]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.164]                             "", base::R.version$version.string), 
[17:48:38.164]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:38.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.164]                               "release", "version")], collapse = " "), 
[17:48:38.164]                             hostname = base::Sys.info()[["nodename"]])
[17:48:38.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.164]                             info)
[17:48:38.164]                           info <- base::paste(info, collapse = "; ")
[17:48:38.164]                           if (!has_future) {
[17:48:38.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.164]                               info)
[17:48:38.164]                           }
[17:48:38.164]                           else {
[17:48:38.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.164]                               info, version)
[17:48:38.164]                           }
[17:48:38.164]                           base::stop(msg)
[17:48:38.164]                         }
[17:48:38.164]                       })
[17:48:38.164]                     }
[17:48:38.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.164]                     base::options(mc.cores = 1L)
[17:48:38.164]                   }
[17:48:38.164]                   ...future.strategy.old <- future::plan("list")
[17:48:38.164]                   options(future.plan = NULL)
[17:48:38.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.164]                 }
[17:48:38.164]                 ...future.workdir <- getwd()
[17:48:38.164]             }
[17:48:38.164]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.164]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.164]         }
[17:48:38.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.164]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.164]             base::names(...future.oldOptions))
[17:48:38.164]     }
[17:48:38.164]     if (FALSE) {
[17:48:38.164]     }
[17:48:38.164]     else {
[17:48:38.164]         if (TRUE) {
[17:48:38.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.164]                 open = "w")
[17:48:38.164]         }
[17:48:38.164]         else {
[17:48:38.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.164]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.164]         }
[17:48:38.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.164]             base::sink(type = "output", split = FALSE)
[17:48:38.164]             base::close(...future.stdout)
[17:48:38.164]         }, add = TRUE)
[17:48:38.164]     }
[17:48:38.164]     ...future.frame <- base::sys.nframe()
[17:48:38.164]     ...future.conditions <- base::list()
[17:48:38.164]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.164]     if (FALSE) {
[17:48:38.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.164]     }
[17:48:38.164]     ...future.result <- base::tryCatch({
[17:48:38.164]         base::withCallingHandlers({
[17:48:38.164]             ...future.value <- base::withVisible(base::local({
[17:48:38.164]                 withCallingHandlers({
[17:48:38.164]                   print(42)
[17:48:38.164]                 }, immediateCondition = function(cond) {
[17:48:38.164]                   save_rds <- function (object, pathname, ...) 
[17:48:38.164]                   {
[17:48:38.164]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.164]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.164]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.164]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.164]                         fi_tmp[["mtime"]])
[17:48:38.164]                     }
[17:48:38.164]                     tryCatch({
[17:48:38.164]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.164]                     }, error = function(ex) {
[17:48:38.164]                       msg <- conditionMessage(ex)
[17:48:38.164]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.164]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.164]                         fi_tmp[["mtime"]], msg)
[17:48:38.164]                       ex$message <- msg
[17:48:38.164]                       stop(ex)
[17:48:38.164]                     })
[17:48:38.164]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.164]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.164]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.164]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.164]                       fi <- file.info(pathname)
[17:48:38.164]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.164]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.164]                         fi[["size"]], fi[["mtime"]])
[17:48:38.164]                       stop(msg)
[17:48:38.164]                     }
[17:48:38.164]                     invisible(pathname)
[17:48:38.164]                   }
[17:48:38.164]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.164]                     rootPath = tempdir()) 
[17:48:38.164]                   {
[17:48:38.164]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.164]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.164]                       tmpdir = path, fileext = ".rds")
[17:48:38.164]                     save_rds(obj, file)
[17:48:38.164]                   }
[17:48:38.164]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.164]                   {
[17:48:38.164]                     inherits <- base::inherits
[17:48:38.164]                     invokeRestart <- base::invokeRestart
[17:48:38.164]                     is.null <- base::is.null
[17:48:38.164]                     muffled <- FALSE
[17:48:38.164]                     if (inherits(cond, "message")) {
[17:48:38.164]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.164]                       if (muffled) 
[17:48:38.164]                         invokeRestart("muffleMessage")
[17:48:38.164]                     }
[17:48:38.164]                     else if (inherits(cond, "warning")) {
[17:48:38.164]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.164]                       if (muffled) 
[17:48:38.164]                         invokeRestart("muffleWarning")
[17:48:38.164]                     }
[17:48:38.164]                     else if (inherits(cond, "condition")) {
[17:48:38.164]                       if (!is.null(pattern)) {
[17:48:38.164]                         computeRestarts <- base::computeRestarts
[17:48:38.164]                         grepl <- base::grepl
[17:48:38.164]                         restarts <- computeRestarts(cond)
[17:48:38.164]                         for (restart in restarts) {
[17:48:38.164]                           name <- restart$name
[17:48:38.164]                           if (is.null(name)) 
[17:48:38.164]                             next
[17:48:38.164]                           if (!grepl(pattern, name)) 
[17:48:38.164]                             next
[17:48:38.164]                           invokeRestart(restart)
[17:48:38.164]                           muffled <- TRUE
[17:48:38.164]                           break
[17:48:38.164]                         }
[17:48:38.164]                       }
[17:48:38.164]                     }
[17:48:38.164]                     invisible(muffled)
[17:48:38.164]                   }
[17:48:38.164]                   muffleCondition(cond)
[17:48:38.164]                 })
[17:48:38.164]             }))
[17:48:38.164]             future::FutureResult(value = ...future.value$value, 
[17:48:38.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.164]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.164]                     ...future.globalenv.names))
[17:48:38.164]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.164]         }, condition = base::local({
[17:48:38.164]             c <- base::c
[17:48:38.164]             inherits <- base::inherits
[17:48:38.164]             invokeRestart <- base::invokeRestart
[17:48:38.164]             length <- base::length
[17:48:38.164]             list <- base::list
[17:48:38.164]             seq.int <- base::seq.int
[17:48:38.164]             signalCondition <- base::signalCondition
[17:48:38.164]             sys.calls <- base::sys.calls
[17:48:38.164]             `[[` <- base::`[[`
[17:48:38.164]             `+` <- base::`+`
[17:48:38.164]             `<<-` <- base::`<<-`
[17:48:38.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.164]                   3L)]
[17:48:38.164]             }
[17:48:38.164]             function(cond) {
[17:48:38.164]                 is_error <- inherits(cond, "error")
[17:48:38.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.164]                   NULL)
[17:48:38.164]                 if (is_error) {
[17:48:38.164]                   sessionInformation <- function() {
[17:48:38.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.164]                       search = base::search(), system = base::Sys.info())
[17:48:38.164]                   }
[17:48:38.164]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.164]                     cond$call), session = sessionInformation(), 
[17:48:38.164]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.164]                   signalCondition(cond)
[17:48:38.164]                 }
[17:48:38.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.164]                 "immediateCondition"))) {
[17:48:38.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.164]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.164]                   if (TRUE && !signal) {
[17:48:38.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.164]                     {
[17:48:38.164]                       inherits <- base::inherits
[17:48:38.164]                       invokeRestart <- base::invokeRestart
[17:48:38.164]                       is.null <- base::is.null
[17:48:38.164]                       muffled <- FALSE
[17:48:38.164]                       if (inherits(cond, "message")) {
[17:48:38.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.164]                         if (muffled) 
[17:48:38.164]                           invokeRestart("muffleMessage")
[17:48:38.164]                       }
[17:48:38.164]                       else if (inherits(cond, "warning")) {
[17:48:38.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.164]                         if (muffled) 
[17:48:38.164]                           invokeRestart("muffleWarning")
[17:48:38.164]                       }
[17:48:38.164]                       else if (inherits(cond, "condition")) {
[17:48:38.164]                         if (!is.null(pattern)) {
[17:48:38.164]                           computeRestarts <- base::computeRestarts
[17:48:38.164]                           grepl <- base::grepl
[17:48:38.164]                           restarts <- computeRestarts(cond)
[17:48:38.164]                           for (restart in restarts) {
[17:48:38.164]                             name <- restart$name
[17:48:38.164]                             if (is.null(name)) 
[17:48:38.164]                               next
[17:48:38.164]                             if (!grepl(pattern, name)) 
[17:48:38.164]                               next
[17:48:38.164]                             invokeRestart(restart)
[17:48:38.164]                             muffled <- TRUE
[17:48:38.164]                             break
[17:48:38.164]                           }
[17:48:38.164]                         }
[17:48:38.164]                       }
[17:48:38.164]                       invisible(muffled)
[17:48:38.164]                     }
[17:48:38.164]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.164]                   }
[17:48:38.164]                 }
[17:48:38.164]                 else {
[17:48:38.164]                   if (TRUE) {
[17:48:38.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.164]                     {
[17:48:38.164]                       inherits <- base::inherits
[17:48:38.164]                       invokeRestart <- base::invokeRestart
[17:48:38.164]                       is.null <- base::is.null
[17:48:38.164]                       muffled <- FALSE
[17:48:38.164]                       if (inherits(cond, "message")) {
[17:48:38.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.164]                         if (muffled) 
[17:48:38.164]                           invokeRestart("muffleMessage")
[17:48:38.164]                       }
[17:48:38.164]                       else if (inherits(cond, "warning")) {
[17:48:38.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.164]                         if (muffled) 
[17:48:38.164]                           invokeRestart("muffleWarning")
[17:48:38.164]                       }
[17:48:38.164]                       else if (inherits(cond, "condition")) {
[17:48:38.164]                         if (!is.null(pattern)) {
[17:48:38.164]                           computeRestarts <- base::computeRestarts
[17:48:38.164]                           grepl <- base::grepl
[17:48:38.164]                           restarts <- computeRestarts(cond)
[17:48:38.164]                           for (restart in restarts) {
[17:48:38.164]                             name <- restart$name
[17:48:38.164]                             if (is.null(name)) 
[17:48:38.164]                               next
[17:48:38.164]                             if (!grepl(pattern, name)) 
[17:48:38.164]                               next
[17:48:38.164]                             invokeRestart(restart)
[17:48:38.164]                             muffled <- TRUE
[17:48:38.164]                             break
[17:48:38.164]                           }
[17:48:38.164]                         }
[17:48:38.164]                       }
[17:48:38.164]                       invisible(muffled)
[17:48:38.164]                     }
[17:48:38.164]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.164]                   }
[17:48:38.164]                 }
[17:48:38.164]             }
[17:48:38.164]         }))
[17:48:38.164]     }, error = function(ex) {
[17:48:38.164]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.164]                 ...future.rng), started = ...future.startTime, 
[17:48:38.164]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.164]             version = "1.8"), class = "FutureResult")
[17:48:38.164]     }, finally = {
[17:48:38.164]         if (!identical(...future.workdir, getwd())) 
[17:48:38.164]             setwd(...future.workdir)
[17:48:38.164]         {
[17:48:38.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.164]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.164]             }
[17:48:38.164]             base::options(...future.oldOptions)
[17:48:38.164]             if (.Platform$OS.type == "windows") {
[17:48:38.164]                 old_names <- names(...future.oldEnvVars)
[17:48:38.164]                 envs <- base::Sys.getenv()
[17:48:38.164]                 names <- names(envs)
[17:48:38.164]                 common <- intersect(names, old_names)
[17:48:38.164]                 added <- setdiff(names, old_names)
[17:48:38.164]                 removed <- setdiff(old_names, names)
[17:48:38.164]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.164]                   envs[common]]
[17:48:38.164]                 NAMES <- toupper(changed)
[17:48:38.164]                 args <- list()
[17:48:38.164]                 for (kk in seq_along(NAMES)) {
[17:48:38.164]                   name <- changed[[kk]]
[17:48:38.164]                   NAME <- NAMES[[kk]]
[17:48:38.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.164]                     next
[17:48:38.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.164]                 }
[17:48:38.164]                 NAMES <- toupper(added)
[17:48:38.164]                 for (kk in seq_along(NAMES)) {
[17:48:38.164]                   name <- added[[kk]]
[17:48:38.164]                   NAME <- NAMES[[kk]]
[17:48:38.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.164]                     next
[17:48:38.164]                   args[[name]] <- ""
[17:48:38.164]                 }
[17:48:38.164]                 NAMES <- toupper(removed)
[17:48:38.164]                 for (kk in seq_along(NAMES)) {
[17:48:38.164]                   name <- removed[[kk]]
[17:48:38.164]                   NAME <- NAMES[[kk]]
[17:48:38.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.164]                     next
[17:48:38.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.164]                 }
[17:48:38.164]                 if (length(args) > 0) 
[17:48:38.164]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.164]             }
[17:48:38.164]             else {
[17:48:38.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.164]             }
[17:48:38.164]             {
[17:48:38.164]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.164]                   0L) {
[17:48:38.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.164]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.164]                   base::options(opts)
[17:48:38.164]                 }
[17:48:38.164]                 {
[17:48:38.164]                   {
[17:48:38.164]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.164]                     NULL
[17:48:38.164]                   }
[17:48:38.164]                   options(future.plan = NULL)
[17:48:38.164]                   if (is.na(NA_character_)) 
[17:48:38.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.164]                     .init = FALSE)
[17:48:38.164]                 }
[17:48:38.164]             }
[17:48:38.164]         }
[17:48:38.164]     })
[17:48:38.164]     if (TRUE) {
[17:48:38.164]         base::sink(type = "output", split = FALSE)
[17:48:38.164]         if (TRUE) {
[17:48:38.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.164]         }
[17:48:38.164]         else {
[17:48:38.164]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.164]         }
[17:48:38.164]         base::close(...future.stdout)
[17:48:38.164]         ...future.stdout <- NULL
[17:48:38.164]     }
[17:48:38.164]     ...future.result$conditions <- ...future.conditions
[17:48:38.164]     ...future.result$finished <- base::Sys.time()
[17:48:38.164]     ...future.result
[17:48:38.164] }
[17:48:38.166] requestCore(): workers = 2
[17:48:38.168] MulticoreFuture started
[17:48:38.169] - Launch lazy future ... done
[17:48:38.169] run() for ‘MulticoreFuture’ ... done
[17:48:38.169] result() for MulticoreFuture ...
[17:48:38.169] plan(): Setting new future strategy stack:
[17:48:38.169] List of future strategies:
[17:48:38.169] 1. sequential:
[17:48:38.169]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.169]    - tweaked: FALSE
[17:48:38.169]    - call: NULL
[17:48:38.170] plan(): nbrOfWorkers() = 1
[17:48:38.172] plan(): Setting new future strategy stack:
[17:48:38.173] List of future strategies:
[17:48:38.173] 1. multicore:
[17:48:38.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.173]    - tweaked: FALSE
[17:48:38.173]    - call: plan(strategy)
[17:48:38.177] plan(): nbrOfWorkers() = 2
[17:48:38.178] result() for MulticoreFuture ...
[17:48:38.178] result() for MulticoreFuture ... done
[17:48:38.179] result() for MulticoreFuture ... done
[17:48:38.179] result() for MulticoreFuture ...
[17:48:38.179] result() for MulticoreFuture ... done
[17:48:38.179] result() for MulticoreFuture ...
[17:48:38.179] result() for MulticoreFuture ... done
[1] 42
[17:48:38.179] result() for MulticoreFuture ...
[17:48:38.180] result() for MulticoreFuture ... done
- stdout = FALSE
[17:48:38.180] getGlobalsAndPackages() ...
[17:48:38.180] Searching for globals...
[17:48:38.184] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.184] Searching for globals ... DONE
[17:48:38.184] Resolving globals: FALSE
[17:48:38.185] 
[17:48:38.185] - packages: [1] ‘utils’
[17:48:38.185] getGlobalsAndPackages() ... DONE
[17:48:38.185] run() for ‘Future’ ...
[17:48:38.185] - state: ‘created’
[17:48:38.186] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.190] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.190] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.190]   - Field: ‘label’
[17:48:38.190]   - Field: ‘local’
[17:48:38.190]   - Field: ‘owner’
[17:48:38.190]   - Field: ‘envir’
[17:48:38.190]   - Field: ‘workers’
[17:48:38.191]   - Field: ‘packages’
[17:48:38.191]   - Field: ‘gc’
[17:48:38.191]   - Field: ‘job’
[17:48:38.191]   - Field: ‘conditions’
[17:48:38.191]   - Field: ‘expr’
[17:48:38.191]   - Field: ‘uuid’
[17:48:38.191]   - Field: ‘seed’
[17:48:38.191]   - Field: ‘version’
[17:48:38.191]   - Field: ‘result’
[17:48:38.192]   - Field: ‘asynchronous’
[17:48:38.192]   - Field: ‘calls’
[17:48:38.192]   - Field: ‘globals’
[17:48:38.192]   - Field: ‘stdout’
[17:48:38.192]   - Field: ‘earlySignal’
[17:48:38.192]   - Field: ‘lazy’
[17:48:38.192]   - Field: ‘state’
[17:48:38.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.192] - Launch lazy future ...
[17:48:38.193] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.193] Packages needed by future strategies (n = 0): <none>
[17:48:38.194] {
[17:48:38.194]     {
[17:48:38.194]         {
[17:48:38.194]             ...future.startTime <- base::Sys.time()
[17:48:38.194]             {
[17:48:38.194]                 {
[17:48:38.194]                   {
[17:48:38.194]                     {
[17:48:38.194]                       {
[17:48:38.194]                         base::local({
[17:48:38.194]                           has_future <- base::requireNamespace("future", 
[17:48:38.194]                             quietly = TRUE)
[17:48:38.194]                           if (has_future) {
[17:48:38.194]                             ns <- base::getNamespace("future")
[17:48:38.194]                             version <- ns[[".package"]][["version"]]
[17:48:38.194]                             if (is.null(version)) 
[17:48:38.194]                               version <- utils::packageVersion("future")
[17:48:38.194]                           }
[17:48:38.194]                           else {
[17:48:38.194]                             version <- NULL
[17:48:38.194]                           }
[17:48:38.194]                           if (!has_future || version < "1.8.0") {
[17:48:38.194]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.194]                               "", base::R.version$version.string), 
[17:48:38.194]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:38.194]                                 base::R.version$platform, 8 * 
[17:48:38.194]                                   base::.Machine$sizeof.pointer), 
[17:48:38.194]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.194]                                 "release", "version")], collapse = " "), 
[17:48:38.194]                               hostname = base::Sys.info()[["nodename"]])
[17:48:38.194]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.194]                               info)
[17:48:38.194]                             info <- base::paste(info, collapse = "; ")
[17:48:38.194]                             if (!has_future) {
[17:48:38.194]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.194]                                 info)
[17:48:38.194]                             }
[17:48:38.194]                             else {
[17:48:38.194]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.194]                                 info, version)
[17:48:38.194]                             }
[17:48:38.194]                             base::stop(msg)
[17:48:38.194]                           }
[17:48:38.194]                         })
[17:48:38.194]                       }
[17:48:38.194]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.194]                       base::options(mc.cores = 1L)
[17:48:38.194]                     }
[17:48:38.194]                     base::local({
[17:48:38.194]                       for (pkg in "utils") {
[17:48:38.194]                         base::loadNamespace(pkg)
[17:48:38.194]                         base::library(pkg, character.only = TRUE)
[17:48:38.194]                       }
[17:48:38.194]                     })
[17:48:38.194]                   }
[17:48:38.194]                   ...future.strategy.old <- future::plan("list")
[17:48:38.194]                   options(future.plan = NULL)
[17:48:38.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.194]                 }
[17:48:38.194]                 ...future.workdir <- getwd()
[17:48:38.194]             }
[17:48:38.194]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.194]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.194]         }
[17:48:38.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.194]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.194]             base::names(...future.oldOptions))
[17:48:38.194]     }
[17:48:38.194]     if (FALSE) {
[17:48:38.194]     }
[17:48:38.194]     else {
[17:48:38.194]         if (FALSE) {
[17:48:38.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.194]                 open = "w")
[17:48:38.194]         }
[17:48:38.194]         else {
[17:48:38.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.194]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.194]         }
[17:48:38.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.194]             base::sink(type = "output", split = FALSE)
[17:48:38.194]             base::close(...future.stdout)
[17:48:38.194]         }, add = TRUE)
[17:48:38.194]     }
[17:48:38.194]     ...future.frame <- base::sys.nframe()
[17:48:38.194]     ...future.conditions <- base::list()
[17:48:38.194]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.194]     if (FALSE) {
[17:48:38.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.194]     }
[17:48:38.194]     ...future.result <- base::tryCatch({
[17:48:38.194]         base::withCallingHandlers({
[17:48:38.194]             ...future.value <- base::withVisible(base::local({
[17:48:38.194]                 withCallingHandlers({
[17:48:38.194]                   {
[17:48:38.194]                     print(1:50)
[17:48:38.194]                     str(1:50)
[17:48:38.194]                     cat(letters, sep = "-")
[17:48:38.194]                     cat(1:6, collapse = "\n")
[17:48:38.194]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.194]                     42L
[17:48:38.194]                   }
[17:48:38.194]                 }, immediateCondition = function(cond) {
[17:48:38.194]                   save_rds <- function (object, pathname, ...) 
[17:48:38.194]                   {
[17:48:38.194]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.194]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.194]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.194]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.194]                         fi_tmp[["mtime"]])
[17:48:38.194]                     }
[17:48:38.194]                     tryCatch({
[17:48:38.194]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.194]                     }, error = function(ex) {
[17:48:38.194]                       msg <- conditionMessage(ex)
[17:48:38.194]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.194]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.194]                         fi_tmp[["mtime"]], msg)
[17:48:38.194]                       ex$message <- msg
[17:48:38.194]                       stop(ex)
[17:48:38.194]                     })
[17:48:38.194]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.194]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.194]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.194]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.194]                       fi <- file.info(pathname)
[17:48:38.194]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.194]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.194]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.194]                         fi[["size"]], fi[["mtime"]])
[17:48:38.194]                       stop(msg)
[17:48:38.194]                     }
[17:48:38.194]                     invisible(pathname)
[17:48:38.194]                   }
[17:48:38.194]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.194]                     rootPath = tempdir()) 
[17:48:38.194]                   {
[17:48:38.194]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.194]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.194]                       tmpdir = path, fileext = ".rds")
[17:48:38.194]                     save_rds(obj, file)
[17:48:38.194]                   }
[17:48:38.194]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.194]                   {
[17:48:38.194]                     inherits <- base::inherits
[17:48:38.194]                     invokeRestart <- base::invokeRestart
[17:48:38.194]                     is.null <- base::is.null
[17:48:38.194]                     muffled <- FALSE
[17:48:38.194]                     if (inherits(cond, "message")) {
[17:48:38.194]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.194]                       if (muffled) 
[17:48:38.194]                         invokeRestart("muffleMessage")
[17:48:38.194]                     }
[17:48:38.194]                     else if (inherits(cond, "warning")) {
[17:48:38.194]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.194]                       if (muffled) 
[17:48:38.194]                         invokeRestart("muffleWarning")
[17:48:38.194]                     }
[17:48:38.194]                     else if (inherits(cond, "condition")) {
[17:48:38.194]                       if (!is.null(pattern)) {
[17:48:38.194]                         computeRestarts <- base::computeRestarts
[17:48:38.194]                         grepl <- base::grepl
[17:48:38.194]                         restarts <- computeRestarts(cond)
[17:48:38.194]                         for (restart in restarts) {
[17:48:38.194]                           name <- restart$name
[17:48:38.194]                           if (is.null(name)) 
[17:48:38.194]                             next
[17:48:38.194]                           if (!grepl(pattern, name)) 
[17:48:38.194]                             next
[17:48:38.194]                           invokeRestart(restart)
[17:48:38.194]                           muffled <- TRUE
[17:48:38.194]                           break
[17:48:38.194]                         }
[17:48:38.194]                       }
[17:48:38.194]                     }
[17:48:38.194]                     invisible(muffled)
[17:48:38.194]                   }
[17:48:38.194]                   muffleCondition(cond)
[17:48:38.194]                 })
[17:48:38.194]             }))
[17:48:38.194]             future::FutureResult(value = ...future.value$value, 
[17:48:38.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.194]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.194]                     ...future.globalenv.names))
[17:48:38.194]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.194]         }, condition = base::local({
[17:48:38.194]             c <- base::c
[17:48:38.194]             inherits <- base::inherits
[17:48:38.194]             invokeRestart <- base::invokeRestart
[17:48:38.194]             length <- base::length
[17:48:38.194]             list <- base::list
[17:48:38.194]             seq.int <- base::seq.int
[17:48:38.194]             signalCondition <- base::signalCondition
[17:48:38.194]             sys.calls <- base::sys.calls
[17:48:38.194]             `[[` <- base::`[[`
[17:48:38.194]             `+` <- base::`+`
[17:48:38.194]             `<<-` <- base::`<<-`
[17:48:38.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.194]                   3L)]
[17:48:38.194]             }
[17:48:38.194]             function(cond) {
[17:48:38.194]                 is_error <- inherits(cond, "error")
[17:48:38.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.194]                   NULL)
[17:48:38.194]                 if (is_error) {
[17:48:38.194]                   sessionInformation <- function() {
[17:48:38.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.194]                       search = base::search(), system = base::Sys.info())
[17:48:38.194]                   }
[17:48:38.194]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.194]                     cond$call), session = sessionInformation(), 
[17:48:38.194]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.194]                   signalCondition(cond)
[17:48:38.194]                 }
[17:48:38.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.194]                 "immediateCondition"))) {
[17:48:38.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.194]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.194]                   if (TRUE && !signal) {
[17:48:38.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.194]                     {
[17:48:38.194]                       inherits <- base::inherits
[17:48:38.194]                       invokeRestart <- base::invokeRestart
[17:48:38.194]                       is.null <- base::is.null
[17:48:38.194]                       muffled <- FALSE
[17:48:38.194]                       if (inherits(cond, "message")) {
[17:48:38.194]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.194]                         if (muffled) 
[17:48:38.194]                           invokeRestart("muffleMessage")
[17:48:38.194]                       }
[17:48:38.194]                       else if (inherits(cond, "warning")) {
[17:48:38.194]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.194]                         if (muffled) 
[17:48:38.194]                           invokeRestart("muffleWarning")
[17:48:38.194]                       }
[17:48:38.194]                       else if (inherits(cond, "condition")) {
[17:48:38.194]                         if (!is.null(pattern)) {
[17:48:38.194]                           computeRestarts <- base::computeRestarts
[17:48:38.194]                           grepl <- base::grepl
[17:48:38.194]                           restarts <- computeRestarts(cond)
[17:48:38.194]                           for (restart in restarts) {
[17:48:38.194]                             name <- restart$name
[17:48:38.194]                             if (is.null(name)) 
[17:48:38.194]                               next
[17:48:38.194]                             if (!grepl(pattern, name)) 
[17:48:38.194]                               next
[17:48:38.194]                             invokeRestart(restart)
[17:48:38.194]                             muffled <- TRUE
[17:48:38.194]                             break
[17:48:38.194]                           }
[17:48:38.194]                         }
[17:48:38.194]                       }
[17:48:38.194]                       invisible(muffled)
[17:48:38.194]                     }
[17:48:38.194]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.194]                   }
[17:48:38.194]                 }
[17:48:38.194]                 else {
[17:48:38.194]                   if (TRUE) {
[17:48:38.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.194]                     {
[17:48:38.194]                       inherits <- base::inherits
[17:48:38.194]                       invokeRestart <- base::invokeRestart
[17:48:38.194]                       is.null <- base::is.null
[17:48:38.194]                       muffled <- FALSE
[17:48:38.194]                       if (inherits(cond, "message")) {
[17:48:38.194]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.194]                         if (muffled) 
[17:48:38.194]                           invokeRestart("muffleMessage")
[17:48:38.194]                       }
[17:48:38.194]                       else if (inherits(cond, "warning")) {
[17:48:38.194]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.194]                         if (muffled) 
[17:48:38.194]                           invokeRestart("muffleWarning")
[17:48:38.194]                       }
[17:48:38.194]                       else if (inherits(cond, "condition")) {
[17:48:38.194]                         if (!is.null(pattern)) {
[17:48:38.194]                           computeRestarts <- base::computeRestarts
[17:48:38.194]                           grepl <- base::grepl
[17:48:38.194]                           restarts <- computeRestarts(cond)
[17:48:38.194]                           for (restart in restarts) {
[17:48:38.194]                             name <- restart$name
[17:48:38.194]                             if (is.null(name)) 
[17:48:38.194]                               next
[17:48:38.194]                             if (!grepl(pattern, name)) 
[17:48:38.194]                               next
[17:48:38.194]                             invokeRestart(restart)
[17:48:38.194]                             muffled <- TRUE
[17:48:38.194]                             break
[17:48:38.194]                           }
[17:48:38.194]                         }
[17:48:38.194]                       }
[17:48:38.194]                       invisible(muffled)
[17:48:38.194]                     }
[17:48:38.194]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.194]                   }
[17:48:38.194]                 }
[17:48:38.194]             }
[17:48:38.194]         }))
[17:48:38.194]     }, error = function(ex) {
[17:48:38.194]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.194]                 ...future.rng), started = ...future.startTime, 
[17:48:38.194]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.194]             version = "1.8"), class = "FutureResult")
[17:48:38.194]     }, finally = {
[17:48:38.194]         if (!identical(...future.workdir, getwd())) 
[17:48:38.194]             setwd(...future.workdir)
[17:48:38.194]         {
[17:48:38.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.194]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.194]             }
[17:48:38.194]             base::options(...future.oldOptions)
[17:48:38.194]             if (.Platform$OS.type == "windows") {
[17:48:38.194]                 old_names <- names(...future.oldEnvVars)
[17:48:38.194]                 envs <- base::Sys.getenv()
[17:48:38.194]                 names <- names(envs)
[17:48:38.194]                 common <- intersect(names, old_names)
[17:48:38.194]                 added <- setdiff(names, old_names)
[17:48:38.194]                 removed <- setdiff(old_names, names)
[17:48:38.194]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.194]                   envs[common]]
[17:48:38.194]                 NAMES <- toupper(changed)
[17:48:38.194]                 args <- list()
[17:48:38.194]                 for (kk in seq_along(NAMES)) {
[17:48:38.194]                   name <- changed[[kk]]
[17:48:38.194]                   NAME <- NAMES[[kk]]
[17:48:38.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.194]                     next
[17:48:38.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.194]                 }
[17:48:38.194]                 NAMES <- toupper(added)
[17:48:38.194]                 for (kk in seq_along(NAMES)) {
[17:48:38.194]                   name <- added[[kk]]
[17:48:38.194]                   NAME <- NAMES[[kk]]
[17:48:38.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.194]                     next
[17:48:38.194]                   args[[name]] <- ""
[17:48:38.194]                 }
[17:48:38.194]                 NAMES <- toupper(removed)
[17:48:38.194]                 for (kk in seq_along(NAMES)) {
[17:48:38.194]                   name <- removed[[kk]]
[17:48:38.194]                   NAME <- NAMES[[kk]]
[17:48:38.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.194]                     next
[17:48:38.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.194]                 }
[17:48:38.194]                 if (length(args) > 0) 
[17:48:38.194]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.194]             }
[17:48:38.194]             else {
[17:48:38.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.194]             }
[17:48:38.194]             {
[17:48:38.194]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.194]                   0L) {
[17:48:38.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.194]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.194]                   base::options(opts)
[17:48:38.194]                 }
[17:48:38.194]                 {
[17:48:38.194]                   {
[17:48:38.194]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.194]                     NULL
[17:48:38.194]                   }
[17:48:38.194]                   options(future.plan = NULL)
[17:48:38.194]                   if (is.na(NA_character_)) 
[17:48:38.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.194]                     .init = FALSE)
[17:48:38.194]                 }
[17:48:38.194]             }
[17:48:38.194]         }
[17:48:38.194]     })
[17:48:38.194]     if (TRUE) {
[17:48:38.194]         base::sink(type = "output", split = FALSE)
[17:48:38.194]         if (FALSE) {
[17:48:38.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.194]         }
[17:48:38.194]         else {
[17:48:38.194]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.194]         }
[17:48:38.194]         base::close(...future.stdout)
[17:48:38.194]         ...future.stdout <- NULL
[17:48:38.194]     }
[17:48:38.194]     ...future.result$conditions <- ...future.conditions
[17:48:38.194]     ...future.result$finished <- base::Sys.time()
[17:48:38.194]     ...future.result
[17:48:38.194] }
[17:48:38.196] requestCore(): workers = 2
[17:48:38.198] MulticoreFuture started
[17:48:38.198] - Launch lazy future ... done
[17:48:38.198] run() for ‘MulticoreFuture’ ... done
[17:48:38.199] result() for MulticoreFuture ...
[17:48:38.199] plan(): Setting new future strategy stack:
[17:48:38.200] List of future strategies:
[17:48:38.200] 1. sequential:
[17:48:38.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.200]    - tweaked: FALSE
[17:48:38.200]    - call: NULL
[17:48:38.201] plan(): nbrOfWorkers() = 1
[17:48:38.209] plan(): Setting new future strategy stack:
[17:48:38.209] List of future strategies:
[17:48:38.209] 1. multicore:
[17:48:38.209]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.209]    - tweaked: FALSE
[17:48:38.209]    - call: plan(strategy)
[17:48:38.214] plan(): nbrOfWorkers() = 2
[17:48:38.215] result() for MulticoreFuture ...
[17:48:38.215] result() for MulticoreFuture ... done
[17:48:38.216] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ session_uuid: chr "4c8c5ca8-9b41-5671-6d21-98a60a3c10b1"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50467
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:38"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:38.229] result() for MulticoreFuture ...
[17:48:38.229] result() for MulticoreFuture ... done
[17:48:38.229] result() for MulticoreFuture ...
[17:48:38.229] result() for MulticoreFuture ... done
[17:48:38.229] getGlobalsAndPackages() ...
[17:48:38.229] Searching for globals...
[17:48:38.233] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.233] Searching for globals ... DONE
[17:48:38.234] Resolving globals: FALSE
[17:48:38.234] 
[17:48:38.234] - packages: [1] ‘utils’
[17:48:38.234] getGlobalsAndPackages() ... DONE
[17:48:38.235] run() for ‘Future’ ...
[17:48:38.235] - state: ‘created’
[17:48:38.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.239] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.239]   - Field: ‘label’
[17:48:38.239]   - Field: ‘local’
[17:48:38.239]   - Field: ‘owner’
[17:48:38.239]   - Field: ‘envir’
[17:48:38.240]   - Field: ‘workers’
[17:48:38.240]   - Field: ‘packages’
[17:48:38.240]   - Field: ‘gc’
[17:48:38.240]   - Field: ‘job’
[17:48:38.240]   - Field: ‘conditions’
[17:48:38.240]   - Field: ‘expr’
[17:48:38.240]   - Field: ‘uuid’
[17:48:38.240]   - Field: ‘seed’
[17:48:38.240]   - Field: ‘version’
[17:48:38.240]   - Field: ‘result’
[17:48:38.241]   - Field: ‘asynchronous’
[17:48:38.241]   - Field: ‘calls’
[17:48:38.241]   - Field: ‘globals’
[17:48:38.241]   - Field: ‘stdout’
[17:48:38.241]   - Field: ‘earlySignal’
[17:48:38.241]   - Field: ‘lazy’
[17:48:38.241]   - Field: ‘state’
[17:48:38.241] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.241] - Launch lazy future ...
[17:48:38.242] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.242] Packages needed by future strategies (n = 0): <none>
[17:48:38.243] {
[17:48:38.243]     {
[17:48:38.243]         {
[17:48:38.243]             ...future.startTime <- base::Sys.time()
[17:48:38.243]             {
[17:48:38.243]                 {
[17:48:38.243]                   {
[17:48:38.243]                     {
[17:48:38.243]                       {
[17:48:38.243]                         base::local({
[17:48:38.243]                           has_future <- base::requireNamespace("future", 
[17:48:38.243]                             quietly = TRUE)
[17:48:38.243]                           if (has_future) {
[17:48:38.243]                             ns <- base::getNamespace("future")
[17:48:38.243]                             version <- ns[[".package"]][["version"]]
[17:48:38.243]                             if (is.null(version)) 
[17:48:38.243]                               version <- utils::packageVersion("future")
[17:48:38.243]                           }
[17:48:38.243]                           else {
[17:48:38.243]                             version <- NULL
[17:48:38.243]                           }
[17:48:38.243]                           if (!has_future || version < "1.8.0") {
[17:48:38.243]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.243]                               "", base::R.version$version.string), 
[17:48:38.243]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:38.243]                                 base::R.version$platform, 8 * 
[17:48:38.243]                                   base::.Machine$sizeof.pointer), 
[17:48:38.243]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.243]                                 "release", "version")], collapse = " "), 
[17:48:38.243]                               hostname = base::Sys.info()[["nodename"]])
[17:48:38.243]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.243]                               info)
[17:48:38.243]                             info <- base::paste(info, collapse = "; ")
[17:48:38.243]                             if (!has_future) {
[17:48:38.243]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.243]                                 info)
[17:48:38.243]                             }
[17:48:38.243]                             else {
[17:48:38.243]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.243]                                 info, version)
[17:48:38.243]                             }
[17:48:38.243]                             base::stop(msg)
[17:48:38.243]                           }
[17:48:38.243]                         })
[17:48:38.243]                       }
[17:48:38.243]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.243]                       base::options(mc.cores = 1L)
[17:48:38.243]                     }
[17:48:38.243]                     base::local({
[17:48:38.243]                       for (pkg in "utils") {
[17:48:38.243]                         base::loadNamespace(pkg)
[17:48:38.243]                         base::library(pkg, character.only = TRUE)
[17:48:38.243]                       }
[17:48:38.243]                     })
[17:48:38.243]                   }
[17:48:38.243]                   ...future.strategy.old <- future::plan("list")
[17:48:38.243]                   options(future.plan = NULL)
[17:48:38.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.243]                 }
[17:48:38.243]                 ...future.workdir <- getwd()
[17:48:38.243]             }
[17:48:38.243]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.243]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.243]         }
[17:48:38.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.243]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.243]             base::names(...future.oldOptions))
[17:48:38.243]     }
[17:48:38.243]     if (FALSE) {
[17:48:38.243]     }
[17:48:38.243]     else {
[17:48:38.243]         if (FALSE) {
[17:48:38.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.243]                 open = "w")
[17:48:38.243]         }
[17:48:38.243]         else {
[17:48:38.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.243]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.243]         }
[17:48:38.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.243]             base::sink(type = "output", split = FALSE)
[17:48:38.243]             base::close(...future.stdout)
[17:48:38.243]         }, add = TRUE)
[17:48:38.243]     }
[17:48:38.243]     ...future.frame <- base::sys.nframe()
[17:48:38.243]     ...future.conditions <- base::list()
[17:48:38.243]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.243]     if (FALSE) {
[17:48:38.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.243]     }
[17:48:38.243]     ...future.result <- base::tryCatch({
[17:48:38.243]         base::withCallingHandlers({
[17:48:38.243]             ...future.value <- base::withVisible(base::local({
[17:48:38.243]                 withCallingHandlers({
[17:48:38.243]                   {
[17:48:38.243]                     print(1:50)
[17:48:38.243]                     str(1:50)
[17:48:38.243]                     cat(letters, sep = "-")
[17:48:38.243]                     cat(1:6, collapse = "\n")
[17:48:38.243]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.243]                     42L
[17:48:38.243]                   }
[17:48:38.243]                 }, immediateCondition = function(cond) {
[17:48:38.243]                   save_rds <- function (object, pathname, ...) 
[17:48:38.243]                   {
[17:48:38.243]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.243]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.243]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.243]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.243]                         fi_tmp[["mtime"]])
[17:48:38.243]                     }
[17:48:38.243]                     tryCatch({
[17:48:38.243]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.243]                     }, error = function(ex) {
[17:48:38.243]                       msg <- conditionMessage(ex)
[17:48:38.243]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.243]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.243]                         fi_tmp[["mtime"]], msg)
[17:48:38.243]                       ex$message <- msg
[17:48:38.243]                       stop(ex)
[17:48:38.243]                     })
[17:48:38.243]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.243]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.243]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.243]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.243]                       fi <- file.info(pathname)
[17:48:38.243]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.243]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.243]                         fi[["size"]], fi[["mtime"]])
[17:48:38.243]                       stop(msg)
[17:48:38.243]                     }
[17:48:38.243]                     invisible(pathname)
[17:48:38.243]                   }
[17:48:38.243]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.243]                     rootPath = tempdir()) 
[17:48:38.243]                   {
[17:48:38.243]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.243]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.243]                       tmpdir = path, fileext = ".rds")
[17:48:38.243]                     save_rds(obj, file)
[17:48:38.243]                   }
[17:48:38.243]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.243]                   {
[17:48:38.243]                     inherits <- base::inherits
[17:48:38.243]                     invokeRestart <- base::invokeRestart
[17:48:38.243]                     is.null <- base::is.null
[17:48:38.243]                     muffled <- FALSE
[17:48:38.243]                     if (inherits(cond, "message")) {
[17:48:38.243]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.243]                       if (muffled) 
[17:48:38.243]                         invokeRestart("muffleMessage")
[17:48:38.243]                     }
[17:48:38.243]                     else if (inherits(cond, "warning")) {
[17:48:38.243]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.243]                       if (muffled) 
[17:48:38.243]                         invokeRestart("muffleWarning")
[17:48:38.243]                     }
[17:48:38.243]                     else if (inherits(cond, "condition")) {
[17:48:38.243]                       if (!is.null(pattern)) {
[17:48:38.243]                         computeRestarts <- base::computeRestarts
[17:48:38.243]                         grepl <- base::grepl
[17:48:38.243]                         restarts <- computeRestarts(cond)
[17:48:38.243]                         for (restart in restarts) {
[17:48:38.243]                           name <- restart$name
[17:48:38.243]                           if (is.null(name)) 
[17:48:38.243]                             next
[17:48:38.243]                           if (!grepl(pattern, name)) 
[17:48:38.243]                             next
[17:48:38.243]                           invokeRestart(restart)
[17:48:38.243]                           muffled <- TRUE
[17:48:38.243]                           break
[17:48:38.243]                         }
[17:48:38.243]                       }
[17:48:38.243]                     }
[17:48:38.243]                     invisible(muffled)
[17:48:38.243]                   }
[17:48:38.243]                   muffleCondition(cond)
[17:48:38.243]                 })
[17:48:38.243]             }))
[17:48:38.243]             future::FutureResult(value = ...future.value$value, 
[17:48:38.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.243]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.243]                     ...future.globalenv.names))
[17:48:38.243]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.243]         }, condition = base::local({
[17:48:38.243]             c <- base::c
[17:48:38.243]             inherits <- base::inherits
[17:48:38.243]             invokeRestart <- base::invokeRestart
[17:48:38.243]             length <- base::length
[17:48:38.243]             list <- base::list
[17:48:38.243]             seq.int <- base::seq.int
[17:48:38.243]             signalCondition <- base::signalCondition
[17:48:38.243]             sys.calls <- base::sys.calls
[17:48:38.243]             `[[` <- base::`[[`
[17:48:38.243]             `+` <- base::`+`
[17:48:38.243]             `<<-` <- base::`<<-`
[17:48:38.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.243]                   3L)]
[17:48:38.243]             }
[17:48:38.243]             function(cond) {
[17:48:38.243]                 is_error <- inherits(cond, "error")
[17:48:38.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.243]                   NULL)
[17:48:38.243]                 if (is_error) {
[17:48:38.243]                   sessionInformation <- function() {
[17:48:38.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.243]                       search = base::search(), system = base::Sys.info())
[17:48:38.243]                   }
[17:48:38.243]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.243]                     cond$call), session = sessionInformation(), 
[17:48:38.243]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.243]                   signalCondition(cond)
[17:48:38.243]                 }
[17:48:38.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.243]                 "immediateCondition"))) {
[17:48:38.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.243]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.243]                   if (TRUE && !signal) {
[17:48:38.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.243]                     {
[17:48:38.243]                       inherits <- base::inherits
[17:48:38.243]                       invokeRestart <- base::invokeRestart
[17:48:38.243]                       is.null <- base::is.null
[17:48:38.243]                       muffled <- FALSE
[17:48:38.243]                       if (inherits(cond, "message")) {
[17:48:38.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.243]                         if (muffled) 
[17:48:38.243]                           invokeRestart("muffleMessage")
[17:48:38.243]                       }
[17:48:38.243]                       else if (inherits(cond, "warning")) {
[17:48:38.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.243]                         if (muffled) 
[17:48:38.243]                           invokeRestart("muffleWarning")
[17:48:38.243]                       }
[17:48:38.243]                       else if (inherits(cond, "condition")) {
[17:48:38.243]                         if (!is.null(pattern)) {
[17:48:38.243]                           computeRestarts <- base::computeRestarts
[17:48:38.243]                           grepl <- base::grepl
[17:48:38.243]                           restarts <- computeRestarts(cond)
[17:48:38.243]                           for (restart in restarts) {
[17:48:38.243]                             name <- restart$name
[17:48:38.243]                             if (is.null(name)) 
[17:48:38.243]                               next
[17:48:38.243]                             if (!grepl(pattern, name)) 
[17:48:38.243]                               next
[17:48:38.243]                             invokeRestart(restart)
[17:48:38.243]                             muffled <- TRUE
[17:48:38.243]                             break
[17:48:38.243]                           }
[17:48:38.243]                         }
[17:48:38.243]                       }
[17:48:38.243]                       invisible(muffled)
[17:48:38.243]                     }
[17:48:38.243]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.243]                   }
[17:48:38.243]                 }
[17:48:38.243]                 else {
[17:48:38.243]                   if (TRUE) {
[17:48:38.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.243]                     {
[17:48:38.243]                       inherits <- base::inherits
[17:48:38.243]                       invokeRestart <- base::invokeRestart
[17:48:38.243]                       is.null <- base::is.null
[17:48:38.243]                       muffled <- FALSE
[17:48:38.243]                       if (inherits(cond, "message")) {
[17:48:38.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.243]                         if (muffled) 
[17:48:38.243]                           invokeRestart("muffleMessage")
[17:48:38.243]                       }
[17:48:38.243]                       else if (inherits(cond, "warning")) {
[17:48:38.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.243]                         if (muffled) 
[17:48:38.243]                           invokeRestart("muffleWarning")
[17:48:38.243]                       }
[17:48:38.243]                       else if (inherits(cond, "condition")) {
[17:48:38.243]                         if (!is.null(pattern)) {
[17:48:38.243]                           computeRestarts <- base::computeRestarts
[17:48:38.243]                           grepl <- base::grepl
[17:48:38.243]                           restarts <- computeRestarts(cond)
[17:48:38.243]                           for (restart in restarts) {
[17:48:38.243]                             name <- restart$name
[17:48:38.243]                             if (is.null(name)) 
[17:48:38.243]                               next
[17:48:38.243]                             if (!grepl(pattern, name)) 
[17:48:38.243]                               next
[17:48:38.243]                             invokeRestart(restart)
[17:48:38.243]                             muffled <- TRUE
[17:48:38.243]                             break
[17:48:38.243]                           }
[17:48:38.243]                         }
[17:48:38.243]                       }
[17:48:38.243]                       invisible(muffled)
[17:48:38.243]                     }
[17:48:38.243]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.243]                   }
[17:48:38.243]                 }
[17:48:38.243]             }
[17:48:38.243]         }))
[17:48:38.243]     }, error = function(ex) {
[17:48:38.243]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.243]                 ...future.rng), started = ...future.startTime, 
[17:48:38.243]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.243]             version = "1.8"), class = "FutureResult")
[17:48:38.243]     }, finally = {
[17:48:38.243]         if (!identical(...future.workdir, getwd())) 
[17:48:38.243]             setwd(...future.workdir)
[17:48:38.243]         {
[17:48:38.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.243]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.243]             }
[17:48:38.243]             base::options(...future.oldOptions)
[17:48:38.243]             if (.Platform$OS.type == "windows") {
[17:48:38.243]                 old_names <- names(...future.oldEnvVars)
[17:48:38.243]                 envs <- base::Sys.getenv()
[17:48:38.243]                 names <- names(envs)
[17:48:38.243]                 common <- intersect(names, old_names)
[17:48:38.243]                 added <- setdiff(names, old_names)
[17:48:38.243]                 removed <- setdiff(old_names, names)
[17:48:38.243]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.243]                   envs[common]]
[17:48:38.243]                 NAMES <- toupper(changed)
[17:48:38.243]                 args <- list()
[17:48:38.243]                 for (kk in seq_along(NAMES)) {
[17:48:38.243]                   name <- changed[[kk]]
[17:48:38.243]                   NAME <- NAMES[[kk]]
[17:48:38.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.243]                     next
[17:48:38.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.243]                 }
[17:48:38.243]                 NAMES <- toupper(added)
[17:48:38.243]                 for (kk in seq_along(NAMES)) {
[17:48:38.243]                   name <- added[[kk]]
[17:48:38.243]                   NAME <- NAMES[[kk]]
[17:48:38.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.243]                     next
[17:48:38.243]                   args[[name]] <- ""
[17:48:38.243]                 }
[17:48:38.243]                 NAMES <- toupper(removed)
[17:48:38.243]                 for (kk in seq_along(NAMES)) {
[17:48:38.243]                   name <- removed[[kk]]
[17:48:38.243]                   NAME <- NAMES[[kk]]
[17:48:38.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.243]                     next
[17:48:38.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.243]                 }
[17:48:38.243]                 if (length(args) > 0) 
[17:48:38.243]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.243]             }
[17:48:38.243]             else {
[17:48:38.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.243]             }
[17:48:38.243]             {
[17:48:38.243]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.243]                   0L) {
[17:48:38.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.243]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.243]                   base::options(opts)
[17:48:38.243]                 }
[17:48:38.243]                 {
[17:48:38.243]                   {
[17:48:38.243]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.243]                     NULL
[17:48:38.243]                   }
[17:48:38.243]                   options(future.plan = NULL)
[17:48:38.243]                   if (is.na(NA_character_)) 
[17:48:38.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.243]                     .init = FALSE)
[17:48:38.243]                 }
[17:48:38.243]             }
[17:48:38.243]         }
[17:48:38.243]     })
[17:48:38.243]     if (TRUE) {
[17:48:38.243]         base::sink(type = "output", split = FALSE)
[17:48:38.243]         if (FALSE) {
[17:48:38.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.243]         }
[17:48:38.243]         else {
[17:48:38.243]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.243]         }
[17:48:38.243]         base::close(...future.stdout)
[17:48:38.243]         ...future.stdout <- NULL
[17:48:38.243]     }
[17:48:38.243]     ...future.result$conditions <- ...future.conditions
[17:48:38.243]     ...future.result$finished <- base::Sys.time()
[17:48:38.243]     ...future.result
[17:48:38.243] }
[17:48:38.245] requestCore(): workers = 2
[17:48:38.247] MulticoreFuture started
[17:48:38.247] - Launch lazy future ... done
[17:48:38.247] run() for ‘MulticoreFuture’ ... done
[17:48:38.248] result() for MulticoreFuture ...
[17:48:38.248] plan(): Setting new future strategy stack:
[17:48:38.248] List of future strategies:
[17:48:38.248] 1. sequential:
[17:48:38.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.248]    - tweaked: FALSE
[17:48:38.248]    - call: NULL
[17:48:38.249] plan(): nbrOfWorkers() = 1
[17:48:38.253] plan(): Setting new future strategy stack:
[17:48:38.253] List of future strategies:
[17:48:38.253] 1. multicore:
[17:48:38.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.253]    - tweaked: FALSE
[17:48:38.253]    - call: plan(strategy)
[17:48:38.258] plan(): nbrOfWorkers() = 2
[17:48:38.259] result() for MulticoreFuture ...
[17:48:38.259] result() for MulticoreFuture ... done
[17:48:38.259] result() for MulticoreFuture ... done
[17:48:38.259] result() for MulticoreFuture ...
[17:48:38.259] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:48:38.260] getGlobalsAndPackages() ...
[17:48:38.260] Searching for globals...
[17:48:38.261] - globals found: [1] ‘print’
[17:48:38.261] Searching for globals ... DONE
[17:48:38.261] Resolving globals: FALSE
[17:48:38.261] 
[17:48:38.261] 
[17:48:38.261] getGlobalsAndPackages() ... DONE
[17:48:38.262] run() for ‘Future’ ...
[17:48:38.262] - state: ‘created’
[17:48:38.262] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.266] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.266]   - Field: ‘label’
[17:48:38.266]   - Field: ‘local’
[17:48:38.267]   - Field: ‘owner’
[17:48:38.267]   - Field: ‘envir’
[17:48:38.267]   - Field: ‘workers’
[17:48:38.267]   - Field: ‘packages’
[17:48:38.267]   - Field: ‘gc’
[17:48:38.267]   - Field: ‘job’
[17:48:38.267]   - Field: ‘conditions’
[17:48:38.267]   - Field: ‘expr’
[17:48:38.268]   - Field: ‘uuid’
[17:48:38.268]   - Field: ‘seed’
[17:48:38.268]   - Field: ‘version’
[17:48:38.268]   - Field: ‘result’
[17:48:38.268]   - Field: ‘asynchronous’
[17:48:38.268]   - Field: ‘calls’
[17:48:38.270]   - Field: ‘globals’
[17:48:38.271]   - Field: ‘stdout’
[17:48:38.271]   - Field: ‘earlySignal’
[17:48:38.271]   - Field: ‘lazy’
[17:48:38.271]   - Field: ‘state’
[17:48:38.271] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.271] - Launch lazy future ...
[17:48:38.272] Packages needed by the future expression (n = 0): <none>
[17:48:38.272] Packages needed by future strategies (n = 0): <none>
[17:48:38.272] {
[17:48:38.272]     {
[17:48:38.272]         {
[17:48:38.272]             ...future.startTime <- base::Sys.time()
[17:48:38.272]             {
[17:48:38.272]                 {
[17:48:38.272]                   {
[17:48:38.272]                     {
[17:48:38.272]                       base::local({
[17:48:38.272]                         has_future <- base::requireNamespace("future", 
[17:48:38.272]                           quietly = TRUE)
[17:48:38.272]                         if (has_future) {
[17:48:38.272]                           ns <- base::getNamespace("future")
[17:48:38.272]                           version <- ns[[".package"]][["version"]]
[17:48:38.272]                           if (is.null(version)) 
[17:48:38.272]                             version <- utils::packageVersion("future")
[17:48:38.272]                         }
[17:48:38.272]                         else {
[17:48:38.272]                           version <- NULL
[17:48:38.272]                         }
[17:48:38.272]                         if (!has_future || version < "1.8.0") {
[17:48:38.272]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.272]                             "", base::R.version$version.string), 
[17:48:38.272]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:38.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.272]                               "release", "version")], collapse = " "), 
[17:48:38.272]                             hostname = base::Sys.info()[["nodename"]])
[17:48:38.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.272]                             info)
[17:48:38.272]                           info <- base::paste(info, collapse = "; ")
[17:48:38.272]                           if (!has_future) {
[17:48:38.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.272]                               info)
[17:48:38.272]                           }
[17:48:38.272]                           else {
[17:48:38.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.272]                               info, version)
[17:48:38.272]                           }
[17:48:38.272]                           base::stop(msg)
[17:48:38.272]                         }
[17:48:38.272]                       })
[17:48:38.272]                     }
[17:48:38.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.272]                     base::options(mc.cores = 1L)
[17:48:38.272]                   }
[17:48:38.272]                   ...future.strategy.old <- future::plan("list")
[17:48:38.272]                   options(future.plan = NULL)
[17:48:38.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.272]                 }
[17:48:38.272]                 ...future.workdir <- getwd()
[17:48:38.272]             }
[17:48:38.272]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.272]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.272]         }
[17:48:38.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.272]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.272]             base::names(...future.oldOptions))
[17:48:38.272]     }
[17:48:38.272]     if (FALSE) {
[17:48:38.272]     }
[17:48:38.272]     else {
[17:48:38.272]         if (TRUE) {
[17:48:38.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.272]                 open = "w")
[17:48:38.272]         }
[17:48:38.272]         else {
[17:48:38.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.272]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.272]         }
[17:48:38.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.272]             base::sink(type = "output", split = FALSE)
[17:48:38.272]             base::close(...future.stdout)
[17:48:38.272]         }, add = TRUE)
[17:48:38.272]     }
[17:48:38.272]     ...future.frame <- base::sys.nframe()
[17:48:38.272]     ...future.conditions <- base::list()
[17:48:38.272]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.272]     if (FALSE) {
[17:48:38.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.272]     }
[17:48:38.272]     ...future.result <- base::tryCatch({
[17:48:38.272]         base::withCallingHandlers({
[17:48:38.272]             ...future.value <- base::withVisible(base::local({
[17:48:38.272]                 withCallingHandlers({
[17:48:38.272]                   print(42)
[17:48:38.272]                 }, immediateCondition = function(cond) {
[17:48:38.272]                   save_rds <- function (object, pathname, ...) 
[17:48:38.272]                   {
[17:48:38.272]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.272]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.272]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.272]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.272]                         fi_tmp[["mtime"]])
[17:48:38.272]                     }
[17:48:38.272]                     tryCatch({
[17:48:38.272]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.272]                     }, error = function(ex) {
[17:48:38.272]                       msg <- conditionMessage(ex)
[17:48:38.272]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.272]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.272]                         fi_tmp[["mtime"]], msg)
[17:48:38.272]                       ex$message <- msg
[17:48:38.272]                       stop(ex)
[17:48:38.272]                     })
[17:48:38.272]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.272]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.272]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.272]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.272]                       fi <- file.info(pathname)
[17:48:38.272]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.272]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.272]                         fi[["size"]], fi[["mtime"]])
[17:48:38.272]                       stop(msg)
[17:48:38.272]                     }
[17:48:38.272]                     invisible(pathname)
[17:48:38.272]                   }
[17:48:38.272]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.272]                     rootPath = tempdir()) 
[17:48:38.272]                   {
[17:48:38.272]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.272]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.272]                       tmpdir = path, fileext = ".rds")
[17:48:38.272]                     save_rds(obj, file)
[17:48:38.272]                   }
[17:48:38.272]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.272]                   {
[17:48:38.272]                     inherits <- base::inherits
[17:48:38.272]                     invokeRestart <- base::invokeRestart
[17:48:38.272]                     is.null <- base::is.null
[17:48:38.272]                     muffled <- FALSE
[17:48:38.272]                     if (inherits(cond, "message")) {
[17:48:38.272]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.272]                       if (muffled) 
[17:48:38.272]                         invokeRestart("muffleMessage")
[17:48:38.272]                     }
[17:48:38.272]                     else if (inherits(cond, "warning")) {
[17:48:38.272]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.272]                       if (muffled) 
[17:48:38.272]                         invokeRestart("muffleWarning")
[17:48:38.272]                     }
[17:48:38.272]                     else if (inherits(cond, "condition")) {
[17:48:38.272]                       if (!is.null(pattern)) {
[17:48:38.272]                         computeRestarts <- base::computeRestarts
[17:48:38.272]                         grepl <- base::grepl
[17:48:38.272]                         restarts <- computeRestarts(cond)
[17:48:38.272]                         for (restart in restarts) {
[17:48:38.272]                           name <- restart$name
[17:48:38.272]                           if (is.null(name)) 
[17:48:38.272]                             next
[17:48:38.272]                           if (!grepl(pattern, name)) 
[17:48:38.272]                             next
[17:48:38.272]                           invokeRestart(restart)
[17:48:38.272]                           muffled <- TRUE
[17:48:38.272]                           break
[17:48:38.272]                         }
[17:48:38.272]                       }
[17:48:38.272]                     }
[17:48:38.272]                     invisible(muffled)
[17:48:38.272]                   }
[17:48:38.272]                   muffleCondition(cond)
[17:48:38.272]                 })
[17:48:38.272]             }))
[17:48:38.272]             future::FutureResult(value = ...future.value$value, 
[17:48:38.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.272]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.272]                     ...future.globalenv.names))
[17:48:38.272]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.272]         }, condition = base::local({
[17:48:38.272]             c <- base::c
[17:48:38.272]             inherits <- base::inherits
[17:48:38.272]             invokeRestart <- base::invokeRestart
[17:48:38.272]             length <- base::length
[17:48:38.272]             list <- base::list
[17:48:38.272]             seq.int <- base::seq.int
[17:48:38.272]             signalCondition <- base::signalCondition
[17:48:38.272]             sys.calls <- base::sys.calls
[17:48:38.272]             `[[` <- base::`[[`
[17:48:38.272]             `+` <- base::`+`
[17:48:38.272]             `<<-` <- base::`<<-`
[17:48:38.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.272]                   3L)]
[17:48:38.272]             }
[17:48:38.272]             function(cond) {
[17:48:38.272]                 is_error <- inherits(cond, "error")
[17:48:38.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.272]                   NULL)
[17:48:38.272]                 if (is_error) {
[17:48:38.272]                   sessionInformation <- function() {
[17:48:38.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.272]                       search = base::search(), system = base::Sys.info())
[17:48:38.272]                   }
[17:48:38.272]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.272]                     cond$call), session = sessionInformation(), 
[17:48:38.272]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.272]                   signalCondition(cond)
[17:48:38.272]                 }
[17:48:38.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.272]                 "immediateCondition"))) {
[17:48:38.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.272]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.272]                   if (TRUE && !signal) {
[17:48:38.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.272]                     {
[17:48:38.272]                       inherits <- base::inherits
[17:48:38.272]                       invokeRestart <- base::invokeRestart
[17:48:38.272]                       is.null <- base::is.null
[17:48:38.272]                       muffled <- FALSE
[17:48:38.272]                       if (inherits(cond, "message")) {
[17:48:38.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.272]                         if (muffled) 
[17:48:38.272]                           invokeRestart("muffleMessage")
[17:48:38.272]                       }
[17:48:38.272]                       else if (inherits(cond, "warning")) {
[17:48:38.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.272]                         if (muffled) 
[17:48:38.272]                           invokeRestart("muffleWarning")
[17:48:38.272]                       }
[17:48:38.272]                       else if (inherits(cond, "condition")) {
[17:48:38.272]                         if (!is.null(pattern)) {
[17:48:38.272]                           computeRestarts <- base::computeRestarts
[17:48:38.272]                           grepl <- base::grepl
[17:48:38.272]                           restarts <- computeRestarts(cond)
[17:48:38.272]                           for (restart in restarts) {
[17:48:38.272]                             name <- restart$name
[17:48:38.272]                             if (is.null(name)) 
[17:48:38.272]                               next
[17:48:38.272]                             if (!grepl(pattern, name)) 
[17:48:38.272]                               next
[17:48:38.272]                             invokeRestart(restart)
[17:48:38.272]                             muffled <- TRUE
[17:48:38.272]                             break
[17:48:38.272]                           }
[17:48:38.272]                         }
[17:48:38.272]                       }
[17:48:38.272]                       invisible(muffled)
[17:48:38.272]                     }
[17:48:38.272]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.272]                   }
[17:48:38.272]                 }
[17:48:38.272]                 else {
[17:48:38.272]                   if (TRUE) {
[17:48:38.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.272]                     {
[17:48:38.272]                       inherits <- base::inherits
[17:48:38.272]                       invokeRestart <- base::invokeRestart
[17:48:38.272]                       is.null <- base::is.null
[17:48:38.272]                       muffled <- FALSE
[17:48:38.272]                       if (inherits(cond, "message")) {
[17:48:38.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.272]                         if (muffled) 
[17:48:38.272]                           invokeRestart("muffleMessage")
[17:48:38.272]                       }
[17:48:38.272]                       else if (inherits(cond, "warning")) {
[17:48:38.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.272]                         if (muffled) 
[17:48:38.272]                           invokeRestart("muffleWarning")
[17:48:38.272]                       }
[17:48:38.272]                       else if (inherits(cond, "condition")) {
[17:48:38.272]                         if (!is.null(pattern)) {
[17:48:38.272]                           computeRestarts <- base::computeRestarts
[17:48:38.272]                           grepl <- base::grepl
[17:48:38.272]                           restarts <- computeRestarts(cond)
[17:48:38.272]                           for (restart in restarts) {
[17:48:38.272]                             name <- restart$name
[17:48:38.272]                             if (is.null(name)) 
[17:48:38.272]                               next
[17:48:38.272]                             if (!grepl(pattern, name)) 
[17:48:38.272]                               next
[17:48:38.272]                             invokeRestart(restart)
[17:48:38.272]                             muffled <- TRUE
[17:48:38.272]                             break
[17:48:38.272]                           }
[17:48:38.272]                         }
[17:48:38.272]                       }
[17:48:38.272]                       invisible(muffled)
[17:48:38.272]                     }
[17:48:38.272]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.272]                   }
[17:48:38.272]                 }
[17:48:38.272]             }
[17:48:38.272]         }))
[17:48:38.272]     }, error = function(ex) {
[17:48:38.272]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.272]                 ...future.rng), started = ...future.startTime, 
[17:48:38.272]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.272]             version = "1.8"), class = "FutureResult")
[17:48:38.272]     }, finally = {
[17:48:38.272]         if (!identical(...future.workdir, getwd())) 
[17:48:38.272]             setwd(...future.workdir)
[17:48:38.272]         {
[17:48:38.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.272]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.272]             }
[17:48:38.272]             base::options(...future.oldOptions)
[17:48:38.272]             if (.Platform$OS.type == "windows") {
[17:48:38.272]                 old_names <- names(...future.oldEnvVars)
[17:48:38.272]                 envs <- base::Sys.getenv()
[17:48:38.272]                 names <- names(envs)
[17:48:38.272]                 common <- intersect(names, old_names)
[17:48:38.272]                 added <- setdiff(names, old_names)
[17:48:38.272]                 removed <- setdiff(old_names, names)
[17:48:38.272]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.272]                   envs[common]]
[17:48:38.272]                 NAMES <- toupper(changed)
[17:48:38.272]                 args <- list()
[17:48:38.272]                 for (kk in seq_along(NAMES)) {
[17:48:38.272]                   name <- changed[[kk]]
[17:48:38.272]                   NAME <- NAMES[[kk]]
[17:48:38.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.272]                     next
[17:48:38.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.272]                 }
[17:48:38.272]                 NAMES <- toupper(added)
[17:48:38.272]                 for (kk in seq_along(NAMES)) {
[17:48:38.272]                   name <- added[[kk]]
[17:48:38.272]                   NAME <- NAMES[[kk]]
[17:48:38.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.272]                     next
[17:48:38.272]                   args[[name]] <- ""
[17:48:38.272]                 }
[17:48:38.272]                 NAMES <- toupper(removed)
[17:48:38.272]                 for (kk in seq_along(NAMES)) {
[17:48:38.272]                   name <- removed[[kk]]
[17:48:38.272]                   NAME <- NAMES[[kk]]
[17:48:38.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.272]                     next
[17:48:38.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.272]                 }
[17:48:38.272]                 if (length(args) > 0) 
[17:48:38.272]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.272]             }
[17:48:38.272]             else {
[17:48:38.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.272]             }
[17:48:38.272]             {
[17:48:38.272]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.272]                   0L) {
[17:48:38.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.272]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.272]                   base::options(opts)
[17:48:38.272]                 }
[17:48:38.272]                 {
[17:48:38.272]                   {
[17:48:38.272]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.272]                     NULL
[17:48:38.272]                   }
[17:48:38.272]                   options(future.plan = NULL)
[17:48:38.272]                   if (is.na(NA_character_)) 
[17:48:38.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.272]                     .init = FALSE)
[17:48:38.272]                 }
[17:48:38.272]             }
[17:48:38.272]         }
[17:48:38.272]     })
[17:48:38.272]     if (TRUE) {
[17:48:38.272]         base::sink(type = "output", split = FALSE)
[17:48:38.272]         if (TRUE) {
[17:48:38.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.272]         }
[17:48:38.272]         else {
[17:48:38.272]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.272]         }
[17:48:38.272]         base::close(...future.stdout)
[17:48:38.272]         ...future.stdout <- NULL
[17:48:38.272]     }
[17:48:38.272]     ...future.result$conditions <- ...future.conditions
[17:48:38.272]     ...future.result$finished <- base::Sys.time()
[17:48:38.272]     ...future.result
[17:48:38.272] }
[17:48:38.275] requestCore(): workers = 2
[17:48:38.276] MulticoreFuture started
[17:48:38.277] - Launch lazy future ... done
[17:48:38.277] run() for ‘MulticoreFuture’ ... done
[17:48:38.277] result() for MulticoreFuture ...
[17:48:38.277] plan(): Setting new future strategy stack:
[17:48:38.278] List of future strategies:
[17:48:38.278] 1. sequential:
[17:48:38.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.278]    - tweaked: FALSE
[17:48:38.278]    - call: NULL
[17:48:38.279] plan(): nbrOfWorkers() = 1
[17:48:38.281] plan(): Setting new future strategy stack:
[17:48:38.281] List of future strategies:
[17:48:38.281] 1. multicore:
[17:48:38.281]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.281]    - tweaked: FALSE
[17:48:38.281]    - call: plan(strategy)
[17:48:38.286] plan(): nbrOfWorkers() = 2
[17:48:38.287] result() for MulticoreFuture ...
[17:48:38.287] result() for MulticoreFuture ... done
[17:48:38.287] result() for MulticoreFuture ... done
[17:48:38.288] result() for MulticoreFuture ...
[17:48:38.288] result() for MulticoreFuture ... done
[17:48:38.288] result() for MulticoreFuture ...
[17:48:38.288] result() for MulticoreFuture ... done
[1] 42
[17:48:38.288] result() for MulticoreFuture ...
[17:48:38.288] result() for MulticoreFuture ... done
- stdout = NA
[17:48:38.288] getGlobalsAndPackages() ...
[17:48:38.289] Searching for globals...
[17:48:38.293] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.293] Searching for globals ... DONE
[17:48:38.293] Resolving globals: FALSE
[17:48:38.293] 
[17:48:38.294] - packages: [1] ‘utils’
[17:48:38.294] getGlobalsAndPackages() ... DONE
[17:48:38.294] run() for ‘Future’ ...
[17:48:38.294] - state: ‘created’
[17:48:38.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.298] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.299]   - Field: ‘label’
[17:48:38.299]   - Field: ‘local’
[17:48:38.299]   - Field: ‘owner’
[17:48:38.299]   - Field: ‘envir’
[17:48:38.299]   - Field: ‘workers’
[17:48:38.299]   - Field: ‘packages’
[17:48:38.299]   - Field: ‘gc’
[17:48:38.300]   - Field: ‘job’
[17:48:38.300]   - Field: ‘conditions’
[17:48:38.300]   - Field: ‘expr’
[17:48:38.300]   - Field: ‘uuid’
[17:48:38.300]   - Field: ‘seed’
[17:48:38.300]   - Field: ‘version’
[17:48:38.300]   - Field: ‘result’
[17:48:38.300]   - Field: ‘asynchronous’
[17:48:38.300]   - Field: ‘calls’
[17:48:38.301]   - Field: ‘globals’
[17:48:38.301]   - Field: ‘stdout’
[17:48:38.301]   - Field: ‘earlySignal’
[17:48:38.301]   - Field: ‘lazy’
[17:48:38.301]   - Field: ‘state’
[17:48:38.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.301] - Launch lazy future ...
[17:48:38.301] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.302] Packages needed by future strategies (n = 0): <none>
[17:48:38.302] {
[17:48:38.302]     {
[17:48:38.302]         {
[17:48:38.302]             ...future.startTime <- base::Sys.time()
[17:48:38.302]             {
[17:48:38.302]                 {
[17:48:38.302]                   {
[17:48:38.302]                     {
[17:48:38.302]                       {
[17:48:38.302]                         base::local({
[17:48:38.302]                           has_future <- base::requireNamespace("future", 
[17:48:38.302]                             quietly = TRUE)
[17:48:38.302]                           if (has_future) {
[17:48:38.302]                             ns <- base::getNamespace("future")
[17:48:38.302]                             version <- ns[[".package"]][["version"]]
[17:48:38.302]                             if (is.null(version)) 
[17:48:38.302]                               version <- utils::packageVersion("future")
[17:48:38.302]                           }
[17:48:38.302]                           else {
[17:48:38.302]                             version <- NULL
[17:48:38.302]                           }
[17:48:38.302]                           if (!has_future || version < "1.8.0") {
[17:48:38.302]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.302]                               "", base::R.version$version.string), 
[17:48:38.302]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:38.302]                                 base::R.version$platform, 8 * 
[17:48:38.302]                                   base::.Machine$sizeof.pointer), 
[17:48:38.302]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.302]                                 "release", "version")], collapse = " "), 
[17:48:38.302]                               hostname = base::Sys.info()[["nodename"]])
[17:48:38.302]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.302]                               info)
[17:48:38.302]                             info <- base::paste(info, collapse = "; ")
[17:48:38.302]                             if (!has_future) {
[17:48:38.302]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.302]                                 info)
[17:48:38.302]                             }
[17:48:38.302]                             else {
[17:48:38.302]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.302]                                 info, version)
[17:48:38.302]                             }
[17:48:38.302]                             base::stop(msg)
[17:48:38.302]                           }
[17:48:38.302]                         })
[17:48:38.302]                       }
[17:48:38.302]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.302]                       base::options(mc.cores = 1L)
[17:48:38.302]                     }
[17:48:38.302]                     base::local({
[17:48:38.302]                       for (pkg in "utils") {
[17:48:38.302]                         base::loadNamespace(pkg)
[17:48:38.302]                         base::library(pkg, character.only = TRUE)
[17:48:38.302]                       }
[17:48:38.302]                     })
[17:48:38.302]                   }
[17:48:38.302]                   ...future.strategy.old <- future::plan("list")
[17:48:38.302]                   options(future.plan = NULL)
[17:48:38.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.302]                 }
[17:48:38.302]                 ...future.workdir <- getwd()
[17:48:38.302]             }
[17:48:38.302]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.302]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.302]         }
[17:48:38.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.302]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.302]             base::names(...future.oldOptions))
[17:48:38.302]     }
[17:48:38.302]     if (TRUE) {
[17:48:38.302]     }
[17:48:38.302]     else {
[17:48:38.302]         if (NA) {
[17:48:38.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.302]                 open = "w")
[17:48:38.302]         }
[17:48:38.302]         else {
[17:48:38.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.302]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.302]         }
[17:48:38.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.302]             base::sink(type = "output", split = FALSE)
[17:48:38.302]             base::close(...future.stdout)
[17:48:38.302]         }, add = TRUE)
[17:48:38.302]     }
[17:48:38.302]     ...future.frame <- base::sys.nframe()
[17:48:38.302]     ...future.conditions <- base::list()
[17:48:38.302]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.302]     if (FALSE) {
[17:48:38.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.302]     }
[17:48:38.302]     ...future.result <- base::tryCatch({
[17:48:38.302]         base::withCallingHandlers({
[17:48:38.302]             ...future.value <- base::withVisible(base::local({
[17:48:38.302]                 withCallingHandlers({
[17:48:38.302]                   {
[17:48:38.302]                     print(1:50)
[17:48:38.302]                     str(1:50)
[17:48:38.302]                     cat(letters, sep = "-")
[17:48:38.302]                     cat(1:6, collapse = "\n")
[17:48:38.302]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.302]                     42L
[17:48:38.302]                   }
[17:48:38.302]                 }, immediateCondition = function(cond) {
[17:48:38.302]                   save_rds <- function (object, pathname, ...) 
[17:48:38.302]                   {
[17:48:38.302]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.302]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.302]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.302]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.302]                         fi_tmp[["mtime"]])
[17:48:38.302]                     }
[17:48:38.302]                     tryCatch({
[17:48:38.302]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.302]                     }, error = function(ex) {
[17:48:38.302]                       msg <- conditionMessage(ex)
[17:48:38.302]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.302]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.302]                         fi_tmp[["mtime"]], msg)
[17:48:38.302]                       ex$message <- msg
[17:48:38.302]                       stop(ex)
[17:48:38.302]                     })
[17:48:38.302]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.302]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.302]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.302]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.302]                       fi <- file.info(pathname)
[17:48:38.302]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.302]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.302]                         fi[["size"]], fi[["mtime"]])
[17:48:38.302]                       stop(msg)
[17:48:38.302]                     }
[17:48:38.302]                     invisible(pathname)
[17:48:38.302]                   }
[17:48:38.302]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.302]                     rootPath = tempdir()) 
[17:48:38.302]                   {
[17:48:38.302]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.302]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.302]                       tmpdir = path, fileext = ".rds")
[17:48:38.302]                     save_rds(obj, file)
[17:48:38.302]                   }
[17:48:38.302]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.302]                   {
[17:48:38.302]                     inherits <- base::inherits
[17:48:38.302]                     invokeRestart <- base::invokeRestart
[17:48:38.302]                     is.null <- base::is.null
[17:48:38.302]                     muffled <- FALSE
[17:48:38.302]                     if (inherits(cond, "message")) {
[17:48:38.302]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.302]                       if (muffled) 
[17:48:38.302]                         invokeRestart("muffleMessage")
[17:48:38.302]                     }
[17:48:38.302]                     else if (inherits(cond, "warning")) {
[17:48:38.302]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.302]                       if (muffled) 
[17:48:38.302]                         invokeRestart("muffleWarning")
[17:48:38.302]                     }
[17:48:38.302]                     else if (inherits(cond, "condition")) {
[17:48:38.302]                       if (!is.null(pattern)) {
[17:48:38.302]                         computeRestarts <- base::computeRestarts
[17:48:38.302]                         grepl <- base::grepl
[17:48:38.302]                         restarts <- computeRestarts(cond)
[17:48:38.302]                         for (restart in restarts) {
[17:48:38.302]                           name <- restart$name
[17:48:38.302]                           if (is.null(name)) 
[17:48:38.302]                             next
[17:48:38.302]                           if (!grepl(pattern, name)) 
[17:48:38.302]                             next
[17:48:38.302]                           invokeRestart(restart)
[17:48:38.302]                           muffled <- TRUE
[17:48:38.302]                           break
[17:48:38.302]                         }
[17:48:38.302]                       }
[17:48:38.302]                     }
[17:48:38.302]                     invisible(muffled)
[17:48:38.302]                   }
[17:48:38.302]                   muffleCondition(cond)
[17:48:38.302]                 })
[17:48:38.302]             }))
[17:48:38.302]             future::FutureResult(value = ...future.value$value, 
[17:48:38.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.302]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.302]                     ...future.globalenv.names))
[17:48:38.302]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.302]         }, condition = base::local({
[17:48:38.302]             c <- base::c
[17:48:38.302]             inherits <- base::inherits
[17:48:38.302]             invokeRestart <- base::invokeRestart
[17:48:38.302]             length <- base::length
[17:48:38.302]             list <- base::list
[17:48:38.302]             seq.int <- base::seq.int
[17:48:38.302]             signalCondition <- base::signalCondition
[17:48:38.302]             sys.calls <- base::sys.calls
[17:48:38.302]             `[[` <- base::`[[`
[17:48:38.302]             `+` <- base::`+`
[17:48:38.302]             `<<-` <- base::`<<-`
[17:48:38.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.302]                   3L)]
[17:48:38.302]             }
[17:48:38.302]             function(cond) {
[17:48:38.302]                 is_error <- inherits(cond, "error")
[17:48:38.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.302]                   NULL)
[17:48:38.302]                 if (is_error) {
[17:48:38.302]                   sessionInformation <- function() {
[17:48:38.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.302]                       search = base::search(), system = base::Sys.info())
[17:48:38.302]                   }
[17:48:38.302]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.302]                     cond$call), session = sessionInformation(), 
[17:48:38.302]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.302]                   signalCondition(cond)
[17:48:38.302]                 }
[17:48:38.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.302]                 "immediateCondition"))) {
[17:48:38.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.302]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.302]                   if (TRUE && !signal) {
[17:48:38.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.302]                     {
[17:48:38.302]                       inherits <- base::inherits
[17:48:38.302]                       invokeRestart <- base::invokeRestart
[17:48:38.302]                       is.null <- base::is.null
[17:48:38.302]                       muffled <- FALSE
[17:48:38.302]                       if (inherits(cond, "message")) {
[17:48:38.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.302]                         if (muffled) 
[17:48:38.302]                           invokeRestart("muffleMessage")
[17:48:38.302]                       }
[17:48:38.302]                       else if (inherits(cond, "warning")) {
[17:48:38.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.302]                         if (muffled) 
[17:48:38.302]                           invokeRestart("muffleWarning")
[17:48:38.302]                       }
[17:48:38.302]                       else if (inherits(cond, "condition")) {
[17:48:38.302]                         if (!is.null(pattern)) {
[17:48:38.302]                           computeRestarts <- base::computeRestarts
[17:48:38.302]                           grepl <- base::grepl
[17:48:38.302]                           restarts <- computeRestarts(cond)
[17:48:38.302]                           for (restart in restarts) {
[17:48:38.302]                             name <- restart$name
[17:48:38.302]                             if (is.null(name)) 
[17:48:38.302]                               next
[17:48:38.302]                             if (!grepl(pattern, name)) 
[17:48:38.302]                               next
[17:48:38.302]                             invokeRestart(restart)
[17:48:38.302]                             muffled <- TRUE
[17:48:38.302]                             break
[17:48:38.302]                           }
[17:48:38.302]                         }
[17:48:38.302]                       }
[17:48:38.302]                       invisible(muffled)
[17:48:38.302]                     }
[17:48:38.302]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.302]                   }
[17:48:38.302]                 }
[17:48:38.302]                 else {
[17:48:38.302]                   if (TRUE) {
[17:48:38.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.302]                     {
[17:48:38.302]                       inherits <- base::inherits
[17:48:38.302]                       invokeRestart <- base::invokeRestart
[17:48:38.302]                       is.null <- base::is.null
[17:48:38.302]                       muffled <- FALSE
[17:48:38.302]                       if (inherits(cond, "message")) {
[17:48:38.302]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.302]                         if (muffled) 
[17:48:38.302]                           invokeRestart("muffleMessage")
[17:48:38.302]                       }
[17:48:38.302]                       else if (inherits(cond, "warning")) {
[17:48:38.302]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.302]                         if (muffled) 
[17:48:38.302]                           invokeRestart("muffleWarning")
[17:48:38.302]                       }
[17:48:38.302]                       else if (inherits(cond, "condition")) {
[17:48:38.302]                         if (!is.null(pattern)) {
[17:48:38.302]                           computeRestarts <- base::computeRestarts
[17:48:38.302]                           grepl <- base::grepl
[17:48:38.302]                           restarts <- computeRestarts(cond)
[17:48:38.302]                           for (restart in restarts) {
[17:48:38.302]                             name <- restart$name
[17:48:38.302]                             if (is.null(name)) 
[17:48:38.302]                               next
[17:48:38.302]                             if (!grepl(pattern, name)) 
[17:48:38.302]                               next
[17:48:38.302]                             invokeRestart(restart)
[17:48:38.302]                             muffled <- TRUE
[17:48:38.302]                             break
[17:48:38.302]                           }
[17:48:38.302]                         }
[17:48:38.302]                       }
[17:48:38.302]                       invisible(muffled)
[17:48:38.302]                     }
[17:48:38.302]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.302]                   }
[17:48:38.302]                 }
[17:48:38.302]             }
[17:48:38.302]         }))
[17:48:38.302]     }, error = function(ex) {
[17:48:38.302]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.302]                 ...future.rng), started = ...future.startTime, 
[17:48:38.302]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.302]             version = "1.8"), class = "FutureResult")
[17:48:38.302]     }, finally = {
[17:48:38.302]         if (!identical(...future.workdir, getwd())) 
[17:48:38.302]             setwd(...future.workdir)
[17:48:38.302]         {
[17:48:38.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.302]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.302]             }
[17:48:38.302]             base::options(...future.oldOptions)
[17:48:38.302]             if (.Platform$OS.type == "windows") {
[17:48:38.302]                 old_names <- names(...future.oldEnvVars)
[17:48:38.302]                 envs <- base::Sys.getenv()
[17:48:38.302]                 names <- names(envs)
[17:48:38.302]                 common <- intersect(names, old_names)
[17:48:38.302]                 added <- setdiff(names, old_names)
[17:48:38.302]                 removed <- setdiff(old_names, names)
[17:48:38.302]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.302]                   envs[common]]
[17:48:38.302]                 NAMES <- toupper(changed)
[17:48:38.302]                 args <- list()
[17:48:38.302]                 for (kk in seq_along(NAMES)) {
[17:48:38.302]                   name <- changed[[kk]]
[17:48:38.302]                   NAME <- NAMES[[kk]]
[17:48:38.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.302]                     next
[17:48:38.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.302]                 }
[17:48:38.302]                 NAMES <- toupper(added)
[17:48:38.302]                 for (kk in seq_along(NAMES)) {
[17:48:38.302]                   name <- added[[kk]]
[17:48:38.302]                   NAME <- NAMES[[kk]]
[17:48:38.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.302]                     next
[17:48:38.302]                   args[[name]] <- ""
[17:48:38.302]                 }
[17:48:38.302]                 NAMES <- toupper(removed)
[17:48:38.302]                 for (kk in seq_along(NAMES)) {
[17:48:38.302]                   name <- removed[[kk]]
[17:48:38.302]                   NAME <- NAMES[[kk]]
[17:48:38.302]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.302]                     next
[17:48:38.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.302]                 }
[17:48:38.302]                 if (length(args) > 0) 
[17:48:38.302]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.302]             }
[17:48:38.302]             else {
[17:48:38.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.302]             }
[17:48:38.302]             {
[17:48:38.302]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.302]                   0L) {
[17:48:38.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.302]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.302]                   base::options(opts)
[17:48:38.302]                 }
[17:48:38.302]                 {
[17:48:38.302]                   {
[17:48:38.302]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.302]                     NULL
[17:48:38.302]                   }
[17:48:38.302]                   options(future.plan = NULL)
[17:48:38.302]                   if (is.na(NA_character_)) 
[17:48:38.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.302]                     .init = FALSE)
[17:48:38.302]                 }
[17:48:38.302]             }
[17:48:38.302]         }
[17:48:38.302]     })
[17:48:38.302]     if (FALSE) {
[17:48:38.302]         base::sink(type = "output", split = FALSE)
[17:48:38.302]         if (NA) {
[17:48:38.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.302]         }
[17:48:38.302]         else {
[17:48:38.302]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.302]         }
[17:48:38.302]         base::close(...future.stdout)
[17:48:38.302]         ...future.stdout <- NULL
[17:48:38.302]     }
[17:48:38.302]     ...future.result$conditions <- ...future.conditions
[17:48:38.302]     ...future.result$finished <- base::Sys.time()
[17:48:38.302]     ...future.result
[17:48:38.302] }
[17:48:38.305] requestCore(): workers = 2
[17:48:38.307] MulticoreFuture started
[17:48:38.307] - Launch lazy future ... done
[17:48:38.307] run() for ‘MulticoreFuture’ ... done
[17:48:38.308] result() for MulticoreFuture ...
[17:48:38.308] plan(): Setting new future strategy stack:
[17:48:38.308] List of future strategies:
[17:48:38.308] 1. sequential:
[17:48:38.308]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.308]    - tweaked: FALSE
[17:48:38.308]    - call: NULL
[17:48:38.309] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:48:38.313] plan(): Setting new future strategy stack:
[17:48:38.313] List of future strategies:
[17:48:38.313] 1. multicore:
[17:48:38.313]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.313]    - tweaked: FALSE
[17:48:38.313]    - call: plan(strategy)
[17:48:38.318] plan(): nbrOfWorkers() = 2
[17:48:38.319] result() for MulticoreFuture ...
[17:48:38.319] result() for MulticoreFuture ... done
[17:48:38.319] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:38"
 $ session_uuid: chr "0850443c-c55e-5305-4f35-99647f973bee"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50482
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:38"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:38.329] result() for MulticoreFuture ...
[17:48:38.329] result() for MulticoreFuture ... done
[17:48:38.329] result() for MulticoreFuture ...
[17:48:38.329] result() for MulticoreFuture ... done
[17:48:38.330] getGlobalsAndPackages() ...
[17:48:38.330] Searching for globals...
[17:48:38.337] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:38.337] Searching for globals ... DONE
[17:48:38.337] Resolving globals: FALSE
[17:48:38.338] 
[17:48:38.338] - packages: [1] ‘utils’
[17:48:38.338] getGlobalsAndPackages() ... DONE
[17:48:38.338] run() for ‘Future’ ...
[17:48:38.339] - state: ‘created’
[17:48:38.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.343] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.343]   - Field: ‘label’
[17:48:38.343]   - Field: ‘local’
[17:48:38.343]   - Field: ‘owner’
[17:48:38.344]   - Field: ‘envir’
[17:48:38.344]   - Field: ‘workers’
[17:48:38.344]   - Field: ‘packages’
[17:48:38.344]   - Field: ‘gc’
[17:48:38.344]   - Field: ‘job’
[17:48:38.344]   - Field: ‘conditions’
[17:48:38.344]   - Field: ‘expr’
[17:48:38.344]   - Field: ‘uuid’
[17:48:38.344]   - Field: ‘seed’
[17:48:38.345]   - Field: ‘version’
[17:48:38.345]   - Field: ‘result’
[17:48:38.345]   - Field: ‘asynchronous’
[17:48:38.345]   - Field: ‘calls’
[17:48:38.345]   - Field: ‘globals’
[17:48:38.345]   - Field: ‘stdout’
[17:48:38.345]   - Field: ‘earlySignal’
[17:48:38.345]   - Field: ‘lazy’
[17:48:38.345]   - Field: ‘state’
[17:48:38.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.346] - Launch lazy future ...
[17:48:38.346] Packages needed by the future expression (n = 1): ‘utils’
[17:48:38.346] Packages needed by future strategies (n = 0): <none>
[17:48:38.347] {
[17:48:38.347]     {
[17:48:38.347]         {
[17:48:38.347]             ...future.startTime <- base::Sys.time()
[17:48:38.347]             {
[17:48:38.347]                 {
[17:48:38.347]                   {
[17:48:38.347]                     {
[17:48:38.347]                       {
[17:48:38.347]                         base::local({
[17:48:38.347]                           has_future <- base::requireNamespace("future", 
[17:48:38.347]                             quietly = TRUE)
[17:48:38.347]                           if (has_future) {
[17:48:38.347]                             ns <- base::getNamespace("future")
[17:48:38.347]                             version <- ns[[".package"]][["version"]]
[17:48:38.347]                             if (is.null(version)) 
[17:48:38.347]                               version <- utils::packageVersion("future")
[17:48:38.347]                           }
[17:48:38.347]                           else {
[17:48:38.347]                             version <- NULL
[17:48:38.347]                           }
[17:48:38.347]                           if (!has_future || version < "1.8.0") {
[17:48:38.347]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.347]                               "", base::R.version$version.string), 
[17:48:38.347]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:38.347]                                 base::R.version$platform, 8 * 
[17:48:38.347]                                   base::.Machine$sizeof.pointer), 
[17:48:38.347]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.347]                                 "release", "version")], collapse = " "), 
[17:48:38.347]                               hostname = base::Sys.info()[["nodename"]])
[17:48:38.347]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.347]                               info)
[17:48:38.347]                             info <- base::paste(info, collapse = "; ")
[17:48:38.347]                             if (!has_future) {
[17:48:38.347]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.347]                                 info)
[17:48:38.347]                             }
[17:48:38.347]                             else {
[17:48:38.347]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.347]                                 info, version)
[17:48:38.347]                             }
[17:48:38.347]                             base::stop(msg)
[17:48:38.347]                           }
[17:48:38.347]                         })
[17:48:38.347]                       }
[17:48:38.347]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.347]                       base::options(mc.cores = 1L)
[17:48:38.347]                     }
[17:48:38.347]                     base::local({
[17:48:38.347]                       for (pkg in "utils") {
[17:48:38.347]                         base::loadNamespace(pkg)
[17:48:38.347]                         base::library(pkg, character.only = TRUE)
[17:48:38.347]                       }
[17:48:38.347]                     })
[17:48:38.347]                   }
[17:48:38.347]                   ...future.strategy.old <- future::plan("list")
[17:48:38.347]                   options(future.plan = NULL)
[17:48:38.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.347]                 }
[17:48:38.347]                 ...future.workdir <- getwd()
[17:48:38.347]             }
[17:48:38.347]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.347]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.347]         }
[17:48:38.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.347]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.347]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.347]             base::names(...future.oldOptions))
[17:48:38.347]     }
[17:48:38.347]     if (TRUE) {
[17:48:38.347]     }
[17:48:38.347]     else {
[17:48:38.347]         if (NA) {
[17:48:38.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.347]                 open = "w")
[17:48:38.347]         }
[17:48:38.347]         else {
[17:48:38.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.347]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.347]         }
[17:48:38.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.347]             base::sink(type = "output", split = FALSE)
[17:48:38.347]             base::close(...future.stdout)
[17:48:38.347]         }, add = TRUE)
[17:48:38.347]     }
[17:48:38.347]     ...future.frame <- base::sys.nframe()
[17:48:38.347]     ...future.conditions <- base::list()
[17:48:38.347]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.347]     if (FALSE) {
[17:48:38.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.347]     }
[17:48:38.347]     ...future.result <- base::tryCatch({
[17:48:38.347]         base::withCallingHandlers({
[17:48:38.347]             ...future.value <- base::withVisible(base::local({
[17:48:38.347]                 withCallingHandlers({
[17:48:38.347]                   {
[17:48:38.347]                     print(1:50)
[17:48:38.347]                     str(1:50)
[17:48:38.347]                     cat(letters, sep = "-")
[17:48:38.347]                     cat(1:6, collapse = "\n")
[17:48:38.347]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:38.347]                     42L
[17:48:38.347]                   }
[17:48:38.347]                 }, immediateCondition = function(cond) {
[17:48:38.347]                   save_rds <- function (object, pathname, ...) 
[17:48:38.347]                   {
[17:48:38.347]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.347]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.347]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.347]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.347]                         fi_tmp[["mtime"]])
[17:48:38.347]                     }
[17:48:38.347]                     tryCatch({
[17:48:38.347]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.347]                     }, error = function(ex) {
[17:48:38.347]                       msg <- conditionMessage(ex)
[17:48:38.347]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.347]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.347]                         fi_tmp[["mtime"]], msg)
[17:48:38.347]                       ex$message <- msg
[17:48:38.347]                       stop(ex)
[17:48:38.347]                     })
[17:48:38.347]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.347]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.347]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.347]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.347]                       fi <- file.info(pathname)
[17:48:38.347]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.347]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.347]                         fi[["size"]], fi[["mtime"]])
[17:48:38.347]                       stop(msg)
[17:48:38.347]                     }
[17:48:38.347]                     invisible(pathname)
[17:48:38.347]                   }
[17:48:38.347]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.347]                     rootPath = tempdir()) 
[17:48:38.347]                   {
[17:48:38.347]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.347]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.347]                       tmpdir = path, fileext = ".rds")
[17:48:38.347]                     save_rds(obj, file)
[17:48:38.347]                   }
[17:48:38.347]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.347]                   {
[17:48:38.347]                     inherits <- base::inherits
[17:48:38.347]                     invokeRestart <- base::invokeRestart
[17:48:38.347]                     is.null <- base::is.null
[17:48:38.347]                     muffled <- FALSE
[17:48:38.347]                     if (inherits(cond, "message")) {
[17:48:38.347]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.347]                       if (muffled) 
[17:48:38.347]                         invokeRestart("muffleMessage")
[17:48:38.347]                     }
[17:48:38.347]                     else if (inherits(cond, "warning")) {
[17:48:38.347]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.347]                       if (muffled) 
[17:48:38.347]                         invokeRestart("muffleWarning")
[17:48:38.347]                     }
[17:48:38.347]                     else if (inherits(cond, "condition")) {
[17:48:38.347]                       if (!is.null(pattern)) {
[17:48:38.347]                         computeRestarts <- base::computeRestarts
[17:48:38.347]                         grepl <- base::grepl
[17:48:38.347]                         restarts <- computeRestarts(cond)
[17:48:38.347]                         for (restart in restarts) {
[17:48:38.347]                           name <- restart$name
[17:48:38.347]                           if (is.null(name)) 
[17:48:38.347]                             next
[17:48:38.347]                           if (!grepl(pattern, name)) 
[17:48:38.347]                             next
[17:48:38.347]                           invokeRestart(restart)
[17:48:38.347]                           muffled <- TRUE
[17:48:38.347]                           break
[17:48:38.347]                         }
[17:48:38.347]                       }
[17:48:38.347]                     }
[17:48:38.347]                     invisible(muffled)
[17:48:38.347]                   }
[17:48:38.347]                   muffleCondition(cond)
[17:48:38.347]                 })
[17:48:38.347]             }))
[17:48:38.347]             future::FutureResult(value = ...future.value$value, 
[17:48:38.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.347]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.347]                     ...future.globalenv.names))
[17:48:38.347]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.347]         }, condition = base::local({
[17:48:38.347]             c <- base::c
[17:48:38.347]             inherits <- base::inherits
[17:48:38.347]             invokeRestart <- base::invokeRestart
[17:48:38.347]             length <- base::length
[17:48:38.347]             list <- base::list
[17:48:38.347]             seq.int <- base::seq.int
[17:48:38.347]             signalCondition <- base::signalCondition
[17:48:38.347]             sys.calls <- base::sys.calls
[17:48:38.347]             `[[` <- base::`[[`
[17:48:38.347]             `+` <- base::`+`
[17:48:38.347]             `<<-` <- base::`<<-`
[17:48:38.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.347]                   3L)]
[17:48:38.347]             }
[17:48:38.347]             function(cond) {
[17:48:38.347]                 is_error <- inherits(cond, "error")
[17:48:38.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.347]                   NULL)
[17:48:38.347]                 if (is_error) {
[17:48:38.347]                   sessionInformation <- function() {
[17:48:38.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.347]                       search = base::search(), system = base::Sys.info())
[17:48:38.347]                   }
[17:48:38.347]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.347]                     cond$call), session = sessionInformation(), 
[17:48:38.347]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.347]                   signalCondition(cond)
[17:48:38.347]                 }
[17:48:38.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.347]                 "immediateCondition"))) {
[17:48:38.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.347]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.347]                   if (TRUE && !signal) {
[17:48:38.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.347]                     {
[17:48:38.347]                       inherits <- base::inherits
[17:48:38.347]                       invokeRestart <- base::invokeRestart
[17:48:38.347]                       is.null <- base::is.null
[17:48:38.347]                       muffled <- FALSE
[17:48:38.347]                       if (inherits(cond, "message")) {
[17:48:38.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.347]                         if (muffled) 
[17:48:38.347]                           invokeRestart("muffleMessage")
[17:48:38.347]                       }
[17:48:38.347]                       else if (inherits(cond, "warning")) {
[17:48:38.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.347]                         if (muffled) 
[17:48:38.347]                           invokeRestart("muffleWarning")
[17:48:38.347]                       }
[17:48:38.347]                       else if (inherits(cond, "condition")) {
[17:48:38.347]                         if (!is.null(pattern)) {
[17:48:38.347]                           computeRestarts <- base::computeRestarts
[17:48:38.347]                           grepl <- base::grepl
[17:48:38.347]                           restarts <- computeRestarts(cond)
[17:48:38.347]                           for (restart in restarts) {
[17:48:38.347]                             name <- restart$name
[17:48:38.347]                             if (is.null(name)) 
[17:48:38.347]                               next
[17:48:38.347]                             if (!grepl(pattern, name)) 
[17:48:38.347]                               next
[17:48:38.347]                             invokeRestart(restart)
[17:48:38.347]                             muffled <- TRUE
[17:48:38.347]                             break
[17:48:38.347]                           }
[17:48:38.347]                         }
[17:48:38.347]                       }
[17:48:38.347]                       invisible(muffled)
[17:48:38.347]                     }
[17:48:38.347]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.347]                   }
[17:48:38.347]                 }
[17:48:38.347]                 else {
[17:48:38.347]                   if (TRUE) {
[17:48:38.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.347]                     {
[17:48:38.347]                       inherits <- base::inherits
[17:48:38.347]                       invokeRestart <- base::invokeRestart
[17:48:38.347]                       is.null <- base::is.null
[17:48:38.347]                       muffled <- FALSE
[17:48:38.347]                       if (inherits(cond, "message")) {
[17:48:38.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.347]                         if (muffled) 
[17:48:38.347]                           invokeRestart("muffleMessage")
[17:48:38.347]                       }
[17:48:38.347]                       else if (inherits(cond, "warning")) {
[17:48:38.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.347]                         if (muffled) 
[17:48:38.347]                           invokeRestart("muffleWarning")
[17:48:38.347]                       }
[17:48:38.347]                       else if (inherits(cond, "condition")) {
[17:48:38.347]                         if (!is.null(pattern)) {
[17:48:38.347]                           computeRestarts <- base::computeRestarts
[17:48:38.347]                           grepl <- base::grepl
[17:48:38.347]                           restarts <- computeRestarts(cond)
[17:48:38.347]                           for (restart in restarts) {
[17:48:38.347]                             name <- restart$name
[17:48:38.347]                             if (is.null(name)) 
[17:48:38.347]                               next
[17:48:38.347]                             if (!grepl(pattern, name)) 
[17:48:38.347]                               next
[17:48:38.347]                             invokeRestart(restart)
[17:48:38.347]                             muffled <- TRUE
[17:48:38.347]                             break
[17:48:38.347]                           }
[17:48:38.347]                         }
[17:48:38.347]                       }
[17:48:38.347]                       invisible(muffled)
[17:48:38.347]                     }
[17:48:38.347]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.347]                   }
[17:48:38.347]                 }
[17:48:38.347]             }
[17:48:38.347]         }))
[17:48:38.347]     }, error = function(ex) {
[17:48:38.347]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.347]                 ...future.rng), started = ...future.startTime, 
[17:48:38.347]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.347]             version = "1.8"), class = "FutureResult")
[17:48:38.347]     }, finally = {
[17:48:38.347]         if (!identical(...future.workdir, getwd())) 
[17:48:38.347]             setwd(...future.workdir)
[17:48:38.347]         {
[17:48:38.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.347]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.347]             }
[17:48:38.347]             base::options(...future.oldOptions)
[17:48:38.347]             if (.Platform$OS.type == "windows") {
[17:48:38.347]                 old_names <- names(...future.oldEnvVars)
[17:48:38.347]                 envs <- base::Sys.getenv()
[17:48:38.347]                 names <- names(envs)
[17:48:38.347]                 common <- intersect(names, old_names)
[17:48:38.347]                 added <- setdiff(names, old_names)
[17:48:38.347]                 removed <- setdiff(old_names, names)
[17:48:38.347]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.347]                   envs[common]]
[17:48:38.347]                 NAMES <- toupper(changed)
[17:48:38.347]                 args <- list()
[17:48:38.347]                 for (kk in seq_along(NAMES)) {
[17:48:38.347]                   name <- changed[[kk]]
[17:48:38.347]                   NAME <- NAMES[[kk]]
[17:48:38.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.347]                     next
[17:48:38.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.347]                 }
[17:48:38.347]                 NAMES <- toupper(added)
[17:48:38.347]                 for (kk in seq_along(NAMES)) {
[17:48:38.347]                   name <- added[[kk]]
[17:48:38.347]                   NAME <- NAMES[[kk]]
[17:48:38.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.347]                     next
[17:48:38.347]                   args[[name]] <- ""
[17:48:38.347]                 }
[17:48:38.347]                 NAMES <- toupper(removed)
[17:48:38.347]                 for (kk in seq_along(NAMES)) {
[17:48:38.347]                   name <- removed[[kk]]
[17:48:38.347]                   NAME <- NAMES[[kk]]
[17:48:38.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.347]                     next
[17:48:38.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.347]                 }
[17:48:38.347]                 if (length(args) > 0) 
[17:48:38.347]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.347]             }
[17:48:38.347]             else {
[17:48:38.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.347]             }
[17:48:38.347]             {
[17:48:38.347]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.347]                   0L) {
[17:48:38.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.347]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.347]                   base::options(opts)
[17:48:38.347]                 }
[17:48:38.347]                 {
[17:48:38.347]                   {
[17:48:38.347]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.347]                     NULL
[17:48:38.347]                   }
[17:48:38.347]                   options(future.plan = NULL)
[17:48:38.347]                   if (is.na(NA_character_)) 
[17:48:38.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.347]                     .init = FALSE)
[17:48:38.347]                 }
[17:48:38.347]             }
[17:48:38.347]         }
[17:48:38.347]     })
[17:48:38.347]     if (FALSE) {
[17:48:38.347]         base::sink(type = "output", split = FALSE)
[17:48:38.347]         if (NA) {
[17:48:38.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.347]         }
[17:48:38.347]         else {
[17:48:38.347]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.347]         }
[17:48:38.347]         base::close(...future.stdout)
[17:48:38.347]         ...future.stdout <- NULL
[17:48:38.347]     }
[17:48:38.347]     ...future.result$conditions <- ...future.conditions
[17:48:38.347]     ...future.result$finished <- base::Sys.time()
[17:48:38.347]     ...future.result
[17:48:38.347] }
[17:48:38.349] requestCore(): workers = 2
[17:48:38.352] MulticoreFuture started
[17:48:38.352] - Launch lazy future ... done
[17:48:38.352] run() for ‘MulticoreFuture’ ... done
[17:48:38.353] result() for MulticoreFuture ...
[17:48:38.353] plan(): Setting new future strategy stack:
[17:48:38.353] List of future strategies:
[17:48:38.353] 1. sequential:
[17:48:38.353]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.353]    - tweaked: FALSE
[17:48:38.353]    - call: NULL
[17:48:38.355] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:48:38.358] plan(): Setting new future strategy stack:
[17:48:38.359] List of future strategies:
[17:48:38.359] 1. multicore:
[17:48:38.359]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.359]    - tweaked: FALSE
[17:48:38.359]    - call: plan(strategy)
[17:48:38.364] plan(): nbrOfWorkers() = 2
[17:48:38.364] result() for MulticoreFuture ...
[17:48:38.365] result() for MulticoreFuture ... done
[17:48:38.365] result() for MulticoreFuture ... done
[17:48:38.365] result() for MulticoreFuture ...
[17:48:38.365] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:48:38.365] getGlobalsAndPackages() ...
[17:48:38.366] Searching for globals...
[17:48:38.366] - globals found: [1] ‘print’
[17:48:38.367] Searching for globals ... DONE
[17:48:38.367] Resolving globals: FALSE
[17:48:38.367] 
[17:48:38.367] 
[17:48:38.367] getGlobalsAndPackages() ... DONE
[17:48:38.368] run() for ‘Future’ ...
[17:48:38.368] - state: ‘created’
[17:48:38.368] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:48:38.373] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:38.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:48:38.373]   - Field: ‘label’
[17:48:38.373]   - Field: ‘local’
[17:48:38.373]   - Field: ‘owner’
[17:48:38.373]   - Field: ‘envir’
[17:48:38.373]   - Field: ‘workers’
[17:48:38.373]   - Field: ‘packages’
[17:48:38.374]   - Field: ‘gc’
[17:48:38.374]   - Field: ‘job’
[17:48:38.374]   - Field: ‘conditions’
[17:48:38.374]   - Field: ‘expr’
[17:48:38.374]   - Field: ‘uuid’
[17:48:38.374]   - Field: ‘seed’
[17:48:38.374]   - Field: ‘version’
[17:48:38.374]   - Field: ‘result’
[17:48:38.374]   - Field: ‘asynchronous’
[17:48:38.375]   - Field: ‘calls’
[17:48:38.375]   - Field: ‘globals’
[17:48:38.375]   - Field: ‘stdout’
[17:48:38.375]   - Field: ‘earlySignal’
[17:48:38.375]   - Field: ‘lazy’
[17:48:38.375]   - Field: ‘state’
[17:48:38.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:48:38.375] - Launch lazy future ...
[17:48:38.376] Packages needed by the future expression (n = 0): <none>
[17:48:38.376] Packages needed by future strategies (n = 0): <none>
[17:48:38.377] {
[17:48:38.377]     {
[17:48:38.377]         {
[17:48:38.377]             ...future.startTime <- base::Sys.time()
[17:48:38.377]             {
[17:48:38.377]                 {
[17:48:38.377]                   {
[17:48:38.377]                     {
[17:48:38.377]                       base::local({
[17:48:38.377]                         has_future <- base::requireNamespace("future", 
[17:48:38.377]                           quietly = TRUE)
[17:48:38.377]                         if (has_future) {
[17:48:38.377]                           ns <- base::getNamespace("future")
[17:48:38.377]                           version <- ns[[".package"]][["version"]]
[17:48:38.377]                           if (is.null(version)) 
[17:48:38.377]                             version <- utils::packageVersion("future")
[17:48:38.377]                         }
[17:48:38.377]                         else {
[17:48:38.377]                           version <- NULL
[17:48:38.377]                         }
[17:48:38.377]                         if (!has_future || version < "1.8.0") {
[17:48:38.377]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.377]                             "", base::R.version$version.string), 
[17:48:38.377]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:38.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.377]                               "release", "version")], collapse = " "), 
[17:48:38.377]                             hostname = base::Sys.info()[["nodename"]])
[17:48:38.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.377]                             info)
[17:48:38.377]                           info <- base::paste(info, collapse = "; ")
[17:48:38.377]                           if (!has_future) {
[17:48:38.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.377]                               info)
[17:48:38.377]                           }
[17:48:38.377]                           else {
[17:48:38.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.377]                               info, version)
[17:48:38.377]                           }
[17:48:38.377]                           base::stop(msg)
[17:48:38.377]                         }
[17:48:38.377]                       })
[17:48:38.377]                     }
[17:48:38.377]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.377]                     base::options(mc.cores = 1L)
[17:48:38.377]                   }
[17:48:38.377]                   ...future.strategy.old <- future::plan("list")
[17:48:38.377]                   options(future.plan = NULL)
[17:48:38.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.377]                 }
[17:48:38.377]                 ...future.workdir <- getwd()
[17:48:38.377]             }
[17:48:38.377]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.377]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.377]         }
[17:48:38.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.377]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.377]             base::names(...future.oldOptions))
[17:48:38.377]     }
[17:48:38.377]     if (FALSE) {
[17:48:38.377]     }
[17:48:38.377]     else {
[17:48:38.377]         if (TRUE) {
[17:48:38.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.377]                 open = "w")
[17:48:38.377]         }
[17:48:38.377]         else {
[17:48:38.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.377]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.377]         }
[17:48:38.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.377]             base::sink(type = "output", split = FALSE)
[17:48:38.377]             base::close(...future.stdout)
[17:48:38.377]         }, add = TRUE)
[17:48:38.377]     }
[17:48:38.377]     ...future.frame <- base::sys.nframe()
[17:48:38.377]     ...future.conditions <- base::list()
[17:48:38.377]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.377]     if (FALSE) {
[17:48:38.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.377]     }
[17:48:38.377]     ...future.result <- base::tryCatch({
[17:48:38.377]         base::withCallingHandlers({
[17:48:38.377]             ...future.value <- base::withVisible(base::local({
[17:48:38.377]                 withCallingHandlers({
[17:48:38.377]                   print(42)
[17:48:38.377]                 }, immediateCondition = function(cond) {
[17:48:38.377]                   save_rds <- function (object, pathname, ...) 
[17:48:38.377]                   {
[17:48:38.377]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:48:38.377]                     if (file_test("-f", pathname_tmp)) {
[17:48:38.377]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.377]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:48:38.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.377]                         fi_tmp[["mtime"]])
[17:48:38.377]                     }
[17:48:38.377]                     tryCatch({
[17:48:38.377]                       saveRDS(object, file = pathname_tmp, ...)
[17:48:38.377]                     }, error = function(ex) {
[17:48:38.377]                       msg <- conditionMessage(ex)
[17:48:38.377]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.377]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:48:38.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.377]                         fi_tmp[["mtime"]], msg)
[17:48:38.377]                       ex$message <- msg
[17:48:38.377]                       stop(ex)
[17:48:38.377]                     })
[17:48:38.377]                     stopifnot(file_test("-f", pathname_tmp))
[17:48:38.377]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:48:38.377]                     if (!res || file_test("-f", pathname_tmp)) {
[17:48:38.377]                       fi_tmp <- file.info(pathname_tmp)
[17:48:38.377]                       fi <- file.info(pathname)
[17:48:38.377]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:48:38.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:48:38.377]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:48:38.377]                         fi[["size"]], fi[["mtime"]])
[17:48:38.377]                       stop(msg)
[17:48:38.377]                     }
[17:48:38.377]                     invisible(pathname)
[17:48:38.377]                   }
[17:48:38.377]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:48:38.377]                     rootPath = tempdir()) 
[17:48:38.377]                   {
[17:48:38.377]                     obj <- list(time = Sys.time(), condition = cond)
[17:48:38.377]                     file <- tempfile(pattern = class(cond)[1], 
[17:48:38.377]                       tmpdir = path, fileext = ".rds")
[17:48:38.377]                     save_rds(obj, file)
[17:48:38.377]                   }
[17:48:38.377]                   saveImmediateCondition(cond, path = "/tmp/RtmpVGIxgu/.future/immediateConditions")
[17:48:38.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.377]                   {
[17:48:38.377]                     inherits <- base::inherits
[17:48:38.377]                     invokeRestart <- base::invokeRestart
[17:48:38.377]                     is.null <- base::is.null
[17:48:38.377]                     muffled <- FALSE
[17:48:38.377]                     if (inherits(cond, "message")) {
[17:48:38.377]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.377]                       if (muffled) 
[17:48:38.377]                         invokeRestart("muffleMessage")
[17:48:38.377]                     }
[17:48:38.377]                     else if (inherits(cond, "warning")) {
[17:48:38.377]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.377]                       if (muffled) 
[17:48:38.377]                         invokeRestart("muffleWarning")
[17:48:38.377]                     }
[17:48:38.377]                     else if (inherits(cond, "condition")) {
[17:48:38.377]                       if (!is.null(pattern)) {
[17:48:38.377]                         computeRestarts <- base::computeRestarts
[17:48:38.377]                         grepl <- base::grepl
[17:48:38.377]                         restarts <- computeRestarts(cond)
[17:48:38.377]                         for (restart in restarts) {
[17:48:38.377]                           name <- restart$name
[17:48:38.377]                           if (is.null(name)) 
[17:48:38.377]                             next
[17:48:38.377]                           if (!grepl(pattern, name)) 
[17:48:38.377]                             next
[17:48:38.377]                           invokeRestart(restart)
[17:48:38.377]                           muffled <- TRUE
[17:48:38.377]                           break
[17:48:38.377]                         }
[17:48:38.377]                       }
[17:48:38.377]                     }
[17:48:38.377]                     invisible(muffled)
[17:48:38.377]                   }
[17:48:38.377]                   muffleCondition(cond)
[17:48:38.377]                 })
[17:48:38.377]             }))
[17:48:38.377]             future::FutureResult(value = ...future.value$value, 
[17:48:38.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.377]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.377]                     ...future.globalenv.names))
[17:48:38.377]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.377]         }, condition = base::local({
[17:48:38.377]             c <- base::c
[17:48:38.377]             inherits <- base::inherits
[17:48:38.377]             invokeRestart <- base::invokeRestart
[17:48:38.377]             length <- base::length
[17:48:38.377]             list <- base::list
[17:48:38.377]             seq.int <- base::seq.int
[17:48:38.377]             signalCondition <- base::signalCondition
[17:48:38.377]             sys.calls <- base::sys.calls
[17:48:38.377]             `[[` <- base::`[[`
[17:48:38.377]             `+` <- base::`+`
[17:48:38.377]             `<<-` <- base::`<<-`
[17:48:38.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.377]                   3L)]
[17:48:38.377]             }
[17:48:38.377]             function(cond) {
[17:48:38.377]                 is_error <- inherits(cond, "error")
[17:48:38.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.377]                   NULL)
[17:48:38.377]                 if (is_error) {
[17:48:38.377]                   sessionInformation <- function() {
[17:48:38.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.377]                       search = base::search(), system = base::Sys.info())
[17:48:38.377]                   }
[17:48:38.377]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.377]                     cond$call), session = sessionInformation(), 
[17:48:38.377]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.377]                   signalCondition(cond)
[17:48:38.377]                 }
[17:48:38.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.377]                 "immediateCondition"))) {
[17:48:38.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.377]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.377]                   if (TRUE && !signal) {
[17:48:38.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.377]                     {
[17:48:38.377]                       inherits <- base::inherits
[17:48:38.377]                       invokeRestart <- base::invokeRestart
[17:48:38.377]                       is.null <- base::is.null
[17:48:38.377]                       muffled <- FALSE
[17:48:38.377]                       if (inherits(cond, "message")) {
[17:48:38.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.377]                         if (muffled) 
[17:48:38.377]                           invokeRestart("muffleMessage")
[17:48:38.377]                       }
[17:48:38.377]                       else if (inherits(cond, "warning")) {
[17:48:38.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.377]                         if (muffled) 
[17:48:38.377]                           invokeRestart("muffleWarning")
[17:48:38.377]                       }
[17:48:38.377]                       else if (inherits(cond, "condition")) {
[17:48:38.377]                         if (!is.null(pattern)) {
[17:48:38.377]                           computeRestarts <- base::computeRestarts
[17:48:38.377]                           grepl <- base::grepl
[17:48:38.377]                           restarts <- computeRestarts(cond)
[17:48:38.377]                           for (restart in restarts) {
[17:48:38.377]                             name <- restart$name
[17:48:38.377]                             if (is.null(name)) 
[17:48:38.377]                               next
[17:48:38.377]                             if (!grepl(pattern, name)) 
[17:48:38.377]                               next
[17:48:38.377]                             invokeRestart(restart)
[17:48:38.377]                             muffled <- TRUE
[17:48:38.377]                             break
[17:48:38.377]                           }
[17:48:38.377]                         }
[17:48:38.377]                       }
[17:48:38.377]                       invisible(muffled)
[17:48:38.377]                     }
[17:48:38.377]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.377]                   }
[17:48:38.377]                 }
[17:48:38.377]                 else {
[17:48:38.377]                   if (TRUE) {
[17:48:38.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.377]                     {
[17:48:38.377]                       inherits <- base::inherits
[17:48:38.377]                       invokeRestart <- base::invokeRestart
[17:48:38.377]                       is.null <- base::is.null
[17:48:38.377]                       muffled <- FALSE
[17:48:38.377]                       if (inherits(cond, "message")) {
[17:48:38.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.377]                         if (muffled) 
[17:48:38.377]                           invokeRestart("muffleMessage")
[17:48:38.377]                       }
[17:48:38.377]                       else if (inherits(cond, "warning")) {
[17:48:38.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.377]                         if (muffled) 
[17:48:38.377]                           invokeRestart("muffleWarning")
[17:48:38.377]                       }
[17:48:38.377]                       else if (inherits(cond, "condition")) {
[17:48:38.377]                         if (!is.null(pattern)) {
[17:48:38.377]                           computeRestarts <- base::computeRestarts
[17:48:38.377]                           grepl <- base::grepl
[17:48:38.377]                           restarts <- computeRestarts(cond)
[17:48:38.377]                           for (restart in restarts) {
[17:48:38.377]                             name <- restart$name
[17:48:38.377]                             if (is.null(name)) 
[17:48:38.377]                               next
[17:48:38.377]                             if (!grepl(pattern, name)) 
[17:48:38.377]                               next
[17:48:38.377]                             invokeRestart(restart)
[17:48:38.377]                             muffled <- TRUE
[17:48:38.377]                             break
[17:48:38.377]                           }
[17:48:38.377]                         }
[17:48:38.377]                       }
[17:48:38.377]                       invisible(muffled)
[17:48:38.377]                     }
[17:48:38.377]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.377]                   }
[17:48:38.377]                 }
[17:48:38.377]             }
[17:48:38.377]         }))
[17:48:38.377]     }, error = function(ex) {
[17:48:38.377]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.377]                 ...future.rng), started = ...future.startTime, 
[17:48:38.377]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.377]             version = "1.8"), class = "FutureResult")
[17:48:38.377]     }, finally = {
[17:48:38.377]         if (!identical(...future.workdir, getwd())) 
[17:48:38.377]             setwd(...future.workdir)
[17:48:38.377]         {
[17:48:38.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.377]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.377]             }
[17:48:38.377]             base::options(...future.oldOptions)
[17:48:38.377]             if (.Platform$OS.type == "windows") {
[17:48:38.377]                 old_names <- names(...future.oldEnvVars)
[17:48:38.377]                 envs <- base::Sys.getenv()
[17:48:38.377]                 names <- names(envs)
[17:48:38.377]                 common <- intersect(names, old_names)
[17:48:38.377]                 added <- setdiff(names, old_names)
[17:48:38.377]                 removed <- setdiff(old_names, names)
[17:48:38.377]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.377]                   envs[common]]
[17:48:38.377]                 NAMES <- toupper(changed)
[17:48:38.377]                 args <- list()
[17:48:38.377]                 for (kk in seq_along(NAMES)) {
[17:48:38.377]                   name <- changed[[kk]]
[17:48:38.377]                   NAME <- NAMES[[kk]]
[17:48:38.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.377]                     next
[17:48:38.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.377]                 }
[17:48:38.377]                 NAMES <- toupper(added)
[17:48:38.377]                 for (kk in seq_along(NAMES)) {
[17:48:38.377]                   name <- added[[kk]]
[17:48:38.377]                   NAME <- NAMES[[kk]]
[17:48:38.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.377]                     next
[17:48:38.377]                   args[[name]] <- ""
[17:48:38.377]                 }
[17:48:38.377]                 NAMES <- toupper(removed)
[17:48:38.377]                 for (kk in seq_along(NAMES)) {
[17:48:38.377]                   name <- removed[[kk]]
[17:48:38.377]                   NAME <- NAMES[[kk]]
[17:48:38.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.377]                     next
[17:48:38.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.377]                 }
[17:48:38.377]                 if (length(args) > 0) 
[17:48:38.377]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.377]             }
[17:48:38.377]             else {
[17:48:38.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.377]             }
[17:48:38.377]             {
[17:48:38.377]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.377]                   0L) {
[17:48:38.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.377]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.377]                   base::options(opts)
[17:48:38.377]                 }
[17:48:38.377]                 {
[17:48:38.377]                   {
[17:48:38.377]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.377]                     NULL
[17:48:38.377]                   }
[17:48:38.377]                   options(future.plan = NULL)
[17:48:38.377]                   if (is.na(NA_character_)) 
[17:48:38.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.377]                     .init = FALSE)
[17:48:38.377]                 }
[17:48:38.377]             }
[17:48:38.377]         }
[17:48:38.377]     })
[17:48:38.377]     if (TRUE) {
[17:48:38.377]         base::sink(type = "output", split = FALSE)
[17:48:38.377]         if (TRUE) {
[17:48:38.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.377]         }
[17:48:38.377]         else {
[17:48:38.377]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.377]         }
[17:48:38.377]         base::close(...future.stdout)
[17:48:38.377]         ...future.stdout <- NULL
[17:48:38.377]     }
[17:48:38.377]     ...future.result$conditions <- ...future.conditions
[17:48:38.377]     ...future.result$finished <- base::Sys.time()
[17:48:38.377]     ...future.result
[17:48:38.377] }
[17:48:38.379] requestCore(): workers = 2
[17:48:38.381] MulticoreFuture started
[17:48:38.381] - Launch lazy future ... done
[17:48:38.382] run() for ‘MulticoreFuture’ ... done
[17:48:38.382] result() for MulticoreFuture ...
[17:48:38.382] plan(): Setting new future strategy stack:
[17:48:38.382] List of future strategies:
[17:48:38.382] 1. sequential:
[17:48:38.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:38.382]    - tweaked: FALSE
[17:48:38.382]    - call: NULL
[17:48:38.383] plan(): nbrOfWorkers() = 1
[17:48:38.385] plan(): Setting new future strategy stack:
[17:48:38.385] List of future strategies:
[17:48:38.385] 1. multicore:
[17:48:38.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:48:38.385]    - tweaked: FALSE
[17:48:38.385]    - call: plan(strategy)
[17:48:38.390] plan(): nbrOfWorkers() = 2
[17:48:38.391] result() for MulticoreFuture ...
[17:48:38.391] result() for MulticoreFuture ... done
[17:48:38.391] result() for MulticoreFuture ... done
[17:48:38.392] result() for MulticoreFuture ...
[17:48:38.392] result() for MulticoreFuture ... done
[17:48:38.392] result() for MulticoreFuture ...
[17:48:38.392] result() for MulticoreFuture ... done
[1] 42
[17:48:38.392] result() for MulticoreFuture ...
[17:48:38.392] result() for MulticoreFuture ... done
multicore ... done
multisession ...
[17:48:38.393] plan(): Setting new future strategy stack:
[17:48:38.393] List of future strategies:
[17:48:38.393] 1. multisession:
[17:48:38.393]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:48:38.393]    - tweaked: FALSE
[17:48:38.393]    - call: plan(strategy)
[17:48:38.394] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:48:38.394] multisession:
[17:48:38.394] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:48:38.394] - tweaked: FALSE
[17:48:38.394] - call: plan(strategy)
[17:48:38.401] getGlobalsAndPackages() ...
[17:48:38.401] Not searching for globals
[17:48:38.401] - globals: [0] <none>
[17:48:38.401] getGlobalsAndPackages() ... DONE
[17:48:38.402] [local output] makeClusterPSOCK() ...
[17:48:38.447] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:48:38.449] [local output] Base port: 11271
[17:48:38.449] [local output] Getting setup options for 2 cluster nodes ...
[17:48:38.449] [local output]  - Node 1 of 2 ...
[17:48:38.449] [local output] localMachine=TRUE => revtunnel=FALSE

[17:48:38.450] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpVGIxgu/worker.rank=1.parallelly.parent=50428.c4fc276a25c6.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpVGIxgu/worker.rank=1.parallelly.parent=50428.c4fc276a25c6.pid")'’
[17:48:38.637] - Possible to infer worker's PID: TRUE
[17:48:38.637] [local output] Rscript port: 11271

[17:48:38.637] [local output]  - Node 2 of 2 ...
[17:48:38.638] [local output] localMachine=TRUE => revtunnel=FALSE

[17:48:38.638] [local output] Rscript port: 11271

[17:48:38.639] [local output] Getting setup options for 2 cluster nodes ... done
[17:48:38.639] [local output]  - Parallel setup requested for some PSOCK nodes
[17:48:38.639] [local output] Setting up PSOCK nodes in parallel
[17:48:38.640] List of 36
[17:48:38.640]  $ worker          : chr "localhost"
[17:48:38.640]   ..- attr(*, "localhost")= logi TRUE
[17:48:38.640]  $ master          : chr "localhost"
[17:48:38.640]  $ port            : int 11271
[17:48:38.640]  $ connectTimeout  : num 120
[17:48:38.640]  $ timeout         : num 2592000
[17:48:38.640]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:48:38.640]  $ homogeneous     : logi TRUE
[17:48:38.640]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:48:38.640]  $ rscript_envs    : NULL
[17:48:38.640]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:48:38.640]  $ rscript_startup : NULL
[17:48:38.640]  $ rscript_sh      : chr "sh"
[17:48:38.640]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:48:38.640]  $ methods         : logi TRUE
[17:48:38.640]  $ socketOptions   : chr "no-delay"
[17:48:38.640]  $ useXDR          : logi FALSE
[17:48:38.640]  $ outfile         : chr "/dev/null"
[17:48:38.640]  $ renice          : int NA
[17:48:38.640]  $ rshcmd          : NULL
[17:48:38.640]  $ user            : chr(0) 
[17:48:38.640]  $ revtunnel       : logi FALSE
[17:48:38.640]  $ rshlogfile      : NULL
[17:48:38.640]  $ rshopts         : chr(0) 
[17:48:38.640]  $ rank            : int 1
[17:48:38.640]  $ manual          : logi FALSE
[17:48:38.640]  $ dryrun          : logi FALSE
[17:48:38.640]  $ quiet           : logi FALSE
[17:48:38.640]  $ setup_strategy  : chr "parallel"
[17:48:38.640]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:48:38.640]  $ pidfile         : chr "/tmp/RtmpVGIxgu/worker.rank=1.parallelly.parent=50428.c4fc276a25c6.pid"
[17:48:38.640]  $ rshcmd_label    : NULL
[17:48:38.640]  $ rsh_call        : NULL
[17:48:38.640]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:48:38.640]  $ localMachine    : logi TRUE
[17:48:38.640]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:48:38.640]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:48:38.640]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:48:38.640]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:48:38.640]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:48:38.640]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:48:38.640]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:48:38.640]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:48:38.640]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:48:38.640]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:48:38.640]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:48:38.640]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:48:38.640]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:48:38.640]  $ arguments       :List of 28
[17:48:38.640]   ..$ worker          : chr "localhost"
[17:48:38.640]   ..$ master          : NULL
[17:48:38.640]   ..$ port            : int 11271
[17:48:38.640]   ..$ connectTimeout  : num 120
[17:48:38.640]   ..$ timeout         : num 2592000
[17:48:38.640]   ..$ rscript         : NULL
[17:48:38.640]   ..$ homogeneous     : NULL
[17:48:38.640]   ..$ rscript_args    : NULL
[17:48:38.640]   ..$ rscript_envs    : NULL
[17:48:38.640]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:48:38.640]   ..$ rscript_startup : NULL
[17:48:38.640]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:48:38.640]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:48:38.640]   ..$ methods         : logi TRUE
[17:48:38.640]   ..$ socketOptions   : chr "no-delay"
[17:48:38.640]   ..$ useXDR          : logi FALSE
[17:48:38.640]   ..$ outfile         : chr "/dev/null"
[17:48:38.640]   ..$ renice          : int NA
[17:48:38.640]   ..$ rshcmd          : NULL
[17:48:38.640]   ..$ user            : NULL
[17:48:38.640]   ..$ revtunnel       : logi NA
[17:48:38.640]   ..$ rshlogfile      : NULL
[17:48:38.640]   ..$ rshopts         : NULL
[17:48:38.640]   ..$ rank            : int 1
[17:48:38.640]   ..$ manual          : logi FALSE
[17:48:38.640]   ..$ dryrun          : logi FALSE
[17:48:38.640]   ..$ quiet           : logi FALSE
[17:48:38.640]   ..$ setup_strategy  : chr "parallel"
[17:48:38.640]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:48:38.656] [local output] System call to launch all workers:
[17:48:38.656] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpVGIxgu/worker.rank=1.parallelly.parent=50428.c4fc276a25c6.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11271 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:48:38.656] [local output] Starting PSOCK main server
[17:48:38.661] [local output] Workers launched
[17:48:38.662] [local output] Waiting for workers to connect back
[17:48:38.662]  - [local output] 0 workers out of 2 ready
[17:48:38.905]  - [local output] 0 workers out of 2 ready
[17:48:38.905]  - [local output] 1 workers out of 2 ready
[17:48:38.910]  - [local output] 1 workers out of 2 ready
[17:48:38.910]  - [local output] 2 workers out of 2 ready
[17:48:38.910] [local output] Launching of workers completed
[17:48:38.910] [local output] Collecting session information from workers
[17:48:38.911] [local output]  - Worker #1 of 2
[17:48:38.912] [local output]  - Worker #2 of 2
[17:48:38.912] [local output] makeClusterPSOCK() ... done
[17:48:38.924] Packages needed by the future expression (n = 0): <none>
[17:48:38.924] Packages needed by future strategies (n = 0): <none>
[17:48:38.925] {
[17:48:38.925]     {
[17:48:38.925]         {
[17:48:38.925]             ...future.startTime <- base::Sys.time()
[17:48:38.925]             {
[17:48:38.925]                 {
[17:48:38.925]                   {
[17:48:38.925]                     {
[17:48:38.925]                       base::local({
[17:48:38.925]                         has_future <- base::requireNamespace("future", 
[17:48:38.925]                           quietly = TRUE)
[17:48:38.925]                         if (has_future) {
[17:48:38.925]                           ns <- base::getNamespace("future")
[17:48:38.925]                           version <- ns[[".package"]][["version"]]
[17:48:38.925]                           if (is.null(version)) 
[17:48:38.925]                             version <- utils::packageVersion("future")
[17:48:38.925]                         }
[17:48:38.925]                         else {
[17:48:38.925]                           version <- NULL
[17:48:38.925]                         }
[17:48:38.925]                         if (!has_future || version < "1.8.0") {
[17:48:38.925]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:38.925]                             "", base::R.version$version.string), 
[17:48:38.925]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:38.925]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:38.925]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:38.925]                               "release", "version")], collapse = " "), 
[17:48:38.925]                             hostname = base::Sys.info()[["nodename"]])
[17:48:38.925]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:38.925]                             info)
[17:48:38.925]                           info <- base::paste(info, collapse = "; ")
[17:48:38.925]                           if (!has_future) {
[17:48:38.925]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:38.925]                               info)
[17:48:38.925]                           }
[17:48:38.925]                           else {
[17:48:38.925]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:38.925]                               info, version)
[17:48:38.925]                           }
[17:48:38.925]                           base::stop(msg)
[17:48:38.925]                         }
[17:48:38.925]                       })
[17:48:38.925]                     }
[17:48:38.925]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:38.925]                     base::options(mc.cores = 1L)
[17:48:38.925]                   }
[17:48:38.925]                   ...future.strategy.old <- future::plan("list")
[17:48:38.925]                   options(future.plan = NULL)
[17:48:38.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:38.925]                 }
[17:48:38.925]                 ...future.workdir <- getwd()
[17:48:38.925]             }
[17:48:38.925]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:38.925]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:38.925]         }
[17:48:38.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:38.925]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:38.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:38.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:38.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:38.925]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:38.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:38.925]             base::names(...future.oldOptions))
[17:48:38.925]     }
[17:48:38.925]     if (FALSE) {
[17:48:38.925]     }
[17:48:38.925]     else {
[17:48:38.925]         if (TRUE) {
[17:48:38.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:38.925]                 open = "w")
[17:48:38.925]         }
[17:48:38.925]         else {
[17:48:38.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:38.925]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:38.925]         }
[17:48:38.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:38.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:38.925]             base::sink(type = "output", split = FALSE)
[17:48:38.925]             base::close(...future.stdout)
[17:48:38.925]         }, add = TRUE)
[17:48:38.925]     }
[17:48:38.925]     ...future.frame <- base::sys.nframe()
[17:48:38.925]     ...future.conditions <- base::list()
[17:48:38.925]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:38.925]     if (FALSE) {
[17:48:38.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:38.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:38.925]     }
[17:48:38.925]     ...future.result <- base::tryCatch({
[17:48:38.925]         base::withCallingHandlers({
[17:48:38.925]             ...future.value <- base::withVisible(base::local({
[17:48:38.925]                 ...future.makeSendCondition <- base::local({
[17:48:38.925]                   sendCondition <- NULL
[17:48:38.925]                   function(frame = 1L) {
[17:48:38.925]                     if (is.function(sendCondition)) 
[17:48:38.925]                       return(sendCondition)
[17:48:38.925]                     ns <- getNamespace("parallel")
[17:48:38.925]                     if (exists("sendData", mode = "function", 
[17:48:38.925]                       envir = ns)) {
[17:48:38.925]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:38.925]                         envir = ns)
[17:48:38.925]                       envir <- sys.frame(frame)
[17:48:38.925]                       master <- NULL
[17:48:38.925]                       while (!identical(envir, .GlobalEnv) && 
[17:48:38.925]                         !identical(envir, emptyenv())) {
[17:48:38.925]                         if (exists("master", mode = "list", envir = envir, 
[17:48:38.925]                           inherits = FALSE)) {
[17:48:38.925]                           master <- get("master", mode = "list", 
[17:48:38.925]                             envir = envir, inherits = FALSE)
[17:48:38.925]                           if (inherits(master, c("SOCKnode", 
[17:48:38.925]                             "SOCK0node"))) {
[17:48:38.925]                             sendCondition <<- function(cond) {
[17:48:38.925]                               data <- list(type = "VALUE", value = cond, 
[17:48:38.925]                                 success = TRUE)
[17:48:38.925]                               parallel_sendData(master, data)
[17:48:38.925]                             }
[17:48:38.925]                             return(sendCondition)
[17:48:38.925]                           }
[17:48:38.925]                         }
[17:48:38.925]                         frame <- frame + 1L
[17:48:38.925]                         envir <- sys.frame(frame)
[17:48:38.925]                       }
[17:48:38.925]                     }
[17:48:38.925]                     sendCondition <<- function(cond) NULL
[17:48:38.925]                   }
[17:48:38.925]                 })
[17:48:38.925]                 withCallingHandlers({
[17:48:38.925]                   NA
[17:48:38.925]                 }, immediateCondition = function(cond) {
[17:48:38.925]                   sendCondition <- ...future.makeSendCondition()
[17:48:38.925]                   sendCondition(cond)
[17:48:38.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.925]                   {
[17:48:38.925]                     inherits <- base::inherits
[17:48:38.925]                     invokeRestart <- base::invokeRestart
[17:48:38.925]                     is.null <- base::is.null
[17:48:38.925]                     muffled <- FALSE
[17:48:38.925]                     if (inherits(cond, "message")) {
[17:48:38.925]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:38.925]                       if (muffled) 
[17:48:38.925]                         invokeRestart("muffleMessage")
[17:48:38.925]                     }
[17:48:38.925]                     else if (inherits(cond, "warning")) {
[17:48:38.925]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:38.925]                       if (muffled) 
[17:48:38.925]                         invokeRestart("muffleWarning")
[17:48:38.925]                     }
[17:48:38.925]                     else if (inherits(cond, "condition")) {
[17:48:38.925]                       if (!is.null(pattern)) {
[17:48:38.925]                         computeRestarts <- base::computeRestarts
[17:48:38.925]                         grepl <- base::grepl
[17:48:38.925]                         restarts <- computeRestarts(cond)
[17:48:38.925]                         for (restart in restarts) {
[17:48:38.925]                           name <- restart$name
[17:48:38.925]                           if (is.null(name)) 
[17:48:38.925]                             next
[17:48:38.925]                           if (!grepl(pattern, name)) 
[17:48:38.925]                             next
[17:48:38.925]                           invokeRestart(restart)
[17:48:38.925]                           muffled <- TRUE
[17:48:38.925]                           break
[17:48:38.925]                         }
[17:48:38.925]                       }
[17:48:38.925]                     }
[17:48:38.925]                     invisible(muffled)
[17:48:38.925]                   }
[17:48:38.925]                   muffleCondition(cond)
[17:48:38.925]                 })
[17:48:38.925]             }))
[17:48:38.925]             future::FutureResult(value = ...future.value$value, 
[17:48:38.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.925]                   ...future.rng), globalenv = if (FALSE) 
[17:48:38.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:38.925]                     ...future.globalenv.names))
[17:48:38.925]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:38.925]         }, condition = base::local({
[17:48:38.925]             c <- base::c
[17:48:38.925]             inherits <- base::inherits
[17:48:38.925]             invokeRestart <- base::invokeRestart
[17:48:38.925]             length <- base::length
[17:48:38.925]             list <- base::list
[17:48:38.925]             seq.int <- base::seq.int
[17:48:38.925]             signalCondition <- base::signalCondition
[17:48:38.925]             sys.calls <- base::sys.calls
[17:48:38.925]             `[[` <- base::`[[`
[17:48:38.925]             `+` <- base::`+`
[17:48:38.925]             `<<-` <- base::`<<-`
[17:48:38.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:38.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:38.925]                   3L)]
[17:48:38.925]             }
[17:48:38.925]             function(cond) {
[17:48:38.925]                 is_error <- inherits(cond, "error")
[17:48:38.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:38.925]                   NULL)
[17:48:38.925]                 if (is_error) {
[17:48:38.925]                   sessionInformation <- function() {
[17:48:38.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:38.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:38.925]                       search = base::search(), system = base::Sys.info())
[17:48:38.925]                   }
[17:48:38.925]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:38.925]                     cond$call), session = sessionInformation(), 
[17:48:38.925]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:38.925]                   signalCondition(cond)
[17:48:38.925]                 }
[17:48:38.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:38.925]                 "immediateCondition"))) {
[17:48:38.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:38.925]                   ...future.conditions[[length(...future.conditions) + 
[17:48:38.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:38.925]                   if (TRUE && !signal) {
[17:48:38.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.925]                     {
[17:48:38.925]                       inherits <- base::inherits
[17:48:38.925]                       invokeRestart <- base::invokeRestart
[17:48:38.925]                       is.null <- base::is.null
[17:48:38.925]                       muffled <- FALSE
[17:48:38.925]                       if (inherits(cond, "message")) {
[17:48:38.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.925]                         if (muffled) 
[17:48:38.925]                           invokeRestart("muffleMessage")
[17:48:38.925]                       }
[17:48:38.925]                       else if (inherits(cond, "warning")) {
[17:48:38.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.925]                         if (muffled) 
[17:48:38.925]                           invokeRestart("muffleWarning")
[17:48:38.925]                       }
[17:48:38.925]                       else if (inherits(cond, "condition")) {
[17:48:38.925]                         if (!is.null(pattern)) {
[17:48:38.925]                           computeRestarts <- base::computeRestarts
[17:48:38.925]                           grepl <- base::grepl
[17:48:38.925]                           restarts <- computeRestarts(cond)
[17:48:38.925]                           for (restart in restarts) {
[17:48:38.925]                             name <- restart$name
[17:48:38.925]                             if (is.null(name)) 
[17:48:38.925]                               next
[17:48:38.925]                             if (!grepl(pattern, name)) 
[17:48:38.925]                               next
[17:48:38.925]                             invokeRestart(restart)
[17:48:38.925]                             muffled <- TRUE
[17:48:38.925]                             break
[17:48:38.925]                           }
[17:48:38.925]                         }
[17:48:38.925]                       }
[17:48:38.925]                       invisible(muffled)
[17:48:38.925]                     }
[17:48:38.925]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.925]                   }
[17:48:38.925]                 }
[17:48:38.925]                 else {
[17:48:38.925]                   if (TRUE) {
[17:48:38.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:38.925]                     {
[17:48:38.925]                       inherits <- base::inherits
[17:48:38.925]                       invokeRestart <- base::invokeRestart
[17:48:38.925]                       is.null <- base::is.null
[17:48:38.925]                       muffled <- FALSE
[17:48:38.925]                       if (inherits(cond, "message")) {
[17:48:38.925]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:38.925]                         if (muffled) 
[17:48:38.925]                           invokeRestart("muffleMessage")
[17:48:38.925]                       }
[17:48:38.925]                       else if (inherits(cond, "warning")) {
[17:48:38.925]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:38.925]                         if (muffled) 
[17:48:38.925]                           invokeRestart("muffleWarning")
[17:48:38.925]                       }
[17:48:38.925]                       else if (inherits(cond, "condition")) {
[17:48:38.925]                         if (!is.null(pattern)) {
[17:48:38.925]                           computeRestarts <- base::computeRestarts
[17:48:38.925]                           grepl <- base::grepl
[17:48:38.925]                           restarts <- computeRestarts(cond)
[17:48:38.925]                           for (restart in restarts) {
[17:48:38.925]                             name <- restart$name
[17:48:38.925]                             if (is.null(name)) 
[17:48:38.925]                               next
[17:48:38.925]                             if (!grepl(pattern, name)) 
[17:48:38.925]                               next
[17:48:38.925]                             invokeRestart(restart)
[17:48:38.925]                             muffled <- TRUE
[17:48:38.925]                             break
[17:48:38.925]                           }
[17:48:38.925]                         }
[17:48:38.925]                       }
[17:48:38.925]                       invisible(muffled)
[17:48:38.925]                     }
[17:48:38.925]                     muffleCondition(cond, pattern = "^muffle")
[17:48:38.925]                   }
[17:48:38.925]                 }
[17:48:38.925]             }
[17:48:38.925]         }))
[17:48:38.925]     }, error = function(ex) {
[17:48:38.925]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:38.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:38.925]                 ...future.rng), started = ...future.startTime, 
[17:48:38.925]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:38.925]             version = "1.8"), class = "FutureResult")
[17:48:38.925]     }, finally = {
[17:48:38.925]         if (!identical(...future.workdir, getwd())) 
[17:48:38.925]             setwd(...future.workdir)
[17:48:38.925]         {
[17:48:38.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:38.925]                 ...future.oldOptions$nwarnings <- NULL
[17:48:38.925]             }
[17:48:38.925]             base::options(...future.oldOptions)
[17:48:38.925]             if (.Platform$OS.type == "windows") {
[17:48:38.925]                 old_names <- names(...future.oldEnvVars)
[17:48:38.925]                 envs <- base::Sys.getenv()
[17:48:38.925]                 names <- names(envs)
[17:48:38.925]                 common <- intersect(names, old_names)
[17:48:38.925]                 added <- setdiff(names, old_names)
[17:48:38.925]                 removed <- setdiff(old_names, names)
[17:48:38.925]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:38.925]                   envs[common]]
[17:48:38.925]                 NAMES <- toupper(changed)
[17:48:38.925]                 args <- list()
[17:48:38.925]                 for (kk in seq_along(NAMES)) {
[17:48:38.925]                   name <- changed[[kk]]
[17:48:38.925]                   NAME <- NAMES[[kk]]
[17:48:38.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.925]                     next
[17:48:38.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.925]                 }
[17:48:38.925]                 NAMES <- toupper(added)
[17:48:38.925]                 for (kk in seq_along(NAMES)) {
[17:48:38.925]                   name <- added[[kk]]
[17:48:38.925]                   NAME <- NAMES[[kk]]
[17:48:38.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.925]                     next
[17:48:38.925]                   args[[name]] <- ""
[17:48:38.925]                 }
[17:48:38.925]                 NAMES <- toupper(removed)
[17:48:38.925]                 for (kk in seq_along(NAMES)) {
[17:48:38.925]                   name <- removed[[kk]]
[17:48:38.925]                   NAME <- NAMES[[kk]]
[17:48:38.925]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:38.925]                     next
[17:48:38.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:38.925]                 }
[17:48:38.925]                 if (length(args) > 0) 
[17:48:38.925]                   base::do.call(base::Sys.setenv, args = args)
[17:48:38.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:38.925]             }
[17:48:38.925]             else {
[17:48:38.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:38.925]             }
[17:48:38.925]             {
[17:48:38.925]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:38.925]                   0L) {
[17:48:38.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:38.925]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:38.925]                   base::options(opts)
[17:48:38.925]                 }
[17:48:38.925]                 {
[17:48:38.925]                   {
[17:48:38.925]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:38.925]                     NULL
[17:48:38.925]                   }
[17:48:38.925]                   options(future.plan = NULL)
[17:48:38.925]                   if (is.na(NA_character_)) 
[17:48:38.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:38.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:38.925]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:38.925]                     .init = FALSE)
[17:48:38.925]                 }
[17:48:38.925]             }
[17:48:38.925]         }
[17:48:38.925]     })
[17:48:38.925]     if (TRUE) {
[17:48:38.925]         base::sink(type = "output", split = FALSE)
[17:48:38.925]         if (TRUE) {
[17:48:38.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:38.925]         }
[17:48:38.925]         else {
[17:48:38.925]             ...future.result["stdout"] <- base::list(NULL)
[17:48:38.925]         }
[17:48:38.925]         base::close(...future.stdout)
[17:48:38.925]         ...future.stdout <- NULL
[17:48:38.925]     }
[17:48:38.925]     ...future.result$conditions <- ...future.conditions
[17:48:38.925]     ...future.result$finished <- base::Sys.time()
[17:48:38.925]     ...future.result
[17:48:38.925] }
[17:48:38.976] MultisessionFuture started
[17:48:38.977] result() for ClusterFuture ...
[17:48:38.977] receiveMessageFromWorker() for ClusterFuture ...
[17:48:38.977] - Validating connection of MultisessionFuture
[17:48:39.008] - received message: FutureResult
[17:48:39.008] - Received FutureResult
[17:48:39.009] - Erased future from FutureRegistry
[17:48:39.009] result() for ClusterFuture ...
[17:48:39.009] - result already collected: FutureResult
[17:48:39.009] result() for ClusterFuture ... done
[17:48:39.009] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.009] result() for ClusterFuture ... done
[17:48:39.009] result() for ClusterFuture ...
[17:48:39.009] - result already collected: FutureResult
[17:48:39.009] result() for ClusterFuture ... done
[17:48:39.010] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:48:39.014] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[17:48:39.014] getGlobalsAndPackages() ...
[17:48:39.014] Searching for globals...
[17:48:39.018] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:39.018] Searching for globals ... DONE
[17:48:39.018] Resolving globals: FALSE
[17:48:39.019] 
[17:48:39.019] - packages: [1] ‘utils’
[17:48:39.019] getGlobalsAndPackages() ... DONE
[17:48:39.019] run() for ‘Future’ ...
[17:48:39.019] - state: ‘created’
[17:48:39.020] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.034] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.034]   - Field: ‘node’
[17:48:39.034]   - Field: ‘label’
[17:48:39.034]   - Field: ‘local’
[17:48:39.034]   - Field: ‘owner’
[17:48:39.034]   - Field: ‘envir’
[17:48:39.034]   - Field: ‘workers’
[17:48:39.034]   - Field: ‘packages’
[17:48:39.034]   - Field: ‘gc’
[17:48:39.035]   - Field: ‘conditions’
[17:48:39.035]   - Field: ‘persistent’
[17:48:39.035]   - Field: ‘expr’
[17:48:39.035]   - Field: ‘uuid’
[17:48:39.035]   - Field: ‘seed’
[17:48:39.035]   - Field: ‘version’
[17:48:39.035]   - Field: ‘result’
[17:48:39.035]   - Field: ‘asynchronous’
[17:48:39.036]   - Field: ‘calls’
[17:48:39.036]   - Field: ‘globals’
[17:48:39.036]   - Field: ‘stdout’
[17:48:39.036]   - Field: ‘earlySignal’
[17:48:39.036]   - Field: ‘lazy’
[17:48:39.036]   - Field: ‘state’
[17:48:39.036] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.036] - Launch lazy future ...
[17:48:39.037] Packages needed by the future expression (n = 1): ‘utils’
[17:48:39.037] Packages needed by future strategies (n = 0): <none>
[17:48:39.037] {
[17:48:39.037]     {
[17:48:39.037]         {
[17:48:39.037]             ...future.startTime <- base::Sys.time()
[17:48:39.037]             {
[17:48:39.037]                 {
[17:48:39.037]                   {
[17:48:39.037]                     {
[17:48:39.037]                       {
[17:48:39.037]                         base::local({
[17:48:39.037]                           has_future <- base::requireNamespace("future", 
[17:48:39.037]                             quietly = TRUE)
[17:48:39.037]                           if (has_future) {
[17:48:39.037]                             ns <- base::getNamespace("future")
[17:48:39.037]                             version <- ns[[".package"]][["version"]]
[17:48:39.037]                             if (is.null(version)) 
[17:48:39.037]                               version <- utils::packageVersion("future")
[17:48:39.037]                           }
[17:48:39.037]                           else {
[17:48:39.037]                             version <- NULL
[17:48:39.037]                           }
[17:48:39.037]                           if (!has_future || version < "1.8.0") {
[17:48:39.037]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.037]                               "", base::R.version$version.string), 
[17:48:39.037]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:39.037]                                 base::R.version$platform, 8 * 
[17:48:39.037]                                   base::.Machine$sizeof.pointer), 
[17:48:39.037]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.037]                                 "release", "version")], collapse = " "), 
[17:48:39.037]                               hostname = base::Sys.info()[["nodename"]])
[17:48:39.037]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.037]                               info)
[17:48:39.037]                             info <- base::paste(info, collapse = "; ")
[17:48:39.037]                             if (!has_future) {
[17:48:39.037]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.037]                                 info)
[17:48:39.037]                             }
[17:48:39.037]                             else {
[17:48:39.037]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.037]                                 info, version)
[17:48:39.037]                             }
[17:48:39.037]                             base::stop(msg)
[17:48:39.037]                           }
[17:48:39.037]                         })
[17:48:39.037]                       }
[17:48:39.037]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.037]                       base::options(mc.cores = 1L)
[17:48:39.037]                     }
[17:48:39.037]                     base::local({
[17:48:39.037]                       for (pkg in "utils") {
[17:48:39.037]                         base::loadNamespace(pkg)
[17:48:39.037]                         base::library(pkg, character.only = TRUE)
[17:48:39.037]                       }
[17:48:39.037]                     })
[17:48:39.037]                   }
[17:48:39.037]                   ...future.strategy.old <- future::plan("list")
[17:48:39.037]                   options(future.plan = NULL)
[17:48:39.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.037]                 }
[17:48:39.037]                 ...future.workdir <- getwd()
[17:48:39.037]             }
[17:48:39.037]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.037]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.037]         }
[17:48:39.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.037]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.037]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.037]             base::names(...future.oldOptions))
[17:48:39.037]     }
[17:48:39.037]     if (FALSE) {
[17:48:39.037]     }
[17:48:39.037]     else {
[17:48:39.037]         if (TRUE) {
[17:48:39.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.037]                 open = "w")
[17:48:39.037]         }
[17:48:39.037]         else {
[17:48:39.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.037]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.037]         }
[17:48:39.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.037]             base::sink(type = "output", split = FALSE)
[17:48:39.037]             base::close(...future.stdout)
[17:48:39.037]         }, add = TRUE)
[17:48:39.037]     }
[17:48:39.037]     ...future.frame <- base::sys.nframe()
[17:48:39.037]     ...future.conditions <- base::list()
[17:48:39.037]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.037]     if (FALSE) {
[17:48:39.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.037]     }
[17:48:39.037]     ...future.result <- base::tryCatch({
[17:48:39.037]         base::withCallingHandlers({
[17:48:39.037]             ...future.value <- base::withVisible(base::local({
[17:48:39.037]                 ...future.makeSendCondition <- base::local({
[17:48:39.037]                   sendCondition <- NULL
[17:48:39.037]                   function(frame = 1L) {
[17:48:39.037]                     if (is.function(sendCondition)) 
[17:48:39.037]                       return(sendCondition)
[17:48:39.037]                     ns <- getNamespace("parallel")
[17:48:39.037]                     if (exists("sendData", mode = "function", 
[17:48:39.037]                       envir = ns)) {
[17:48:39.037]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.037]                         envir = ns)
[17:48:39.037]                       envir <- sys.frame(frame)
[17:48:39.037]                       master <- NULL
[17:48:39.037]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.037]                         !identical(envir, emptyenv())) {
[17:48:39.037]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.037]                           inherits = FALSE)) {
[17:48:39.037]                           master <- get("master", mode = "list", 
[17:48:39.037]                             envir = envir, inherits = FALSE)
[17:48:39.037]                           if (inherits(master, c("SOCKnode", 
[17:48:39.037]                             "SOCK0node"))) {
[17:48:39.037]                             sendCondition <<- function(cond) {
[17:48:39.037]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.037]                                 success = TRUE)
[17:48:39.037]                               parallel_sendData(master, data)
[17:48:39.037]                             }
[17:48:39.037]                             return(sendCondition)
[17:48:39.037]                           }
[17:48:39.037]                         }
[17:48:39.037]                         frame <- frame + 1L
[17:48:39.037]                         envir <- sys.frame(frame)
[17:48:39.037]                       }
[17:48:39.037]                     }
[17:48:39.037]                     sendCondition <<- function(cond) NULL
[17:48:39.037]                   }
[17:48:39.037]                 })
[17:48:39.037]                 withCallingHandlers({
[17:48:39.037]                   {
[17:48:39.037]                     print(1:50)
[17:48:39.037]                     str(1:50)
[17:48:39.037]                     cat(letters, sep = "-")
[17:48:39.037]                     cat(1:6, collapse = "\n")
[17:48:39.037]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:39.037]                     42L
[17:48:39.037]                   }
[17:48:39.037]                 }, immediateCondition = function(cond) {
[17:48:39.037]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.037]                   sendCondition(cond)
[17:48:39.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.037]                   {
[17:48:39.037]                     inherits <- base::inherits
[17:48:39.037]                     invokeRestart <- base::invokeRestart
[17:48:39.037]                     is.null <- base::is.null
[17:48:39.037]                     muffled <- FALSE
[17:48:39.037]                     if (inherits(cond, "message")) {
[17:48:39.037]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.037]                       if (muffled) 
[17:48:39.037]                         invokeRestart("muffleMessage")
[17:48:39.037]                     }
[17:48:39.037]                     else if (inherits(cond, "warning")) {
[17:48:39.037]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.037]                       if (muffled) 
[17:48:39.037]                         invokeRestart("muffleWarning")
[17:48:39.037]                     }
[17:48:39.037]                     else if (inherits(cond, "condition")) {
[17:48:39.037]                       if (!is.null(pattern)) {
[17:48:39.037]                         computeRestarts <- base::computeRestarts
[17:48:39.037]                         grepl <- base::grepl
[17:48:39.037]                         restarts <- computeRestarts(cond)
[17:48:39.037]                         for (restart in restarts) {
[17:48:39.037]                           name <- restart$name
[17:48:39.037]                           if (is.null(name)) 
[17:48:39.037]                             next
[17:48:39.037]                           if (!grepl(pattern, name)) 
[17:48:39.037]                             next
[17:48:39.037]                           invokeRestart(restart)
[17:48:39.037]                           muffled <- TRUE
[17:48:39.037]                           break
[17:48:39.037]                         }
[17:48:39.037]                       }
[17:48:39.037]                     }
[17:48:39.037]                     invisible(muffled)
[17:48:39.037]                   }
[17:48:39.037]                   muffleCondition(cond)
[17:48:39.037]                 })
[17:48:39.037]             }))
[17:48:39.037]             future::FutureResult(value = ...future.value$value, 
[17:48:39.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.037]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.037]                     ...future.globalenv.names))
[17:48:39.037]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.037]         }, condition = base::local({
[17:48:39.037]             c <- base::c
[17:48:39.037]             inherits <- base::inherits
[17:48:39.037]             invokeRestart <- base::invokeRestart
[17:48:39.037]             length <- base::length
[17:48:39.037]             list <- base::list
[17:48:39.037]             seq.int <- base::seq.int
[17:48:39.037]             signalCondition <- base::signalCondition
[17:48:39.037]             sys.calls <- base::sys.calls
[17:48:39.037]             `[[` <- base::`[[`
[17:48:39.037]             `+` <- base::`+`
[17:48:39.037]             `<<-` <- base::`<<-`
[17:48:39.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.037]                   3L)]
[17:48:39.037]             }
[17:48:39.037]             function(cond) {
[17:48:39.037]                 is_error <- inherits(cond, "error")
[17:48:39.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.037]                   NULL)
[17:48:39.037]                 if (is_error) {
[17:48:39.037]                   sessionInformation <- function() {
[17:48:39.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.037]                       search = base::search(), system = base::Sys.info())
[17:48:39.037]                   }
[17:48:39.037]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.037]                     cond$call), session = sessionInformation(), 
[17:48:39.037]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.037]                   signalCondition(cond)
[17:48:39.037]                 }
[17:48:39.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.037]                 "immediateCondition"))) {
[17:48:39.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.037]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.037]                   if (TRUE && !signal) {
[17:48:39.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.037]                     {
[17:48:39.037]                       inherits <- base::inherits
[17:48:39.037]                       invokeRestart <- base::invokeRestart
[17:48:39.037]                       is.null <- base::is.null
[17:48:39.037]                       muffled <- FALSE
[17:48:39.037]                       if (inherits(cond, "message")) {
[17:48:39.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.037]                         if (muffled) 
[17:48:39.037]                           invokeRestart("muffleMessage")
[17:48:39.037]                       }
[17:48:39.037]                       else if (inherits(cond, "warning")) {
[17:48:39.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.037]                         if (muffled) 
[17:48:39.037]                           invokeRestart("muffleWarning")
[17:48:39.037]                       }
[17:48:39.037]                       else if (inherits(cond, "condition")) {
[17:48:39.037]                         if (!is.null(pattern)) {
[17:48:39.037]                           computeRestarts <- base::computeRestarts
[17:48:39.037]                           grepl <- base::grepl
[17:48:39.037]                           restarts <- computeRestarts(cond)
[17:48:39.037]                           for (restart in restarts) {
[17:48:39.037]                             name <- restart$name
[17:48:39.037]                             if (is.null(name)) 
[17:48:39.037]                               next
[17:48:39.037]                             if (!grepl(pattern, name)) 
[17:48:39.037]                               next
[17:48:39.037]                             invokeRestart(restart)
[17:48:39.037]                             muffled <- TRUE
[17:48:39.037]                             break
[17:48:39.037]                           }
[17:48:39.037]                         }
[17:48:39.037]                       }
[17:48:39.037]                       invisible(muffled)
[17:48:39.037]                     }
[17:48:39.037]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.037]                   }
[17:48:39.037]                 }
[17:48:39.037]                 else {
[17:48:39.037]                   if (TRUE) {
[17:48:39.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.037]                     {
[17:48:39.037]                       inherits <- base::inherits
[17:48:39.037]                       invokeRestart <- base::invokeRestart
[17:48:39.037]                       is.null <- base::is.null
[17:48:39.037]                       muffled <- FALSE
[17:48:39.037]                       if (inherits(cond, "message")) {
[17:48:39.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.037]                         if (muffled) 
[17:48:39.037]                           invokeRestart("muffleMessage")
[17:48:39.037]                       }
[17:48:39.037]                       else if (inherits(cond, "warning")) {
[17:48:39.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.037]                         if (muffled) 
[17:48:39.037]                           invokeRestart("muffleWarning")
[17:48:39.037]                       }
[17:48:39.037]                       else if (inherits(cond, "condition")) {
[17:48:39.037]                         if (!is.null(pattern)) {
[17:48:39.037]                           computeRestarts <- base::computeRestarts
[17:48:39.037]                           grepl <- base::grepl
[17:48:39.037]                           restarts <- computeRestarts(cond)
[17:48:39.037]                           for (restart in restarts) {
[17:48:39.037]                             name <- restart$name
[17:48:39.037]                             if (is.null(name)) 
[17:48:39.037]                               next
[17:48:39.037]                             if (!grepl(pattern, name)) 
[17:48:39.037]                               next
[17:48:39.037]                             invokeRestart(restart)
[17:48:39.037]                             muffled <- TRUE
[17:48:39.037]                             break
[17:48:39.037]                           }
[17:48:39.037]                         }
[17:48:39.037]                       }
[17:48:39.037]                       invisible(muffled)
[17:48:39.037]                     }
[17:48:39.037]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.037]                   }
[17:48:39.037]                 }
[17:48:39.037]             }
[17:48:39.037]         }))
[17:48:39.037]     }, error = function(ex) {
[17:48:39.037]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.037]                 ...future.rng), started = ...future.startTime, 
[17:48:39.037]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.037]             version = "1.8"), class = "FutureResult")
[17:48:39.037]     }, finally = {
[17:48:39.037]         if (!identical(...future.workdir, getwd())) 
[17:48:39.037]             setwd(...future.workdir)
[17:48:39.037]         {
[17:48:39.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.037]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.037]             }
[17:48:39.037]             base::options(...future.oldOptions)
[17:48:39.037]             if (.Platform$OS.type == "windows") {
[17:48:39.037]                 old_names <- names(...future.oldEnvVars)
[17:48:39.037]                 envs <- base::Sys.getenv()
[17:48:39.037]                 names <- names(envs)
[17:48:39.037]                 common <- intersect(names, old_names)
[17:48:39.037]                 added <- setdiff(names, old_names)
[17:48:39.037]                 removed <- setdiff(old_names, names)
[17:48:39.037]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.037]                   envs[common]]
[17:48:39.037]                 NAMES <- toupper(changed)
[17:48:39.037]                 args <- list()
[17:48:39.037]                 for (kk in seq_along(NAMES)) {
[17:48:39.037]                   name <- changed[[kk]]
[17:48:39.037]                   NAME <- NAMES[[kk]]
[17:48:39.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.037]                     next
[17:48:39.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.037]                 }
[17:48:39.037]                 NAMES <- toupper(added)
[17:48:39.037]                 for (kk in seq_along(NAMES)) {
[17:48:39.037]                   name <- added[[kk]]
[17:48:39.037]                   NAME <- NAMES[[kk]]
[17:48:39.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.037]                     next
[17:48:39.037]                   args[[name]] <- ""
[17:48:39.037]                 }
[17:48:39.037]                 NAMES <- toupper(removed)
[17:48:39.037]                 for (kk in seq_along(NAMES)) {
[17:48:39.037]                   name <- removed[[kk]]
[17:48:39.037]                   NAME <- NAMES[[kk]]
[17:48:39.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.037]                     next
[17:48:39.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.037]                 }
[17:48:39.037]                 if (length(args) > 0) 
[17:48:39.037]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.037]             }
[17:48:39.037]             else {
[17:48:39.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.037]             }
[17:48:39.037]             {
[17:48:39.037]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.037]                   0L) {
[17:48:39.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.037]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.037]                   base::options(opts)
[17:48:39.037]                 }
[17:48:39.037]                 {
[17:48:39.037]                   {
[17:48:39.037]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.037]                     NULL
[17:48:39.037]                   }
[17:48:39.037]                   options(future.plan = NULL)
[17:48:39.037]                   if (is.na(NA_character_)) 
[17:48:39.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.037]                     .init = FALSE)
[17:48:39.037]                 }
[17:48:39.037]             }
[17:48:39.037]         }
[17:48:39.037]     })
[17:48:39.037]     if (TRUE) {
[17:48:39.037]         base::sink(type = "output", split = FALSE)
[17:48:39.037]         if (TRUE) {
[17:48:39.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.037]         }
[17:48:39.037]         else {
[17:48:39.037]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.037]         }
[17:48:39.037]         base::close(...future.stdout)
[17:48:39.037]         ...future.stdout <- NULL
[17:48:39.037]     }
[17:48:39.037]     ...future.result$conditions <- ...future.conditions
[17:48:39.037]     ...future.result$finished <- base::Sys.time()
[17:48:39.037]     ...future.result
[17:48:39.037] }
[17:48:39.041] MultisessionFuture started
[17:48:39.041] - Launch lazy future ... done
[17:48:39.041] run() for ‘MultisessionFuture’ ... done
[17:48:39.042] result() for ClusterFuture ...
[17:48:39.042] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.042] - Validating connection of MultisessionFuture
[17:48:39.093] - received message: FutureResult
[17:48:39.093] - Received FutureResult
[17:48:39.093] - Erased future from FutureRegistry
[17:48:39.094] result() for ClusterFuture ...
[17:48:39.094] - result already collected: FutureResult
[17:48:39.094] result() for ClusterFuture ... done
[17:48:39.094] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.094] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:39"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:39"
 $ session_uuid: chr "e31724b7-b062-c0e2-d1f7-8754e7686beb"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50530
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:38"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:39.104] result() for ClusterFuture ...
[17:48:39.104] - result already collected: FutureResult
[17:48:39.104] result() for ClusterFuture ... done
[17:48:39.104] result() for ClusterFuture ...
[17:48:39.104] - result already collected: FutureResult
[17:48:39.104] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.009183168 secs (started 2024-11-22 17:48:39.084048)
version: 1.8
[17:48:39.105] getGlobalsAndPackages() ...
[17:48:39.105] Searching for globals...
[17:48:39.109] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:39.109] Searching for globals ... DONE
[17:48:39.109] Resolving globals: FALSE
[17:48:39.110] 
[17:48:39.110] - packages: [1] ‘utils’
[17:48:39.110] getGlobalsAndPackages() ... DONE
[17:48:39.110] run() for ‘Future’ ...
[17:48:39.111] - state: ‘created’
[17:48:39.111] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.126] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.126]   - Field: ‘node’
[17:48:39.126]   - Field: ‘label’
[17:48:39.126]   - Field: ‘local’
[17:48:39.126]   - Field: ‘owner’
[17:48:39.127]   - Field: ‘envir’
[17:48:39.127]   - Field: ‘workers’
[17:48:39.127]   - Field: ‘packages’
[17:48:39.127]   - Field: ‘gc’
[17:48:39.127]   - Field: ‘conditions’
[17:48:39.127]   - Field: ‘persistent’
[17:48:39.127]   - Field: ‘expr’
[17:48:39.127]   - Field: ‘uuid’
[17:48:39.127]   - Field: ‘seed’
[17:48:39.128]   - Field: ‘version’
[17:48:39.128]   - Field: ‘result’
[17:48:39.128]   - Field: ‘asynchronous’
[17:48:39.128]   - Field: ‘calls’
[17:48:39.128]   - Field: ‘globals’
[17:48:39.128]   - Field: ‘stdout’
[17:48:39.128]   - Field: ‘earlySignal’
[17:48:39.128]   - Field: ‘lazy’
[17:48:39.128]   - Field: ‘state’
[17:48:39.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.129] - Launch lazy future ...
[17:48:39.129] Packages needed by the future expression (n = 1): ‘utils’
[17:48:39.129] Packages needed by future strategies (n = 0): <none>
[17:48:39.130] {
[17:48:39.130]     {
[17:48:39.130]         {
[17:48:39.130]             ...future.startTime <- base::Sys.time()
[17:48:39.130]             {
[17:48:39.130]                 {
[17:48:39.130]                   {
[17:48:39.130]                     {
[17:48:39.130]                       {
[17:48:39.130]                         base::local({
[17:48:39.130]                           has_future <- base::requireNamespace("future", 
[17:48:39.130]                             quietly = TRUE)
[17:48:39.130]                           if (has_future) {
[17:48:39.130]                             ns <- base::getNamespace("future")
[17:48:39.130]                             version <- ns[[".package"]][["version"]]
[17:48:39.130]                             if (is.null(version)) 
[17:48:39.130]                               version <- utils::packageVersion("future")
[17:48:39.130]                           }
[17:48:39.130]                           else {
[17:48:39.130]                             version <- NULL
[17:48:39.130]                           }
[17:48:39.130]                           if (!has_future || version < "1.8.0") {
[17:48:39.130]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.130]                               "", base::R.version$version.string), 
[17:48:39.130]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:39.130]                                 base::R.version$platform, 8 * 
[17:48:39.130]                                   base::.Machine$sizeof.pointer), 
[17:48:39.130]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.130]                                 "release", "version")], collapse = " "), 
[17:48:39.130]                               hostname = base::Sys.info()[["nodename"]])
[17:48:39.130]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.130]                               info)
[17:48:39.130]                             info <- base::paste(info, collapse = "; ")
[17:48:39.130]                             if (!has_future) {
[17:48:39.130]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.130]                                 info)
[17:48:39.130]                             }
[17:48:39.130]                             else {
[17:48:39.130]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.130]                                 info, version)
[17:48:39.130]                             }
[17:48:39.130]                             base::stop(msg)
[17:48:39.130]                           }
[17:48:39.130]                         })
[17:48:39.130]                       }
[17:48:39.130]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.130]                       base::options(mc.cores = 1L)
[17:48:39.130]                     }
[17:48:39.130]                     base::local({
[17:48:39.130]                       for (pkg in "utils") {
[17:48:39.130]                         base::loadNamespace(pkg)
[17:48:39.130]                         base::library(pkg, character.only = TRUE)
[17:48:39.130]                       }
[17:48:39.130]                     })
[17:48:39.130]                   }
[17:48:39.130]                   ...future.strategy.old <- future::plan("list")
[17:48:39.130]                   options(future.plan = NULL)
[17:48:39.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.130]                 }
[17:48:39.130]                 ...future.workdir <- getwd()
[17:48:39.130]             }
[17:48:39.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.130]         }
[17:48:39.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.130]             base::names(...future.oldOptions))
[17:48:39.130]     }
[17:48:39.130]     if (FALSE) {
[17:48:39.130]     }
[17:48:39.130]     else {
[17:48:39.130]         if (TRUE) {
[17:48:39.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.130]                 open = "w")
[17:48:39.130]         }
[17:48:39.130]         else {
[17:48:39.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.130]         }
[17:48:39.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.130]             base::sink(type = "output", split = FALSE)
[17:48:39.130]             base::close(...future.stdout)
[17:48:39.130]         }, add = TRUE)
[17:48:39.130]     }
[17:48:39.130]     ...future.frame <- base::sys.nframe()
[17:48:39.130]     ...future.conditions <- base::list()
[17:48:39.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.130]     if (FALSE) {
[17:48:39.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.130]     }
[17:48:39.130]     ...future.result <- base::tryCatch({
[17:48:39.130]         base::withCallingHandlers({
[17:48:39.130]             ...future.value <- base::withVisible(base::local({
[17:48:39.130]                 ...future.makeSendCondition <- base::local({
[17:48:39.130]                   sendCondition <- NULL
[17:48:39.130]                   function(frame = 1L) {
[17:48:39.130]                     if (is.function(sendCondition)) 
[17:48:39.130]                       return(sendCondition)
[17:48:39.130]                     ns <- getNamespace("parallel")
[17:48:39.130]                     if (exists("sendData", mode = "function", 
[17:48:39.130]                       envir = ns)) {
[17:48:39.130]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.130]                         envir = ns)
[17:48:39.130]                       envir <- sys.frame(frame)
[17:48:39.130]                       master <- NULL
[17:48:39.130]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.130]                         !identical(envir, emptyenv())) {
[17:48:39.130]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.130]                           inherits = FALSE)) {
[17:48:39.130]                           master <- get("master", mode = "list", 
[17:48:39.130]                             envir = envir, inherits = FALSE)
[17:48:39.130]                           if (inherits(master, c("SOCKnode", 
[17:48:39.130]                             "SOCK0node"))) {
[17:48:39.130]                             sendCondition <<- function(cond) {
[17:48:39.130]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.130]                                 success = TRUE)
[17:48:39.130]                               parallel_sendData(master, data)
[17:48:39.130]                             }
[17:48:39.130]                             return(sendCondition)
[17:48:39.130]                           }
[17:48:39.130]                         }
[17:48:39.130]                         frame <- frame + 1L
[17:48:39.130]                         envir <- sys.frame(frame)
[17:48:39.130]                       }
[17:48:39.130]                     }
[17:48:39.130]                     sendCondition <<- function(cond) NULL
[17:48:39.130]                   }
[17:48:39.130]                 })
[17:48:39.130]                 withCallingHandlers({
[17:48:39.130]                   {
[17:48:39.130]                     print(1:50)
[17:48:39.130]                     str(1:50)
[17:48:39.130]                     cat(letters, sep = "-")
[17:48:39.130]                     cat(1:6, collapse = "\n")
[17:48:39.130]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:39.130]                     42L
[17:48:39.130]                   }
[17:48:39.130]                 }, immediateCondition = function(cond) {
[17:48:39.130]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.130]                   sendCondition(cond)
[17:48:39.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.130]                   {
[17:48:39.130]                     inherits <- base::inherits
[17:48:39.130]                     invokeRestart <- base::invokeRestart
[17:48:39.130]                     is.null <- base::is.null
[17:48:39.130]                     muffled <- FALSE
[17:48:39.130]                     if (inherits(cond, "message")) {
[17:48:39.130]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.130]                       if (muffled) 
[17:48:39.130]                         invokeRestart("muffleMessage")
[17:48:39.130]                     }
[17:48:39.130]                     else if (inherits(cond, "warning")) {
[17:48:39.130]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.130]                       if (muffled) 
[17:48:39.130]                         invokeRestart("muffleWarning")
[17:48:39.130]                     }
[17:48:39.130]                     else if (inherits(cond, "condition")) {
[17:48:39.130]                       if (!is.null(pattern)) {
[17:48:39.130]                         computeRestarts <- base::computeRestarts
[17:48:39.130]                         grepl <- base::grepl
[17:48:39.130]                         restarts <- computeRestarts(cond)
[17:48:39.130]                         for (restart in restarts) {
[17:48:39.130]                           name <- restart$name
[17:48:39.130]                           if (is.null(name)) 
[17:48:39.130]                             next
[17:48:39.130]                           if (!grepl(pattern, name)) 
[17:48:39.130]                             next
[17:48:39.130]                           invokeRestart(restart)
[17:48:39.130]                           muffled <- TRUE
[17:48:39.130]                           break
[17:48:39.130]                         }
[17:48:39.130]                       }
[17:48:39.130]                     }
[17:48:39.130]                     invisible(muffled)
[17:48:39.130]                   }
[17:48:39.130]                   muffleCondition(cond)
[17:48:39.130]                 })
[17:48:39.130]             }))
[17:48:39.130]             future::FutureResult(value = ...future.value$value, 
[17:48:39.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.130]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.130]                     ...future.globalenv.names))
[17:48:39.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.130]         }, condition = base::local({
[17:48:39.130]             c <- base::c
[17:48:39.130]             inherits <- base::inherits
[17:48:39.130]             invokeRestart <- base::invokeRestart
[17:48:39.130]             length <- base::length
[17:48:39.130]             list <- base::list
[17:48:39.130]             seq.int <- base::seq.int
[17:48:39.130]             signalCondition <- base::signalCondition
[17:48:39.130]             sys.calls <- base::sys.calls
[17:48:39.130]             `[[` <- base::`[[`
[17:48:39.130]             `+` <- base::`+`
[17:48:39.130]             `<<-` <- base::`<<-`
[17:48:39.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.130]                   3L)]
[17:48:39.130]             }
[17:48:39.130]             function(cond) {
[17:48:39.130]                 is_error <- inherits(cond, "error")
[17:48:39.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.130]                   NULL)
[17:48:39.130]                 if (is_error) {
[17:48:39.130]                   sessionInformation <- function() {
[17:48:39.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.130]                       search = base::search(), system = base::Sys.info())
[17:48:39.130]                   }
[17:48:39.130]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.130]                     cond$call), session = sessionInformation(), 
[17:48:39.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.130]                   signalCondition(cond)
[17:48:39.130]                 }
[17:48:39.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.130]                 "immediateCondition"))) {
[17:48:39.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.130]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.130]                   if (TRUE && !signal) {
[17:48:39.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.130]                     {
[17:48:39.130]                       inherits <- base::inherits
[17:48:39.130]                       invokeRestart <- base::invokeRestart
[17:48:39.130]                       is.null <- base::is.null
[17:48:39.130]                       muffled <- FALSE
[17:48:39.130]                       if (inherits(cond, "message")) {
[17:48:39.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.130]                         if (muffled) 
[17:48:39.130]                           invokeRestart("muffleMessage")
[17:48:39.130]                       }
[17:48:39.130]                       else if (inherits(cond, "warning")) {
[17:48:39.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.130]                         if (muffled) 
[17:48:39.130]                           invokeRestart("muffleWarning")
[17:48:39.130]                       }
[17:48:39.130]                       else if (inherits(cond, "condition")) {
[17:48:39.130]                         if (!is.null(pattern)) {
[17:48:39.130]                           computeRestarts <- base::computeRestarts
[17:48:39.130]                           grepl <- base::grepl
[17:48:39.130]                           restarts <- computeRestarts(cond)
[17:48:39.130]                           for (restart in restarts) {
[17:48:39.130]                             name <- restart$name
[17:48:39.130]                             if (is.null(name)) 
[17:48:39.130]                               next
[17:48:39.130]                             if (!grepl(pattern, name)) 
[17:48:39.130]                               next
[17:48:39.130]                             invokeRestart(restart)
[17:48:39.130]                             muffled <- TRUE
[17:48:39.130]                             break
[17:48:39.130]                           }
[17:48:39.130]                         }
[17:48:39.130]                       }
[17:48:39.130]                       invisible(muffled)
[17:48:39.130]                     }
[17:48:39.130]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.130]                   }
[17:48:39.130]                 }
[17:48:39.130]                 else {
[17:48:39.130]                   if (TRUE) {
[17:48:39.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.130]                     {
[17:48:39.130]                       inherits <- base::inherits
[17:48:39.130]                       invokeRestart <- base::invokeRestart
[17:48:39.130]                       is.null <- base::is.null
[17:48:39.130]                       muffled <- FALSE
[17:48:39.130]                       if (inherits(cond, "message")) {
[17:48:39.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.130]                         if (muffled) 
[17:48:39.130]                           invokeRestart("muffleMessage")
[17:48:39.130]                       }
[17:48:39.130]                       else if (inherits(cond, "warning")) {
[17:48:39.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.130]                         if (muffled) 
[17:48:39.130]                           invokeRestart("muffleWarning")
[17:48:39.130]                       }
[17:48:39.130]                       else if (inherits(cond, "condition")) {
[17:48:39.130]                         if (!is.null(pattern)) {
[17:48:39.130]                           computeRestarts <- base::computeRestarts
[17:48:39.130]                           grepl <- base::grepl
[17:48:39.130]                           restarts <- computeRestarts(cond)
[17:48:39.130]                           for (restart in restarts) {
[17:48:39.130]                             name <- restart$name
[17:48:39.130]                             if (is.null(name)) 
[17:48:39.130]                               next
[17:48:39.130]                             if (!grepl(pattern, name)) 
[17:48:39.130]                               next
[17:48:39.130]                             invokeRestart(restart)
[17:48:39.130]                             muffled <- TRUE
[17:48:39.130]                             break
[17:48:39.130]                           }
[17:48:39.130]                         }
[17:48:39.130]                       }
[17:48:39.130]                       invisible(muffled)
[17:48:39.130]                     }
[17:48:39.130]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.130]                   }
[17:48:39.130]                 }
[17:48:39.130]             }
[17:48:39.130]         }))
[17:48:39.130]     }, error = function(ex) {
[17:48:39.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.130]                 ...future.rng), started = ...future.startTime, 
[17:48:39.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.130]             version = "1.8"), class = "FutureResult")
[17:48:39.130]     }, finally = {
[17:48:39.130]         if (!identical(...future.workdir, getwd())) 
[17:48:39.130]             setwd(...future.workdir)
[17:48:39.130]         {
[17:48:39.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.130]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.130]             }
[17:48:39.130]             base::options(...future.oldOptions)
[17:48:39.130]             if (.Platform$OS.type == "windows") {
[17:48:39.130]                 old_names <- names(...future.oldEnvVars)
[17:48:39.130]                 envs <- base::Sys.getenv()
[17:48:39.130]                 names <- names(envs)
[17:48:39.130]                 common <- intersect(names, old_names)
[17:48:39.130]                 added <- setdiff(names, old_names)
[17:48:39.130]                 removed <- setdiff(old_names, names)
[17:48:39.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.130]                   envs[common]]
[17:48:39.130]                 NAMES <- toupper(changed)
[17:48:39.130]                 args <- list()
[17:48:39.130]                 for (kk in seq_along(NAMES)) {
[17:48:39.130]                   name <- changed[[kk]]
[17:48:39.130]                   NAME <- NAMES[[kk]]
[17:48:39.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.130]                     next
[17:48:39.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.130]                 }
[17:48:39.130]                 NAMES <- toupper(added)
[17:48:39.130]                 for (kk in seq_along(NAMES)) {
[17:48:39.130]                   name <- added[[kk]]
[17:48:39.130]                   NAME <- NAMES[[kk]]
[17:48:39.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.130]                     next
[17:48:39.130]                   args[[name]] <- ""
[17:48:39.130]                 }
[17:48:39.130]                 NAMES <- toupper(removed)
[17:48:39.130]                 for (kk in seq_along(NAMES)) {
[17:48:39.130]                   name <- removed[[kk]]
[17:48:39.130]                   NAME <- NAMES[[kk]]
[17:48:39.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.130]                     next
[17:48:39.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.130]                 }
[17:48:39.130]                 if (length(args) > 0) 
[17:48:39.130]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.130]             }
[17:48:39.130]             else {
[17:48:39.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.130]             }
[17:48:39.130]             {
[17:48:39.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.130]                   0L) {
[17:48:39.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.130]                   base::options(opts)
[17:48:39.130]                 }
[17:48:39.130]                 {
[17:48:39.130]                   {
[17:48:39.130]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.130]                     NULL
[17:48:39.130]                   }
[17:48:39.130]                   options(future.plan = NULL)
[17:48:39.130]                   if (is.na(NA_character_)) 
[17:48:39.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.130]                     .init = FALSE)
[17:48:39.130]                 }
[17:48:39.130]             }
[17:48:39.130]         }
[17:48:39.130]     })
[17:48:39.130]     if (TRUE) {
[17:48:39.130]         base::sink(type = "output", split = FALSE)
[17:48:39.130]         if (TRUE) {
[17:48:39.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.130]         }
[17:48:39.130]         else {
[17:48:39.130]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.130]         }
[17:48:39.130]         base::close(...future.stdout)
[17:48:39.130]         ...future.stdout <- NULL
[17:48:39.130]     }
[17:48:39.130]     ...future.result$conditions <- ...future.conditions
[17:48:39.130]     ...future.result$finished <- base::Sys.time()
[17:48:39.130]     ...future.result
[17:48:39.130] }
[17:48:39.133] MultisessionFuture started
[17:48:39.134] - Launch lazy future ... done
[17:48:39.134] run() for ‘MultisessionFuture’ ... done
[17:48:39.134] result() for ClusterFuture ...
[17:48:39.134] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.134] - Validating connection of MultisessionFuture
[17:48:39.178] - received message: FutureResult
[17:48:39.178] - Received FutureResult
[17:48:39.178] - Erased future from FutureRegistry
[17:48:39.178] result() for ClusterFuture ...
[17:48:39.179] - result already collected: FutureResult
[17:48:39.179] result() for ClusterFuture ... done
[17:48:39.179] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.179] result() for ClusterFuture ... done
[17:48:39.179] result() for ClusterFuture ...
[17:48:39.179] - result already collected: FutureResult
[17:48:39.179] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:48:39.182] getGlobalsAndPackages() ...
[17:48:39.182] Searching for globals...
[17:48:39.183] - globals found: [1] ‘print’
[17:48:39.183] Searching for globals ... DONE
[17:48:39.183] Resolving globals: FALSE
[17:48:39.183] 
[17:48:39.183] 
[17:48:39.183] getGlobalsAndPackages() ... DONE
[17:48:39.184] run() for ‘Future’ ...
[17:48:39.184] - state: ‘created’
[17:48:39.184] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.198] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.198] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.198]   - Field: ‘node’
[17:48:39.198]   - Field: ‘label’
[17:48:39.198]   - Field: ‘local’
[17:48:39.198]   - Field: ‘owner’
[17:48:39.198]   - Field: ‘envir’
[17:48:39.198]   - Field: ‘workers’
[17:48:39.198]   - Field: ‘packages’
[17:48:39.198]   - Field: ‘gc’
[17:48:39.199]   - Field: ‘conditions’
[17:48:39.199]   - Field: ‘persistent’
[17:48:39.199]   - Field: ‘expr’
[17:48:39.199]   - Field: ‘uuid’
[17:48:39.199]   - Field: ‘seed’
[17:48:39.199]   - Field: ‘version’
[17:48:39.199]   - Field: ‘result’
[17:48:39.199]   - Field: ‘asynchronous’
[17:48:39.199]   - Field: ‘calls’
[17:48:39.199]   - Field: ‘globals’
[17:48:39.199]   - Field: ‘stdout’
[17:48:39.200]   - Field: ‘earlySignal’
[17:48:39.200]   - Field: ‘lazy’
[17:48:39.200]   - Field: ‘state’
[17:48:39.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.200] - Launch lazy future ...
[17:48:39.200] Packages needed by the future expression (n = 0): <none>
[17:48:39.200] Packages needed by future strategies (n = 0): <none>
[17:48:39.201] {
[17:48:39.201]     {
[17:48:39.201]         {
[17:48:39.201]             ...future.startTime <- base::Sys.time()
[17:48:39.201]             {
[17:48:39.201]                 {
[17:48:39.201]                   {
[17:48:39.201]                     {
[17:48:39.201]                       base::local({
[17:48:39.201]                         has_future <- base::requireNamespace("future", 
[17:48:39.201]                           quietly = TRUE)
[17:48:39.201]                         if (has_future) {
[17:48:39.201]                           ns <- base::getNamespace("future")
[17:48:39.201]                           version <- ns[[".package"]][["version"]]
[17:48:39.201]                           if (is.null(version)) 
[17:48:39.201]                             version <- utils::packageVersion("future")
[17:48:39.201]                         }
[17:48:39.201]                         else {
[17:48:39.201]                           version <- NULL
[17:48:39.201]                         }
[17:48:39.201]                         if (!has_future || version < "1.8.0") {
[17:48:39.201]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.201]                             "", base::R.version$version.string), 
[17:48:39.201]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:39.201]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:39.201]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.201]                               "release", "version")], collapse = " "), 
[17:48:39.201]                             hostname = base::Sys.info()[["nodename"]])
[17:48:39.201]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.201]                             info)
[17:48:39.201]                           info <- base::paste(info, collapse = "; ")
[17:48:39.201]                           if (!has_future) {
[17:48:39.201]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.201]                               info)
[17:48:39.201]                           }
[17:48:39.201]                           else {
[17:48:39.201]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.201]                               info, version)
[17:48:39.201]                           }
[17:48:39.201]                           base::stop(msg)
[17:48:39.201]                         }
[17:48:39.201]                       })
[17:48:39.201]                     }
[17:48:39.201]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.201]                     base::options(mc.cores = 1L)
[17:48:39.201]                   }
[17:48:39.201]                   ...future.strategy.old <- future::plan("list")
[17:48:39.201]                   options(future.plan = NULL)
[17:48:39.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.201]                 }
[17:48:39.201]                 ...future.workdir <- getwd()
[17:48:39.201]             }
[17:48:39.201]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.201]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.201]         }
[17:48:39.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.201]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.201]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.201]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.201]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.201]             base::names(...future.oldOptions))
[17:48:39.201]     }
[17:48:39.201]     if (FALSE) {
[17:48:39.201]     }
[17:48:39.201]     else {
[17:48:39.201]         if (TRUE) {
[17:48:39.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.201]                 open = "w")
[17:48:39.201]         }
[17:48:39.201]         else {
[17:48:39.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.201]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.201]         }
[17:48:39.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.201]             base::sink(type = "output", split = FALSE)
[17:48:39.201]             base::close(...future.stdout)
[17:48:39.201]         }, add = TRUE)
[17:48:39.201]     }
[17:48:39.201]     ...future.frame <- base::sys.nframe()
[17:48:39.201]     ...future.conditions <- base::list()
[17:48:39.201]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.201]     if (FALSE) {
[17:48:39.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.201]     }
[17:48:39.201]     ...future.result <- base::tryCatch({
[17:48:39.201]         base::withCallingHandlers({
[17:48:39.201]             ...future.value <- base::withVisible(base::local({
[17:48:39.201]                 ...future.makeSendCondition <- base::local({
[17:48:39.201]                   sendCondition <- NULL
[17:48:39.201]                   function(frame = 1L) {
[17:48:39.201]                     if (is.function(sendCondition)) 
[17:48:39.201]                       return(sendCondition)
[17:48:39.201]                     ns <- getNamespace("parallel")
[17:48:39.201]                     if (exists("sendData", mode = "function", 
[17:48:39.201]                       envir = ns)) {
[17:48:39.201]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.201]                         envir = ns)
[17:48:39.201]                       envir <- sys.frame(frame)
[17:48:39.201]                       master <- NULL
[17:48:39.201]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.201]                         !identical(envir, emptyenv())) {
[17:48:39.201]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.201]                           inherits = FALSE)) {
[17:48:39.201]                           master <- get("master", mode = "list", 
[17:48:39.201]                             envir = envir, inherits = FALSE)
[17:48:39.201]                           if (inherits(master, c("SOCKnode", 
[17:48:39.201]                             "SOCK0node"))) {
[17:48:39.201]                             sendCondition <<- function(cond) {
[17:48:39.201]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.201]                                 success = TRUE)
[17:48:39.201]                               parallel_sendData(master, data)
[17:48:39.201]                             }
[17:48:39.201]                             return(sendCondition)
[17:48:39.201]                           }
[17:48:39.201]                         }
[17:48:39.201]                         frame <- frame + 1L
[17:48:39.201]                         envir <- sys.frame(frame)
[17:48:39.201]                       }
[17:48:39.201]                     }
[17:48:39.201]                     sendCondition <<- function(cond) NULL
[17:48:39.201]                   }
[17:48:39.201]                 })
[17:48:39.201]                 withCallingHandlers({
[17:48:39.201]                   print(42)
[17:48:39.201]                 }, immediateCondition = function(cond) {
[17:48:39.201]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.201]                   sendCondition(cond)
[17:48:39.201]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.201]                   {
[17:48:39.201]                     inherits <- base::inherits
[17:48:39.201]                     invokeRestart <- base::invokeRestart
[17:48:39.201]                     is.null <- base::is.null
[17:48:39.201]                     muffled <- FALSE
[17:48:39.201]                     if (inherits(cond, "message")) {
[17:48:39.201]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.201]                       if (muffled) 
[17:48:39.201]                         invokeRestart("muffleMessage")
[17:48:39.201]                     }
[17:48:39.201]                     else if (inherits(cond, "warning")) {
[17:48:39.201]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.201]                       if (muffled) 
[17:48:39.201]                         invokeRestart("muffleWarning")
[17:48:39.201]                     }
[17:48:39.201]                     else if (inherits(cond, "condition")) {
[17:48:39.201]                       if (!is.null(pattern)) {
[17:48:39.201]                         computeRestarts <- base::computeRestarts
[17:48:39.201]                         grepl <- base::grepl
[17:48:39.201]                         restarts <- computeRestarts(cond)
[17:48:39.201]                         for (restart in restarts) {
[17:48:39.201]                           name <- restart$name
[17:48:39.201]                           if (is.null(name)) 
[17:48:39.201]                             next
[17:48:39.201]                           if (!grepl(pattern, name)) 
[17:48:39.201]                             next
[17:48:39.201]                           invokeRestart(restart)
[17:48:39.201]                           muffled <- TRUE
[17:48:39.201]                           break
[17:48:39.201]                         }
[17:48:39.201]                       }
[17:48:39.201]                     }
[17:48:39.201]                     invisible(muffled)
[17:48:39.201]                   }
[17:48:39.201]                   muffleCondition(cond)
[17:48:39.201]                 })
[17:48:39.201]             }))
[17:48:39.201]             future::FutureResult(value = ...future.value$value, 
[17:48:39.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.201]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.201]                     ...future.globalenv.names))
[17:48:39.201]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.201]         }, condition = base::local({
[17:48:39.201]             c <- base::c
[17:48:39.201]             inherits <- base::inherits
[17:48:39.201]             invokeRestart <- base::invokeRestart
[17:48:39.201]             length <- base::length
[17:48:39.201]             list <- base::list
[17:48:39.201]             seq.int <- base::seq.int
[17:48:39.201]             signalCondition <- base::signalCondition
[17:48:39.201]             sys.calls <- base::sys.calls
[17:48:39.201]             `[[` <- base::`[[`
[17:48:39.201]             `+` <- base::`+`
[17:48:39.201]             `<<-` <- base::`<<-`
[17:48:39.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.201]                   3L)]
[17:48:39.201]             }
[17:48:39.201]             function(cond) {
[17:48:39.201]                 is_error <- inherits(cond, "error")
[17:48:39.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.201]                   NULL)
[17:48:39.201]                 if (is_error) {
[17:48:39.201]                   sessionInformation <- function() {
[17:48:39.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.201]                       search = base::search(), system = base::Sys.info())
[17:48:39.201]                   }
[17:48:39.201]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.201]                     cond$call), session = sessionInformation(), 
[17:48:39.201]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.201]                   signalCondition(cond)
[17:48:39.201]                 }
[17:48:39.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.201]                 "immediateCondition"))) {
[17:48:39.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.201]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.201]                   if (TRUE && !signal) {
[17:48:39.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.201]                     {
[17:48:39.201]                       inherits <- base::inherits
[17:48:39.201]                       invokeRestart <- base::invokeRestart
[17:48:39.201]                       is.null <- base::is.null
[17:48:39.201]                       muffled <- FALSE
[17:48:39.201]                       if (inherits(cond, "message")) {
[17:48:39.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.201]                         if (muffled) 
[17:48:39.201]                           invokeRestart("muffleMessage")
[17:48:39.201]                       }
[17:48:39.201]                       else if (inherits(cond, "warning")) {
[17:48:39.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.201]                         if (muffled) 
[17:48:39.201]                           invokeRestart("muffleWarning")
[17:48:39.201]                       }
[17:48:39.201]                       else if (inherits(cond, "condition")) {
[17:48:39.201]                         if (!is.null(pattern)) {
[17:48:39.201]                           computeRestarts <- base::computeRestarts
[17:48:39.201]                           grepl <- base::grepl
[17:48:39.201]                           restarts <- computeRestarts(cond)
[17:48:39.201]                           for (restart in restarts) {
[17:48:39.201]                             name <- restart$name
[17:48:39.201]                             if (is.null(name)) 
[17:48:39.201]                               next
[17:48:39.201]                             if (!grepl(pattern, name)) 
[17:48:39.201]                               next
[17:48:39.201]                             invokeRestart(restart)
[17:48:39.201]                             muffled <- TRUE
[17:48:39.201]                             break
[17:48:39.201]                           }
[17:48:39.201]                         }
[17:48:39.201]                       }
[17:48:39.201]                       invisible(muffled)
[17:48:39.201]                     }
[17:48:39.201]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.201]                   }
[17:48:39.201]                 }
[17:48:39.201]                 else {
[17:48:39.201]                   if (TRUE) {
[17:48:39.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.201]                     {
[17:48:39.201]                       inherits <- base::inherits
[17:48:39.201]                       invokeRestart <- base::invokeRestart
[17:48:39.201]                       is.null <- base::is.null
[17:48:39.201]                       muffled <- FALSE
[17:48:39.201]                       if (inherits(cond, "message")) {
[17:48:39.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.201]                         if (muffled) 
[17:48:39.201]                           invokeRestart("muffleMessage")
[17:48:39.201]                       }
[17:48:39.201]                       else if (inherits(cond, "warning")) {
[17:48:39.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.201]                         if (muffled) 
[17:48:39.201]                           invokeRestart("muffleWarning")
[17:48:39.201]                       }
[17:48:39.201]                       else if (inherits(cond, "condition")) {
[17:48:39.201]                         if (!is.null(pattern)) {
[17:48:39.201]                           computeRestarts <- base::computeRestarts
[17:48:39.201]                           grepl <- base::grepl
[17:48:39.201]                           restarts <- computeRestarts(cond)
[17:48:39.201]                           for (restart in restarts) {
[17:48:39.201]                             name <- restart$name
[17:48:39.201]                             if (is.null(name)) 
[17:48:39.201]                               next
[17:48:39.201]                             if (!grepl(pattern, name)) 
[17:48:39.201]                               next
[17:48:39.201]                             invokeRestart(restart)
[17:48:39.201]                             muffled <- TRUE
[17:48:39.201]                             break
[17:48:39.201]                           }
[17:48:39.201]                         }
[17:48:39.201]                       }
[17:48:39.201]                       invisible(muffled)
[17:48:39.201]                     }
[17:48:39.201]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.201]                   }
[17:48:39.201]                 }
[17:48:39.201]             }
[17:48:39.201]         }))
[17:48:39.201]     }, error = function(ex) {
[17:48:39.201]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.201]                 ...future.rng), started = ...future.startTime, 
[17:48:39.201]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.201]             version = "1.8"), class = "FutureResult")
[17:48:39.201]     }, finally = {
[17:48:39.201]         if (!identical(...future.workdir, getwd())) 
[17:48:39.201]             setwd(...future.workdir)
[17:48:39.201]         {
[17:48:39.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.201]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.201]             }
[17:48:39.201]             base::options(...future.oldOptions)
[17:48:39.201]             if (.Platform$OS.type == "windows") {
[17:48:39.201]                 old_names <- names(...future.oldEnvVars)
[17:48:39.201]                 envs <- base::Sys.getenv()
[17:48:39.201]                 names <- names(envs)
[17:48:39.201]                 common <- intersect(names, old_names)
[17:48:39.201]                 added <- setdiff(names, old_names)
[17:48:39.201]                 removed <- setdiff(old_names, names)
[17:48:39.201]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.201]                   envs[common]]
[17:48:39.201]                 NAMES <- toupper(changed)
[17:48:39.201]                 args <- list()
[17:48:39.201]                 for (kk in seq_along(NAMES)) {
[17:48:39.201]                   name <- changed[[kk]]
[17:48:39.201]                   NAME <- NAMES[[kk]]
[17:48:39.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.201]                     next
[17:48:39.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.201]                 }
[17:48:39.201]                 NAMES <- toupper(added)
[17:48:39.201]                 for (kk in seq_along(NAMES)) {
[17:48:39.201]                   name <- added[[kk]]
[17:48:39.201]                   NAME <- NAMES[[kk]]
[17:48:39.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.201]                     next
[17:48:39.201]                   args[[name]] <- ""
[17:48:39.201]                 }
[17:48:39.201]                 NAMES <- toupper(removed)
[17:48:39.201]                 for (kk in seq_along(NAMES)) {
[17:48:39.201]                   name <- removed[[kk]]
[17:48:39.201]                   NAME <- NAMES[[kk]]
[17:48:39.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.201]                     next
[17:48:39.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.201]                 }
[17:48:39.201]                 if (length(args) > 0) 
[17:48:39.201]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.201]             }
[17:48:39.201]             else {
[17:48:39.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.201]             }
[17:48:39.201]             {
[17:48:39.201]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.201]                   0L) {
[17:48:39.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.201]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.201]                   base::options(opts)
[17:48:39.201]                 }
[17:48:39.201]                 {
[17:48:39.201]                   {
[17:48:39.201]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.201]                     NULL
[17:48:39.201]                   }
[17:48:39.201]                   options(future.plan = NULL)
[17:48:39.201]                   if (is.na(NA_character_)) 
[17:48:39.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.201]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.201]                     .init = FALSE)
[17:48:39.201]                 }
[17:48:39.201]             }
[17:48:39.201]         }
[17:48:39.201]     })
[17:48:39.201]     if (TRUE) {
[17:48:39.201]         base::sink(type = "output", split = FALSE)
[17:48:39.201]         if (TRUE) {
[17:48:39.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.201]         }
[17:48:39.201]         else {
[17:48:39.201]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.201]         }
[17:48:39.201]         base::close(...future.stdout)
[17:48:39.201]         ...future.stdout <- NULL
[17:48:39.201]     }
[17:48:39.201]     ...future.result$conditions <- ...future.conditions
[17:48:39.201]     ...future.result$finished <- base::Sys.time()
[17:48:39.201]     ...future.result
[17:48:39.201] }
[17:48:39.204] MultisessionFuture started
[17:48:39.204] - Launch lazy future ... done
[17:48:39.204] run() for ‘MultisessionFuture’ ... done
[17:48:39.204] result() for ClusterFuture ...
[17:48:39.204] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.205] - Validating connection of MultisessionFuture
[17:48:39.206] - received message: FutureResult
[17:48:39.206] - Received FutureResult
[17:48:39.206] - Erased future from FutureRegistry
[17:48:39.206] result() for ClusterFuture ...
[17:48:39.206] - result already collected: FutureResult
[17:48:39.206] result() for ClusterFuture ... done
[17:48:39.206] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.206] result() for ClusterFuture ... done
[17:48:39.206] result() for ClusterFuture ...
[17:48:39.207] - result already collected: FutureResult
[17:48:39.207] result() for ClusterFuture ... done
[17:48:39.207] result() for ClusterFuture ...
[17:48:39.207] - result already collected: FutureResult
[17:48:39.207] result() for ClusterFuture ... done
[1] 42
[17:48:39.207] result() for ClusterFuture ...
[17:48:39.207] - result already collected: FutureResult
[17:48:39.207] result() for ClusterFuture ... done
- stdout = FALSE
[17:48:39.207] getGlobalsAndPackages() ...
[17:48:39.207] Searching for globals...
[17:48:39.210] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:39.210] Searching for globals ... DONE
[17:48:39.210] Resolving globals: FALSE
[17:48:39.211] 
[17:48:39.211] - packages: [1] ‘utils’
[17:48:39.211] getGlobalsAndPackages() ... DONE
[17:48:39.211] run() for ‘Future’ ...
[17:48:39.212] - state: ‘created’
[17:48:39.212] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.226]   - Field: ‘node’
[17:48:39.226]   - Field: ‘label’
[17:48:39.226]   - Field: ‘local’
[17:48:39.226]   - Field: ‘owner’
[17:48:39.226]   - Field: ‘envir’
[17:48:39.226]   - Field: ‘workers’
[17:48:39.226]   - Field: ‘packages’
[17:48:39.226]   - Field: ‘gc’
[17:48:39.226]   - Field: ‘conditions’
[17:48:39.226]   - Field: ‘persistent’
[17:48:39.226]   - Field: ‘expr’
[17:48:39.227]   - Field: ‘uuid’
[17:48:39.227]   - Field: ‘seed’
[17:48:39.227]   - Field: ‘version’
[17:48:39.227]   - Field: ‘result’
[17:48:39.227]   - Field: ‘asynchronous’
[17:48:39.227]   - Field: ‘calls’
[17:48:39.227]   - Field: ‘globals’
[17:48:39.227]   - Field: ‘stdout’
[17:48:39.227]   - Field: ‘earlySignal’
[17:48:39.227]   - Field: ‘lazy’
[17:48:39.227]   - Field: ‘state’
[17:48:39.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.228] - Launch lazy future ...
[17:48:39.228] Packages needed by the future expression (n = 1): ‘utils’
[17:48:39.228] Packages needed by future strategies (n = 0): <none>
[17:48:39.228] {
[17:48:39.228]     {
[17:48:39.228]         {
[17:48:39.228]             ...future.startTime <- base::Sys.time()
[17:48:39.228]             {
[17:48:39.228]                 {
[17:48:39.228]                   {
[17:48:39.228]                     {
[17:48:39.228]                       {
[17:48:39.228]                         base::local({
[17:48:39.228]                           has_future <- base::requireNamespace("future", 
[17:48:39.228]                             quietly = TRUE)
[17:48:39.228]                           if (has_future) {
[17:48:39.228]                             ns <- base::getNamespace("future")
[17:48:39.228]                             version <- ns[[".package"]][["version"]]
[17:48:39.228]                             if (is.null(version)) 
[17:48:39.228]                               version <- utils::packageVersion("future")
[17:48:39.228]                           }
[17:48:39.228]                           else {
[17:48:39.228]                             version <- NULL
[17:48:39.228]                           }
[17:48:39.228]                           if (!has_future || version < "1.8.0") {
[17:48:39.228]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.228]                               "", base::R.version$version.string), 
[17:48:39.228]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:39.228]                                 base::R.version$platform, 8 * 
[17:48:39.228]                                   base::.Machine$sizeof.pointer), 
[17:48:39.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.228]                                 "release", "version")], collapse = " "), 
[17:48:39.228]                               hostname = base::Sys.info()[["nodename"]])
[17:48:39.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.228]                               info)
[17:48:39.228]                             info <- base::paste(info, collapse = "; ")
[17:48:39.228]                             if (!has_future) {
[17:48:39.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.228]                                 info)
[17:48:39.228]                             }
[17:48:39.228]                             else {
[17:48:39.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.228]                                 info, version)
[17:48:39.228]                             }
[17:48:39.228]                             base::stop(msg)
[17:48:39.228]                           }
[17:48:39.228]                         })
[17:48:39.228]                       }
[17:48:39.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.228]                       base::options(mc.cores = 1L)
[17:48:39.228]                     }
[17:48:39.228]                     base::local({
[17:48:39.228]                       for (pkg in "utils") {
[17:48:39.228]                         base::loadNamespace(pkg)
[17:48:39.228]                         base::library(pkg, character.only = TRUE)
[17:48:39.228]                       }
[17:48:39.228]                     })
[17:48:39.228]                   }
[17:48:39.228]                   ...future.strategy.old <- future::plan("list")
[17:48:39.228]                   options(future.plan = NULL)
[17:48:39.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.228]                 }
[17:48:39.228]                 ...future.workdir <- getwd()
[17:48:39.228]             }
[17:48:39.228]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.228]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.228]         }
[17:48:39.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.228]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.228]             base::names(...future.oldOptions))
[17:48:39.228]     }
[17:48:39.228]     if (FALSE) {
[17:48:39.228]     }
[17:48:39.228]     else {
[17:48:39.228]         if (FALSE) {
[17:48:39.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.228]                 open = "w")
[17:48:39.228]         }
[17:48:39.228]         else {
[17:48:39.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.228]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.228]         }
[17:48:39.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.228]             base::sink(type = "output", split = FALSE)
[17:48:39.228]             base::close(...future.stdout)
[17:48:39.228]         }, add = TRUE)
[17:48:39.228]     }
[17:48:39.228]     ...future.frame <- base::sys.nframe()
[17:48:39.228]     ...future.conditions <- base::list()
[17:48:39.228]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.228]     if (FALSE) {
[17:48:39.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.228]     }
[17:48:39.228]     ...future.result <- base::tryCatch({
[17:48:39.228]         base::withCallingHandlers({
[17:48:39.228]             ...future.value <- base::withVisible(base::local({
[17:48:39.228]                 ...future.makeSendCondition <- base::local({
[17:48:39.228]                   sendCondition <- NULL
[17:48:39.228]                   function(frame = 1L) {
[17:48:39.228]                     if (is.function(sendCondition)) 
[17:48:39.228]                       return(sendCondition)
[17:48:39.228]                     ns <- getNamespace("parallel")
[17:48:39.228]                     if (exists("sendData", mode = "function", 
[17:48:39.228]                       envir = ns)) {
[17:48:39.228]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.228]                         envir = ns)
[17:48:39.228]                       envir <- sys.frame(frame)
[17:48:39.228]                       master <- NULL
[17:48:39.228]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.228]                         !identical(envir, emptyenv())) {
[17:48:39.228]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.228]                           inherits = FALSE)) {
[17:48:39.228]                           master <- get("master", mode = "list", 
[17:48:39.228]                             envir = envir, inherits = FALSE)
[17:48:39.228]                           if (inherits(master, c("SOCKnode", 
[17:48:39.228]                             "SOCK0node"))) {
[17:48:39.228]                             sendCondition <<- function(cond) {
[17:48:39.228]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.228]                                 success = TRUE)
[17:48:39.228]                               parallel_sendData(master, data)
[17:48:39.228]                             }
[17:48:39.228]                             return(sendCondition)
[17:48:39.228]                           }
[17:48:39.228]                         }
[17:48:39.228]                         frame <- frame + 1L
[17:48:39.228]                         envir <- sys.frame(frame)
[17:48:39.228]                       }
[17:48:39.228]                     }
[17:48:39.228]                     sendCondition <<- function(cond) NULL
[17:48:39.228]                   }
[17:48:39.228]                 })
[17:48:39.228]                 withCallingHandlers({
[17:48:39.228]                   {
[17:48:39.228]                     print(1:50)
[17:48:39.228]                     str(1:50)
[17:48:39.228]                     cat(letters, sep = "-")
[17:48:39.228]                     cat(1:6, collapse = "\n")
[17:48:39.228]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:39.228]                     42L
[17:48:39.228]                   }
[17:48:39.228]                 }, immediateCondition = function(cond) {
[17:48:39.228]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.228]                   sendCondition(cond)
[17:48:39.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.228]                   {
[17:48:39.228]                     inherits <- base::inherits
[17:48:39.228]                     invokeRestart <- base::invokeRestart
[17:48:39.228]                     is.null <- base::is.null
[17:48:39.228]                     muffled <- FALSE
[17:48:39.228]                     if (inherits(cond, "message")) {
[17:48:39.228]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.228]                       if (muffled) 
[17:48:39.228]                         invokeRestart("muffleMessage")
[17:48:39.228]                     }
[17:48:39.228]                     else if (inherits(cond, "warning")) {
[17:48:39.228]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.228]                       if (muffled) 
[17:48:39.228]                         invokeRestart("muffleWarning")
[17:48:39.228]                     }
[17:48:39.228]                     else if (inherits(cond, "condition")) {
[17:48:39.228]                       if (!is.null(pattern)) {
[17:48:39.228]                         computeRestarts <- base::computeRestarts
[17:48:39.228]                         grepl <- base::grepl
[17:48:39.228]                         restarts <- computeRestarts(cond)
[17:48:39.228]                         for (restart in restarts) {
[17:48:39.228]                           name <- restart$name
[17:48:39.228]                           if (is.null(name)) 
[17:48:39.228]                             next
[17:48:39.228]                           if (!grepl(pattern, name)) 
[17:48:39.228]                             next
[17:48:39.228]                           invokeRestart(restart)
[17:48:39.228]                           muffled <- TRUE
[17:48:39.228]                           break
[17:48:39.228]                         }
[17:48:39.228]                       }
[17:48:39.228]                     }
[17:48:39.228]                     invisible(muffled)
[17:48:39.228]                   }
[17:48:39.228]                   muffleCondition(cond)
[17:48:39.228]                 })
[17:48:39.228]             }))
[17:48:39.228]             future::FutureResult(value = ...future.value$value, 
[17:48:39.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.228]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.228]                     ...future.globalenv.names))
[17:48:39.228]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.228]         }, condition = base::local({
[17:48:39.228]             c <- base::c
[17:48:39.228]             inherits <- base::inherits
[17:48:39.228]             invokeRestart <- base::invokeRestart
[17:48:39.228]             length <- base::length
[17:48:39.228]             list <- base::list
[17:48:39.228]             seq.int <- base::seq.int
[17:48:39.228]             signalCondition <- base::signalCondition
[17:48:39.228]             sys.calls <- base::sys.calls
[17:48:39.228]             `[[` <- base::`[[`
[17:48:39.228]             `+` <- base::`+`
[17:48:39.228]             `<<-` <- base::`<<-`
[17:48:39.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.228]                   3L)]
[17:48:39.228]             }
[17:48:39.228]             function(cond) {
[17:48:39.228]                 is_error <- inherits(cond, "error")
[17:48:39.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.228]                   NULL)
[17:48:39.228]                 if (is_error) {
[17:48:39.228]                   sessionInformation <- function() {
[17:48:39.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.228]                       search = base::search(), system = base::Sys.info())
[17:48:39.228]                   }
[17:48:39.228]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.228]                     cond$call), session = sessionInformation(), 
[17:48:39.228]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.228]                   signalCondition(cond)
[17:48:39.228]                 }
[17:48:39.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.228]                 "immediateCondition"))) {
[17:48:39.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.228]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.228]                   if (TRUE && !signal) {
[17:48:39.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.228]                     {
[17:48:39.228]                       inherits <- base::inherits
[17:48:39.228]                       invokeRestart <- base::invokeRestart
[17:48:39.228]                       is.null <- base::is.null
[17:48:39.228]                       muffled <- FALSE
[17:48:39.228]                       if (inherits(cond, "message")) {
[17:48:39.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.228]                         if (muffled) 
[17:48:39.228]                           invokeRestart("muffleMessage")
[17:48:39.228]                       }
[17:48:39.228]                       else if (inherits(cond, "warning")) {
[17:48:39.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.228]                         if (muffled) 
[17:48:39.228]                           invokeRestart("muffleWarning")
[17:48:39.228]                       }
[17:48:39.228]                       else if (inherits(cond, "condition")) {
[17:48:39.228]                         if (!is.null(pattern)) {
[17:48:39.228]                           computeRestarts <- base::computeRestarts
[17:48:39.228]                           grepl <- base::grepl
[17:48:39.228]                           restarts <- computeRestarts(cond)
[17:48:39.228]                           for (restart in restarts) {
[17:48:39.228]                             name <- restart$name
[17:48:39.228]                             if (is.null(name)) 
[17:48:39.228]                               next
[17:48:39.228]                             if (!grepl(pattern, name)) 
[17:48:39.228]                               next
[17:48:39.228]                             invokeRestart(restart)
[17:48:39.228]                             muffled <- TRUE
[17:48:39.228]                             break
[17:48:39.228]                           }
[17:48:39.228]                         }
[17:48:39.228]                       }
[17:48:39.228]                       invisible(muffled)
[17:48:39.228]                     }
[17:48:39.228]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.228]                   }
[17:48:39.228]                 }
[17:48:39.228]                 else {
[17:48:39.228]                   if (TRUE) {
[17:48:39.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.228]                     {
[17:48:39.228]                       inherits <- base::inherits
[17:48:39.228]                       invokeRestart <- base::invokeRestart
[17:48:39.228]                       is.null <- base::is.null
[17:48:39.228]                       muffled <- FALSE
[17:48:39.228]                       if (inherits(cond, "message")) {
[17:48:39.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.228]                         if (muffled) 
[17:48:39.228]                           invokeRestart("muffleMessage")
[17:48:39.228]                       }
[17:48:39.228]                       else if (inherits(cond, "warning")) {
[17:48:39.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.228]                         if (muffled) 
[17:48:39.228]                           invokeRestart("muffleWarning")
[17:48:39.228]                       }
[17:48:39.228]                       else if (inherits(cond, "condition")) {
[17:48:39.228]                         if (!is.null(pattern)) {
[17:48:39.228]                           computeRestarts <- base::computeRestarts
[17:48:39.228]                           grepl <- base::grepl
[17:48:39.228]                           restarts <- computeRestarts(cond)
[17:48:39.228]                           for (restart in restarts) {
[17:48:39.228]                             name <- restart$name
[17:48:39.228]                             if (is.null(name)) 
[17:48:39.228]                               next
[17:48:39.228]                             if (!grepl(pattern, name)) 
[17:48:39.228]                               next
[17:48:39.228]                             invokeRestart(restart)
[17:48:39.228]                             muffled <- TRUE
[17:48:39.228]                             break
[17:48:39.228]                           }
[17:48:39.228]                         }
[17:48:39.228]                       }
[17:48:39.228]                       invisible(muffled)
[17:48:39.228]                     }
[17:48:39.228]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.228]                   }
[17:48:39.228]                 }
[17:48:39.228]             }
[17:48:39.228]         }))
[17:48:39.228]     }, error = function(ex) {
[17:48:39.228]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.228]                 ...future.rng), started = ...future.startTime, 
[17:48:39.228]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.228]             version = "1.8"), class = "FutureResult")
[17:48:39.228]     }, finally = {
[17:48:39.228]         if (!identical(...future.workdir, getwd())) 
[17:48:39.228]             setwd(...future.workdir)
[17:48:39.228]         {
[17:48:39.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.228]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.228]             }
[17:48:39.228]             base::options(...future.oldOptions)
[17:48:39.228]             if (.Platform$OS.type == "windows") {
[17:48:39.228]                 old_names <- names(...future.oldEnvVars)
[17:48:39.228]                 envs <- base::Sys.getenv()
[17:48:39.228]                 names <- names(envs)
[17:48:39.228]                 common <- intersect(names, old_names)
[17:48:39.228]                 added <- setdiff(names, old_names)
[17:48:39.228]                 removed <- setdiff(old_names, names)
[17:48:39.228]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.228]                   envs[common]]
[17:48:39.228]                 NAMES <- toupper(changed)
[17:48:39.228]                 args <- list()
[17:48:39.228]                 for (kk in seq_along(NAMES)) {
[17:48:39.228]                   name <- changed[[kk]]
[17:48:39.228]                   NAME <- NAMES[[kk]]
[17:48:39.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.228]                     next
[17:48:39.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.228]                 }
[17:48:39.228]                 NAMES <- toupper(added)
[17:48:39.228]                 for (kk in seq_along(NAMES)) {
[17:48:39.228]                   name <- added[[kk]]
[17:48:39.228]                   NAME <- NAMES[[kk]]
[17:48:39.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.228]                     next
[17:48:39.228]                   args[[name]] <- ""
[17:48:39.228]                 }
[17:48:39.228]                 NAMES <- toupper(removed)
[17:48:39.228]                 for (kk in seq_along(NAMES)) {
[17:48:39.228]                   name <- removed[[kk]]
[17:48:39.228]                   NAME <- NAMES[[kk]]
[17:48:39.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.228]                     next
[17:48:39.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.228]                 }
[17:48:39.228]                 if (length(args) > 0) 
[17:48:39.228]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.228]             }
[17:48:39.228]             else {
[17:48:39.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.228]             }
[17:48:39.228]             {
[17:48:39.228]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.228]                   0L) {
[17:48:39.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.228]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.228]                   base::options(opts)
[17:48:39.228]                 }
[17:48:39.228]                 {
[17:48:39.228]                   {
[17:48:39.228]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.228]                     NULL
[17:48:39.228]                   }
[17:48:39.228]                   options(future.plan = NULL)
[17:48:39.228]                   if (is.na(NA_character_)) 
[17:48:39.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.228]                     .init = FALSE)
[17:48:39.228]                 }
[17:48:39.228]             }
[17:48:39.228]         }
[17:48:39.228]     })
[17:48:39.228]     if (TRUE) {
[17:48:39.228]         base::sink(type = "output", split = FALSE)
[17:48:39.228]         if (FALSE) {
[17:48:39.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.228]         }
[17:48:39.228]         else {
[17:48:39.228]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.228]         }
[17:48:39.228]         base::close(...future.stdout)
[17:48:39.228]         ...future.stdout <- NULL
[17:48:39.228]     }
[17:48:39.228]     ...future.result$conditions <- ...future.conditions
[17:48:39.228]     ...future.result$finished <- base::Sys.time()
[17:48:39.228]     ...future.result
[17:48:39.228] }
[17:48:39.232] MultisessionFuture started
[17:48:39.232] - Launch lazy future ... done
[17:48:39.232] run() for ‘MultisessionFuture’ ... done
[17:48:39.232] result() for ClusterFuture ...
[17:48:39.232] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.232] - Validating connection of MultisessionFuture
[17:48:39.278] - received message: FutureResult
[17:48:39.278] - Received FutureResult
[17:48:39.278] - Erased future from FutureRegistry
[17:48:39.278] result() for ClusterFuture ...
[17:48:39.278] - result already collected: FutureResult
[17:48:39.278] result() for ClusterFuture ... done
[17:48:39.278] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.279] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:39"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:39"
 $ session_uuid: chr "e31724b7-b062-c0e2-d1f7-8754e7686beb"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50530
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:38"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:39.286] result() for ClusterFuture ...
[17:48:39.286] - result already collected: FutureResult
[17:48:39.286] result() for ClusterFuture ... done
[17:48:39.287] result() for ClusterFuture ...
[17:48:39.287] - result already collected: FutureResult
[17:48:39.287] result() for ClusterFuture ... done
[17:48:39.287] getGlobalsAndPackages() ...
[17:48:39.287] Searching for globals...
[17:48:39.290] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:39.290] Searching for globals ... DONE
[17:48:39.290] Resolving globals: FALSE
[17:48:39.291] 
[17:48:39.291] - packages: [1] ‘utils’
[17:48:39.291] getGlobalsAndPackages() ... DONE
[17:48:39.291] run() for ‘Future’ ...
[17:48:39.291] - state: ‘created’
[17:48:39.291] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.305] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.306]   - Field: ‘node’
[17:48:39.306]   - Field: ‘label’
[17:48:39.306]   - Field: ‘local’
[17:48:39.306]   - Field: ‘owner’
[17:48:39.306]   - Field: ‘envir’
[17:48:39.306]   - Field: ‘workers’
[17:48:39.306]   - Field: ‘packages’
[17:48:39.306]   - Field: ‘gc’
[17:48:39.306]   - Field: ‘conditions’
[17:48:39.307]   - Field: ‘persistent’
[17:48:39.307]   - Field: ‘expr’
[17:48:39.307]   - Field: ‘uuid’
[17:48:39.307]   - Field: ‘seed’
[17:48:39.307]   - Field: ‘version’
[17:48:39.307]   - Field: ‘result’
[17:48:39.307]   - Field: ‘asynchronous’
[17:48:39.307]   - Field: ‘calls’
[17:48:39.307]   - Field: ‘globals’
[17:48:39.307]   - Field: ‘stdout’
[17:48:39.308]   - Field: ‘earlySignal’
[17:48:39.308]   - Field: ‘lazy’
[17:48:39.308]   - Field: ‘state’
[17:48:39.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.308] - Launch lazy future ...
[17:48:39.308] Packages needed by the future expression (n = 1): ‘utils’
[17:48:39.308] Packages needed by future strategies (n = 0): <none>
[17:48:39.309] {
[17:48:39.309]     {
[17:48:39.309]         {
[17:48:39.309]             ...future.startTime <- base::Sys.time()
[17:48:39.309]             {
[17:48:39.309]                 {
[17:48:39.309]                   {
[17:48:39.309]                     {
[17:48:39.309]                       {
[17:48:39.309]                         base::local({
[17:48:39.309]                           has_future <- base::requireNamespace("future", 
[17:48:39.309]                             quietly = TRUE)
[17:48:39.309]                           if (has_future) {
[17:48:39.309]                             ns <- base::getNamespace("future")
[17:48:39.309]                             version <- ns[[".package"]][["version"]]
[17:48:39.309]                             if (is.null(version)) 
[17:48:39.309]                               version <- utils::packageVersion("future")
[17:48:39.309]                           }
[17:48:39.309]                           else {
[17:48:39.309]                             version <- NULL
[17:48:39.309]                           }
[17:48:39.309]                           if (!has_future || version < "1.8.0") {
[17:48:39.309]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.309]                               "", base::R.version$version.string), 
[17:48:39.309]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:39.309]                                 base::R.version$platform, 8 * 
[17:48:39.309]                                   base::.Machine$sizeof.pointer), 
[17:48:39.309]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.309]                                 "release", "version")], collapse = " "), 
[17:48:39.309]                               hostname = base::Sys.info()[["nodename"]])
[17:48:39.309]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.309]                               info)
[17:48:39.309]                             info <- base::paste(info, collapse = "; ")
[17:48:39.309]                             if (!has_future) {
[17:48:39.309]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.309]                                 info)
[17:48:39.309]                             }
[17:48:39.309]                             else {
[17:48:39.309]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.309]                                 info, version)
[17:48:39.309]                             }
[17:48:39.309]                             base::stop(msg)
[17:48:39.309]                           }
[17:48:39.309]                         })
[17:48:39.309]                       }
[17:48:39.309]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.309]                       base::options(mc.cores = 1L)
[17:48:39.309]                     }
[17:48:39.309]                     base::local({
[17:48:39.309]                       for (pkg in "utils") {
[17:48:39.309]                         base::loadNamespace(pkg)
[17:48:39.309]                         base::library(pkg, character.only = TRUE)
[17:48:39.309]                       }
[17:48:39.309]                     })
[17:48:39.309]                   }
[17:48:39.309]                   ...future.strategy.old <- future::plan("list")
[17:48:39.309]                   options(future.plan = NULL)
[17:48:39.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.309]                 }
[17:48:39.309]                 ...future.workdir <- getwd()
[17:48:39.309]             }
[17:48:39.309]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.309]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.309]         }
[17:48:39.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.309]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.309]             base::names(...future.oldOptions))
[17:48:39.309]     }
[17:48:39.309]     if (FALSE) {
[17:48:39.309]     }
[17:48:39.309]     else {
[17:48:39.309]         if (FALSE) {
[17:48:39.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.309]                 open = "w")
[17:48:39.309]         }
[17:48:39.309]         else {
[17:48:39.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.309]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.309]         }
[17:48:39.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.309]             base::sink(type = "output", split = FALSE)
[17:48:39.309]             base::close(...future.stdout)
[17:48:39.309]         }, add = TRUE)
[17:48:39.309]     }
[17:48:39.309]     ...future.frame <- base::sys.nframe()
[17:48:39.309]     ...future.conditions <- base::list()
[17:48:39.309]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.309]     if (FALSE) {
[17:48:39.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.309]     }
[17:48:39.309]     ...future.result <- base::tryCatch({
[17:48:39.309]         base::withCallingHandlers({
[17:48:39.309]             ...future.value <- base::withVisible(base::local({
[17:48:39.309]                 ...future.makeSendCondition <- base::local({
[17:48:39.309]                   sendCondition <- NULL
[17:48:39.309]                   function(frame = 1L) {
[17:48:39.309]                     if (is.function(sendCondition)) 
[17:48:39.309]                       return(sendCondition)
[17:48:39.309]                     ns <- getNamespace("parallel")
[17:48:39.309]                     if (exists("sendData", mode = "function", 
[17:48:39.309]                       envir = ns)) {
[17:48:39.309]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.309]                         envir = ns)
[17:48:39.309]                       envir <- sys.frame(frame)
[17:48:39.309]                       master <- NULL
[17:48:39.309]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.309]                         !identical(envir, emptyenv())) {
[17:48:39.309]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.309]                           inherits = FALSE)) {
[17:48:39.309]                           master <- get("master", mode = "list", 
[17:48:39.309]                             envir = envir, inherits = FALSE)
[17:48:39.309]                           if (inherits(master, c("SOCKnode", 
[17:48:39.309]                             "SOCK0node"))) {
[17:48:39.309]                             sendCondition <<- function(cond) {
[17:48:39.309]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.309]                                 success = TRUE)
[17:48:39.309]                               parallel_sendData(master, data)
[17:48:39.309]                             }
[17:48:39.309]                             return(sendCondition)
[17:48:39.309]                           }
[17:48:39.309]                         }
[17:48:39.309]                         frame <- frame + 1L
[17:48:39.309]                         envir <- sys.frame(frame)
[17:48:39.309]                       }
[17:48:39.309]                     }
[17:48:39.309]                     sendCondition <<- function(cond) NULL
[17:48:39.309]                   }
[17:48:39.309]                 })
[17:48:39.309]                 withCallingHandlers({
[17:48:39.309]                   {
[17:48:39.309]                     print(1:50)
[17:48:39.309]                     str(1:50)
[17:48:39.309]                     cat(letters, sep = "-")
[17:48:39.309]                     cat(1:6, collapse = "\n")
[17:48:39.309]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:39.309]                     42L
[17:48:39.309]                   }
[17:48:39.309]                 }, immediateCondition = function(cond) {
[17:48:39.309]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.309]                   sendCondition(cond)
[17:48:39.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.309]                   {
[17:48:39.309]                     inherits <- base::inherits
[17:48:39.309]                     invokeRestart <- base::invokeRestart
[17:48:39.309]                     is.null <- base::is.null
[17:48:39.309]                     muffled <- FALSE
[17:48:39.309]                     if (inherits(cond, "message")) {
[17:48:39.309]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.309]                       if (muffled) 
[17:48:39.309]                         invokeRestart("muffleMessage")
[17:48:39.309]                     }
[17:48:39.309]                     else if (inherits(cond, "warning")) {
[17:48:39.309]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.309]                       if (muffled) 
[17:48:39.309]                         invokeRestart("muffleWarning")
[17:48:39.309]                     }
[17:48:39.309]                     else if (inherits(cond, "condition")) {
[17:48:39.309]                       if (!is.null(pattern)) {
[17:48:39.309]                         computeRestarts <- base::computeRestarts
[17:48:39.309]                         grepl <- base::grepl
[17:48:39.309]                         restarts <- computeRestarts(cond)
[17:48:39.309]                         for (restart in restarts) {
[17:48:39.309]                           name <- restart$name
[17:48:39.309]                           if (is.null(name)) 
[17:48:39.309]                             next
[17:48:39.309]                           if (!grepl(pattern, name)) 
[17:48:39.309]                             next
[17:48:39.309]                           invokeRestart(restart)
[17:48:39.309]                           muffled <- TRUE
[17:48:39.309]                           break
[17:48:39.309]                         }
[17:48:39.309]                       }
[17:48:39.309]                     }
[17:48:39.309]                     invisible(muffled)
[17:48:39.309]                   }
[17:48:39.309]                   muffleCondition(cond)
[17:48:39.309]                 })
[17:48:39.309]             }))
[17:48:39.309]             future::FutureResult(value = ...future.value$value, 
[17:48:39.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.309]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.309]                     ...future.globalenv.names))
[17:48:39.309]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.309]         }, condition = base::local({
[17:48:39.309]             c <- base::c
[17:48:39.309]             inherits <- base::inherits
[17:48:39.309]             invokeRestart <- base::invokeRestart
[17:48:39.309]             length <- base::length
[17:48:39.309]             list <- base::list
[17:48:39.309]             seq.int <- base::seq.int
[17:48:39.309]             signalCondition <- base::signalCondition
[17:48:39.309]             sys.calls <- base::sys.calls
[17:48:39.309]             `[[` <- base::`[[`
[17:48:39.309]             `+` <- base::`+`
[17:48:39.309]             `<<-` <- base::`<<-`
[17:48:39.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.309]                   3L)]
[17:48:39.309]             }
[17:48:39.309]             function(cond) {
[17:48:39.309]                 is_error <- inherits(cond, "error")
[17:48:39.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.309]                   NULL)
[17:48:39.309]                 if (is_error) {
[17:48:39.309]                   sessionInformation <- function() {
[17:48:39.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.309]                       search = base::search(), system = base::Sys.info())
[17:48:39.309]                   }
[17:48:39.309]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.309]                     cond$call), session = sessionInformation(), 
[17:48:39.309]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.309]                   signalCondition(cond)
[17:48:39.309]                 }
[17:48:39.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.309]                 "immediateCondition"))) {
[17:48:39.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.309]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.309]                   if (TRUE && !signal) {
[17:48:39.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.309]                     {
[17:48:39.309]                       inherits <- base::inherits
[17:48:39.309]                       invokeRestart <- base::invokeRestart
[17:48:39.309]                       is.null <- base::is.null
[17:48:39.309]                       muffled <- FALSE
[17:48:39.309]                       if (inherits(cond, "message")) {
[17:48:39.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.309]                         if (muffled) 
[17:48:39.309]                           invokeRestart("muffleMessage")
[17:48:39.309]                       }
[17:48:39.309]                       else if (inherits(cond, "warning")) {
[17:48:39.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.309]                         if (muffled) 
[17:48:39.309]                           invokeRestart("muffleWarning")
[17:48:39.309]                       }
[17:48:39.309]                       else if (inherits(cond, "condition")) {
[17:48:39.309]                         if (!is.null(pattern)) {
[17:48:39.309]                           computeRestarts <- base::computeRestarts
[17:48:39.309]                           grepl <- base::grepl
[17:48:39.309]                           restarts <- computeRestarts(cond)
[17:48:39.309]                           for (restart in restarts) {
[17:48:39.309]                             name <- restart$name
[17:48:39.309]                             if (is.null(name)) 
[17:48:39.309]                               next
[17:48:39.309]                             if (!grepl(pattern, name)) 
[17:48:39.309]                               next
[17:48:39.309]                             invokeRestart(restart)
[17:48:39.309]                             muffled <- TRUE
[17:48:39.309]                             break
[17:48:39.309]                           }
[17:48:39.309]                         }
[17:48:39.309]                       }
[17:48:39.309]                       invisible(muffled)
[17:48:39.309]                     }
[17:48:39.309]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.309]                   }
[17:48:39.309]                 }
[17:48:39.309]                 else {
[17:48:39.309]                   if (TRUE) {
[17:48:39.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.309]                     {
[17:48:39.309]                       inherits <- base::inherits
[17:48:39.309]                       invokeRestart <- base::invokeRestart
[17:48:39.309]                       is.null <- base::is.null
[17:48:39.309]                       muffled <- FALSE
[17:48:39.309]                       if (inherits(cond, "message")) {
[17:48:39.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.309]                         if (muffled) 
[17:48:39.309]                           invokeRestart("muffleMessage")
[17:48:39.309]                       }
[17:48:39.309]                       else if (inherits(cond, "warning")) {
[17:48:39.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.309]                         if (muffled) 
[17:48:39.309]                           invokeRestart("muffleWarning")
[17:48:39.309]                       }
[17:48:39.309]                       else if (inherits(cond, "condition")) {
[17:48:39.309]                         if (!is.null(pattern)) {
[17:48:39.309]                           computeRestarts <- base::computeRestarts
[17:48:39.309]                           grepl <- base::grepl
[17:48:39.309]                           restarts <- computeRestarts(cond)
[17:48:39.309]                           for (restart in restarts) {
[17:48:39.309]                             name <- restart$name
[17:48:39.309]                             if (is.null(name)) 
[17:48:39.309]                               next
[17:48:39.309]                             if (!grepl(pattern, name)) 
[17:48:39.309]                               next
[17:48:39.309]                             invokeRestart(restart)
[17:48:39.309]                             muffled <- TRUE
[17:48:39.309]                             break
[17:48:39.309]                           }
[17:48:39.309]                         }
[17:48:39.309]                       }
[17:48:39.309]                       invisible(muffled)
[17:48:39.309]                     }
[17:48:39.309]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.309]                   }
[17:48:39.309]                 }
[17:48:39.309]             }
[17:48:39.309]         }))
[17:48:39.309]     }, error = function(ex) {
[17:48:39.309]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.309]                 ...future.rng), started = ...future.startTime, 
[17:48:39.309]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.309]             version = "1.8"), class = "FutureResult")
[17:48:39.309]     }, finally = {
[17:48:39.309]         if (!identical(...future.workdir, getwd())) 
[17:48:39.309]             setwd(...future.workdir)
[17:48:39.309]         {
[17:48:39.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.309]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.309]             }
[17:48:39.309]             base::options(...future.oldOptions)
[17:48:39.309]             if (.Platform$OS.type == "windows") {
[17:48:39.309]                 old_names <- names(...future.oldEnvVars)
[17:48:39.309]                 envs <- base::Sys.getenv()
[17:48:39.309]                 names <- names(envs)
[17:48:39.309]                 common <- intersect(names, old_names)
[17:48:39.309]                 added <- setdiff(names, old_names)
[17:48:39.309]                 removed <- setdiff(old_names, names)
[17:48:39.309]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.309]                   envs[common]]
[17:48:39.309]                 NAMES <- toupper(changed)
[17:48:39.309]                 args <- list()
[17:48:39.309]                 for (kk in seq_along(NAMES)) {
[17:48:39.309]                   name <- changed[[kk]]
[17:48:39.309]                   NAME <- NAMES[[kk]]
[17:48:39.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.309]                     next
[17:48:39.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.309]                 }
[17:48:39.309]                 NAMES <- toupper(added)
[17:48:39.309]                 for (kk in seq_along(NAMES)) {
[17:48:39.309]                   name <- added[[kk]]
[17:48:39.309]                   NAME <- NAMES[[kk]]
[17:48:39.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.309]                     next
[17:48:39.309]                   args[[name]] <- ""
[17:48:39.309]                 }
[17:48:39.309]                 NAMES <- toupper(removed)
[17:48:39.309]                 for (kk in seq_along(NAMES)) {
[17:48:39.309]                   name <- removed[[kk]]
[17:48:39.309]                   NAME <- NAMES[[kk]]
[17:48:39.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.309]                     next
[17:48:39.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.309]                 }
[17:48:39.309]                 if (length(args) > 0) 
[17:48:39.309]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.309]             }
[17:48:39.309]             else {
[17:48:39.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.309]             }
[17:48:39.309]             {
[17:48:39.309]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.309]                   0L) {
[17:48:39.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.309]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.309]                   base::options(opts)
[17:48:39.309]                 }
[17:48:39.309]                 {
[17:48:39.309]                   {
[17:48:39.309]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.309]                     NULL
[17:48:39.309]                   }
[17:48:39.309]                   options(future.plan = NULL)
[17:48:39.309]                   if (is.na(NA_character_)) 
[17:48:39.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.309]                     .init = FALSE)
[17:48:39.309]                 }
[17:48:39.309]             }
[17:48:39.309]         }
[17:48:39.309]     })
[17:48:39.309]     if (TRUE) {
[17:48:39.309]         base::sink(type = "output", split = FALSE)
[17:48:39.309]         if (FALSE) {
[17:48:39.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.309]         }
[17:48:39.309]         else {
[17:48:39.309]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.309]         }
[17:48:39.309]         base::close(...future.stdout)
[17:48:39.309]         ...future.stdout <- NULL
[17:48:39.309]     }
[17:48:39.309]     ...future.result$conditions <- ...future.conditions
[17:48:39.309]     ...future.result$finished <- base::Sys.time()
[17:48:39.309]     ...future.result
[17:48:39.309] }
[17:48:39.312] MultisessionFuture started
[17:48:39.312] - Launch lazy future ... done
[17:48:39.312] run() for ‘MultisessionFuture’ ... done
[17:48:39.312] result() for ClusterFuture ...
[17:48:39.313] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.313] - Validating connection of MultisessionFuture
[17:48:39.358] - received message: FutureResult
[17:48:39.358] - Received FutureResult
[17:48:39.358] - Erased future from FutureRegistry
[17:48:39.358] result() for ClusterFuture ...
[17:48:39.358] - result already collected: FutureResult
[17:48:39.358] result() for ClusterFuture ... done
[17:48:39.358] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.358] result() for ClusterFuture ... done
[17:48:39.359] result() for ClusterFuture ...
[17:48:39.359] - result already collected: FutureResult
[17:48:39.359] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:48:39.359] getGlobalsAndPackages() ...
[17:48:39.359] Searching for globals...
[17:48:39.360] - globals found: [1] ‘print’
[17:48:39.360] Searching for globals ... DONE
[17:48:39.360] Resolving globals: FALSE
[17:48:39.360] 
[17:48:39.360] 
[17:48:39.360] getGlobalsAndPackages() ... DONE
[17:48:39.361] run() for ‘Future’ ...
[17:48:39.361] - state: ‘created’
[17:48:39.361] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.375] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.375]   - Field: ‘node’
[17:48:39.375]   - Field: ‘label’
[17:48:39.375]   - Field: ‘local’
[17:48:39.375]   - Field: ‘owner’
[17:48:39.375]   - Field: ‘envir’
[17:48:39.375]   - Field: ‘workers’
[17:48:39.376]   - Field: ‘packages’
[17:48:39.376]   - Field: ‘gc’
[17:48:39.376]   - Field: ‘conditions’
[17:48:39.376]   - Field: ‘persistent’
[17:48:39.376]   - Field: ‘expr’
[17:48:39.376]   - Field: ‘uuid’
[17:48:39.376]   - Field: ‘seed’
[17:48:39.376]   - Field: ‘version’
[17:48:39.376]   - Field: ‘result’
[17:48:39.376]   - Field: ‘asynchronous’
[17:48:39.376]   - Field: ‘calls’
[17:48:39.377]   - Field: ‘globals’
[17:48:39.377]   - Field: ‘stdout’
[17:48:39.377]   - Field: ‘earlySignal’
[17:48:39.377]   - Field: ‘lazy’
[17:48:39.377]   - Field: ‘state’
[17:48:39.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.377] - Launch lazy future ...
[17:48:39.377] Packages needed by the future expression (n = 0): <none>
[17:48:39.377] Packages needed by future strategies (n = 0): <none>
[17:48:39.378] {
[17:48:39.378]     {
[17:48:39.378]         {
[17:48:39.378]             ...future.startTime <- base::Sys.time()
[17:48:39.378]             {
[17:48:39.378]                 {
[17:48:39.378]                   {
[17:48:39.378]                     {
[17:48:39.378]                       base::local({
[17:48:39.378]                         has_future <- base::requireNamespace("future", 
[17:48:39.378]                           quietly = TRUE)
[17:48:39.378]                         if (has_future) {
[17:48:39.378]                           ns <- base::getNamespace("future")
[17:48:39.378]                           version <- ns[[".package"]][["version"]]
[17:48:39.378]                           if (is.null(version)) 
[17:48:39.378]                             version <- utils::packageVersion("future")
[17:48:39.378]                         }
[17:48:39.378]                         else {
[17:48:39.378]                           version <- NULL
[17:48:39.378]                         }
[17:48:39.378]                         if (!has_future || version < "1.8.0") {
[17:48:39.378]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.378]                             "", base::R.version$version.string), 
[17:48:39.378]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:39.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:39.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.378]                               "release", "version")], collapse = " "), 
[17:48:39.378]                             hostname = base::Sys.info()[["nodename"]])
[17:48:39.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.378]                             info)
[17:48:39.378]                           info <- base::paste(info, collapse = "; ")
[17:48:39.378]                           if (!has_future) {
[17:48:39.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.378]                               info)
[17:48:39.378]                           }
[17:48:39.378]                           else {
[17:48:39.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.378]                               info, version)
[17:48:39.378]                           }
[17:48:39.378]                           base::stop(msg)
[17:48:39.378]                         }
[17:48:39.378]                       })
[17:48:39.378]                     }
[17:48:39.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.378]                     base::options(mc.cores = 1L)
[17:48:39.378]                   }
[17:48:39.378]                   ...future.strategy.old <- future::plan("list")
[17:48:39.378]                   options(future.plan = NULL)
[17:48:39.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.378]                 }
[17:48:39.378]                 ...future.workdir <- getwd()
[17:48:39.378]             }
[17:48:39.378]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.378]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.378]         }
[17:48:39.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.378]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.378]             base::names(...future.oldOptions))
[17:48:39.378]     }
[17:48:39.378]     if (FALSE) {
[17:48:39.378]     }
[17:48:39.378]     else {
[17:48:39.378]         if (TRUE) {
[17:48:39.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.378]                 open = "w")
[17:48:39.378]         }
[17:48:39.378]         else {
[17:48:39.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.378]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.378]         }
[17:48:39.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.378]             base::sink(type = "output", split = FALSE)
[17:48:39.378]             base::close(...future.stdout)
[17:48:39.378]         }, add = TRUE)
[17:48:39.378]     }
[17:48:39.378]     ...future.frame <- base::sys.nframe()
[17:48:39.378]     ...future.conditions <- base::list()
[17:48:39.378]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.378]     if (FALSE) {
[17:48:39.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.378]     }
[17:48:39.378]     ...future.result <- base::tryCatch({
[17:48:39.378]         base::withCallingHandlers({
[17:48:39.378]             ...future.value <- base::withVisible(base::local({
[17:48:39.378]                 ...future.makeSendCondition <- base::local({
[17:48:39.378]                   sendCondition <- NULL
[17:48:39.378]                   function(frame = 1L) {
[17:48:39.378]                     if (is.function(sendCondition)) 
[17:48:39.378]                       return(sendCondition)
[17:48:39.378]                     ns <- getNamespace("parallel")
[17:48:39.378]                     if (exists("sendData", mode = "function", 
[17:48:39.378]                       envir = ns)) {
[17:48:39.378]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.378]                         envir = ns)
[17:48:39.378]                       envir <- sys.frame(frame)
[17:48:39.378]                       master <- NULL
[17:48:39.378]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.378]                         !identical(envir, emptyenv())) {
[17:48:39.378]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.378]                           inherits = FALSE)) {
[17:48:39.378]                           master <- get("master", mode = "list", 
[17:48:39.378]                             envir = envir, inherits = FALSE)
[17:48:39.378]                           if (inherits(master, c("SOCKnode", 
[17:48:39.378]                             "SOCK0node"))) {
[17:48:39.378]                             sendCondition <<- function(cond) {
[17:48:39.378]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.378]                                 success = TRUE)
[17:48:39.378]                               parallel_sendData(master, data)
[17:48:39.378]                             }
[17:48:39.378]                             return(sendCondition)
[17:48:39.378]                           }
[17:48:39.378]                         }
[17:48:39.378]                         frame <- frame + 1L
[17:48:39.378]                         envir <- sys.frame(frame)
[17:48:39.378]                       }
[17:48:39.378]                     }
[17:48:39.378]                     sendCondition <<- function(cond) NULL
[17:48:39.378]                   }
[17:48:39.378]                 })
[17:48:39.378]                 withCallingHandlers({
[17:48:39.378]                   print(42)
[17:48:39.378]                 }, immediateCondition = function(cond) {
[17:48:39.378]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.378]                   sendCondition(cond)
[17:48:39.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.378]                   {
[17:48:39.378]                     inherits <- base::inherits
[17:48:39.378]                     invokeRestart <- base::invokeRestart
[17:48:39.378]                     is.null <- base::is.null
[17:48:39.378]                     muffled <- FALSE
[17:48:39.378]                     if (inherits(cond, "message")) {
[17:48:39.378]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.378]                       if (muffled) 
[17:48:39.378]                         invokeRestart("muffleMessage")
[17:48:39.378]                     }
[17:48:39.378]                     else if (inherits(cond, "warning")) {
[17:48:39.378]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.378]                       if (muffled) 
[17:48:39.378]                         invokeRestart("muffleWarning")
[17:48:39.378]                     }
[17:48:39.378]                     else if (inherits(cond, "condition")) {
[17:48:39.378]                       if (!is.null(pattern)) {
[17:48:39.378]                         computeRestarts <- base::computeRestarts
[17:48:39.378]                         grepl <- base::grepl
[17:48:39.378]                         restarts <- computeRestarts(cond)
[17:48:39.378]                         for (restart in restarts) {
[17:48:39.378]                           name <- restart$name
[17:48:39.378]                           if (is.null(name)) 
[17:48:39.378]                             next
[17:48:39.378]                           if (!grepl(pattern, name)) 
[17:48:39.378]                             next
[17:48:39.378]                           invokeRestart(restart)
[17:48:39.378]                           muffled <- TRUE
[17:48:39.378]                           break
[17:48:39.378]                         }
[17:48:39.378]                       }
[17:48:39.378]                     }
[17:48:39.378]                     invisible(muffled)
[17:48:39.378]                   }
[17:48:39.378]                   muffleCondition(cond)
[17:48:39.378]                 })
[17:48:39.378]             }))
[17:48:39.378]             future::FutureResult(value = ...future.value$value, 
[17:48:39.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.378]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.378]                     ...future.globalenv.names))
[17:48:39.378]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.378]         }, condition = base::local({
[17:48:39.378]             c <- base::c
[17:48:39.378]             inherits <- base::inherits
[17:48:39.378]             invokeRestart <- base::invokeRestart
[17:48:39.378]             length <- base::length
[17:48:39.378]             list <- base::list
[17:48:39.378]             seq.int <- base::seq.int
[17:48:39.378]             signalCondition <- base::signalCondition
[17:48:39.378]             sys.calls <- base::sys.calls
[17:48:39.378]             `[[` <- base::`[[`
[17:48:39.378]             `+` <- base::`+`
[17:48:39.378]             `<<-` <- base::`<<-`
[17:48:39.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.378]                   3L)]
[17:48:39.378]             }
[17:48:39.378]             function(cond) {
[17:48:39.378]                 is_error <- inherits(cond, "error")
[17:48:39.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.378]                   NULL)
[17:48:39.378]                 if (is_error) {
[17:48:39.378]                   sessionInformation <- function() {
[17:48:39.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.378]                       search = base::search(), system = base::Sys.info())
[17:48:39.378]                   }
[17:48:39.378]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.378]                     cond$call), session = sessionInformation(), 
[17:48:39.378]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.378]                   signalCondition(cond)
[17:48:39.378]                 }
[17:48:39.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.378]                 "immediateCondition"))) {
[17:48:39.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.378]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.378]                   if (TRUE && !signal) {
[17:48:39.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.378]                     {
[17:48:39.378]                       inherits <- base::inherits
[17:48:39.378]                       invokeRestart <- base::invokeRestart
[17:48:39.378]                       is.null <- base::is.null
[17:48:39.378]                       muffled <- FALSE
[17:48:39.378]                       if (inherits(cond, "message")) {
[17:48:39.378]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.378]                         if (muffled) 
[17:48:39.378]                           invokeRestart("muffleMessage")
[17:48:39.378]                       }
[17:48:39.378]                       else if (inherits(cond, "warning")) {
[17:48:39.378]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.378]                         if (muffled) 
[17:48:39.378]                           invokeRestart("muffleWarning")
[17:48:39.378]                       }
[17:48:39.378]                       else if (inherits(cond, "condition")) {
[17:48:39.378]                         if (!is.null(pattern)) {
[17:48:39.378]                           computeRestarts <- base::computeRestarts
[17:48:39.378]                           grepl <- base::grepl
[17:48:39.378]                           restarts <- computeRestarts(cond)
[17:48:39.378]                           for (restart in restarts) {
[17:48:39.378]                             name <- restart$name
[17:48:39.378]                             if (is.null(name)) 
[17:48:39.378]                               next
[17:48:39.378]                             if (!grepl(pattern, name)) 
[17:48:39.378]                               next
[17:48:39.378]                             invokeRestart(restart)
[17:48:39.378]                             muffled <- TRUE
[17:48:39.378]                             break
[17:48:39.378]                           }
[17:48:39.378]                         }
[17:48:39.378]                       }
[17:48:39.378]                       invisible(muffled)
[17:48:39.378]                     }
[17:48:39.378]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.378]                   }
[17:48:39.378]                 }
[17:48:39.378]                 else {
[17:48:39.378]                   if (TRUE) {
[17:48:39.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.378]                     {
[17:48:39.378]                       inherits <- base::inherits
[17:48:39.378]                       invokeRestart <- base::invokeRestart
[17:48:39.378]                       is.null <- base::is.null
[17:48:39.378]                       muffled <- FALSE
[17:48:39.378]                       if (inherits(cond, "message")) {
[17:48:39.378]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.378]                         if (muffled) 
[17:48:39.378]                           invokeRestart("muffleMessage")
[17:48:39.378]                       }
[17:48:39.378]                       else if (inherits(cond, "warning")) {
[17:48:39.378]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.378]                         if (muffled) 
[17:48:39.378]                           invokeRestart("muffleWarning")
[17:48:39.378]                       }
[17:48:39.378]                       else if (inherits(cond, "condition")) {
[17:48:39.378]                         if (!is.null(pattern)) {
[17:48:39.378]                           computeRestarts <- base::computeRestarts
[17:48:39.378]                           grepl <- base::grepl
[17:48:39.378]                           restarts <- computeRestarts(cond)
[17:48:39.378]                           for (restart in restarts) {
[17:48:39.378]                             name <- restart$name
[17:48:39.378]                             if (is.null(name)) 
[17:48:39.378]                               next
[17:48:39.378]                             if (!grepl(pattern, name)) 
[17:48:39.378]                               next
[17:48:39.378]                             invokeRestart(restart)
[17:48:39.378]                             muffled <- TRUE
[17:48:39.378]                             break
[17:48:39.378]                           }
[17:48:39.378]                         }
[17:48:39.378]                       }
[17:48:39.378]                       invisible(muffled)
[17:48:39.378]                     }
[17:48:39.378]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.378]                   }
[17:48:39.378]                 }
[17:48:39.378]             }
[17:48:39.378]         }))
[17:48:39.378]     }, error = function(ex) {
[17:48:39.378]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.378]                 ...future.rng), started = ...future.startTime, 
[17:48:39.378]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.378]             version = "1.8"), class = "FutureResult")
[17:48:39.378]     }, finally = {
[17:48:39.378]         if (!identical(...future.workdir, getwd())) 
[17:48:39.378]             setwd(...future.workdir)
[17:48:39.378]         {
[17:48:39.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.378]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.378]             }
[17:48:39.378]             base::options(...future.oldOptions)
[17:48:39.378]             if (.Platform$OS.type == "windows") {
[17:48:39.378]                 old_names <- names(...future.oldEnvVars)
[17:48:39.378]                 envs <- base::Sys.getenv()
[17:48:39.378]                 names <- names(envs)
[17:48:39.378]                 common <- intersect(names, old_names)
[17:48:39.378]                 added <- setdiff(names, old_names)
[17:48:39.378]                 removed <- setdiff(old_names, names)
[17:48:39.378]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.378]                   envs[common]]
[17:48:39.378]                 NAMES <- toupper(changed)
[17:48:39.378]                 args <- list()
[17:48:39.378]                 for (kk in seq_along(NAMES)) {
[17:48:39.378]                   name <- changed[[kk]]
[17:48:39.378]                   NAME <- NAMES[[kk]]
[17:48:39.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.378]                     next
[17:48:39.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.378]                 }
[17:48:39.378]                 NAMES <- toupper(added)
[17:48:39.378]                 for (kk in seq_along(NAMES)) {
[17:48:39.378]                   name <- added[[kk]]
[17:48:39.378]                   NAME <- NAMES[[kk]]
[17:48:39.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.378]                     next
[17:48:39.378]                   args[[name]] <- ""
[17:48:39.378]                 }
[17:48:39.378]                 NAMES <- toupper(removed)
[17:48:39.378]                 for (kk in seq_along(NAMES)) {
[17:48:39.378]                   name <- removed[[kk]]
[17:48:39.378]                   NAME <- NAMES[[kk]]
[17:48:39.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.378]                     next
[17:48:39.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.378]                 }
[17:48:39.378]                 if (length(args) > 0) 
[17:48:39.378]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.378]             }
[17:48:39.378]             else {
[17:48:39.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.378]             }
[17:48:39.378]             {
[17:48:39.378]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.378]                   0L) {
[17:48:39.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.378]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.378]                   base::options(opts)
[17:48:39.378]                 }
[17:48:39.378]                 {
[17:48:39.378]                   {
[17:48:39.378]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.378]                     NULL
[17:48:39.378]                   }
[17:48:39.378]                   options(future.plan = NULL)
[17:48:39.378]                   if (is.na(NA_character_)) 
[17:48:39.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.378]                     .init = FALSE)
[17:48:39.378]                 }
[17:48:39.378]             }
[17:48:39.378]         }
[17:48:39.378]     })
[17:48:39.378]     if (TRUE) {
[17:48:39.378]         base::sink(type = "output", split = FALSE)
[17:48:39.378]         if (TRUE) {
[17:48:39.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.378]         }
[17:48:39.378]         else {
[17:48:39.378]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.378]         }
[17:48:39.378]         base::close(...future.stdout)
[17:48:39.378]         ...future.stdout <- NULL
[17:48:39.378]     }
[17:48:39.378]     ...future.result$conditions <- ...future.conditions
[17:48:39.378]     ...future.result$finished <- base::Sys.time()
[17:48:39.378]     ...future.result
[17:48:39.378] }
[17:48:39.381] MultisessionFuture started
[17:48:39.381] - Launch lazy future ... done
[17:48:39.381] run() for ‘MultisessionFuture’ ... done
[17:48:39.381] result() for ClusterFuture ...
[17:48:39.382] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.382] - Validating connection of MultisessionFuture
[17:48:39.383] - received message: FutureResult
[17:48:39.383] - Received FutureResult
[17:48:39.383] - Erased future from FutureRegistry
[17:48:39.383] result() for ClusterFuture ...
[17:48:39.383] - result already collected: FutureResult
[17:48:39.383] result() for ClusterFuture ... done
[17:48:39.383] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.384] result() for ClusterFuture ... done
[17:48:39.384] result() for ClusterFuture ...
[17:48:39.384] - result already collected: FutureResult
[17:48:39.384] result() for ClusterFuture ... done
[17:48:39.384] result() for ClusterFuture ...
[17:48:39.384] - result already collected: FutureResult
[17:48:39.384] result() for ClusterFuture ... done
[1] 42
[17:48:39.384] result() for ClusterFuture ...
[17:48:39.384] - result already collected: FutureResult
[17:48:39.384] result() for ClusterFuture ... done
- stdout = NA
[17:48:39.385] getGlobalsAndPackages() ...
[17:48:39.385] Searching for globals...
[17:48:39.387] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:39.388] Searching for globals ... DONE
[17:48:39.388] Resolving globals: FALSE
[17:48:39.388] 
[17:48:39.388] - packages: [1] ‘utils’
[17:48:39.388] getGlobalsAndPackages() ... DONE
[17:48:39.389] run() for ‘Future’ ...
[17:48:39.389] - state: ‘created’
[17:48:39.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.403] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.403]   - Field: ‘node’
[17:48:39.403]   - Field: ‘label’
[17:48:39.403]   - Field: ‘local’
[17:48:39.403]   - Field: ‘owner’
[17:48:39.403]   - Field: ‘envir’
[17:48:39.403]   - Field: ‘workers’
[17:48:39.404]   - Field: ‘packages’
[17:48:39.404]   - Field: ‘gc’
[17:48:39.404]   - Field: ‘conditions’
[17:48:39.404]   - Field: ‘persistent’
[17:48:39.404]   - Field: ‘expr’
[17:48:39.404]   - Field: ‘uuid’
[17:48:39.404]   - Field: ‘seed’
[17:48:39.404]   - Field: ‘version’
[17:48:39.404]   - Field: ‘result’
[17:48:39.404]   - Field: ‘asynchronous’
[17:48:39.404]   - Field: ‘calls’
[17:48:39.405]   - Field: ‘globals’
[17:48:39.405]   - Field: ‘stdout’
[17:48:39.405]   - Field: ‘earlySignal’
[17:48:39.405]   - Field: ‘lazy’
[17:48:39.405]   - Field: ‘state’
[17:48:39.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.405] - Launch lazy future ...
[17:48:39.407] Packages needed by the future expression (n = 1): ‘utils’
[17:48:39.407] Packages needed by future strategies (n = 0): <none>
[17:48:39.408] {
[17:48:39.408]     {
[17:48:39.408]         {
[17:48:39.408]             ...future.startTime <- base::Sys.time()
[17:48:39.408]             {
[17:48:39.408]                 {
[17:48:39.408]                   {
[17:48:39.408]                     {
[17:48:39.408]                       {
[17:48:39.408]                         base::local({
[17:48:39.408]                           has_future <- base::requireNamespace("future", 
[17:48:39.408]                             quietly = TRUE)
[17:48:39.408]                           if (has_future) {
[17:48:39.408]                             ns <- base::getNamespace("future")
[17:48:39.408]                             version <- ns[[".package"]][["version"]]
[17:48:39.408]                             if (is.null(version)) 
[17:48:39.408]                               version <- utils::packageVersion("future")
[17:48:39.408]                           }
[17:48:39.408]                           else {
[17:48:39.408]                             version <- NULL
[17:48:39.408]                           }
[17:48:39.408]                           if (!has_future || version < "1.8.0") {
[17:48:39.408]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.408]                               "", base::R.version$version.string), 
[17:48:39.408]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:39.408]                                 base::R.version$platform, 8 * 
[17:48:39.408]                                   base::.Machine$sizeof.pointer), 
[17:48:39.408]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.408]                                 "release", "version")], collapse = " "), 
[17:48:39.408]                               hostname = base::Sys.info()[["nodename"]])
[17:48:39.408]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.408]                               info)
[17:48:39.408]                             info <- base::paste(info, collapse = "; ")
[17:48:39.408]                             if (!has_future) {
[17:48:39.408]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.408]                                 info)
[17:48:39.408]                             }
[17:48:39.408]                             else {
[17:48:39.408]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.408]                                 info, version)
[17:48:39.408]                             }
[17:48:39.408]                             base::stop(msg)
[17:48:39.408]                           }
[17:48:39.408]                         })
[17:48:39.408]                       }
[17:48:39.408]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.408]                       base::options(mc.cores = 1L)
[17:48:39.408]                     }
[17:48:39.408]                     base::local({
[17:48:39.408]                       for (pkg in "utils") {
[17:48:39.408]                         base::loadNamespace(pkg)
[17:48:39.408]                         base::library(pkg, character.only = TRUE)
[17:48:39.408]                       }
[17:48:39.408]                     })
[17:48:39.408]                   }
[17:48:39.408]                   ...future.strategy.old <- future::plan("list")
[17:48:39.408]                   options(future.plan = NULL)
[17:48:39.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.408]                 }
[17:48:39.408]                 ...future.workdir <- getwd()
[17:48:39.408]             }
[17:48:39.408]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.408]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.408]         }
[17:48:39.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.408]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.408]             base::names(...future.oldOptions))
[17:48:39.408]     }
[17:48:39.408]     if (TRUE) {
[17:48:39.408]     }
[17:48:39.408]     else {
[17:48:39.408]         if (NA) {
[17:48:39.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.408]                 open = "w")
[17:48:39.408]         }
[17:48:39.408]         else {
[17:48:39.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.408]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.408]         }
[17:48:39.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.408]             base::sink(type = "output", split = FALSE)
[17:48:39.408]             base::close(...future.stdout)
[17:48:39.408]         }, add = TRUE)
[17:48:39.408]     }
[17:48:39.408]     ...future.frame <- base::sys.nframe()
[17:48:39.408]     ...future.conditions <- base::list()
[17:48:39.408]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.408]     if (FALSE) {
[17:48:39.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.408]     }
[17:48:39.408]     ...future.result <- base::tryCatch({
[17:48:39.408]         base::withCallingHandlers({
[17:48:39.408]             ...future.value <- base::withVisible(base::local({
[17:48:39.408]                 ...future.makeSendCondition <- base::local({
[17:48:39.408]                   sendCondition <- NULL
[17:48:39.408]                   function(frame = 1L) {
[17:48:39.408]                     if (is.function(sendCondition)) 
[17:48:39.408]                       return(sendCondition)
[17:48:39.408]                     ns <- getNamespace("parallel")
[17:48:39.408]                     if (exists("sendData", mode = "function", 
[17:48:39.408]                       envir = ns)) {
[17:48:39.408]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.408]                         envir = ns)
[17:48:39.408]                       envir <- sys.frame(frame)
[17:48:39.408]                       master <- NULL
[17:48:39.408]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.408]                         !identical(envir, emptyenv())) {
[17:48:39.408]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.408]                           inherits = FALSE)) {
[17:48:39.408]                           master <- get("master", mode = "list", 
[17:48:39.408]                             envir = envir, inherits = FALSE)
[17:48:39.408]                           if (inherits(master, c("SOCKnode", 
[17:48:39.408]                             "SOCK0node"))) {
[17:48:39.408]                             sendCondition <<- function(cond) {
[17:48:39.408]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.408]                                 success = TRUE)
[17:48:39.408]                               parallel_sendData(master, data)
[17:48:39.408]                             }
[17:48:39.408]                             return(sendCondition)
[17:48:39.408]                           }
[17:48:39.408]                         }
[17:48:39.408]                         frame <- frame + 1L
[17:48:39.408]                         envir <- sys.frame(frame)
[17:48:39.408]                       }
[17:48:39.408]                     }
[17:48:39.408]                     sendCondition <<- function(cond) NULL
[17:48:39.408]                   }
[17:48:39.408]                 })
[17:48:39.408]                 withCallingHandlers({
[17:48:39.408]                   {
[17:48:39.408]                     print(1:50)
[17:48:39.408]                     str(1:50)
[17:48:39.408]                     cat(letters, sep = "-")
[17:48:39.408]                     cat(1:6, collapse = "\n")
[17:48:39.408]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:39.408]                     42L
[17:48:39.408]                   }
[17:48:39.408]                 }, immediateCondition = function(cond) {
[17:48:39.408]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.408]                   sendCondition(cond)
[17:48:39.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.408]                   {
[17:48:39.408]                     inherits <- base::inherits
[17:48:39.408]                     invokeRestart <- base::invokeRestart
[17:48:39.408]                     is.null <- base::is.null
[17:48:39.408]                     muffled <- FALSE
[17:48:39.408]                     if (inherits(cond, "message")) {
[17:48:39.408]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.408]                       if (muffled) 
[17:48:39.408]                         invokeRestart("muffleMessage")
[17:48:39.408]                     }
[17:48:39.408]                     else if (inherits(cond, "warning")) {
[17:48:39.408]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.408]                       if (muffled) 
[17:48:39.408]                         invokeRestart("muffleWarning")
[17:48:39.408]                     }
[17:48:39.408]                     else if (inherits(cond, "condition")) {
[17:48:39.408]                       if (!is.null(pattern)) {
[17:48:39.408]                         computeRestarts <- base::computeRestarts
[17:48:39.408]                         grepl <- base::grepl
[17:48:39.408]                         restarts <- computeRestarts(cond)
[17:48:39.408]                         for (restart in restarts) {
[17:48:39.408]                           name <- restart$name
[17:48:39.408]                           if (is.null(name)) 
[17:48:39.408]                             next
[17:48:39.408]                           if (!grepl(pattern, name)) 
[17:48:39.408]                             next
[17:48:39.408]                           invokeRestart(restart)
[17:48:39.408]                           muffled <- TRUE
[17:48:39.408]                           break
[17:48:39.408]                         }
[17:48:39.408]                       }
[17:48:39.408]                     }
[17:48:39.408]                     invisible(muffled)
[17:48:39.408]                   }
[17:48:39.408]                   muffleCondition(cond)
[17:48:39.408]                 })
[17:48:39.408]             }))
[17:48:39.408]             future::FutureResult(value = ...future.value$value, 
[17:48:39.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.408]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.408]                     ...future.globalenv.names))
[17:48:39.408]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.408]         }, condition = base::local({
[17:48:39.408]             c <- base::c
[17:48:39.408]             inherits <- base::inherits
[17:48:39.408]             invokeRestart <- base::invokeRestart
[17:48:39.408]             length <- base::length
[17:48:39.408]             list <- base::list
[17:48:39.408]             seq.int <- base::seq.int
[17:48:39.408]             signalCondition <- base::signalCondition
[17:48:39.408]             sys.calls <- base::sys.calls
[17:48:39.408]             `[[` <- base::`[[`
[17:48:39.408]             `+` <- base::`+`
[17:48:39.408]             `<<-` <- base::`<<-`
[17:48:39.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.408]                   3L)]
[17:48:39.408]             }
[17:48:39.408]             function(cond) {
[17:48:39.408]                 is_error <- inherits(cond, "error")
[17:48:39.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.408]                   NULL)
[17:48:39.408]                 if (is_error) {
[17:48:39.408]                   sessionInformation <- function() {
[17:48:39.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.408]                       search = base::search(), system = base::Sys.info())
[17:48:39.408]                   }
[17:48:39.408]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.408]                     cond$call), session = sessionInformation(), 
[17:48:39.408]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.408]                   signalCondition(cond)
[17:48:39.408]                 }
[17:48:39.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.408]                 "immediateCondition"))) {
[17:48:39.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.408]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.408]                   if (TRUE && !signal) {
[17:48:39.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.408]                     {
[17:48:39.408]                       inherits <- base::inherits
[17:48:39.408]                       invokeRestart <- base::invokeRestart
[17:48:39.408]                       is.null <- base::is.null
[17:48:39.408]                       muffled <- FALSE
[17:48:39.408]                       if (inherits(cond, "message")) {
[17:48:39.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.408]                         if (muffled) 
[17:48:39.408]                           invokeRestart("muffleMessage")
[17:48:39.408]                       }
[17:48:39.408]                       else if (inherits(cond, "warning")) {
[17:48:39.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.408]                         if (muffled) 
[17:48:39.408]                           invokeRestart("muffleWarning")
[17:48:39.408]                       }
[17:48:39.408]                       else if (inherits(cond, "condition")) {
[17:48:39.408]                         if (!is.null(pattern)) {
[17:48:39.408]                           computeRestarts <- base::computeRestarts
[17:48:39.408]                           grepl <- base::grepl
[17:48:39.408]                           restarts <- computeRestarts(cond)
[17:48:39.408]                           for (restart in restarts) {
[17:48:39.408]                             name <- restart$name
[17:48:39.408]                             if (is.null(name)) 
[17:48:39.408]                               next
[17:48:39.408]                             if (!grepl(pattern, name)) 
[17:48:39.408]                               next
[17:48:39.408]                             invokeRestart(restart)
[17:48:39.408]                             muffled <- TRUE
[17:48:39.408]                             break
[17:48:39.408]                           }
[17:48:39.408]                         }
[17:48:39.408]                       }
[17:48:39.408]                       invisible(muffled)
[17:48:39.408]                     }
[17:48:39.408]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.408]                   }
[17:48:39.408]                 }
[17:48:39.408]                 else {
[17:48:39.408]                   if (TRUE) {
[17:48:39.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.408]                     {
[17:48:39.408]                       inherits <- base::inherits
[17:48:39.408]                       invokeRestart <- base::invokeRestart
[17:48:39.408]                       is.null <- base::is.null
[17:48:39.408]                       muffled <- FALSE
[17:48:39.408]                       if (inherits(cond, "message")) {
[17:48:39.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.408]                         if (muffled) 
[17:48:39.408]                           invokeRestart("muffleMessage")
[17:48:39.408]                       }
[17:48:39.408]                       else if (inherits(cond, "warning")) {
[17:48:39.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.408]                         if (muffled) 
[17:48:39.408]                           invokeRestart("muffleWarning")
[17:48:39.408]                       }
[17:48:39.408]                       else if (inherits(cond, "condition")) {
[17:48:39.408]                         if (!is.null(pattern)) {
[17:48:39.408]                           computeRestarts <- base::computeRestarts
[17:48:39.408]                           grepl <- base::grepl
[17:48:39.408]                           restarts <- computeRestarts(cond)
[17:48:39.408]                           for (restart in restarts) {
[17:48:39.408]                             name <- restart$name
[17:48:39.408]                             if (is.null(name)) 
[17:48:39.408]                               next
[17:48:39.408]                             if (!grepl(pattern, name)) 
[17:48:39.408]                               next
[17:48:39.408]                             invokeRestart(restart)
[17:48:39.408]                             muffled <- TRUE
[17:48:39.408]                             break
[17:48:39.408]                           }
[17:48:39.408]                         }
[17:48:39.408]                       }
[17:48:39.408]                       invisible(muffled)
[17:48:39.408]                     }
[17:48:39.408]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.408]                   }
[17:48:39.408]                 }
[17:48:39.408]             }
[17:48:39.408]         }))
[17:48:39.408]     }, error = function(ex) {
[17:48:39.408]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.408]                 ...future.rng), started = ...future.startTime, 
[17:48:39.408]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.408]             version = "1.8"), class = "FutureResult")
[17:48:39.408]     }, finally = {
[17:48:39.408]         if (!identical(...future.workdir, getwd())) 
[17:48:39.408]             setwd(...future.workdir)
[17:48:39.408]         {
[17:48:39.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.408]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.408]             }
[17:48:39.408]             base::options(...future.oldOptions)
[17:48:39.408]             if (.Platform$OS.type == "windows") {
[17:48:39.408]                 old_names <- names(...future.oldEnvVars)
[17:48:39.408]                 envs <- base::Sys.getenv()
[17:48:39.408]                 names <- names(envs)
[17:48:39.408]                 common <- intersect(names, old_names)
[17:48:39.408]                 added <- setdiff(names, old_names)
[17:48:39.408]                 removed <- setdiff(old_names, names)
[17:48:39.408]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.408]                   envs[common]]
[17:48:39.408]                 NAMES <- toupper(changed)
[17:48:39.408]                 args <- list()
[17:48:39.408]                 for (kk in seq_along(NAMES)) {
[17:48:39.408]                   name <- changed[[kk]]
[17:48:39.408]                   NAME <- NAMES[[kk]]
[17:48:39.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.408]                     next
[17:48:39.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.408]                 }
[17:48:39.408]                 NAMES <- toupper(added)
[17:48:39.408]                 for (kk in seq_along(NAMES)) {
[17:48:39.408]                   name <- added[[kk]]
[17:48:39.408]                   NAME <- NAMES[[kk]]
[17:48:39.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.408]                     next
[17:48:39.408]                   args[[name]] <- ""
[17:48:39.408]                 }
[17:48:39.408]                 NAMES <- toupper(removed)
[17:48:39.408]                 for (kk in seq_along(NAMES)) {
[17:48:39.408]                   name <- removed[[kk]]
[17:48:39.408]                   NAME <- NAMES[[kk]]
[17:48:39.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.408]                     next
[17:48:39.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.408]                 }
[17:48:39.408]                 if (length(args) > 0) 
[17:48:39.408]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.408]             }
[17:48:39.408]             else {
[17:48:39.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.408]             }
[17:48:39.408]             {
[17:48:39.408]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.408]                   0L) {
[17:48:39.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.408]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.408]                   base::options(opts)
[17:48:39.408]                 }
[17:48:39.408]                 {
[17:48:39.408]                   {
[17:48:39.408]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.408]                     NULL
[17:48:39.408]                   }
[17:48:39.408]                   options(future.plan = NULL)
[17:48:39.408]                   if (is.na(NA_character_)) 
[17:48:39.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.408]                     .init = FALSE)
[17:48:39.408]                 }
[17:48:39.408]             }
[17:48:39.408]         }
[17:48:39.408]     })
[17:48:39.408]     if (FALSE) {
[17:48:39.408]         base::sink(type = "output", split = FALSE)
[17:48:39.408]         if (NA) {
[17:48:39.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.408]         }
[17:48:39.408]         else {
[17:48:39.408]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.408]         }
[17:48:39.408]         base::close(...future.stdout)
[17:48:39.408]         ...future.stdout <- NULL
[17:48:39.408]     }
[17:48:39.408]     ...future.result$conditions <- ...future.conditions
[17:48:39.408]     ...future.result$finished <- base::Sys.time()
[17:48:39.408]     ...future.result
[17:48:39.408] }
[17:48:39.411] MultisessionFuture started
[17:48:39.411] - Launch lazy future ... done
[17:48:39.411] run() for ‘MultisessionFuture’ ... done
[17:48:39.411] result() for ClusterFuture ...
[17:48:39.412] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.412] - Validating connection of MultisessionFuture
[17:48:39.454] - received message: FutureResult
[17:48:39.454] - Received FutureResult
[17:48:39.454] - Erased future from FutureRegistry
[17:48:39.454] result() for ClusterFuture ...
[17:48:39.454] - result already collected: FutureResult
[17:48:39.454] result() for ClusterFuture ... done
[17:48:39.454] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.454] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-11-22 17:48:39"
 $ finished    : POSIXct[1:1], format: "2024-11-22 17:48:39"
 $ session_uuid: chr "e31724b7-b062-c0e2-d1f7-8754e7686beb"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "2570bfddfbfd"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "2570bfddfbfd" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50530
  .. ..$ time  : POSIXct[1:1], format: "2024-11-22 17:48:38"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:48:39.462] result() for ClusterFuture ...
[17:48:39.462] - result already collected: FutureResult
[17:48:39.462] result() for ClusterFuture ... done
[17:48:39.462] result() for ClusterFuture ...
[17:48:39.462] - result already collected: FutureResult
[17:48:39.462] result() for ClusterFuture ... done
[17:48:39.463] getGlobalsAndPackages() ...
[17:48:39.463] Searching for globals...
[17:48:39.465] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:48:39.465] Searching for globals ... DONE
[17:48:39.466] Resolving globals: FALSE
[17:48:39.466] 
[17:48:39.466] - packages: [1] ‘utils’
[17:48:39.466] getGlobalsAndPackages() ... DONE
[17:48:39.467] run() for ‘Future’ ...
[17:48:39.467] - state: ‘created’
[17:48:39.467] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.480] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.481]   - Field: ‘node’
[17:48:39.481]   - Field: ‘label’
[17:48:39.481]   - Field: ‘local’
[17:48:39.481]   - Field: ‘owner’
[17:48:39.481]   - Field: ‘envir’
[17:48:39.481]   - Field: ‘workers’
[17:48:39.481]   - Field: ‘packages’
[17:48:39.481]   - Field: ‘gc’
[17:48:39.481]   - Field: ‘conditions’
[17:48:39.481]   - Field: ‘persistent’
[17:48:39.481]   - Field: ‘expr’
[17:48:39.482]   - Field: ‘uuid’
[17:48:39.482]   - Field: ‘seed’
[17:48:39.482]   - Field: ‘version’
[17:48:39.482]   - Field: ‘result’
[17:48:39.482]   - Field: ‘asynchronous’
[17:48:39.482]   - Field: ‘calls’
[17:48:39.482]   - Field: ‘globals’
[17:48:39.482]   - Field: ‘stdout’
[17:48:39.482]   - Field: ‘earlySignal’
[17:48:39.482]   - Field: ‘lazy’
[17:48:39.482]   - Field: ‘state’
[17:48:39.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.483] - Launch lazy future ...
[17:48:39.483] Packages needed by the future expression (n = 1): ‘utils’
[17:48:39.483] Packages needed by future strategies (n = 0): <none>
[17:48:39.484] {
[17:48:39.484]     {
[17:48:39.484]         {
[17:48:39.484]             ...future.startTime <- base::Sys.time()
[17:48:39.484]             {
[17:48:39.484]                 {
[17:48:39.484]                   {
[17:48:39.484]                     {
[17:48:39.484]                       {
[17:48:39.484]                         base::local({
[17:48:39.484]                           has_future <- base::requireNamespace("future", 
[17:48:39.484]                             quietly = TRUE)
[17:48:39.484]                           if (has_future) {
[17:48:39.484]                             ns <- base::getNamespace("future")
[17:48:39.484]                             version <- ns[[".package"]][["version"]]
[17:48:39.484]                             if (is.null(version)) 
[17:48:39.484]                               version <- utils::packageVersion("future")
[17:48:39.484]                           }
[17:48:39.484]                           else {
[17:48:39.484]                             version <- NULL
[17:48:39.484]                           }
[17:48:39.484]                           if (!has_future || version < "1.8.0") {
[17:48:39.484]                             info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.484]                               "", base::R.version$version.string), 
[17:48:39.484]                               platform = base::sprintf("%s (%s-bit)", 
[17:48:39.484]                                 base::R.version$platform, 8 * 
[17:48:39.484]                                   base::.Machine$sizeof.pointer), 
[17:48:39.484]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.484]                                 "release", "version")], collapse = " "), 
[17:48:39.484]                               hostname = base::Sys.info()[["nodename"]])
[17:48:39.484]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.484]                               info)
[17:48:39.484]                             info <- base::paste(info, collapse = "; ")
[17:48:39.484]                             if (!has_future) {
[17:48:39.484]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.484]                                 info)
[17:48:39.484]                             }
[17:48:39.484]                             else {
[17:48:39.484]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.484]                                 info, version)
[17:48:39.484]                             }
[17:48:39.484]                             base::stop(msg)
[17:48:39.484]                           }
[17:48:39.484]                         })
[17:48:39.484]                       }
[17:48:39.484]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.484]                       base::options(mc.cores = 1L)
[17:48:39.484]                     }
[17:48:39.484]                     base::local({
[17:48:39.484]                       for (pkg in "utils") {
[17:48:39.484]                         base::loadNamespace(pkg)
[17:48:39.484]                         base::library(pkg, character.only = TRUE)
[17:48:39.484]                       }
[17:48:39.484]                     })
[17:48:39.484]                   }
[17:48:39.484]                   ...future.strategy.old <- future::plan("list")
[17:48:39.484]                   options(future.plan = NULL)
[17:48:39.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.484]                 }
[17:48:39.484]                 ...future.workdir <- getwd()
[17:48:39.484]             }
[17:48:39.484]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.484]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.484]         }
[17:48:39.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.484]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.484]             base::names(...future.oldOptions))
[17:48:39.484]     }
[17:48:39.484]     if (TRUE) {
[17:48:39.484]     }
[17:48:39.484]     else {
[17:48:39.484]         if (NA) {
[17:48:39.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.484]                 open = "w")
[17:48:39.484]         }
[17:48:39.484]         else {
[17:48:39.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.484]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.484]         }
[17:48:39.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.484]             base::sink(type = "output", split = FALSE)
[17:48:39.484]             base::close(...future.stdout)
[17:48:39.484]         }, add = TRUE)
[17:48:39.484]     }
[17:48:39.484]     ...future.frame <- base::sys.nframe()
[17:48:39.484]     ...future.conditions <- base::list()
[17:48:39.484]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.484]     if (FALSE) {
[17:48:39.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.484]     }
[17:48:39.484]     ...future.result <- base::tryCatch({
[17:48:39.484]         base::withCallingHandlers({
[17:48:39.484]             ...future.value <- base::withVisible(base::local({
[17:48:39.484]                 ...future.makeSendCondition <- base::local({
[17:48:39.484]                   sendCondition <- NULL
[17:48:39.484]                   function(frame = 1L) {
[17:48:39.484]                     if (is.function(sendCondition)) 
[17:48:39.484]                       return(sendCondition)
[17:48:39.484]                     ns <- getNamespace("parallel")
[17:48:39.484]                     if (exists("sendData", mode = "function", 
[17:48:39.484]                       envir = ns)) {
[17:48:39.484]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.484]                         envir = ns)
[17:48:39.484]                       envir <- sys.frame(frame)
[17:48:39.484]                       master <- NULL
[17:48:39.484]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.484]                         !identical(envir, emptyenv())) {
[17:48:39.484]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.484]                           inherits = FALSE)) {
[17:48:39.484]                           master <- get("master", mode = "list", 
[17:48:39.484]                             envir = envir, inherits = FALSE)
[17:48:39.484]                           if (inherits(master, c("SOCKnode", 
[17:48:39.484]                             "SOCK0node"))) {
[17:48:39.484]                             sendCondition <<- function(cond) {
[17:48:39.484]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.484]                                 success = TRUE)
[17:48:39.484]                               parallel_sendData(master, data)
[17:48:39.484]                             }
[17:48:39.484]                             return(sendCondition)
[17:48:39.484]                           }
[17:48:39.484]                         }
[17:48:39.484]                         frame <- frame + 1L
[17:48:39.484]                         envir <- sys.frame(frame)
[17:48:39.484]                       }
[17:48:39.484]                     }
[17:48:39.484]                     sendCondition <<- function(cond) NULL
[17:48:39.484]                   }
[17:48:39.484]                 })
[17:48:39.484]                 withCallingHandlers({
[17:48:39.484]                   {
[17:48:39.484]                     print(1:50)
[17:48:39.484]                     str(1:50)
[17:48:39.484]                     cat(letters, sep = "-")
[17:48:39.484]                     cat(1:6, collapse = "\n")
[17:48:39.484]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:48:39.484]                     42L
[17:48:39.484]                   }
[17:48:39.484]                 }, immediateCondition = function(cond) {
[17:48:39.484]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.484]                   sendCondition(cond)
[17:48:39.484]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.484]                   {
[17:48:39.484]                     inherits <- base::inherits
[17:48:39.484]                     invokeRestart <- base::invokeRestart
[17:48:39.484]                     is.null <- base::is.null
[17:48:39.484]                     muffled <- FALSE
[17:48:39.484]                     if (inherits(cond, "message")) {
[17:48:39.484]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.484]                       if (muffled) 
[17:48:39.484]                         invokeRestart("muffleMessage")
[17:48:39.484]                     }
[17:48:39.484]                     else if (inherits(cond, "warning")) {
[17:48:39.484]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.484]                       if (muffled) 
[17:48:39.484]                         invokeRestart("muffleWarning")
[17:48:39.484]                     }
[17:48:39.484]                     else if (inherits(cond, "condition")) {
[17:48:39.484]                       if (!is.null(pattern)) {
[17:48:39.484]                         computeRestarts <- base::computeRestarts
[17:48:39.484]                         grepl <- base::grepl
[17:48:39.484]                         restarts <- computeRestarts(cond)
[17:48:39.484]                         for (restart in restarts) {
[17:48:39.484]                           name <- restart$name
[17:48:39.484]                           if (is.null(name)) 
[17:48:39.484]                             next
[17:48:39.484]                           if (!grepl(pattern, name)) 
[17:48:39.484]                             next
[17:48:39.484]                           invokeRestart(restart)
[17:48:39.484]                           muffled <- TRUE
[17:48:39.484]                           break
[17:48:39.484]                         }
[17:48:39.484]                       }
[17:48:39.484]                     }
[17:48:39.484]                     invisible(muffled)
[17:48:39.484]                   }
[17:48:39.484]                   muffleCondition(cond)
[17:48:39.484]                 })
[17:48:39.484]             }))
[17:48:39.484]             future::FutureResult(value = ...future.value$value, 
[17:48:39.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.484]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.484]                     ...future.globalenv.names))
[17:48:39.484]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.484]         }, condition = base::local({
[17:48:39.484]             c <- base::c
[17:48:39.484]             inherits <- base::inherits
[17:48:39.484]             invokeRestart <- base::invokeRestart
[17:48:39.484]             length <- base::length
[17:48:39.484]             list <- base::list
[17:48:39.484]             seq.int <- base::seq.int
[17:48:39.484]             signalCondition <- base::signalCondition
[17:48:39.484]             sys.calls <- base::sys.calls
[17:48:39.484]             `[[` <- base::`[[`
[17:48:39.484]             `+` <- base::`+`
[17:48:39.484]             `<<-` <- base::`<<-`
[17:48:39.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.484]                   3L)]
[17:48:39.484]             }
[17:48:39.484]             function(cond) {
[17:48:39.484]                 is_error <- inherits(cond, "error")
[17:48:39.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.484]                   NULL)
[17:48:39.484]                 if (is_error) {
[17:48:39.484]                   sessionInformation <- function() {
[17:48:39.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.484]                       search = base::search(), system = base::Sys.info())
[17:48:39.484]                   }
[17:48:39.484]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.484]                     cond$call), session = sessionInformation(), 
[17:48:39.484]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.484]                   signalCondition(cond)
[17:48:39.484]                 }
[17:48:39.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.484]                 "immediateCondition"))) {
[17:48:39.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.484]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.484]                   if (TRUE && !signal) {
[17:48:39.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.484]                     {
[17:48:39.484]                       inherits <- base::inherits
[17:48:39.484]                       invokeRestart <- base::invokeRestart
[17:48:39.484]                       is.null <- base::is.null
[17:48:39.484]                       muffled <- FALSE
[17:48:39.484]                       if (inherits(cond, "message")) {
[17:48:39.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.484]                         if (muffled) 
[17:48:39.484]                           invokeRestart("muffleMessage")
[17:48:39.484]                       }
[17:48:39.484]                       else if (inherits(cond, "warning")) {
[17:48:39.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.484]                         if (muffled) 
[17:48:39.484]                           invokeRestart("muffleWarning")
[17:48:39.484]                       }
[17:48:39.484]                       else if (inherits(cond, "condition")) {
[17:48:39.484]                         if (!is.null(pattern)) {
[17:48:39.484]                           computeRestarts <- base::computeRestarts
[17:48:39.484]                           grepl <- base::grepl
[17:48:39.484]                           restarts <- computeRestarts(cond)
[17:48:39.484]                           for (restart in restarts) {
[17:48:39.484]                             name <- restart$name
[17:48:39.484]                             if (is.null(name)) 
[17:48:39.484]                               next
[17:48:39.484]                             if (!grepl(pattern, name)) 
[17:48:39.484]                               next
[17:48:39.484]                             invokeRestart(restart)
[17:48:39.484]                             muffled <- TRUE
[17:48:39.484]                             break
[17:48:39.484]                           }
[17:48:39.484]                         }
[17:48:39.484]                       }
[17:48:39.484]                       invisible(muffled)
[17:48:39.484]                     }
[17:48:39.484]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.484]                   }
[17:48:39.484]                 }
[17:48:39.484]                 else {
[17:48:39.484]                   if (TRUE) {
[17:48:39.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.484]                     {
[17:48:39.484]                       inherits <- base::inherits
[17:48:39.484]                       invokeRestart <- base::invokeRestart
[17:48:39.484]                       is.null <- base::is.null
[17:48:39.484]                       muffled <- FALSE
[17:48:39.484]                       if (inherits(cond, "message")) {
[17:48:39.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.484]                         if (muffled) 
[17:48:39.484]                           invokeRestart("muffleMessage")
[17:48:39.484]                       }
[17:48:39.484]                       else if (inherits(cond, "warning")) {
[17:48:39.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.484]                         if (muffled) 
[17:48:39.484]                           invokeRestart("muffleWarning")
[17:48:39.484]                       }
[17:48:39.484]                       else if (inherits(cond, "condition")) {
[17:48:39.484]                         if (!is.null(pattern)) {
[17:48:39.484]                           computeRestarts <- base::computeRestarts
[17:48:39.484]                           grepl <- base::grepl
[17:48:39.484]                           restarts <- computeRestarts(cond)
[17:48:39.484]                           for (restart in restarts) {
[17:48:39.484]                             name <- restart$name
[17:48:39.484]                             if (is.null(name)) 
[17:48:39.484]                               next
[17:48:39.484]                             if (!grepl(pattern, name)) 
[17:48:39.484]                               next
[17:48:39.484]                             invokeRestart(restart)
[17:48:39.484]                             muffled <- TRUE
[17:48:39.484]                             break
[17:48:39.484]                           }
[17:48:39.484]                         }
[17:48:39.484]                       }
[17:48:39.484]                       invisible(muffled)
[17:48:39.484]                     }
[17:48:39.484]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.484]                   }
[17:48:39.484]                 }
[17:48:39.484]             }
[17:48:39.484]         }))
[17:48:39.484]     }, error = function(ex) {
[17:48:39.484]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.484]                 ...future.rng), started = ...future.startTime, 
[17:48:39.484]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.484]             version = "1.8"), class = "FutureResult")
[17:48:39.484]     }, finally = {
[17:48:39.484]         if (!identical(...future.workdir, getwd())) 
[17:48:39.484]             setwd(...future.workdir)
[17:48:39.484]         {
[17:48:39.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.484]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.484]             }
[17:48:39.484]             base::options(...future.oldOptions)
[17:48:39.484]             if (.Platform$OS.type == "windows") {
[17:48:39.484]                 old_names <- names(...future.oldEnvVars)
[17:48:39.484]                 envs <- base::Sys.getenv()
[17:48:39.484]                 names <- names(envs)
[17:48:39.484]                 common <- intersect(names, old_names)
[17:48:39.484]                 added <- setdiff(names, old_names)
[17:48:39.484]                 removed <- setdiff(old_names, names)
[17:48:39.484]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.484]                   envs[common]]
[17:48:39.484]                 NAMES <- toupper(changed)
[17:48:39.484]                 args <- list()
[17:48:39.484]                 for (kk in seq_along(NAMES)) {
[17:48:39.484]                   name <- changed[[kk]]
[17:48:39.484]                   NAME <- NAMES[[kk]]
[17:48:39.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.484]                     next
[17:48:39.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.484]                 }
[17:48:39.484]                 NAMES <- toupper(added)
[17:48:39.484]                 for (kk in seq_along(NAMES)) {
[17:48:39.484]                   name <- added[[kk]]
[17:48:39.484]                   NAME <- NAMES[[kk]]
[17:48:39.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.484]                     next
[17:48:39.484]                   args[[name]] <- ""
[17:48:39.484]                 }
[17:48:39.484]                 NAMES <- toupper(removed)
[17:48:39.484]                 for (kk in seq_along(NAMES)) {
[17:48:39.484]                   name <- removed[[kk]]
[17:48:39.484]                   NAME <- NAMES[[kk]]
[17:48:39.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.484]                     next
[17:48:39.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.484]                 }
[17:48:39.484]                 if (length(args) > 0) 
[17:48:39.484]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.484]             }
[17:48:39.484]             else {
[17:48:39.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.484]             }
[17:48:39.484]             {
[17:48:39.484]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.484]                   0L) {
[17:48:39.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.484]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.484]                   base::options(opts)
[17:48:39.484]                 }
[17:48:39.484]                 {
[17:48:39.484]                   {
[17:48:39.484]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.484]                     NULL
[17:48:39.484]                   }
[17:48:39.484]                   options(future.plan = NULL)
[17:48:39.484]                   if (is.na(NA_character_)) 
[17:48:39.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.484]                     .init = FALSE)
[17:48:39.484]                 }
[17:48:39.484]             }
[17:48:39.484]         }
[17:48:39.484]     })
[17:48:39.484]     if (FALSE) {
[17:48:39.484]         base::sink(type = "output", split = FALSE)
[17:48:39.484]         if (NA) {
[17:48:39.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.484]         }
[17:48:39.484]         else {
[17:48:39.484]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.484]         }
[17:48:39.484]         base::close(...future.stdout)
[17:48:39.484]         ...future.stdout <- NULL
[17:48:39.484]     }
[17:48:39.484]     ...future.result$conditions <- ...future.conditions
[17:48:39.484]     ...future.result$finished <- base::Sys.time()
[17:48:39.484]     ...future.result
[17:48:39.484] }
[17:48:39.487] MultisessionFuture started
[17:48:39.487] - Launch lazy future ... done
[17:48:39.487] run() for ‘MultisessionFuture’ ... done
[17:48:39.487] result() for ClusterFuture ...
[17:48:39.487] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.487] - Validating connection of MultisessionFuture
[17:48:39.530] - received message: FutureResult
[17:48:39.530] - Received FutureResult
[17:48:39.530] - Erased future from FutureRegistry
[17:48:39.530] result() for ClusterFuture ...
[17:48:39.530] - result already collected: FutureResult
[17:48:39.530] result() for ClusterFuture ... done
[17:48:39.530] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.531] result() for ClusterFuture ... done
[17:48:39.531] result() for ClusterFuture ...
[17:48:39.531] - result already collected: FutureResult
[17:48:39.531] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:48:39.531] getGlobalsAndPackages() ...
[17:48:39.531] Searching for globals...
[17:48:39.532] - globals found: [1] ‘print’
[17:48:39.532] Searching for globals ... DONE
[17:48:39.532] Resolving globals: FALSE
[17:48:39.532] 
[17:48:39.532] 
[17:48:39.532] getGlobalsAndPackages() ... DONE
[17:48:39.533] run() for ‘Future’ ...
[17:48:39.533] - state: ‘created’
[17:48:39.533] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:39.549] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:39.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:39.549]   - Field: ‘node’
[17:48:39.549]   - Field: ‘label’
[17:48:39.549]   - Field: ‘local’
[17:48:39.549]   - Field: ‘owner’
[17:48:39.549]   - Field: ‘envir’
[17:48:39.550]   - Field: ‘workers’
[17:48:39.550]   - Field: ‘packages’
[17:48:39.550]   - Field: ‘gc’
[17:48:39.550]   - Field: ‘conditions’
[17:48:39.550]   - Field: ‘persistent’
[17:48:39.550]   - Field: ‘expr’
[17:48:39.550]   - Field: ‘uuid’
[17:48:39.550]   - Field: ‘seed’
[17:48:39.550]   - Field: ‘version’
[17:48:39.550]   - Field: ‘result’
[17:48:39.550]   - Field: ‘asynchronous’
[17:48:39.551]   - Field: ‘calls’
[17:48:39.551]   - Field: ‘globals’
[17:48:39.551]   - Field: ‘stdout’
[17:48:39.551]   - Field: ‘earlySignal’
[17:48:39.551]   - Field: ‘lazy’
[17:48:39.551]   - Field: ‘state’
[17:48:39.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:39.551] - Launch lazy future ...
[17:48:39.551] Packages needed by the future expression (n = 0): <none>
[17:48:39.552] Packages needed by future strategies (n = 0): <none>
[17:48:39.552] {
[17:48:39.552]     {
[17:48:39.552]         {
[17:48:39.552]             ...future.startTime <- base::Sys.time()
[17:48:39.552]             {
[17:48:39.552]                 {
[17:48:39.552]                   {
[17:48:39.552]                     {
[17:48:39.552]                       base::local({
[17:48:39.552]                         has_future <- base::requireNamespace("future", 
[17:48:39.552]                           quietly = TRUE)
[17:48:39.552]                         if (has_future) {
[17:48:39.552]                           ns <- base::getNamespace("future")
[17:48:39.552]                           version <- ns[[".package"]][["version"]]
[17:48:39.552]                           if (is.null(version)) 
[17:48:39.552]                             version <- utils::packageVersion("future")
[17:48:39.552]                         }
[17:48:39.552]                         else {
[17:48:39.552]                           version <- NULL
[17:48:39.552]                         }
[17:48:39.552]                         if (!has_future || version < "1.8.0") {
[17:48:39.552]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:39.552]                             "", base::R.version$version.string), 
[17:48:39.552]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:39.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:39.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:39.552]                               "release", "version")], collapse = " "), 
[17:48:39.552]                             hostname = base::Sys.info()[["nodename"]])
[17:48:39.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:39.552]                             info)
[17:48:39.552]                           info <- base::paste(info, collapse = "; ")
[17:48:39.552]                           if (!has_future) {
[17:48:39.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:39.552]                               info)
[17:48:39.552]                           }
[17:48:39.552]                           else {
[17:48:39.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:39.552]                               info, version)
[17:48:39.552]                           }
[17:48:39.552]                           base::stop(msg)
[17:48:39.552]                         }
[17:48:39.552]                       })
[17:48:39.552]                     }
[17:48:39.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:39.552]                     base::options(mc.cores = 1L)
[17:48:39.552]                   }
[17:48:39.552]                   ...future.strategy.old <- future::plan("list")
[17:48:39.552]                   options(future.plan = NULL)
[17:48:39.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:39.552]                 }
[17:48:39.552]                 ...future.workdir <- getwd()
[17:48:39.552]             }
[17:48:39.552]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:39.552]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:39.552]         }
[17:48:39.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:39.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:39.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:39.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:39.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:39.552]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:39.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:39.552]             base::names(...future.oldOptions))
[17:48:39.552]     }
[17:48:39.552]     if (FALSE) {
[17:48:39.552]     }
[17:48:39.552]     else {
[17:48:39.552]         if (TRUE) {
[17:48:39.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:39.552]                 open = "w")
[17:48:39.552]         }
[17:48:39.552]         else {
[17:48:39.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:39.552]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:39.552]         }
[17:48:39.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:39.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:39.552]             base::sink(type = "output", split = FALSE)
[17:48:39.552]             base::close(...future.stdout)
[17:48:39.552]         }, add = TRUE)
[17:48:39.552]     }
[17:48:39.552]     ...future.frame <- base::sys.nframe()
[17:48:39.552]     ...future.conditions <- base::list()
[17:48:39.552]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:39.552]     if (FALSE) {
[17:48:39.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:39.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:39.552]     }
[17:48:39.552]     ...future.result <- base::tryCatch({
[17:48:39.552]         base::withCallingHandlers({
[17:48:39.552]             ...future.value <- base::withVisible(base::local({
[17:48:39.552]                 ...future.makeSendCondition <- base::local({
[17:48:39.552]                   sendCondition <- NULL
[17:48:39.552]                   function(frame = 1L) {
[17:48:39.552]                     if (is.function(sendCondition)) 
[17:48:39.552]                       return(sendCondition)
[17:48:39.552]                     ns <- getNamespace("parallel")
[17:48:39.552]                     if (exists("sendData", mode = "function", 
[17:48:39.552]                       envir = ns)) {
[17:48:39.552]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:39.552]                         envir = ns)
[17:48:39.552]                       envir <- sys.frame(frame)
[17:48:39.552]                       master <- NULL
[17:48:39.552]                       while (!identical(envir, .GlobalEnv) && 
[17:48:39.552]                         !identical(envir, emptyenv())) {
[17:48:39.552]                         if (exists("master", mode = "list", envir = envir, 
[17:48:39.552]                           inherits = FALSE)) {
[17:48:39.552]                           master <- get("master", mode = "list", 
[17:48:39.552]                             envir = envir, inherits = FALSE)
[17:48:39.552]                           if (inherits(master, c("SOCKnode", 
[17:48:39.552]                             "SOCK0node"))) {
[17:48:39.552]                             sendCondition <<- function(cond) {
[17:48:39.552]                               data <- list(type = "VALUE", value = cond, 
[17:48:39.552]                                 success = TRUE)
[17:48:39.552]                               parallel_sendData(master, data)
[17:48:39.552]                             }
[17:48:39.552]                             return(sendCondition)
[17:48:39.552]                           }
[17:48:39.552]                         }
[17:48:39.552]                         frame <- frame + 1L
[17:48:39.552]                         envir <- sys.frame(frame)
[17:48:39.552]                       }
[17:48:39.552]                     }
[17:48:39.552]                     sendCondition <<- function(cond) NULL
[17:48:39.552]                   }
[17:48:39.552]                 })
[17:48:39.552]                 withCallingHandlers({
[17:48:39.552]                   print(42)
[17:48:39.552]                 }, immediateCondition = function(cond) {
[17:48:39.552]                   sendCondition <- ...future.makeSendCondition()
[17:48:39.552]                   sendCondition(cond)
[17:48:39.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.552]                   {
[17:48:39.552]                     inherits <- base::inherits
[17:48:39.552]                     invokeRestart <- base::invokeRestart
[17:48:39.552]                     is.null <- base::is.null
[17:48:39.552]                     muffled <- FALSE
[17:48:39.552]                     if (inherits(cond, "message")) {
[17:48:39.552]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:39.552]                       if (muffled) 
[17:48:39.552]                         invokeRestart("muffleMessage")
[17:48:39.552]                     }
[17:48:39.552]                     else if (inherits(cond, "warning")) {
[17:48:39.552]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:39.552]                       if (muffled) 
[17:48:39.552]                         invokeRestart("muffleWarning")
[17:48:39.552]                     }
[17:48:39.552]                     else if (inherits(cond, "condition")) {
[17:48:39.552]                       if (!is.null(pattern)) {
[17:48:39.552]                         computeRestarts <- base::computeRestarts
[17:48:39.552]                         grepl <- base::grepl
[17:48:39.552]                         restarts <- computeRestarts(cond)
[17:48:39.552]                         for (restart in restarts) {
[17:48:39.552]                           name <- restart$name
[17:48:39.552]                           if (is.null(name)) 
[17:48:39.552]                             next
[17:48:39.552]                           if (!grepl(pattern, name)) 
[17:48:39.552]                             next
[17:48:39.552]                           invokeRestart(restart)
[17:48:39.552]                           muffled <- TRUE
[17:48:39.552]                           break
[17:48:39.552]                         }
[17:48:39.552]                       }
[17:48:39.552]                     }
[17:48:39.552]                     invisible(muffled)
[17:48:39.552]                   }
[17:48:39.552]                   muffleCondition(cond)
[17:48:39.552]                 })
[17:48:39.552]             }))
[17:48:39.552]             future::FutureResult(value = ...future.value$value, 
[17:48:39.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.552]                   ...future.rng), globalenv = if (FALSE) 
[17:48:39.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:39.552]                     ...future.globalenv.names))
[17:48:39.552]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:39.552]         }, condition = base::local({
[17:48:39.552]             c <- base::c
[17:48:39.552]             inherits <- base::inherits
[17:48:39.552]             invokeRestart <- base::invokeRestart
[17:48:39.552]             length <- base::length
[17:48:39.552]             list <- base::list
[17:48:39.552]             seq.int <- base::seq.int
[17:48:39.552]             signalCondition <- base::signalCondition
[17:48:39.552]             sys.calls <- base::sys.calls
[17:48:39.552]             `[[` <- base::`[[`
[17:48:39.552]             `+` <- base::`+`
[17:48:39.552]             `<<-` <- base::`<<-`
[17:48:39.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:39.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:39.552]                   3L)]
[17:48:39.552]             }
[17:48:39.552]             function(cond) {
[17:48:39.552]                 is_error <- inherits(cond, "error")
[17:48:39.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:39.552]                   NULL)
[17:48:39.552]                 if (is_error) {
[17:48:39.552]                   sessionInformation <- function() {
[17:48:39.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:39.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:39.552]                       search = base::search(), system = base::Sys.info())
[17:48:39.552]                   }
[17:48:39.552]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:39.552]                     cond$call), session = sessionInformation(), 
[17:48:39.552]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:39.552]                   signalCondition(cond)
[17:48:39.552]                 }
[17:48:39.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:39.552]                 "immediateCondition"))) {
[17:48:39.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:39.552]                   ...future.conditions[[length(...future.conditions) + 
[17:48:39.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:39.552]                   if (TRUE && !signal) {
[17:48:39.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.552]                     {
[17:48:39.552]                       inherits <- base::inherits
[17:48:39.552]                       invokeRestart <- base::invokeRestart
[17:48:39.552]                       is.null <- base::is.null
[17:48:39.552]                       muffled <- FALSE
[17:48:39.552]                       if (inherits(cond, "message")) {
[17:48:39.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.552]                         if (muffled) 
[17:48:39.552]                           invokeRestart("muffleMessage")
[17:48:39.552]                       }
[17:48:39.552]                       else if (inherits(cond, "warning")) {
[17:48:39.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.552]                         if (muffled) 
[17:48:39.552]                           invokeRestart("muffleWarning")
[17:48:39.552]                       }
[17:48:39.552]                       else if (inherits(cond, "condition")) {
[17:48:39.552]                         if (!is.null(pattern)) {
[17:48:39.552]                           computeRestarts <- base::computeRestarts
[17:48:39.552]                           grepl <- base::grepl
[17:48:39.552]                           restarts <- computeRestarts(cond)
[17:48:39.552]                           for (restart in restarts) {
[17:48:39.552]                             name <- restart$name
[17:48:39.552]                             if (is.null(name)) 
[17:48:39.552]                               next
[17:48:39.552]                             if (!grepl(pattern, name)) 
[17:48:39.552]                               next
[17:48:39.552]                             invokeRestart(restart)
[17:48:39.552]                             muffled <- TRUE
[17:48:39.552]                             break
[17:48:39.552]                           }
[17:48:39.552]                         }
[17:48:39.552]                       }
[17:48:39.552]                       invisible(muffled)
[17:48:39.552]                     }
[17:48:39.552]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.552]                   }
[17:48:39.552]                 }
[17:48:39.552]                 else {
[17:48:39.552]                   if (TRUE) {
[17:48:39.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:39.552]                     {
[17:48:39.552]                       inherits <- base::inherits
[17:48:39.552]                       invokeRestart <- base::invokeRestart
[17:48:39.552]                       is.null <- base::is.null
[17:48:39.552]                       muffled <- FALSE
[17:48:39.552]                       if (inherits(cond, "message")) {
[17:48:39.552]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:39.552]                         if (muffled) 
[17:48:39.552]                           invokeRestart("muffleMessage")
[17:48:39.552]                       }
[17:48:39.552]                       else if (inherits(cond, "warning")) {
[17:48:39.552]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:39.552]                         if (muffled) 
[17:48:39.552]                           invokeRestart("muffleWarning")
[17:48:39.552]                       }
[17:48:39.552]                       else if (inherits(cond, "condition")) {
[17:48:39.552]                         if (!is.null(pattern)) {
[17:48:39.552]                           computeRestarts <- base::computeRestarts
[17:48:39.552]                           grepl <- base::grepl
[17:48:39.552]                           restarts <- computeRestarts(cond)
[17:48:39.552]                           for (restart in restarts) {
[17:48:39.552]                             name <- restart$name
[17:48:39.552]                             if (is.null(name)) 
[17:48:39.552]                               next
[17:48:39.552]                             if (!grepl(pattern, name)) 
[17:48:39.552]                               next
[17:48:39.552]                             invokeRestart(restart)
[17:48:39.552]                             muffled <- TRUE
[17:48:39.552]                             break
[17:48:39.552]                           }
[17:48:39.552]                         }
[17:48:39.552]                       }
[17:48:39.552]                       invisible(muffled)
[17:48:39.552]                     }
[17:48:39.552]                     muffleCondition(cond, pattern = "^muffle")
[17:48:39.552]                   }
[17:48:39.552]                 }
[17:48:39.552]             }
[17:48:39.552]         }))
[17:48:39.552]     }, error = function(ex) {
[17:48:39.552]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:39.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:39.552]                 ...future.rng), started = ...future.startTime, 
[17:48:39.552]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:39.552]             version = "1.8"), class = "FutureResult")
[17:48:39.552]     }, finally = {
[17:48:39.552]         if (!identical(...future.workdir, getwd())) 
[17:48:39.552]             setwd(...future.workdir)
[17:48:39.552]         {
[17:48:39.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:39.552]                 ...future.oldOptions$nwarnings <- NULL
[17:48:39.552]             }
[17:48:39.552]             base::options(...future.oldOptions)
[17:48:39.552]             if (.Platform$OS.type == "windows") {
[17:48:39.552]                 old_names <- names(...future.oldEnvVars)
[17:48:39.552]                 envs <- base::Sys.getenv()
[17:48:39.552]                 names <- names(envs)
[17:48:39.552]                 common <- intersect(names, old_names)
[17:48:39.552]                 added <- setdiff(names, old_names)
[17:48:39.552]                 removed <- setdiff(old_names, names)
[17:48:39.552]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:39.552]                   envs[common]]
[17:48:39.552]                 NAMES <- toupper(changed)
[17:48:39.552]                 args <- list()
[17:48:39.552]                 for (kk in seq_along(NAMES)) {
[17:48:39.552]                   name <- changed[[kk]]
[17:48:39.552]                   NAME <- NAMES[[kk]]
[17:48:39.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.552]                     next
[17:48:39.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.552]                 }
[17:48:39.552]                 NAMES <- toupper(added)
[17:48:39.552]                 for (kk in seq_along(NAMES)) {
[17:48:39.552]                   name <- added[[kk]]
[17:48:39.552]                   NAME <- NAMES[[kk]]
[17:48:39.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.552]                     next
[17:48:39.552]                   args[[name]] <- ""
[17:48:39.552]                 }
[17:48:39.552]                 NAMES <- toupper(removed)
[17:48:39.552]                 for (kk in seq_along(NAMES)) {
[17:48:39.552]                   name <- removed[[kk]]
[17:48:39.552]                   NAME <- NAMES[[kk]]
[17:48:39.552]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:39.552]                     next
[17:48:39.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:39.552]                 }
[17:48:39.552]                 if (length(args) > 0) 
[17:48:39.552]                   base::do.call(base::Sys.setenv, args = args)
[17:48:39.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:39.552]             }
[17:48:39.552]             else {
[17:48:39.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:39.552]             }
[17:48:39.552]             {
[17:48:39.552]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:39.552]                   0L) {
[17:48:39.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:39.552]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:39.552]                   base::options(opts)
[17:48:39.552]                 }
[17:48:39.552]                 {
[17:48:39.552]                   {
[17:48:39.552]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:39.552]                     NULL
[17:48:39.552]                   }
[17:48:39.552]                   options(future.plan = NULL)
[17:48:39.552]                   if (is.na(NA_character_)) 
[17:48:39.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:39.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:39.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:39.552]                     .init = FALSE)
[17:48:39.552]                 }
[17:48:39.552]             }
[17:48:39.552]         }
[17:48:39.552]     })
[17:48:39.552]     if (TRUE) {
[17:48:39.552]         base::sink(type = "output", split = FALSE)
[17:48:39.552]         if (TRUE) {
[17:48:39.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:39.552]         }
[17:48:39.552]         else {
[17:48:39.552]             ...future.result["stdout"] <- base::list(NULL)
[17:48:39.552]         }
[17:48:39.552]         base::close(...future.stdout)
[17:48:39.552]         ...future.stdout <- NULL
[17:48:39.552]     }
[17:48:39.552]     ...future.result$conditions <- ...future.conditions
[17:48:39.552]     ...future.result$finished <- base::Sys.time()
[17:48:39.552]     ...future.result
[17:48:39.552] }
[17:48:39.555] MultisessionFuture started
[17:48:39.555] - Launch lazy future ... done
[17:48:39.555] run() for ‘MultisessionFuture’ ... done
[17:48:39.555] result() for ClusterFuture ...
[17:48:39.556] receiveMessageFromWorker() for ClusterFuture ...
[17:48:39.556] - Validating connection of MultisessionFuture
[17:48:39.557] - received message: FutureResult
[17:48:39.557] - Received FutureResult
[17:48:39.557] - Erased future from FutureRegistry
[17:48:39.557] result() for ClusterFuture ...
[17:48:39.557] - result already collected: FutureResult
[17:48:39.557] result() for ClusterFuture ... done
[17:48:39.558] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:39.558] result() for ClusterFuture ... done
[17:48:39.558] result() for ClusterFuture ...
[17:48:39.558] - result already collected: FutureResult
[17:48:39.558] result() for ClusterFuture ... done
[17:48:39.558] result() for ClusterFuture ...
[17:48:39.558] - result already collected: FutureResult
[17:48:39.558] result() for ClusterFuture ... done
[1] 42
[17:48:39.558] result() for ClusterFuture ...
[17:48:39.558] - result already collected: FutureResult
[17:48:39.558] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[17:48:39.559] plan(): Setting new future strategy stack:
[17:48:39.559] List of future strategies:
[17:48:39.559] 1. FutureStrategy:
[17:48:39.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:39.559]    - tweaked: FALSE
[17:48:39.559]    - call: future::plan(oplan)
[17:48:39.560] plan(): nbrOfWorkers() = 1
> 
