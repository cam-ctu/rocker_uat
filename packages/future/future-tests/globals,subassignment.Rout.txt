
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:02:46.514] plan(): Setting new future strategy stack:
[17:02:46.515] List of future strategies:
[17:02:46.515] 1. sequential:
[17:02:46.515]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.515]    - tweaked: FALSE
[17:02:46.515]    - call: future::plan("sequential")
[17:02:46.526] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[17:02:46.595] plan(): Setting new future strategy stack:
[17:02:46.595] List of future strategies:
[17:02:46.595] 1. sequential:
[17:02:46.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.595]    - tweaked: FALSE
[17:02:46.595]    - call: plan(strategy)
[17:02:46.607] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.608] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.608] Searching for globals...
[17:02:46.616] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.616] Searching for globals ... DONE
[17:02:46.616] Resolving globals: TRUE
[17:02:46.616] Resolving any globals that are futures ...
[17:02:46.616] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.617] Resolving any globals that are futures ... DONE
[17:02:46.617] Resolving futures part of globals (recursively) ...
[17:02:46.618] resolve() on list ...
[17:02:46.618]  recursive: 99
[17:02:46.618]  length: 1
[17:02:46.618]  elements: ‘x’
[17:02:46.618]  length: 0 (resolved future 1)
[17:02:46.618] resolve() on list ... DONE
[17:02:46.619] - globals: [1] ‘x’
[17:02:46.619] Resolving futures part of globals (recursively) ... DONE
[17:02:46.619] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.620] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.620] - globals: [1] ‘x’
[17:02:46.620] 
[17:02:46.620] getGlobalsAndPackages() ... DONE
[17:02:46.621] run() for ‘Future’ ...
[17:02:46.621] - state: ‘created’
[17:02:46.621] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.621] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.621] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.621]   - Field: ‘label’
[17:02:46.621]   - Field: ‘local’
[17:02:46.622]   - Field: ‘owner’
[17:02:46.622]   - Field: ‘envir’
[17:02:46.622]   - Field: ‘packages’
[17:02:46.622]   - Field: ‘gc’
[17:02:46.622]   - Field: ‘conditions’
[17:02:46.622]   - Field: ‘expr’
[17:02:46.622]   - Field: ‘uuid’
[17:02:46.622]   - Field: ‘seed’
[17:02:46.622]   - Field: ‘version’
[17:02:46.622]   - Field: ‘result’
[17:02:46.622]   - Field: ‘asynchronous’
[17:02:46.623]   - Field: ‘calls’
[17:02:46.623]   - Field: ‘globals’
[17:02:46.623]   - Field: ‘stdout’
[17:02:46.623]   - Field: ‘earlySignal’
[17:02:46.623]   - Field: ‘lazy’
[17:02:46.623]   - Field: ‘state’
[17:02:46.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.623] - Launch lazy future ...
[17:02:46.624] Packages needed by the future expression (n = 0): <none>
[17:02:46.624] Packages needed by future strategies (n = 0): <none>
[17:02:46.625] {
[17:02:46.625]     {
[17:02:46.625]         {
[17:02:46.625]             ...future.startTime <- base::Sys.time()
[17:02:46.625]             {
[17:02:46.625]                 {
[17:02:46.625]                   {
[17:02:46.625]                     base::local({
[17:02:46.625]                       has_future <- base::requireNamespace("future", 
[17:02:46.625]                         quietly = TRUE)
[17:02:46.625]                       if (has_future) {
[17:02:46.625]                         ns <- base::getNamespace("future")
[17:02:46.625]                         version <- ns[[".package"]][["version"]]
[17:02:46.625]                         if (is.null(version)) 
[17:02:46.625]                           version <- utils::packageVersion("future")
[17:02:46.625]                       }
[17:02:46.625]                       else {
[17:02:46.625]                         version <- NULL
[17:02:46.625]                       }
[17:02:46.625]                       if (!has_future || version < "1.8.0") {
[17:02:46.625]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.625]                           "", base::R.version$version.string), 
[17:02:46.625]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.625]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.625]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.625]                             "release", "version")], collapse = " "), 
[17:02:46.625]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.625]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.625]                           info)
[17:02:46.625]                         info <- base::paste(info, collapse = "; ")
[17:02:46.625]                         if (!has_future) {
[17:02:46.625]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.625]                             info)
[17:02:46.625]                         }
[17:02:46.625]                         else {
[17:02:46.625]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.625]                             info, version)
[17:02:46.625]                         }
[17:02:46.625]                         base::stop(msg)
[17:02:46.625]                       }
[17:02:46.625]                     })
[17:02:46.625]                   }
[17:02:46.625]                   ...future.strategy.old <- future::plan("list")
[17:02:46.625]                   options(future.plan = NULL)
[17:02:46.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.625]                 }
[17:02:46.625]                 ...future.workdir <- getwd()
[17:02:46.625]             }
[17:02:46.625]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.625]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.625]         }
[17:02:46.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.625]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.625]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.625]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.625]             base::names(...future.oldOptions))
[17:02:46.625]     }
[17:02:46.625]     if (FALSE) {
[17:02:46.625]     }
[17:02:46.625]     else {
[17:02:46.625]         if (TRUE) {
[17:02:46.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.625]                 open = "w")
[17:02:46.625]         }
[17:02:46.625]         else {
[17:02:46.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.625]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.625]         }
[17:02:46.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.625]             base::sink(type = "output", split = FALSE)
[17:02:46.625]             base::close(...future.stdout)
[17:02:46.625]         }, add = TRUE)
[17:02:46.625]     }
[17:02:46.625]     ...future.frame <- base::sys.nframe()
[17:02:46.625]     ...future.conditions <- base::list()
[17:02:46.625]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.625]     if (FALSE) {
[17:02:46.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.625]     }
[17:02:46.625]     ...future.result <- base::tryCatch({
[17:02:46.625]         base::withCallingHandlers({
[17:02:46.625]             ...future.value <- base::withVisible(base::local({
[17:02:46.625]                 x$a <- 1
[17:02:46.625]                 x
[17:02:46.625]             }))
[17:02:46.625]             future::FutureResult(value = ...future.value$value, 
[17:02:46.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.625]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.625]                     ...future.globalenv.names))
[17:02:46.625]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.625]         }, condition = base::local({
[17:02:46.625]             c <- base::c
[17:02:46.625]             inherits <- base::inherits
[17:02:46.625]             invokeRestart <- base::invokeRestart
[17:02:46.625]             length <- base::length
[17:02:46.625]             list <- base::list
[17:02:46.625]             seq.int <- base::seq.int
[17:02:46.625]             signalCondition <- base::signalCondition
[17:02:46.625]             sys.calls <- base::sys.calls
[17:02:46.625]             `[[` <- base::`[[`
[17:02:46.625]             `+` <- base::`+`
[17:02:46.625]             `<<-` <- base::`<<-`
[17:02:46.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.625]                   3L)]
[17:02:46.625]             }
[17:02:46.625]             function(cond) {
[17:02:46.625]                 is_error <- inherits(cond, "error")
[17:02:46.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.625]                   NULL)
[17:02:46.625]                 if (is_error) {
[17:02:46.625]                   sessionInformation <- function() {
[17:02:46.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.625]                       search = base::search(), system = base::Sys.info())
[17:02:46.625]                   }
[17:02:46.625]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.625]                     cond$call), session = sessionInformation(), 
[17:02:46.625]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.625]                   signalCondition(cond)
[17:02:46.625]                 }
[17:02:46.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.625]                 "immediateCondition"))) {
[17:02:46.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.625]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.625]                   if (TRUE && !signal) {
[17:02:46.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.625]                     {
[17:02:46.625]                       inherits <- base::inherits
[17:02:46.625]                       invokeRestart <- base::invokeRestart
[17:02:46.625]                       is.null <- base::is.null
[17:02:46.625]                       muffled <- FALSE
[17:02:46.625]                       if (inherits(cond, "message")) {
[17:02:46.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.625]                         if (muffled) 
[17:02:46.625]                           invokeRestart("muffleMessage")
[17:02:46.625]                       }
[17:02:46.625]                       else if (inherits(cond, "warning")) {
[17:02:46.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.625]                         if (muffled) 
[17:02:46.625]                           invokeRestart("muffleWarning")
[17:02:46.625]                       }
[17:02:46.625]                       else if (inherits(cond, "condition")) {
[17:02:46.625]                         if (!is.null(pattern)) {
[17:02:46.625]                           computeRestarts <- base::computeRestarts
[17:02:46.625]                           grepl <- base::grepl
[17:02:46.625]                           restarts <- computeRestarts(cond)
[17:02:46.625]                           for (restart in restarts) {
[17:02:46.625]                             name <- restart$name
[17:02:46.625]                             if (is.null(name)) 
[17:02:46.625]                               next
[17:02:46.625]                             if (!grepl(pattern, name)) 
[17:02:46.625]                               next
[17:02:46.625]                             invokeRestart(restart)
[17:02:46.625]                             muffled <- TRUE
[17:02:46.625]                             break
[17:02:46.625]                           }
[17:02:46.625]                         }
[17:02:46.625]                       }
[17:02:46.625]                       invisible(muffled)
[17:02:46.625]                     }
[17:02:46.625]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.625]                   }
[17:02:46.625]                 }
[17:02:46.625]                 else {
[17:02:46.625]                   if (TRUE) {
[17:02:46.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.625]                     {
[17:02:46.625]                       inherits <- base::inherits
[17:02:46.625]                       invokeRestart <- base::invokeRestart
[17:02:46.625]                       is.null <- base::is.null
[17:02:46.625]                       muffled <- FALSE
[17:02:46.625]                       if (inherits(cond, "message")) {
[17:02:46.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.625]                         if (muffled) 
[17:02:46.625]                           invokeRestart("muffleMessage")
[17:02:46.625]                       }
[17:02:46.625]                       else if (inherits(cond, "warning")) {
[17:02:46.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.625]                         if (muffled) 
[17:02:46.625]                           invokeRestart("muffleWarning")
[17:02:46.625]                       }
[17:02:46.625]                       else if (inherits(cond, "condition")) {
[17:02:46.625]                         if (!is.null(pattern)) {
[17:02:46.625]                           computeRestarts <- base::computeRestarts
[17:02:46.625]                           grepl <- base::grepl
[17:02:46.625]                           restarts <- computeRestarts(cond)
[17:02:46.625]                           for (restart in restarts) {
[17:02:46.625]                             name <- restart$name
[17:02:46.625]                             if (is.null(name)) 
[17:02:46.625]                               next
[17:02:46.625]                             if (!grepl(pattern, name)) 
[17:02:46.625]                               next
[17:02:46.625]                             invokeRestart(restart)
[17:02:46.625]                             muffled <- TRUE
[17:02:46.625]                             break
[17:02:46.625]                           }
[17:02:46.625]                         }
[17:02:46.625]                       }
[17:02:46.625]                       invisible(muffled)
[17:02:46.625]                     }
[17:02:46.625]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.625]                   }
[17:02:46.625]                 }
[17:02:46.625]             }
[17:02:46.625]         }))
[17:02:46.625]     }, error = function(ex) {
[17:02:46.625]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.625]                 ...future.rng), started = ...future.startTime, 
[17:02:46.625]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.625]             version = "1.8"), class = "FutureResult")
[17:02:46.625]     }, finally = {
[17:02:46.625]         if (!identical(...future.workdir, getwd())) 
[17:02:46.625]             setwd(...future.workdir)
[17:02:46.625]         {
[17:02:46.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.625]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.625]             }
[17:02:46.625]             base::options(...future.oldOptions)
[17:02:46.625]             if (.Platform$OS.type == "windows") {
[17:02:46.625]                 old_names <- names(...future.oldEnvVars)
[17:02:46.625]                 envs <- base::Sys.getenv()
[17:02:46.625]                 names <- names(envs)
[17:02:46.625]                 common <- intersect(names, old_names)
[17:02:46.625]                 added <- setdiff(names, old_names)
[17:02:46.625]                 removed <- setdiff(old_names, names)
[17:02:46.625]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.625]                   envs[common]]
[17:02:46.625]                 NAMES <- toupper(changed)
[17:02:46.625]                 args <- list()
[17:02:46.625]                 for (kk in seq_along(NAMES)) {
[17:02:46.625]                   name <- changed[[kk]]
[17:02:46.625]                   NAME <- NAMES[[kk]]
[17:02:46.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.625]                     next
[17:02:46.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.625]                 }
[17:02:46.625]                 NAMES <- toupper(added)
[17:02:46.625]                 for (kk in seq_along(NAMES)) {
[17:02:46.625]                   name <- added[[kk]]
[17:02:46.625]                   NAME <- NAMES[[kk]]
[17:02:46.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.625]                     next
[17:02:46.625]                   args[[name]] <- ""
[17:02:46.625]                 }
[17:02:46.625]                 NAMES <- toupper(removed)
[17:02:46.625]                 for (kk in seq_along(NAMES)) {
[17:02:46.625]                   name <- removed[[kk]]
[17:02:46.625]                   NAME <- NAMES[[kk]]
[17:02:46.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.625]                     next
[17:02:46.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.625]                 }
[17:02:46.625]                 if (length(args) > 0) 
[17:02:46.625]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.625]             }
[17:02:46.625]             else {
[17:02:46.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.625]             }
[17:02:46.625]             {
[17:02:46.625]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.625]                   0L) {
[17:02:46.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.625]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.625]                   base::options(opts)
[17:02:46.625]                 }
[17:02:46.625]                 {
[17:02:46.625]                   {
[17:02:46.625]                     NULL
[17:02:46.625]                     RNGkind("Mersenne-Twister")
[17:02:46.625]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.625]                       inherits = FALSE)
[17:02:46.625]                   }
[17:02:46.625]                   options(future.plan = NULL)
[17:02:46.625]                   if (is.na(NA_character_)) 
[17:02:46.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.625]                     .init = FALSE)
[17:02:46.625]                 }
[17:02:46.625]             }
[17:02:46.625]         }
[17:02:46.625]     })
[17:02:46.625]     if (TRUE) {
[17:02:46.625]         base::sink(type = "output", split = FALSE)
[17:02:46.625]         if (TRUE) {
[17:02:46.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.625]         }
[17:02:46.625]         else {
[17:02:46.625]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.625]         }
[17:02:46.625]         base::close(...future.stdout)
[17:02:46.625]         ...future.stdout <- NULL
[17:02:46.625]     }
[17:02:46.625]     ...future.result$conditions <- ...future.conditions
[17:02:46.625]     ...future.result$finished <- base::Sys.time()
[17:02:46.625]     ...future.result
[17:02:46.625] }
[17:02:46.627] assign_globals() ...
[17:02:46.627] List of 1
[17:02:46.627]  $ x: list()
[17:02:46.627]  - attr(*, "where")=List of 1
[17:02:46.627]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.627]  - attr(*, "resolved")= logi TRUE
[17:02:46.627]  - attr(*, "total_size")= num 0
[17:02:46.627]  - attr(*, "already-done")= logi TRUE
[17:02:46.629] - copied ‘x’ to environment
[17:02:46.629] assign_globals() ... done
[17:02:46.630] plan(): Setting new future strategy stack:
[17:02:46.630] List of future strategies:
[17:02:46.630] 1. sequential:
[17:02:46.630]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.630]    - tweaked: FALSE
[17:02:46.630]    - call: NULL
[17:02:46.630] plan(): nbrOfWorkers() = 1
[17:02:46.631] plan(): Setting new future strategy stack:
[17:02:46.631] List of future strategies:
[17:02:46.631] 1. sequential:
[17:02:46.631]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.631]    - tweaked: FALSE
[17:02:46.631]    - call: plan(strategy)
[17:02:46.634] plan(): nbrOfWorkers() = 1
[17:02:46.635] SequentialFuture started (and completed)
[17:02:46.635] - Launch lazy future ... done
[17:02:46.635] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.636] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.636] Searching for globals...
[17:02:46.638] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.638] Searching for globals ... DONE
[17:02:46.638] Resolving globals: TRUE
[17:02:46.638] Resolving any globals that are futures ...
[17:02:46.638] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.638] Resolving any globals that are futures ... DONE
[17:02:46.639] Resolving futures part of globals (recursively) ...
[17:02:46.639] resolve() on list ...
[17:02:46.639]  recursive: 99
[17:02:46.639]  length: 1
[17:02:46.639]  elements: ‘x’
[17:02:46.639]  length: 0 (resolved future 1)
[17:02:46.639] resolve() on list ... DONE
[17:02:46.640] - globals: [1] ‘x’
[17:02:46.640] Resolving futures part of globals (recursively) ... DONE
[17:02:46.640] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.640] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.640] - globals: [1] ‘x’
[17:02:46.640] 
[17:02:46.640] getGlobalsAndPackages() ... DONE
[17:02:46.641] run() for ‘Future’ ...
[17:02:46.641] - state: ‘created’
[17:02:46.641] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.641]   - Field: ‘label’
[17:02:46.641]   - Field: ‘local’
[17:02:46.642]   - Field: ‘owner’
[17:02:46.642]   - Field: ‘envir’
[17:02:46.642]   - Field: ‘packages’
[17:02:46.642]   - Field: ‘gc’
[17:02:46.642]   - Field: ‘conditions’
[17:02:46.642]   - Field: ‘expr’
[17:02:46.642]   - Field: ‘uuid’
[17:02:46.642]   - Field: ‘seed’
[17:02:46.642]   - Field: ‘version’
[17:02:46.642]   - Field: ‘result’
[17:02:46.642]   - Field: ‘asynchronous’
[17:02:46.643]   - Field: ‘calls’
[17:02:46.643]   - Field: ‘globals’
[17:02:46.643]   - Field: ‘stdout’
[17:02:46.643]   - Field: ‘earlySignal’
[17:02:46.643]   - Field: ‘lazy’
[17:02:46.643]   - Field: ‘state’
[17:02:46.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.643] - Launch lazy future ...
[17:02:46.643] Packages needed by the future expression (n = 0): <none>
[17:02:46.644] Packages needed by future strategies (n = 0): <none>
[17:02:46.644] {
[17:02:46.644]     {
[17:02:46.644]         {
[17:02:46.644]             ...future.startTime <- base::Sys.time()
[17:02:46.644]             {
[17:02:46.644]                 {
[17:02:46.644]                   {
[17:02:46.644]                     base::local({
[17:02:46.644]                       has_future <- base::requireNamespace("future", 
[17:02:46.644]                         quietly = TRUE)
[17:02:46.644]                       if (has_future) {
[17:02:46.644]                         ns <- base::getNamespace("future")
[17:02:46.644]                         version <- ns[[".package"]][["version"]]
[17:02:46.644]                         if (is.null(version)) 
[17:02:46.644]                           version <- utils::packageVersion("future")
[17:02:46.644]                       }
[17:02:46.644]                       else {
[17:02:46.644]                         version <- NULL
[17:02:46.644]                       }
[17:02:46.644]                       if (!has_future || version < "1.8.0") {
[17:02:46.644]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.644]                           "", base::R.version$version.string), 
[17:02:46.644]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.644]                             "release", "version")], collapse = " "), 
[17:02:46.644]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.644]                           info)
[17:02:46.644]                         info <- base::paste(info, collapse = "; ")
[17:02:46.644]                         if (!has_future) {
[17:02:46.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.644]                             info)
[17:02:46.644]                         }
[17:02:46.644]                         else {
[17:02:46.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.644]                             info, version)
[17:02:46.644]                         }
[17:02:46.644]                         base::stop(msg)
[17:02:46.644]                       }
[17:02:46.644]                     })
[17:02:46.644]                   }
[17:02:46.644]                   ...future.strategy.old <- future::plan("list")
[17:02:46.644]                   options(future.plan = NULL)
[17:02:46.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.644]                 }
[17:02:46.644]                 ...future.workdir <- getwd()
[17:02:46.644]             }
[17:02:46.644]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.644]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.644]         }
[17:02:46.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.644]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.644]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.644]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.644]             base::names(...future.oldOptions))
[17:02:46.644]     }
[17:02:46.644]     if (FALSE) {
[17:02:46.644]     }
[17:02:46.644]     else {
[17:02:46.644]         if (TRUE) {
[17:02:46.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.644]                 open = "w")
[17:02:46.644]         }
[17:02:46.644]         else {
[17:02:46.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.644]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.644]         }
[17:02:46.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.644]             base::sink(type = "output", split = FALSE)
[17:02:46.644]             base::close(...future.stdout)
[17:02:46.644]         }, add = TRUE)
[17:02:46.644]     }
[17:02:46.644]     ...future.frame <- base::sys.nframe()
[17:02:46.644]     ...future.conditions <- base::list()
[17:02:46.644]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.644]     if (FALSE) {
[17:02:46.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.644]     }
[17:02:46.644]     ...future.result <- base::tryCatch({
[17:02:46.644]         base::withCallingHandlers({
[17:02:46.644]             ...future.value <- base::withVisible(base::local({
[17:02:46.644]                 x$a <- 1
[17:02:46.644]                 x
[17:02:46.644]             }))
[17:02:46.644]             future::FutureResult(value = ...future.value$value, 
[17:02:46.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.644]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.644]                     ...future.globalenv.names))
[17:02:46.644]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.644]         }, condition = base::local({
[17:02:46.644]             c <- base::c
[17:02:46.644]             inherits <- base::inherits
[17:02:46.644]             invokeRestart <- base::invokeRestart
[17:02:46.644]             length <- base::length
[17:02:46.644]             list <- base::list
[17:02:46.644]             seq.int <- base::seq.int
[17:02:46.644]             signalCondition <- base::signalCondition
[17:02:46.644]             sys.calls <- base::sys.calls
[17:02:46.644]             `[[` <- base::`[[`
[17:02:46.644]             `+` <- base::`+`
[17:02:46.644]             `<<-` <- base::`<<-`
[17:02:46.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.644]                   3L)]
[17:02:46.644]             }
[17:02:46.644]             function(cond) {
[17:02:46.644]                 is_error <- inherits(cond, "error")
[17:02:46.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.644]                   NULL)
[17:02:46.644]                 if (is_error) {
[17:02:46.644]                   sessionInformation <- function() {
[17:02:46.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.644]                       search = base::search(), system = base::Sys.info())
[17:02:46.644]                   }
[17:02:46.644]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.644]                     cond$call), session = sessionInformation(), 
[17:02:46.644]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.644]                   signalCondition(cond)
[17:02:46.644]                 }
[17:02:46.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.644]                 "immediateCondition"))) {
[17:02:46.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.644]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.644]                   if (TRUE && !signal) {
[17:02:46.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.644]                     {
[17:02:46.644]                       inherits <- base::inherits
[17:02:46.644]                       invokeRestart <- base::invokeRestart
[17:02:46.644]                       is.null <- base::is.null
[17:02:46.644]                       muffled <- FALSE
[17:02:46.644]                       if (inherits(cond, "message")) {
[17:02:46.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.644]                         if (muffled) 
[17:02:46.644]                           invokeRestart("muffleMessage")
[17:02:46.644]                       }
[17:02:46.644]                       else if (inherits(cond, "warning")) {
[17:02:46.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.644]                         if (muffled) 
[17:02:46.644]                           invokeRestart("muffleWarning")
[17:02:46.644]                       }
[17:02:46.644]                       else if (inherits(cond, "condition")) {
[17:02:46.644]                         if (!is.null(pattern)) {
[17:02:46.644]                           computeRestarts <- base::computeRestarts
[17:02:46.644]                           grepl <- base::grepl
[17:02:46.644]                           restarts <- computeRestarts(cond)
[17:02:46.644]                           for (restart in restarts) {
[17:02:46.644]                             name <- restart$name
[17:02:46.644]                             if (is.null(name)) 
[17:02:46.644]                               next
[17:02:46.644]                             if (!grepl(pattern, name)) 
[17:02:46.644]                               next
[17:02:46.644]                             invokeRestart(restart)
[17:02:46.644]                             muffled <- TRUE
[17:02:46.644]                             break
[17:02:46.644]                           }
[17:02:46.644]                         }
[17:02:46.644]                       }
[17:02:46.644]                       invisible(muffled)
[17:02:46.644]                     }
[17:02:46.644]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.644]                   }
[17:02:46.644]                 }
[17:02:46.644]                 else {
[17:02:46.644]                   if (TRUE) {
[17:02:46.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.644]                     {
[17:02:46.644]                       inherits <- base::inherits
[17:02:46.644]                       invokeRestart <- base::invokeRestart
[17:02:46.644]                       is.null <- base::is.null
[17:02:46.644]                       muffled <- FALSE
[17:02:46.644]                       if (inherits(cond, "message")) {
[17:02:46.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.644]                         if (muffled) 
[17:02:46.644]                           invokeRestart("muffleMessage")
[17:02:46.644]                       }
[17:02:46.644]                       else if (inherits(cond, "warning")) {
[17:02:46.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.644]                         if (muffled) 
[17:02:46.644]                           invokeRestart("muffleWarning")
[17:02:46.644]                       }
[17:02:46.644]                       else if (inherits(cond, "condition")) {
[17:02:46.644]                         if (!is.null(pattern)) {
[17:02:46.644]                           computeRestarts <- base::computeRestarts
[17:02:46.644]                           grepl <- base::grepl
[17:02:46.644]                           restarts <- computeRestarts(cond)
[17:02:46.644]                           for (restart in restarts) {
[17:02:46.644]                             name <- restart$name
[17:02:46.644]                             if (is.null(name)) 
[17:02:46.644]                               next
[17:02:46.644]                             if (!grepl(pattern, name)) 
[17:02:46.644]                               next
[17:02:46.644]                             invokeRestart(restart)
[17:02:46.644]                             muffled <- TRUE
[17:02:46.644]                             break
[17:02:46.644]                           }
[17:02:46.644]                         }
[17:02:46.644]                       }
[17:02:46.644]                       invisible(muffled)
[17:02:46.644]                     }
[17:02:46.644]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.644]                   }
[17:02:46.644]                 }
[17:02:46.644]             }
[17:02:46.644]         }))
[17:02:46.644]     }, error = function(ex) {
[17:02:46.644]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.644]                 ...future.rng), started = ...future.startTime, 
[17:02:46.644]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.644]             version = "1.8"), class = "FutureResult")
[17:02:46.644]     }, finally = {
[17:02:46.644]         if (!identical(...future.workdir, getwd())) 
[17:02:46.644]             setwd(...future.workdir)
[17:02:46.644]         {
[17:02:46.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.644]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.644]             }
[17:02:46.644]             base::options(...future.oldOptions)
[17:02:46.644]             if (.Platform$OS.type == "windows") {
[17:02:46.644]                 old_names <- names(...future.oldEnvVars)
[17:02:46.644]                 envs <- base::Sys.getenv()
[17:02:46.644]                 names <- names(envs)
[17:02:46.644]                 common <- intersect(names, old_names)
[17:02:46.644]                 added <- setdiff(names, old_names)
[17:02:46.644]                 removed <- setdiff(old_names, names)
[17:02:46.644]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.644]                   envs[common]]
[17:02:46.644]                 NAMES <- toupper(changed)
[17:02:46.644]                 args <- list()
[17:02:46.644]                 for (kk in seq_along(NAMES)) {
[17:02:46.644]                   name <- changed[[kk]]
[17:02:46.644]                   NAME <- NAMES[[kk]]
[17:02:46.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.644]                     next
[17:02:46.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.644]                 }
[17:02:46.644]                 NAMES <- toupper(added)
[17:02:46.644]                 for (kk in seq_along(NAMES)) {
[17:02:46.644]                   name <- added[[kk]]
[17:02:46.644]                   NAME <- NAMES[[kk]]
[17:02:46.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.644]                     next
[17:02:46.644]                   args[[name]] <- ""
[17:02:46.644]                 }
[17:02:46.644]                 NAMES <- toupper(removed)
[17:02:46.644]                 for (kk in seq_along(NAMES)) {
[17:02:46.644]                   name <- removed[[kk]]
[17:02:46.644]                   NAME <- NAMES[[kk]]
[17:02:46.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.644]                     next
[17:02:46.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.644]                 }
[17:02:46.644]                 if (length(args) > 0) 
[17:02:46.644]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.644]             }
[17:02:46.644]             else {
[17:02:46.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.644]             }
[17:02:46.644]             {
[17:02:46.644]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.644]                   0L) {
[17:02:46.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.644]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.644]                   base::options(opts)
[17:02:46.644]                 }
[17:02:46.644]                 {
[17:02:46.644]                   {
[17:02:46.644]                     NULL
[17:02:46.644]                     RNGkind("Mersenne-Twister")
[17:02:46.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.644]                       inherits = FALSE)
[17:02:46.644]                   }
[17:02:46.644]                   options(future.plan = NULL)
[17:02:46.644]                   if (is.na(NA_character_)) 
[17:02:46.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.644]                     .init = FALSE)
[17:02:46.644]                 }
[17:02:46.644]             }
[17:02:46.644]         }
[17:02:46.644]     })
[17:02:46.644]     if (TRUE) {
[17:02:46.644]         base::sink(type = "output", split = FALSE)
[17:02:46.644]         if (TRUE) {
[17:02:46.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.644]         }
[17:02:46.644]         else {
[17:02:46.644]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.644]         }
[17:02:46.644]         base::close(...future.stdout)
[17:02:46.644]         ...future.stdout <- NULL
[17:02:46.644]     }
[17:02:46.644]     ...future.result$conditions <- ...future.conditions
[17:02:46.644]     ...future.result$finished <- base::Sys.time()
[17:02:46.644]     ...future.result
[17:02:46.644] }
[17:02:46.645] assign_globals() ...
[17:02:46.646] List of 1
[17:02:46.646]  $ x: list()
[17:02:46.646]  - attr(*, "where")=List of 1
[17:02:46.646]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.646]  - attr(*, "resolved")= logi TRUE
[17:02:46.646]  - attr(*, "total_size")= num 0
[17:02:46.646]  - attr(*, "already-done")= logi TRUE
[17:02:46.648] - copied ‘x’ to environment
[17:02:46.648] assign_globals() ... done
[17:02:46.648] plan(): Setting new future strategy stack:
[17:02:46.648] List of future strategies:
[17:02:46.648] 1. sequential:
[17:02:46.648]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.648]    - tweaked: FALSE
[17:02:46.648]    - call: NULL
[17:02:46.649] plan(): nbrOfWorkers() = 1
[17:02:46.650] plan(): Setting new future strategy stack:
[17:02:46.650] List of future strategies:
[17:02:46.650] 1. sequential:
[17:02:46.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.650]    - tweaked: FALSE
[17:02:46.650]    - call: plan(strategy)
[17:02:46.650] plan(): nbrOfWorkers() = 1
[17:02:46.650] SequentialFuture started (and completed)
[17:02:46.650] - Launch lazy future ... done
[17:02:46.651] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.652] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.652] Searching for globals...
[17:02:46.654] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.654] Searching for globals ... DONE
[17:02:46.654] Resolving globals: TRUE
[17:02:46.654] Resolving any globals that are futures ...
[17:02:46.654] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.654] Resolving any globals that are futures ... DONE
[17:02:46.655] Resolving futures part of globals (recursively) ...
[17:02:46.655] resolve() on list ...
[17:02:46.655]  recursive: 99
[17:02:46.655]  length: 1
[17:02:46.655]  elements: ‘x’
[17:02:46.655]  length: 0 (resolved future 1)
[17:02:46.655] resolve() on list ... DONE
[17:02:46.655] - globals: [1] ‘x’
[17:02:46.656] Resolving futures part of globals (recursively) ... DONE
[17:02:46.656] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.656] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.656] - globals: [1] ‘x’
[17:02:46.656] 
[17:02:46.656] getGlobalsAndPackages() ... DONE
[17:02:46.657] run() for ‘Future’ ...
[17:02:46.657] - state: ‘created’
[17:02:46.657] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.657] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.657] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.657]   - Field: ‘label’
[17:02:46.657]   - Field: ‘local’
[17:02:46.657]   - Field: ‘owner’
[17:02:46.658]   - Field: ‘envir’
[17:02:46.658]   - Field: ‘packages’
[17:02:46.658]   - Field: ‘gc’
[17:02:46.658]   - Field: ‘conditions’
[17:02:46.658]   - Field: ‘expr’
[17:02:46.658]   - Field: ‘uuid’
[17:02:46.658]   - Field: ‘seed’
[17:02:46.658]   - Field: ‘version’
[17:02:46.658]   - Field: ‘result’
[17:02:46.658]   - Field: ‘asynchronous’
[17:02:46.658]   - Field: ‘calls’
[17:02:46.658]   - Field: ‘globals’
[17:02:46.659]   - Field: ‘stdout’
[17:02:46.659]   - Field: ‘earlySignal’
[17:02:46.659]   - Field: ‘lazy’
[17:02:46.659]   - Field: ‘state’
[17:02:46.659] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.659] - Launch lazy future ...
[17:02:46.659] Packages needed by the future expression (n = 0): <none>
[17:02:46.659] Packages needed by future strategies (n = 0): <none>
[17:02:46.660] {
[17:02:46.660]     {
[17:02:46.660]         {
[17:02:46.660]             ...future.startTime <- base::Sys.time()
[17:02:46.660]             {
[17:02:46.660]                 {
[17:02:46.660]                   {
[17:02:46.660]                     base::local({
[17:02:46.660]                       has_future <- base::requireNamespace("future", 
[17:02:46.660]                         quietly = TRUE)
[17:02:46.660]                       if (has_future) {
[17:02:46.660]                         ns <- base::getNamespace("future")
[17:02:46.660]                         version <- ns[[".package"]][["version"]]
[17:02:46.660]                         if (is.null(version)) 
[17:02:46.660]                           version <- utils::packageVersion("future")
[17:02:46.660]                       }
[17:02:46.660]                       else {
[17:02:46.660]                         version <- NULL
[17:02:46.660]                       }
[17:02:46.660]                       if (!has_future || version < "1.8.0") {
[17:02:46.660]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.660]                           "", base::R.version$version.string), 
[17:02:46.660]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.660]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.660]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.660]                             "release", "version")], collapse = " "), 
[17:02:46.660]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.660]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.660]                           info)
[17:02:46.660]                         info <- base::paste(info, collapse = "; ")
[17:02:46.660]                         if (!has_future) {
[17:02:46.660]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.660]                             info)
[17:02:46.660]                         }
[17:02:46.660]                         else {
[17:02:46.660]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.660]                             info, version)
[17:02:46.660]                         }
[17:02:46.660]                         base::stop(msg)
[17:02:46.660]                       }
[17:02:46.660]                     })
[17:02:46.660]                   }
[17:02:46.660]                   ...future.strategy.old <- future::plan("list")
[17:02:46.660]                   options(future.plan = NULL)
[17:02:46.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.660]                 }
[17:02:46.660]                 ...future.workdir <- getwd()
[17:02:46.660]             }
[17:02:46.660]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.660]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.660]         }
[17:02:46.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.660]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.660]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.660]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.660]             base::names(...future.oldOptions))
[17:02:46.660]     }
[17:02:46.660]     if (FALSE) {
[17:02:46.660]     }
[17:02:46.660]     else {
[17:02:46.660]         if (TRUE) {
[17:02:46.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.660]                 open = "w")
[17:02:46.660]         }
[17:02:46.660]         else {
[17:02:46.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.660]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.660]         }
[17:02:46.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.660]             base::sink(type = "output", split = FALSE)
[17:02:46.660]             base::close(...future.stdout)
[17:02:46.660]         }, add = TRUE)
[17:02:46.660]     }
[17:02:46.660]     ...future.frame <- base::sys.nframe()
[17:02:46.660]     ...future.conditions <- base::list()
[17:02:46.660]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.660]     if (FALSE) {
[17:02:46.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.660]     }
[17:02:46.660]     ...future.result <- base::tryCatch({
[17:02:46.660]         base::withCallingHandlers({
[17:02:46.660]             ...future.value <- base::withVisible(base::local({
[17:02:46.660]                 x$a <- 1
[17:02:46.660]                 x
[17:02:46.660]             }))
[17:02:46.660]             future::FutureResult(value = ...future.value$value, 
[17:02:46.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.660]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.660]                     ...future.globalenv.names))
[17:02:46.660]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.660]         }, condition = base::local({
[17:02:46.660]             c <- base::c
[17:02:46.660]             inherits <- base::inherits
[17:02:46.660]             invokeRestart <- base::invokeRestart
[17:02:46.660]             length <- base::length
[17:02:46.660]             list <- base::list
[17:02:46.660]             seq.int <- base::seq.int
[17:02:46.660]             signalCondition <- base::signalCondition
[17:02:46.660]             sys.calls <- base::sys.calls
[17:02:46.660]             `[[` <- base::`[[`
[17:02:46.660]             `+` <- base::`+`
[17:02:46.660]             `<<-` <- base::`<<-`
[17:02:46.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.660]                   3L)]
[17:02:46.660]             }
[17:02:46.660]             function(cond) {
[17:02:46.660]                 is_error <- inherits(cond, "error")
[17:02:46.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.660]                   NULL)
[17:02:46.660]                 if (is_error) {
[17:02:46.660]                   sessionInformation <- function() {
[17:02:46.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.660]                       search = base::search(), system = base::Sys.info())
[17:02:46.660]                   }
[17:02:46.660]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.660]                     cond$call), session = sessionInformation(), 
[17:02:46.660]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.660]                   signalCondition(cond)
[17:02:46.660]                 }
[17:02:46.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.660]                 "immediateCondition"))) {
[17:02:46.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.660]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.660]                   if (TRUE && !signal) {
[17:02:46.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.660]                     {
[17:02:46.660]                       inherits <- base::inherits
[17:02:46.660]                       invokeRestart <- base::invokeRestart
[17:02:46.660]                       is.null <- base::is.null
[17:02:46.660]                       muffled <- FALSE
[17:02:46.660]                       if (inherits(cond, "message")) {
[17:02:46.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.660]                         if (muffled) 
[17:02:46.660]                           invokeRestart("muffleMessage")
[17:02:46.660]                       }
[17:02:46.660]                       else if (inherits(cond, "warning")) {
[17:02:46.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.660]                         if (muffled) 
[17:02:46.660]                           invokeRestart("muffleWarning")
[17:02:46.660]                       }
[17:02:46.660]                       else if (inherits(cond, "condition")) {
[17:02:46.660]                         if (!is.null(pattern)) {
[17:02:46.660]                           computeRestarts <- base::computeRestarts
[17:02:46.660]                           grepl <- base::grepl
[17:02:46.660]                           restarts <- computeRestarts(cond)
[17:02:46.660]                           for (restart in restarts) {
[17:02:46.660]                             name <- restart$name
[17:02:46.660]                             if (is.null(name)) 
[17:02:46.660]                               next
[17:02:46.660]                             if (!grepl(pattern, name)) 
[17:02:46.660]                               next
[17:02:46.660]                             invokeRestart(restart)
[17:02:46.660]                             muffled <- TRUE
[17:02:46.660]                             break
[17:02:46.660]                           }
[17:02:46.660]                         }
[17:02:46.660]                       }
[17:02:46.660]                       invisible(muffled)
[17:02:46.660]                     }
[17:02:46.660]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.660]                   }
[17:02:46.660]                 }
[17:02:46.660]                 else {
[17:02:46.660]                   if (TRUE) {
[17:02:46.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.660]                     {
[17:02:46.660]                       inherits <- base::inherits
[17:02:46.660]                       invokeRestart <- base::invokeRestart
[17:02:46.660]                       is.null <- base::is.null
[17:02:46.660]                       muffled <- FALSE
[17:02:46.660]                       if (inherits(cond, "message")) {
[17:02:46.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.660]                         if (muffled) 
[17:02:46.660]                           invokeRestart("muffleMessage")
[17:02:46.660]                       }
[17:02:46.660]                       else if (inherits(cond, "warning")) {
[17:02:46.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.660]                         if (muffled) 
[17:02:46.660]                           invokeRestart("muffleWarning")
[17:02:46.660]                       }
[17:02:46.660]                       else if (inherits(cond, "condition")) {
[17:02:46.660]                         if (!is.null(pattern)) {
[17:02:46.660]                           computeRestarts <- base::computeRestarts
[17:02:46.660]                           grepl <- base::grepl
[17:02:46.660]                           restarts <- computeRestarts(cond)
[17:02:46.660]                           for (restart in restarts) {
[17:02:46.660]                             name <- restart$name
[17:02:46.660]                             if (is.null(name)) 
[17:02:46.660]                               next
[17:02:46.660]                             if (!grepl(pattern, name)) 
[17:02:46.660]                               next
[17:02:46.660]                             invokeRestart(restart)
[17:02:46.660]                             muffled <- TRUE
[17:02:46.660]                             break
[17:02:46.660]                           }
[17:02:46.660]                         }
[17:02:46.660]                       }
[17:02:46.660]                       invisible(muffled)
[17:02:46.660]                     }
[17:02:46.660]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.660]                   }
[17:02:46.660]                 }
[17:02:46.660]             }
[17:02:46.660]         }))
[17:02:46.660]     }, error = function(ex) {
[17:02:46.660]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.660]                 ...future.rng), started = ...future.startTime, 
[17:02:46.660]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.660]             version = "1.8"), class = "FutureResult")
[17:02:46.660]     }, finally = {
[17:02:46.660]         if (!identical(...future.workdir, getwd())) 
[17:02:46.660]             setwd(...future.workdir)
[17:02:46.660]         {
[17:02:46.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.660]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.660]             }
[17:02:46.660]             base::options(...future.oldOptions)
[17:02:46.660]             if (.Platform$OS.type == "windows") {
[17:02:46.660]                 old_names <- names(...future.oldEnvVars)
[17:02:46.660]                 envs <- base::Sys.getenv()
[17:02:46.660]                 names <- names(envs)
[17:02:46.660]                 common <- intersect(names, old_names)
[17:02:46.660]                 added <- setdiff(names, old_names)
[17:02:46.660]                 removed <- setdiff(old_names, names)
[17:02:46.660]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.660]                   envs[common]]
[17:02:46.660]                 NAMES <- toupper(changed)
[17:02:46.660]                 args <- list()
[17:02:46.660]                 for (kk in seq_along(NAMES)) {
[17:02:46.660]                   name <- changed[[kk]]
[17:02:46.660]                   NAME <- NAMES[[kk]]
[17:02:46.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.660]                     next
[17:02:46.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.660]                 }
[17:02:46.660]                 NAMES <- toupper(added)
[17:02:46.660]                 for (kk in seq_along(NAMES)) {
[17:02:46.660]                   name <- added[[kk]]
[17:02:46.660]                   NAME <- NAMES[[kk]]
[17:02:46.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.660]                     next
[17:02:46.660]                   args[[name]] <- ""
[17:02:46.660]                 }
[17:02:46.660]                 NAMES <- toupper(removed)
[17:02:46.660]                 for (kk in seq_along(NAMES)) {
[17:02:46.660]                   name <- removed[[kk]]
[17:02:46.660]                   NAME <- NAMES[[kk]]
[17:02:46.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.660]                     next
[17:02:46.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.660]                 }
[17:02:46.660]                 if (length(args) > 0) 
[17:02:46.660]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.660]             }
[17:02:46.660]             else {
[17:02:46.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.660]             }
[17:02:46.660]             {
[17:02:46.660]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.660]                   0L) {
[17:02:46.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.660]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.660]                   base::options(opts)
[17:02:46.660]                 }
[17:02:46.660]                 {
[17:02:46.660]                   {
[17:02:46.660]                     NULL
[17:02:46.660]                     RNGkind("Mersenne-Twister")
[17:02:46.660]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.660]                       inherits = FALSE)
[17:02:46.660]                   }
[17:02:46.660]                   options(future.plan = NULL)
[17:02:46.660]                   if (is.na(NA_character_)) 
[17:02:46.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.660]                     .init = FALSE)
[17:02:46.660]                 }
[17:02:46.660]             }
[17:02:46.660]         }
[17:02:46.660]     })
[17:02:46.660]     if (TRUE) {
[17:02:46.660]         base::sink(type = "output", split = FALSE)
[17:02:46.660]         if (TRUE) {
[17:02:46.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.660]         }
[17:02:46.660]         else {
[17:02:46.660]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.660]         }
[17:02:46.660]         base::close(...future.stdout)
[17:02:46.660]         ...future.stdout <- NULL
[17:02:46.660]     }
[17:02:46.660]     ...future.result$conditions <- ...future.conditions
[17:02:46.660]     ...future.result$finished <- base::Sys.time()
[17:02:46.660]     ...future.result
[17:02:46.660] }
[17:02:46.661] assign_globals() ...
[17:02:46.661] List of 1
[17:02:46.661]  $ x: list()
[17:02:46.661]  - attr(*, "where")=List of 1
[17:02:46.661]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.661]  - attr(*, "resolved")= logi TRUE
[17:02:46.661]  - attr(*, "total_size")= num 0
[17:02:46.661]  - attr(*, "already-done")= logi TRUE
[17:02:46.665] - copied ‘x’ to environment
[17:02:46.666] assign_globals() ... done
[17:02:46.666] plan(): Setting new future strategy stack:
[17:02:46.666] List of future strategies:
[17:02:46.666] 1. sequential:
[17:02:46.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.666]    - tweaked: FALSE
[17:02:46.666]    - call: NULL
[17:02:46.666] plan(): nbrOfWorkers() = 1
[17:02:46.667] plan(): Setting new future strategy stack:
[17:02:46.667] List of future strategies:
[17:02:46.667] 1. sequential:
[17:02:46.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.667]    - tweaked: FALSE
[17:02:46.667]    - call: plan(strategy)
[17:02:46.668] plan(): nbrOfWorkers() = 1
[17:02:46.668] SequentialFuture started (and completed)
[17:02:46.668] - Launch lazy future ... done
[17:02:46.668] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.668] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.669] Searching for globals...
[17:02:46.670] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.671] Searching for globals ... DONE
[17:02:46.671] Resolving globals: TRUE
[17:02:46.671] Resolving any globals that are futures ...
[17:02:46.671] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.671] Resolving any globals that are futures ... DONE
[17:02:46.671] Resolving futures part of globals (recursively) ...
[17:02:46.672] resolve() on list ...
[17:02:46.672]  recursive: 99
[17:02:46.672]  length: 1
[17:02:46.672]  elements: ‘x’
[17:02:46.672]  length: 0 (resolved future 1)
[17:02:46.672] resolve() on list ... DONE
[17:02:46.672] - globals: [1] ‘x’
[17:02:46.672] Resolving futures part of globals (recursively) ... DONE
[17:02:46.672] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.673] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.673] - globals: [1] ‘x’
[17:02:46.673] 
[17:02:46.673] getGlobalsAndPackages() ... DONE
[17:02:46.673] run() for ‘Future’ ...
[17:02:46.673] - state: ‘created’
[17:02:46.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.674] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.674]   - Field: ‘label’
[17:02:46.674]   - Field: ‘local’
[17:02:46.674]   - Field: ‘owner’
[17:02:46.674]   - Field: ‘envir’
[17:02:46.674]   - Field: ‘packages’
[17:02:46.674]   - Field: ‘gc’
[17:02:46.674]   - Field: ‘conditions’
[17:02:46.675]   - Field: ‘expr’
[17:02:46.675]   - Field: ‘uuid’
[17:02:46.675]   - Field: ‘seed’
[17:02:46.675]   - Field: ‘version’
[17:02:46.675]   - Field: ‘result’
[17:02:46.675]   - Field: ‘asynchronous’
[17:02:46.675]   - Field: ‘calls’
[17:02:46.675]   - Field: ‘globals’
[17:02:46.675]   - Field: ‘stdout’
[17:02:46.675]   - Field: ‘earlySignal’
[17:02:46.676]   - Field: ‘lazy’
[17:02:46.676]   - Field: ‘state’
[17:02:46.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.676] - Launch lazy future ...
[17:02:46.676] Packages needed by the future expression (n = 0): <none>
[17:02:46.676] Packages needed by future strategies (n = 0): <none>
[17:02:46.676] {
[17:02:46.676]     {
[17:02:46.676]         {
[17:02:46.676]             ...future.startTime <- base::Sys.time()
[17:02:46.676]             {
[17:02:46.676]                 {
[17:02:46.676]                   {
[17:02:46.676]                     base::local({
[17:02:46.676]                       has_future <- base::requireNamespace("future", 
[17:02:46.676]                         quietly = TRUE)
[17:02:46.676]                       if (has_future) {
[17:02:46.676]                         ns <- base::getNamespace("future")
[17:02:46.676]                         version <- ns[[".package"]][["version"]]
[17:02:46.676]                         if (is.null(version)) 
[17:02:46.676]                           version <- utils::packageVersion("future")
[17:02:46.676]                       }
[17:02:46.676]                       else {
[17:02:46.676]                         version <- NULL
[17:02:46.676]                       }
[17:02:46.676]                       if (!has_future || version < "1.8.0") {
[17:02:46.676]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.676]                           "", base::R.version$version.string), 
[17:02:46.676]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.676]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.676]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.676]                             "release", "version")], collapse = " "), 
[17:02:46.676]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.676]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.676]                           info)
[17:02:46.676]                         info <- base::paste(info, collapse = "; ")
[17:02:46.676]                         if (!has_future) {
[17:02:46.676]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.676]                             info)
[17:02:46.676]                         }
[17:02:46.676]                         else {
[17:02:46.676]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.676]                             info, version)
[17:02:46.676]                         }
[17:02:46.676]                         base::stop(msg)
[17:02:46.676]                       }
[17:02:46.676]                     })
[17:02:46.676]                   }
[17:02:46.676]                   ...future.strategy.old <- future::plan("list")
[17:02:46.676]                   options(future.plan = NULL)
[17:02:46.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.676]                 }
[17:02:46.676]                 ...future.workdir <- getwd()
[17:02:46.676]             }
[17:02:46.676]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.676]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.676]         }
[17:02:46.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.676]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.676]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.676]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.676]             base::names(...future.oldOptions))
[17:02:46.676]     }
[17:02:46.676]     if (FALSE) {
[17:02:46.676]     }
[17:02:46.676]     else {
[17:02:46.676]         if (TRUE) {
[17:02:46.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.676]                 open = "w")
[17:02:46.676]         }
[17:02:46.676]         else {
[17:02:46.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.676]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.676]         }
[17:02:46.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.676]             base::sink(type = "output", split = FALSE)
[17:02:46.676]             base::close(...future.stdout)
[17:02:46.676]         }, add = TRUE)
[17:02:46.676]     }
[17:02:46.676]     ...future.frame <- base::sys.nframe()
[17:02:46.676]     ...future.conditions <- base::list()
[17:02:46.676]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.676]     if (FALSE) {
[17:02:46.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.676]     }
[17:02:46.676]     ...future.result <- base::tryCatch({
[17:02:46.676]         base::withCallingHandlers({
[17:02:46.676]             ...future.value <- base::withVisible(base::local({
[17:02:46.676]                 x$a <- 1
[17:02:46.676]                 x
[17:02:46.676]             }))
[17:02:46.676]             future::FutureResult(value = ...future.value$value, 
[17:02:46.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.676]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.676]                     ...future.globalenv.names))
[17:02:46.676]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.676]         }, condition = base::local({
[17:02:46.676]             c <- base::c
[17:02:46.676]             inherits <- base::inherits
[17:02:46.676]             invokeRestart <- base::invokeRestart
[17:02:46.676]             length <- base::length
[17:02:46.676]             list <- base::list
[17:02:46.676]             seq.int <- base::seq.int
[17:02:46.676]             signalCondition <- base::signalCondition
[17:02:46.676]             sys.calls <- base::sys.calls
[17:02:46.676]             `[[` <- base::`[[`
[17:02:46.676]             `+` <- base::`+`
[17:02:46.676]             `<<-` <- base::`<<-`
[17:02:46.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.676]                   3L)]
[17:02:46.676]             }
[17:02:46.676]             function(cond) {
[17:02:46.676]                 is_error <- inherits(cond, "error")
[17:02:46.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.676]                   NULL)
[17:02:46.676]                 if (is_error) {
[17:02:46.676]                   sessionInformation <- function() {
[17:02:46.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.676]                       search = base::search(), system = base::Sys.info())
[17:02:46.676]                   }
[17:02:46.676]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.676]                     cond$call), session = sessionInformation(), 
[17:02:46.676]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.676]                   signalCondition(cond)
[17:02:46.676]                 }
[17:02:46.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.676]                 "immediateCondition"))) {
[17:02:46.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.676]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.676]                   if (TRUE && !signal) {
[17:02:46.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.676]                     {
[17:02:46.676]                       inherits <- base::inherits
[17:02:46.676]                       invokeRestart <- base::invokeRestart
[17:02:46.676]                       is.null <- base::is.null
[17:02:46.676]                       muffled <- FALSE
[17:02:46.676]                       if (inherits(cond, "message")) {
[17:02:46.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.676]                         if (muffled) 
[17:02:46.676]                           invokeRestart("muffleMessage")
[17:02:46.676]                       }
[17:02:46.676]                       else if (inherits(cond, "warning")) {
[17:02:46.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.676]                         if (muffled) 
[17:02:46.676]                           invokeRestart("muffleWarning")
[17:02:46.676]                       }
[17:02:46.676]                       else if (inherits(cond, "condition")) {
[17:02:46.676]                         if (!is.null(pattern)) {
[17:02:46.676]                           computeRestarts <- base::computeRestarts
[17:02:46.676]                           grepl <- base::grepl
[17:02:46.676]                           restarts <- computeRestarts(cond)
[17:02:46.676]                           for (restart in restarts) {
[17:02:46.676]                             name <- restart$name
[17:02:46.676]                             if (is.null(name)) 
[17:02:46.676]                               next
[17:02:46.676]                             if (!grepl(pattern, name)) 
[17:02:46.676]                               next
[17:02:46.676]                             invokeRestart(restart)
[17:02:46.676]                             muffled <- TRUE
[17:02:46.676]                             break
[17:02:46.676]                           }
[17:02:46.676]                         }
[17:02:46.676]                       }
[17:02:46.676]                       invisible(muffled)
[17:02:46.676]                     }
[17:02:46.676]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.676]                   }
[17:02:46.676]                 }
[17:02:46.676]                 else {
[17:02:46.676]                   if (TRUE) {
[17:02:46.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.676]                     {
[17:02:46.676]                       inherits <- base::inherits
[17:02:46.676]                       invokeRestart <- base::invokeRestart
[17:02:46.676]                       is.null <- base::is.null
[17:02:46.676]                       muffled <- FALSE
[17:02:46.676]                       if (inherits(cond, "message")) {
[17:02:46.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.676]                         if (muffled) 
[17:02:46.676]                           invokeRestart("muffleMessage")
[17:02:46.676]                       }
[17:02:46.676]                       else if (inherits(cond, "warning")) {
[17:02:46.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.676]                         if (muffled) 
[17:02:46.676]                           invokeRestart("muffleWarning")
[17:02:46.676]                       }
[17:02:46.676]                       else if (inherits(cond, "condition")) {
[17:02:46.676]                         if (!is.null(pattern)) {
[17:02:46.676]                           computeRestarts <- base::computeRestarts
[17:02:46.676]                           grepl <- base::grepl
[17:02:46.676]                           restarts <- computeRestarts(cond)
[17:02:46.676]                           for (restart in restarts) {
[17:02:46.676]                             name <- restart$name
[17:02:46.676]                             if (is.null(name)) 
[17:02:46.676]                               next
[17:02:46.676]                             if (!grepl(pattern, name)) 
[17:02:46.676]                               next
[17:02:46.676]                             invokeRestart(restart)
[17:02:46.676]                             muffled <- TRUE
[17:02:46.676]                             break
[17:02:46.676]                           }
[17:02:46.676]                         }
[17:02:46.676]                       }
[17:02:46.676]                       invisible(muffled)
[17:02:46.676]                     }
[17:02:46.676]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.676]                   }
[17:02:46.676]                 }
[17:02:46.676]             }
[17:02:46.676]         }))
[17:02:46.676]     }, error = function(ex) {
[17:02:46.676]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.676]                 ...future.rng), started = ...future.startTime, 
[17:02:46.676]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.676]             version = "1.8"), class = "FutureResult")
[17:02:46.676]     }, finally = {
[17:02:46.676]         if (!identical(...future.workdir, getwd())) 
[17:02:46.676]             setwd(...future.workdir)
[17:02:46.676]         {
[17:02:46.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.676]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.676]             }
[17:02:46.676]             base::options(...future.oldOptions)
[17:02:46.676]             if (.Platform$OS.type == "windows") {
[17:02:46.676]                 old_names <- names(...future.oldEnvVars)
[17:02:46.676]                 envs <- base::Sys.getenv()
[17:02:46.676]                 names <- names(envs)
[17:02:46.676]                 common <- intersect(names, old_names)
[17:02:46.676]                 added <- setdiff(names, old_names)
[17:02:46.676]                 removed <- setdiff(old_names, names)
[17:02:46.676]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.676]                   envs[common]]
[17:02:46.676]                 NAMES <- toupper(changed)
[17:02:46.676]                 args <- list()
[17:02:46.676]                 for (kk in seq_along(NAMES)) {
[17:02:46.676]                   name <- changed[[kk]]
[17:02:46.676]                   NAME <- NAMES[[kk]]
[17:02:46.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.676]                     next
[17:02:46.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.676]                 }
[17:02:46.676]                 NAMES <- toupper(added)
[17:02:46.676]                 for (kk in seq_along(NAMES)) {
[17:02:46.676]                   name <- added[[kk]]
[17:02:46.676]                   NAME <- NAMES[[kk]]
[17:02:46.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.676]                     next
[17:02:46.676]                   args[[name]] <- ""
[17:02:46.676]                 }
[17:02:46.676]                 NAMES <- toupper(removed)
[17:02:46.676]                 for (kk in seq_along(NAMES)) {
[17:02:46.676]                   name <- removed[[kk]]
[17:02:46.676]                   NAME <- NAMES[[kk]]
[17:02:46.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.676]                     next
[17:02:46.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.676]                 }
[17:02:46.676]                 if (length(args) > 0) 
[17:02:46.676]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.676]             }
[17:02:46.676]             else {
[17:02:46.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.676]             }
[17:02:46.676]             {
[17:02:46.676]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.676]                   0L) {
[17:02:46.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.676]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.676]                   base::options(opts)
[17:02:46.676]                 }
[17:02:46.676]                 {
[17:02:46.676]                   {
[17:02:46.676]                     NULL
[17:02:46.676]                     RNGkind("Mersenne-Twister")
[17:02:46.676]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.676]                       inherits = FALSE)
[17:02:46.676]                   }
[17:02:46.676]                   options(future.plan = NULL)
[17:02:46.676]                   if (is.na(NA_character_)) 
[17:02:46.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.676]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.676]                     .init = FALSE)
[17:02:46.676]                 }
[17:02:46.676]             }
[17:02:46.676]         }
[17:02:46.676]     })
[17:02:46.676]     if (TRUE) {
[17:02:46.676]         base::sink(type = "output", split = FALSE)
[17:02:46.676]         if (TRUE) {
[17:02:46.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.676]         }
[17:02:46.676]         else {
[17:02:46.676]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.676]         }
[17:02:46.676]         base::close(...future.stdout)
[17:02:46.676]         ...future.stdout <- NULL
[17:02:46.676]     }
[17:02:46.676]     ...future.result$conditions <- ...future.conditions
[17:02:46.676]     ...future.result$finished <- base::Sys.time()
[17:02:46.676]     ...future.result
[17:02:46.676] }
[17:02:46.678] assign_globals() ...
[17:02:46.678] List of 1
[17:02:46.678]  $ x: list()
[17:02:46.678]  - attr(*, "where")=List of 1
[17:02:46.678]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.678]  - attr(*, "resolved")= logi TRUE
[17:02:46.678]  - attr(*, "total_size")= num 0
[17:02:46.678]  - attr(*, "already-done")= logi TRUE
[17:02:46.680] - copied ‘x’ to environment
[17:02:46.681] assign_globals() ... done
[17:02:46.681] plan(): Setting new future strategy stack:
[17:02:46.681] List of future strategies:
[17:02:46.681] 1. sequential:
[17:02:46.681]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.681]    - tweaked: FALSE
[17:02:46.681]    - call: NULL
[17:02:46.681] plan(): nbrOfWorkers() = 1
[17:02:46.682] plan(): Setting new future strategy stack:
[17:02:46.682] List of future strategies:
[17:02:46.682] 1. sequential:
[17:02:46.682]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.682]    - tweaked: FALSE
[17:02:46.682]    - call: plan(strategy)
[17:02:46.683] plan(): nbrOfWorkers() = 1
[17:02:46.683] SequentialFuture started (and completed)
[17:02:46.683] - Launch lazy future ... done
[17:02:46.683] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.683] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.684] Searching for globals...
[17:02:46.686] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:02:46.686] Searching for globals ... DONE
[17:02:46.686] Resolving globals: TRUE
[17:02:46.686] Resolving any globals that are futures ...
[17:02:46.686] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:02:46.687] Resolving any globals that are futures ... DONE
[17:02:46.687] 
[17:02:46.687] 
[17:02:46.687] getGlobalsAndPackages() ... DONE
[17:02:46.687] run() for ‘Future’ ...
[17:02:46.687] - state: ‘created’
[17:02:46.687] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.688] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.688] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.688]   - Field: ‘label’
[17:02:46.688]   - Field: ‘local’
[17:02:46.688]   - Field: ‘owner’
[17:02:46.688]   - Field: ‘envir’
[17:02:46.688]   - Field: ‘packages’
[17:02:46.688]   - Field: ‘gc’
[17:02:46.688]   - Field: ‘conditions’
[17:02:46.689]   - Field: ‘expr’
[17:02:46.689]   - Field: ‘uuid’
[17:02:46.689]   - Field: ‘seed’
[17:02:46.689]   - Field: ‘version’
[17:02:46.689]   - Field: ‘result’
[17:02:46.689]   - Field: ‘asynchronous’
[17:02:46.689]   - Field: ‘calls’
[17:02:46.689]   - Field: ‘globals’
[17:02:46.689]   - Field: ‘stdout’
[17:02:46.689]   - Field: ‘earlySignal’
[17:02:46.689]   - Field: ‘lazy’
[17:02:46.690]   - Field: ‘state’
[17:02:46.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.690] - Launch lazy future ...
[17:02:46.690] Packages needed by the future expression (n = 0): <none>
[17:02:46.690] Packages needed by future strategies (n = 0): <none>
[17:02:46.690] {
[17:02:46.690]     {
[17:02:46.690]         {
[17:02:46.690]             ...future.startTime <- base::Sys.time()
[17:02:46.690]             {
[17:02:46.690]                 {
[17:02:46.690]                   {
[17:02:46.690]                     base::local({
[17:02:46.690]                       has_future <- base::requireNamespace("future", 
[17:02:46.690]                         quietly = TRUE)
[17:02:46.690]                       if (has_future) {
[17:02:46.690]                         ns <- base::getNamespace("future")
[17:02:46.690]                         version <- ns[[".package"]][["version"]]
[17:02:46.690]                         if (is.null(version)) 
[17:02:46.690]                           version <- utils::packageVersion("future")
[17:02:46.690]                       }
[17:02:46.690]                       else {
[17:02:46.690]                         version <- NULL
[17:02:46.690]                       }
[17:02:46.690]                       if (!has_future || version < "1.8.0") {
[17:02:46.690]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.690]                           "", base::R.version$version.string), 
[17:02:46.690]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.690]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.690]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.690]                             "release", "version")], collapse = " "), 
[17:02:46.690]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.690]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.690]                           info)
[17:02:46.690]                         info <- base::paste(info, collapse = "; ")
[17:02:46.690]                         if (!has_future) {
[17:02:46.690]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.690]                             info)
[17:02:46.690]                         }
[17:02:46.690]                         else {
[17:02:46.690]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.690]                             info, version)
[17:02:46.690]                         }
[17:02:46.690]                         base::stop(msg)
[17:02:46.690]                       }
[17:02:46.690]                     })
[17:02:46.690]                   }
[17:02:46.690]                   ...future.strategy.old <- future::plan("list")
[17:02:46.690]                   options(future.plan = NULL)
[17:02:46.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.690]                 }
[17:02:46.690]                 ...future.workdir <- getwd()
[17:02:46.690]             }
[17:02:46.690]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.690]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.690]         }
[17:02:46.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.690]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.690]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.690]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.690]             base::names(...future.oldOptions))
[17:02:46.690]     }
[17:02:46.690]     if (FALSE) {
[17:02:46.690]     }
[17:02:46.690]     else {
[17:02:46.690]         if (TRUE) {
[17:02:46.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.690]                 open = "w")
[17:02:46.690]         }
[17:02:46.690]         else {
[17:02:46.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.690]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.690]         }
[17:02:46.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.690]             base::sink(type = "output", split = FALSE)
[17:02:46.690]             base::close(...future.stdout)
[17:02:46.690]         }, add = TRUE)
[17:02:46.690]     }
[17:02:46.690]     ...future.frame <- base::sys.nframe()
[17:02:46.690]     ...future.conditions <- base::list()
[17:02:46.690]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.690]     if (FALSE) {
[17:02:46.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.690]     }
[17:02:46.690]     ...future.result <- base::tryCatch({
[17:02:46.690]         base::withCallingHandlers({
[17:02:46.690]             ...future.value <- base::withVisible(base::local({
[17:02:46.690]                 x <- list(b = 2)
[17:02:46.690]                 x$a <- 1
[17:02:46.690]                 x
[17:02:46.690]             }))
[17:02:46.690]             future::FutureResult(value = ...future.value$value, 
[17:02:46.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.690]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.690]                     ...future.globalenv.names))
[17:02:46.690]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.690]         }, condition = base::local({
[17:02:46.690]             c <- base::c
[17:02:46.690]             inherits <- base::inherits
[17:02:46.690]             invokeRestart <- base::invokeRestart
[17:02:46.690]             length <- base::length
[17:02:46.690]             list <- base::list
[17:02:46.690]             seq.int <- base::seq.int
[17:02:46.690]             signalCondition <- base::signalCondition
[17:02:46.690]             sys.calls <- base::sys.calls
[17:02:46.690]             `[[` <- base::`[[`
[17:02:46.690]             `+` <- base::`+`
[17:02:46.690]             `<<-` <- base::`<<-`
[17:02:46.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.690]                   3L)]
[17:02:46.690]             }
[17:02:46.690]             function(cond) {
[17:02:46.690]                 is_error <- inherits(cond, "error")
[17:02:46.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.690]                   NULL)
[17:02:46.690]                 if (is_error) {
[17:02:46.690]                   sessionInformation <- function() {
[17:02:46.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.690]                       search = base::search(), system = base::Sys.info())
[17:02:46.690]                   }
[17:02:46.690]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.690]                     cond$call), session = sessionInformation(), 
[17:02:46.690]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.690]                   signalCondition(cond)
[17:02:46.690]                 }
[17:02:46.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.690]                 "immediateCondition"))) {
[17:02:46.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.690]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.690]                   if (TRUE && !signal) {
[17:02:46.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.690]                     {
[17:02:46.690]                       inherits <- base::inherits
[17:02:46.690]                       invokeRestart <- base::invokeRestart
[17:02:46.690]                       is.null <- base::is.null
[17:02:46.690]                       muffled <- FALSE
[17:02:46.690]                       if (inherits(cond, "message")) {
[17:02:46.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.690]                         if (muffled) 
[17:02:46.690]                           invokeRestart("muffleMessage")
[17:02:46.690]                       }
[17:02:46.690]                       else if (inherits(cond, "warning")) {
[17:02:46.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.690]                         if (muffled) 
[17:02:46.690]                           invokeRestart("muffleWarning")
[17:02:46.690]                       }
[17:02:46.690]                       else if (inherits(cond, "condition")) {
[17:02:46.690]                         if (!is.null(pattern)) {
[17:02:46.690]                           computeRestarts <- base::computeRestarts
[17:02:46.690]                           grepl <- base::grepl
[17:02:46.690]                           restarts <- computeRestarts(cond)
[17:02:46.690]                           for (restart in restarts) {
[17:02:46.690]                             name <- restart$name
[17:02:46.690]                             if (is.null(name)) 
[17:02:46.690]                               next
[17:02:46.690]                             if (!grepl(pattern, name)) 
[17:02:46.690]                               next
[17:02:46.690]                             invokeRestart(restart)
[17:02:46.690]                             muffled <- TRUE
[17:02:46.690]                             break
[17:02:46.690]                           }
[17:02:46.690]                         }
[17:02:46.690]                       }
[17:02:46.690]                       invisible(muffled)
[17:02:46.690]                     }
[17:02:46.690]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.690]                   }
[17:02:46.690]                 }
[17:02:46.690]                 else {
[17:02:46.690]                   if (TRUE) {
[17:02:46.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.690]                     {
[17:02:46.690]                       inherits <- base::inherits
[17:02:46.690]                       invokeRestart <- base::invokeRestart
[17:02:46.690]                       is.null <- base::is.null
[17:02:46.690]                       muffled <- FALSE
[17:02:46.690]                       if (inherits(cond, "message")) {
[17:02:46.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.690]                         if (muffled) 
[17:02:46.690]                           invokeRestart("muffleMessage")
[17:02:46.690]                       }
[17:02:46.690]                       else if (inherits(cond, "warning")) {
[17:02:46.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.690]                         if (muffled) 
[17:02:46.690]                           invokeRestart("muffleWarning")
[17:02:46.690]                       }
[17:02:46.690]                       else if (inherits(cond, "condition")) {
[17:02:46.690]                         if (!is.null(pattern)) {
[17:02:46.690]                           computeRestarts <- base::computeRestarts
[17:02:46.690]                           grepl <- base::grepl
[17:02:46.690]                           restarts <- computeRestarts(cond)
[17:02:46.690]                           for (restart in restarts) {
[17:02:46.690]                             name <- restart$name
[17:02:46.690]                             if (is.null(name)) 
[17:02:46.690]                               next
[17:02:46.690]                             if (!grepl(pattern, name)) 
[17:02:46.690]                               next
[17:02:46.690]                             invokeRestart(restart)
[17:02:46.690]                             muffled <- TRUE
[17:02:46.690]                             break
[17:02:46.690]                           }
[17:02:46.690]                         }
[17:02:46.690]                       }
[17:02:46.690]                       invisible(muffled)
[17:02:46.690]                     }
[17:02:46.690]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.690]                   }
[17:02:46.690]                 }
[17:02:46.690]             }
[17:02:46.690]         }))
[17:02:46.690]     }, error = function(ex) {
[17:02:46.690]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.690]                 ...future.rng), started = ...future.startTime, 
[17:02:46.690]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.690]             version = "1.8"), class = "FutureResult")
[17:02:46.690]     }, finally = {
[17:02:46.690]         if (!identical(...future.workdir, getwd())) 
[17:02:46.690]             setwd(...future.workdir)
[17:02:46.690]         {
[17:02:46.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.690]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.690]             }
[17:02:46.690]             base::options(...future.oldOptions)
[17:02:46.690]             if (.Platform$OS.type == "windows") {
[17:02:46.690]                 old_names <- names(...future.oldEnvVars)
[17:02:46.690]                 envs <- base::Sys.getenv()
[17:02:46.690]                 names <- names(envs)
[17:02:46.690]                 common <- intersect(names, old_names)
[17:02:46.690]                 added <- setdiff(names, old_names)
[17:02:46.690]                 removed <- setdiff(old_names, names)
[17:02:46.690]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.690]                   envs[common]]
[17:02:46.690]                 NAMES <- toupper(changed)
[17:02:46.690]                 args <- list()
[17:02:46.690]                 for (kk in seq_along(NAMES)) {
[17:02:46.690]                   name <- changed[[kk]]
[17:02:46.690]                   NAME <- NAMES[[kk]]
[17:02:46.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.690]                     next
[17:02:46.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.690]                 }
[17:02:46.690]                 NAMES <- toupper(added)
[17:02:46.690]                 for (kk in seq_along(NAMES)) {
[17:02:46.690]                   name <- added[[kk]]
[17:02:46.690]                   NAME <- NAMES[[kk]]
[17:02:46.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.690]                     next
[17:02:46.690]                   args[[name]] <- ""
[17:02:46.690]                 }
[17:02:46.690]                 NAMES <- toupper(removed)
[17:02:46.690]                 for (kk in seq_along(NAMES)) {
[17:02:46.690]                   name <- removed[[kk]]
[17:02:46.690]                   NAME <- NAMES[[kk]]
[17:02:46.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.690]                     next
[17:02:46.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.690]                 }
[17:02:46.690]                 if (length(args) > 0) 
[17:02:46.690]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.690]             }
[17:02:46.690]             else {
[17:02:46.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.690]             }
[17:02:46.690]             {
[17:02:46.690]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.690]                   0L) {
[17:02:46.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.690]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.690]                   base::options(opts)
[17:02:46.690]                 }
[17:02:46.690]                 {
[17:02:46.690]                   {
[17:02:46.690]                     NULL
[17:02:46.690]                     RNGkind("Mersenne-Twister")
[17:02:46.690]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.690]                       inherits = FALSE)
[17:02:46.690]                   }
[17:02:46.690]                   options(future.plan = NULL)
[17:02:46.690]                   if (is.na(NA_character_)) 
[17:02:46.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.690]                     .init = FALSE)
[17:02:46.690]                 }
[17:02:46.690]             }
[17:02:46.690]         }
[17:02:46.690]     })
[17:02:46.690]     if (TRUE) {
[17:02:46.690]         base::sink(type = "output", split = FALSE)
[17:02:46.690]         if (TRUE) {
[17:02:46.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.690]         }
[17:02:46.690]         else {
[17:02:46.690]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.690]         }
[17:02:46.690]         base::close(...future.stdout)
[17:02:46.690]         ...future.stdout <- NULL
[17:02:46.690]     }
[17:02:46.690]     ...future.result$conditions <- ...future.conditions
[17:02:46.690]     ...future.result$finished <- base::Sys.time()
[17:02:46.690]     ...future.result
[17:02:46.690] }
[17:02:46.692] plan(): Setting new future strategy stack:
[17:02:46.692] List of future strategies:
[17:02:46.692] 1. sequential:
[17:02:46.692]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.692]    - tweaked: FALSE
[17:02:46.692]    - call: NULL
[17:02:46.694] plan(): nbrOfWorkers() = 1
[17:02:46.695] plan(): Setting new future strategy stack:
[17:02:46.695] List of future strategies:
[17:02:46.695] 1. sequential:
[17:02:46.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.695]    - tweaked: FALSE
[17:02:46.695]    - call: plan(strategy)
[17:02:46.696] plan(): nbrOfWorkers() = 1
[17:02:46.696] SequentialFuture started (and completed)
[17:02:46.696] - Launch lazy future ... done
[17:02:46.696] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.696] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.697] Searching for globals...
[17:02:46.698] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:46.698] Searching for globals ... DONE
[17:02:46.699] Resolving globals: TRUE
[17:02:46.699] Resolving any globals that are futures ...
[17:02:46.699] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:46.699] Resolving any globals that are futures ... DONE
[17:02:46.699] Resolving futures part of globals (recursively) ...
[17:02:46.699] resolve() on list ...
[17:02:46.700]  recursive: 99
[17:02:46.700]  length: 1
[17:02:46.700]  elements: ‘x’
[17:02:46.700]  length: 0 (resolved future 1)
[17:02:46.700] resolve() on list ... DONE
[17:02:46.700] - globals: [1] ‘x’
[17:02:46.700] Resolving futures part of globals (recursively) ... DONE
[17:02:46.700] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.701] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.701] - globals: [1] ‘x’
[17:02:46.701] 
[17:02:46.701] getGlobalsAndPackages() ... DONE
[17:02:46.701] run() for ‘Future’ ...
[17:02:46.701] - state: ‘created’
[17:02:46.701] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.702] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.702]   - Field: ‘label’
[17:02:46.702]   - Field: ‘local’
[17:02:46.702]   - Field: ‘owner’
[17:02:46.702]   - Field: ‘envir’
[17:02:46.702]   - Field: ‘packages’
[17:02:46.702]   - Field: ‘gc’
[17:02:46.702]   - Field: ‘conditions’
[17:02:46.702]   - Field: ‘expr’
[17:02:46.703]   - Field: ‘uuid’
[17:02:46.703]   - Field: ‘seed’
[17:02:46.703]   - Field: ‘version’
[17:02:46.703]   - Field: ‘result’
[17:02:46.703]   - Field: ‘asynchronous’
[17:02:46.703]   - Field: ‘calls’
[17:02:46.703]   - Field: ‘globals’
[17:02:46.703]   - Field: ‘stdout’
[17:02:46.703]   - Field: ‘earlySignal’
[17:02:46.703]   - Field: ‘lazy’
[17:02:46.703]   - Field: ‘state’
[17:02:46.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.704] - Launch lazy future ...
[17:02:46.704] Packages needed by the future expression (n = 0): <none>
[17:02:46.704] Packages needed by future strategies (n = 0): <none>
[17:02:46.704] {
[17:02:46.704]     {
[17:02:46.704]         {
[17:02:46.704]             ...future.startTime <- base::Sys.time()
[17:02:46.704]             {
[17:02:46.704]                 {
[17:02:46.704]                   {
[17:02:46.704]                     base::local({
[17:02:46.704]                       has_future <- base::requireNamespace("future", 
[17:02:46.704]                         quietly = TRUE)
[17:02:46.704]                       if (has_future) {
[17:02:46.704]                         ns <- base::getNamespace("future")
[17:02:46.704]                         version <- ns[[".package"]][["version"]]
[17:02:46.704]                         if (is.null(version)) 
[17:02:46.704]                           version <- utils::packageVersion("future")
[17:02:46.704]                       }
[17:02:46.704]                       else {
[17:02:46.704]                         version <- NULL
[17:02:46.704]                       }
[17:02:46.704]                       if (!has_future || version < "1.8.0") {
[17:02:46.704]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.704]                           "", base::R.version$version.string), 
[17:02:46.704]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.704]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.704]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.704]                             "release", "version")], collapse = " "), 
[17:02:46.704]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.704]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.704]                           info)
[17:02:46.704]                         info <- base::paste(info, collapse = "; ")
[17:02:46.704]                         if (!has_future) {
[17:02:46.704]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.704]                             info)
[17:02:46.704]                         }
[17:02:46.704]                         else {
[17:02:46.704]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.704]                             info, version)
[17:02:46.704]                         }
[17:02:46.704]                         base::stop(msg)
[17:02:46.704]                       }
[17:02:46.704]                     })
[17:02:46.704]                   }
[17:02:46.704]                   ...future.strategy.old <- future::plan("list")
[17:02:46.704]                   options(future.plan = NULL)
[17:02:46.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.704]                 }
[17:02:46.704]                 ...future.workdir <- getwd()
[17:02:46.704]             }
[17:02:46.704]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.704]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.704]         }
[17:02:46.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.704]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.704]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.704]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.704]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.704]             base::names(...future.oldOptions))
[17:02:46.704]     }
[17:02:46.704]     if (FALSE) {
[17:02:46.704]     }
[17:02:46.704]     else {
[17:02:46.704]         if (TRUE) {
[17:02:46.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.704]                 open = "w")
[17:02:46.704]         }
[17:02:46.704]         else {
[17:02:46.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.704]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.704]         }
[17:02:46.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.704]             base::sink(type = "output", split = FALSE)
[17:02:46.704]             base::close(...future.stdout)
[17:02:46.704]         }, add = TRUE)
[17:02:46.704]     }
[17:02:46.704]     ...future.frame <- base::sys.nframe()
[17:02:46.704]     ...future.conditions <- base::list()
[17:02:46.704]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.704]     if (FALSE) {
[17:02:46.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.704]     }
[17:02:46.704]     ...future.result <- base::tryCatch({
[17:02:46.704]         base::withCallingHandlers({
[17:02:46.704]             ...future.value <- base::withVisible(base::local({
[17:02:46.704]                 x[["a"]] <- 1
[17:02:46.704]                 x
[17:02:46.704]             }))
[17:02:46.704]             future::FutureResult(value = ...future.value$value, 
[17:02:46.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.704]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.704]                     ...future.globalenv.names))
[17:02:46.704]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.704]         }, condition = base::local({
[17:02:46.704]             c <- base::c
[17:02:46.704]             inherits <- base::inherits
[17:02:46.704]             invokeRestart <- base::invokeRestart
[17:02:46.704]             length <- base::length
[17:02:46.704]             list <- base::list
[17:02:46.704]             seq.int <- base::seq.int
[17:02:46.704]             signalCondition <- base::signalCondition
[17:02:46.704]             sys.calls <- base::sys.calls
[17:02:46.704]             `[[` <- base::`[[`
[17:02:46.704]             `+` <- base::`+`
[17:02:46.704]             `<<-` <- base::`<<-`
[17:02:46.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.704]                   3L)]
[17:02:46.704]             }
[17:02:46.704]             function(cond) {
[17:02:46.704]                 is_error <- inherits(cond, "error")
[17:02:46.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.704]                   NULL)
[17:02:46.704]                 if (is_error) {
[17:02:46.704]                   sessionInformation <- function() {
[17:02:46.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.704]                       search = base::search(), system = base::Sys.info())
[17:02:46.704]                   }
[17:02:46.704]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.704]                     cond$call), session = sessionInformation(), 
[17:02:46.704]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.704]                   signalCondition(cond)
[17:02:46.704]                 }
[17:02:46.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.704]                 "immediateCondition"))) {
[17:02:46.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.704]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.704]                   if (TRUE && !signal) {
[17:02:46.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.704]                     {
[17:02:46.704]                       inherits <- base::inherits
[17:02:46.704]                       invokeRestart <- base::invokeRestart
[17:02:46.704]                       is.null <- base::is.null
[17:02:46.704]                       muffled <- FALSE
[17:02:46.704]                       if (inherits(cond, "message")) {
[17:02:46.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.704]                         if (muffled) 
[17:02:46.704]                           invokeRestart("muffleMessage")
[17:02:46.704]                       }
[17:02:46.704]                       else if (inherits(cond, "warning")) {
[17:02:46.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.704]                         if (muffled) 
[17:02:46.704]                           invokeRestart("muffleWarning")
[17:02:46.704]                       }
[17:02:46.704]                       else if (inherits(cond, "condition")) {
[17:02:46.704]                         if (!is.null(pattern)) {
[17:02:46.704]                           computeRestarts <- base::computeRestarts
[17:02:46.704]                           grepl <- base::grepl
[17:02:46.704]                           restarts <- computeRestarts(cond)
[17:02:46.704]                           for (restart in restarts) {
[17:02:46.704]                             name <- restart$name
[17:02:46.704]                             if (is.null(name)) 
[17:02:46.704]                               next
[17:02:46.704]                             if (!grepl(pattern, name)) 
[17:02:46.704]                               next
[17:02:46.704]                             invokeRestart(restart)
[17:02:46.704]                             muffled <- TRUE
[17:02:46.704]                             break
[17:02:46.704]                           }
[17:02:46.704]                         }
[17:02:46.704]                       }
[17:02:46.704]                       invisible(muffled)
[17:02:46.704]                     }
[17:02:46.704]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.704]                   }
[17:02:46.704]                 }
[17:02:46.704]                 else {
[17:02:46.704]                   if (TRUE) {
[17:02:46.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.704]                     {
[17:02:46.704]                       inherits <- base::inherits
[17:02:46.704]                       invokeRestart <- base::invokeRestart
[17:02:46.704]                       is.null <- base::is.null
[17:02:46.704]                       muffled <- FALSE
[17:02:46.704]                       if (inherits(cond, "message")) {
[17:02:46.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.704]                         if (muffled) 
[17:02:46.704]                           invokeRestart("muffleMessage")
[17:02:46.704]                       }
[17:02:46.704]                       else if (inherits(cond, "warning")) {
[17:02:46.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.704]                         if (muffled) 
[17:02:46.704]                           invokeRestart("muffleWarning")
[17:02:46.704]                       }
[17:02:46.704]                       else if (inherits(cond, "condition")) {
[17:02:46.704]                         if (!is.null(pattern)) {
[17:02:46.704]                           computeRestarts <- base::computeRestarts
[17:02:46.704]                           grepl <- base::grepl
[17:02:46.704]                           restarts <- computeRestarts(cond)
[17:02:46.704]                           for (restart in restarts) {
[17:02:46.704]                             name <- restart$name
[17:02:46.704]                             if (is.null(name)) 
[17:02:46.704]                               next
[17:02:46.704]                             if (!grepl(pattern, name)) 
[17:02:46.704]                               next
[17:02:46.704]                             invokeRestart(restart)
[17:02:46.704]                             muffled <- TRUE
[17:02:46.704]                             break
[17:02:46.704]                           }
[17:02:46.704]                         }
[17:02:46.704]                       }
[17:02:46.704]                       invisible(muffled)
[17:02:46.704]                     }
[17:02:46.704]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.704]                   }
[17:02:46.704]                 }
[17:02:46.704]             }
[17:02:46.704]         }))
[17:02:46.704]     }, error = function(ex) {
[17:02:46.704]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.704]                 ...future.rng), started = ...future.startTime, 
[17:02:46.704]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.704]             version = "1.8"), class = "FutureResult")
[17:02:46.704]     }, finally = {
[17:02:46.704]         if (!identical(...future.workdir, getwd())) 
[17:02:46.704]             setwd(...future.workdir)
[17:02:46.704]         {
[17:02:46.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.704]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.704]             }
[17:02:46.704]             base::options(...future.oldOptions)
[17:02:46.704]             if (.Platform$OS.type == "windows") {
[17:02:46.704]                 old_names <- names(...future.oldEnvVars)
[17:02:46.704]                 envs <- base::Sys.getenv()
[17:02:46.704]                 names <- names(envs)
[17:02:46.704]                 common <- intersect(names, old_names)
[17:02:46.704]                 added <- setdiff(names, old_names)
[17:02:46.704]                 removed <- setdiff(old_names, names)
[17:02:46.704]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.704]                   envs[common]]
[17:02:46.704]                 NAMES <- toupper(changed)
[17:02:46.704]                 args <- list()
[17:02:46.704]                 for (kk in seq_along(NAMES)) {
[17:02:46.704]                   name <- changed[[kk]]
[17:02:46.704]                   NAME <- NAMES[[kk]]
[17:02:46.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.704]                     next
[17:02:46.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.704]                 }
[17:02:46.704]                 NAMES <- toupper(added)
[17:02:46.704]                 for (kk in seq_along(NAMES)) {
[17:02:46.704]                   name <- added[[kk]]
[17:02:46.704]                   NAME <- NAMES[[kk]]
[17:02:46.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.704]                     next
[17:02:46.704]                   args[[name]] <- ""
[17:02:46.704]                 }
[17:02:46.704]                 NAMES <- toupper(removed)
[17:02:46.704]                 for (kk in seq_along(NAMES)) {
[17:02:46.704]                   name <- removed[[kk]]
[17:02:46.704]                   NAME <- NAMES[[kk]]
[17:02:46.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.704]                     next
[17:02:46.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.704]                 }
[17:02:46.704]                 if (length(args) > 0) 
[17:02:46.704]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.704]             }
[17:02:46.704]             else {
[17:02:46.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.704]             }
[17:02:46.704]             {
[17:02:46.704]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.704]                   0L) {
[17:02:46.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.704]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.704]                   base::options(opts)
[17:02:46.704]                 }
[17:02:46.704]                 {
[17:02:46.704]                   {
[17:02:46.704]                     NULL
[17:02:46.704]                     RNGkind("Mersenne-Twister")
[17:02:46.704]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.704]                       inherits = FALSE)
[17:02:46.704]                   }
[17:02:46.704]                   options(future.plan = NULL)
[17:02:46.704]                   if (is.na(NA_character_)) 
[17:02:46.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.704]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.704]                     .init = FALSE)
[17:02:46.704]                 }
[17:02:46.704]             }
[17:02:46.704]         }
[17:02:46.704]     })
[17:02:46.704]     if (TRUE) {
[17:02:46.704]         base::sink(type = "output", split = FALSE)
[17:02:46.704]         if (TRUE) {
[17:02:46.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.704]         }
[17:02:46.704]         else {
[17:02:46.704]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.704]         }
[17:02:46.704]         base::close(...future.stdout)
[17:02:46.704]         ...future.stdout <- NULL
[17:02:46.704]     }
[17:02:46.704]     ...future.result$conditions <- ...future.conditions
[17:02:46.704]     ...future.result$finished <- base::Sys.time()
[17:02:46.704]     ...future.result
[17:02:46.704] }
[17:02:46.706] assign_globals() ...
[17:02:46.706] List of 1
[17:02:46.706]  $ x: list()
[17:02:46.706]  - attr(*, "where")=List of 1
[17:02:46.706]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.706]  - attr(*, "resolved")= logi TRUE
[17:02:46.706]  - attr(*, "total_size")= num 0
[17:02:46.706]  - attr(*, "already-done")= logi TRUE
[17:02:46.708] - copied ‘x’ to environment
[17:02:46.708] assign_globals() ... done
[17:02:46.709] plan(): Setting new future strategy stack:
[17:02:46.709] List of future strategies:
[17:02:46.709] 1. sequential:
[17:02:46.709]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.709]    - tweaked: FALSE
[17:02:46.709]    - call: NULL
[17:02:46.709] plan(): nbrOfWorkers() = 1
[17:02:46.710] plan(): Setting new future strategy stack:
[17:02:46.710] List of future strategies:
[17:02:46.710] 1. sequential:
[17:02:46.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.710]    - tweaked: FALSE
[17:02:46.710]    - call: plan(strategy)
[17:02:46.710] plan(): nbrOfWorkers() = 1
[17:02:46.711] SequentialFuture started (and completed)
[17:02:46.711] - Launch lazy future ... done
[17:02:46.711] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.711] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.711] Searching for globals...
[17:02:46.713] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:46.713] Searching for globals ... DONE
[17:02:46.713] Resolving globals: TRUE
[17:02:46.714] Resolving any globals that are futures ...
[17:02:46.714] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:46.714] Resolving any globals that are futures ... DONE
[17:02:46.714] Resolving futures part of globals (recursively) ...
[17:02:46.714] resolve() on list ...
[17:02:46.714]  recursive: 99
[17:02:46.714]  length: 1
[17:02:46.715]  elements: ‘x’
[17:02:46.715]  length: 0 (resolved future 1)
[17:02:46.715] resolve() on list ... DONE
[17:02:46.715] - globals: [1] ‘x’
[17:02:46.715] Resolving futures part of globals (recursively) ... DONE
[17:02:46.715] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.715] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.716] - globals: [1] ‘x’
[17:02:46.716] 
[17:02:46.716] getGlobalsAndPackages() ... DONE
[17:02:46.716] run() for ‘Future’ ...
[17:02:46.716] - state: ‘created’
[17:02:46.716] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.716] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.717]   - Field: ‘label’
[17:02:46.717]   - Field: ‘local’
[17:02:46.717]   - Field: ‘owner’
[17:02:46.717]   - Field: ‘envir’
[17:02:46.717]   - Field: ‘packages’
[17:02:46.717]   - Field: ‘gc’
[17:02:46.717]   - Field: ‘conditions’
[17:02:46.717]   - Field: ‘expr’
[17:02:46.717]   - Field: ‘uuid’
[17:02:46.718]   - Field: ‘seed’
[17:02:46.718]   - Field: ‘version’
[17:02:46.718]   - Field: ‘result’
[17:02:46.718]   - Field: ‘asynchronous’
[17:02:46.718]   - Field: ‘calls’
[17:02:46.718]   - Field: ‘globals’
[17:02:46.718]   - Field: ‘stdout’
[17:02:46.718]   - Field: ‘earlySignal’
[17:02:46.718]   - Field: ‘lazy’
[17:02:46.718]   - Field: ‘state’
[17:02:46.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.719] - Launch lazy future ...
[17:02:46.719] Packages needed by the future expression (n = 0): <none>
[17:02:46.719] Packages needed by future strategies (n = 0): <none>
[17:02:46.719] {
[17:02:46.719]     {
[17:02:46.719]         {
[17:02:46.719]             ...future.startTime <- base::Sys.time()
[17:02:46.719]             {
[17:02:46.719]                 {
[17:02:46.719]                   {
[17:02:46.719]                     base::local({
[17:02:46.719]                       has_future <- base::requireNamespace("future", 
[17:02:46.719]                         quietly = TRUE)
[17:02:46.719]                       if (has_future) {
[17:02:46.719]                         ns <- base::getNamespace("future")
[17:02:46.719]                         version <- ns[[".package"]][["version"]]
[17:02:46.719]                         if (is.null(version)) 
[17:02:46.719]                           version <- utils::packageVersion("future")
[17:02:46.719]                       }
[17:02:46.719]                       else {
[17:02:46.719]                         version <- NULL
[17:02:46.719]                       }
[17:02:46.719]                       if (!has_future || version < "1.8.0") {
[17:02:46.719]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.719]                           "", base::R.version$version.string), 
[17:02:46.719]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.719]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.719]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.719]                             "release", "version")], collapse = " "), 
[17:02:46.719]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.719]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.719]                           info)
[17:02:46.719]                         info <- base::paste(info, collapse = "; ")
[17:02:46.719]                         if (!has_future) {
[17:02:46.719]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.719]                             info)
[17:02:46.719]                         }
[17:02:46.719]                         else {
[17:02:46.719]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.719]                             info, version)
[17:02:46.719]                         }
[17:02:46.719]                         base::stop(msg)
[17:02:46.719]                       }
[17:02:46.719]                     })
[17:02:46.719]                   }
[17:02:46.719]                   ...future.strategy.old <- future::plan("list")
[17:02:46.719]                   options(future.plan = NULL)
[17:02:46.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.719]                 }
[17:02:46.719]                 ...future.workdir <- getwd()
[17:02:46.719]             }
[17:02:46.719]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.719]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.719]         }
[17:02:46.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.719]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.719]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.719]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.719]             base::names(...future.oldOptions))
[17:02:46.719]     }
[17:02:46.719]     if (FALSE) {
[17:02:46.719]     }
[17:02:46.719]     else {
[17:02:46.719]         if (TRUE) {
[17:02:46.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.719]                 open = "w")
[17:02:46.719]         }
[17:02:46.719]         else {
[17:02:46.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.719]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.719]         }
[17:02:46.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.719]             base::sink(type = "output", split = FALSE)
[17:02:46.719]             base::close(...future.stdout)
[17:02:46.719]         }, add = TRUE)
[17:02:46.719]     }
[17:02:46.719]     ...future.frame <- base::sys.nframe()
[17:02:46.719]     ...future.conditions <- base::list()
[17:02:46.719]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.719]     if (FALSE) {
[17:02:46.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.719]     }
[17:02:46.719]     ...future.result <- base::tryCatch({
[17:02:46.719]         base::withCallingHandlers({
[17:02:46.719]             ...future.value <- base::withVisible(base::local({
[17:02:46.719]                 x[["a"]] <- 1
[17:02:46.719]                 x
[17:02:46.719]             }))
[17:02:46.719]             future::FutureResult(value = ...future.value$value, 
[17:02:46.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.719]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.719]                     ...future.globalenv.names))
[17:02:46.719]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.719]         }, condition = base::local({
[17:02:46.719]             c <- base::c
[17:02:46.719]             inherits <- base::inherits
[17:02:46.719]             invokeRestart <- base::invokeRestart
[17:02:46.719]             length <- base::length
[17:02:46.719]             list <- base::list
[17:02:46.719]             seq.int <- base::seq.int
[17:02:46.719]             signalCondition <- base::signalCondition
[17:02:46.719]             sys.calls <- base::sys.calls
[17:02:46.719]             `[[` <- base::`[[`
[17:02:46.719]             `+` <- base::`+`
[17:02:46.719]             `<<-` <- base::`<<-`
[17:02:46.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.719]                   3L)]
[17:02:46.719]             }
[17:02:46.719]             function(cond) {
[17:02:46.719]                 is_error <- inherits(cond, "error")
[17:02:46.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.719]                   NULL)
[17:02:46.719]                 if (is_error) {
[17:02:46.719]                   sessionInformation <- function() {
[17:02:46.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.719]                       search = base::search(), system = base::Sys.info())
[17:02:46.719]                   }
[17:02:46.719]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.719]                     cond$call), session = sessionInformation(), 
[17:02:46.719]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.719]                   signalCondition(cond)
[17:02:46.719]                 }
[17:02:46.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.719]                 "immediateCondition"))) {
[17:02:46.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.719]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.719]                   if (TRUE && !signal) {
[17:02:46.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.719]                     {
[17:02:46.719]                       inherits <- base::inherits
[17:02:46.719]                       invokeRestart <- base::invokeRestart
[17:02:46.719]                       is.null <- base::is.null
[17:02:46.719]                       muffled <- FALSE
[17:02:46.719]                       if (inherits(cond, "message")) {
[17:02:46.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.719]                         if (muffled) 
[17:02:46.719]                           invokeRestart("muffleMessage")
[17:02:46.719]                       }
[17:02:46.719]                       else if (inherits(cond, "warning")) {
[17:02:46.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.719]                         if (muffled) 
[17:02:46.719]                           invokeRestart("muffleWarning")
[17:02:46.719]                       }
[17:02:46.719]                       else if (inherits(cond, "condition")) {
[17:02:46.719]                         if (!is.null(pattern)) {
[17:02:46.719]                           computeRestarts <- base::computeRestarts
[17:02:46.719]                           grepl <- base::grepl
[17:02:46.719]                           restarts <- computeRestarts(cond)
[17:02:46.719]                           for (restart in restarts) {
[17:02:46.719]                             name <- restart$name
[17:02:46.719]                             if (is.null(name)) 
[17:02:46.719]                               next
[17:02:46.719]                             if (!grepl(pattern, name)) 
[17:02:46.719]                               next
[17:02:46.719]                             invokeRestart(restart)
[17:02:46.719]                             muffled <- TRUE
[17:02:46.719]                             break
[17:02:46.719]                           }
[17:02:46.719]                         }
[17:02:46.719]                       }
[17:02:46.719]                       invisible(muffled)
[17:02:46.719]                     }
[17:02:46.719]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.719]                   }
[17:02:46.719]                 }
[17:02:46.719]                 else {
[17:02:46.719]                   if (TRUE) {
[17:02:46.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.719]                     {
[17:02:46.719]                       inherits <- base::inherits
[17:02:46.719]                       invokeRestart <- base::invokeRestart
[17:02:46.719]                       is.null <- base::is.null
[17:02:46.719]                       muffled <- FALSE
[17:02:46.719]                       if (inherits(cond, "message")) {
[17:02:46.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.719]                         if (muffled) 
[17:02:46.719]                           invokeRestart("muffleMessage")
[17:02:46.719]                       }
[17:02:46.719]                       else if (inherits(cond, "warning")) {
[17:02:46.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.719]                         if (muffled) 
[17:02:46.719]                           invokeRestart("muffleWarning")
[17:02:46.719]                       }
[17:02:46.719]                       else if (inherits(cond, "condition")) {
[17:02:46.719]                         if (!is.null(pattern)) {
[17:02:46.719]                           computeRestarts <- base::computeRestarts
[17:02:46.719]                           grepl <- base::grepl
[17:02:46.719]                           restarts <- computeRestarts(cond)
[17:02:46.719]                           for (restart in restarts) {
[17:02:46.719]                             name <- restart$name
[17:02:46.719]                             if (is.null(name)) 
[17:02:46.719]                               next
[17:02:46.719]                             if (!grepl(pattern, name)) 
[17:02:46.719]                               next
[17:02:46.719]                             invokeRestart(restart)
[17:02:46.719]                             muffled <- TRUE
[17:02:46.719]                             break
[17:02:46.719]                           }
[17:02:46.719]                         }
[17:02:46.719]                       }
[17:02:46.719]                       invisible(muffled)
[17:02:46.719]                     }
[17:02:46.719]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.719]                   }
[17:02:46.719]                 }
[17:02:46.719]             }
[17:02:46.719]         }))
[17:02:46.719]     }, error = function(ex) {
[17:02:46.719]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.719]                 ...future.rng), started = ...future.startTime, 
[17:02:46.719]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.719]             version = "1.8"), class = "FutureResult")
[17:02:46.719]     }, finally = {
[17:02:46.719]         if (!identical(...future.workdir, getwd())) 
[17:02:46.719]             setwd(...future.workdir)
[17:02:46.719]         {
[17:02:46.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.719]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.719]             }
[17:02:46.719]             base::options(...future.oldOptions)
[17:02:46.719]             if (.Platform$OS.type == "windows") {
[17:02:46.719]                 old_names <- names(...future.oldEnvVars)
[17:02:46.719]                 envs <- base::Sys.getenv()
[17:02:46.719]                 names <- names(envs)
[17:02:46.719]                 common <- intersect(names, old_names)
[17:02:46.719]                 added <- setdiff(names, old_names)
[17:02:46.719]                 removed <- setdiff(old_names, names)
[17:02:46.719]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.719]                   envs[common]]
[17:02:46.719]                 NAMES <- toupper(changed)
[17:02:46.719]                 args <- list()
[17:02:46.719]                 for (kk in seq_along(NAMES)) {
[17:02:46.719]                   name <- changed[[kk]]
[17:02:46.719]                   NAME <- NAMES[[kk]]
[17:02:46.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.719]                     next
[17:02:46.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.719]                 }
[17:02:46.719]                 NAMES <- toupper(added)
[17:02:46.719]                 for (kk in seq_along(NAMES)) {
[17:02:46.719]                   name <- added[[kk]]
[17:02:46.719]                   NAME <- NAMES[[kk]]
[17:02:46.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.719]                     next
[17:02:46.719]                   args[[name]] <- ""
[17:02:46.719]                 }
[17:02:46.719]                 NAMES <- toupper(removed)
[17:02:46.719]                 for (kk in seq_along(NAMES)) {
[17:02:46.719]                   name <- removed[[kk]]
[17:02:46.719]                   NAME <- NAMES[[kk]]
[17:02:46.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.719]                     next
[17:02:46.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.719]                 }
[17:02:46.719]                 if (length(args) > 0) 
[17:02:46.719]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.719]             }
[17:02:46.719]             else {
[17:02:46.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.719]             }
[17:02:46.719]             {
[17:02:46.719]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.719]                   0L) {
[17:02:46.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.719]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.719]                   base::options(opts)
[17:02:46.719]                 }
[17:02:46.719]                 {
[17:02:46.719]                   {
[17:02:46.719]                     NULL
[17:02:46.719]                     RNGkind("Mersenne-Twister")
[17:02:46.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.719]                       inherits = FALSE)
[17:02:46.719]                   }
[17:02:46.719]                   options(future.plan = NULL)
[17:02:46.719]                   if (is.na(NA_character_)) 
[17:02:46.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.719]                     .init = FALSE)
[17:02:46.719]                 }
[17:02:46.719]             }
[17:02:46.719]         }
[17:02:46.719]     })
[17:02:46.719]     if (TRUE) {
[17:02:46.719]         base::sink(type = "output", split = FALSE)
[17:02:46.719]         if (TRUE) {
[17:02:46.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.719]         }
[17:02:46.719]         else {
[17:02:46.719]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.719]         }
[17:02:46.719]         base::close(...future.stdout)
[17:02:46.719]         ...future.stdout <- NULL
[17:02:46.719]     }
[17:02:46.719]     ...future.result$conditions <- ...future.conditions
[17:02:46.719]     ...future.result$finished <- base::Sys.time()
[17:02:46.719]     ...future.result
[17:02:46.719] }
[17:02:46.721] assign_globals() ...
[17:02:46.721] List of 1
[17:02:46.721]  $ x: list()
[17:02:46.721]  - attr(*, "where")=List of 1
[17:02:46.721]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.721]  - attr(*, "resolved")= logi TRUE
[17:02:46.721]  - attr(*, "total_size")= num 0
[17:02:46.721]  - attr(*, "already-done")= logi TRUE
[17:02:46.725] - copied ‘x’ to environment
[17:02:46.725] assign_globals() ... done
[17:02:46.725] plan(): Setting new future strategy stack:
[17:02:46.725] List of future strategies:
[17:02:46.725] 1. sequential:
[17:02:46.725]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.725]    - tweaked: FALSE
[17:02:46.725]    - call: NULL
[17:02:46.726] plan(): nbrOfWorkers() = 1
[17:02:46.727] plan(): Setting new future strategy stack:
[17:02:46.727] List of future strategies:
[17:02:46.727] 1. sequential:
[17:02:46.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.727]    - tweaked: FALSE
[17:02:46.727]    - call: plan(strategy)
[17:02:46.727] plan(): nbrOfWorkers() = 1
[17:02:46.727] SequentialFuture started (and completed)
[17:02:46.727] - Launch lazy future ... done
[17:02:46.727] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.728] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.728] Searching for globals...
[17:02:46.730] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:46.730] Searching for globals ... DONE
[17:02:46.730] Resolving globals: TRUE
[17:02:46.730] Resolving any globals that are futures ...
[17:02:46.730] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:46.730] Resolving any globals that are futures ... DONE
[17:02:46.731] Resolving futures part of globals (recursively) ...
[17:02:46.731] resolve() on list ...
[17:02:46.731]  recursive: 99
[17:02:46.731]  length: 1
[17:02:46.731]  elements: ‘x’
[17:02:46.731]  length: 0 (resolved future 1)
[17:02:46.732] resolve() on list ... DONE
[17:02:46.732] - globals: [1] ‘x’
[17:02:46.732] Resolving futures part of globals (recursively) ... DONE
[17:02:46.732] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.732] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.732] - globals: [1] ‘x’
[17:02:46.732] 
[17:02:46.732] getGlobalsAndPackages() ... DONE
[17:02:46.733] run() for ‘Future’ ...
[17:02:46.733] - state: ‘created’
[17:02:46.733] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.733] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.733] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.733]   - Field: ‘label’
[17:02:46.734]   - Field: ‘local’
[17:02:46.734]   - Field: ‘owner’
[17:02:46.734]   - Field: ‘envir’
[17:02:46.734]   - Field: ‘packages’
[17:02:46.734]   - Field: ‘gc’
[17:02:46.734]   - Field: ‘conditions’
[17:02:46.734]   - Field: ‘expr’
[17:02:46.734]   - Field: ‘uuid’
[17:02:46.734]   - Field: ‘seed’
[17:02:46.734]   - Field: ‘version’
[17:02:46.734]   - Field: ‘result’
[17:02:46.735]   - Field: ‘asynchronous’
[17:02:46.735]   - Field: ‘calls’
[17:02:46.735]   - Field: ‘globals’
[17:02:46.735]   - Field: ‘stdout’
[17:02:46.735]   - Field: ‘earlySignal’
[17:02:46.735]   - Field: ‘lazy’
[17:02:46.735]   - Field: ‘state’
[17:02:46.735] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.735] - Launch lazy future ...
[17:02:46.735] Packages needed by the future expression (n = 0): <none>
[17:02:46.736] Packages needed by future strategies (n = 0): <none>
[17:02:46.736] {
[17:02:46.736]     {
[17:02:46.736]         {
[17:02:46.736]             ...future.startTime <- base::Sys.time()
[17:02:46.736]             {
[17:02:46.736]                 {
[17:02:46.736]                   {
[17:02:46.736]                     base::local({
[17:02:46.736]                       has_future <- base::requireNamespace("future", 
[17:02:46.736]                         quietly = TRUE)
[17:02:46.736]                       if (has_future) {
[17:02:46.736]                         ns <- base::getNamespace("future")
[17:02:46.736]                         version <- ns[[".package"]][["version"]]
[17:02:46.736]                         if (is.null(version)) 
[17:02:46.736]                           version <- utils::packageVersion("future")
[17:02:46.736]                       }
[17:02:46.736]                       else {
[17:02:46.736]                         version <- NULL
[17:02:46.736]                       }
[17:02:46.736]                       if (!has_future || version < "1.8.0") {
[17:02:46.736]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.736]                           "", base::R.version$version.string), 
[17:02:46.736]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.736]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.736]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.736]                             "release", "version")], collapse = " "), 
[17:02:46.736]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.736]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.736]                           info)
[17:02:46.736]                         info <- base::paste(info, collapse = "; ")
[17:02:46.736]                         if (!has_future) {
[17:02:46.736]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.736]                             info)
[17:02:46.736]                         }
[17:02:46.736]                         else {
[17:02:46.736]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.736]                             info, version)
[17:02:46.736]                         }
[17:02:46.736]                         base::stop(msg)
[17:02:46.736]                       }
[17:02:46.736]                     })
[17:02:46.736]                   }
[17:02:46.736]                   ...future.strategy.old <- future::plan("list")
[17:02:46.736]                   options(future.plan = NULL)
[17:02:46.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.736]                 }
[17:02:46.736]                 ...future.workdir <- getwd()
[17:02:46.736]             }
[17:02:46.736]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.736]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.736]         }
[17:02:46.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.736]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.736]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.736]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.736]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.736]             base::names(...future.oldOptions))
[17:02:46.736]     }
[17:02:46.736]     if (FALSE) {
[17:02:46.736]     }
[17:02:46.736]     else {
[17:02:46.736]         if (TRUE) {
[17:02:46.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.736]                 open = "w")
[17:02:46.736]         }
[17:02:46.736]         else {
[17:02:46.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.736]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.736]         }
[17:02:46.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.736]             base::sink(type = "output", split = FALSE)
[17:02:46.736]             base::close(...future.stdout)
[17:02:46.736]         }, add = TRUE)
[17:02:46.736]     }
[17:02:46.736]     ...future.frame <- base::sys.nframe()
[17:02:46.736]     ...future.conditions <- base::list()
[17:02:46.736]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.736]     if (FALSE) {
[17:02:46.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.736]     }
[17:02:46.736]     ...future.result <- base::tryCatch({
[17:02:46.736]         base::withCallingHandlers({
[17:02:46.736]             ...future.value <- base::withVisible(base::local({
[17:02:46.736]                 x[["a"]] <- 1
[17:02:46.736]                 x
[17:02:46.736]             }))
[17:02:46.736]             future::FutureResult(value = ...future.value$value, 
[17:02:46.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.736]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.736]                     ...future.globalenv.names))
[17:02:46.736]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.736]         }, condition = base::local({
[17:02:46.736]             c <- base::c
[17:02:46.736]             inherits <- base::inherits
[17:02:46.736]             invokeRestart <- base::invokeRestart
[17:02:46.736]             length <- base::length
[17:02:46.736]             list <- base::list
[17:02:46.736]             seq.int <- base::seq.int
[17:02:46.736]             signalCondition <- base::signalCondition
[17:02:46.736]             sys.calls <- base::sys.calls
[17:02:46.736]             `[[` <- base::`[[`
[17:02:46.736]             `+` <- base::`+`
[17:02:46.736]             `<<-` <- base::`<<-`
[17:02:46.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.736]                   3L)]
[17:02:46.736]             }
[17:02:46.736]             function(cond) {
[17:02:46.736]                 is_error <- inherits(cond, "error")
[17:02:46.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.736]                   NULL)
[17:02:46.736]                 if (is_error) {
[17:02:46.736]                   sessionInformation <- function() {
[17:02:46.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.736]                       search = base::search(), system = base::Sys.info())
[17:02:46.736]                   }
[17:02:46.736]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.736]                     cond$call), session = sessionInformation(), 
[17:02:46.736]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.736]                   signalCondition(cond)
[17:02:46.736]                 }
[17:02:46.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.736]                 "immediateCondition"))) {
[17:02:46.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.736]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.736]                   if (TRUE && !signal) {
[17:02:46.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.736]                     {
[17:02:46.736]                       inherits <- base::inherits
[17:02:46.736]                       invokeRestart <- base::invokeRestart
[17:02:46.736]                       is.null <- base::is.null
[17:02:46.736]                       muffled <- FALSE
[17:02:46.736]                       if (inherits(cond, "message")) {
[17:02:46.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.736]                         if (muffled) 
[17:02:46.736]                           invokeRestart("muffleMessage")
[17:02:46.736]                       }
[17:02:46.736]                       else if (inherits(cond, "warning")) {
[17:02:46.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.736]                         if (muffled) 
[17:02:46.736]                           invokeRestart("muffleWarning")
[17:02:46.736]                       }
[17:02:46.736]                       else if (inherits(cond, "condition")) {
[17:02:46.736]                         if (!is.null(pattern)) {
[17:02:46.736]                           computeRestarts <- base::computeRestarts
[17:02:46.736]                           grepl <- base::grepl
[17:02:46.736]                           restarts <- computeRestarts(cond)
[17:02:46.736]                           for (restart in restarts) {
[17:02:46.736]                             name <- restart$name
[17:02:46.736]                             if (is.null(name)) 
[17:02:46.736]                               next
[17:02:46.736]                             if (!grepl(pattern, name)) 
[17:02:46.736]                               next
[17:02:46.736]                             invokeRestart(restart)
[17:02:46.736]                             muffled <- TRUE
[17:02:46.736]                             break
[17:02:46.736]                           }
[17:02:46.736]                         }
[17:02:46.736]                       }
[17:02:46.736]                       invisible(muffled)
[17:02:46.736]                     }
[17:02:46.736]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.736]                   }
[17:02:46.736]                 }
[17:02:46.736]                 else {
[17:02:46.736]                   if (TRUE) {
[17:02:46.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.736]                     {
[17:02:46.736]                       inherits <- base::inherits
[17:02:46.736]                       invokeRestart <- base::invokeRestart
[17:02:46.736]                       is.null <- base::is.null
[17:02:46.736]                       muffled <- FALSE
[17:02:46.736]                       if (inherits(cond, "message")) {
[17:02:46.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.736]                         if (muffled) 
[17:02:46.736]                           invokeRestart("muffleMessage")
[17:02:46.736]                       }
[17:02:46.736]                       else if (inherits(cond, "warning")) {
[17:02:46.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.736]                         if (muffled) 
[17:02:46.736]                           invokeRestart("muffleWarning")
[17:02:46.736]                       }
[17:02:46.736]                       else if (inherits(cond, "condition")) {
[17:02:46.736]                         if (!is.null(pattern)) {
[17:02:46.736]                           computeRestarts <- base::computeRestarts
[17:02:46.736]                           grepl <- base::grepl
[17:02:46.736]                           restarts <- computeRestarts(cond)
[17:02:46.736]                           for (restart in restarts) {
[17:02:46.736]                             name <- restart$name
[17:02:46.736]                             if (is.null(name)) 
[17:02:46.736]                               next
[17:02:46.736]                             if (!grepl(pattern, name)) 
[17:02:46.736]                               next
[17:02:46.736]                             invokeRestart(restart)
[17:02:46.736]                             muffled <- TRUE
[17:02:46.736]                             break
[17:02:46.736]                           }
[17:02:46.736]                         }
[17:02:46.736]                       }
[17:02:46.736]                       invisible(muffled)
[17:02:46.736]                     }
[17:02:46.736]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.736]                   }
[17:02:46.736]                 }
[17:02:46.736]             }
[17:02:46.736]         }))
[17:02:46.736]     }, error = function(ex) {
[17:02:46.736]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.736]                 ...future.rng), started = ...future.startTime, 
[17:02:46.736]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.736]             version = "1.8"), class = "FutureResult")
[17:02:46.736]     }, finally = {
[17:02:46.736]         if (!identical(...future.workdir, getwd())) 
[17:02:46.736]             setwd(...future.workdir)
[17:02:46.736]         {
[17:02:46.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.736]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.736]             }
[17:02:46.736]             base::options(...future.oldOptions)
[17:02:46.736]             if (.Platform$OS.type == "windows") {
[17:02:46.736]                 old_names <- names(...future.oldEnvVars)
[17:02:46.736]                 envs <- base::Sys.getenv()
[17:02:46.736]                 names <- names(envs)
[17:02:46.736]                 common <- intersect(names, old_names)
[17:02:46.736]                 added <- setdiff(names, old_names)
[17:02:46.736]                 removed <- setdiff(old_names, names)
[17:02:46.736]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.736]                   envs[common]]
[17:02:46.736]                 NAMES <- toupper(changed)
[17:02:46.736]                 args <- list()
[17:02:46.736]                 for (kk in seq_along(NAMES)) {
[17:02:46.736]                   name <- changed[[kk]]
[17:02:46.736]                   NAME <- NAMES[[kk]]
[17:02:46.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.736]                     next
[17:02:46.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.736]                 }
[17:02:46.736]                 NAMES <- toupper(added)
[17:02:46.736]                 for (kk in seq_along(NAMES)) {
[17:02:46.736]                   name <- added[[kk]]
[17:02:46.736]                   NAME <- NAMES[[kk]]
[17:02:46.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.736]                     next
[17:02:46.736]                   args[[name]] <- ""
[17:02:46.736]                 }
[17:02:46.736]                 NAMES <- toupper(removed)
[17:02:46.736]                 for (kk in seq_along(NAMES)) {
[17:02:46.736]                   name <- removed[[kk]]
[17:02:46.736]                   NAME <- NAMES[[kk]]
[17:02:46.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.736]                     next
[17:02:46.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.736]                 }
[17:02:46.736]                 if (length(args) > 0) 
[17:02:46.736]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.736]             }
[17:02:46.736]             else {
[17:02:46.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.736]             }
[17:02:46.736]             {
[17:02:46.736]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.736]                   0L) {
[17:02:46.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.736]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.736]                   base::options(opts)
[17:02:46.736]                 }
[17:02:46.736]                 {
[17:02:46.736]                   {
[17:02:46.736]                     NULL
[17:02:46.736]                     RNGkind("Mersenne-Twister")
[17:02:46.736]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.736]                       inherits = FALSE)
[17:02:46.736]                   }
[17:02:46.736]                   options(future.plan = NULL)
[17:02:46.736]                   if (is.na(NA_character_)) 
[17:02:46.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.736]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.736]                     .init = FALSE)
[17:02:46.736]                 }
[17:02:46.736]             }
[17:02:46.736]         }
[17:02:46.736]     })
[17:02:46.736]     if (TRUE) {
[17:02:46.736]         base::sink(type = "output", split = FALSE)
[17:02:46.736]         if (TRUE) {
[17:02:46.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.736]         }
[17:02:46.736]         else {
[17:02:46.736]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.736]         }
[17:02:46.736]         base::close(...future.stdout)
[17:02:46.736]         ...future.stdout <- NULL
[17:02:46.736]     }
[17:02:46.736]     ...future.result$conditions <- ...future.conditions
[17:02:46.736]     ...future.result$finished <- base::Sys.time()
[17:02:46.736]     ...future.result
[17:02:46.736] }
[17:02:46.738] assign_globals() ...
[17:02:46.738] List of 1
[17:02:46.738]  $ x: list()
[17:02:46.738]  - attr(*, "where")=List of 1
[17:02:46.738]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.738]  - attr(*, "resolved")= logi TRUE
[17:02:46.738]  - attr(*, "total_size")= num 0
[17:02:46.738]  - attr(*, "already-done")= logi TRUE
[17:02:46.740] - copied ‘x’ to environment
[17:02:46.740] assign_globals() ... done
[17:02:46.740] plan(): Setting new future strategy stack:
[17:02:46.740] List of future strategies:
[17:02:46.740] 1. sequential:
[17:02:46.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.740]    - tweaked: FALSE
[17:02:46.740]    - call: NULL
[17:02:46.741] plan(): nbrOfWorkers() = 1
[17:02:46.741] plan(): Setting new future strategy stack:
[17:02:46.742] List of future strategies:
[17:02:46.742] 1. sequential:
[17:02:46.742]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.742]    - tweaked: FALSE
[17:02:46.742]    - call: plan(strategy)
[17:02:46.742] plan(): nbrOfWorkers() = 1
[17:02:46.742] SequentialFuture started (and completed)
[17:02:46.742] - Launch lazy future ... done
[17:02:46.742] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.743] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.743] Searching for globals...
[17:02:46.745] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:46.745] Searching for globals ... DONE
[17:02:46.745] Resolving globals: TRUE
[17:02:46.745] Resolving any globals that are futures ...
[17:02:46.745] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:46.746] Resolving any globals that are futures ... DONE
[17:02:46.746] Resolving futures part of globals (recursively) ...
[17:02:46.746] resolve() on list ...
[17:02:46.746]  recursive: 99
[17:02:46.746]  length: 1
[17:02:46.746]  elements: ‘x’
[17:02:46.747]  length: 0 (resolved future 1)
[17:02:46.747] resolve() on list ... DONE
[17:02:46.747] - globals: [1] ‘x’
[17:02:46.747] Resolving futures part of globals (recursively) ... DONE
[17:02:46.747] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.747] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.747] - globals: [1] ‘x’
[17:02:46.748] 
[17:02:46.748] getGlobalsAndPackages() ... DONE
[17:02:46.748] run() for ‘Future’ ...
[17:02:46.748] - state: ‘created’
[17:02:46.748] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.748] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.749]   - Field: ‘label’
[17:02:46.749]   - Field: ‘local’
[17:02:46.749]   - Field: ‘owner’
[17:02:46.749]   - Field: ‘envir’
[17:02:46.749]   - Field: ‘packages’
[17:02:46.749]   - Field: ‘gc’
[17:02:46.749]   - Field: ‘conditions’
[17:02:46.749]   - Field: ‘expr’
[17:02:46.749]   - Field: ‘uuid’
[17:02:46.751]   - Field: ‘seed’
[17:02:46.751]   - Field: ‘version’
[17:02:46.751]   - Field: ‘result’
[17:02:46.751]   - Field: ‘asynchronous’
[17:02:46.751]   - Field: ‘calls’
[17:02:46.751]   - Field: ‘globals’
[17:02:46.752]   - Field: ‘stdout’
[17:02:46.752]   - Field: ‘earlySignal’
[17:02:46.752]   - Field: ‘lazy’
[17:02:46.752]   - Field: ‘state’
[17:02:46.752] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.752] - Launch lazy future ...
[17:02:46.752] Packages needed by the future expression (n = 0): <none>
[17:02:46.752] Packages needed by future strategies (n = 0): <none>
[17:02:46.753] {
[17:02:46.753]     {
[17:02:46.753]         {
[17:02:46.753]             ...future.startTime <- base::Sys.time()
[17:02:46.753]             {
[17:02:46.753]                 {
[17:02:46.753]                   {
[17:02:46.753]                     base::local({
[17:02:46.753]                       has_future <- base::requireNamespace("future", 
[17:02:46.753]                         quietly = TRUE)
[17:02:46.753]                       if (has_future) {
[17:02:46.753]                         ns <- base::getNamespace("future")
[17:02:46.753]                         version <- ns[[".package"]][["version"]]
[17:02:46.753]                         if (is.null(version)) 
[17:02:46.753]                           version <- utils::packageVersion("future")
[17:02:46.753]                       }
[17:02:46.753]                       else {
[17:02:46.753]                         version <- NULL
[17:02:46.753]                       }
[17:02:46.753]                       if (!has_future || version < "1.8.0") {
[17:02:46.753]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.753]                           "", base::R.version$version.string), 
[17:02:46.753]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.753]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.753]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.753]                             "release", "version")], collapse = " "), 
[17:02:46.753]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.753]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.753]                           info)
[17:02:46.753]                         info <- base::paste(info, collapse = "; ")
[17:02:46.753]                         if (!has_future) {
[17:02:46.753]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.753]                             info)
[17:02:46.753]                         }
[17:02:46.753]                         else {
[17:02:46.753]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.753]                             info, version)
[17:02:46.753]                         }
[17:02:46.753]                         base::stop(msg)
[17:02:46.753]                       }
[17:02:46.753]                     })
[17:02:46.753]                   }
[17:02:46.753]                   ...future.strategy.old <- future::plan("list")
[17:02:46.753]                   options(future.plan = NULL)
[17:02:46.753]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.753]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.753]                 }
[17:02:46.753]                 ...future.workdir <- getwd()
[17:02:46.753]             }
[17:02:46.753]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.753]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.753]         }
[17:02:46.753]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.753]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.753]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.753]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.753]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.753]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.753]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.753]             base::names(...future.oldOptions))
[17:02:46.753]     }
[17:02:46.753]     if (FALSE) {
[17:02:46.753]     }
[17:02:46.753]     else {
[17:02:46.753]         if (TRUE) {
[17:02:46.753]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.753]                 open = "w")
[17:02:46.753]         }
[17:02:46.753]         else {
[17:02:46.753]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.753]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.753]         }
[17:02:46.753]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.753]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.753]             base::sink(type = "output", split = FALSE)
[17:02:46.753]             base::close(...future.stdout)
[17:02:46.753]         }, add = TRUE)
[17:02:46.753]     }
[17:02:46.753]     ...future.frame <- base::sys.nframe()
[17:02:46.753]     ...future.conditions <- base::list()
[17:02:46.753]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.753]     if (FALSE) {
[17:02:46.753]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.753]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.753]     }
[17:02:46.753]     ...future.result <- base::tryCatch({
[17:02:46.753]         base::withCallingHandlers({
[17:02:46.753]             ...future.value <- base::withVisible(base::local({
[17:02:46.753]                 x["a"] <- list(1)
[17:02:46.753]                 x
[17:02:46.753]             }))
[17:02:46.753]             future::FutureResult(value = ...future.value$value, 
[17:02:46.753]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.753]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.753]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.753]                     ...future.globalenv.names))
[17:02:46.753]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.753]         }, condition = base::local({
[17:02:46.753]             c <- base::c
[17:02:46.753]             inherits <- base::inherits
[17:02:46.753]             invokeRestart <- base::invokeRestart
[17:02:46.753]             length <- base::length
[17:02:46.753]             list <- base::list
[17:02:46.753]             seq.int <- base::seq.int
[17:02:46.753]             signalCondition <- base::signalCondition
[17:02:46.753]             sys.calls <- base::sys.calls
[17:02:46.753]             `[[` <- base::`[[`
[17:02:46.753]             `+` <- base::`+`
[17:02:46.753]             `<<-` <- base::`<<-`
[17:02:46.753]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.753]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.753]                   3L)]
[17:02:46.753]             }
[17:02:46.753]             function(cond) {
[17:02:46.753]                 is_error <- inherits(cond, "error")
[17:02:46.753]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.753]                   NULL)
[17:02:46.753]                 if (is_error) {
[17:02:46.753]                   sessionInformation <- function() {
[17:02:46.753]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.753]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.753]                       search = base::search(), system = base::Sys.info())
[17:02:46.753]                   }
[17:02:46.753]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.753]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.753]                     cond$call), session = sessionInformation(), 
[17:02:46.753]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.753]                   signalCondition(cond)
[17:02:46.753]                 }
[17:02:46.753]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.753]                 "immediateCondition"))) {
[17:02:46.753]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.753]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.753]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.753]                   if (TRUE && !signal) {
[17:02:46.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.753]                     {
[17:02:46.753]                       inherits <- base::inherits
[17:02:46.753]                       invokeRestart <- base::invokeRestart
[17:02:46.753]                       is.null <- base::is.null
[17:02:46.753]                       muffled <- FALSE
[17:02:46.753]                       if (inherits(cond, "message")) {
[17:02:46.753]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.753]                         if (muffled) 
[17:02:46.753]                           invokeRestart("muffleMessage")
[17:02:46.753]                       }
[17:02:46.753]                       else if (inherits(cond, "warning")) {
[17:02:46.753]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.753]                         if (muffled) 
[17:02:46.753]                           invokeRestart("muffleWarning")
[17:02:46.753]                       }
[17:02:46.753]                       else if (inherits(cond, "condition")) {
[17:02:46.753]                         if (!is.null(pattern)) {
[17:02:46.753]                           computeRestarts <- base::computeRestarts
[17:02:46.753]                           grepl <- base::grepl
[17:02:46.753]                           restarts <- computeRestarts(cond)
[17:02:46.753]                           for (restart in restarts) {
[17:02:46.753]                             name <- restart$name
[17:02:46.753]                             if (is.null(name)) 
[17:02:46.753]                               next
[17:02:46.753]                             if (!grepl(pattern, name)) 
[17:02:46.753]                               next
[17:02:46.753]                             invokeRestart(restart)
[17:02:46.753]                             muffled <- TRUE
[17:02:46.753]                             break
[17:02:46.753]                           }
[17:02:46.753]                         }
[17:02:46.753]                       }
[17:02:46.753]                       invisible(muffled)
[17:02:46.753]                     }
[17:02:46.753]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.753]                   }
[17:02:46.753]                 }
[17:02:46.753]                 else {
[17:02:46.753]                   if (TRUE) {
[17:02:46.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.753]                     {
[17:02:46.753]                       inherits <- base::inherits
[17:02:46.753]                       invokeRestart <- base::invokeRestart
[17:02:46.753]                       is.null <- base::is.null
[17:02:46.753]                       muffled <- FALSE
[17:02:46.753]                       if (inherits(cond, "message")) {
[17:02:46.753]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.753]                         if (muffled) 
[17:02:46.753]                           invokeRestart("muffleMessage")
[17:02:46.753]                       }
[17:02:46.753]                       else if (inherits(cond, "warning")) {
[17:02:46.753]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.753]                         if (muffled) 
[17:02:46.753]                           invokeRestart("muffleWarning")
[17:02:46.753]                       }
[17:02:46.753]                       else if (inherits(cond, "condition")) {
[17:02:46.753]                         if (!is.null(pattern)) {
[17:02:46.753]                           computeRestarts <- base::computeRestarts
[17:02:46.753]                           grepl <- base::grepl
[17:02:46.753]                           restarts <- computeRestarts(cond)
[17:02:46.753]                           for (restart in restarts) {
[17:02:46.753]                             name <- restart$name
[17:02:46.753]                             if (is.null(name)) 
[17:02:46.753]                               next
[17:02:46.753]                             if (!grepl(pattern, name)) 
[17:02:46.753]                               next
[17:02:46.753]                             invokeRestart(restart)
[17:02:46.753]                             muffled <- TRUE
[17:02:46.753]                             break
[17:02:46.753]                           }
[17:02:46.753]                         }
[17:02:46.753]                       }
[17:02:46.753]                       invisible(muffled)
[17:02:46.753]                     }
[17:02:46.753]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.753]                   }
[17:02:46.753]                 }
[17:02:46.753]             }
[17:02:46.753]         }))
[17:02:46.753]     }, error = function(ex) {
[17:02:46.753]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.753]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.753]                 ...future.rng), started = ...future.startTime, 
[17:02:46.753]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.753]             version = "1.8"), class = "FutureResult")
[17:02:46.753]     }, finally = {
[17:02:46.753]         if (!identical(...future.workdir, getwd())) 
[17:02:46.753]             setwd(...future.workdir)
[17:02:46.753]         {
[17:02:46.753]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.753]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.753]             }
[17:02:46.753]             base::options(...future.oldOptions)
[17:02:46.753]             if (.Platform$OS.type == "windows") {
[17:02:46.753]                 old_names <- names(...future.oldEnvVars)
[17:02:46.753]                 envs <- base::Sys.getenv()
[17:02:46.753]                 names <- names(envs)
[17:02:46.753]                 common <- intersect(names, old_names)
[17:02:46.753]                 added <- setdiff(names, old_names)
[17:02:46.753]                 removed <- setdiff(old_names, names)
[17:02:46.753]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.753]                   envs[common]]
[17:02:46.753]                 NAMES <- toupper(changed)
[17:02:46.753]                 args <- list()
[17:02:46.753]                 for (kk in seq_along(NAMES)) {
[17:02:46.753]                   name <- changed[[kk]]
[17:02:46.753]                   NAME <- NAMES[[kk]]
[17:02:46.753]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.753]                     next
[17:02:46.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.753]                 }
[17:02:46.753]                 NAMES <- toupper(added)
[17:02:46.753]                 for (kk in seq_along(NAMES)) {
[17:02:46.753]                   name <- added[[kk]]
[17:02:46.753]                   NAME <- NAMES[[kk]]
[17:02:46.753]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.753]                     next
[17:02:46.753]                   args[[name]] <- ""
[17:02:46.753]                 }
[17:02:46.753]                 NAMES <- toupper(removed)
[17:02:46.753]                 for (kk in seq_along(NAMES)) {
[17:02:46.753]                   name <- removed[[kk]]
[17:02:46.753]                   NAME <- NAMES[[kk]]
[17:02:46.753]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.753]                     next
[17:02:46.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.753]                 }
[17:02:46.753]                 if (length(args) > 0) 
[17:02:46.753]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.753]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.753]             }
[17:02:46.753]             else {
[17:02:46.753]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.753]             }
[17:02:46.753]             {
[17:02:46.753]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.753]                   0L) {
[17:02:46.753]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.753]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.753]                   base::options(opts)
[17:02:46.753]                 }
[17:02:46.753]                 {
[17:02:46.753]                   {
[17:02:46.753]                     NULL
[17:02:46.753]                     RNGkind("Mersenne-Twister")
[17:02:46.753]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.753]                       inherits = FALSE)
[17:02:46.753]                   }
[17:02:46.753]                   options(future.plan = NULL)
[17:02:46.753]                   if (is.na(NA_character_)) 
[17:02:46.753]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.753]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.753]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.753]                     .init = FALSE)
[17:02:46.753]                 }
[17:02:46.753]             }
[17:02:46.753]         }
[17:02:46.753]     })
[17:02:46.753]     if (TRUE) {
[17:02:46.753]         base::sink(type = "output", split = FALSE)
[17:02:46.753]         if (TRUE) {
[17:02:46.753]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.753]         }
[17:02:46.753]         else {
[17:02:46.753]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.753]         }
[17:02:46.753]         base::close(...future.stdout)
[17:02:46.753]         ...future.stdout <- NULL
[17:02:46.753]     }
[17:02:46.753]     ...future.result$conditions <- ...future.conditions
[17:02:46.753]     ...future.result$finished <- base::Sys.time()
[17:02:46.753]     ...future.result
[17:02:46.753] }
[17:02:46.754] assign_globals() ...
[17:02:46.754] List of 1
[17:02:46.754]  $ x: list()
[17:02:46.754]  - attr(*, "where")=List of 1
[17:02:46.754]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.754]  - attr(*, "resolved")= logi TRUE
[17:02:46.754]  - attr(*, "total_size")= num 0
[17:02:46.754]  - attr(*, "already-done")= logi TRUE
[17:02:46.757] - copied ‘x’ to environment
[17:02:46.757] assign_globals() ... done
[17:02:46.757] plan(): Setting new future strategy stack:
[17:02:46.757] List of future strategies:
[17:02:46.757] 1. sequential:
[17:02:46.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.757]    - tweaked: FALSE
[17:02:46.757]    - call: NULL
[17:02:46.758] plan(): nbrOfWorkers() = 1
[17:02:46.758] plan(): Setting new future strategy stack:
[17:02:46.758] List of future strategies:
[17:02:46.758] 1. sequential:
[17:02:46.758]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.758]    - tweaked: FALSE
[17:02:46.758]    - call: plan(strategy)
[17:02:46.759] plan(): nbrOfWorkers() = 1
[17:02:46.759] SequentialFuture started (and completed)
[17:02:46.759] - Launch lazy future ... done
[17:02:46.759] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.760] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.760] Searching for globals...
[17:02:46.762] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:46.762] Searching for globals ... DONE
[17:02:46.762] Resolving globals: TRUE
[17:02:46.762] Resolving any globals that are futures ...
[17:02:46.762] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:46.762] Resolving any globals that are futures ... DONE
[17:02:46.763] Resolving futures part of globals (recursively) ...
[17:02:46.763] resolve() on list ...
[17:02:46.763]  recursive: 99
[17:02:46.763]  length: 1
[17:02:46.763]  elements: ‘x’
[17:02:46.763]  length: 0 (resolved future 1)
[17:02:46.764] resolve() on list ... DONE
[17:02:46.764] - globals: [1] ‘x’
[17:02:46.764] Resolving futures part of globals (recursively) ... DONE
[17:02:46.764] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.764] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.764] - globals: [1] ‘x’
[17:02:46.764] 
[17:02:46.765] getGlobalsAndPackages() ... DONE
[17:02:46.765] run() for ‘Future’ ...
[17:02:46.765] - state: ‘created’
[17:02:46.765] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.765] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.765]   - Field: ‘label’
[17:02:46.766]   - Field: ‘local’
[17:02:46.766]   - Field: ‘owner’
[17:02:46.766]   - Field: ‘envir’
[17:02:46.766]   - Field: ‘packages’
[17:02:46.766]   - Field: ‘gc’
[17:02:46.766]   - Field: ‘conditions’
[17:02:46.766]   - Field: ‘expr’
[17:02:46.766]   - Field: ‘uuid’
[17:02:46.766]   - Field: ‘seed’
[17:02:46.766]   - Field: ‘version’
[17:02:46.766]   - Field: ‘result’
[17:02:46.767]   - Field: ‘asynchronous’
[17:02:46.767]   - Field: ‘calls’
[17:02:46.767]   - Field: ‘globals’
[17:02:46.767]   - Field: ‘stdout’
[17:02:46.767]   - Field: ‘earlySignal’
[17:02:46.767]   - Field: ‘lazy’
[17:02:46.767]   - Field: ‘state’
[17:02:46.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.767] - Launch lazy future ...
[17:02:46.767] Packages needed by the future expression (n = 0): <none>
[17:02:46.768] Packages needed by future strategies (n = 0): <none>
[17:02:46.768] {
[17:02:46.768]     {
[17:02:46.768]         {
[17:02:46.768]             ...future.startTime <- base::Sys.time()
[17:02:46.768]             {
[17:02:46.768]                 {
[17:02:46.768]                   {
[17:02:46.768]                     base::local({
[17:02:46.768]                       has_future <- base::requireNamespace("future", 
[17:02:46.768]                         quietly = TRUE)
[17:02:46.768]                       if (has_future) {
[17:02:46.768]                         ns <- base::getNamespace("future")
[17:02:46.768]                         version <- ns[[".package"]][["version"]]
[17:02:46.768]                         if (is.null(version)) 
[17:02:46.768]                           version <- utils::packageVersion("future")
[17:02:46.768]                       }
[17:02:46.768]                       else {
[17:02:46.768]                         version <- NULL
[17:02:46.768]                       }
[17:02:46.768]                       if (!has_future || version < "1.8.0") {
[17:02:46.768]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.768]                           "", base::R.version$version.string), 
[17:02:46.768]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.768]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.768]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.768]                             "release", "version")], collapse = " "), 
[17:02:46.768]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.768]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.768]                           info)
[17:02:46.768]                         info <- base::paste(info, collapse = "; ")
[17:02:46.768]                         if (!has_future) {
[17:02:46.768]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.768]                             info)
[17:02:46.768]                         }
[17:02:46.768]                         else {
[17:02:46.768]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.768]                             info, version)
[17:02:46.768]                         }
[17:02:46.768]                         base::stop(msg)
[17:02:46.768]                       }
[17:02:46.768]                     })
[17:02:46.768]                   }
[17:02:46.768]                   ...future.strategy.old <- future::plan("list")
[17:02:46.768]                   options(future.plan = NULL)
[17:02:46.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.768]                 }
[17:02:46.768]                 ...future.workdir <- getwd()
[17:02:46.768]             }
[17:02:46.768]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.768]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.768]         }
[17:02:46.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.768]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.768]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.768]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.768]             base::names(...future.oldOptions))
[17:02:46.768]     }
[17:02:46.768]     if (FALSE) {
[17:02:46.768]     }
[17:02:46.768]     else {
[17:02:46.768]         if (TRUE) {
[17:02:46.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.768]                 open = "w")
[17:02:46.768]         }
[17:02:46.768]         else {
[17:02:46.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.768]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.768]         }
[17:02:46.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.768]             base::sink(type = "output", split = FALSE)
[17:02:46.768]             base::close(...future.stdout)
[17:02:46.768]         }, add = TRUE)
[17:02:46.768]     }
[17:02:46.768]     ...future.frame <- base::sys.nframe()
[17:02:46.768]     ...future.conditions <- base::list()
[17:02:46.768]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.768]     if (FALSE) {
[17:02:46.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.768]     }
[17:02:46.768]     ...future.result <- base::tryCatch({
[17:02:46.768]         base::withCallingHandlers({
[17:02:46.768]             ...future.value <- base::withVisible(base::local({
[17:02:46.768]                 x["a"] <- list(1)
[17:02:46.768]                 x
[17:02:46.768]             }))
[17:02:46.768]             future::FutureResult(value = ...future.value$value, 
[17:02:46.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.768]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.768]                     ...future.globalenv.names))
[17:02:46.768]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.768]         }, condition = base::local({
[17:02:46.768]             c <- base::c
[17:02:46.768]             inherits <- base::inherits
[17:02:46.768]             invokeRestart <- base::invokeRestart
[17:02:46.768]             length <- base::length
[17:02:46.768]             list <- base::list
[17:02:46.768]             seq.int <- base::seq.int
[17:02:46.768]             signalCondition <- base::signalCondition
[17:02:46.768]             sys.calls <- base::sys.calls
[17:02:46.768]             `[[` <- base::`[[`
[17:02:46.768]             `+` <- base::`+`
[17:02:46.768]             `<<-` <- base::`<<-`
[17:02:46.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.768]                   3L)]
[17:02:46.768]             }
[17:02:46.768]             function(cond) {
[17:02:46.768]                 is_error <- inherits(cond, "error")
[17:02:46.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.768]                   NULL)
[17:02:46.768]                 if (is_error) {
[17:02:46.768]                   sessionInformation <- function() {
[17:02:46.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.768]                       search = base::search(), system = base::Sys.info())
[17:02:46.768]                   }
[17:02:46.768]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.768]                     cond$call), session = sessionInformation(), 
[17:02:46.768]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.768]                   signalCondition(cond)
[17:02:46.768]                 }
[17:02:46.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.768]                 "immediateCondition"))) {
[17:02:46.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.768]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.768]                   if (TRUE && !signal) {
[17:02:46.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.768]                     {
[17:02:46.768]                       inherits <- base::inherits
[17:02:46.768]                       invokeRestart <- base::invokeRestart
[17:02:46.768]                       is.null <- base::is.null
[17:02:46.768]                       muffled <- FALSE
[17:02:46.768]                       if (inherits(cond, "message")) {
[17:02:46.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.768]                         if (muffled) 
[17:02:46.768]                           invokeRestart("muffleMessage")
[17:02:46.768]                       }
[17:02:46.768]                       else if (inherits(cond, "warning")) {
[17:02:46.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.768]                         if (muffled) 
[17:02:46.768]                           invokeRestart("muffleWarning")
[17:02:46.768]                       }
[17:02:46.768]                       else if (inherits(cond, "condition")) {
[17:02:46.768]                         if (!is.null(pattern)) {
[17:02:46.768]                           computeRestarts <- base::computeRestarts
[17:02:46.768]                           grepl <- base::grepl
[17:02:46.768]                           restarts <- computeRestarts(cond)
[17:02:46.768]                           for (restart in restarts) {
[17:02:46.768]                             name <- restart$name
[17:02:46.768]                             if (is.null(name)) 
[17:02:46.768]                               next
[17:02:46.768]                             if (!grepl(pattern, name)) 
[17:02:46.768]                               next
[17:02:46.768]                             invokeRestart(restart)
[17:02:46.768]                             muffled <- TRUE
[17:02:46.768]                             break
[17:02:46.768]                           }
[17:02:46.768]                         }
[17:02:46.768]                       }
[17:02:46.768]                       invisible(muffled)
[17:02:46.768]                     }
[17:02:46.768]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.768]                   }
[17:02:46.768]                 }
[17:02:46.768]                 else {
[17:02:46.768]                   if (TRUE) {
[17:02:46.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.768]                     {
[17:02:46.768]                       inherits <- base::inherits
[17:02:46.768]                       invokeRestart <- base::invokeRestart
[17:02:46.768]                       is.null <- base::is.null
[17:02:46.768]                       muffled <- FALSE
[17:02:46.768]                       if (inherits(cond, "message")) {
[17:02:46.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.768]                         if (muffled) 
[17:02:46.768]                           invokeRestart("muffleMessage")
[17:02:46.768]                       }
[17:02:46.768]                       else if (inherits(cond, "warning")) {
[17:02:46.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.768]                         if (muffled) 
[17:02:46.768]                           invokeRestart("muffleWarning")
[17:02:46.768]                       }
[17:02:46.768]                       else if (inherits(cond, "condition")) {
[17:02:46.768]                         if (!is.null(pattern)) {
[17:02:46.768]                           computeRestarts <- base::computeRestarts
[17:02:46.768]                           grepl <- base::grepl
[17:02:46.768]                           restarts <- computeRestarts(cond)
[17:02:46.768]                           for (restart in restarts) {
[17:02:46.768]                             name <- restart$name
[17:02:46.768]                             if (is.null(name)) 
[17:02:46.768]                               next
[17:02:46.768]                             if (!grepl(pattern, name)) 
[17:02:46.768]                               next
[17:02:46.768]                             invokeRestart(restart)
[17:02:46.768]                             muffled <- TRUE
[17:02:46.768]                             break
[17:02:46.768]                           }
[17:02:46.768]                         }
[17:02:46.768]                       }
[17:02:46.768]                       invisible(muffled)
[17:02:46.768]                     }
[17:02:46.768]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.768]                   }
[17:02:46.768]                 }
[17:02:46.768]             }
[17:02:46.768]         }))
[17:02:46.768]     }, error = function(ex) {
[17:02:46.768]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.768]                 ...future.rng), started = ...future.startTime, 
[17:02:46.768]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.768]             version = "1.8"), class = "FutureResult")
[17:02:46.768]     }, finally = {
[17:02:46.768]         if (!identical(...future.workdir, getwd())) 
[17:02:46.768]             setwd(...future.workdir)
[17:02:46.768]         {
[17:02:46.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.768]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.768]             }
[17:02:46.768]             base::options(...future.oldOptions)
[17:02:46.768]             if (.Platform$OS.type == "windows") {
[17:02:46.768]                 old_names <- names(...future.oldEnvVars)
[17:02:46.768]                 envs <- base::Sys.getenv()
[17:02:46.768]                 names <- names(envs)
[17:02:46.768]                 common <- intersect(names, old_names)
[17:02:46.768]                 added <- setdiff(names, old_names)
[17:02:46.768]                 removed <- setdiff(old_names, names)
[17:02:46.768]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.768]                   envs[common]]
[17:02:46.768]                 NAMES <- toupper(changed)
[17:02:46.768]                 args <- list()
[17:02:46.768]                 for (kk in seq_along(NAMES)) {
[17:02:46.768]                   name <- changed[[kk]]
[17:02:46.768]                   NAME <- NAMES[[kk]]
[17:02:46.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.768]                     next
[17:02:46.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.768]                 }
[17:02:46.768]                 NAMES <- toupper(added)
[17:02:46.768]                 for (kk in seq_along(NAMES)) {
[17:02:46.768]                   name <- added[[kk]]
[17:02:46.768]                   NAME <- NAMES[[kk]]
[17:02:46.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.768]                     next
[17:02:46.768]                   args[[name]] <- ""
[17:02:46.768]                 }
[17:02:46.768]                 NAMES <- toupper(removed)
[17:02:46.768]                 for (kk in seq_along(NAMES)) {
[17:02:46.768]                   name <- removed[[kk]]
[17:02:46.768]                   NAME <- NAMES[[kk]]
[17:02:46.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.768]                     next
[17:02:46.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.768]                 }
[17:02:46.768]                 if (length(args) > 0) 
[17:02:46.768]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.768]             }
[17:02:46.768]             else {
[17:02:46.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.768]             }
[17:02:46.768]             {
[17:02:46.768]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.768]                   0L) {
[17:02:46.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.768]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.768]                   base::options(opts)
[17:02:46.768]                 }
[17:02:46.768]                 {
[17:02:46.768]                   {
[17:02:46.768]                     NULL
[17:02:46.768]                     RNGkind("Mersenne-Twister")
[17:02:46.768]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.768]                       inherits = FALSE)
[17:02:46.768]                   }
[17:02:46.768]                   options(future.plan = NULL)
[17:02:46.768]                   if (is.na(NA_character_)) 
[17:02:46.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.768]                     .init = FALSE)
[17:02:46.768]                 }
[17:02:46.768]             }
[17:02:46.768]         }
[17:02:46.768]     })
[17:02:46.768]     if (TRUE) {
[17:02:46.768]         base::sink(type = "output", split = FALSE)
[17:02:46.768]         if (TRUE) {
[17:02:46.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.768]         }
[17:02:46.768]         else {
[17:02:46.768]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.768]         }
[17:02:46.768]         base::close(...future.stdout)
[17:02:46.768]         ...future.stdout <- NULL
[17:02:46.768]     }
[17:02:46.768]     ...future.result$conditions <- ...future.conditions
[17:02:46.768]     ...future.result$finished <- base::Sys.time()
[17:02:46.768]     ...future.result
[17:02:46.768] }
[17:02:46.770] assign_globals() ...
[17:02:46.770] List of 1
[17:02:46.770]  $ x: list()
[17:02:46.770]  - attr(*, "where")=List of 1
[17:02:46.770]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.770]  - attr(*, "resolved")= logi TRUE
[17:02:46.770]  - attr(*, "total_size")= num 0
[17:02:46.770]  - attr(*, "already-done")= logi TRUE
[17:02:46.772] - copied ‘x’ to environment
[17:02:46.772] assign_globals() ... done
[17:02:46.772] plan(): Setting new future strategy stack:
[17:02:46.772] List of future strategies:
[17:02:46.772] 1. sequential:
[17:02:46.772]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.772]    - tweaked: FALSE
[17:02:46.772]    - call: NULL
[17:02:46.773] plan(): nbrOfWorkers() = 1
[17:02:46.774] plan(): Setting new future strategy stack:
[17:02:46.774] List of future strategies:
[17:02:46.774] 1. sequential:
[17:02:46.774]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.774]    - tweaked: FALSE
[17:02:46.774]    - call: plan(strategy)
[17:02:46.774] plan(): nbrOfWorkers() = 1
[17:02:46.774] SequentialFuture started (and completed)
[17:02:46.774] - Launch lazy future ... done
[17:02:46.774] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.775] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.775] Searching for globals...
[17:02:46.777] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:46.777] Searching for globals ... DONE
[17:02:46.777] Resolving globals: TRUE
[17:02:46.777] Resolving any globals that are futures ...
[17:02:46.778] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:46.778] Resolving any globals that are futures ... DONE
[17:02:46.778] Resolving futures part of globals (recursively) ...
[17:02:46.780] resolve() on list ...
[17:02:46.780]  recursive: 99
[17:02:46.780]  length: 1
[17:02:46.780]  elements: ‘x’
[17:02:46.780]  length: 0 (resolved future 1)
[17:02:46.780] resolve() on list ... DONE
[17:02:46.781] - globals: [1] ‘x’
[17:02:46.781] Resolving futures part of globals (recursively) ... DONE
[17:02:46.781] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.781] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.781] - globals: [1] ‘x’
[17:02:46.781] 
[17:02:46.781] getGlobalsAndPackages() ... DONE
[17:02:46.782] run() for ‘Future’ ...
[17:02:46.782] - state: ‘created’
[17:02:46.782] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.782] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.782] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.782]   - Field: ‘label’
[17:02:46.782]   - Field: ‘local’
[17:02:46.783]   - Field: ‘owner’
[17:02:46.783]   - Field: ‘envir’
[17:02:46.783]   - Field: ‘packages’
[17:02:46.783]   - Field: ‘gc’
[17:02:46.783]   - Field: ‘conditions’
[17:02:46.783]   - Field: ‘expr’
[17:02:46.783]   - Field: ‘uuid’
[17:02:46.783]   - Field: ‘seed’
[17:02:46.783]   - Field: ‘version’
[17:02:46.783]   - Field: ‘result’
[17:02:46.784]   - Field: ‘asynchronous’
[17:02:46.784]   - Field: ‘calls’
[17:02:46.784]   - Field: ‘globals’
[17:02:46.784]   - Field: ‘stdout’
[17:02:46.784]   - Field: ‘earlySignal’
[17:02:46.784]   - Field: ‘lazy’
[17:02:46.784]   - Field: ‘state’
[17:02:46.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.784] - Launch lazy future ...
[17:02:46.784] Packages needed by the future expression (n = 0): <none>
[17:02:46.785] Packages needed by future strategies (n = 0): <none>
[17:02:46.785] {
[17:02:46.785]     {
[17:02:46.785]         {
[17:02:46.785]             ...future.startTime <- base::Sys.time()
[17:02:46.785]             {
[17:02:46.785]                 {
[17:02:46.785]                   {
[17:02:46.785]                     base::local({
[17:02:46.785]                       has_future <- base::requireNamespace("future", 
[17:02:46.785]                         quietly = TRUE)
[17:02:46.785]                       if (has_future) {
[17:02:46.785]                         ns <- base::getNamespace("future")
[17:02:46.785]                         version <- ns[[".package"]][["version"]]
[17:02:46.785]                         if (is.null(version)) 
[17:02:46.785]                           version <- utils::packageVersion("future")
[17:02:46.785]                       }
[17:02:46.785]                       else {
[17:02:46.785]                         version <- NULL
[17:02:46.785]                       }
[17:02:46.785]                       if (!has_future || version < "1.8.0") {
[17:02:46.785]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.785]                           "", base::R.version$version.string), 
[17:02:46.785]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.785]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.785]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.785]                             "release", "version")], collapse = " "), 
[17:02:46.785]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.785]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.785]                           info)
[17:02:46.785]                         info <- base::paste(info, collapse = "; ")
[17:02:46.785]                         if (!has_future) {
[17:02:46.785]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.785]                             info)
[17:02:46.785]                         }
[17:02:46.785]                         else {
[17:02:46.785]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.785]                             info, version)
[17:02:46.785]                         }
[17:02:46.785]                         base::stop(msg)
[17:02:46.785]                       }
[17:02:46.785]                     })
[17:02:46.785]                   }
[17:02:46.785]                   ...future.strategy.old <- future::plan("list")
[17:02:46.785]                   options(future.plan = NULL)
[17:02:46.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.785]                 }
[17:02:46.785]                 ...future.workdir <- getwd()
[17:02:46.785]             }
[17:02:46.785]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.785]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.785]         }
[17:02:46.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.785]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.785]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.785]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.785]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.785]             base::names(...future.oldOptions))
[17:02:46.785]     }
[17:02:46.785]     if (FALSE) {
[17:02:46.785]     }
[17:02:46.785]     else {
[17:02:46.785]         if (TRUE) {
[17:02:46.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.785]                 open = "w")
[17:02:46.785]         }
[17:02:46.785]         else {
[17:02:46.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.785]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.785]         }
[17:02:46.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.785]             base::sink(type = "output", split = FALSE)
[17:02:46.785]             base::close(...future.stdout)
[17:02:46.785]         }, add = TRUE)
[17:02:46.785]     }
[17:02:46.785]     ...future.frame <- base::sys.nframe()
[17:02:46.785]     ...future.conditions <- base::list()
[17:02:46.785]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.785]     if (FALSE) {
[17:02:46.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.785]     }
[17:02:46.785]     ...future.result <- base::tryCatch({
[17:02:46.785]         base::withCallingHandlers({
[17:02:46.785]             ...future.value <- base::withVisible(base::local({
[17:02:46.785]                 x["a"] <- list(1)
[17:02:46.785]                 x
[17:02:46.785]             }))
[17:02:46.785]             future::FutureResult(value = ...future.value$value, 
[17:02:46.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.785]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.785]                     ...future.globalenv.names))
[17:02:46.785]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.785]         }, condition = base::local({
[17:02:46.785]             c <- base::c
[17:02:46.785]             inherits <- base::inherits
[17:02:46.785]             invokeRestart <- base::invokeRestart
[17:02:46.785]             length <- base::length
[17:02:46.785]             list <- base::list
[17:02:46.785]             seq.int <- base::seq.int
[17:02:46.785]             signalCondition <- base::signalCondition
[17:02:46.785]             sys.calls <- base::sys.calls
[17:02:46.785]             `[[` <- base::`[[`
[17:02:46.785]             `+` <- base::`+`
[17:02:46.785]             `<<-` <- base::`<<-`
[17:02:46.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.785]                   3L)]
[17:02:46.785]             }
[17:02:46.785]             function(cond) {
[17:02:46.785]                 is_error <- inherits(cond, "error")
[17:02:46.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.785]                   NULL)
[17:02:46.785]                 if (is_error) {
[17:02:46.785]                   sessionInformation <- function() {
[17:02:46.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.785]                       search = base::search(), system = base::Sys.info())
[17:02:46.785]                   }
[17:02:46.785]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.785]                     cond$call), session = sessionInformation(), 
[17:02:46.785]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.785]                   signalCondition(cond)
[17:02:46.785]                 }
[17:02:46.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.785]                 "immediateCondition"))) {
[17:02:46.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.785]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.785]                   if (TRUE && !signal) {
[17:02:46.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.785]                     {
[17:02:46.785]                       inherits <- base::inherits
[17:02:46.785]                       invokeRestart <- base::invokeRestart
[17:02:46.785]                       is.null <- base::is.null
[17:02:46.785]                       muffled <- FALSE
[17:02:46.785]                       if (inherits(cond, "message")) {
[17:02:46.785]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.785]                         if (muffled) 
[17:02:46.785]                           invokeRestart("muffleMessage")
[17:02:46.785]                       }
[17:02:46.785]                       else if (inherits(cond, "warning")) {
[17:02:46.785]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.785]                         if (muffled) 
[17:02:46.785]                           invokeRestart("muffleWarning")
[17:02:46.785]                       }
[17:02:46.785]                       else if (inherits(cond, "condition")) {
[17:02:46.785]                         if (!is.null(pattern)) {
[17:02:46.785]                           computeRestarts <- base::computeRestarts
[17:02:46.785]                           grepl <- base::grepl
[17:02:46.785]                           restarts <- computeRestarts(cond)
[17:02:46.785]                           for (restart in restarts) {
[17:02:46.785]                             name <- restart$name
[17:02:46.785]                             if (is.null(name)) 
[17:02:46.785]                               next
[17:02:46.785]                             if (!grepl(pattern, name)) 
[17:02:46.785]                               next
[17:02:46.785]                             invokeRestart(restart)
[17:02:46.785]                             muffled <- TRUE
[17:02:46.785]                             break
[17:02:46.785]                           }
[17:02:46.785]                         }
[17:02:46.785]                       }
[17:02:46.785]                       invisible(muffled)
[17:02:46.785]                     }
[17:02:46.785]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.785]                   }
[17:02:46.785]                 }
[17:02:46.785]                 else {
[17:02:46.785]                   if (TRUE) {
[17:02:46.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.785]                     {
[17:02:46.785]                       inherits <- base::inherits
[17:02:46.785]                       invokeRestart <- base::invokeRestart
[17:02:46.785]                       is.null <- base::is.null
[17:02:46.785]                       muffled <- FALSE
[17:02:46.785]                       if (inherits(cond, "message")) {
[17:02:46.785]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.785]                         if (muffled) 
[17:02:46.785]                           invokeRestart("muffleMessage")
[17:02:46.785]                       }
[17:02:46.785]                       else if (inherits(cond, "warning")) {
[17:02:46.785]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.785]                         if (muffled) 
[17:02:46.785]                           invokeRestart("muffleWarning")
[17:02:46.785]                       }
[17:02:46.785]                       else if (inherits(cond, "condition")) {
[17:02:46.785]                         if (!is.null(pattern)) {
[17:02:46.785]                           computeRestarts <- base::computeRestarts
[17:02:46.785]                           grepl <- base::grepl
[17:02:46.785]                           restarts <- computeRestarts(cond)
[17:02:46.785]                           for (restart in restarts) {
[17:02:46.785]                             name <- restart$name
[17:02:46.785]                             if (is.null(name)) 
[17:02:46.785]                               next
[17:02:46.785]                             if (!grepl(pattern, name)) 
[17:02:46.785]                               next
[17:02:46.785]                             invokeRestart(restart)
[17:02:46.785]                             muffled <- TRUE
[17:02:46.785]                             break
[17:02:46.785]                           }
[17:02:46.785]                         }
[17:02:46.785]                       }
[17:02:46.785]                       invisible(muffled)
[17:02:46.785]                     }
[17:02:46.785]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.785]                   }
[17:02:46.785]                 }
[17:02:46.785]             }
[17:02:46.785]         }))
[17:02:46.785]     }, error = function(ex) {
[17:02:46.785]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.785]                 ...future.rng), started = ...future.startTime, 
[17:02:46.785]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.785]             version = "1.8"), class = "FutureResult")
[17:02:46.785]     }, finally = {
[17:02:46.785]         if (!identical(...future.workdir, getwd())) 
[17:02:46.785]             setwd(...future.workdir)
[17:02:46.785]         {
[17:02:46.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.785]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.785]             }
[17:02:46.785]             base::options(...future.oldOptions)
[17:02:46.785]             if (.Platform$OS.type == "windows") {
[17:02:46.785]                 old_names <- names(...future.oldEnvVars)
[17:02:46.785]                 envs <- base::Sys.getenv()
[17:02:46.785]                 names <- names(envs)
[17:02:46.785]                 common <- intersect(names, old_names)
[17:02:46.785]                 added <- setdiff(names, old_names)
[17:02:46.785]                 removed <- setdiff(old_names, names)
[17:02:46.785]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.785]                   envs[common]]
[17:02:46.785]                 NAMES <- toupper(changed)
[17:02:46.785]                 args <- list()
[17:02:46.785]                 for (kk in seq_along(NAMES)) {
[17:02:46.785]                   name <- changed[[kk]]
[17:02:46.785]                   NAME <- NAMES[[kk]]
[17:02:46.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.785]                     next
[17:02:46.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.785]                 }
[17:02:46.785]                 NAMES <- toupper(added)
[17:02:46.785]                 for (kk in seq_along(NAMES)) {
[17:02:46.785]                   name <- added[[kk]]
[17:02:46.785]                   NAME <- NAMES[[kk]]
[17:02:46.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.785]                     next
[17:02:46.785]                   args[[name]] <- ""
[17:02:46.785]                 }
[17:02:46.785]                 NAMES <- toupper(removed)
[17:02:46.785]                 for (kk in seq_along(NAMES)) {
[17:02:46.785]                   name <- removed[[kk]]
[17:02:46.785]                   NAME <- NAMES[[kk]]
[17:02:46.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.785]                     next
[17:02:46.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.785]                 }
[17:02:46.785]                 if (length(args) > 0) 
[17:02:46.785]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.785]             }
[17:02:46.785]             else {
[17:02:46.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.785]             }
[17:02:46.785]             {
[17:02:46.785]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.785]                   0L) {
[17:02:46.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.785]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.785]                   base::options(opts)
[17:02:46.785]                 }
[17:02:46.785]                 {
[17:02:46.785]                   {
[17:02:46.785]                     NULL
[17:02:46.785]                     RNGkind("Mersenne-Twister")
[17:02:46.785]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.785]                       inherits = FALSE)
[17:02:46.785]                   }
[17:02:46.785]                   options(future.plan = NULL)
[17:02:46.785]                   if (is.na(NA_character_)) 
[17:02:46.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.785]                     .init = FALSE)
[17:02:46.785]                 }
[17:02:46.785]             }
[17:02:46.785]         }
[17:02:46.785]     })
[17:02:46.785]     if (TRUE) {
[17:02:46.785]         base::sink(type = "output", split = FALSE)
[17:02:46.785]         if (TRUE) {
[17:02:46.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.785]         }
[17:02:46.785]         else {
[17:02:46.785]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.785]         }
[17:02:46.785]         base::close(...future.stdout)
[17:02:46.785]         ...future.stdout <- NULL
[17:02:46.785]     }
[17:02:46.785]     ...future.result$conditions <- ...future.conditions
[17:02:46.785]     ...future.result$finished <- base::Sys.time()
[17:02:46.785]     ...future.result
[17:02:46.785] }
[17:02:46.786] assign_globals() ...
[17:02:46.787] List of 1
[17:02:46.787]  $ x: list()
[17:02:46.787]  - attr(*, "where")=List of 1
[17:02:46.787]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.787]  - attr(*, "resolved")= logi TRUE
[17:02:46.787]  - attr(*, "total_size")= num 0
[17:02:46.787]  - attr(*, "already-done")= logi TRUE
[17:02:46.789] - copied ‘x’ to environment
[17:02:46.789] assign_globals() ... done
[17:02:46.789] plan(): Setting new future strategy stack:
[17:02:46.789] List of future strategies:
[17:02:46.789] 1. sequential:
[17:02:46.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.789]    - tweaked: FALSE
[17:02:46.789]    - call: NULL
[17:02:46.790] plan(): nbrOfWorkers() = 1
[17:02:46.790] plan(): Setting new future strategy stack:
[17:02:46.791] List of future strategies:
[17:02:46.791] 1. sequential:
[17:02:46.791]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.791]    - tweaked: FALSE
[17:02:46.791]    - call: plan(strategy)
[17:02:46.791] plan(): nbrOfWorkers() = 1
[17:02:46.791] SequentialFuture started (and completed)
[17:02:46.791] - Launch lazy future ... done
[17:02:46.791] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.792] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.792] Searching for globals...
[17:02:46.794] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:02:46.794] Searching for globals ... DONE
[17:02:46.794] Resolving globals: TRUE
[17:02:46.795] Resolving any globals that are futures ...
[17:02:46.795] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:02:46.795] Resolving any globals that are futures ... DONE
[17:02:46.795] Resolving futures part of globals (recursively) ...
[17:02:46.795] resolve() on list ...
[17:02:46.795]  recursive: 99
[17:02:46.796]  length: 2
[17:02:46.796]  elements: ‘x’, ‘name’
[17:02:46.796]  length: 1 (resolved future 1)
[17:02:46.796]  length: 0 (resolved future 2)
[17:02:46.796] resolve() on list ... DONE
[17:02:46.796] - globals: [2] ‘x’, ‘name’
[17:02:46.796] Resolving futures part of globals (recursively) ... DONE
[17:02:46.796] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:46.797] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:02:46.797] - globals: [2] ‘x’, ‘name’
[17:02:46.797] 
[17:02:46.797] getGlobalsAndPackages() ... DONE
[17:02:46.797] run() for ‘Future’ ...
[17:02:46.797] - state: ‘created’
[17:02:46.797] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:02:46.798] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:02:46.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:02:46.798]   - Field: ‘label’
[17:02:46.798]   - Field: ‘local’
[17:02:46.798]   - Field: ‘owner’
[17:02:46.798]   - Field: ‘envir’
[17:02:46.798]   - Field: ‘packages’
[17:02:46.798]   - Field: ‘gc’
[17:02:46.798]   - Field: ‘conditions’
[17:02:46.799]   - Field: ‘expr’
[17:02:46.799]   - Field: ‘uuid’
[17:02:46.799]   - Field: ‘seed’
[17:02:46.799]   - Field: ‘version’
[17:02:46.799]   - Field: ‘result’
[17:02:46.799]   - Field: ‘asynchronous’
[17:02:46.799]   - Field: ‘calls’
[17:02:46.799]   - Field: ‘globals’
[17:02:46.799]   - Field: ‘stdout’
[17:02:46.799]   - Field: ‘earlySignal’
[17:02:46.799]   - Field: ‘lazy’
[17:02:46.800]   - Field: ‘state’
[17:02:46.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:02:46.800] - Launch lazy future ...
[17:02:46.800] Packages needed by the future expression (n = 0): <none>
[17:02:46.800] Packages needed by future strategies (n = 0): <none>
[17:02:46.800] {
[17:02:46.800]     {
[17:02:46.800]         {
[17:02:46.800]             ...future.startTime <- base::Sys.time()
[17:02:46.800]             {
[17:02:46.800]                 {
[17:02:46.800]                   {
[17:02:46.800]                     base::local({
[17:02:46.800]                       has_future <- base::requireNamespace("future", 
[17:02:46.800]                         quietly = TRUE)
[17:02:46.800]                       if (has_future) {
[17:02:46.800]                         ns <- base::getNamespace("future")
[17:02:46.800]                         version <- ns[[".package"]][["version"]]
[17:02:46.800]                         if (is.null(version)) 
[17:02:46.800]                           version <- utils::packageVersion("future")
[17:02:46.800]                       }
[17:02:46.800]                       else {
[17:02:46.800]                         version <- NULL
[17:02:46.800]                       }
[17:02:46.800]                       if (!has_future || version < "1.8.0") {
[17:02:46.800]                         info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.800]                           "", base::R.version$version.string), 
[17:02:46.800]                           platform = base::sprintf("%s (%s-bit)", 
[17:02:46.800]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.800]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.800]                             "release", "version")], collapse = " "), 
[17:02:46.800]                           hostname = base::Sys.info()[["nodename"]])
[17:02:46.800]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.800]                           info)
[17:02:46.800]                         info <- base::paste(info, collapse = "; ")
[17:02:46.800]                         if (!has_future) {
[17:02:46.800]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.800]                             info)
[17:02:46.800]                         }
[17:02:46.800]                         else {
[17:02:46.800]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.800]                             info, version)
[17:02:46.800]                         }
[17:02:46.800]                         base::stop(msg)
[17:02:46.800]                       }
[17:02:46.800]                     })
[17:02:46.800]                   }
[17:02:46.800]                   ...future.strategy.old <- future::plan("list")
[17:02:46.800]                   options(future.plan = NULL)
[17:02:46.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.800]                 }
[17:02:46.800]                 ...future.workdir <- getwd()
[17:02:46.800]             }
[17:02:46.800]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.800]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.800]         }
[17:02:46.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.800]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.800]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.800]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.800]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.800]             base::names(...future.oldOptions))
[17:02:46.800]     }
[17:02:46.800]     if (FALSE) {
[17:02:46.800]     }
[17:02:46.800]     else {
[17:02:46.800]         if (TRUE) {
[17:02:46.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.800]                 open = "w")
[17:02:46.800]         }
[17:02:46.800]         else {
[17:02:46.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.800]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.800]         }
[17:02:46.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.800]             base::sink(type = "output", split = FALSE)
[17:02:46.800]             base::close(...future.stdout)
[17:02:46.800]         }, add = TRUE)
[17:02:46.800]     }
[17:02:46.800]     ...future.frame <- base::sys.nframe()
[17:02:46.800]     ...future.conditions <- base::list()
[17:02:46.800]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.800]     if (FALSE) {
[17:02:46.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.800]     }
[17:02:46.800]     ...future.result <- base::tryCatch({
[17:02:46.800]         base::withCallingHandlers({
[17:02:46.800]             ...future.value <- base::withVisible(base::local({
[17:02:46.800]                 x[name] <- list(1)
[17:02:46.800]                 x
[17:02:46.800]             }))
[17:02:46.800]             future::FutureResult(value = ...future.value$value, 
[17:02:46.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.800]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.800]                     ...future.globalenv.names))
[17:02:46.800]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.800]         }, condition = base::local({
[17:02:46.800]             c <- base::c
[17:02:46.800]             inherits <- base::inherits
[17:02:46.800]             invokeRestart <- base::invokeRestart
[17:02:46.800]             length <- base::length
[17:02:46.800]             list <- base::list
[17:02:46.800]             seq.int <- base::seq.int
[17:02:46.800]             signalCondition <- base::signalCondition
[17:02:46.800]             sys.calls <- base::sys.calls
[17:02:46.800]             `[[` <- base::`[[`
[17:02:46.800]             `+` <- base::`+`
[17:02:46.800]             `<<-` <- base::`<<-`
[17:02:46.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.800]                   3L)]
[17:02:46.800]             }
[17:02:46.800]             function(cond) {
[17:02:46.800]                 is_error <- inherits(cond, "error")
[17:02:46.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.800]                   NULL)
[17:02:46.800]                 if (is_error) {
[17:02:46.800]                   sessionInformation <- function() {
[17:02:46.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.800]                       search = base::search(), system = base::Sys.info())
[17:02:46.800]                   }
[17:02:46.800]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.800]                     cond$call), session = sessionInformation(), 
[17:02:46.800]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.800]                   signalCondition(cond)
[17:02:46.800]                 }
[17:02:46.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.800]                 "immediateCondition"))) {
[17:02:46.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.800]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.800]                   if (TRUE && !signal) {
[17:02:46.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.800]                     {
[17:02:46.800]                       inherits <- base::inherits
[17:02:46.800]                       invokeRestart <- base::invokeRestart
[17:02:46.800]                       is.null <- base::is.null
[17:02:46.800]                       muffled <- FALSE
[17:02:46.800]                       if (inherits(cond, "message")) {
[17:02:46.800]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.800]                         if (muffled) 
[17:02:46.800]                           invokeRestart("muffleMessage")
[17:02:46.800]                       }
[17:02:46.800]                       else if (inherits(cond, "warning")) {
[17:02:46.800]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.800]                         if (muffled) 
[17:02:46.800]                           invokeRestart("muffleWarning")
[17:02:46.800]                       }
[17:02:46.800]                       else if (inherits(cond, "condition")) {
[17:02:46.800]                         if (!is.null(pattern)) {
[17:02:46.800]                           computeRestarts <- base::computeRestarts
[17:02:46.800]                           grepl <- base::grepl
[17:02:46.800]                           restarts <- computeRestarts(cond)
[17:02:46.800]                           for (restart in restarts) {
[17:02:46.800]                             name <- restart$name
[17:02:46.800]                             if (is.null(name)) 
[17:02:46.800]                               next
[17:02:46.800]                             if (!grepl(pattern, name)) 
[17:02:46.800]                               next
[17:02:46.800]                             invokeRestart(restart)
[17:02:46.800]                             muffled <- TRUE
[17:02:46.800]                             break
[17:02:46.800]                           }
[17:02:46.800]                         }
[17:02:46.800]                       }
[17:02:46.800]                       invisible(muffled)
[17:02:46.800]                     }
[17:02:46.800]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.800]                   }
[17:02:46.800]                 }
[17:02:46.800]                 else {
[17:02:46.800]                   if (TRUE) {
[17:02:46.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.800]                     {
[17:02:46.800]                       inherits <- base::inherits
[17:02:46.800]                       invokeRestart <- base::invokeRestart
[17:02:46.800]                       is.null <- base::is.null
[17:02:46.800]                       muffled <- FALSE
[17:02:46.800]                       if (inherits(cond, "message")) {
[17:02:46.800]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.800]                         if (muffled) 
[17:02:46.800]                           invokeRestart("muffleMessage")
[17:02:46.800]                       }
[17:02:46.800]                       else if (inherits(cond, "warning")) {
[17:02:46.800]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.800]                         if (muffled) 
[17:02:46.800]                           invokeRestart("muffleWarning")
[17:02:46.800]                       }
[17:02:46.800]                       else if (inherits(cond, "condition")) {
[17:02:46.800]                         if (!is.null(pattern)) {
[17:02:46.800]                           computeRestarts <- base::computeRestarts
[17:02:46.800]                           grepl <- base::grepl
[17:02:46.800]                           restarts <- computeRestarts(cond)
[17:02:46.800]                           for (restart in restarts) {
[17:02:46.800]                             name <- restart$name
[17:02:46.800]                             if (is.null(name)) 
[17:02:46.800]                               next
[17:02:46.800]                             if (!grepl(pattern, name)) 
[17:02:46.800]                               next
[17:02:46.800]                             invokeRestart(restart)
[17:02:46.800]                             muffled <- TRUE
[17:02:46.800]                             break
[17:02:46.800]                           }
[17:02:46.800]                         }
[17:02:46.800]                       }
[17:02:46.800]                       invisible(muffled)
[17:02:46.800]                     }
[17:02:46.800]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.800]                   }
[17:02:46.800]                 }
[17:02:46.800]             }
[17:02:46.800]         }))
[17:02:46.800]     }, error = function(ex) {
[17:02:46.800]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.800]                 ...future.rng), started = ...future.startTime, 
[17:02:46.800]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.800]             version = "1.8"), class = "FutureResult")
[17:02:46.800]     }, finally = {
[17:02:46.800]         if (!identical(...future.workdir, getwd())) 
[17:02:46.800]             setwd(...future.workdir)
[17:02:46.800]         {
[17:02:46.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.800]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.800]             }
[17:02:46.800]             base::options(...future.oldOptions)
[17:02:46.800]             if (.Platform$OS.type == "windows") {
[17:02:46.800]                 old_names <- names(...future.oldEnvVars)
[17:02:46.800]                 envs <- base::Sys.getenv()
[17:02:46.800]                 names <- names(envs)
[17:02:46.800]                 common <- intersect(names, old_names)
[17:02:46.800]                 added <- setdiff(names, old_names)
[17:02:46.800]                 removed <- setdiff(old_names, names)
[17:02:46.800]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.800]                   envs[common]]
[17:02:46.800]                 NAMES <- toupper(changed)
[17:02:46.800]                 args <- list()
[17:02:46.800]                 for (kk in seq_along(NAMES)) {
[17:02:46.800]                   name <- changed[[kk]]
[17:02:46.800]                   NAME <- NAMES[[kk]]
[17:02:46.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.800]                     next
[17:02:46.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.800]                 }
[17:02:46.800]                 NAMES <- toupper(added)
[17:02:46.800]                 for (kk in seq_along(NAMES)) {
[17:02:46.800]                   name <- added[[kk]]
[17:02:46.800]                   NAME <- NAMES[[kk]]
[17:02:46.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.800]                     next
[17:02:46.800]                   args[[name]] <- ""
[17:02:46.800]                 }
[17:02:46.800]                 NAMES <- toupper(removed)
[17:02:46.800]                 for (kk in seq_along(NAMES)) {
[17:02:46.800]                   name <- removed[[kk]]
[17:02:46.800]                   NAME <- NAMES[[kk]]
[17:02:46.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.800]                     next
[17:02:46.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.800]                 }
[17:02:46.800]                 if (length(args) > 0) 
[17:02:46.800]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.800]             }
[17:02:46.800]             else {
[17:02:46.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.800]             }
[17:02:46.800]             {
[17:02:46.800]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.800]                   0L) {
[17:02:46.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.800]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.800]                   base::options(opts)
[17:02:46.800]                 }
[17:02:46.800]                 {
[17:02:46.800]                   {
[17:02:46.800]                     NULL
[17:02:46.800]                     RNGkind("Mersenne-Twister")
[17:02:46.800]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:02:46.800]                       inherits = FALSE)
[17:02:46.800]                   }
[17:02:46.800]                   options(future.plan = NULL)
[17:02:46.800]                   if (is.na(NA_character_)) 
[17:02:46.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.800]                     .init = FALSE)
[17:02:46.800]                 }
[17:02:46.800]             }
[17:02:46.800]         }
[17:02:46.800]     })
[17:02:46.800]     if (TRUE) {
[17:02:46.800]         base::sink(type = "output", split = FALSE)
[17:02:46.800]         if (TRUE) {
[17:02:46.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.800]         }
[17:02:46.800]         else {
[17:02:46.800]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.800]         }
[17:02:46.800]         base::close(...future.stdout)
[17:02:46.800]         ...future.stdout <- NULL
[17:02:46.800]     }
[17:02:46.800]     ...future.result$conditions <- ...future.conditions
[17:02:46.800]     ...future.result$finished <- base::Sys.time()
[17:02:46.800]     ...future.result
[17:02:46.800] }
[17:02:46.802] assign_globals() ...
[17:02:46.802] List of 2
[17:02:46.802]  $ x   : list()
[17:02:46.802]  $ name: chr "a"
[17:02:46.802]  - attr(*, "where")=List of 2
[17:02:46.802]   ..$ x   :<environment: R_EmptyEnv> 
[17:02:46.802]   ..$ name:<environment: R_EmptyEnv> 
[17:02:46.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.802]  - attr(*, "resolved")= logi TRUE
[17:02:46.802]  - attr(*, "total_size")= num 112
[17:02:46.802]  - attr(*, "already-done")= logi TRUE
[17:02:46.805] - copied ‘x’ to environment
[17:02:46.805] - copied ‘name’ to environment
[17:02:46.805] assign_globals() ... done
[17:02:46.805] plan(): Setting new future strategy stack:
[17:02:46.805] List of future strategies:
[17:02:46.805] 1. sequential:
[17:02:46.805]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.805]    - tweaked: FALSE
[17:02:46.805]    - call: NULL
[17:02:46.806] plan(): nbrOfWorkers() = 1
[17:02:46.806] plan(): Setting new future strategy stack:
[17:02:46.807] List of future strategies:
[17:02:46.807] 1. sequential:
[17:02:46.807]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.807]    - tweaked: FALSE
[17:02:46.807]    - call: plan(strategy)
[17:02:46.809] plan(): nbrOfWorkers() = 1
[17:02:46.809] SequentialFuture started (and completed)
[17:02:46.809] - Launch lazy future ... done
[17:02:46.809] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[17:02:46.818] plan(): Setting new future strategy stack:
[17:02:46.818] List of future strategies:
[17:02:46.818] 1. multicore:
[17:02:46.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:46.818]    - tweaked: FALSE
[17:02:46.818]    - call: plan(strategy)
[17:02:46.821] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.822] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.822] Searching for globals...
[17:02:46.824] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.824] Searching for globals ... DONE
[17:02:46.824] Resolving globals: TRUE
[17:02:46.824] Resolving any globals that are futures ...
[17:02:46.824] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.824] Resolving any globals that are futures ... DONE
[17:02:46.825] Resolving futures part of globals (recursively) ...
[17:02:46.825] resolve() on list ...
[17:02:46.825]  recursive: 99
[17:02:46.825]  length: 1
[17:02:46.825]  elements: ‘x’
[17:02:46.825]  length: 0 (resolved future 1)
[17:02:46.825] resolve() on list ... DONE
[17:02:46.825] - globals: [1] ‘x’
[17:02:46.825] Resolving futures part of globals (recursively) ... DONE
[17:02:46.826] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.826] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.826] - globals: [1] ‘x’
[17:02:46.826] 
[17:02:46.826] getGlobalsAndPackages() ... DONE
[17:02:46.826] run() for ‘Future’ ...
[17:02:46.827] - state: ‘created’
[17:02:46.827] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:46.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:46.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:46.831]   - Field: ‘label’
[17:02:46.831]   - Field: ‘local’
[17:02:46.831]   - Field: ‘owner’
[17:02:46.831]   - Field: ‘envir’
[17:02:46.831]   - Field: ‘workers’
[17:02:46.831]   - Field: ‘packages’
[17:02:46.831]   - Field: ‘gc’
[17:02:46.831]   - Field: ‘job’
[17:02:46.831]   - Field: ‘conditions’
[17:02:46.831]   - Field: ‘expr’
[17:02:46.832]   - Field: ‘uuid’
[17:02:46.832]   - Field: ‘seed’
[17:02:46.832]   - Field: ‘version’
[17:02:46.832]   - Field: ‘result’
[17:02:46.832]   - Field: ‘asynchronous’
[17:02:46.832]   - Field: ‘calls’
[17:02:46.832]   - Field: ‘globals’
[17:02:46.832]   - Field: ‘stdout’
[17:02:46.832]   - Field: ‘earlySignal’
[17:02:46.832]   - Field: ‘lazy’
[17:02:46.832]   - Field: ‘state’
[17:02:46.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:46.833] - Launch lazy future ...
[17:02:46.834] Packages needed by the future expression (n = 0): <none>
[17:02:46.834] Packages needed by future strategies (n = 0): <none>
[17:02:46.834] {
[17:02:46.834]     {
[17:02:46.834]         {
[17:02:46.834]             ...future.startTime <- base::Sys.time()
[17:02:46.834]             {
[17:02:46.834]                 {
[17:02:46.834]                   {
[17:02:46.834]                     {
[17:02:46.834]                       base::local({
[17:02:46.834]                         has_future <- base::requireNamespace("future", 
[17:02:46.834]                           quietly = TRUE)
[17:02:46.834]                         if (has_future) {
[17:02:46.834]                           ns <- base::getNamespace("future")
[17:02:46.834]                           version <- ns[[".package"]][["version"]]
[17:02:46.834]                           if (is.null(version)) 
[17:02:46.834]                             version <- utils::packageVersion("future")
[17:02:46.834]                         }
[17:02:46.834]                         else {
[17:02:46.834]                           version <- NULL
[17:02:46.834]                         }
[17:02:46.834]                         if (!has_future || version < "1.8.0") {
[17:02:46.834]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.834]                             "", base::R.version$version.string), 
[17:02:46.834]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:46.834]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.834]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.834]                               "release", "version")], collapse = " "), 
[17:02:46.834]                             hostname = base::Sys.info()[["nodename"]])
[17:02:46.834]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.834]                             info)
[17:02:46.834]                           info <- base::paste(info, collapse = "; ")
[17:02:46.834]                           if (!has_future) {
[17:02:46.834]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.834]                               info)
[17:02:46.834]                           }
[17:02:46.834]                           else {
[17:02:46.834]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.834]                               info, version)
[17:02:46.834]                           }
[17:02:46.834]                           base::stop(msg)
[17:02:46.834]                         }
[17:02:46.834]                       })
[17:02:46.834]                     }
[17:02:46.834]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:46.834]                     base::options(mc.cores = 1L)
[17:02:46.834]                   }
[17:02:46.834]                   ...future.strategy.old <- future::plan("list")
[17:02:46.834]                   options(future.plan = NULL)
[17:02:46.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.834]                 }
[17:02:46.834]                 ...future.workdir <- getwd()
[17:02:46.834]             }
[17:02:46.834]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.834]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.834]         }
[17:02:46.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.834]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.834]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.834]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.834]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.834]             base::names(...future.oldOptions))
[17:02:46.834]     }
[17:02:46.834]     if (FALSE) {
[17:02:46.834]     }
[17:02:46.834]     else {
[17:02:46.834]         if (TRUE) {
[17:02:46.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.834]                 open = "w")
[17:02:46.834]         }
[17:02:46.834]         else {
[17:02:46.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.834]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.834]         }
[17:02:46.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.834]             base::sink(type = "output", split = FALSE)
[17:02:46.834]             base::close(...future.stdout)
[17:02:46.834]         }, add = TRUE)
[17:02:46.834]     }
[17:02:46.834]     ...future.frame <- base::sys.nframe()
[17:02:46.834]     ...future.conditions <- base::list()
[17:02:46.834]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.834]     if (FALSE) {
[17:02:46.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.834]     }
[17:02:46.834]     ...future.result <- base::tryCatch({
[17:02:46.834]         base::withCallingHandlers({
[17:02:46.834]             ...future.value <- base::withVisible(base::local({
[17:02:46.834]                 withCallingHandlers({
[17:02:46.834]                   {
[17:02:46.834]                     x$a <- 1
[17:02:46.834]                     x
[17:02:46.834]                   }
[17:02:46.834]                 }, immediateCondition = function(cond) {
[17:02:46.834]                   save_rds <- function (object, pathname, ...) 
[17:02:46.834]                   {
[17:02:46.834]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:46.834]                     if (file_test("-f", pathname_tmp)) {
[17:02:46.834]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.834]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:46.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.834]                         fi_tmp[["mtime"]])
[17:02:46.834]                     }
[17:02:46.834]                     tryCatch({
[17:02:46.834]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:46.834]                     }, error = function(ex) {
[17:02:46.834]                       msg <- conditionMessage(ex)
[17:02:46.834]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.834]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:46.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.834]                         fi_tmp[["mtime"]], msg)
[17:02:46.834]                       ex$message <- msg
[17:02:46.834]                       stop(ex)
[17:02:46.834]                     })
[17:02:46.834]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:46.834]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:46.834]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:46.834]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.834]                       fi <- file.info(pathname)
[17:02:46.834]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:46.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.834]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:46.834]                         fi[["size"]], fi[["mtime"]])
[17:02:46.834]                       stop(msg)
[17:02:46.834]                     }
[17:02:46.834]                     invisible(pathname)
[17:02:46.834]                   }
[17:02:46.834]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:46.834]                     rootPath = tempdir()) 
[17:02:46.834]                   {
[17:02:46.834]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:46.834]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:46.834]                       tmpdir = path, fileext = ".rds")
[17:02:46.834]                     save_rds(obj, file)
[17:02:46.834]                   }
[17:02:46.834]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:46.834]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.834]                   {
[17:02:46.834]                     inherits <- base::inherits
[17:02:46.834]                     invokeRestart <- base::invokeRestart
[17:02:46.834]                     is.null <- base::is.null
[17:02:46.834]                     muffled <- FALSE
[17:02:46.834]                     if (inherits(cond, "message")) {
[17:02:46.834]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:46.834]                       if (muffled) 
[17:02:46.834]                         invokeRestart("muffleMessage")
[17:02:46.834]                     }
[17:02:46.834]                     else if (inherits(cond, "warning")) {
[17:02:46.834]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:46.834]                       if (muffled) 
[17:02:46.834]                         invokeRestart("muffleWarning")
[17:02:46.834]                     }
[17:02:46.834]                     else if (inherits(cond, "condition")) {
[17:02:46.834]                       if (!is.null(pattern)) {
[17:02:46.834]                         computeRestarts <- base::computeRestarts
[17:02:46.834]                         grepl <- base::grepl
[17:02:46.834]                         restarts <- computeRestarts(cond)
[17:02:46.834]                         for (restart in restarts) {
[17:02:46.834]                           name <- restart$name
[17:02:46.834]                           if (is.null(name)) 
[17:02:46.834]                             next
[17:02:46.834]                           if (!grepl(pattern, name)) 
[17:02:46.834]                             next
[17:02:46.834]                           invokeRestart(restart)
[17:02:46.834]                           muffled <- TRUE
[17:02:46.834]                           break
[17:02:46.834]                         }
[17:02:46.834]                       }
[17:02:46.834]                     }
[17:02:46.834]                     invisible(muffled)
[17:02:46.834]                   }
[17:02:46.834]                   muffleCondition(cond)
[17:02:46.834]                 })
[17:02:46.834]             }))
[17:02:46.834]             future::FutureResult(value = ...future.value$value, 
[17:02:46.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.834]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.834]                     ...future.globalenv.names))
[17:02:46.834]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.834]         }, condition = base::local({
[17:02:46.834]             c <- base::c
[17:02:46.834]             inherits <- base::inherits
[17:02:46.834]             invokeRestart <- base::invokeRestart
[17:02:46.834]             length <- base::length
[17:02:46.834]             list <- base::list
[17:02:46.834]             seq.int <- base::seq.int
[17:02:46.834]             signalCondition <- base::signalCondition
[17:02:46.834]             sys.calls <- base::sys.calls
[17:02:46.834]             `[[` <- base::`[[`
[17:02:46.834]             `+` <- base::`+`
[17:02:46.834]             `<<-` <- base::`<<-`
[17:02:46.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.834]                   3L)]
[17:02:46.834]             }
[17:02:46.834]             function(cond) {
[17:02:46.834]                 is_error <- inherits(cond, "error")
[17:02:46.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.834]                   NULL)
[17:02:46.834]                 if (is_error) {
[17:02:46.834]                   sessionInformation <- function() {
[17:02:46.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.834]                       search = base::search(), system = base::Sys.info())
[17:02:46.834]                   }
[17:02:46.834]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.834]                     cond$call), session = sessionInformation(), 
[17:02:46.834]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.834]                   signalCondition(cond)
[17:02:46.834]                 }
[17:02:46.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.834]                 "immediateCondition"))) {
[17:02:46.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.834]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.834]                   if (TRUE && !signal) {
[17:02:46.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.834]                     {
[17:02:46.834]                       inherits <- base::inherits
[17:02:46.834]                       invokeRestart <- base::invokeRestart
[17:02:46.834]                       is.null <- base::is.null
[17:02:46.834]                       muffled <- FALSE
[17:02:46.834]                       if (inherits(cond, "message")) {
[17:02:46.834]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.834]                         if (muffled) 
[17:02:46.834]                           invokeRestart("muffleMessage")
[17:02:46.834]                       }
[17:02:46.834]                       else if (inherits(cond, "warning")) {
[17:02:46.834]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.834]                         if (muffled) 
[17:02:46.834]                           invokeRestart("muffleWarning")
[17:02:46.834]                       }
[17:02:46.834]                       else if (inherits(cond, "condition")) {
[17:02:46.834]                         if (!is.null(pattern)) {
[17:02:46.834]                           computeRestarts <- base::computeRestarts
[17:02:46.834]                           grepl <- base::grepl
[17:02:46.834]                           restarts <- computeRestarts(cond)
[17:02:46.834]                           for (restart in restarts) {
[17:02:46.834]                             name <- restart$name
[17:02:46.834]                             if (is.null(name)) 
[17:02:46.834]                               next
[17:02:46.834]                             if (!grepl(pattern, name)) 
[17:02:46.834]                               next
[17:02:46.834]                             invokeRestart(restart)
[17:02:46.834]                             muffled <- TRUE
[17:02:46.834]                             break
[17:02:46.834]                           }
[17:02:46.834]                         }
[17:02:46.834]                       }
[17:02:46.834]                       invisible(muffled)
[17:02:46.834]                     }
[17:02:46.834]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.834]                   }
[17:02:46.834]                 }
[17:02:46.834]                 else {
[17:02:46.834]                   if (TRUE) {
[17:02:46.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.834]                     {
[17:02:46.834]                       inherits <- base::inherits
[17:02:46.834]                       invokeRestart <- base::invokeRestart
[17:02:46.834]                       is.null <- base::is.null
[17:02:46.834]                       muffled <- FALSE
[17:02:46.834]                       if (inherits(cond, "message")) {
[17:02:46.834]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.834]                         if (muffled) 
[17:02:46.834]                           invokeRestart("muffleMessage")
[17:02:46.834]                       }
[17:02:46.834]                       else if (inherits(cond, "warning")) {
[17:02:46.834]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.834]                         if (muffled) 
[17:02:46.834]                           invokeRestart("muffleWarning")
[17:02:46.834]                       }
[17:02:46.834]                       else if (inherits(cond, "condition")) {
[17:02:46.834]                         if (!is.null(pattern)) {
[17:02:46.834]                           computeRestarts <- base::computeRestarts
[17:02:46.834]                           grepl <- base::grepl
[17:02:46.834]                           restarts <- computeRestarts(cond)
[17:02:46.834]                           for (restart in restarts) {
[17:02:46.834]                             name <- restart$name
[17:02:46.834]                             if (is.null(name)) 
[17:02:46.834]                               next
[17:02:46.834]                             if (!grepl(pattern, name)) 
[17:02:46.834]                               next
[17:02:46.834]                             invokeRestart(restart)
[17:02:46.834]                             muffled <- TRUE
[17:02:46.834]                             break
[17:02:46.834]                           }
[17:02:46.834]                         }
[17:02:46.834]                       }
[17:02:46.834]                       invisible(muffled)
[17:02:46.834]                     }
[17:02:46.834]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.834]                   }
[17:02:46.834]                 }
[17:02:46.834]             }
[17:02:46.834]         }))
[17:02:46.834]     }, error = function(ex) {
[17:02:46.834]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.834]                 ...future.rng), started = ...future.startTime, 
[17:02:46.834]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.834]             version = "1.8"), class = "FutureResult")
[17:02:46.834]     }, finally = {
[17:02:46.834]         if (!identical(...future.workdir, getwd())) 
[17:02:46.834]             setwd(...future.workdir)
[17:02:46.834]         {
[17:02:46.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.834]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.834]             }
[17:02:46.834]             base::options(...future.oldOptions)
[17:02:46.834]             if (.Platform$OS.type == "windows") {
[17:02:46.834]                 old_names <- names(...future.oldEnvVars)
[17:02:46.834]                 envs <- base::Sys.getenv()
[17:02:46.834]                 names <- names(envs)
[17:02:46.834]                 common <- intersect(names, old_names)
[17:02:46.834]                 added <- setdiff(names, old_names)
[17:02:46.834]                 removed <- setdiff(old_names, names)
[17:02:46.834]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.834]                   envs[common]]
[17:02:46.834]                 NAMES <- toupper(changed)
[17:02:46.834]                 args <- list()
[17:02:46.834]                 for (kk in seq_along(NAMES)) {
[17:02:46.834]                   name <- changed[[kk]]
[17:02:46.834]                   NAME <- NAMES[[kk]]
[17:02:46.834]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.834]                     next
[17:02:46.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.834]                 }
[17:02:46.834]                 NAMES <- toupper(added)
[17:02:46.834]                 for (kk in seq_along(NAMES)) {
[17:02:46.834]                   name <- added[[kk]]
[17:02:46.834]                   NAME <- NAMES[[kk]]
[17:02:46.834]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.834]                     next
[17:02:46.834]                   args[[name]] <- ""
[17:02:46.834]                 }
[17:02:46.834]                 NAMES <- toupper(removed)
[17:02:46.834]                 for (kk in seq_along(NAMES)) {
[17:02:46.834]                   name <- removed[[kk]]
[17:02:46.834]                   NAME <- NAMES[[kk]]
[17:02:46.834]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.834]                     next
[17:02:46.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.834]                 }
[17:02:46.834]                 if (length(args) > 0) 
[17:02:46.834]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.834]             }
[17:02:46.834]             else {
[17:02:46.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.834]             }
[17:02:46.834]             {
[17:02:46.834]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.834]                   0L) {
[17:02:46.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.834]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.834]                   base::options(opts)
[17:02:46.834]                 }
[17:02:46.834]                 {
[17:02:46.834]                   {
[17:02:46.834]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:46.834]                     NULL
[17:02:46.834]                   }
[17:02:46.834]                   options(future.plan = NULL)
[17:02:46.834]                   if (is.na(NA_character_)) 
[17:02:46.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.834]                     .init = FALSE)
[17:02:46.834]                 }
[17:02:46.834]             }
[17:02:46.834]         }
[17:02:46.834]     })
[17:02:46.834]     if (TRUE) {
[17:02:46.834]         base::sink(type = "output", split = FALSE)
[17:02:46.834]         if (TRUE) {
[17:02:46.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.834]         }
[17:02:46.834]         else {
[17:02:46.834]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.834]         }
[17:02:46.834]         base::close(...future.stdout)
[17:02:46.834]         ...future.stdout <- NULL
[17:02:46.834]     }
[17:02:46.834]     ...future.result$conditions <- ...future.conditions
[17:02:46.834]     ...future.result$finished <- base::Sys.time()
[17:02:46.834]     ...future.result
[17:02:46.834] }
[17:02:46.836] assign_globals() ...
[17:02:46.836] List of 1
[17:02:46.836]  $ x: list()
[17:02:46.836]  - attr(*, "where")=List of 1
[17:02:46.836]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.836]  - attr(*, "resolved")= logi TRUE
[17:02:46.836]  - attr(*, "total_size")= num 0
[17:02:46.836]  - attr(*, "already-done")= logi TRUE
[17:02:46.839] - copied ‘x’ to environment
[17:02:46.839] assign_globals() ... done
[17:02:46.839] requestCore(): workers = 2
[17:02:46.842] MulticoreFuture started
[17:02:46.842] - Launch lazy future ... done
[17:02:46.842] plan(): Setting new future strategy stack:
[17:02:46.842] run() for ‘MulticoreFuture’ ... done
[17:02:46.843] List of future strategies:
[17:02:46.843] 1. sequential:
[17:02:46.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.843]    - tweaked: FALSE
[17:02:46.843]    - call: NULL
[17:02:46.844] result() for MulticoreFuture ...
[17:02:46.844] plan(): nbrOfWorkers() = 1
[17:02:46.846] plan(): Setting new future strategy stack:
[17:02:46.846] List of future strategies:
[17:02:46.846] 1. multicore:
[17:02:46.846]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:46.846]    - tweaked: FALSE
[17:02:46.846]    - call: plan(strategy)
[17:02:46.856] plan(): nbrOfWorkers() = 2
[17:02:46.864] result() for MulticoreFuture ...
[17:02:46.864] result() for MulticoreFuture ... done
[17:02:46.865] result() for MulticoreFuture ... done
[17:02:46.865] result() for MulticoreFuture ...
[17:02:46.865] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.865] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.865] Searching for globals...
[17:02:46.868] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.868] Searching for globals ... DONE
[17:02:46.868] Resolving globals: TRUE
[17:02:46.868] Resolving any globals that are futures ...
[17:02:46.869] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.869] Resolving any globals that are futures ... DONE
[17:02:46.869] Resolving futures part of globals (recursively) ...
[17:02:46.869] resolve() on list ...
[17:02:46.869]  recursive: 99
[17:02:46.870]  length: 1
[17:02:46.870]  elements: ‘x’
[17:02:46.870]  length: 0 (resolved future 1)
[17:02:46.870] resolve() on list ... DONE
[17:02:46.870] - globals: [1] ‘x’
[17:02:46.870] Resolving futures part of globals (recursively) ... DONE
[17:02:46.870] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.871] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.871] - globals: [1] ‘x’
[17:02:46.871] 
[17:02:46.871] getGlobalsAndPackages() ... DONE
[17:02:46.872] run() for ‘Future’ ...
[17:02:46.872] - state: ‘created’
[17:02:46.872] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:46.876] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:46.876] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:46.876]   - Field: ‘label’
[17:02:46.876]   - Field: ‘local’
[17:02:46.876]   - Field: ‘owner’
[17:02:46.876]   - Field: ‘envir’
[17:02:46.876]   - Field: ‘workers’
[17:02:46.877]   - Field: ‘packages’
[17:02:46.877]   - Field: ‘gc’
[17:02:46.877]   - Field: ‘job’
[17:02:46.877]   - Field: ‘conditions’
[17:02:46.877]   - Field: ‘expr’
[17:02:46.877]   - Field: ‘uuid’
[17:02:46.877]   - Field: ‘seed’
[17:02:46.877]   - Field: ‘version’
[17:02:46.877]   - Field: ‘result’
[17:02:46.878]   - Field: ‘asynchronous’
[17:02:46.878]   - Field: ‘calls’
[17:02:46.878]   - Field: ‘globals’
[17:02:46.878]   - Field: ‘stdout’
[17:02:46.878]   - Field: ‘earlySignal’
[17:02:46.878]   - Field: ‘lazy’
[17:02:46.878]   - Field: ‘state’
[17:02:46.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:46.878] - Launch lazy future ...
[17:02:46.879] Packages needed by the future expression (n = 0): <none>
[17:02:46.879] Packages needed by future strategies (n = 0): <none>
[17:02:46.879] {
[17:02:46.879]     {
[17:02:46.879]         {
[17:02:46.879]             ...future.startTime <- base::Sys.time()
[17:02:46.879]             {
[17:02:46.879]                 {
[17:02:46.879]                   {
[17:02:46.879]                     {
[17:02:46.879]                       base::local({
[17:02:46.879]                         has_future <- base::requireNamespace("future", 
[17:02:46.879]                           quietly = TRUE)
[17:02:46.879]                         if (has_future) {
[17:02:46.879]                           ns <- base::getNamespace("future")
[17:02:46.879]                           version <- ns[[".package"]][["version"]]
[17:02:46.879]                           if (is.null(version)) 
[17:02:46.879]                             version <- utils::packageVersion("future")
[17:02:46.879]                         }
[17:02:46.879]                         else {
[17:02:46.879]                           version <- NULL
[17:02:46.879]                         }
[17:02:46.879]                         if (!has_future || version < "1.8.0") {
[17:02:46.879]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.879]                             "", base::R.version$version.string), 
[17:02:46.879]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:46.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.879]                               "release", "version")], collapse = " "), 
[17:02:46.879]                             hostname = base::Sys.info()[["nodename"]])
[17:02:46.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.879]                             info)
[17:02:46.879]                           info <- base::paste(info, collapse = "; ")
[17:02:46.879]                           if (!has_future) {
[17:02:46.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.879]                               info)
[17:02:46.879]                           }
[17:02:46.879]                           else {
[17:02:46.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.879]                               info, version)
[17:02:46.879]                           }
[17:02:46.879]                           base::stop(msg)
[17:02:46.879]                         }
[17:02:46.879]                       })
[17:02:46.879]                     }
[17:02:46.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:46.879]                     base::options(mc.cores = 1L)
[17:02:46.879]                   }
[17:02:46.879]                   ...future.strategy.old <- future::plan("list")
[17:02:46.879]                   options(future.plan = NULL)
[17:02:46.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.879]                 }
[17:02:46.879]                 ...future.workdir <- getwd()
[17:02:46.879]             }
[17:02:46.879]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.879]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.879]         }
[17:02:46.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.879]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.879]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.879]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.879]             base::names(...future.oldOptions))
[17:02:46.879]     }
[17:02:46.879]     if (FALSE) {
[17:02:46.879]     }
[17:02:46.879]     else {
[17:02:46.879]         if (TRUE) {
[17:02:46.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.879]                 open = "w")
[17:02:46.879]         }
[17:02:46.879]         else {
[17:02:46.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.879]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.879]         }
[17:02:46.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.879]             base::sink(type = "output", split = FALSE)
[17:02:46.879]             base::close(...future.stdout)
[17:02:46.879]         }, add = TRUE)
[17:02:46.879]     }
[17:02:46.879]     ...future.frame <- base::sys.nframe()
[17:02:46.879]     ...future.conditions <- base::list()
[17:02:46.879]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.879]     if (FALSE) {
[17:02:46.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.879]     }
[17:02:46.879]     ...future.result <- base::tryCatch({
[17:02:46.879]         base::withCallingHandlers({
[17:02:46.879]             ...future.value <- base::withVisible(base::local({
[17:02:46.879]                 withCallingHandlers({
[17:02:46.879]                   {
[17:02:46.879]                     x$a <- 1
[17:02:46.879]                     x
[17:02:46.879]                   }
[17:02:46.879]                 }, immediateCondition = function(cond) {
[17:02:46.879]                   save_rds <- function (object, pathname, ...) 
[17:02:46.879]                   {
[17:02:46.879]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:46.879]                     if (file_test("-f", pathname_tmp)) {
[17:02:46.879]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.879]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:46.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.879]                         fi_tmp[["mtime"]])
[17:02:46.879]                     }
[17:02:46.879]                     tryCatch({
[17:02:46.879]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:46.879]                     }, error = function(ex) {
[17:02:46.879]                       msg <- conditionMessage(ex)
[17:02:46.879]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.879]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:46.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.879]                         fi_tmp[["mtime"]], msg)
[17:02:46.879]                       ex$message <- msg
[17:02:46.879]                       stop(ex)
[17:02:46.879]                     })
[17:02:46.879]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:46.879]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:46.879]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:46.879]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.879]                       fi <- file.info(pathname)
[17:02:46.879]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:46.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.879]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:46.879]                         fi[["size"]], fi[["mtime"]])
[17:02:46.879]                       stop(msg)
[17:02:46.879]                     }
[17:02:46.879]                     invisible(pathname)
[17:02:46.879]                   }
[17:02:46.879]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:46.879]                     rootPath = tempdir()) 
[17:02:46.879]                   {
[17:02:46.879]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:46.879]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:46.879]                       tmpdir = path, fileext = ".rds")
[17:02:46.879]                     save_rds(obj, file)
[17:02:46.879]                   }
[17:02:46.879]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:46.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.879]                   {
[17:02:46.879]                     inherits <- base::inherits
[17:02:46.879]                     invokeRestart <- base::invokeRestart
[17:02:46.879]                     is.null <- base::is.null
[17:02:46.879]                     muffled <- FALSE
[17:02:46.879]                     if (inherits(cond, "message")) {
[17:02:46.879]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:46.879]                       if (muffled) 
[17:02:46.879]                         invokeRestart("muffleMessage")
[17:02:46.879]                     }
[17:02:46.879]                     else if (inherits(cond, "warning")) {
[17:02:46.879]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:46.879]                       if (muffled) 
[17:02:46.879]                         invokeRestart("muffleWarning")
[17:02:46.879]                     }
[17:02:46.879]                     else if (inherits(cond, "condition")) {
[17:02:46.879]                       if (!is.null(pattern)) {
[17:02:46.879]                         computeRestarts <- base::computeRestarts
[17:02:46.879]                         grepl <- base::grepl
[17:02:46.879]                         restarts <- computeRestarts(cond)
[17:02:46.879]                         for (restart in restarts) {
[17:02:46.879]                           name <- restart$name
[17:02:46.879]                           if (is.null(name)) 
[17:02:46.879]                             next
[17:02:46.879]                           if (!grepl(pattern, name)) 
[17:02:46.879]                             next
[17:02:46.879]                           invokeRestart(restart)
[17:02:46.879]                           muffled <- TRUE
[17:02:46.879]                           break
[17:02:46.879]                         }
[17:02:46.879]                       }
[17:02:46.879]                     }
[17:02:46.879]                     invisible(muffled)
[17:02:46.879]                   }
[17:02:46.879]                   muffleCondition(cond)
[17:02:46.879]                 })
[17:02:46.879]             }))
[17:02:46.879]             future::FutureResult(value = ...future.value$value, 
[17:02:46.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.879]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.879]                     ...future.globalenv.names))
[17:02:46.879]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.879]         }, condition = base::local({
[17:02:46.879]             c <- base::c
[17:02:46.879]             inherits <- base::inherits
[17:02:46.879]             invokeRestart <- base::invokeRestart
[17:02:46.879]             length <- base::length
[17:02:46.879]             list <- base::list
[17:02:46.879]             seq.int <- base::seq.int
[17:02:46.879]             signalCondition <- base::signalCondition
[17:02:46.879]             sys.calls <- base::sys.calls
[17:02:46.879]             `[[` <- base::`[[`
[17:02:46.879]             `+` <- base::`+`
[17:02:46.879]             `<<-` <- base::`<<-`
[17:02:46.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.879]                   3L)]
[17:02:46.879]             }
[17:02:46.879]             function(cond) {
[17:02:46.879]                 is_error <- inherits(cond, "error")
[17:02:46.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.879]                   NULL)
[17:02:46.879]                 if (is_error) {
[17:02:46.879]                   sessionInformation <- function() {
[17:02:46.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.879]                       search = base::search(), system = base::Sys.info())
[17:02:46.879]                   }
[17:02:46.879]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.879]                     cond$call), session = sessionInformation(), 
[17:02:46.879]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.879]                   signalCondition(cond)
[17:02:46.879]                 }
[17:02:46.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.879]                 "immediateCondition"))) {
[17:02:46.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.879]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.879]                   if (TRUE && !signal) {
[17:02:46.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.879]                     {
[17:02:46.879]                       inherits <- base::inherits
[17:02:46.879]                       invokeRestart <- base::invokeRestart
[17:02:46.879]                       is.null <- base::is.null
[17:02:46.879]                       muffled <- FALSE
[17:02:46.879]                       if (inherits(cond, "message")) {
[17:02:46.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.879]                         if (muffled) 
[17:02:46.879]                           invokeRestart("muffleMessage")
[17:02:46.879]                       }
[17:02:46.879]                       else if (inherits(cond, "warning")) {
[17:02:46.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.879]                         if (muffled) 
[17:02:46.879]                           invokeRestart("muffleWarning")
[17:02:46.879]                       }
[17:02:46.879]                       else if (inherits(cond, "condition")) {
[17:02:46.879]                         if (!is.null(pattern)) {
[17:02:46.879]                           computeRestarts <- base::computeRestarts
[17:02:46.879]                           grepl <- base::grepl
[17:02:46.879]                           restarts <- computeRestarts(cond)
[17:02:46.879]                           for (restart in restarts) {
[17:02:46.879]                             name <- restart$name
[17:02:46.879]                             if (is.null(name)) 
[17:02:46.879]                               next
[17:02:46.879]                             if (!grepl(pattern, name)) 
[17:02:46.879]                               next
[17:02:46.879]                             invokeRestart(restart)
[17:02:46.879]                             muffled <- TRUE
[17:02:46.879]                             break
[17:02:46.879]                           }
[17:02:46.879]                         }
[17:02:46.879]                       }
[17:02:46.879]                       invisible(muffled)
[17:02:46.879]                     }
[17:02:46.879]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.879]                   }
[17:02:46.879]                 }
[17:02:46.879]                 else {
[17:02:46.879]                   if (TRUE) {
[17:02:46.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.879]                     {
[17:02:46.879]                       inherits <- base::inherits
[17:02:46.879]                       invokeRestart <- base::invokeRestart
[17:02:46.879]                       is.null <- base::is.null
[17:02:46.879]                       muffled <- FALSE
[17:02:46.879]                       if (inherits(cond, "message")) {
[17:02:46.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.879]                         if (muffled) 
[17:02:46.879]                           invokeRestart("muffleMessage")
[17:02:46.879]                       }
[17:02:46.879]                       else if (inherits(cond, "warning")) {
[17:02:46.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.879]                         if (muffled) 
[17:02:46.879]                           invokeRestart("muffleWarning")
[17:02:46.879]                       }
[17:02:46.879]                       else if (inherits(cond, "condition")) {
[17:02:46.879]                         if (!is.null(pattern)) {
[17:02:46.879]                           computeRestarts <- base::computeRestarts
[17:02:46.879]                           grepl <- base::grepl
[17:02:46.879]                           restarts <- computeRestarts(cond)
[17:02:46.879]                           for (restart in restarts) {
[17:02:46.879]                             name <- restart$name
[17:02:46.879]                             if (is.null(name)) 
[17:02:46.879]                               next
[17:02:46.879]                             if (!grepl(pattern, name)) 
[17:02:46.879]                               next
[17:02:46.879]                             invokeRestart(restart)
[17:02:46.879]                             muffled <- TRUE
[17:02:46.879]                             break
[17:02:46.879]                           }
[17:02:46.879]                         }
[17:02:46.879]                       }
[17:02:46.879]                       invisible(muffled)
[17:02:46.879]                     }
[17:02:46.879]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.879]                   }
[17:02:46.879]                 }
[17:02:46.879]             }
[17:02:46.879]         }))
[17:02:46.879]     }, error = function(ex) {
[17:02:46.879]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.879]                 ...future.rng), started = ...future.startTime, 
[17:02:46.879]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.879]             version = "1.8"), class = "FutureResult")
[17:02:46.879]     }, finally = {
[17:02:46.879]         if (!identical(...future.workdir, getwd())) 
[17:02:46.879]             setwd(...future.workdir)
[17:02:46.879]         {
[17:02:46.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.879]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.879]             }
[17:02:46.879]             base::options(...future.oldOptions)
[17:02:46.879]             if (.Platform$OS.type == "windows") {
[17:02:46.879]                 old_names <- names(...future.oldEnvVars)
[17:02:46.879]                 envs <- base::Sys.getenv()
[17:02:46.879]                 names <- names(envs)
[17:02:46.879]                 common <- intersect(names, old_names)
[17:02:46.879]                 added <- setdiff(names, old_names)
[17:02:46.879]                 removed <- setdiff(old_names, names)
[17:02:46.879]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.879]                   envs[common]]
[17:02:46.879]                 NAMES <- toupper(changed)
[17:02:46.879]                 args <- list()
[17:02:46.879]                 for (kk in seq_along(NAMES)) {
[17:02:46.879]                   name <- changed[[kk]]
[17:02:46.879]                   NAME <- NAMES[[kk]]
[17:02:46.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.879]                     next
[17:02:46.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.879]                 }
[17:02:46.879]                 NAMES <- toupper(added)
[17:02:46.879]                 for (kk in seq_along(NAMES)) {
[17:02:46.879]                   name <- added[[kk]]
[17:02:46.879]                   NAME <- NAMES[[kk]]
[17:02:46.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.879]                     next
[17:02:46.879]                   args[[name]] <- ""
[17:02:46.879]                 }
[17:02:46.879]                 NAMES <- toupper(removed)
[17:02:46.879]                 for (kk in seq_along(NAMES)) {
[17:02:46.879]                   name <- removed[[kk]]
[17:02:46.879]                   NAME <- NAMES[[kk]]
[17:02:46.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.879]                     next
[17:02:46.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.879]                 }
[17:02:46.879]                 if (length(args) > 0) 
[17:02:46.879]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.879]             }
[17:02:46.879]             else {
[17:02:46.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.879]             }
[17:02:46.879]             {
[17:02:46.879]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.879]                   0L) {
[17:02:46.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.879]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.879]                   base::options(opts)
[17:02:46.879]                 }
[17:02:46.879]                 {
[17:02:46.879]                   {
[17:02:46.879]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:46.879]                     NULL
[17:02:46.879]                   }
[17:02:46.879]                   options(future.plan = NULL)
[17:02:46.879]                   if (is.na(NA_character_)) 
[17:02:46.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.879]                     .init = FALSE)
[17:02:46.879]                 }
[17:02:46.879]             }
[17:02:46.879]         }
[17:02:46.879]     })
[17:02:46.879]     if (TRUE) {
[17:02:46.879]         base::sink(type = "output", split = FALSE)
[17:02:46.879]         if (TRUE) {
[17:02:46.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.879]         }
[17:02:46.879]         else {
[17:02:46.879]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.879]         }
[17:02:46.879]         base::close(...future.stdout)
[17:02:46.879]         ...future.stdout <- NULL
[17:02:46.879]     }
[17:02:46.879]     ...future.result$conditions <- ...future.conditions
[17:02:46.879]     ...future.result$finished <- base::Sys.time()
[17:02:46.879]     ...future.result
[17:02:46.879] }
[17:02:46.882] assign_globals() ...
[17:02:46.882] List of 1
[17:02:46.882]  $ x: list()
[17:02:46.882]  - attr(*, "where")=List of 1
[17:02:46.882]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.882]  - attr(*, "resolved")= logi TRUE
[17:02:46.882]  - attr(*, "total_size")= num 0
[17:02:46.882]  - attr(*, "already-done")= logi TRUE
[17:02:46.885] - copied ‘x’ to environment
[17:02:46.885] assign_globals() ... done
[17:02:46.885] requestCore(): workers = 2
[17:02:46.887] MulticoreFuture started
[17:02:46.887] - Launch lazy future ... done
[17:02:46.888] run() for ‘MulticoreFuture’ ... done
[17:02:46.888] result() for MulticoreFuture ...
[17:02:46.888] plan(): Setting new future strategy stack:
[17:02:46.889] List of future strategies:
[17:02:46.889] 1. sequential:
[17:02:46.889]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.889]    - tweaked: FALSE
[17:02:46.889]    - call: NULL
[17:02:46.890] plan(): nbrOfWorkers() = 1
[17:02:46.892] plan(): Setting new future strategy stack:
[17:02:46.892] List of future strategies:
[17:02:46.892] 1. multicore:
[17:02:46.892]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:46.892]    - tweaked: FALSE
[17:02:46.892]    - call: plan(strategy)
[17:02:46.897] plan(): nbrOfWorkers() = 2
[17:02:46.898] result() for MulticoreFuture ...
[17:02:46.898] result() for MulticoreFuture ... done
[17:02:46.898] result() for MulticoreFuture ... done
[17:02:46.898] result() for MulticoreFuture ...
[17:02:46.898] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.899] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.899] Searching for globals...
[17:02:46.902] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.902] Searching for globals ... DONE
[17:02:46.902] Resolving globals: TRUE
[17:02:46.902] Resolving any globals that are futures ...
[17:02:46.902] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.903] Resolving any globals that are futures ... DONE
[17:02:46.903] Resolving futures part of globals (recursively) ...
[17:02:46.904] resolve() on list ...
[17:02:46.904]  recursive: 99
[17:02:46.904]  length: 1
[17:02:46.904]  elements: ‘x’
[17:02:46.904]  length: 0 (resolved future 1)
[17:02:46.904] resolve() on list ... DONE
[17:02:46.904] - globals: [1] ‘x’
[17:02:46.904] Resolving futures part of globals (recursively) ... DONE
[17:02:46.905] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.905] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.905] - globals: [1] ‘x’
[17:02:46.905] 
[17:02:46.905] getGlobalsAndPackages() ... DONE
[17:02:46.906] run() for ‘Future’ ...
[17:02:46.906] - state: ‘created’
[17:02:46.906] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:46.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:46.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:46.913]   - Field: ‘label’
[17:02:46.913]   - Field: ‘local’
[17:02:46.913]   - Field: ‘owner’
[17:02:46.914]   - Field: ‘envir’
[17:02:46.914]   - Field: ‘workers’
[17:02:46.914]   - Field: ‘packages’
[17:02:46.914]   - Field: ‘gc’
[17:02:46.914]   - Field: ‘job’
[17:02:46.914]   - Field: ‘conditions’
[17:02:46.914]   - Field: ‘expr’
[17:02:46.914]   - Field: ‘uuid’
[17:02:46.915]   - Field: ‘seed’
[17:02:46.915]   - Field: ‘version’
[17:02:46.915]   - Field: ‘result’
[17:02:46.915]   - Field: ‘asynchronous’
[17:02:46.915]   - Field: ‘calls’
[17:02:46.915]   - Field: ‘globals’
[17:02:46.915]   - Field: ‘stdout’
[17:02:46.915]   - Field: ‘earlySignal’
[17:02:46.916]   - Field: ‘lazy’
[17:02:46.916]   - Field: ‘state’
[17:02:46.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:46.916] - Launch lazy future ...
[17:02:46.916] Packages needed by the future expression (n = 0): <none>
[17:02:46.916] Packages needed by future strategies (n = 0): <none>
[17:02:46.917] {
[17:02:46.917]     {
[17:02:46.917]         {
[17:02:46.917]             ...future.startTime <- base::Sys.time()
[17:02:46.917]             {
[17:02:46.917]                 {
[17:02:46.917]                   {
[17:02:46.917]                     {
[17:02:46.917]                       base::local({
[17:02:46.917]                         has_future <- base::requireNamespace("future", 
[17:02:46.917]                           quietly = TRUE)
[17:02:46.917]                         if (has_future) {
[17:02:46.917]                           ns <- base::getNamespace("future")
[17:02:46.917]                           version <- ns[[".package"]][["version"]]
[17:02:46.917]                           if (is.null(version)) 
[17:02:46.917]                             version <- utils::packageVersion("future")
[17:02:46.917]                         }
[17:02:46.917]                         else {
[17:02:46.917]                           version <- NULL
[17:02:46.917]                         }
[17:02:46.917]                         if (!has_future || version < "1.8.0") {
[17:02:46.917]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.917]                             "", base::R.version$version.string), 
[17:02:46.917]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:46.917]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.917]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.917]                               "release", "version")], collapse = " "), 
[17:02:46.917]                             hostname = base::Sys.info()[["nodename"]])
[17:02:46.917]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.917]                             info)
[17:02:46.917]                           info <- base::paste(info, collapse = "; ")
[17:02:46.917]                           if (!has_future) {
[17:02:46.917]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.917]                               info)
[17:02:46.917]                           }
[17:02:46.917]                           else {
[17:02:46.917]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.917]                               info, version)
[17:02:46.917]                           }
[17:02:46.917]                           base::stop(msg)
[17:02:46.917]                         }
[17:02:46.917]                       })
[17:02:46.917]                     }
[17:02:46.917]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:46.917]                     base::options(mc.cores = 1L)
[17:02:46.917]                   }
[17:02:46.917]                   ...future.strategy.old <- future::plan("list")
[17:02:46.917]                   options(future.plan = NULL)
[17:02:46.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.917]                 }
[17:02:46.917]                 ...future.workdir <- getwd()
[17:02:46.917]             }
[17:02:46.917]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.917]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.917]         }
[17:02:46.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.917]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.917]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.917]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.917]             base::names(...future.oldOptions))
[17:02:46.917]     }
[17:02:46.917]     if (FALSE) {
[17:02:46.917]     }
[17:02:46.917]     else {
[17:02:46.917]         if (TRUE) {
[17:02:46.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.917]                 open = "w")
[17:02:46.917]         }
[17:02:46.917]         else {
[17:02:46.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.917]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.917]         }
[17:02:46.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.917]             base::sink(type = "output", split = FALSE)
[17:02:46.917]             base::close(...future.stdout)
[17:02:46.917]         }, add = TRUE)
[17:02:46.917]     }
[17:02:46.917]     ...future.frame <- base::sys.nframe()
[17:02:46.917]     ...future.conditions <- base::list()
[17:02:46.917]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.917]     if (FALSE) {
[17:02:46.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.917]     }
[17:02:46.917]     ...future.result <- base::tryCatch({
[17:02:46.917]         base::withCallingHandlers({
[17:02:46.917]             ...future.value <- base::withVisible(base::local({
[17:02:46.917]                 withCallingHandlers({
[17:02:46.917]                   {
[17:02:46.917]                     x$a <- 1
[17:02:46.917]                     x
[17:02:46.917]                   }
[17:02:46.917]                 }, immediateCondition = function(cond) {
[17:02:46.917]                   save_rds <- function (object, pathname, ...) 
[17:02:46.917]                   {
[17:02:46.917]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:46.917]                     if (file_test("-f", pathname_tmp)) {
[17:02:46.917]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.917]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:46.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.917]                         fi_tmp[["mtime"]])
[17:02:46.917]                     }
[17:02:46.917]                     tryCatch({
[17:02:46.917]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:46.917]                     }, error = function(ex) {
[17:02:46.917]                       msg <- conditionMessage(ex)
[17:02:46.917]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.917]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:46.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.917]                         fi_tmp[["mtime"]], msg)
[17:02:46.917]                       ex$message <- msg
[17:02:46.917]                       stop(ex)
[17:02:46.917]                     })
[17:02:46.917]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:46.917]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:46.917]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:46.917]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.917]                       fi <- file.info(pathname)
[17:02:46.917]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:46.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.917]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:46.917]                         fi[["size"]], fi[["mtime"]])
[17:02:46.917]                       stop(msg)
[17:02:46.917]                     }
[17:02:46.917]                     invisible(pathname)
[17:02:46.917]                   }
[17:02:46.917]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:46.917]                     rootPath = tempdir()) 
[17:02:46.917]                   {
[17:02:46.917]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:46.917]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:46.917]                       tmpdir = path, fileext = ".rds")
[17:02:46.917]                     save_rds(obj, file)
[17:02:46.917]                   }
[17:02:46.917]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:46.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.917]                   {
[17:02:46.917]                     inherits <- base::inherits
[17:02:46.917]                     invokeRestart <- base::invokeRestart
[17:02:46.917]                     is.null <- base::is.null
[17:02:46.917]                     muffled <- FALSE
[17:02:46.917]                     if (inherits(cond, "message")) {
[17:02:46.917]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:46.917]                       if (muffled) 
[17:02:46.917]                         invokeRestart("muffleMessage")
[17:02:46.917]                     }
[17:02:46.917]                     else if (inherits(cond, "warning")) {
[17:02:46.917]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:46.917]                       if (muffled) 
[17:02:46.917]                         invokeRestart("muffleWarning")
[17:02:46.917]                     }
[17:02:46.917]                     else if (inherits(cond, "condition")) {
[17:02:46.917]                       if (!is.null(pattern)) {
[17:02:46.917]                         computeRestarts <- base::computeRestarts
[17:02:46.917]                         grepl <- base::grepl
[17:02:46.917]                         restarts <- computeRestarts(cond)
[17:02:46.917]                         for (restart in restarts) {
[17:02:46.917]                           name <- restart$name
[17:02:46.917]                           if (is.null(name)) 
[17:02:46.917]                             next
[17:02:46.917]                           if (!grepl(pattern, name)) 
[17:02:46.917]                             next
[17:02:46.917]                           invokeRestart(restart)
[17:02:46.917]                           muffled <- TRUE
[17:02:46.917]                           break
[17:02:46.917]                         }
[17:02:46.917]                       }
[17:02:46.917]                     }
[17:02:46.917]                     invisible(muffled)
[17:02:46.917]                   }
[17:02:46.917]                   muffleCondition(cond)
[17:02:46.917]                 })
[17:02:46.917]             }))
[17:02:46.917]             future::FutureResult(value = ...future.value$value, 
[17:02:46.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.917]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.917]                     ...future.globalenv.names))
[17:02:46.917]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.917]         }, condition = base::local({
[17:02:46.917]             c <- base::c
[17:02:46.917]             inherits <- base::inherits
[17:02:46.917]             invokeRestart <- base::invokeRestart
[17:02:46.917]             length <- base::length
[17:02:46.917]             list <- base::list
[17:02:46.917]             seq.int <- base::seq.int
[17:02:46.917]             signalCondition <- base::signalCondition
[17:02:46.917]             sys.calls <- base::sys.calls
[17:02:46.917]             `[[` <- base::`[[`
[17:02:46.917]             `+` <- base::`+`
[17:02:46.917]             `<<-` <- base::`<<-`
[17:02:46.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.917]                   3L)]
[17:02:46.917]             }
[17:02:46.917]             function(cond) {
[17:02:46.917]                 is_error <- inherits(cond, "error")
[17:02:46.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.917]                   NULL)
[17:02:46.917]                 if (is_error) {
[17:02:46.917]                   sessionInformation <- function() {
[17:02:46.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.917]                       search = base::search(), system = base::Sys.info())
[17:02:46.917]                   }
[17:02:46.917]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.917]                     cond$call), session = sessionInformation(), 
[17:02:46.917]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.917]                   signalCondition(cond)
[17:02:46.917]                 }
[17:02:46.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.917]                 "immediateCondition"))) {
[17:02:46.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.917]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.917]                   if (TRUE && !signal) {
[17:02:46.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.917]                     {
[17:02:46.917]                       inherits <- base::inherits
[17:02:46.917]                       invokeRestart <- base::invokeRestart
[17:02:46.917]                       is.null <- base::is.null
[17:02:46.917]                       muffled <- FALSE
[17:02:46.917]                       if (inherits(cond, "message")) {
[17:02:46.917]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.917]                         if (muffled) 
[17:02:46.917]                           invokeRestart("muffleMessage")
[17:02:46.917]                       }
[17:02:46.917]                       else if (inherits(cond, "warning")) {
[17:02:46.917]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.917]                         if (muffled) 
[17:02:46.917]                           invokeRestart("muffleWarning")
[17:02:46.917]                       }
[17:02:46.917]                       else if (inherits(cond, "condition")) {
[17:02:46.917]                         if (!is.null(pattern)) {
[17:02:46.917]                           computeRestarts <- base::computeRestarts
[17:02:46.917]                           grepl <- base::grepl
[17:02:46.917]                           restarts <- computeRestarts(cond)
[17:02:46.917]                           for (restart in restarts) {
[17:02:46.917]                             name <- restart$name
[17:02:46.917]                             if (is.null(name)) 
[17:02:46.917]                               next
[17:02:46.917]                             if (!grepl(pattern, name)) 
[17:02:46.917]                               next
[17:02:46.917]                             invokeRestart(restart)
[17:02:46.917]                             muffled <- TRUE
[17:02:46.917]                             break
[17:02:46.917]                           }
[17:02:46.917]                         }
[17:02:46.917]                       }
[17:02:46.917]                       invisible(muffled)
[17:02:46.917]                     }
[17:02:46.917]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.917]                   }
[17:02:46.917]                 }
[17:02:46.917]                 else {
[17:02:46.917]                   if (TRUE) {
[17:02:46.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.917]                     {
[17:02:46.917]                       inherits <- base::inherits
[17:02:46.917]                       invokeRestart <- base::invokeRestart
[17:02:46.917]                       is.null <- base::is.null
[17:02:46.917]                       muffled <- FALSE
[17:02:46.917]                       if (inherits(cond, "message")) {
[17:02:46.917]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.917]                         if (muffled) 
[17:02:46.917]                           invokeRestart("muffleMessage")
[17:02:46.917]                       }
[17:02:46.917]                       else if (inherits(cond, "warning")) {
[17:02:46.917]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.917]                         if (muffled) 
[17:02:46.917]                           invokeRestart("muffleWarning")
[17:02:46.917]                       }
[17:02:46.917]                       else if (inherits(cond, "condition")) {
[17:02:46.917]                         if (!is.null(pattern)) {
[17:02:46.917]                           computeRestarts <- base::computeRestarts
[17:02:46.917]                           grepl <- base::grepl
[17:02:46.917]                           restarts <- computeRestarts(cond)
[17:02:46.917]                           for (restart in restarts) {
[17:02:46.917]                             name <- restart$name
[17:02:46.917]                             if (is.null(name)) 
[17:02:46.917]                               next
[17:02:46.917]                             if (!grepl(pattern, name)) 
[17:02:46.917]                               next
[17:02:46.917]                             invokeRestart(restart)
[17:02:46.917]                             muffled <- TRUE
[17:02:46.917]                             break
[17:02:46.917]                           }
[17:02:46.917]                         }
[17:02:46.917]                       }
[17:02:46.917]                       invisible(muffled)
[17:02:46.917]                     }
[17:02:46.917]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.917]                   }
[17:02:46.917]                 }
[17:02:46.917]             }
[17:02:46.917]         }))
[17:02:46.917]     }, error = function(ex) {
[17:02:46.917]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.917]                 ...future.rng), started = ...future.startTime, 
[17:02:46.917]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.917]             version = "1.8"), class = "FutureResult")
[17:02:46.917]     }, finally = {
[17:02:46.917]         if (!identical(...future.workdir, getwd())) 
[17:02:46.917]             setwd(...future.workdir)
[17:02:46.917]         {
[17:02:46.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.917]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.917]             }
[17:02:46.917]             base::options(...future.oldOptions)
[17:02:46.917]             if (.Platform$OS.type == "windows") {
[17:02:46.917]                 old_names <- names(...future.oldEnvVars)
[17:02:46.917]                 envs <- base::Sys.getenv()
[17:02:46.917]                 names <- names(envs)
[17:02:46.917]                 common <- intersect(names, old_names)
[17:02:46.917]                 added <- setdiff(names, old_names)
[17:02:46.917]                 removed <- setdiff(old_names, names)
[17:02:46.917]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.917]                   envs[common]]
[17:02:46.917]                 NAMES <- toupper(changed)
[17:02:46.917]                 args <- list()
[17:02:46.917]                 for (kk in seq_along(NAMES)) {
[17:02:46.917]                   name <- changed[[kk]]
[17:02:46.917]                   NAME <- NAMES[[kk]]
[17:02:46.917]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.917]                     next
[17:02:46.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.917]                 }
[17:02:46.917]                 NAMES <- toupper(added)
[17:02:46.917]                 for (kk in seq_along(NAMES)) {
[17:02:46.917]                   name <- added[[kk]]
[17:02:46.917]                   NAME <- NAMES[[kk]]
[17:02:46.917]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.917]                     next
[17:02:46.917]                   args[[name]] <- ""
[17:02:46.917]                 }
[17:02:46.917]                 NAMES <- toupper(removed)
[17:02:46.917]                 for (kk in seq_along(NAMES)) {
[17:02:46.917]                   name <- removed[[kk]]
[17:02:46.917]                   NAME <- NAMES[[kk]]
[17:02:46.917]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.917]                     next
[17:02:46.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.917]                 }
[17:02:46.917]                 if (length(args) > 0) 
[17:02:46.917]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.917]             }
[17:02:46.917]             else {
[17:02:46.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.917]             }
[17:02:46.917]             {
[17:02:46.917]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.917]                   0L) {
[17:02:46.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.917]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.917]                   base::options(opts)
[17:02:46.917]                 }
[17:02:46.917]                 {
[17:02:46.917]                   {
[17:02:46.917]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:46.917]                     NULL
[17:02:46.917]                   }
[17:02:46.917]                   options(future.plan = NULL)
[17:02:46.917]                   if (is.na(NA_character_)) 
[17:02:46.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.917]                     .init = FALSE)
[17:02:46.917]                 }
[17:02:46.917]             }
[17:02:46.917]         }
[17:02:46.917]     })
[17:02:46.917]     if (TRUE) {
[17:02:46.917]         base::sink(type = "output", split = FALSE)
[17:02:46.917]         if (TRUE) {
[17:02:46.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.917]         }
[17:02:46.917]         else {
[17:02:46.917]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.917]         }
[17:02:46.917]         base::close(...future.stdout)
[17:02:46.917]         ...future.stdout <- NULL
[17:02:46.917]     }
[17:02:46.917]     ...future.result$conditions <- ...future.conditions
[17:02:46.917]     ...future.result$finished <- base::Sys.time()
[17:02:46.917]     ...future.result
[17:02:46.917] }
[17:02:46.919] assign_globals() ...
[17:02:46.919] List of 1
[17:02:46.919]  $ x: list()
[17:02:46.919]  - attr(*, "where")=List of 1
[17:02:46.919]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.919]  - attr(*, "resolved")= logi TRUE
[17:02:46.919]  - attr(*, "total_size")= num 0
[17:02:46.919]  - attr(*, "already-done")= logi TRUE
[17:02:46.922] - copied ‘x’ to environment
[17:02:46.923] assign_globals() ... done
[17:02:46.923] requestCore(): workers = 2
[17:02:46.925] MulticoreFuture started
[17:02:46.925] - Launch lazy future ... done
[17:02:46.925] run() for ‘MulticoreFuture’ ... done
[17:02:46.926] result() for MulticoreFuture ...
[17:02:46.926] plan(): Setting new future strategy stack:
[17:02:46.926] List of future strategies:
[17:02:46.926] 1. sequential:
[17:02:46.926]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.926]    - tweaked: FALSE
[17:02:46.926]    - call: NULL
[17:02:46.927] plan(): nbrOfWorkers() = 1
[17:02:46.929] plan(): Setting new future strategy stack:
[17:02:46.929] List of future strategies:
[17:02:46.929] 1. multicore:
[17:02:46.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:46.929]    - tweaked: FALSE
[17:02:46.929]    - call: plan(strategy)
[17:02:46.935] plan(): nbrOfWorkers() = 2
[17:02:46.936] result() for MulticoreFuture ...
[17:02:46.936] result() for MulticoreFuture ... done
[17:02:46.936] result() for MulticoreFuture ... done
[17:02:46.936] result() for MulticoreFuture ...
[17:02:46.936] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.937] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.937] Searching for globals...
[17:02:46.940] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.940] Searching for globals ... DONE
[17:02:46.940] Resolving globals: TRUE
[17:02:46.940] Resolving any globals that are futures ...
[17:02:46.941] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:46.941] Resolving any globals that are futures ... DONE
[17:02:46.941] Resolving futures part of globals (recursively) ...
[17:02:46.942] resolve() on list ...
[17:02:46.942]  recursive: 99
[17:02:46.942]  length: 1
[17:02:46.942]  elements: ‘x’
[17:02:46.942]  length: 0 (resolved future 1)
[17:02:46.942] resolve() on list ... DONE
[17:02:46.942] - globals: [1] ‘x’
[17:02:46.942] Resolving futures part of globals (recursively) ... DONE
[17:02:46.943] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:46.943] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:46.943] - globals: [1] ‘x’
[17:02:46.943] 
[17:02:46.943] getGlobalsAndPackages() ... DONE
[17:02:46.944] run() for ‘Future’ ...
[17:02:46.944] - state: ‘created’
[17:02:46.944] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:46.948] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:46.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:46.949]   - Field: ‘label’
[17:02:46.949]   - Field: ‘local’
[17:02:46.949]   - Field: ‘owner’
[17:02:46.949]   - Field: ‘envir’
[17:02:46.949]   - Field: ‘workers’
[17:02:46.949]   - Field: ‘packages’
[17:02:46.949]   - Field: ‘gc’
[17:02:46.949]   - Field: ‘job’
[17:02:46.949]   - Field: ‘conditions’
[17:02:46.950]   - Field: ‘expr’
[17:02:46.950]   - Field: ‘uuid’
[17:02:46.950]   - Field: ‘seed’
[17:02:46.950]   - Field: ‘version’
[17:02:46.950]   - Field: ‘result’
[17:02:46.950]   - Field: ‘asynchronous’
[17:02:46.950]   - Field: ‘calls’
[17:02:46.950]   - Field: ‘globals’
[17:02:46.950]   - Field: ‘stdout’
[17:02:46.951]   - Field: ‘earlySignal’
[17:02:46.951]   - Field: ‘lazy’
[17:02:46.951]   - Field: ‘state’
[17:02:46.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:46.951] - Launch lazy future ...
[17:02:46.951] Packages needed by the future expression (n = 0): <none>
[17:02:46.952] Packages needed by future strategies (n = 0): <none>
[17:02:46.952] {
[17:02:46.952]     {
[17:02:46.952]         {
[17:02:46.952]             ...future.startTime <- base::Sys.time()
[17:02:46.952]             {
[17:02:46.952]                 {
[17:02:46.952]                   {
[17:02:46.952]                     {
[17:02:46.952]                       base::local({
[17:02:46.952]                         has_future <- base::requireNamespace("future", 
[17:02:46.952]                           quietly = TRUE)
[17:02:46.952]                         if (has_future) {
[17:02:46.952]                           ns <- base::getNamespace("future")
[17:02:46.952]                           version <- ns[[".package"]][["version"]]
[17:02:46.952]                           if (is.null(version)) 
[17:02:46.952]                             version <- utils::packageVersion("future")
[17:02:46.952]                         }
[17:02:46.952]                         else {
[17:02:46.952]                           version <- NULL
[17:02:46.952]                         }
[17:02:46.952]                         if (!has_future || version < "1.8.0") {
[17:02:46.952]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.952]                             "", base::R.version$version.string), 
[17:02:46.952]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:46.952]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.952]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.952]                               "release", "version")], collapse = " "), 
[17:02:46.952]                             hostname = base::Sys.info()[["nodename"]])
[17:02:46.952]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.952]                             info)
[17:02:46.952]                           info <- base::paste(info, collapse = "; ")
[17:02:46.952]                           if (!has_future) {
[17:02:46.952]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.952]                               info)
[17:02:46.952]                           }
[17:02:46.952]                           else {
[17:02:46.952]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.952]                               info, version)
[17:02:46.952]                           }
[17:02:46.952]                           base::stop(msg)
[17:02:46.952]                         }
[17:02:46.952]                       })
[17:02:46.952]                     }
[17:02:46.952]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:46.952]                     base::options(mc.cores = 1L)
[17:02:46.952]                   }
[17:02:46.952]                   ...future.strategy.old <- future::plan("list")
[17:02:46.952]                   options(future.plan = NULL)
[17:02:46.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.952]                 }
[17:02:46.952]                 ...future.workdir <- getwd()
[17:02:46.952]             }
[17:02:46.952]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.952]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.952]         }
[17:02:46.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.952]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.952]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.952]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.952]             base::names(...future.oldOptions))
[17:02:46.952]     }
[17:02:46.952]     if (FALSE) {
[17:02:46.952]     }
[17:02:46.952]     else {
[17:02:46.952]         if (TRUE) {
[17:02:46.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.952]                 open = "w")
[17:02:46.952]         }
[17:02:46.952]         else {
[17:02:46.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.952]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.952]         }
[17:02:46.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.952]             base::sink(type = "output", split = FALSE)
[17:02:46.952]             base::close(...future.stdout)
[17:02:46.952]         }, add = TRUE)
[17:02:46.952]     }
[17:02:46.952]     ...future.frame <- base::sys.nframe()
[17:02:46.952]     ...future.conditions <- base::list()
[17:02:46.952]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.952]     if (FALSE) {
[17:02:46.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.952]     }
[17:02:46.952]     ...future.result <- base::tryCatch({
[17:02:46.952]         base::withCallingHandlers({
[17:02:46.952]             ...future.value <- base::withVisible(base::local({
[17:02:46.952]                 withCallingHandlers({
[17:02:46.952]                   {
[17:02:46.952]                     x$a <- 1
[17:02:46.952]                     x
[17:02:46.952]                   }
[17:02:46.952]                 }, immediateCondition = function(cond) {
[17:02:46.952]                   save_rds <- function (object, pathname, ...) 
[17:02:46.952]                   {
[17:02:46.952]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:46.952]                     if (file_test("-f", pathname_tmp)) {
[17:02:46.952]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.952]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:46.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.952]                         fi_tmp[["mtime"]])
[17:02:46.952]                     }
[17:02:46.952]                     tryCatch({
[17:02:46.952]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:46.952]                     }, error = function(ex) {
[17:02:46.952]                       msg <- conditionMessage(ex)
[17:02:46.952]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.952]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:46.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.952]                         fi_tmp[["mtime"]], msg)
[17:02:46.952]                       ex$message <- msg
[17:02:46.952]                       stop(ex)
[17:02:46.952]                     })
[17:02:46.952]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:46.952]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:46.952]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:46.952]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.952]                       fi <- file.info(pathname)
[17:02:46.952]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:46.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.952]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:46.952]                         fi[["size"]], fi[["mtime"]])
[17:02:46.952]                       stop(msg)
[17:02:46.952]                     }
[17:02:46.952]                     invisible(pathname)
[17:02:46.952]                   }
[17:02:46.952]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:46.952]                     rootPath = tempdir()) 
[17:02:46.952]                   {
[17:02:46.952]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:46.952]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:46.952]                       tmpdir = path, fileext = ".rds")
[17:02:46.952]                     save_rds(obj, file)
[17:02:46.952]                   }
[17:02:46.952]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:46.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.952]                   {
[17:02:46.952]                     inherits <- base::inherits
[17:02:46.952]                     invokeRestart <- base::invokeRestart
[17:02:46.952]                     is.null <- base::is.null
[17:02:46.952]                     muffled <- FALSE
[17:02:46.952]                     if (inherits(cond, "message")) {
[17:02:46.952]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:46.952]                       if (muffled) 
[17:02:46.952]                         invokeRestart("muffleMessage")
[17:02:46.952]                     }
[17:02:46.952]                     else if (inherits(cond, "warning")) {
[17:02:46.952]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:46.952]                       if (muffled) 
[17:02:46.952]                         invokeRestart("muffleWarning")
[17:02:46.952]                     }
[17:02:46.952]                     else if (inherits(cond, "condition")) {
[17:02:46.952]                       if (!is.null(pattern)) {
[17:02:46.952]                         computeRestarts <- base::computeRestarts
[17:02:46.952]                         grepl <- base::grepl
[17:02:46.952]                         restarts <- computeRestarts(cond)
[17:02:46.952]                         for (restart in restarts) {
[17:02:46.952]                           name <- restart$name
[17:02:46.952]                           if (is.null(name)) 
[17:02:46.952]                             next
[17:02:46.952]                           if (!grepl(pattern, name)) 
[17:02:46.952]                             next
[17:02:46.952]                           invokeRestart(restart)
[17:02:46.952]                           muffled <- TRUE
[17:02:46.952]                           break
[17:02:46.952]                         }
[17:02:46.952]                       }
[17:02:46.952]                     }
[17:02:46.952]                     invisible(muffled)
[17:02:46.952]                   }
[17:02:46.952]                   muffleCondition(cond)
[17:02:46.952]                 })
[17:02:46.952]             }))
[17:02:46.952]             future::FutureResult(value = ...future.value$value, 
[17:02:46.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.952]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.952]                     ...future.globalenv.names))
[17:02:46.952]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.952]         }, condition = base::local({
[17:02:46.952]             c <- base::c
[17:02:46.952]             inherits <- base::inherits
[17:02:46.952]             invokeRestart <- base::invokeRestart
[17:02:46.952]             length <- base::length
[17:02:46.952]             list <- base::list
[17:02:46.952]             seq.int <- base::seq.int
[17:02:46.952]             signalCondition <- base::signalCondition
[17:02:46.952]             sys.calls <- base::sys.calls
[17:02:46.952]             `[[` <- base::`[[`
[17:02:46.952]             `+` <- base::`+`
[17:02:46.952]             `<<-` <- base::`<<-`
[17:02:46.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.952]                   3L)]
[17:02:46.952]             }
[17:02:46.952]             function(cond) {
[17:02:46.952]                 is_error <- inherits(cond, "error")
[17:02:46.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.952]                   NULL)
[17:02:46.952]                 if (is_error) {
[17:02:46.952]                   sessionInformation <- function() {
[17:02:46.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.952]                       search = base::search(), system = base::Sys.info())
[17:02:46.952]                   }
[17:02:46.952]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.952]                     cond$call), session = sessionInformation(), 
[17:02:46.952]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.952]                   signalCondition(cond)
[17:02:46.952]                 }
[17:02:46.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.952]                 "immediateCondition"))) {
[17:02:46.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.952]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.952]                   if (TRUE && !signal) {
[17:02:46.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.952]                     {
[17:02:46.952]                       inherits <- base::inherits
[17:02:46.952]                       invokeRestart <- base::invokeRestart
[17:02:46.952]                       is.null <- base::is.null
[17:02:46.952]                       muffled <- FALSE
[17:02:46.952]                       if (inherits(cond, "message")) {
[17:02:46.952]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.952]                         if (muffled) 
[17:02:46.952]                           invokeRestart("muffleMessage")
[17:02:46.952]                       }
[17:02:46.952]                       else if (inherits(cond, "warning")) {
[17:02:46.952]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.952]                         if (muffled) 
[17:02:46.952]                           invokeRestart("muffleWarning")
[17:02:46.952]                       }
[17:02:46.952]                       else if (inherits(cond, "condition")) {
[17:02:46.952]                         if (!is.null(pattern)) {
[17:02:46.952]                           computeRestarts <- base::computeRestarts
[17:02:46.952]                           grepl <- base::grepl
[17:02:46.952]                           restarts <- computeRestarts(cond)
[17:02:46.952]                           for (restart in restarts) {
[17:02:46.952]                             name <- restart$name
[17:02:46.952]                             if (is.null(name)) 
[17:02:46.952]                               next
[17:02:46.952]                             if (!grepl(pattern, name)) 
[17:02:46.952]                               next
[17:02:46.952]                             invokeRestart(restart)
[17:02:46.952]                             muffled <- TRUE
[17:02:46.952]                             break
[17:02:46.952]                           }
[17:02:46.952]                         }
[17:02:46.952]                       }
[17:02:46.952]                       invisible(muffled)
[17:02:46.952]                     }
[17:02:46.952]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.952]                   }
[17:02:46.952]                 }
[17:02:46.952]                 else {
[17:02:46.952]                   if (TRUE) {
[17:02:46.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.952]                     {
[17:02:46.952]                       inherits <- base::inherits
[17:02:46.952]                       invokeRestart <- base::invokeRestart
[17:02:46.952]                       is.null <- base::is.null
[17:02:46.952]                       muffled <- FALSE
[17:02:46.952]                       if (inherits(cond, "message")) {
[17:02:46.952]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.952]                         if (muffled) 
[17:02:46.952]                           invokeRestart("muffleMessage")
[17:02:46.952]                       }
[17:02:46.952]                       else if (inherits(cond, "warning")) {
[17:02:46.952]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.952]                         if (muffled) 
[17:02:46.952]                           invokeRestart("muffleWarning")
[17:02:46.952]                       }
[17:02:46.952]                       else if (inherits(cond, "condition")) {
[17:02:46.952]                         if (!is.null(pattern)) {
[17:02:46.952]                           computeRestarts <- base::computeRestarts
[17:02:46.952]                           grepl <- base::grepl
[17:02:46.952]                           restarts <- computeRestarts(cond)
[17:02:46.952]                           for (restart in restarts) {
[17:02:46.952]                             name <- restart$name
[17:02:46.952]                             if (is.null(name)) 
[17:02:46.952]                               next
[17:02:46.952]                             if (!grepl(pattern, name)) 
[17:02:46.952]                               next
[17:02:46.952]                             invokeRestart(restart)
[17:02:46.952]                             muffled <- TRUE
[17:02:46.952]                             break
[17:02:46.952]                           }
[17:02:46.952]                         }
[17:02:46.952]                       }
[17:02:46.952]                       invisible(muffled)
[17:02:46.952]                     }
[17:02:46.952]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.952]                   }
[17:02:46.952]                 }
[17:02:46.952]             }
[17:02:46.952]         }))
[17:02:46.952]     }, error = function(ex) {
[17:02:46.952]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.952]                 ...future.rng), started = ...future.startTime, 
[17:02:46.952]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.952]             version = "1.8"), class = "FutureResult")
[17:02:46.952]     }, finally = {
[17:02:46.952]         if (!identical(...future.workdir, getwd())) 
[17:02:46.952]             setwd(...future.workdir)
[17:02:46.952]         {
[17:02:46.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.952]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.952]             }
[17:02:46.952]             base::options(...future.oldOptions)
[17:02:46.952]             if (.Platform$OS.type == "windows") {
[17:02:46.952]                 old_names <- names(...future.oldEnvVars)
[17:02:46.952]                 envs <- base::Sys.getenv()
[17:02:46.952]                 names <- names(envs)
[17:02:46.952]                 common <- intersect(names, old_names)
[17:02:46.952]                 added <- setdiff(names, old_names)
[17:02:46.952]                 removed <- setdiff(old_names, names)
[17:02:46.952]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.952]                   envs[common]]
[17:02:46.952]                 NAMES <- toupper(changed)
[17:02:46.952]                 args <- list()
[17:02:46.952]                 for (kk in seq_along(NAMES)) {
[17:02:46.952]                   name <- changed[[kk]]
[17:02:46.952]                   NAME <- NAMES[[kk]]
[17:02:46.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.952]                     next
[17:02:46.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.952]                 }
[17:02:46.952]                 NAMES <- toupper(added)
[17:02:46.952]                 for (kk in seq_along(NAMES)) {
[17:02:46.952]                   name <- added[[kk]]
[17:02:46.952]                   NAME <- NAMES[[kk]]
[17:02:46.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.952]                     next
[17:02:46.952]                   args[[name]] <- ""
[17:02:46.952]                 }
[17:02:46.952]                 NAMES <- toupper(removed)
[17:02:46.952]                 for (kk in seq_along(NAMES)) {
[17:02:46.952]                   name <- removed[[kk]]
[17:02:46.952]                   NAME <- NAMES[[kk]]
[17:02:46.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.952]                     next
[17:02:46.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.952]                 }
[17:02:46.952]                 if (length(args) > 0) 
[17:02:46.952]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.952]             }
[17:02:46.952]             else {
[17:02:46.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.952]             }
[17:02:46.952]             {
[17:02:46.952]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.952]                   0L) {
[17:02:46.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.952]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.952]                   base::options(opts)
[17:02:46.952]                 }
[17:02:46.952]                 {
[17:02:46.952]                   {
[17:02:46.952]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:46.952]                     NULL
[17:02:46.952]                   }
[17:02:46.952]                   options(future.plan = NULL)
[17:02:46.952]                   if (is.na(NA_character_)) 
[17:02:46.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.952]                     .init = FALSE)
[17:02:46.952]                 }
[17:02:46.952]             }
[17:02:46.952]         }
[17:02:46.952]     })
[17:02:46.952]     if (TRUE) {
[17:02:46.952]         base::sink(type = "output", split = FALSE)
[17:02:46.952]         if (TRUE) {
[17:02:46.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.952]         }
[17:02:46.952]         else {
[17:02:46.952]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.952]         }
[17:02:46.952]         base::close(...future.stdout)
[17:02:46.952]         ...future.stdout <- NULL
[17:02:46.952]     }
[17:02:46.952]     ...future.result$conditions <- ...future.conditions
[17:02:46.952]     ...future.result$finished <- base::Sys.time()
[17:02:46.952]     ...future.result
[17:02:46.952] }
[17:02:46.955] assign_globals() ...
[17:02:46.955] List of 1
[17:02:46.955]  $ x: list()
[17:02:46.955]  - attr(*, "where")=List of 1
[17:02:46.955]   ..$ x:<environment: R_EmptyEnv> 
[17:02:46.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:46.955]  - attr(*, "resolved")= logi TRUE
[17:02:46.955]  - attr(*, "total_size")= num 0
[17:02:46.955]  - attr(*, "already-done")= logi TRUE
[17:02:46.958] - copied ‘x’ to environment
[17:02:46.958] assign_globals() ... done
[17:02:46.958] requestCore(): workers = 2
[17:02:46.960] MulticoreFuture started
[17:02:46.960] - Launch lazy future ... done
[17:02:46.961] run() for ‘MulticoreFuture’ ... done
[17:02:46.961] result() for MulticoreFuture ...
[17:02:46.961] plan(): Setting new future strategy stack:
[17:02:46.961] List of future strategies:
[17:02:46.961] 1. sequential:
[17:02:46.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:46.961]    - tweaked: FALSE
[17:02:46.961]    - call: NULL
[17:02:46.962] plan(): nbrOfWorkers() = 1
[17:02:46.964] plan(): Setting new future strategy stack:
[17:02:46.965] List of future strategies:
[17:02:46.965] 1. multicore:
[17:02:46.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:46.965]    - tweaked: FALSE
[17:02:46.965]    - call: plan(strategy)
[17:02:46.974] plan(): nbrOfWorkers() = 2
[17:02:46.975] result() for MulticoreFuture ...
[17:02:46.976] result() for MulticoreFuture ... done
[17:02:46.976] result() for MulticoreFuture ... done
[17:02:46.976] result() for MulticoreFuture ...
[17:02:46.976] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:46.977] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:46.977] Searching for globals...
[17:02:46.984] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:02:46.984] Searching for globals ... DONE
[17:02:46.985] Resolving globals: TRUE
[17:02:46.985] Resolving any globals that are futures ...
[17:02:46.985] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:02:46.985] Resolving any globals that are futures ... DONE
[17:02:46.985] 
[17:02:46.986] 
[17:02:46.986] getGlobalsAndPackages() ... DONE
[17:02:46.986] run() for ‘Future’ ...
[17:02:46.986] - state: ‘created’
[17:02:46.986] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:46.990] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:46.991] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:46.991]   - Field: ‘label’
[17:02:46.991]   - Field: ‘local’
[17:02:46.991]   - Field: ‘owner’
[17:02:46.991]   - Field: ‘envir’
[17:02:46.991]   - Field: ‘workers’
[17:02:46.991]   - Field: ‘packages’
[17:02:46.991]   - Field: ‘gc’
[17:02:46.992]   - Field: ‘job’
[17:02:46.992]   - Field: ‘conditions’
[17:02:46.992]   - Field: ‘expr’
[17:02:46.992]   - Field: ‘uuid’
[17:02:46.992]   - Field: ‘seed’
[17:02:46.992]   - Field: ‘version’
[17:02:46.992]   - Field: ‘result’
[17:02:46.992]   - Field: ‘asynchronous’
[17:02:46.992]   - Field: ‘calls’
[17:02:46.993]   - Field: ‘globals’
[17:02:46.993]   - Field: ‘stdout’
[17:02:46.993]   - Field: ‘earlySignal’
[17:02:46.993]   - Field: ‘lazy’
[17:02:46.993]   - Field: ‘state’
[17:02:46.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:46.993] - Launch lazy future ...
[17:02:46.994] Packages needed by the future expression (n = 0): <none>
[17:02:46.994] Packages needed by future strategies (n = 0): <none>
[17:02:46.994] {
[17:02:46.994]     {
[17:02:46.994]         {
[17:02:46.994]             ...future.startTime <- base::Sys.time()
[17:02:46.994]             {
[17:02:46.994]                 {
[17:02:46.994]                   {
[17:02:46.994]                     {
[17:02:46.994]                       base::local({
[17:02:46.994]                         has_future <- base::requireNamespace("future", 
[17:02:46.994]                           quietly = TRUE)
[17:02:46.994]                         if (has_future) {
[17:02:46.994]                           ns <- base::getNamespace("future")
[17:02:46.994]                           version <- ns[[".package"]][["version"]]
[17:02:46.994]                           if (is.null(version)) 
[17:02:46.994]                             version <- utils::packageVersion("future")
[17:02:46.994]                         }
[17:02:46.994]                         else {
[17:02:46.994]                           version <- NULL
[17:02:46.994]                         }
[17:02:46.994]                         if (!has_future || version < "1.8.0") {
[17:02:46.994]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:46.994]                             "", base::R.version$version.string), 
[17:02:46.994]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:46.994]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:46.994]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:46.994]                               "release", "version")], collapse = " "), 
[17:02:46.994]                             hostname = base::Sys.info()[["nodename"]])
[17:02:46.994]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:46.994]                             info)
[17:02:46.994]                           info <- base::paste(info, collapse = "; ")
[17:02:46.994]                           if (!has_future) {
[17:02:46.994]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:46.994]                               info)
[17:02:46.994]                           }
[17:02:46.994]                           else {
[17:02:46.994]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:46.994]                               info, version)
[17:02:46.994]                           }
[17:02:46.994]                           base::stop(msg)
[17:02:46.994]                         }
[17:02:46.994]                       })
[17:02:46.994]                     }
[17:02:46.994]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:46.994]                     base::options(mc.cores = 1L)
[17:02:46.994]                   }
[17:02:46.994]                   ...future.strategy.old <- future::plan("list")
[17:02:46.994]                   options(future.plan = NULL)
[17:02:46.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:46.994]                 }
[17:02:46.994]                 ...future.workdir <- getwd()
[17:02:46.994]             }
[17:02:46.994]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:46.994]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:46.994]         }
[17:02:46.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:46.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:46.994]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:46.994]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:46.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:46.994]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:46.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:46.994]             base::names(...future.oldOptions))
[17:02:46.994]     }
[17:02:46.994]     if (FALSE) {
[17:02:46.994]     }
[17:02:46.994]     else {
[17:02:46.994]         if (TRUE) {
[17:02:46.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:46.994]                 open = "w")
[17:02:46.994]         }
[17:02:46.994]         else {
[17:02:46.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:46.994]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:46.994]         }
[17:02:46.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:46.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:46.994]             base::sink(type = "output", split = FALSE)
[17:02:46.994]             base::close(...future.stdout)
[17:02:46.994]         }, add = TRUE)
[17:02:46.994]     }
[17:02:46.994]     ...future.frame <- base::sys.nframe()
[17:02:46.994]     ...future.conditions <- base::list()
[17:02:46.994]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:46.994]     if (FALSE) {
[17:02:46.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:46.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:46.994]     }
[17:02:46.994]     ...future.result <- base::tryCatch({
[17:02:46.994]         base::withCallingHandlers({
[17:02:46.994]             ...future.value <- base::withVisible(base::local({
[17:02:46.994]                 withCallingHandlers({
[17:02:46.994]                   {
[17:02:46.994]                     x <- list(b = 2)
[17:02:46.994]                     x$a <- 1
[17:02:46.994]                     x
[17:02:46.994]                   }
[17:02:46.994]                 }, immediateCondition = function(cond) {
[17:02:46.994]                   save_rds <- function (object, pathname, ...) 
[17:02:46.994]                   {
[17:02:46.994]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:46.994]                     if (file_test("-f", pathname_tmp)) {
[17:02:46.994]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.994]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:46.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.994]                         fi_tmp[["mtime"]])
[17:02:46.994]                     }
[17:02:46.994]                     tryCatch({
[17:02:46.994]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:46.994]                     }, error = function(ex) {
[17:02:46.994]                       msg <- conditionMessage(ex)
[17:02:46.994]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.994]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:46.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.994]                         fi_tmp[["mtime"]], msg)
[17:02:46.994]                       ex$message <- msg
[17:02:46.994]                       stop(ex)
[17:02:46.994]                     })
[17:02:46.994]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:46.994]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:46.994]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:46.994]                       fi_tmp <- file.info(pathname_tmp)
[17:02:46.994]                       fi <- file.info(pathname)
[17:02:46.994]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:46.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:46.994]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:46.994]                         fi[["size"]], fi[["mtime"]])
[17:02:46.994]                       stop(msg)
[17:02:46.994]                     }
[17:02:46.994]                     invisible(pathname)
[17:02:46.994]                   }
[17:02:46.994]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:46.994]                     rootPath = tempdir()) 
[17:02:46.994]                   {
[17:02:46.994]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:46.994]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:46.994]                       tmpdir = path, fileext = ".rds")
[17:02:46.994]                     save_rds(obj, file)
[17:02:46.994]                   }
[17:02:46.994]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:46.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.994]                   {
[17:02:46.994]                     inherits <- base::inherits
[17:02:46.994]                     invokeRestart <- base::invokeRestart
[17:02:46.994]                     is.null <- base::is.null
[17:02:46.994]                     muffled <- FALSE
[17:02:46.994]                     if (inherits(cond, "message")) {
[17:02:46.994]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:46.994]                       if (muffled) 
[17:02:46.994]                         invokeRestart("muffleMessage")
[17:02:46.994]                     }
[17:02:46.994]                     else if (inherits(cond, "warning")) {
[17:02:46.994]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:46.994]                       if (muffled) 
[17:02:46.994]                         invokeRestart("muffleWarning")
[17:02:46.994]                     }
[17:02:46.994]                     else if (inherits(cond, "condition")) {
[17:02:46.994]                       if (!is.null(pattern)) {
[17:02:46.994]                         computeRestarts <- base::computeRestarts
[17:02:46.994]                         grepl <- base::grepl
[17:02:46.994]                         restarts <- computeRestarts(cond)
[17:02:46.994]                         for (restart in restarts) {
[17:02:46.994]                           name <- restart$name
[17:02:46.994]                           if (is.null(name)) 
[17:02:46.994]                             next
[17:02:46.994]                           if (!grepl(pattern, name)) 
[17:02:46.994]                             next
[17:02:46.994]                           invokeRestart(restart)
[17:02:46.994]                           muffled <- TRUE
[17:02:46.994]                           break
[17:02:46.994]                         }
[17:02:46.994]                       }
[17:02:46.994]                     }
[17:02:46.994]                     invisible(muffled)
[17:02:46.994]                   }
[17:02:46.994]                   muffleCondition(cond)
[17:02:46.994]                 })
[17:02:46.994]             }))
[17:02:46.994]             future::FutureResult(value = ...future.value$value, 
[17:02:46.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.994]                   ...future.rng), globalenv = if (FALSE) 
[17:02:46.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:46.994]                     ...future.globalenv.names))
[17:02:46.994]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:46.994]         }, condition = base::local({
[17:02:46.994]             c <- base::c
[17:02:46.994]             inherits <- base::inherits
[17:02:46.994]             invokeRestart <- base::invokeRestart
[17:02:46.994]             length <- base::length
[17:02:46.994]             list <- base::list
[17:02:46.994]             seq.int <- base::seq.int
[17:02:46.994]             signalCondition <- base::signalCondition
[17:02:46.994]             sys.calls <- base::sys.calls
[17:02:46.994]             `[[` <- base::`[[`
[17:02:46.994]             `+` <- base::`+`
[17:02:46.994]             `<<-` <- base::`<<-`
[17:02:46.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:46.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:46.994]                   3L)]
[17:02:46.994]             }
[17:02:46.994]             function(cond) {
[17:02:46.994]                 is_error <- inherits(cond, "error")
[17:02:46.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:46.994]                   NULL)
[17:02:46.994]                 if (is_error) {
[17:02:46.994]                   sessionInformation <- function() {
[17:02:46.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:46.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:46.994]                       search = base::search(), system = base::Sys.info())
[17:02:46.994]                   }
[17:02:46.994]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:46.994]                     cond$call), session = sessionInformation(), 
[17:02:46.994]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:46.994]                   signalCondition(cond)
[17:02:46.994]                 }
[17:02:46.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:46.994]                 "immediateCondition"))) {
[17:02:46.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:46.994]                   ...future.conditions[[length(...future.conditions) + 
[17:02:46.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:46.994]                   if (TRUE && !signal) {
[17:02:46.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.994]                     {
[17:02:46.994]                       inherits <- base::inherits
[17:02:46.994]                       invokeRestart <- base::invokeRestart
[17:02:46.994]                       is.null <- base::is.null
[17:02:46.994]                       muffled <- FALSE
[17:02:46.994]                       if (inherits(cond, "message")) {
[17:02:46.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.994]                         if (muffled) 
[17:02:46.994]                           invokeRestart("muffleMessage")
[17:02:46.994]                       }
[17:02:46.994]                       else if (inherits(cond, "warning")) {
[17:02:46.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.994]                         if (muffled) 
[17:02:46.994]                           invokeRestart("muffleWarning")
[17:02:46.994]                       }
[17:02:46.994]                       else if (inherits(cond, "condition")) {
[17:02:46.994]                         if (!is.null(pattern)) {
[17:02:46.994]                           computeRestarts <- base::computeRestarts
[17:02:46.994]                           grepl <- base::grepl
[17:02:46.994]                           restarts <- computeRestarts(cond)
[17:02:46.994]                           for (restart in restarts) {
[17:02:46.994]                             name <- restart$name
[17:02:46.994]                             if (is.null(name)) 
[17:02:46.994]                               next
[17:02:46.994]                             if (!grepl(pattern, name)) 
[17:02:46.994]                               next
[17:02:46.994]                             invokeRestart(restart)
[17:02:46.994]                             muffled <- TRUE
[17:02:46.994]                             break
[17:02:46.994]                           }
[17:02:46.994]                         }
[17:02:46.994]                       }
[17:02:46.994]                       invisible(muffled)
[17:02:46.994]                     }
[17:02:46.994]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.994]                   }
[17:02:46.994]                 }
[17:02:46.994]                 else {
[17:02:46.994]                   if (TRUE) {
[17:02:46.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:46.994]                     {
[17:02:46.994]                       inherits <- base::inherits
[17:02:46.994]                       invokeRestart <- base::invokeRestart
[17:02:46.994]                       is.null <- base::is.null
[17:02:46.994]                       muffled <- FALSE
[17:02:46.994]                       if (inherits(cond, "message")) {
[17:02:46.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:46.994]                         if (muffled) 
[17:02:46.994]                           invokeRestart("muffleMessage")
[17:02:46.994]                       }
[17:02:46.994]                       else if (inherits(cond, "warning")) {
[17:02:46.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:46.994]                         if (muffled) 
[17:02:46.994]                           invokeRestart("muffleWarning")
[17:02:46.994]                       }
[17:02:46.994]                       else if (inherits(cond, "condition")) {
[17:02:46.994]                         if (!is.null(pattern)) {
[17:02:46.994]                           computeRestarts <- base::computeRestarts
[17:02:46.994]                           grepl <- base::grepl
[17:02:46.994]                           restarts <- computeRestarts(cond)
[17:02:46.994]                           for (restart in restarts) {
[17:02:46.994]                             name <- restart$name
[17:02:46.994]                             if (is.null(name)) 
[17:02:46.994]                               next
[17:02:46.994]                             if (!grepl(pattern, name)) 
[17:02:46.994]                               next
[17:02:46.994]                             invokeRestart(restart)
[17:02:46.994]                             muffled <- TRUE
[17:02:46.994]                             break
[17:02:46.994]                           }
[17:02:46.994]                         }
[17:02:46.994]                       }
[17:02:46.994]                       invisible(muffled)
[17:02:46.994]                     }
[17:02:46.994]                     muffleCondition(cond, pattern = "^muffle")
[17:02:46.994]                   }
[17:02:46.994]                 }
[17:02:46.994]             }
[17:02:46.994]         }))
[17:02:46.994]     }, error = function(ex) {
[17:02:46.994]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:46.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:46.994]                 ...future.rng), started = ...future.startTime, 
[17:02:46.994]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:46.994]             version = "1.8"), class = "FutureResult")
[17:02:46.994]     }, finally = {
[17:02:46.994]         if (!identical(...future.workdir, getwd())) 
[17:02:46.994]             setwd(...future.workdir)
[17:02:46.994]         {
[17:02:46.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:46.994]                 ...future.oldOptions$nwarnings <- NULL
[17:02:46.994]             }
[17:02:46.994]             base::options(...future.oldOptions)
[17:02:46.994]             if (.Platform$OS.type == "windows") {
[17:02:46.994]                 old_names <- names(...future.oldEnvVars)
[17:02:46.994]                 envs <- base::Sys.getenv()
[17:02:46.994]                 names <- names(envs)
[17:02:46.994]                 common <- intersect(names, old_names)
[17:02:46.994]                 added <- setdiff(names, old_names)
[17:02:46.994]                 removed <- setdiff(old_names, names)
[17:02:46.994]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:46.994]                   envs[common]]
[17:02:46.994]                 NAMES <- toupper(changed)
[17:02:46.994]                 args <- list()
[17:02:46.994]                 for (kk in seq_along(NAMES)) {
[17:02:46.994]                   name <- changed[[kk]]
[17:02:46.994]                   NAME <- NAMES[[kk]]
[17:02:46.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.994]                     next
[17:02:46.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.994]                 }
[17:02:46.994]                 NAMES <- toupper(added)
[17:02:46.994]                 for (kk in seq_along(NAMES)) {
[17:02:46.994]                   name <- added[[kk]]
[17:02:46.994]                   NAME <- NAMES[[kk]]
[17:02:46.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.994]                     next
[17:02:46.994]                   args[[name]] <- ""
[17:02:46.994]                 }
[17:02:46.994]                 NAMES <- toupper(removed)
[17:02:46.994]                 for (kk in seq_along(NAMES)) {
[17:02:46.994]                   name <- removed[[kk]]
[17:02:46.994]                   NAME <- NAMES[[kk]]
[17:02:46.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:46.994]                     next
[17:02:46.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:46.994]                 }
[17:02:46.994]                 if (length(args) > 0) 
[17:02:46.994]                   base::do.call(base::Sys.setenv, args = args)
[17:02:46.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:46.994]             }
[17:02:46.994]             else {
[17:02:46.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:46.994]             }
[17:02:46.994]             {
[17:02:46.994]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:46.994]                   0L) {
[17:02:46.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:46.994]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:46.994]                   base::options(opts)
[17:02:46.994]                 }
[17:02:46.994]                 {
[17:02:46.994]                   {
[17:02:46.994]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:46.994]                     NULL
[17:02:46.994]                   }
[17:02:46.994]                   options(future.plan = NULL)
[17:02:46.994]                   if (is.na(NA_character_)) 
[17:02:46.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:46.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:46.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:46.994]                     .init = FALSE)
[17:02:46.994]                 }
[17:02:46.994]             }
[17:02:46.994]         }
[17:02:46.994]     })
[17:02:46.994]     if (TRUE) {
[17:02:46.994]         base::sink(type = "output", split = FALSE)
[17:02:46.994]         if (TRUE) {
[17:02:46.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:46.994]         }
[17:02:46.994]         else {
[17:02:46.994]             ...future.result["stdout"] <- base::list(NULL)
[17:02:46.994]         }
[17:02:46.994]         base::close(...future.stdout)
[17:02:46.994]         ...future.stdout <- NULL
[17:02:46.994]     }
[17:02:46.994]     ...future.result$conditions <- ...future.conditions
[17:02:46.994]     ...future.result$finished <- base::Sys.time()
[17:02:46.994]     ...future.result
[17:02:46.994] }
[17:02:46.997] requestCore(): workers = 2
[17:02:46.999] MulticoreFuture started
[17:02:46.999] - Launch lazy future ... done
[17:02:46.999] run() for ‘MulticoreFuture’ ... done
[17:02:47.000] result() for MulticoreFuture ...
[17:02:47.000] plan(): Setting new future strategy stack:
[17:02:47.000] List of future strategies:
[17:02:47.000] 1. sequential:
[17:02:47.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.000]    - tweaked: FALSE
[17:02:47.000]    - call: NULL
[17:02:47.001] plan(): nbrOfWorkers() = 1
[17:02:47.003] plan(): Setting new future strategy stack:
[17:02:47.003] List of future strategies:
[17:02:47.003] 1. multicore:
[17:02:47.003]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.003]    - tweaked: FALSE
[17:02:47.003]    - call: plan(strategy)
[17:02:47.009] plan(): nbrOfWorkers() = 2
[17:02:47.010] result() for MulticoreFuture ...
[17:02:47.010] result() for MulticoreFuture ... done
[17:02:47.010] result() for MulticoreFuture ... done
[17:02:47.010] result() for MulticoreFuture ...
[17:02:47.010] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.011] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.011] Searching for globals...
[17:02:47.014] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:47.015] Searching for globals ... DONE
[17:02:47.015] Resolving globals: TRUE
[17:02:47.015] Resolving any globals that are futures ...
[17:02:47.015] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:47.015] Resolving any globals that are futures ... DONE
[17:02:47.016] Resolving futures part of globals (recursively) ...
[17:02:47.016] resolve() on list ...
[17:02:47.016]  recursive: 99
[17:02:47.016]  length: 1
[17:02:47.016]  elements: ‘x’
[17:02:47.016]  length: 0 (resolved future 1)
[17:02:47.017] resolve() on list ... DONE
[17:02:47.017] - globals: [1] ‘x’
[17:02:47.017] Resolving futures part of globals (recursively) ... DONE
[17:02:47.017] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.017] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.018] - globals: [1] ‘x’
[17:02:47.018] 
[17:02:47.018] getGlobalsAndPackages() ... DONE
[17:02:47.018] run() for ‘Future’ ...
[17:02:47.018] - state: ‘created’
[17:02:47.018] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.023] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:47.023]   - Field: ‘label’
[17:02:47.023]   - Field: ‘local’
[17:02:47.023]   - Field: ‘owner’
[17:02:47.023]   - Field: ‘envir’
[17:02:47.023]   - Field: ‘workers’
[17:02:47.024]   - Field: ‘packages’
[17:02:47.024]   - Field: ‘gc’
[17:02:47.024]   - Field: ‘job’
[17:02:47.024]   - Field: ‘conditions’
[17:02:47.024]   - Field: ‘expr’
[17:02:47.024]   - Field: ‘uuid’
[17:02:47.024]   - Field: ‘seed’
[17:02:47.024]   - Field: ‘version’
[17:02:47.024]   - Field: ‘result’
[17:02:47.025]   - Field: ‘asynchronous’
[17:02:47.025]   - Field: ‘calls’
[17:02:47.025]   - Field: ‘globals’
[17:02:47.025]   - Field: ‘stdout’
[17:02:47.025]   - Field: ‘earlySignal’
[17:02:47.025]   - Field: ‘lazy’
[17:02:47.025]   - Field: ‘state’
[17:02:47.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:47.025] - Launch lazy future ...
[17:02:47.026] Packages needed by the future expression (n = 0): <none>
[17:02:47.026] Packages needed by future strategies (n = 0): <none>
[17:02:47.027] {
[17:02:47.027]     {
[17:02:47.027]         {
[17:02:47.027]             ...future.startTime <- base::Sys.time()
[17:02:47.027]             {
[17:02:47.027]                 {
[17:02:47.027]                   {
[17:02:47.027]                     {
[17:02:47.027]                       base::local({
[17:02:47.027]                         has_future <- base::requireNamespace("future", 
[17:02:47.027]                           quietly = TRUE)
[17:02:47.027]                         if (has_future) {
[17:02:47.027]                           ns <- base::getNamespace("future")
[17:02:47.027]                           version <- ns[[".package"]][["version"]]
[17:02:47.027]                           if (is.null(version)) 
[17:02:47.027]                             version <- utils::packageVersion("future")
[17:02:47.027]                         }
[17:02:47.027]                         else {
[17:02:47.027]                           version <- NULL
[17:02:47.027]                         }
[17:02:47.027]                         if (!has_future || version < "1.8.0") {
[17:02:47.027]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.027]                             "", base::R.version$version.string), 
[17:02:47.027]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.027]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.027]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.027]                               "release", "version")], collapse = " "), 
[17:02:47.027]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.027]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.027]                             info)
[17:02:47.027]                           info <- base::paste(info, collapse = "; ")
[17:02:47.027]                           if (!has_future) {
[17:02:47.027]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.027]                               info)
[17:02:47.027]                           }
[17:02:47.027]                           else {
[17:02:47.027]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.027]                               info, version)
[17:02:47.027]                           }
[17:02:47.027]                           base::stop(msg)
[17:02:47.027]                         }
[17:02:47.027]                       })
[17:02:47.027]                     }
[17:02:47.027]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.027]                     base::options(mc.cores = 1L)
[17:02:47.027]                   }
[17:02:47.027]                   ...future.strategy.old <- future::plan("list")
[17:02:47.027]                   options(future.plan = NULL)
[17:02:47.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.027]                 }
[17:02:47.027]                 ...future.workdir <- getwd()
[17:02:47.027]             }
[17:02:47.027]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.027]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.027]         }
[17:02:47.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.027]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.027]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.027]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.027]             base::names(...future.oldOptions))
[17:02:47.027]     }
[17:02:47.027]     if (FALSE) {
[17:02:47.027]     }
[17:02:47.027]     else {
[17:02:47.027]         if (TRUE) {
[17:02:47.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.027]                 open = "w")
[17:02:47.027]         }
[17:02:47.027]         else {
[17:02:47.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.027]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.027]         }
[17:02:47.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.027]             base::sink(type = "output", split = FALSE)
[17:02:47.027]             base::close(...future.stdout)
[17:02:47.027]         }, add = TRUE)
[17:02:47.027]     }
[17:02:47.027]     ...future.frame <- base::sys.nframe()
[17:02:47.027]     ...future.conditions <- base::list()
[17:02:47.027]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.027]     if (FALSE) {
[17:02:47.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.027]     }
[17:02:47.027]     ...future.result <- base::tryCatch({
[17:02:47.027]         base::withCallingHandlers({
[17:02:47.027]             ...future.value <- base::withVisible(base::local({
[17:02:47.027]                 withCallingHandlers({
[17:02:47.027]                   {
[17:02:47.027]                     x[["a"]] <- 1
[17:02:47.027]                     x
[17:02:47.027]                   }
[17:02:47.027]                 }, immediateCondition = function(cond) {
[17:02:47.027]                   save_rds <- function (object, pathname, ...) 
[17:02:47.027]                   {
[17:02:47.027]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:47.027]                     if (file_test("-f", pathname_tmp)) {
[17:02:47.027]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.027]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:47.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.027]                         fi_tmp[["mtime"]])
[17:02:47.027]                     }
[17:02:47.027]                     tryCatch({
[17:02:47.027]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:47.027]                     }, error = function(ex) {
[17:02:47.027]                       msg <- conditionMessage(ex)
[17:02:47.027]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.027]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:47.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.027]                         fi_tmp[["mtime"]], msg)
[17:02:47.027]                       ex$message <- msg
[17:02:47.027]                       stop(ex)
[17:02:47.027]                     })
[17:02:47.027]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:47.027]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:47.027]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:47.027]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.027]                       fi <- file.info(pathname)
[17:02:47.027]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:47.027]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.027]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:47.027]                         fi[["size"]], fi[["mtime"]])
[17:02:47.027]                       stop(msg)
[17:02:47.027]                     }
[17:02:47.027]                     invisible(pathname)
[17:02:47.027]                   }
[17:02:47.027]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:47.027]                     rootPath = tempdir()) 
[17:02:47.027]                   {
[17:02:47.027]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:47.027]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:47.027]                       tmpdir = path, fileext = ".rds")
[17:02:47.027]                     save_rds(obj, file)
[17:02:47.027]                   }
[17:02:47.027]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:47.027]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.027]                   {
[17:02:47.027]                     inherits <- base::inherits
[17:02:47.027]                     invokeRestart <- base::invokeRestart
[17:02:47.027]                     is.null <- base::is.null
[17:02:47.027]                     muffled <- FALSE
[17:02:47.027]                     if (inherits(cond, "message")) {
[17:02:47.027]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.027]                       if (muffled) 
[17:02:47.027]                         invokeRestart("muffleMessage")
[17:02:47.027]                     }
[17:02:47.027]                     else if (inherits(cond, "warning")) {
[17:02:47.027]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.027]                       if (muffled) 
[17:02:47.027]                         invokeRestart("muffleWarning")
[17:02:47.027]                     }
[17:02:47.027]                     else if (inherits(cond, "condition")) {
[17:02:47.027]                       if (!is.null(pattern)) {
[17:02:47.027]                         computeRestarts <- base::computeRestarts
[17:02:47.027]                         grepl <- base::grepl
[17:02:47.027]                         restarts <- computeRestarts(cond)
[17:02:47.027]                         for (restart in restarts) {
[17:02:47.027]                           name <- restart$name
[17:02:47.027]                           if (is.null(name)) 
[17:02:47.027]                             next
[17:02:47.027]                           if (!grepl(pattern, name)) 
[17:02:47.027]                             next
[17:02:47.027]                           invokeRestart(restart)
[17:02:47.027]                           muffled <- TRUE
[17:02:47.027]                           break
[17:02:47.027]                         }
[17:02:47.027]                       }
[17:02:47.027]                     }
[17:02:47.027]                     invisible(muffled)
[17:02:47.027]                   }
[17:02:47.027]                   muffleCondition(cond)
[17:02:47.027]                 })
[17:02:47.027]             }))
[17:02:47.027]             future::FutureResult(value = ...future.value$value, 
[17:02:47.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.027]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.027]                     ...future.globalenv.names))
[17:02:47.027]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.027]         }, condition = base::local({
[17:02:47.027]             c <- base::c
[17:02:47.027]             inherits <- base::inherits
[17:02:47.027]             invokeRestart <- base::invokeRestart
[17:02:47.027]             length <- base::length
[17:02:47.027]             list <- base::list
[17:02:47.027]             seq.int <- base::seq.int
[17:02:47.027]             signalCondition <- base::signalCondition
[17:02:47.027]             sys.calls <- base::sys.calls
[17:02:47.027]             `[[` <- base::`[[`
[17:02:47.027]             `+` <- base::`+`
[17:02:47.027]             `<<-` <- base::`<<-`
[17:02:47.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.027]                   3L)]
[17:02:47.027]             }
[17:02:47.027]             function(cond) {
[17:02:47.027]                 is_error <- inherits(cond, "error")
[17:02:47.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.027]                   NULL)
[17:02:47.027]                 if (is_error) {
[17:02:47.027]                   sessionInformation <- function() {
[17:02:47.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.027]                       search = base::search(), system = base::Sys.info())
[17:02:47.027]                   }
[17:02:47.027]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.027]                     cond$call), session = sessionInformation(), 
[17:02:47.027]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.027]                   signalCondition(cond)
[17:02:47.027]                 }
[17:02:47.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.027]                 "immediateCondition"))) {
[17:02:47.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.027]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.027]                   if (TRUE && !signal) {
[17:02:47.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.027]                     {
[17:02:47.027]                       inherits <- base::inherits
[17:02:47.027]                       invokeRestart <- base::invokeRestart
[17:02:47.027]                       is.null <- base::is.null
[17:02:47.027]                       muffled <- FALSE
[17:02:47.027]                       if (inherits(cond, "message")) {
[17:02:47.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.027]                         if (muffled) 
[17:02:47.027]                           invokeRestart("muffleMessage")
[17:02:47.027]                       }
[17:02:47.027]                       else if (inherits(cond, "warning")) {
[17:02:47.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.027]                         if (muffled) 
[17:02:47.027]                           invokeRestart("muffleWarning")
[17:02:47.027]                       }
[17:02:47.027]                       else if (inherits(cond, "condition")) {
[17:02:47.027]                         if (!is.null(pattern)) {
[17:02:47.027]                           computeRestarts <- base::computeRestarts
[17:02:47.027]                           grepl <- base::grepl
[17:02:47.027]                           restarts <- computeRestarts(cond)
[17:02:47.027]                           for (restart in restarts) {
[17:02:47.027]                             name <- restart$name
[17:02:47.027]                             if (is.null(name)) 
[17:02:47.027]                               next
[17:02:47.027]                             if (!grepl(pattern, name)) 
[17:02:47.027]                               next
[17:02:47.027]                             invokeRestart(restart)
[17:02:47.027]                             muffled <- TRUE
[17:02:47.027]                             break
[17:02:47.027]                           }
[17:02:47.027]                         }
[17:02:47.027]                       }
[17:02:47.027]                       invisible(muffled)
[17:02:47.027]                     }
[17:02:47.027]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.027]                   }
[17:02:47.027]                 }
[17:02:47.027]                 else {
[17:02:47.027]                   if (TRUE) {
[17:02:47.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.027]                     {
[17:02:47.027]                       inherits <- base::inherits
[17:02:47.027]                       invokeRestart <- base::invokeRestart
[17:02:47.027]                       is.null <- base::is.null
[17:02:47.027]                       muffled <- FALSE
[17:02:47.027]                       if (inherits(cond, "message")) {
[17:02:47.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.027]                         if (muffled) 
[17:02:47.027]                           invokeRestart("muffleMessage")
[17:02:47.027]                       }
[17:02:47.027]                       else if (inherits(cond, "warning")) {
[17:02:47.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.027]                         if (muffled) 
[17:02:47.027]                           invokeRestart("muffleWarning")
[17:02:47.027]                       }
[17:02:47.027]                       else if (inherits(cond, "condition")) {
[17:02:47.027]                         if (!is.null(pattern)) {
[17:02:47.027]                           computeRestarts <- base::computeRestarts
[17:02:47.027]                           grepl <- base::grepl
[17:02:47.027]                           restarts <- computeRestarts(cond)
[17:02:47.027]                           for (restart in restarts) {
[17:02:47.027]                             name <- restart$name
[17:02:47.027]                             if (is.null(name)) 
[17:02:47.027]                               next
[17:02:47.027]                             if (!grepl(pattern, name)) 
[17:02:47.027]                               next
[17:02:47.027]                             invokeRestart(restart)
[17:02:47.027]                             muffled <- TRUE
[17:02:47.027]                             break
[17:02:47.027]                           }
[17:02:47.027]                         }
[17:02:47.027]                       }
[17:02:47.027]                       invisible(muffled)
[17:02:47.027]                     }
[17:02:47.027]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.027]                   }
[17:02:47.027]                 }
[17:02:47.027]             }
[17:02:47.027]         }))
[17:02:47.027]     }, error = function(ex) {
[17:02:47.027]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.027]                 ...future.rng), started = ...future.startTime, 
[17:02:47.027]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.027]             version = "1.8"), class = "FutureResult")
[17:02:47.027]     }, finally = {
[17:02:47.027]         if (!identical(...future.workdir, getwd())) 
[17:02:47.027]             setwd(...future.workdir)
[17:02:47.027]         {
[17:02:47.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.027]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.027]             }
[17:02:47.027]             base::options(...future.oldOptions)
[17:02:47.027]             if (.Platform$OS.type == "windows") {
[17:02:47.027]                 old_names <- names(...future.oldEnvVars)
[17:02:47.027]                 envs <- base::Sys.getenv()
[17:02:47.027]                 names <- names(envs)
[17:02:47.027]                 common <- intersect(names, old_names)
[17:02:47.027]                 added <- setdiff(names, old_names)
[17:02:47.027]                 removed <- setdiff(old_names, names)
[17:02:47.027]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.027]                   envs[common]]
[17:02:47.027]                 NAMES <- toupper(changed)
[17:02:47.027]                 args <- list()
[17:02:47.027]                 for (kk in seq_along(NAMES)) {
[17:02:47.027]                   name <- changed[[kk]]
[17:02:47.027]                   NAME <- NAMES[[kk]]
[17:02:47.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.027]                     next
[17:02:47.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.027]                 }
[17:02:47.027]                 NAMES <- toupper(added)
[17:02:47.027]                 for (kk in seq_along(NAMES)) {
[17:02:47.027]                   name <- added[[kk]]
[17:02:47.027]                   NAME <- NAMES[[kk]]
[17:02:47.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.027]                     next
[17:02:47.027]                   args[[name]] <- ""
[17:02:47.027]                 }
[17:02:47.027]                 NAMES <- toupper(removed)
[17:02:47.027]                 for (kk in seq_along(NAMES)) {
[17:02:47.027]                   name <- removed[[kk]]
[17:02:47.027]                   NAME <- NAMES[[kk]]
[17:02:47.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.027]                     next
[17:02:47.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.027]                 }
[17:02:47.027]                 if (length(args) > 0) 
[17:02:47.027]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.027]             }
[17:02:47.027]             else {
[17:02:47.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.027]             }
[17:02:47.027]             {
[17:02:47.027]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.027]                   0L) {
[17:02:47.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.027]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.027]                   base::options(opts)
[17:02:47.027]                 }
[17:02:47.027]                 {
[17:02:47.027]                   {
[17:02:47.027]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.027]                     NULL
[17:02:47.027]                   }
[17:02:47.027]                   options(future.plan = NULL)
[17:02:47.027]                   if (is.na(NA_character_)) 
[17:02:47.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.027]                     .init = FALSE)
[17:02:47.027]                 }
[17:02:47.027]             }
[17:02:47.027]         }
[17:02:47.027]     })
[17:02:47.027]     if (TRUE) {
[17:02:47.027]         base::sink(type = "output", split = FALSE)
[17:02:47.027]         if (TRUE) {
[17:02:47.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.027]         }
[17:02:47.027]         else {
[17:02:47.027]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.027]         }
[17:02:47.027]         base::close(...future.stdout)
[17:02:47.027]         ...future.stdout <- NULL
[17:02:47.027]     }
[17:02:47.027]     ...future.result$conditions <- ...future.conditions
[17:02:47.027]     ...future.result$finished <- base::Sys.time()
[17:02:47.027]     ...future.result
[17:02:47.027] }
[17:02:47.029] assign_globals() ...
[17:02:47.029] List of 1
[17:02:47.029]  $ x: list()
[17:02:47.029]  - attr(*, "where")=List of 1
[17:02:47.029]   ..$ x:<environment: R_EmptyEnv> 
[17:02:47.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:47.029]  - attr(*, "resolved")= logi TRUE
[17:02:47.029]  - attr(*, "total_size")= num 0
[17:02:47.029]  - attr(*, "already-done")= logi TRUE
[17:02:47.032] - copied ‘x’ to environment
[17:02:47.032] assign_globals() ... done
[17:02:47.032] requestCore(): workers = 2
[17:02:47.035] MulticoreFuture started
[17:02:47.035] - Launch lazy future ... done
[17:02:47.035] run() for ‘MulticoreFuture’ ... done
[17:02:47.036] plan(): Setting new future strategy stack:
[17:02:47.035] result() for MulticoreFuture ...
[17:02:47.036] List of future strategies:
[17:02:47.036] 1. sequential:
[17:02:47.036]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.036]    - tweaked: FALSE
[17:02:47.036]    - call: NULL
[17:02:47.041] plan(): nbrOfWorkers() = 1
[17:02:47.043] plan(): Setting new future strategy stack:
[17:02:47.043] List of future strategies:
[17:02:47.043] 1. multicore:
[17:02:47.043]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.043]    - tweaked: FALSE
[17:02:47.043]    - call: plan(strategy)
[17:02:47.048] plan(): nbrOfWorkers() = 2
[17:02:47.049] result() for MulticoreFuture ...
[17:02:47.049] result() for MulticoreFuture ... done
[17:02:47.049] result() for MulticoreFuture ... done
[17:02:47.050] result() for MulticoreFuture ...
[17:02:47.050] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.050] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.051] Searching for globals...
[17:02:47.053] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:47.054] Searching for globals ... DONE
[17:02:47.054] Resolving globals: TRUE
[17:02:47.054] Resolving any globals that are futures ...
[17:02:47.054] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:47.054] Resolving any globals that are futures ... DONE
[17:02:47.055] Resolving futures part of globals (recursively) ...
[17:02:47.055] resolve() on list ...
[17:02:47.055]  recursive: 99
[17:02:47.055]  length: 1
[17:02:47.055]  elements: ‘x’
[17:02:47.055]  length: 0 (resolved future 1)
[17:02:47.056] resolve() on list ... DONE
[17:02:47.056] - globals: [1] ‘x’
[17:02:47.056] Resolving futures part of globals (recursively) ... DONE
[17:02:47.056] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.056] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.057] - globals: [1] ‘x’
[17:02:47.057] 
[17:02:47.057] getGlobalsAndPackages() ... DONE
[17:02:47.057] run() for ‘Future’ ...
[17:02:47.057] - state: ‘created’
[17:02:47.057] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.062] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:47.062]   - Field: ‘label’
[17:02:47.062]   - Field: ‘local’
[17:02:47.062]   - Field: ‘owner’
[17:02:47.063]   - Field: ‘envir’
[17:02:47.063]   - Field: ‘workers’
[17:02:47.063]   - Field: ‘packages’
[17:02:47.063]   - Field: ‘gc’
[17:02:47.063]   - Field: ‘job’
[17:02:47.063]   - Field: ‘conditions’
[17:02:47.063]   - Field: ‘expr’
[17:02:47.064]   - Field: ‘uuid’
[17:02:47.064]   - Field: ‘seed’
[17:02:47.064]   - Field: ‘version’
[17:02:47.064]   - Field: ‘result’
[17:02:47.064]   - Field: ‘asynchronous’
[17:02:47.064]   - Field: ‘calls’
[17:02:47.064]   - Field: ‘globals’
[17:02:47.064]   - Field: ‘stdout’
[17:02:47.064]   - Field: ‘earlySignal’
[17:02:47.065]   - Field: ‘lazy’
[17:02:47.065]   - Field: ‘state’
[17:02:47.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:47.065] - Launch lazy future ...
[17:02:47.065] Packages needed by the future expression (n = 0): <none>
[17:02:47.065] Packages needed by future strategies (n = 0): <none>
[17:02:47.066] {
[17:02:47.066]     {
[17:02:47.066]         {
[17:02:47.066]             ...future.startTime <- base::Sys.time()
[17:02:47.066]             {
[17:02:47.066]                 {
[17:02:47.066]                   {
[17:02:47.066]                     {
[17:02:47.066]                       base::local({
[17:02:47.066]                         has_future <- base::requireNamespace("future", 
[17:02:47.066]                           quietly = TRUE)
[17:02:47.066]                         if (has_future) {
[17:02:47.066]                           ns <- base::getNamespace("future")
[17:02:47.066]                           version <- ns[[".package"]][["version"]]
[17:02:47.066]                           if (is.null(version)) 
[17:02:47.066]                             version <- utils::packageVersion("future")
[17:02:47.066]                         }
[17:02:47.066]                         else {
[17:02:47.066]                           version <- NULL
[17:02:47.066]                         }
[17:02:47.066]                         if (!has_future || version < "1.8.0") {
[17:02:47.066]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.066]                             "", base::R.version$version.string), 
[17:02:47.066]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.066]                               "release", "version")], collapse = " "), 
[17:02:47.066]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.066]                             info)
[17:02:47.066]                           info <- base::paste(info, collapse = "; ")
[17:02:47.066]                           if (!has_future) {
[17:02:47.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.066]                               info)
[17:02:47.066]                           }
[17:02:47.066]                           else {
[17:02:47.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.066]                               info, version)
[17:02:47.066]                           }
[17:02:47.066]                           base::stop(msg)
[17:02:47.066]                         }
[17:02:47.066]                       })
[17:02:47.066]                     }
[17:02:47.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.066]                     base::options(mc.cores = 1L)
[17:02:47.066]                   }
[17:02:47.066]                   ...future.strategy.old <- future::plan("list")
[17:02:47.066]                   options(future.plan = NULL)
[17:02:47.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.066]                 }
[17:02:47.066]                 ...future.workdir <- getwd()
[17:02:47.066]             }
[17:02:47.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.066]         }
[17:02:47.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.066]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.066]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.066]             base::names(...future.oldOptions))
[17:02:47.066]     }
[17:02:47.066]     if (FALSE) {
[17:02:47.066]     }
[17:02:47.066]     else {
[17:02:47.066]         if (TRUE) {
[17:02:47.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.066]                 open = "w")
[17:02:47.066]         }
[17:02:47.066]         else {
[17:02:47.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.066]         }
[17:02:47.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.066]             base::sink(type = "output", split = FALSE)
[17:02:47.066]             base::close(...future.stdout)
[17:02:47.066]         }, add = TRUE)
[17:02:47.066]     }
[17:02:47.066]     ...future.frame <- base::sys.nframe()
[17:02:47.066]     ...future.conditions <- base::list()
[17:02:47.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.066]     if (FALSE) {
[17:02:47.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.066]     }
[17:02:47.066]     ...future.result <- base::tryCatch({
[17:02:47.066]         base::withCallingHandlers({
[17:02:47.066]             ...future.value <- base::withVisible(base::local({
[17:02:47.066]                 withCallingHandlers({
[17:02:47.066]                   {
[17:02:47.066]                     x[["a"]] <- 1
[17:02:47.066]                     x
[17:02:47.066]                   }
[17:02:47.066]                 }, immediateCondition = function(cond) {
[17:02:47.066]                   save_rds <- function (object, pathname, ...) 
[17:02:47.066]                   {
[17:02:47.066]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:47.066]                     if (file_test("-f", pathname_tmp)) {
[17:02:47.066]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.066]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:47.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.066]                         fi_tmp[["mtime"]])
[17:02:47.066]                     }
[17:02:47.066]                     tryCatch({
[17:02:47.066]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:47.066]                     }, error = function(ex) {
[17:02:47.066]                       msg <- conditionMessage(ex)
[17:02:47.066]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.066]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:47.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.066]                         fi_tmp[["mtime"]], msg)
[17:02:47.066]                       ex$message <- msg
[17:02:47.066]                       stop(ex)
[17:02:47.066]                     })
[17:02:47.066]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:47.066]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:47.066]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:47.066]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.066]                       fi <- file.info(pathname)
[17:02:47.066]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:47.066]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.066]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:47.066]                         fi[["size"]], fi[["mtime"]])
[17:02:47.066]                       stop(msg)
[17:02:47.066]                     }
[17:02:47.066]                     invisible(pathname)
[17:02:47.066]                   }
[17:02:47.066]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:47.066]                     rootPath = tempdir()) 
[17:02:47.066]                   {
[17:02:47.066]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:47.066]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:47.066]                       tmpdir = path, fileext = ".rds")
[17:02:47.066]                     save_rds(obj, file)
[17:02:47.066]                   }
[17:02:47.066]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:47.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.066]                   {
[17:02:47.066]                     inherits <- base::inherits
[17:02:47.066]                     invokeRestart <- base::invokeRestart
[17:02:47.066]                     is.null <- base::is.null
[17:02:47.066]                     muffled <- FALSE
[17:02:47.066]                     if (inherits(cond, "message")) {
[17:02:47.066]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.066]                       if (muffled) 
[17:02:47.066]                         invokeRestart("muffleMessage")
[17:02:47.066]                     }
[17:02:47.066]                     else if (inherits(cond, "warning")) {
[17:02:47.066]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.066]                       if (muffled) 
[17:02:47.066]                         invokeRestart("muffleWarning")
[17:02:47.066]                     }
[17:02:47.066]                     else if (inherits(cond, "condition")) {
[17:02:47.066]                       if (!is.null(pattern)) {
[17:02:47.066]                         computeRestarts <- base::computeRestarts
[17:02:47.066]                         grepl <- base::grepl
[17:02:47.066]                         restarts <- computeRestarts(cond)
[17:02:47.066]                         for (restart in restarts) {
[17:02:47.066]                           name <- restart$name
[17:02:47.066]                           if (is.null(name)) 
[17:02:47.066]                             next
[17:02:47.066]                           if (!grepl(pattern, name)) 
[17:02:47.066]                             next
[17:02:47.066]                           invokeRestart(restart)
[17:02:47.066]                           muffled <- TRUE
[17:02:47.066]                           break
[17:02:47.066]                         }
[17:02:47.066]                       }
[17:02:47.066]                     }
[17:02:47.066]                     invisible(muffled)
[17:02:47.066]                   }
[17:02:47.066]                   muffleCondition(cond)
[17:02:47.066]                 })
[17:02:47.066]             }))
[17:02:47.066]             future::FutureResult(value = ...future.value$value, 
[17:02:47.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.066]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.066]                     ...future.globalenv.names))
[17:02:47.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.066]         }, condition = base::local({
[17:02:47.066]             c <- base::c
[17:02:47.066]             inherits <- base::inherits
[17:02:47.066]             invokeRestart <- base::invokeRestart
[17:02:47.066]             length <- base::length
[17:02:47.066]             list <- base::list
[17:02:47.066]             seq.int <- base::seq.int
[17:02:47.066]             signalCondition <- base::signalCondition
[17:02:47.066]             sys.calls <- base::sys.calls
[17:02:47.066]             `[[` <- base::`[[`
[17:02:47.066]             `+` <- base::`+`
[17:02:47.066]             `<<-` <- base::`<<-`
[17:02:47.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.066]                   3L)]
[17:02:47.066]             }
[17:02:47.066]             function(cond) {
[17:02:47.066]                 is_error <- inherits(cond, "error")
[17:02:47.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.066]                   NULL)
[17:02:47.066]                 if (is_error) {
[17:02:47.066]                   sessionInformation <- function() {
[17:02:47.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.066]                       search = base::search(), system = base::Sys.info())
[17:02:47.066]                   }
[17:02:47.066]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.066]                     cond$call), session = sessionInformation(), 
[17:02:47.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.066]                   signalCondition(cond)
[17:02:47.066]                 }
[17:02:47.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.066]                 "immediateCondition"))) {
[17:02:47.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.066]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.066]                   if (TRUE && !signal) {
[17:02:47.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.066]                     {
[17:02:47.066]                       inherits <- base::inherits
[17:02:47.066]                       invokeRestart <- base::invokeRestart
[17:02:47.066]                       is.null <- base::is.null
[17:02:47.066]                       muffled <- FALSE
[17:02:47.066]                       if (inherits(cond, "message")) {
[17:02:47.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.066]                         if (muffled) 
[17:02:47.066]                           invokeRestart("muffleMessage")
[17:02:47.066]                       }
[17:02:47.066]                       else if (inherits(cond, "warning")) {
[17:02:47.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.066]                         if (muffled) 
[17:02:47.066]                           invokeRestart("muffleWarning")
[17:02:47.066]                       }
[17:02:47.066]                       else if (inherits(cond, "condition")) {
[17:02:47.066]                         if (!is.null(pattern)) {
[17:02:47.066]                           computeRestarts <- base::computeRestarts
[17:02:47.066]                           grepl <- base::grepl
[17:02:47.066]                           restarts <- computeRestarts(cond)
[17:02:47.066]                           for (restart in restarts) {
[17:02:47.066]                             name <- restart$name
[17:02:47.066]                             if (is.null(name)) 
[17:02:47.066]                               next
[17:02:47.066]                             if (!grepl(pattern, name)) 
[17:02:47.066]                               next
[17:02:47.066]                             invokeRestart(restart)
[17:02:47.066]                             muffled <- TRUE
[17:02:47.066]                             break
[17:02:47.066]                           }
[17:02:47.066]                         }
[17:02:47.066]                       }
[17:02:47.066]                       invisible(muffled)
[17:02:47.066]                     }
[17:02:47.066]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.066]                   }
[17:02:47.066]                 }
[17:02:47.066]                 else {
[17:02:47.066]                   if (TRUE) {
[17:02:47.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.066]                     {
[17:02:47.066]                       inherits <- base::inherits
[17:02:47.066]                       invokeRestart <- base::invokeRestart
[17:02:47.066]                       is.null <- base::is.null
[17:02:47.066]                       muffled <- FALSE
[17:02:47.066]                       if (inherits(cond, "message")) {
[17:02:47.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.066]                         if (muffled) 
[17:02:47.066]                           invokeRestart("muffleMessage")
[17:02:47.066]                       }
[17:02:47.066]                       else if (inherits(cond, "warning")) {
[17:02:47.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.066]                         if (muffled) 
[17:02:47.066]                           invokeRestart("muffleWarning")
[17:02:47.066]                       }
[17:02:47.066]                       else if (inherits(cond, "condition")) {
[17:02:47.066]                         if (!is.null(pattern)) {
[17:02:47.066]                           computeRestarts <- base::computeRestarts
[17:02:47.066]                           grepl <- base::grepl
[17:02:47.066]                           restarts <- computeRestarts(cond)
[17:02:47.066]                           for (restart in restarts) {
[17:02:47.066]                             name <- restart$name
[17:02:47.066]                             if (is.null(name)) 
[17:02:47.066]                               next
[17:02:47.066]                             if (!grepl(pattern, name)) 
[17:02:47.066]                               next
[17:02:47.066]                             invokeRestart(restart)
[17:02:47.066]                             muffled <- TRUE
[17:02:47.066]                             break
[17:02:47.066]                           }
[17:02:47.066]                         }
[17:02:47.066]                       }
[17:02:47.066]                       invisible(muffled)
[17:02:47.066]                     }
[17:02:47.066]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.066]                   }
[17:02:47.066]                 }
[17:02:47.066]             }
[17:02:47.066]         }))
[17:02:47.066]     }, error = function(ex) {
[17:02:47.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.066]                 ...future.rng), started = ...future.startTime, 
[17:02:47.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.066]             version = "1.8"), class = "FutureResult")
[17:02:47.066]     }, finally = {
[17:02:47.066]         if (!identical(...future.workdir, getwd())) 
[17:02:47.066]             setwd(...future.workdir)
[17:02:47.066]         {
[17:02:47.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.066]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.066]             }
[17:02:47.066]             base::options(...future.oldOptions)
[17:02:47.066]             if (.Platform$OS.type == "windows") {
[17:02:47.066]                 old_names <- names(...future.oldEnvVars)
[17:02:47.066]                 envs <- base::Sys.getenv()
[17:02:47.066]                 names <- names(envs)
[17:02:47.066]                 common <- intersect(names, old_names)
[17:02:47.066]                 added <- setdiff(names, old_names)
[17:02:47.066]                 removed <- setdiff(old_names, names)
[17:02:47.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.066]                   envs[common]]
[17:02:47.066]                 NAMES <- toupper(changed)
[17:02:47.066]                 args <- list()
[17:02:47.066]                 for (kk in seq_along(NAMES)) {
[17:02:47.066]                   name <- changed[[kk]]
[17:02:47.066]                   NAME <- NAMES[[kk]]
[17:02:47.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.066]                     next
[17:02:47.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.066]                 }
[17:02:47.066]                 NAMES <- toupper(added)
[17:02:47.066]                 for (kk in seq_along(NAMES)) {
[17:02:47.066]                   name <- added[[kk]]
[17:02:47.066]                   NAME <- NAMES[[kk]]
[17:02:47.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.066]                     next
[17:02:47.066]                   args[[name]] <- ""
[17:02:47.066]                 }
[17:02:47.066]                 NAMES <- toupper(removed)
[17:02:47.066]                 for (kk in seq_along(NAMES)) {
[17:02:47.066]                   name <- removed[[kk]]
[17:02:47.066]                   NAME <- NAMES[[kk]]
[17:02:47.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.066]                     next
[17:02:47.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.066]                 }
[17:02:47.066]                 if (length(args) > 0) 
[17:02:47.066]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.066]             }
[17:02:47.066]             else {
[17:02:47.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.066]             }
[17:02:47.066]             {
[17:02:47.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.066]                   0L) {
[17:02:47.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.066]                   base::options(opts)
[17:02:47.066]                 }
[17:02:47.066]                 {
[17:02:47.066]                   {
[17:02:47.066]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.066]                     NULL
[17:02:47.066]                   }
[17:02:47.066]                   options(future.plan = NULL)
[17:02:47.066]                   if (is.na(NA_character_)) 
[17:02:47.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.066]                     .init = FALSE)
[17:02:47.066]                 }
[17:02:47.066]             }
[17:02:47.066]         }
[17:02:47.066]     })
[17:02:47.066]     if (TRUE) {
[17:02:47.066]         base::sink(type = "output", split = FALSE)
[17:02:47.066]         if (TRUE) {
[17:02:47.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.066]         }
[17:02:47.066]         else {
[17:02:47.066]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.066]         }
[17:02:47.066]         base::close(...future.stdout)
[17:02:47.066]         ...future.stdout <- NULL
[17:02:47.066]     }
[17:02:47.066]     ...future.result$conditions <- ...future.conditions
[17:02:47.066]     ...future.result$finished <- base::Sys.time()
[17:02:47.066]     ...future.result
[17:02:47.066] }
[17:02:47.068] assign_globals() ...
[17:02:47.069] List of 1
[17:02:47.069]  $ x: list()
[17:02:47.069]  - attr(*, "where")=List of 1
[17:02:47.069]   ..$ x:<environment: R_EmptyEnv> 
[17:02:47.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:47.069]  - attr(*, "resolved")= logi TRUE
[17:02:47.069]  - attr(*, "total_size")= num 0
[17:02:47.069]  - attr(*, "already-done")= logi TRUE
[17:02:47.071] - copied ‘x’ to environment
[17:02:47.072] assign_globals() ... done
[17:02:47.072] requestCore(): workers = 2
[17:02:47.074] MulticoreFuture started
[17:02:47.074] - Launch lazy future ... done
[17:02:47.074] run() for ‘MulticoreFuture’ ... done
[17:02:47.075] result() for MulticoreFuture ...
[17:02:47.075] plan(): Setting new future strategy stack:
[17:02:47.075] List of future strategies:
[17:02:47.075] 1. sequential:
[17:02:47.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.075]    - tweaked: FALSE
[17:02:47.075]    - call: NULL
[17:02:47.076] plan(): nbrOfWorkers() = 1
[17:02:47.078] plan(): Setting new future strategy stack:
[17:02:47.078] List of future strategies:
[17:02:47.078] 1. multicore:
[17:02:47.078]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.078]    - tweaked: FALSE
[17:02:47.078]    - call: plan(strategy)
[17:02:47.084] plan(): nbrOfWorkers() = 2
[17:02:47.085] result() for MulticoreFuture ...
[17:02:47.085] result() for MulticoreFuture ... done
[17:02:47.085] result() for MulticoreFuture ... done
[17:02:47.085] result() for MulticoreFuture ...
[17:02:47.085] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.086] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.086] Searching for globals...
[17:02:47.089] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:47.089] Searching for globals ... DONE
[17:02:47.089] Resolving globals: TRUE
[17:02:47.090] Resolving any globals that are futures ...
[17:02:47.090] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:47.090] Resolving any globals that are futures ... DONE
[17:02:47.090] Resolving futures part of globals (recursively) ...
[17:02:47.091] resolve() on list ...
[17:02:47.091]  recursive: 99
[17:02:47.091]  length: 1
[17:02:47.091]  elements: ‘x’
[17:02:47.091]  length: 0 (resolved future 1)
[17:02:47.091] resolve() on list ... DONE
[17:02:47.091] - globals: [1] ‘x’
[17:02:47.092] Resolving futures part of globals (recursively) ... DONE
[17:02:47.092] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.092] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.092] - globals: [1] ‘x’
[17:02:47.092] 
[17:02:47.093] getGlobalsAndPackages() ... DONE
[17:02:47.093] run() for ‘Future’ ...
[17:02:47.093] - state: ‘created’
[17:02:47.093] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.097] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.098] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:47.098]   - Field: ‘label’
[17:02:47.098]   - Field: ‘local’
[17:02:47.098]   - Field: ‘owner’
[17:02:47.098]   - Field: ‘envir’
[17:02:47.098]   - Field: ‘workers’
[17:02:47.098]   - Field: ‘packages’
[17:02:47.098]   - Field: ‘gc’
[17:02:47.099]   - Field: ‘job’
[17:02:47.099]   - Field: ‘conditions’
[17:02:47.099]   - Field: ‘expr’
[17:02:47.099]   - Field: ‘uuid’
[17:02:47.099]   - Field: ‘seed’
[17:02:47.102]   - Field: ‘version’
[17:02:47.102]   - Field: ‘result’
[17:02:47.102]   - Field: ‘asynchronous’
[17:02:47.102]   - Field: ‘calls’
[17:02:47.102]   - Field: ‘globals’
[17:02:47.102]   - Field: ‘stdout’
[17:02:47.103]   - Field: ‘earlySignal’
[17:02:47.103]   - Field: ‘lazy’
[17:02:47.103]   - Field: ‘state’
[17:02:47.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:47.103] - Launch lazy future ...
[17:02:47.104] Packages needed by the future expression (n = 0): <none>
[17:02:47.104] Packages needed by future strategies (n = 0): <none>
[17:02:47.104] {
[17:02:47.104]     {
[17:02:47.104]         {
[17:02:47.104]             ...future.startTime <- base::Sys.time()
[17:02:47.104]             {
[17:02:47.104]                 {
[17:02:47.104]                   {
[17:02:47.104]                     {
[17:02:47.104]                       base::local({
[17:02:47.104]                         has_future <- base::requireNamespace("future", 
[17:02:47.104]                           quietly = TRUE)
[17:02:47.104]                         if (has_future) {
[17:02:47.104]                           ns <- base::getNamespace("future")
[17:02:47.104]                           version <- ns[[".package"]][["version"]]
[17:02:47.104]                           if (is.null(version)) 
[17:02:47.104]                             version <- utils::packageVersion("future")
[17:02:47.104]                         }
[17:02:47.104]                         else {
[17:02:47.104]                           version <- NULL
[17:02:47.104]                         }
[17:02:47.104]                         if (!has_future || version < "1.8.0") {
[17:02:47.104]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.104]                             "", base::R.version$version.string), 
[17:02:47.104]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.104]                               "release", "version")], collapse = " "), 
[17:02:47.104]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.104]                             info)
[17:02:47.104]                           info <- base::paste(info, collapse = "; ")
[17:02:47.104]                           if (!has_future) {
[17:02:47.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.104]                               info)
[17:02:47.104]                           }
[17:02:47.104]                           else {
[17:02:47.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.104]                               info, version)
[17:02:47.104]                           }
[17:02:47.104]                           base::stop(msg)
[17:02:47.104]                         }
[17:02:47.104]                       })
[17:02:47.104]                     }
[17:02:47.104]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.104]                     base::options(mc.cores = 1L)
[17:02:47.104]                   }
[17:02:47.104]                   ...future.strategy.old <- future::plan("list")
[17:02:47.104]                   options(future.plan = NULL)
[17:02:47.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.104]                 }
[17:02:47.104]                 ...future.workdir <- getwd()
[17:02:47.104]             }
[17:02:47.104]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.104]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.104]         }
[17:02:47.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.104]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.104]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.104]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.104]             base::names(...future.oldOptions))
[17:02:47.104]     }
[17:02:47.104]     if (FALSE) {
[17:02:47.104]     }
[17:02:47.104]     else {
[17:02:47.104]         if (TRUE) {
[17:02:47.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.104]                 open = "w")
[17:02:47.104]         }
[17:02:47.104]         else {
[17:02:47.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.104]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.104]         }
[17:02:47.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.104]             base::sink(type = "output", split = FALSE)
[17:02:47.104]             base::close(...future.stdout)
[17:02:47.104]         }, add = TRUE)
[17:02:47.104]     }
[17:02:47.104]     ...future.frame <- base::sys.nframe()
[17:02:47.104]     ...future.conditions <- base::list()
[17:02:47.104]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.104]     if (FALSE) {
[17:02:47.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.104]     }
[17:02:47.104]     ...future.result <- base::tryCatch({
[17:02:47.104]         base::withCallingHandlers({
[17:02:47.104]             ...future.value <- base::withVisible(base::local({
[17:02:47.104]                 withCallingHandlers({
[17:02:47.104]                   {
[17:02:47.104]                     x[["a"]] <- 1
[17:02:47.104]                     x
[17:02:47.104]                   }
[17:02:47.104]                 }, immediateCondition = function(cond) {
[17:02:47.104]                   save_rds <- function (object, pathname, ...) 
[17:02:47.104]                   {
[17:02:47.104]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:47.104]                     if (file_test("-f", pathname_tmp)) {
[17:02:47.104]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.104]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:47.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.104]                         fi_tmp[["mtime"]])
[17:02:47.104]                     }
[17:02:47.104]                     tryCatch({
[17:02:47.104]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:47.104]                     }, error = function(ex) {
[17:02:47.104]                       msg <- conditionMessage(ex)
[17:02:47.104]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.104]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:47.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.104]                         fi_tmp[["mtime"]], msg)
[17:02:47.104]                       ex$message <- msg
[17:02:47.104]                       stop(ex)
[17:02:47.104]                     })
[17:02:47.104]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:47.104]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:47.104]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:47.104]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.104]                       fi <- file.info(pathname)
[17:02:47.104]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:47.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.104]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:47.104]                         fi[["size"]], fi[["mtime"]])
[17:02:47.104]                       stop(msg)
[17:02:47.104]                     }
[17:02:47.104]                     invisible(pathname)
[17:02:47.104]                   }
[17:02:47.104]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:47.104]                     rootPath = tempdir()) 
[17:02:47.104]                   {
[17:02:47.104]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:47.104]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:47.104]                       tmpdir = path, fileext = ".rds")
[17:02:47.104]                     save_rds(obj, file)
[17:02:47.104]                   }
[17:02:47.104]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:47.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.104]                   {
[17:02:47.104]                     inherits <- base::inherits
[17:02:47.104]                     invokeRestart <- base::invokeRestart
[17:02:47.104]                     is.null <- base::is.null
[17:02:47.104]                     muffled <- FALSE
[17:02:47.104]                     if (inherits(cond, "message")) {
[17:02:47.104]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.104]                       if (muffled) 
[17:02:47.104]                         invokeRestart("muffleMessage")
[17:02:47.104]                     }
[17:02:47.104]                     else if (inherits(cond, "warning")) {
[17:02:47.104]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.104]                       if (muffled) 
[17:02:47.104]                         invokeRestart("muffleWarning")
[17:02:47.104]                     }
[17:02:47.104]                     else if (inherits(cond, "condition")) {
[17:02:47.104]                       if (!is.null(pattern)) {
[17:02:47.104]                         computeRestarts <- base::computeRestarts
[17:02:47.104]                         grepl <- base::grepl
[17:02:47.104]                         restarts <- computeRestarts(cond)
[17:02:47.104]                         for (restart in restarts) {
[17:02:47.104]                           name <- restart$name
[17:02:47.104]                           if (is.null(name)) 
[17:02:47.104]                             next
[17:02:47.104]                           if (!grepl(pattern, name)) 
[17:02:47.104]                             next
[17:02:47.104]                           invokeRestart(restart)
[17:02:47.104]                           muffled <- TRUE
[17:02:47.104]                           break
[17:02:47.104]                         }
[17:02:47.104]                       }
[17:02:47.104]                     }
[17:02:47.104]                     invisible(muffled)
[17:02:47.104]                   }
[17:02:47.104]                   muffleCondition(cond)
[17:02:47.104]                 })
[17:02:47.104]             }))
[17:02:47.104]             future::FutureResult(value = ...future.value$value, 
[17:02:47.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.104]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.104]                     ...future.globalenv.names))
[17:02:47.104]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.104]         }, condition = base::local({
[17:02:47.104]             c <- base::c
[17:02:47.104]             inherits <- base::inherits
[17:02:47.104]             invokeRestart <- base::invokeRestart
[17:02:47.104]             length <- base::length
[17:02:47.104]             list <- base::list
[17:02:47.104]             seq.int <- base::seq.int
[17:02:47.104]             signalCondition <- base::signalCondition
[17:02:47.104]             sys.calls <- base::sys.calls
[17:02:47.104]             `[[` <- base::`[[`
[17:02:47.104]             `+` <- base::`+`
[17:02:47.104]             `<<-` <- base::`<<-`
[17:02:47.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.104]                   3L)]
[17:02:47.104]             }
[17:02:47.104]             function(cond) {
[17:02:47.104]                 is_error <- inherits(cond, "error")
[17:02:47.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.104]                   NULL)
[17:02:47.104]                 if (is_error) {
[17:02:47.104]                   sessionInformation <- function() {
[17:02:47.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.104]                       search = base::search(), system = base::Sys.info())
[17:02:47.104]                   }
[17:02:47.104]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.104]                     cond$call), session = sessionInformation(), 
[17:02:47.104]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.104]                   signalCondition(cond)
[17:02:47.104]                 }
[17:02:47.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.104]                 "immediateCondition"))) {
[17:02:47.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.104]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.104]                   if (TRUE && !signal) {
[17:02:47.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.104]                     {
[17:02:47.104]                       inherits <- base::inherits
[17:02:47.104]                       invokeRestart <- base::invokeRestart
[17:02:47.104]                       is.null <- base::is.null
[17:02:47.104]                       muffled <- FALSE
[17:02:47.104]                       if (inherits(cond, "message")) {
[17:02:47.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.104]                         if (muffled) 
[17:02:47.104]                           invokeRestart("muffleMessage")
[17:02:47.104]                       }
[17:02:47.104]                       else if (inherits(cond, "warning")) {
[17:02:47.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.104]                         if (muffled) 
[17:02:47.104]                           invokeRestart("muffleWarning")
[17:02:47.104]                       }
[17:02:47.104]                       else if (inherits(cond, "condition")) {
[17:02:47.104]                         if (!is.null(pattern)) {
[17:02:47.104]                           computeRestarts <- base::computeRestarts
[17:02:47.104]                           grepl <- base::grepl
[17:02:47.104]                           restarts <- computeRestarts(cond)
[17:02:47.104]                           for (restart in restarts) {
[17:02:47.104]                             name <- restart$name
[17:02:47.104]                             if (is.null(name)) 
[17:02:47.104]                               next
[17:02:47.104]                             if (!grepl(pattern, name)) 
[17:02:47.104]                               next
[17:02:47.104]                             invokeRestart(restart)
[17:02:47.104]                             muffled <- TRUE
[17:02:47.104]                             break
[17:02:47.104]                           }
[17:02:47.104]                         }
[17:02:47.104]                       }
[17:02:47.104]                       invisible(muffled)
[17:02:47.104]                     }
[17:02:47.104]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.104]                   }
[17:02:47.104]                 }
[17:02:47.104]                 else {
[17:02:47.104]                   if (TRUE) {
[17:02:47.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.104]                     {
[17:02:47.104]                       inherits <- base::inherits
[17:02:47.104]                       invokeRestart <- base::invokeRestart
[17:02:47.104]                       is.null <- base::is.null
[17:02:47.104]                       muffled <- FALSE
[17:02:47.104]                       if (inherits(cond, "message")) {
[17:02:47.104]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.104]                         if (muffled) 
[17:02:47.104]                           invokeRestart("muffleMessage")
[17:02:47.104]                       }
[17:02:47.104]                       else if (inherits(cond, "warning")) {
[17:02:47.104]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.104]                         if (muffled) 
[17:02:47.104]                           invokeRestart("muffleWarning")
[17:02:47.104]                       }
[17:02:47.104]                       else if (inherits(cond, "condition")) {
[17:02:47.104]                         if (!is.null(pattern)) {
[17:02:47.104]                           computeRestarts <- base::computeRestarts
[17:02:47.104]                           grepl <- base::grepl
[17:02:47.104]                           restarts <- computeRestarts(cond)
[17:02:47.104]                           for (restart in restarts) {
[17:02:47.104]                             name <- restart$name
[17:02:47.104]                             if (is.null(name)) 
[17:02:47.104]                               next
[17:02:47.104]                             if (!grepl(pattern, name)) 
[17:02:47.104]                               next
[17:02:47.104]                             invokeRestart(restart)
[17:02:47.104]                             muffled <- TRUE
[17:02:47.104]                             break
[17:02:47.104]                           }
[17:02:47.104]                         }
[17:02:47.104]                       }
[17:02:47.104]                       invisible(muffled)
[17:02:47.104]                     }
[17:02:47.104]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.104]                   }
[17:02:47.104]                 }
[17:02:47.104]             }
[17:02:47.104]         }))
[17:02:47.104]     }, error = function(ex) {
[17:02:47.104]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.104]                 ...future.rng), started = ...future.startTime, 
[17:02:47.104]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.104]             version = "1.8"), class = "FutureResult")
[17:02:47.104]     }, finally = {
[17:02:47.104]         if (!identical(...future.workdir, getwd())) 
[17:02:47.104]             setwd(...future.workdir)
[17:02:47.104]         {
[17:02:47.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.104]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.104]             }
[17:02:47.104]             base::options(...future.oldOptions)
[17:02:47.104]             if (.Platform$OS.type == "windows") {
[17:02:47.104]                 old_names <- names(...future.oldEnvVars)
[17:02:47.104]                 envs <- base::Sys.getenv()
[17:02:47.104]                 names <- names(envs)
[17:02:47.104]                 common <- intersect(names, old_names)
[17:02:47.104]                 added <- setdiff(names, old_names)
[17:02:47.104]                 removed <- setdiff(old_names, names)
[17:02:47.104]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.104]                   envs[common]]
[17:02:47.104]                 NAMES <- toupper(changed)
[17:02:47.104]                 args <- list()
[17:02:47.104]                 for (kk in seq_along(NAMES)) {
[17:02:47.104]                   name <- changed[[kk]]
[17:02:47.104]                   NAME <- NAMES[[kk]]
[17:02:47.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.104]                     next
[17:02:47.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.104]                 }
[17:02:47.104]                 NAMES <- toupper(added)
[17:02:47.104]                 for (kk in seq_along(NAMES)) {
[17:02:47.104]                   name <- added[[kk]]
[17:02:47.104]                   NAME <- NAMES[[kk]]
[17:02:47.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.104]                     next
[17:02:47.104]                   args[[name]] <- ""
[17:02:47.104]                 }
[17:02:47.104]                 NAMES <- toupper(removed)
[17:02:47.104]                 for (kk in seq_along(NAMES)) {
[17:02:47.104]                   name <- removed[[kk]]
[17:02:47.104]                   NAME <- NAMES[[kk]]
[17:02:47.104]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.104]                     next
[17:02:47.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.104]                 }
[17:02:47.104]                 if (length(args) > 0) 
[17:02:47.104]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.104]             }
[17:02:47.104]             else {
[17:02:47.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.104]             }
[17:02:47.104]             {
[17:02:47.104]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.104]                   0L) {
[17:02:47.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.104]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.104]                   base::options(opts)
[17:02:47.104]                 }
[17:02:47.104]                 {
[17:02:47.104]                   {
[17:02:47.104]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.104]                     NULL
[17:02:47.104]                   }
[17:02:47.104]                   options(future.plan = NULL)
[17:02:47.104]                   if (is.na(NA_character_)) 
[17:02:47.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.104]                     .init = FALSE)
[17:02:47.104]                 }
[17:02:47.104]             }
[17:02:47.104]         }
[17:02:47.104]     })
[17:02:47.104]     if (TRUE) {
[17:02:47.104]         base::sink(type = "output", split = FALSE)
[17:02:47.104]         if (TRUE) {
[17:02:47.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.104]         }
[17:02:47.104]         else {
[17:02:47.104]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.104]         }
[17:02:47.104]         base::close(...future.stdout)
[17:02:47.104]         ...future.stdout <- NULL
[17:02:47.104]     }
[17:02:47.104]     ...future.result$conditions <- ...future.conditions
[17:02:47.104]     ...future.result$finished <- base::Sys.time()
[17:02:47.104]     ...future.result
[17:02:47.104] }
[17:02:47.107] assign_globals() ...
[17:02:47.107] List of 1
[17:02:47.107]  $ x: list()
[17:02:47.107]  - attr(*, "where")=List of 1
[17:02:47.107]   ..$ x:<environment: R_EmptyEnv> 
[17:02:47.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:47.107]  - attr(*, "resolved")= logi TRUE
[17:02:47.107]  - attr(*, "total_size")= num 0
[17:02:47.107]  - attr(*, "already-done")= logi TRUE
[17:02:47.110] - copied ‘x’ to environment
[17:02:47.110] assign_globals() ... done
[17:02:47.110] requestCore(): workers = 2
[17:02:47.112] MulticoreFuture started
[17:02:47.113] - Launch lazy future ... done
[17:02:47.113] run() for ‘MulticoreFuture’ ... done
[17:02:47.113] result() for MulticoreFuture ...
[17:02:47.113] plan(): Setting new future strategy stack:
[17:02:47.114] List of future strategies:
[17:02:47.114] 1. sequential:
[17:02:47.114]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.114]    - tweaked: FALSE
[17:02:47.114]    - call: NULL
[17:02:47.115] plan(): nbrOfWorkers() = 1
[17:02:47.117] plan(): Setting new future strategy stack:
[17:02:47.117] List of future strategies:
[17:02:47.117] 1. multicore:
[17:02:47.117]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.117]    - tweaked: FALSE
[17:02:47.117]    - call: plan(strategy)
[17:02:47.122] plan(): nbrOfWorkers() = 2
[17:02:47.123] result() for MulticoreFuture ...
[17:02:47.123] result() for MulticoreFuture ... done
[17:02:47.123] result() for MulticoreFuture ... done
[17:02:47.124] result() for MulticoreFuture ...
[17:02:47.124] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.124] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.124] Searching for globals...
[17:02:47.127] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:47.128] Searching for globals ... DONE
[17:02:47.128] Resolving globals: TRUE
[17:02:47.128] Resolving any globals that are futures ...
[17:02:47.128] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:47.128] Resolving any globals that are futures ... DONE
[17:02:47.129] Resolving futures part of globals (recursively) ...
[17:02:47.129] resolve() on list ...
[17:02:47.129]  recursive: 99
[17:02:47.129]  length: 1
[17:02:47.129]  elements: ‘x’
[17:02:47.129]  length: 0 (resolved future 1)
[17:02:47.130] resolve() on list ... DONE
[17:02:47.130] - globals: [1] ‘x’
[17:02:47.130] Resolving futures part of globals (recursively) ... DONE
[17:02:47.130] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.131] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.131] - globals: [1] ‘x’
[17:02:47.131] 
[17:02:47.131] getGlobalsAndPackages() ... DONE
[17:02:47.131] run() for ‘Future’ ...
[17:02:47.131] - state: ‘created’
[17:02:47.132] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.136] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:47.136]   - Field: ‘label’
[17:02:47.136]   - Field: ‘local’
[17:02:47.136]   - Field: ‘owner’
[17:02:47.137]   - Field: ‘envir’
[17:02:47.137]   - Field: ‘workers’
[17:02:47.137]   - Field: ‘packages’
[17:02:47.137]   - Field: ‘gc’
[17:02:47.137]   - Field: ‘job’
[17:02:47.137]   - Field: ‘conditions’
[17:02:47.137]   - Field: ‘expr’
[17:02:47.137]   - Field: ‘uuid’
[17:02:47.137]   - Field: ‘seed’
[17:02:47.137]   - Field: ‘version’
[17:02:47.138]   - Field: ‘result’
[17:02:47.138]   - Field: ‘asynchronous’
[17:02:47.138]   - Field: ‘calls’
[17:02:47.138]   - Field: ‘globals’
[17:02:47.138]   - Field: ‘stdout’
[17:02:47.138]   - Field: ‘earlySignal’
[17:02:47.138]   - Field: ‘lazy’
[17:02:47.138]   - Field: ‘state’
[17:02:47.138] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:47.139] - Launch lazy future ...
[17:02:47.139] Packages needed by the future expression (n = 0): <none>
[17:02:47.139] Packages needed by future strategies (n = 0): <none>
[17:02:47.140] {
[17:02:47.140]     {
[17:02:47.140]         {
[17:02:47.140]             ...future.startTime <- base::Sys.time()
[17:02:47.140]             {
[17:02:47.140]                 {
[17:02:47.140]                   {
[17:02:47.140]                     {
[17:02:47.140]                       base::local({
[17:02:47.140]                         has_future <- base::requireNamespace("future", 
[17:02:47.140]                           quietly = TRUE)
[17:02:47.140]                         if (has_future) {
[17:02:47.140]                           ns <- base::getNamespace("future")
[17:02:47.140]                           version <- ns[[".package"]][["version"]]
[17:02:47.140]                           if (is.null(version)) 
[17:02:47.140]                             version <- utils::packageVersion("future")
[17:02:47.140]                         }
[17:02:47.140]                         else {
[17:02:47.140]                           version <- NULL
[17:02:47.140]                         }
[17:02:47.140]                         if (!has_future || version < "1.8.0") {
[17:02:47.140]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.140]                             "", base::R.version$version.string), 
[17:02:47.140]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.140]                               "release", "version")], collapse = " "), 
[17:02:47.140]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.140]                             info)
[17:02:47.140]                           info <- base::paste(info, collapse = "; ")
[17:02:47.140]                           if (!has_future) {
[17:02:47.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.140]                               info)
[17:02:47.140]                           }
[17:02:47.140]                           else {
[17:02:47.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.140]                               info, version)
[17:02:47.140]                           }
[17:02:47.140]                           base::stop(msg)
[17:02:47.140]                         }
[17:02:47.140]                       })
[17:02:47.140]                     }
[17:02:47.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.140]                     base::options(mc.cores = 1L)
[17:02:47.140]                   }
[17:02:47.140]                   ...future.strategy.old <- future::plan("list")
[17:02:47.140]                   options(future.plan = NULL)
[17:02:47.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.140]                 }
[17:02:47.140]                 ...future.workdir <- getwd()
[17:02:47.140]             }
[17:02:47.140]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.140]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.140]         }
[17:02:47.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.140]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.140]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.140]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.140]             base::names(...future.oldOptions))
[17:02:47.140]     }
[17:02:47.140]     if (FALSE) {
[17:02:47.140]     }
[17:02:47.140]     else {
[17:02:47.140]         if (TRUE) {
[17:02:47.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.140]                 open = "w")
[17:02:47.140]         }
[17:02:47.140]         else {
[17:02:47.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.140]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.140]         }
[17:02:47.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.140]             base::sink(type = "output", split = FALSE)
[17:02:47.140]             base::close(...future.stdout)
[17:02:47.140]         }, add = TRUE)
[17:02:47.140]     }
[17:02:47.140]     ...future.frame <- base::sys.nframe()
[17:02:47.140]     ...future.conditions <- base::list()
[17:02:47.140]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.140]     if (FALSE) {
[17:02:47.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.140]     }
[17:02:47.140]     ...future.result <- base::tryCatch({
[17:02:47.140]         base::withCallingHandlers({
[17:02:47.140]             ...future.value <- base::withVisible(base::local({
[17:02:47.140]                 withCallingHandlers({
[17:02:47.140]                   {
[17:02:47.140]                     x["a"] <- list(1)
[17:02:47.140]                     x
[17:02:47.140]                   }
[17:02:47.140]                 }, immediateCondition = function(cond) {
[17:02:47.140]                   save_rds <- function (object, pathname, ...) 
[17:02:47.140]                   {
[17:02:47.140]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:47.140]                     if (file_test("-f", pathname_tmp)) {
[17:02:47.140]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.140]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:47.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.140]                         fi_tmp[["mtime"]])
[17:02:47.140]                     }
[17:02:47.140]                     tryCatch({
[17:02:47.140]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:47.140]                     }, error = function(ex) {
[17:02:47.140]                       msg <- conditionMessage(ex)
[17:02:47.140]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.140]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:47.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.140]                         fi_tmp[["mtime"]], msg)
[17:02:47.140]                       ex$message <- msg
[17:02:47.140]                       stop(ex)
[17:02:47.140]                     })
[17:02:47.140]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:47.140]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:47.140]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:47.140]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.140]                       fi <- file.info(pathname)
[17:02:47.140]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:47.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.140]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:47.140]                         fi[["size"]], fi[["mtime"]])
[17:02:47.140]                       stop(msg)
[17:02:47.140]                     }
[17:02:47.140]                     invisible(pathname)
[17:02:47.140]                   }
[17:02:47.140]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:47.140]                     rootPath = tempdir()) 
[17:02:47.140]                   {
[17:02:47.140]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:47.140]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:47.140]                       tmpdir = path, fileext = ".rds")
[17:02:47.140]                     save_rds(obj, file)
[17:02:47.140]                   }
[17:02:47.140]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:47.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.140]                   {
[17:02:47.140]                     inherits <- base::inherits
[17:02:47.140]                     invokeRestart <- base::invokeRestart
[17:02:47.140]                     is.null <- base::is.null
[17:02:47.140]                     muffled <- FALSE
[17:02:47.140]                     if (inherits(cond, "message")) {
[17:02:47.140]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.140]                       if (muffled) 
[17:02:47.140]                         invokeRestart("muffleMessage")
[17:02:47.140]                     }
[17:02:47.140]                     else if (inherits(cond, "warning")) {
[17:02:47.140]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.140]                       if (muffled) 
[17:02:47.140]                         invokeRestart("muffleWarning")
[17:02:47.140]                     }
[17:02:47.140]                     else if (inherits(cond, "condition")) {
[17:02:47.140]                       if (!is.null(pattern)) {
[17:02:47.140]                         computeRestarts <- base::computeRestarts
[17:02:47.140]                         grepl <- base::grepl
[17:02:47.140]                         restarts <- computeRestarts(cond)
[17:02:47.140]                         for (restart in restarts) {
[17:02:47.140]                           name <- restart$name
[17:02:47.140]                           if (is.null(name)) 
[17:02:47.140]                             next
[17:02:47.140]                           if (!grepl(pattern, name)) 
[17:02:47.140]                             next
[17:02:47.140]                           invokeRestart(restart)
[17:02:47.140]                           muffled <- TRUE
[17:02:47.140]                           break
[17:02:47.140]                         }
[17:02:47.140]                       }
[17:02:47.140]                     }
[17:02:47.140]                     invisible(muffled)
[17:02:47.140]                   }
[17:02:47.140]                   muffleCondition(cond)
[17:02:47.140]                 })
[17:02:47.140]             }))
[17:02:47.140]             future::FutureResult(value = ...future.value$value, 
[17:02:47.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.140]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.140]                     ...future.globalenv.names))
[17:02:47.140]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.140]         }, condition = base::local({
[17:02:47.140]             c <- base::c
[17:02:47.140]             inherits <- base::inherits
[17:02:47.140]             invokeRestart <- base::invokeRestart
[17:02:47.140]             length <- base::length
[17:02:47.140]             list <- base::list
[17:02:47.140]             seq.int <- base::seq.int
[17:02:47.140]             signalCondition <- base::signalCondition
[17:02:47.140]             sys.calls <- base::sys.calls
[17:02:47.140]             `[[` <- base::`[[`
[17:02:47.140]             `+` <- base::`+`
[17:02:47.140]             `<<-` <- base::`<<-`
[17:02:47.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.140]                   3L)]
[17:02:47.140]             }
[17:02:47.140]             function(cond) {
[17:02:47.140]                 is_error <- inherits(cond, "error")
[17:02:47.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.140]                   NULL)
[17:02:47.140]                 if (is_error) {
[17:02:47.140]                   sessionInformation <- function() {
[17:02:47.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.140]                       search = base::search(), system = base::Sys.info())
[17:02:47.140]                   }
[17:02:47.140]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.140]                     cond$call), session = sessionInformation(), 
[17:02:47.140]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.140]                   signalCondition(cond)
[17:02:47.140]                 }
[17:02:47.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.140]                 "immediateCondition"))) {
[17:02:47.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.140]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.140]                   if (TRUE && !signal) {
[17:02:47.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.140]                     {
[17:02:47.140]                       inherits <- base::inherits
[17:02:47.140]                       invokeRestart <- base::invokeRestart
[17:02:47.140]                       is.null <- base::is.null
[17:02:47.140]                       muffled <- FALSE
[17:02:47.140]                       if (inherits(cond, "message")) {
[17:02:47.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.140]                         if (muffled) 
[17:02:47.140]                           invokeRestart("muffleMessage")
[17:02:47.140]                       }
[17:02:47.140]                       else if (inherits(cond, "warning")) {
[17:02:47.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.140]                         if (muffled) 
[17:02:47.140]                           invokeRestart("muffleWarning")
[17:02:47.140]                       }
[17:02:47.140]                       else if (inherits(cond, "condition")) {
[17:02:47.140]                         if (!is.null(pattern)) {
[17:02:47.140]                           computeRestarts <- base::computeRestarts
[17:02:47.140]                           grepl <- base::grepl
[17:02:47.140]                           restarts <- computeRestarts(cond)
[17:02:47.140]                           for (restart in restarts) {
[17:02:47.140]                             name <- restart$name
[17:02:47.140]                             if (is.null(name)) 
[17:02:47.140]                               next
[17:02:47.140]                             if (!grepl(pattern, name)) 
[17:02:47.140]                               next
[17:02:47.140]                             invokeRestart(restart)
[17:02:47.140]                             muffled <- TRUE
[17:02:47.140]                             break
[17:02:47.140]                           }
[17:02:47.140]                         }
[17:02:47.140]                       }
[17:02:47.140]                       invisible(muffled)
[17:02:47.140]                     }
[17:02:47.140]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.140]                   }
[17:02:47.140]                 }
[17:02:47.140]                 else {
[17:02:47.140]                   if (TRUE) {
[17:02:47.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.140]                     {
[17:02:47.140]                       inherits <- base::inherits
[17:02:47.140]                       invokeRestart <- base::invokeRestart
[17:02:47.140]                       is.null <- base::is.null
[17:02:47.140]                       muffled <- FALSE
[17:02:47.140]                       if (inherits(cond, "message")) {
[17:02:47.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.140]                         if (muffled) 
[17:02:47.140]                           invokeRestart("muffleMessage")
[17:02:47.140]                       }
[17:02:47.140]                       else if (inherits(cond, "warning")) {
[17:02:47.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.140]                         if (muffled) 
[17:02:47.140]                           invokeRestart("muffleWarning")
[17:02:47.140]                       }
[17:02:47.140]                       else if (inherits(cond, "condition")) {
[17:02:47.140]                         if (!is.null(pattern)) {
[17:02:47.140]                           computeRestarts <- base::computeRestarts
[17:02:47.140]                           grepl <- base::grepl
[17:02:47.140]                           restarts <- computeRestarts(cond)
[17:02:47.140]                           for (restart in restarts) {
[17:02:47.140]                             name <- restart$name
[17:02:47.140]                             if (is.null(name)) 
[17:02:47.140]                               next
[17:02:47.140]                             if (!grepl(pattern, name)) 
[17:02:47.140]                               next
[17:02:47.140]                             invokeRestart(restart)
[17:02:47.140]                             muffled <- TRUE
[17:02:47.140]                             break
[17:02:47.140]                           }
[17:02:47.140]                         }
[17:02:47.140]                       }
[17:02:47.140]                       invisible(muffled)
[17:02:47.140]                     }
[17:02:47.140]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.140]                   }
[17:02:47.140]                 }
[17:02:47.140]             }
[17:02:47.140]         }))
[17:02:47.140]     }, error = function(ex) {
[17:02:47.140]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.140]                 ...future.rng), started = ...future.startTime, 
[17:02:47.140]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.140]             version = "1.8"), class = "FutureResult")
[17:02:47.140]     }, finally = {
[17:02:47.140]         if (!identical(...future.workdir, getwd())) 
[17:02:47.140]             setwd(...future.workdir)
[17:02:47.140]         {
[17:02:47.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.140]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.140]             }
[17:02:47.140]             base::options(...future.oldOptions)
[17:02:47.140]             if (.Platform$OS.type == "windows") {
[17:02:47.140]                 old_names <- names(...future.oldEnvVars)
[17:02:47.140]                 envs <- base::Sys.getenv()
[17:02:47.140]                 names <- names(envs)
[17:02:47.140]                 common <- intersect(names, old_names)
[17:02:47.140]                 added <- setdiff(names, old_names)
[17:02:47.140]                 removed <- setdiff(old_names, names)
[17:02:47.140]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.140]                   envs[common]]
[17:02:47.140]                 NAMES <- toupper(changed)
[17:02:47.140]                 args <- list()
[17:02:47.140]                 for (kk in seq_along(NAMES)) {
[17:02:47.140]                   name <- changed[[kk]]
[17:02:47.140]                   NAME <- NAMES[[kk]]
[17:02:47.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.140]                     next
[17:02:47.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.140]                 }
[17:02:47.140]                 NAMES <- toupper(added)
[17:02:47.140]                 for (kk in seq_along(NAMES)) {
[17:02:47.140]                   name <- added[[kk]]
[17:02:47.140]                   NAME <- NAMES[[kk]]
[17:02:47.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.140]                     next
[17:02:47.140]                   args[[name]] <- ""
[17:02:47.140]                 }
[17:02:47.140]                 NAMES <- toupper(removed)
[17:02:47.140]                 for (kk in seq_along(NAMES)) {
[17:02:47.140]                   name <- removed[[kk]]
[17:02:47.140]                   NAME <- NAMES[[kk]]
[17:02:47.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.140]                     next
[17:02:47.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.140]                 }
[17:02:47.140]                 if (length(args) > 0) 
[17:02:47.140]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.140]             }
[17:02:47.140]             else {
[17:02:47.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.140]             }
[17:02:47.140]             {
[17:02:47.140]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.140]                   0L) {
[17:02:47.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.140]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.140]                   base::options(opts)
[17:02:47.140]                 }
[17:02:47.140]                 {
[17:02:47.140]                   {
[17:02:47.140]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.140]                     NULL
[17:02:47.140]                   }
[17:02:47.140]                   options(future.plan = NULL)
[17:02:47.140]                   if (is.na(NA_character_)) 
[17:02:47.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.140]                     .init = FALSE)
[17:02:47.140]                 }
[17:02:47.140]             }
[17:02:47.140]         }
[17:02:47.140]     })
[17:02:47.140]     if (TRUE) {
[17:02:47.140]         base::sink(type = "output", split = FALSE)
[17:02:47.140]         if (TRUE) {
[17:02:47.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.140]         }
[17:02:47.140]         else {
[17:02:47.140]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.140]         }
[17:02:47.140]         base::close(...future.stdout)
[17:02:47.140]         ...future.stdout <- NULL
[17:02:47.140]     }
[17:02:47.140]     ...future.result$conditions <- ...future.conditions
[17:02:47.140]     ...future.result$finished <- base::Sys.time()
[17:02:47.140]     ...future.result
[17:02:47.140] }
[17:02:47.142] assign_globals() ...
[17:02:47.142] List of 1
[17:02:47.142]  $ x: list()
[17:02:47.142]  - attr(*, "where")=List of 1
[17:02:47.142]   ..$ x:<environment: R_EmptyEnv> 
[17:02:47.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:47.142]  - attr(*, "resolved")= logi TRUE
[17:02:47.142]  - attr(*, "total_size")= num 0
[17:02:47.142]  - attr(*, "already-done")= logi TRUE
[17:02:47.145] - copied ‘x’ to environment
[17:02:47.145] assign_globals() ... done
[17:02:47.146] requestCore(): workers = 2
[17:02:47.148] MulticoreFuture started
[17:02:47.148] - Launch lazy future ... done
[17:02:47.148] run() for ‘MulticoreFuture’ ... done
[17:02:47.149] result() for MulticoreFuture ...
[17:02:47.149] plan(): Setting new future strategy stack:
[17:02:47.149] List of future strategies:
[17:02:47.149] 1. sequential:
[17:02:47.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.149]    - tweaked: FALSE
[17:02:47.149]    - call: NULL
[17:02:47.150] plan(): nbrOfWorkers() = 1
[17:02:47.152] plan(): Setting new future strategy stack:
[17:02:47.152] List of future strategies:
[17:02:47.152] 1. multicore:
[17:02:47.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.152]    - tweaked: FALSE
[17:02:47.152]    - call: plan(strategy)
[17:02:47.158] plan(): nbrOfWorkers() = 2
[17:02:47.159] result() for MulticoreFuture ...
[17:02:47.159] result() for MulticoreFuture ... done
[17:02:47.159] result() for MulticoreFuture ... done
[17:02:47.160] result() for MulticoreFuture ...
[17:02:47.160] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.160] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.160] Searching for globals...
[17:02:47.167] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:47.167] Searching for globals ... DONE
[17:02:47.167] Resolving globals: TRUE
[17:02:47.167] Resolving any globals that are futures ...
[17:02:47.167] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:47.167] Resolving any globals that are futures ... DONE
[17:02:47.168] Resolving futures part of globals (recursively) ...
[17:02:47.168] resolve() on list ...
[17:02:47.168]  recursive: 99
[17:02:47.169]  length: 1
[17:02:47.169]  elements: ‘x’
[17:02:47.169]  length: 0 (resolved future 1)
[17:02:47.169] resolve() on list ... DONE
[17:02:47.169] - globals: [1] ‘x’
[17:02:47.169] Resolving futures part of globals (recursively) ... DONE
[17:02:47.169] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.170] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.170] - globals: [1] ‘x’
[17:02:47.170] 
[17:02:47.170] getGlobalsAndPackages() ... DONE
[17:02:47.171] run() for ‘Future’ ...
[17:02:47.171] - state: ‘created’
[17:02:47.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.175] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:47.176]   - Field: ‘label’
[17:02:47.176]   - Field: ‘local’
[17:02:47.176]   - Field: ‘owner’
[17:02:47.176]   - Field: ‘envir’
[17:02:47.176]   - Field: ‘workers’
[17:02:47.176]   - Field: ‘packages’
[17:02:47.176]   - Field: ‘gc’
[17:02:47.177]   - Field: ‘job’
[17:02:47.177]   - Field: ‘conditions’
[17:02:47.177]   - Field: ‘expr’
[17:02:47.177]   - Field: ‘uuid’
[17:02:47.177]   - Field: ‘seed’
[17:02:47.177]   - Field: ‘version’
[17:02:47.177]   - Field: ‘result’
[17:02:47.177]   - Field: ‘asynchronous’
[17:02:47.177]   - Field: ‘calls’
[17:02:47.178]   - Field: ‘globals’
[17:02:47.178]   - Field: ‘stdout’
[17:02:47.178]   - Field: ‘earlySignal’
[17:02:47.178]   - Field: ‘lazy’
[17:02:47.178]   - Field: ‘state’
[17:02:47.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:47.178] - Launch lazy future ...
[17:02:47.179] Packages needed by the future expression (n = 0): <none>
[17:02:47.179] Packages needed by future strategies (n = 0): <none>
[17:02:47.179] {
[17:02:47.179]     {
[17:02:47.179]         {
[17:02:47.179]             ...future.startTime <- base::Sys.time()
[17:02:47.179]             {
[17:02:47.179]                 {
[17:02:47.179]                   {
[17:02:47.179]                     {
[17:02:47.179]                       base::local({
[17:02:47.179]                         has_future <- base::requireNamespace("future", 
[17:02:47.179]                           quietly = TRUE)
[17:02:47.179]                         if (has_future) {
[17:02:47.179]                           ns <- base::getNamespace("future")
[17:02:47.179]                           version <- ns[[".package"]][["version"]]
[17:02:47.179]                           if (is.null(version)) 
[17:02:47.179]                             version <- utils::packageVersion("future")
[17:02:47.179]                         }
[17:02:47.179]                         else {
[17:02:47.179]                           version <- NULL
[17:02:47.179]                         }
[17:02:47.179]                         if (!has_future || version < "1.8.0") {
[17:02:47.179]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.179]                             "", base::R.version$version.string), 
[17:02:47.179]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.179]                               "release", "version")], collapse = " "), 
[17:02:47.179]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.179]                             info)
[17:02:47.179]                           info <- base::paste(info, collapse = "; ")
[17:02:47.179]                           if (!has_future) {
[17:02:47.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.179]                               info)
[17:02:47.179]                           }
[17:02:47.179]                           else {
[17:02:47.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.179]                               info, version)
[17:02:47.179]                           }
[17:02:47.179]                           base::stop(msg)
[17:02:47.179]                         }
[17:02:47.179]                       })
[17:02:47.179]                     }
[17:02:47.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.179]                     base::options(mc.cores = 1L)
[17:02:47.179]                   }
[17:02:47.179]                   ...future.strategy.old <- future::plan("list")
[17:02:47.179]                   options(future.plan = NULL)
[17:02:47.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.179]                 }
[17:02:47.179]                 ...future.workdir <- getwd()
[17:02:47.179]             }
[17:02:47.179]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.179]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.179]         }
[17:02:47.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.179]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.179]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.179]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.179]             base::names(...future.oldOptions))
[17:02:47.179]     }
[17:02:47.179]     if (FALSE) {
[17:02:47.179]     }
[17:02:47.179]     else {
[17:02:47.179]         if (TRUE) {
[17:02:47.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.179]                 open = "w")
[17:02:47.179]         }
[17:02:47.179]         else {
[17:02:47.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.179]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.179]         }
[17:02:47.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.179]             base::sink(type = "output", split = FALSE)
[17:02:47.179]             base::close(...future.stdout)
[17:02:47.179]         }, add = TRUE)
[17:02:47.179]     }
[17:02:47.179]     ...future.frame <- base::sys.nframe()
[17:02:47.179]     ...future.conditions <- base::list()
[17:02:47.179]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.179]     if (FALSE) {
[17:02:47.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.179]     }
[17:02:47.179]     ...future.result <- base::tryCatch({
[17:02:47.179]         base::withCallingHandlers({
[17:02:47.179]             ...future.value <- base::withVisible(base::local({
[17:02:47.179]                 withCallingHandlers({
[17:02:47.179]                   {
[17:02:47.179]                     x["a"] <- list(1)
[17:02:47.179]                     x
[17:02:47.179]                   }
[17:02:47.179]                 }, immediateCondition = function(cond) {
[17:02:47.179]                   save_rds <- function (object, pathname, ...) 
[17:02:47.179]                   {
[17:02:47.179]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:47.179]                     if (file_test("-f", pathname_tmp)) {
[17:02:47.179]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.179]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:47.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.179]                         fi_tmp[["mtime"]])
[17:02:47.179]                     }
[17:02:47.179]                     tryCatch({
[17:02:47.179]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:47.179]                     }, error = function(ex) {
[17:02:47.179]                       msg <- conditionMessage(ex)
[17:02:47.179]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.179]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:47.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.179]                         fi_tmp[["mtime"]], msg)
[17:02:47.179]                       ex$message <- msg
[17:02:47.179]                       stop(ex)
[17:02:47.179]                     })
[17:02:47.179]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:47.179]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:47.179]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:47.179]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.179]                       fi <- file.info(pathname)
[17:02:47.179]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:47.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.179]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:47.179]                         fi[["size"]], fi[["mtime"]])
[17:02:47.179]                       stop(msg)
[17:02:47.179]                     }
[17:02:47.179]                     invisible(pathname)
[17:02:47.179]                   }
[17:02:47.179]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:47.179]                     rootPath = tempdir()) 
[17:02:47.179]                   {
[17:02:47.179]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:47.179]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:47.179]                       tmpdir = path, fileext = ".rds")
[17:02:47.179]                     save_rds(obj, file)
[17:02:47.179]                   }
[17:02:47.179]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:47.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.179]                   {
[17:02:47.179]                     inherits <- base::inherits
[17:02:47.179]                     invokeRestart <- base::invokeRestart
[17:02:47.179]                     is.null <- base::is.null
[17:02:47.179]                     muffled <- FALSE
[17:02:47.179]                     if (inherits(cond, "message")) {
[17:02:47.179]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.179]                       if (muffled) 
[17:02:47.179]                         invokeRestart("muffleMessage")
[17:02:47.179]                     }
[17:02:47.179]                     else if (inherits(cond, "warning")) {
[17:02:47.179]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.179]                       if (muffled) 
[17:02:47.179]                         invokeRestart("muffleWarning")
[17:02:47.179]                     }
[17:02:47.179]                     else if (inherits(cond, "condition")) {
[17:02:47.179]                       if (!is.null(pattern)) {
[17:02:47.179]                         computeRestarts <- base::computeRestarts
[17:02:47.179]                         grepl <- base::grepl
[17:02:47.179]                         restarts <- computeRestarts(cond)
[17:02:47.179]                         for (restart in restarts) {
[17:02:47.179]                           name <- restart$name
[17:02:47.179]                           if (is.null(name)) 
[17:02:47.179]                             next
[17:02:47.179]                           if (!grepl(pattern, name)) 
[17:02:47.179]                             next
[17:02:47.179]                           invokeRestart(restart)
[17:02:47.179]                           muffled <- TRUE
[17:02:47.179]                           break
[17:02:47.179]                         }
[17:02:47.179]                       }
[17:02:47.179]                     }
[17:02:47.179]                     invisible(muffled)
[17:02:47.179]                   }
[17:02:47.179]                   muffleCondition(cond)
[17:02:47.179]                 })
[17:02:47.179]             }))
[17:02:47.179]             future::FutureResult(value = ...future.value$value, 
[17:02:47.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.179]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.179]                     ...future.globalenv.names))
[17:02:47.179]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.179]         }, condition = base::local({
[17:02:47.179]             c <- base::c
[17:02:47.179]             inherits <- base::inherits
[17:02:47.179]             invokeRestart <- base::invokeRestart
[17:02:47.179]             length <- base::length
[17:02:47.179]             list <- base::list
[17:02:47.179]             seq.int <- base::seq.int
[17:02:47.179]             signalCondition <- base::signalCondition
[17:02:47.179]             sys.calls <- base::sys.calls
[17:02:47.179]             `[[` <- base::`[[`
[17:02:47.179]             `+` <- base::`+`
[17:02:47.179]             `<<-` <- base::`<<-`
[17:02:47.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.179]                   3L)]
[17:02:47.179]             }
[17:02:47.179]             function(cond) {
[17:02:47.179]                 is_error <- inherits(cond, "error")
[17:02:47.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.179]                   NULL)
[17:02:47.179]                 if (is_error) {
[17:02:47.179]                   sessionInformation <- function() {
[17:02:47.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.179]                       search = base::search(), system = base::Sys.info())
[17:02:47.179]                   }
[17:02:47.179]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.179]                     cond$call), session = sessionInformation(), 
[17:02:47.179]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.179]                   signalCondition(cond)
[17:02:47.179]                 }
[17:02:47.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.179]                 "immediateCondition"))) {
[17:02:47.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.179]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.179]                   if (TRUE && !signal) {
[17:02:47.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.179]                     {
[17:02:47.179]                       inherits <- base::inherits
[17:02:47.179]                       invokeRestart <- base::invokeRestart
[17:02:47.179]                       is.null <- base::is.null
[17:02:47.179]                       muffled <- FALSE
[17:02:47.179]                       if (inherits(cond, "message")) {
[17:02:47.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.179]                         if (muffled) 
[17:02:47.179]                           invokeRestart("muffleMessage")
[17:02:47.179]                       }
[17:02:47.179]                       else if (inherits(cond, "warning")) {
[17:02:47.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.179]                         if (muffled) 
[17:02:47.179]                           invokeRestart("muffleWarning")
[17:02:47.179]                       }
[17:02:47.179]                       else if (inherits(cond, "condition")) {
[17:02:47.179]                         if (!is.null(pattern)) {
[17:02:47.179]                           computeRestarts <- base::computeRestarts
[17:02:47.179]                           grepl <- base::grepl
[17:02:47.179]                           restarts <- computeRestarts(cond)
[17:02:47.179]                           for (restart in restarts) {
[17:02:47.179]                             name <- restart$name
[17:02:47.179]                             if (is.null(name)) 
[17:02:47.179]                               next
[17:02:47.179]                             if (!grepl(pattern, name)) 
[17:02:47.179]                               next
[17:02:47.179]                             invokeRestart(restart)
[17:02:47.179]                             muffled <- TRUE
[17:02:47.179]                             break
[17:02:47.179]                           }
[17:02:47.179]                         }
[17:02:47.179]                       }
[17:02:47.179]                       invisible(muffled)
[17:02:47.179]                     }
[17:02:47.179]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.179]                   }
[17:02:47.179]                 }
[17:02:47.179]                 else {
[17:02:47.179]                   if (TRUE) {
[17:02:47.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.179]                     {
[17:02:47.179]                       inherits <- base::inherits
[17:02:47.179]                       invokeRestart <- base::invokeRestart
[17:02:47.179]                       is.null <- base::is.null
[17:02:47.179]                       muffled <- FALSE
[17:02:47.179]                       if (inherits(cond, "message")) {
[17:02:47.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.179]                         if (muffled) 
[17:02:47.179]                           invokeRestart("muffleMessage")
[17:02:47.179]                       }
[17:02:47.179]                       else if (inherits(cond, "warning")) {
[17:02:47.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.179]                         if (muffled) 
[17:02:47.179]                           invokeRestart("muffleWarning")
[17:02:47.179]                       }
[17:02:47.179]                       else if (inherits(cond, "condition")) {
[17:02:47.179]                         if (!is.null(pattern)) {
[17:02:47.179]                           computeRestarts <- base::computeRestarts
[17:02:47.179]                           grepl <- base::grepl
[17:02:47.179]                           restarts <- computeRestarts(cond)
[17:02:47.179]                           for (restart in restarts) {
[17:02:47.179]                             name <- restart$name
[17:02:47.179]                             if (is.null(name)) 
[17:02:47.179]                               next
[17:02:47.179]                             if (!grepl(pattern, name)) 
[17:02:47.179]                               next
[17:02:47.179]                             invokeRestart(restart)
[17:02:47.179]                             muffled <- TRUE
[17:02:47.179]                             break
[17:02:47.179]                           }
[17:02:47.179]                         }
[17:02:47.179]                       }
[17:02:47.179]                       invisible(muffled)
[17:02:47.179]                     }
[17:02:47.179]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.179]                   }
[17:02:47.179]                 }
[17:02:47.179]             }
[17:02:47.179]         }))
[17:02:47.179]     }, error = function(ex) {
[17:02:47.179]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.179]                 ...future.rng), started = ...future.startTime, 
[17:02:47.179]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.179]             version = "1.8"), class = "FutureResult")
[17:02:47.179]     }, finally = {
[17:02:47.179]         if (!identical(...future.workdir, getwd())) 
[17:02:47.179]             setwd(...future.workdir)
[17:02:47.179]         {
[17:02:47.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.179]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.179]             }
[17:02:47.179]             base::options(...future.oldOptions)
[17:02:47.179]             if (.Platform$OS.type == "windows") {
[17:02:47.179]                 old_names <- names(...future.oldEnvVars)
[17:02:47.179]                 envs <- base::Sys.getenv()
[17:02:47.179]                 names <- names(envs)
[17:02:47.179]                 common <- intersect(names, old_names)
[17:02:47.179]                 added <- setdiff(names, old_names)
[17:02:47.179]                 removed <- setdiff(old_names, names)
[17:02:47.179]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.179]                   envs[common]]
[17:02:47.179]                 NAMES <- toupper(changed)
[17:02:47.179]                 args <- list()
[17:02:47.179]                 for (kk in seq_along(NAMES)) {
[17:02:47.179]                   name <- changed[[kk]]
[17:02:47.179]                   NAME <- NAMES[[kk]]
[17:02:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.179]                     next
[17:02:47.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.179]                 }
[17:02:47.179]                 NAMES <- toupper(added)
[17:02:47.179]                 for (kk in seq_along(NAMES)) {
[17:02:47.179]                   name <- added[[kk]]
[17:02:47.179]                   NAME <- NAMES[[kk]]
[17:02:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.179]                     next
[17:02:47.179]                   args[[name]] <- ""
[17:02:47.179]                 }
[17:02:47.179]                 NAMES <- toupper(removed)
[17:02:47.179]                 for (kk in seq_along(NAMES)) {
[17:02:47.179]                   name <- removed[[kk]]
[17:02:47.179]                   NAME <- NAMES[[kk]]
[17:02:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.179]                     next
[17:02:47.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.179]                 }
[17:02:47.179]                 if (length(args) > 0) 
[17:02:47.179]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.179]             }
[17:02:47.179]             else {
[17:02:47.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.179]             }
[17:02:47.179]             {
[17:02:47.179]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.179]                   0L) {
[17:02:47.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.179]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.179]                   base::options(opts)
[17:02:47.179]                 }
[17:02:47.179]                 {
[17:02:47.179]                   {
[17:02:47.179]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.179]                     NULL
[17:02:47.179]                   }
[17:02:47.179]                   options(future.plan = NULL)
[17:02:47.179]                   if (is.na(NA_character_)) 
[17:02:47.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.179]                     .init = FALSE)
[17:02:47.179]                 }
[17:02:47.179]             }
[17:02:47.179]         }
[17:02:47.179]     })
[17:02:47.179]     if (TRUE) {
[17:02:47.179]         base::sink(type = "output", split = FALSE)
[17:02:47.179]         if (TRUE) {
[17:02:47.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.179]         }
[17:02:47.179]         else {
[17:02:47.179]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.179]         }
[17:02:47.179]         base::close(...future.stdout)
[17:02:47.179]         ...future.stdout <- NULL
[17:02:47.179]     }
[17:02:47.179]     ...future.result$conditions <- ...future.conditions
[17:02:47.179]     ...future.result$finished <- base::Sys.time()
[17:02:47.179]     ...future.result
[17:02:47.179] }
[17:02:47.182] assign_globals() ...
[17:02:47.182] List of 1
[17:02:47.182]  $ x: list()
[17:02:47.182]  - attr(*, "where")=List of 1
[17:02:47.182]   ..$ x:<environment: R_EmptyEnv> 
[17:02:47.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:47.182]  - attr(*, "resolved")= logi TRUE
[17:02:47.182]  - attr(*, "total_size")= num 0
[17:02:47.182]  - attr(*, "already-done")= logi TRUE
[17:02:47.185] - copied ‘x’ to environment
[17:02:47.185] assign_globals() ... done
[17:02:47.185] requestCore(): workers = 2
[17:02:47.187] MulticoreFuture started
[17:02:47.188] - Launch lazy future ... done
[17:02:47.188] run() for ‘MulticoreFuture’ ... done
[17:02:47.188] result() for MulticoreFuture ...
[17:02:47.188] plan(): Setting new future strategy stack:
[17:02:47.189] List of future strategies:
[17:02:47.189] 1. sequential:
[17:02:47.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.189]    - tweaked: FALSE
[17:02:47.189]    - call: NULL
[17:02:47.190] plan(): nbrOfWorkers() = 1
[17:02:47.192] plan(): Setting new future strategy stack:
[17:02:47.192] List of future strategies:
[17:02:47.192] 1. multicore:
[17:02:47.192]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.192]    - tweaked: FALSE
[17:02:47.192]    - call: plan(strategy)
[17:02:47.197] plan(): nbrOfWorkers() = 2
[17:02:47.198] result() for MulticoreFuture ...
[17:02:47.198] result() for MulticoreFuture ... done
[17:02:47.199] result() for MulticoreFuture ... done
[17:02:47.199] result() for MulticoreFuture ...
[17:02:47.199] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.200] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.200] Searching for globals...
[17:02:47.203] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:47.204] Searching for globals ... DONE
[17:02:47.204] Resolving globals: TRUE
[17:02:47.204] Resolving any globals that are futures ...
[17:02:47.204] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:47.204] Resolving any globals that are futures ... DONE
[17:02:47.205] Resolving futures part of globals (recursively) ...
[17:02:47.205] resolve() on list ...
[17:02:47.205]  recursive: 99
[17:02:47.205]  length: 1
[17:02:47.205]  elements: ‘x’
[17:02:47.205]  length: 0 (resolved future 1)
[17:02:47.206] resolve() on list ... DONE
[17:02:47.206] - globals: [1] ‘x’
[17:02:47.206] Resolving futures part of globals (recursively) ... DONE
[17:02:47.206] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.206] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.207] - globals: [1] ‘x’
[17:02:47.207] 
[17:02:47.207] getGlobalsAndPackages() ... DONE
[17:02:47.207] run() for ‘Future’ ...
[17:02:47.207] - state: ‘created’
[17:02:47.207] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.211] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.212] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:47.212]   - Field: ‘label’
[17:02:47.212]   - Field: ‘local’
[17:02:47.212]   - Field: ‘owner’
[17:02:47.212]   - Field: ‘envir’
[17:02:47.212]   - Field: ‘workers’
[17:02:47.212]   - Field: ‘packages’
[17:02:47.212]   - Field: ‘gc’
[17:02:47.213]   - Field: ‘job’
[17:02:47.213]   - Field: ‘conditions’
[17:02:47.213]   - Field: ‘expr’
[17:02:47.213]   - Field: ‘uuid’
[17:02:47.213]   - Field: ‘seed’
[17:02:47.213]   - Field: ‘version’
[17:02:47.213]   - Field: ‘result’
[17:02:47.213]   - Field: ‘asynchronous’
[17:02:47.213]   - Field: ‘calls’
[17:02:47.214]   - Field: ‘globals’
[17:02:47.214]   - Field: ‘stdout’
[17:02:47.214]   - Field: ‘earlySignal’
[17:02:47.214]   - Field: ‘lazy’
[17:02:47.214]   - Field: ‘state’
[17:02:47.214] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:47.214] - Launch lazy future ...
[17:02:47.215] Packages needed by the future expression (n = 0): <none>
[17:02:47.215] Packages needed by future strategies (n = 0): <none>
[17:02:47.215] {
[17:02:47.215]     {
[17:02:47.215]         {
[17:02:47.215]             ...future.startTime <- base::Sys.time()
[17:02:47.215]             {
[17:02:47.215]                 {
[17:02:47.215]                   {
[17:02:47.215]                     {
[17:02:47.215]                       base::local({
[17:02:47.215]                         has_future <- base::requireNamespace("future", 
[17:02:47.215]                           quietly = TRUE)
[17:02:47.215]                         if (has_future) {
[17:02:47.215]                           ns <- base::getNamespace("future")
[17:02:47.215]                           version <- ns[[".package"]][["version"]]
[17:02:47.215]                           if (is.null(version)) 
[17:02:47.215]                             version <- utils::packageVersion("future")
[17:02:47.215]                         }
[17:02:47.215]                         else {
[17:02:47.215]                           version <- NULL
[17:02:47.215]                         }
[17:02:47.215]                         if (!has_future || version < "1.8.0") {
[17:02:47.215]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.215]                             "", base::R.version$version.string), 
[17:02:47.215]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.215]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.215]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.215]                               "release", "version")], collapse = " "), 
[17:02:47.215]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.215]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.215]                             info)
[17:02:47.215]                           info <- base::paste(info, collapse = "; ")
[17:02:47.215]                           if (!has_future) {
[17:02:47.215]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.215]                               info)
[17:02:47.215]                           }
[17:02:47.215]                           else {
[17:02:47.215]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.215]                               info, version)
[17:02:47.215]                           }
[17:02:47.215]                           base::stop(msg)
[17:02:47.215]                         }
[17:02:47.215]                       })
[17:02:47.215]                     }
[17:02:47.215]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.215]                     base::options(mc.cores = 1L)
[17:02:47.215]                   }
[17:02:47.215]                   ...future.strategy.old <- future::plan("list")
[17:02:47.215]                   options(future.plan = NULL)
[17:02:47.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.215]                 }
[17:02:47.215]                 ...future.workdir <- getwd()
[17:02:47.215]             }
[17:02:47.215]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.215]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.215]         }
[17:02:47.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.215]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.215]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.215]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.215]             base::names(...future.oldOptions))
[17:02:47.215]     }
[17:02:47.215]     if (FALSE) {
[17:02:47.215]     }
[17:02:47.215]     else {
[17:02:47.215]         if (TRUE) {
[17:02:47.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.215]                 open = "w")
[17:02:47.215]         }
[17:02:47.215]         else {
[17:02:47.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.215]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.215]         }
[17:02:47.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.215]             base::sink(type = "output", split = FALSE)
[17:02:47.215]             base::close(...future.stdout)
[17:02:47.215]         }, add = TRUE)
[17:02:47.215]     }
[17:02:47.215]     ...future.frame <- base::sys.nframe()
[17:02:47.215]     ...future.conditions <- base::list()
[17:02:47.215]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.215]     if (FALSE) {
[17:02:47.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.215]     }
[17:02:47.215]     ...future.result <- base::tryCatch({
[17:02:47.215]         base::withCallingHandlers({
[17:02:47.215]             ...future.value <- base::withVisible(base::local({
[17:02:47.215]                 withCallingHandlers({
[17:02:47.215]                   {
[17:02:47.215]                     x["a"] <- list(1)
[17:02:47.215]                     x
[17:02:47.215]                   }
[17:02:47.215]                 }, immediateCondition = function(cond) {
[17:02:47.215]                   save_rds <- function (object, pathname, ...) 
[17:02:47.215]                   {
[17:02:47.215]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:47.215]                     if (file_test("-f", pathname_tmp)) {
[17:02:47.215]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.215]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:47.215]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.215]                         fi_tmp[["mtime"]])
[17:02:47.215]                     }
[17:02:47.215]                     tryCatch({
[17:02:47.215]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:47.215]                     }, error = function(ex) {
[17:02:47.215]                       msg <- conditionMessage(ex)
[17:02:47.215]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.215]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:47.215]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.215]                         fi_tmp[["mtime"]], msg)
[17:02:47.215]                       ex$message <- msg
[17:02:47.215]                       stop(ex)
[17:02:47.215]                     })
[17:02:47.215]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:47.215]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:47.215]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:47.215]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.215]                       fi <- file.info(pathname)
[17:02:47.215]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:47.215]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.215]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:47.215]                         fi[["size"]], fi[["mtime"]])
[17:02:47.215]                       stop(msg)
[17:02:47.215]                     }
[17:02:47.215]                     invisible(pathname)
[17:02:47.215]                   }
[17:02:47.215]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:47.215]                     rootPath = tempdir()) 
[17:02:47.215]                   {
[17:02:47.215]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:47.215]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:47.215]                       tmpdir = path, fileext = ".rds")
[17:02:47.215]                     save_rds(obj, file)
[17:02:47.215]                   }
[17:02:47.215]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:47.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.215]                   {
[17:02:47.215]                     inherits <- base::inherits
[17:02:47.215]                     invokeRestart <- base::invokeRestart
[17:02:47.215]                     is.null <- base::is.null
[17:02:47.215]                     muffled <- FALSE
[17:02:47.215]                     if (inherits(cond, "message")) {
[17:02:47.215]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.215]                       if (muffled) 
[17:02:47.215]                         invokeRestart("muffleMessage")
[17:02:47.215]                     }
[17:02:47.215]                     else if (inherits(cond, "warning")) {
[17:02:47.215]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.215]                       if (muffled) 
[17:02:47.215]                         invokeRestart("muffleWarning")
[17:02:47.215]                     }
[17:02:47.215]                     else if (inherits(cond, "condition")) {
[17:02:47.215]                       if (!is.null(pattern)) {
[17:02:47.215]                         computeRestarts <- base::computeRestarts
[17:02:47.215]                         grepl <- base::grepl
[17:02:47.215]                         restarts <- computeRestarts(cond)
[17:02:47.215]                         for (restart in restarts) {
[17:02:47.215]                           name <- restart$name
[17:02:47.215]                           if (is.null(name)) 
[17:02:47.215]                             next
[17:02:47.215]                           if (!grepl(pattern, name)) 
[17:02:47.215]                             next
[17:02:47.215]                           invokeRestart(restart)
[17:02:47.215]                           muffled <- TRUE
[17:02:47.215]                           break
[17:02:47.215]                         }
[17:02:47.215]                       }
[17:02:47.215]                     }
[17:02:47.215]                     invisible(muffled)
[17:02:47.215]                   }
[17:02:47.215]                   muffleCondition(cond)
[17:02:47.215]                 })
[17:02:47.215]             }))
[17:02:47.215]             future::FutureResult(value = ...future.value$value, 
[17:02:47.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.215]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.215]                     ...future.globalenv.names))
[17:02:47.215]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.215]         }, condition = base::local({
[17:02:47.215]             c <- base::c
[17:02:47.215]             inherits <- base::inherits
[17:02:47.215]             invokeRestart <- base::invokeRestart
[17:02:47.215]             length <- base::length
[17:02:47.215]             list <- base::list
[17:02:47.215]             seq.int <- base::seq.int
[17:02:47.215]             signalCondition <- base::signalCondition
[17:02:47.215]             sys.calls <- base::sys.calls
[17:02:47.215]             `[[` <- base::`[[`
[17:02:47.215]             `+` <- base::`+`
[17:02:47.215]             `<<-` <- base::`<<-`
[17:02:47.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.215]                   3L)]
[17:02:47.215]             }
[17:02:47.215]             function(cond) {
[17:02:47.215]                 is_error <- inherits(cond, "error")
[17:02:47.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.215]                   NULL)
[17:02:47.215]                 if (is_error) {
[17:02:47.215]                   sessionInformation <- function() {
[17:02:47.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.215]                       search = base::search(), system = base::Sys.info())
[17:02:47.215]                   }
[17:02:47.215]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.215]                     cond$call), session = sessionInformation(), 
[17:02:47.215]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.215]                   signalCondition(cond)
[17:02:47.215]                 }
[17:02:47.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.215]                 "immediateCondition"))) {
[17:02:47.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.215]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.215]                   if (TRUE && !signal) {
[17:02:47.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.215]                     {
[17:02:47.215]                       inherits <- base::inherits
[17:02:47.215]                       invokeRestart <- base::invokeRestart
[17:02:47.215]                       is.null <- base::is.null
[17:02:47.215]                       muffled <- FALSE
[17:02:47.215]                       if (inherits(cond, "message")) {
[17:02:47.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.215]                         if (muffled) 
[17:02:47.215]                           invokeRestart("muffleMessage")
[17:02:47.215]                       }
[17:02:47.215]                       else if (inherits(cond, "warning")) {
[17:02:47.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.215]                         if (muffled) 
[17:02:47.215]                           invokeRestart("muffleWarning")
[17:02:47.215]                       }
[17:02:47.215]                       else if (inherits(cond, "condition")) {
[17:02:47.215]                         if (!is.null(pattern)) {
[17:02:47.215]                           computeRestarts <- base::computeRestarts
[17:02:47.215]                           grepl <- base::grepl
[17:02:47.215]                           restarts <- computeRestarts(cond)
[17:02:47.215]                           for (restart in restarts) {
[17:02:47.215]                             name <- restart$name
[17:02:47.215]                             if (is.null(name)) 
[17:02:47.215]                               next
[17:02:47.215]                             if (!grepl(pattern, name)) 
[17:02:47.215]                               next
[17:02:47.215]                             invokeRestart(restart)
[17:02:47.215]                             muffled <- TRUE
[17:02:47.215]                             break
[17:02:47.215]                           }
[17:02:47.215]                         }
[17:02:47.215]                       }
[17:02:47.215]                       invisible(muffled)
[17:02:47.215]                     }
[17:02:47.215]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.215]                   }
[17:02:47.215]                 }
[17:02:47.215]                 else {
[17:02:47.215]                   if (TRUE) {
[17:02:47.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.215]                     {
[17:02:47.215]                       inherits <- base::inherits
[17:02:47.215]                       invokeRestart <- base::invokeRestart
[17:02:47.215]                       is.null <- base::is.null
[17:02:47.215]                       muffled <- FALSE
[17:02:47.215]                       if (inherits(cond, "message")) {
[17:02:47.215]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.215]                         if (muffled) 
[17:02:47.215]                           invokeRestart("muffleMessage")
[17:02:47.215]                       }
[17:02:47.215]                       else if (inherits(cond, "warning")) {
[17:02:47.215]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.215]                         if (muffled) 
[17:02:47.215]                           invokeRestart("muffleWarning")
[17:02:47.215]                       }
[17:02:47.215]                       else if (inherits(cond, "condition")) {
[17:02:47.215]                         if (!is.null(pattern)) {
[17:02:47.215]                           computeRestarts <- base::computeRestarts
[17:02:47.215]                           grepl <- base::grepl
[17:02:47.215]                           restarts <- computeRestarts(cond)
[17:02:47.215]                           for (restart in restarts) {
[17:02:47.215]                             name <- restart$name
[17:02:47.215]                             if (is.null(name)) 
[17:02:47.215]                               next
[17:02:47.215]                             if (!grepl(pattern, name)) 
[17:02:47.215]                               next
[17:02:47.215]                             invokeRestart(restart)
[17:02:47.215]                             muffled <- TRUE
[17:02:47.215]                             break
[17:02:47.215]                           }
[17:02:47.215]                         }
[17:02:47.215]                       }
[17:02:47.215]                       invisible(muffled)
[17:02:47.215]                     }
[17:02:47.215]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.215]                   }
[17:02:47.215]                 }
[17:02:47.215]             }
[17:02:47.215]         }))
[17:02:47.215]     }, error = function(ex) {
[17:02:47.215]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.215]                 ...future.rng), started = ...future.startTime, 
[17:02:47.215]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.215]             version = "1.8"), class = "FutureResult")
[17:02:47.215]     }, finally = {
[17:02:47.215]         if (!identical(...future.workdir, getwd())) 
[17:02:47.215]             setwd(...future.workdir)
[17:02:47.215]         {
[17:02:47.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.215]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.215]             }
[17:02:47.215]             base::options(...future.oldOptions)
[17:02:47.215]             if (.Platform$OS.type == "windows") {
[17:02:47.215]                 old_names <- names(...future.oldEnvVars)
[17:02:47.215]                 envs <- base::Sys.getenv()
[17:02:47.215]                 names <- names(envs)
[17:02:47.215]                 common <- intersect(names, old_names)
[17:02:47.215]                 added <- setdiff(names, old_names)
[17:02:47.215]                 removed <- setdiff(old_names, names)
[17:02:47.215]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.215]                   envs[common]]
[17:02:47.215]                 NAMES <- toupper(changed)
[17:02:47.215]                 args <- list()
[17:02:47.215]                 for (kk in seq_along(NAMES)) {
[17:02:47.215]                   name <- changed[[kk]]
[17:02:47.215]                   NAME <- NAMES[[kk]]
[17:02:47.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.215]                     next
[17:02:47.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.215]                 }
[17:02:47.215]                 NAMES <- toupper(added)
[17:02:47.215]                 for (kk in seq_along(NAMES)) {
[17:02:47.215]                   name <- added[[kk]]
[17:02:47.215]                   NAME <- NAMES[[kk]]
[17:02:47.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.215]                     next
[17:02:47.215]                   args[[name]] <- ""
[17:02:47.215]                 }
[17:02:47.215]                 NAMES <- toupper(removed)
[17:02:47.215]                 for (kk in seq_along(NAMES)) {
[17:02:47.215]                   name <- removed[[kk]]
[17:02:47.215]                   NAME <- NAMES[[kk]]
[17:02:47.215]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.215]                     next
[17:02:47.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.215]                 }
[17:02:47.215]                 if (length(args) > 0) 
[17:02:47.215]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.215]             }
[17:02:47.215]             else {
[17:02:47.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.215]             }
[17:02:47.215]             {
[17:02:47.215]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.215]                   0L) {
[17:02:47.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.215]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.215]                   base::options(opts)
[17:02:47.215]                 }
[17:02:47.215]                 {
[17:02:47.215]                   {
[17:02:47.215]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.215]                     NULL
[17:02:47.215]                   }
[17:02:47.215]                   options(future.plan = NULL)
[17:02:47.215]                   if (is.na(NA_character_)) 
[17:02:47.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.215]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.215]                     .init = FALSE)
[17:02:47.215]                 }
[17:02:47.215]             }
[17:02:47.215]         }
[17:02:47.215]     })
[17:02:47.215]     if (TRUE) {
[17:02:47.215]         base::sink(type = "output", split = FALSE)
[17:02:47.215]         if (TRUE) {
[17:02:47.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.215]         }
[17:02:47.215]         else {
[17:02:47.215]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.215]         }
[17:02:47.215]         base::close(...future.stdout)
[17:02:47.215]         ...future.stdout <- NULL
[17:02:47.215]     }
[17:02:47.215]     ...future.result$conditions <- ...future.conditions
[17:02:47.215]     ...future.result$finished <- base::Sys.time()
[17:02:47.215]     ...future.result
[17:02:47.215] }
[17:02:47.218] assign_globals() ...
[17:02:47.218] List of 1
[17:02:47.218]  $ x: list()
[17:02:47.218]  - attr(*, "where")=List of 1
[17:02:47.218]   ..$ x:<environment: R_EmptyEnv> 
[17:02:47.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:47.218]  - attr(*, "resolved")= logi TRUE
[17:02:47.218]  - attr(*, "total_size")= num 0
[17:02:47.218]  - attr(*, "already-done")= logi TRUE
[17:02:47.224] - copied ‘x’ to environment
[17:02:47.224] assign_globals() ... done
[17:02:47.224] requestCore(): workers = 2
[17:02:47.226] MulticoreFuture started
[17:02:47.227] - Launch lazy future ... done
[17:02:47.227] run() for ‘MulticoreFuture’ ... done
[17:02:47.228] result() for MulticoreFuture ...
[17:02:47.228] plan(): Setting new future strategy stack:
[17:02:47.228] List of future strategies:
[17:02:47.228] 1. sequential:
[17:02:47.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.228]    - tweaked: FALSE
[17:02:47.228]    - call: NULL
[17:02:47.229] plan(): nbrOfWorkers() = 1
[17:02:47.231] plan(): Setting new future strategy stack:
[17:02:47.231] List of future strategies:
[17:02:47.231] 1. multicore:
[17:02:47.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.231]    - tweaked: FALSE
[17:02:47.231]    - call: plan(strategy)
[17:02:47.237] plan(): nbrOfWorkers() = 2
[17:02:47.238] result() for MulticoreFuture ...
[17:02:47.238] result() for MulticoreFuture ... done
[17:02:47.238] result() for MulticoreFuture ... done
[17:02:47.238] result() for MulticoreFuture ...
[17:02:47.239] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.239] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.240] Searching for globals...
[17:02:47.243] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:02:47.243] Searching for globals ... DONE
[17:02:47.243] Resolving globals: TRUE
[17:02:47.243] Resolving any globals that are futures ...
[17:02:47.243] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:02:47.243] Resolving any globals that are futures ... DONE
[17:02:47.244] Resolving futures part of globals (recursively) ...
[17:02:47.244] resolve() on list ...
[17:02:47.244]  recursive: 99
[17:02:47.245]  length: 2
[17:02:47.245]  elements: ‘x’, ‘name’
[17:02:47.245]  length: 1 (resolved future 1)
[17:02:47.245]  length: 0 (resolved future 2)
[17:02:47.245] resolve() on list ... DONE
[17:02:47.245] - globals: [2] ‘x’, ‘name’
[17:02:47.245] Resolving futures part of globals (recursively) ... DONE
[17:02:47.246] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:47.246] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:02:47.246] - globals: [2] ‘x’, ‘name’
[17:02:47.246] 
[17:02:47.247] getGlobalsAndPackages() ... DONE
[17:02:47.247] run() for ‘Future’ ...
[17:02:47.247] - state: ‘created’
[17:02:47.247] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.252] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.252] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:02:47.252]   - Field: ‘label’
[17:02:47.252]   - Field: ‘local’
[17:02:47.252]   - Field: ‘owner’
[17:02:47.252]   - Field: ‘envir’
[17:02:47.252]   - Field: ‘workers’
[17:02:47.252]   - Field: ‘packages’
[17:02:47.252]   - Field: ‘gc’
[17:02:47.253]   - Field: ‘job’
[17:02:47.253]   - Field: ‘conditions’
[17:02:47.253]   - Field: ‘expr’
[17:02:47.253]   - Field: ‘uuid’
[17:02:47.253]   - Field: ‘seed’
[17:02:47.253]   - Field: ‘version’
[17:02:47.253]   - Field: ‘result’
[17:02:47.253]   - Field: ‘asynchronous’
[17:02:47.253]   - Field: ‘calls’
[17:02:47.254]   - Field: ‘globals’
[17:02:47.254]   - Field: ‘stdout’
[17:02:47.254]   - Field: ‘earlySignal’
[17:02:47.254]   - Field: ‘lazy’
[17:02:47.254]   - Field: ‘state’
[17:02:47.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:02:47.254] - Launch lazy future ...
[17:02:47.255] Packages needed by the future expression (n = 0): <none>
[17:02:47.255] Packages needed by future strategies (n = 0): <none>
[17:02:47.255] {
[17:02:47.255]     {
[17:02:47.255]         {
[17:02:47.255]             ...future.startTime <- base::Sys.time()
[17:02:47.255]             {
[17:02:47.255]                 {
[17:02:47.255]                   {
[17:02:47.255]                     {
[17:02:47.255]                       base::local({
[17:02:47.255]                         has_future <- base::requireNamespace("future", 
[17:02:47.255]                           quietly = TRUE)
[17:02:47.255]                         if (has_future) {
[17:02:47.255]                           ns <- base::getNamespace("future")
[17:02:47.255]                           version <- ns[[".package"]][["version"]]
[17:02:47.255]                           if (is.null(version)) 
[17:02:47.255]                             version <- utils::packageVersion("future")
[17:02:47.255]                         }
[17:02:47.255]                         else {
[17:02:47.255]                           version <- NULL
[17:02:47.255]                         }
[17:02:47.255]                         if (!has_future || version < "1.8.0") {
[17:02:47.255]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.255]                             "", base::R.version$version.string), 
[17:02:47.255]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.255]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.255]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.255]                               "release", "version")], collapse = " "), 
[17:02:47.255]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.255]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.255]                             info)
[17:02:47.255]                           info <- base::paste(info, collapse = "; ")
[17:02:47.255]                           if (!has_future) {
[17:02:47.255]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.255]                               info)
[17:02:47.255]                           }
[17:02:47.255]                           else {
[17:02:47.255]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.255]                               info, version)
[17:02:47.255]                           }
[17:02:47.255]                           base::stop(msg)
[17:02:47.255]                         }
[17:02:47.255]                       })
[17:02:47.255]                     }
[17:02:47.255]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.255]                     base::options(mc.cores = 1L)
[17:02:47.255]                   }
[17:02:47.255]                   ...future.strategy.old <- future::plan("list")
[17:02:47.255]                   options(future.plan = NULL)
[17:02:47.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.255]                 }
[17:02:47.255]                 ...future.workdir <- getwd()
[17:02:47.255]             }
[17:02:47.255]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.255]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.255]         }
[17:02:47.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.255]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.255]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.255]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.255]             base::names(...future.oldOptions))
[17:02:47.255]     }
[17:02:47.255]     if (FALSE) {
[17:02:47.255]     }
[17:02:47.255]     else {
[17:02:47.255]         if (TRUE) {
[17:02:47.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.255]                 open = "w")
[17:02:47.255]         }
[17:02:47.255]         else {
[17:02:47.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.255]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.255]         }
[17:02:47.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.255]             base::sink(type = "output", split = FALSE)
[17:02:47.255]             base::close(...future.stdout)
[17:02:47.255]         }, add = TRUE)
[17:02:47.255]     }
[17:02:47.255]     ...future.frame <- base::sys.nframe()
[17:02:47.255]     ...future.conditions <- base::list()
[17:02:47.255]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.255]     if (FALSE) {
[17:02:47.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.255]     }
[17:02:47.255]     ...future.result <- base::tryCatch({
[17:02:47.255]         base::withCallingHandlers({
[17:02:47.255]             ...future.value <- base::withVisible(base::local({
[17:02:47.255]                 withCallingHandlers({
[17:02:47.255]                   {
[17:02:47.255]                     x[name] <- list(1)
[17:02:47.255]                     x
[17:02:47.255]                   }
[17:02:47.255]                 }, immediateCondition = function(cond) {
[17:02:47.255]                   save_rds <- function (object, pathname, ...) 
[17:02:47.255]                   {
[17:02:47.255]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:02:47.255]                     if (file_test("-f", pathname_tmp)) {
[17:02:47.255]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.255]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:02:47.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.255]                         fi_tmp[["mtime"]])
[17:02:47.255]                     }
[17:02:47.255]                     tryCatch({
[17:02:47.255]                       saveRDS(object, file = pathname_tmp, ...)
[17:02:47.255]                     }, error = function(ex) {
[17:02:47.255]                       msg <- conditionMessage(ex)
[17:02:47.255]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.255]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:02:47.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.255]                         fi_tmp[["mtime"]], msg)
[17:02:47.255]                       ex$message <- msg
[17:02:47.255]                       stop(ex)
[17:02:47.255]                     })
[17:02:47.255]                     stopifnot(file_test("-f", pathname_tmp))
[17:02:47.255]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:02:47.255]                     if (!res || file_test("-f", pathname_tmp)) {
[17:02:47.255]                       fi_tmp <- file.info(pathname_tmp)
[17:02:47.255]                       fi <- file.info(pathname)
[17:02:47.255]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:02:47.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:02:47.255]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:02:47.255]                         fi[["size"]], fi[["mtime"]])
[17:02:47.255]                       stop(msg)
[17:02:47.255]                     }
[17:02:47.255]                     invisible(pathname)
[17:02:47.255]                   }
[17:02:47.255]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:02:47.255]                     rootPath = tempdir()) 
[17:02:47.255]                   {
[17:02:47.255]                     obj <- list(time = Sys.time(), condition = cond)
[17:02:47.255]                     file <- tempfile(pattern = class(cond)[1], 
[17:02:47.255]                       tmpdir = path, fileext = ".rds")
[17:02:47.255]                     save_rds(obj, file)
[17:02:47.255]                   }
[17:02:47.255]                   saveImmediateCondition(cond, path = "/tmp/RtmpQlUI4N/.future/immediateConditions")
[17:02:47.255]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.255]                   {
[17:02:47.255]                     inherits <- base::inherits
[17:02:47.255]                     invokeRestart <- base::invokeRestart
[17:02:47.255]                     is.null <- base::is.null
[17:02:47.255]                     muffled <- FALSE
[17:02:47.255]                     if (inherits(cond, "message")) {
[17:02:47.255]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.255]                       if (muffled) 
[17:02:47.255]                         invokeRestart("muffleMessage")
[17:02:47.255]                     }
[17:02:47.255]                     else if (inherits(cond, "warning")) {
[17:02:47.255]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.255]                       if (muffled) 
[17:02:47.255]                         invokeRestart("muffleWarning")
[17:02:47.255]                     }
[17:02:47.255]                     else if (inherits(cond, "condition")) {
[17:02:47.255]                       if (!is.null(pattern)) {
[17:02:47.255]                         computeRestarts <- base::computeRestarts
[17:02:47.255]                         grepl <- base::grepl
[17:02:47.255]                         restarts <- computeRestarts(cond)
[17:02:47.255]                         for (restart in restarts) {
[17:02:47.255]                           name <- restart$name
[17:02:47.255]                           if (is.null(name)) 
[17:02:47.255]                             next
[17:02:47.255]                           if (!grepl(pattern, name)) 
[17:02:47.255]                             next
[17:02:47.255]                           invokeRestart(restart)
[17:02:47.255]                           muffled <- TRUE
[17:02:47.255]                           break
[17:02:47.255]                         }
[17:02:47.255]                       }
[17:02:47.255]                     }
[17:02:47.255]                     invisible(muffled)
[17:02:47.255]                   }
[17:02:47.255]                   muffleCondition(cond)
[17:02:47.255]                 })
[17:02:47.255]             }))
[17:02:47.255]             future::FutureResult(value = ...future.value$value, 
[17:02:47.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.255]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.255]                     ...future.globalenv.names))
[17:02:47.255]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.255]         }, condition = base::local({
[17:02:47.255]             c <- base::c
[17:02:47.255]             inherits <- base::inherits
[17:02:47.255]             invokeRestart <- base::invokeRestart
[17:02:47.255]             length <- base::length
[17:02:47.255]             list <- base::list
[17:02:47.255]             seq.int <- base::seq.int
[17:02:47.255]             signalCondition <- base::signalCondition
[17:02:47.255]             sys.calls <- base::sys.calls
[17:02:47.255]             `[[` <- base::`[[`
[17:02:47.255]             `+` <- base::`+`
[17:02:47.255]             `<<-` <- base::`<<-`
[17:02:47.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.255]                   3L)]
[17:02:47.255]             }
[17:02:47.255]             function(cond) {
[17:02:47.255]                 is_error <- inherits(cond, "error")
[17:02:47.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.255]                   NULL)
[17:02:47.255]                 if (is_error) {
[17:02:47.255]                   sessionInformation <- function() {
[17:02:47.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.255]                       search = base::search(), system = base::Sys.info())
[17:02:47.255]                   }
[17:02:47.255]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.255]                     cond$call), session = sessionInformation(), 
[17:02:47.255]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.255]                   signalCondition(cond)
[17:02:47.255]                 }
[17:02:47.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.255]                 "immediateCondition"))) {
[17:02:47.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.255]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.255]                   if (TRUE && !signal) {
[17:02:47.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.255]                     {
[17:02:47.255]                       inherits <- base::inherits
[17:02:47.255]                       invokeRestart <- base::invokeRestart
[17:02:47.255]                       is.null <- base::is.null
[17:02:47.255]                       muffled <- FALSE
[17:02:47.255]                       if (inherits(cond, "message")) {
[17:02:47.255]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.255]                         if (muffled) 
[17:02:47.255]                           invokeRestart("muffleMessage")
[17:02:47.255]                       }
[17:02:47.255]                       else if (inherits(cond, "warning")) {
[17:02:47.255]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.255]                         if (muffled) 
[17:02:47.255]                           invokeRestart("muffleWarning")
[17:02:47.255]                       }
[17:02:47.255]                       else if (inherits(cond, "condition")) {
[17:02:47.255]                         if (!is.null(pattern)) {
[17:02:47.255]                           computeRestarts <- base::computeRestarts
[17:02:47.255]                           grepl <- base::grepl
[17:02:47.255]                           restarts <- computeRestarts(cond)
[17:02:47.255]                           for (restart in restarts) {
[17:02:47.255]                             name <- restart$name
[17:02:47.255]                             if (is.null(name)) 
[17:02:47.255]                               next
[17:02:47.255]                             if (!grepl(pattern, name)) 
[17:02:47.255]                               next
[17:02:47.255]                             invokeRestart(restart)
[17:02:47.255]                             muffled <- TRUE
[17:02:47.255]                             break
[17:02:47.255]                           }
[17:02:47.255]                         }
[17:02:47.255]                       }
[17:02:47.255]                       invisible(muffled)
[17:02:47.255]                     }
[17:02:47.255]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.255]                   }
[17:02:47.255]                 }
[17:02:47.255]                 else {
[17:02:47.255]                   if (TRUE) {
[17:02:47.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.255]                     {
[17:02:47.255]                       inherits <- base::inherits
[17:02:47.255]                       invokeRestart <- base::invokeRestart
[17:02:47.255]                       is.null <- base::is.null
[17:02:47.255]                       muffled <- FALSE
[17:02:47.255]                       if (inherits(cond, "message")) {
[17:02:47.255]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.255]                         if (muffled) 
[17:02:47.255]                           invokeRestart("muffleMessage")
[17:02:47.255]                       }
[17:02:47.255]                       else if (inherits(cond, "warning")) {
[17:02:47.255]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.255]                         if (muffled) 
[17:02:47.255]                           invokeRestart("muffleWarning")
[17:02:47.255]                       }
[17:02:47.255]                       else if (inherits(cond, "condition")) {
[17:02:47.255]                         if (!is.null(pattern)) {
[17:02:47.255]                           computeRestarts <- base::computeRestarts
[17:02:47.255]                           grepl <- base::grepl
[17:02:47.255]                           restarts <- computeRestarts(cond)
[17:02:47.255]                           for (restart in restarts) {
[17:02:47.255]                             name <- restart$name
[17:02:47.255]                             if (is.null(name)) 
[17:02:47.255]                               next
[17:02:47.255]                             if (!grepl(pattern, name)) 
[17:02:47.255]                               next
[17:02:47.255]                             invokeRestart(restart)
[17:02:47.255]                             muffled <- TRUE
[17:02:47.255]                             break
[17:02:47.255]                           }
[17:02:47.255]                         }
[17:02:47.255]                       }
[17:02:47.255]                       invisible(muffled)
[17:02:47.255]                     }
[17:02:47.255]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.255]                   }
[17:02:47.255]                 }
[17:02:47.255]             }
[17:02:47.255]         }))
[17:02:47.255]     }, error = function(ex) {
[17:02:47.255]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.255]                 ...future.rng), started = ...future.startTime, 
[17:02:47.255]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.255]             version = "1.8"), class = "FutureResult")
[17:02:47.255]     }, finally = {
[17:02:47.255]         if (!identical(...future.workdir, getwd())) 
[17:02:47.255]             setwd(...future.workdir)
[17:02:47.255]         {
[17:02:47.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.255]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.255]             }
[17:02:47.255]             base::options(...future.oldOptions)
[17:02:47.255]             if (.Platform$OS.type == "windows") {
[17:02:47.255]                 old_names <- names(...future.oldEnvVars)
[17:02:47.255]                 envs <- base::Sys.getenv()
[17:02:47.255]                 names <- names(envs)
[17:02:47.255]                 common <- intersect(names, old_names)
[17:02:47.255]                 added <- setdiff(names, old_names)
[17:02:47.255]                 removed <- setdiff(old_names, names)
[17:02:47.255]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.255]                   envs[common]]
[17:02:47.255]                 NAMES <- toupper(changed)
[17:02:47.255]                 args <- list()
[17:02:47.255]                 for (kk in seq_along(NAMES)) {
[17:02:47.255]                   name <- changed[[kk]]
[17:02:47.255]                   NAME <- NAMES[[kk]]
[17:02:47.255]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.255]                     next
[17:02:47.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.255]                 }
[17:02:47.255]                 NAMES <- toupper(added)
[17:02:47.255]                 for (kk in seq_along(NAMES)) {
[17:02:47.255]                   name <- added[[kk]]
[17:02:47.255]                   NAME <- NAMES[[kk]]
[17:02:47.255]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.255]                     next
[17:02:47.255]                   args[[name]] <- ""
[17:02:47.255]                 }
[17:02:47.255]                 NAMES <- toupper(removed)
[17:02:47.255]                 for (kk in seq_along(NAMES)) {
[17:02:47.255]                   name <- removed[[kk]]
[17:02:47.255]                   NAME <- NAMES[[kk]]
[17:02:47.255]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.255]                     next
[17:02:47.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.255]                 }
[17:02:47.255]                 if (length(args) > 0) 
[17:02:47.255]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.255]             }
[17:02:47.255]             else {
[17:02:47.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.255]             }
[17:02:47.255]             {
[17:02:47.255]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.255]                   0L) {
[17:02:47.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.255]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.255]                   base::options(opts)
[17:02:47.255]                 }
[17:02:47.255]                 {
[17:02:47.255]                   {
[17:02:47.255]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.255]                     NULL
[17:02:47.255]                   }
[17:02:47.255]                   options(future.plan = NULL)
[17:02:47.255]                   if (is.na(NA_character_)) 
[17:02:47.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.255]                     .init = FALSE)
[17:02:47.255]                 }
[17:02:47.255]             }
[17:02:47.255]         }
[17:02:47.255]     })
[17:02:47.255]     if (TRUE) {
[17:02:47.255]         base::sink(type = "output", split = FALSE)
[17:02:47.255]         if (TRUE) {
[17:02:47.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.255]         }
[17:02:47.255]         else {
[17:02:47.255]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.255]         }
[17:02:47.255]         base::close(...future.stdout)
[17:02:47.255]         ...future.stdout <- NULL
[17:02:47.255]     }
[17:02:47.255]     ...future.result$conditions <- ...future.conditions
[17:02:47.255]     ...future.result$finished <- base::Sys.time()
[17:02:47.255]     ...future.result
[17:02:47.255] }
[17:02:47.258] assign_globals() ...
[17:02:47.258] List of 2
[17:02:47.258]  $ x   : list()
[17:02:47.258]  $ name: chr "a"
[17:02:47.258]  - attr(*, "where")=List of 2
[17:02:47.258]   ..$ x   :<environment: R_EmptyEnv> 
[17:02:47.258]   ..$ name:<environment: R_EmptyEnv> 
[17:02:47.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:02:47.258]  - attr(*, "resolved")= logi TRUE
[17:02:47.258]  - attr(*, "total_size")= num 112
[17:02:47.258]  - attr(*, "already-done")= logi TRUE
[17:02:47.262] - copied ‘x’ to environment
[17:02:47.262] - copied ‘name’ to environment
[17:02:47.262] assign_globals() ... done
[17:02:47.262] requestCore(): workers = 2
[17:02:47.265] MulticoreFuture started
[17:02:47.265] - Launch lazy future ... done
[17:02:47.265] run() for ‘MulticoreFuture’ ... done
[17:02:47.266] plan(): Setting new future strategy stack:
[17:02:47.266] result() for MulticoreFuture ...
[17:02:47.266] List of future strategies:
[17:02:47.266] 1. sequential:
[17:02:47.266]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:47.266]    - tweaked: FALSE
[17:02:47.266]    - call: NULL
[17:02:47.267] plan(): nbrOfWorkers() = 1
[17:02:47.269] plan(): Setting new future strategy stack:
[17:02:47.269] List of future strategies:
[17:02:47.269] 1. multicore:
[17:02:47.269]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:02:47.269]    - tweaked: FALSE
[17:02:47.269]    - call: plan(strategy)
[17:02:47.275] plan(): nbrOfWorkers() = 2
[17:02:47.276] result() for MulticoreFuture ...
[17:02:47.276] result() for MulticoreFuture ... done
[17:02:47.276] result() for MulticoreFuture ... done
[17:02:47.276] result() for MulticoreFuture ...
[17:02:47.277] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[17:02:47.278] plan(): Setting new future strategy stack:
[17:02:47.278] List of future strategies:
[17:02:47.278] 1. multisession:
[17:02:47.278]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:47.278]    - tweaked: FALSE
[17:02:47.278]    - call: plan(strategy)
[17:02:47.279] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:02:47.279] multisession:
[17:02:47.279] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:02:47.279] - tweaked: FALSE
[17:02:47.279] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.289] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.289] Not searching for globals
[17:02:47.290] - globals: [0] <none>
[17:02:47.290] getGlobalsAndPackages() ... DONE
[17:02:47.291] [local output] makeClusterPSOCK() ...
[17:02:47.339] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:02:47.340] [local output] Base port: 11842
[17:02:47.340] [local output] Getting setup options for 2 cluster nodes ...
[17:02:47.340] [local output]  - Node 1 of 2 ...
[17:02:47.340] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:47.341] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQlUI4N/worker.rank=1.parallelly.parent=44171.ac8b13d85712.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpQlUI4N/worker.rank=1.parallelly.parent=44171.ac8b13d85712.pid")'’
[17:02:47.533] - Possible to infer worker's PID: TRUE
[17:02:47.533] [local output] Rscript port: 11842

[17:02:47.533] [local output]  - Node 2 of 2 ...
[17:02:47.534] [local output] localMachine=TRUE => revtunnel=FALSE

[17:02:47.534] [local output] Rscript port: 11842

[17:02:47.535] [local output] Getting setup options for 2 cluster nodes ... done
[17:02:47.535] [local output]  - Parallel setup requested for some PSOCK nodes
[17:02:47.535] [local output] Setting up PSOCK nodes in parallel
[17:02:47.535] List of 36
[17:02:47.535]  $ worker          : chr "localhost"
[17:02:47.535]   ..- attr(*, "localhost")= logi TRUE
[17:02:47.535]  $ master          : chr "localhost"
[17:02:47.535]  $ port            : int 11842
[17:02:47.535]  $ connectTimeout  : num 120
[17:02:47.535]  $ timeout         : num 2592000
[17:02:47.535]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:02:47.535]  $ homogeneous     : logi TRUE
[17:02:47.535]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:02:47.535]  $ rscript_envs    : NULL
[17:02:47.535]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:47.535]  $ rscript_startup : NULL
[17:02:47.535]  $ rscript_sh      : chr "sh"
[17:02:47.535]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:47.535]  $ methods         : logi TRUE
[17:02:47.535]  $ socketOptions   : chr "no-delay"
[17:02:47.535]  $ useXDR          : logi FALSE
[17:02:47.535]  $ outfile         : chr "/dev/null"
[17:02:47.535]  $ renice          : int NA
[17:02:47.535]  $ rshcmd          : NULL
[17:02:47.535]  $ user            : chr(0) 
[17:02:47.535]  $ revtunnel       : logi FALSE
[17:02:47.535]  $ rshlogfile      : NULL
[17:02:47.535]  $ rshopts         : chr(0) 
[17:02:47.535]  $ rank            : int 1
[17:02:47.535]  $ manual          : logi FALSE
[17:02:47.535]  $ dryrun          : logi FALSE
[17:02:47.535]  $ quiet           : logi FALSE
[17:02:47.535]  $ setup_strategy  : chr "parallel"
[17:02:47.535]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:47.535]  $ pidfile         : chr "/tmp/RtmpQlUI4N/worker.rank=1.parallelly.parent=44171.ac8b13d85712.pid"
[17:02:47.535]  $ rshcmd_label    : NULL
[17:02:47.535]  $ rsh_call        : NULL
[17:02:47.535]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:02:47.535]  $ localMachine    : logi TRUE
[17:02:47.535]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:02:47.535]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:02:47.535]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:02:47.535]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:02:47.535]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:02:47.535]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:02:47.535]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:02:47.535]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:02:47.535]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:02:47.535]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:02:47.535]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:02:47.535]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:02:47.535]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:02:47.535]  $ arguments       :List of 28
[17:02:47.535]   ..$ worker          : chr "localhost"
[17:02:47.535]   ..$ master          : NULL
[17:02:47.535]   ..$ port            : int 11842
[17:02:47.535]   ..$ connectTimeout  : num 120
[17:02:47.535]   ..$ timeout         : num 2592000
[17:02:47.535]   ..$ rscript         : NULL
[17:02:47.535]   ..$ homogeneous     : NULL
[17:02:47.535]   ..$ rscript_args    : NULL
[17:02:47.535]   ..$ rscript_envs    : NULL
[17:02:47.535]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:02:47.535]   ..$ rscript_startup : NULL
[17:02:47.535]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:02:47.535]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:02:47.535]   ..$ methods         : logi TRUE
[17:02:47.535]   ..$ socketOptions   : chr "no-delay"
[17:02:47.535]   ..$ useXDR          : logi FALSE
[17:02:47.535]   ..$ outfile         : chr "/dev/null"
[17:02:47.535]   ..$ renice          : int NA
[17:02:47.535]   ..$ rshcmd          : NULL
[17:02:47.535]   ..$ user            : NULL
[17:02:47.535]   ..$ revtunnel       : logi NA
[17:02:47.535]   ..$ rshlogfile      : NULL
[17:02:47.535]   ..$ rshopts         : NULL
[17:02:47.535]   ..$ rank            : int 1
[17:02:47.535]   ..$ manual          : logi FALSE
[17:02:47.535]   ..$ dryrun          : logi FALSE
[17:02:47.535]   ..$ quiet           : logi FALSE
[17:02:47.535]   ..$ setup_strategy  : chr "parallel"
[17:02:47.535]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:02:47.552] [local output] System call to launch all workers:
[17:02:47.552] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpQlUI4N/worker.rank=1.parallelly.parent=44171.ac8b13d85712.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11842 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:02:47.552] [local output] Starting PSOCK main server
[17:02:47.558] [local output] Workers launched
[17:02:47.558] [local output] Waiting for workers to connect back
[17:02:47.558]  - [local output] 0 workers out of 2 ready
[17:02:47.821]  - [local output] 0 workers out of 2 ready
[17:02:47.822]  - [local output] 1 workers out of 2 ready
[17:02:47.823]  - [local output] 1 workers out of 2 ready
[17:02:47.823]  - [local output] 2 workers out of 2 ready
[17:02:47.823] [local output] Launching of workers completed
[17:02:47.823] [local output] Collecting session information from workers
[17:02:47.824] [local output]  - Worker #1 of 2
[17:02:47.825] [local output]  - Worker #2 of 2
[17:02:47.825] [local output] makeClusterPSOCK() ... done
[17:02:47.838] Packages needed by the future expression (n = 0): <none>
[17:02:47.838] Packages needed by future strategies (n = 0): <none>
[17:02:47.838] {
[17:02:47.838]     {
[17:02:47.838]         {
[17:02:47.838]             ...future.startTime <- base::Sys.time()
[17:02:47.838]             {
[17:02:47.838]                 {
[17:02:47.838]                   {
[17:02:47.838]                     {
[17:02:47.838]                       base::local({
[17:02:47.838]                         has_future <- base::requireNamespace("future", 
[17:02:47.838]                           quietly = TRUE)
[17:02:47.838]                         if (has_future) {
[17:02:47.838]                           ns <- base::getNamespace("future")
[17:02:47.838]                           version <- ns[[".package"]][["version"]]
[17:02:47.838]                           if (is.null(version)) 
[17:02:47.838]                             version <- utils::packageVersion("future")
[17:02:47.838]                         }
[17:02:47.838]                         else {
[17:02:47.838]                           version <- NULL
[17:02:47.838]                         }
[17:02:47.838]                         if (!has_future || version < "1.8.0") {
[17:02:47.838]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.838]                             "", base::R.version$version.string), 
[17:02:47.838]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.838]                               "release", "version")], collapse = " "), 
[17:02:47.838]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.838]                             info)
[17:02:47.838]                           info <- base::paste(info, collapse = "; ")
[17:02:47.838]                           if (!has_future) {
[17:02:47.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.838]                               info)
[17:02:47.838]                           }
[17:02:47.838]                           else {
[17:02:47.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.838]                               info, version)
[17:02:47.838]                           }
[17:02:47.838]                           base::stop(msg)
[17:02:47.838]                         }
[17:02:47.838]                       })
[17:02:47.838]                     }
[17:02:47.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.838]                     base::options(mc.cores = 1L)
[17:02:47.838]                   }
[17:02:47.838]                   ...future.strategy.old <- future::plan("list")
[17:02:47.838]                   options(future.plan = NULL)
[17:02:47.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.838]                 }
[17:02:47.838]                 ...future.workdir <- getwd()
[17:02:47.838]             }
[17:02:47.838]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.838]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.838]         }
[17:02:47.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.838]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.838]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.838]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.838]             base::names(...future.oldOptions))
[17:02:47.838]     }
[17:02:47.838]     if (FALSE) {
[17:02:47.838]     }
[17:02:47.838]     else {
[17:02:47.838]         if (TRUE) {
[17:02:47.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.838]                 open = "w")
[17:02:47.838]         }
[17:02:47.838]         else {
[17:02:47.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.838]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.838]         }
[17:02:47.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.838]             base::sink(type = "output", split = FALSE)
[17:02:47.838]             base::close(...future.stdout)
[17:02:47.838]         }, add = TRUE)
[17:02:47.838]     }
[17:02:47.838]     ...future.frame <- base::sys.nframe()
[17:02:47.838]     ...future.conditions <- base::list()
[17:02:47.838]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.838]     if (FALSE) {
[17:02:47.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.838]     }
[17:02:47.838]     ...future.result <- base::tryCatch({
[17:02:47.838]         base::withCallingHandlers({
[17:02:47.838]             ...future.value <- base::withVisible(base::local({
[17:02:47.838]                 ...future.makeSendCondition <- base::local({
[17:02:47.838]                   sendCondition <- NULL
[17:02:47.838]                   function(frame = 1L) {
[17:02:47.838]                     if (is.function(sendCondition)) 
[17:02:47.838]                       return(sendCondition)
[17:02:47.838]                     ns <- getNamespace("parallel")
[17:02:47.838]                     if (exists("sendData", mode = "function", 
[17:02:47.838]                       envir = ns)) {
[17:02:47.838]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:47.838]                         envir = ns)
[17:02:47.838]                       envir <- sys.frame(frame)
[17:02:47.838]                       master <- NULL
[17:02:47.838]                       while (!identical(envir, .GlobalEnv) && 
[17:02:47.838]                         !identical(envir, emptyenv())) {
[17:02:47.838]                         if (exists("master", mode = "list", envir = envir, 
[17:02:47.838]                           inherits = FALSE)) {
[17:02:47.838]                           master <- get("master", mode = "list", 
[17:02:47.838]                             envir = envir, inherits = FALSE)
[17:02:47.838]                           if (inherits(master, c("SOCKnode", 
[17:02:47.838]                             "SOCK0node"))) {
[17:02:47.838]                             sendCondition <<- function(cond) {
[17:02:47.838]                               data <- list(type = "VALUE", value = cond, 
[17:02:47.838]                                 success = TRUE)
[17:02:47.838]                               parallel_sendData(master, data)
[17:02:47.838]                             }
[17:02:47.838]                             return(sendCondition)
[17:02:47.838]                           }
[17:02:47.838]                         }
[17:02:47.838]                         frame <- frame + 1L
[17:02:47.838]                         envir <- sys.frame(frame)
[17:02:47.838]                       }
[17:02:47.838]                     }
[17:02:47.838]                     sendCondition <<- function(cond) NULL
[17:02:47.838]                   }
[17:02:47.838]                 })
[17:02:47.838]                 withCallingHandlers({
[17:02:47.838]                   NA
[17:02:47.838]                 }, immediateCondition = function(cond) {
[17:02:47.838]                   sendCondition <- ...future.makeSendCondition()
[17:02:47.838]                   sendCondition(cond)
[17:02:47.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.838]                   {
[17:02:47.838]                     inherits <- base::inherits
[17:02:47.838]                     invokeRestart <- base::invokeRestart
[17:02:47.838]                     is.null <- base::is.null
[17:02:47.838]                     muffled <- FALSE
[17:02:47.838]                     if (inherits(cond, "message")) {
[17:02:47.838]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.838]                       if (muffled) 
[17:02:47.838]                         invokeRestart("muffleMessage")
[17:02:47.838]                     }
[17:02:47.838]                     else if (inherits(cond, "warning")) {
[17:02:47.838]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.838]                       if (muffled) 
[17:02:47.838]                         invokeRestart("muffleWarning")
[17:02:47.838]                     }
[17:02:47.838]                     else if (inherits(cond, "condition")) {
[17:02:47.838]                       if (!is.null(pattern)) {
[17:02:47.838]                         computeRestarts <- base::computeRestarts
[17:02:47.838]                         grepl <- base::grepl
[17:02:47.838]                         restarts <- computeRestarts(cond)
[17:02:47.838]                         for (restart in restarts) {
[17:02:47.838]                           name <- restart$name
[17:02:47.838]                           if (is.null(name)) 
[17:02:47.838]                             next
[17:02:47.838]                           if (!grepl(pattern, name)) 
[17:02:47.838]                             next
[17:02:47.838]                           invokeRestart(restart)
[17:02:47.838]                           muffled <- TRUE
[17:02:47.838]                           break
[17:02:47.838]                         }
[17:02:47.838]                       }
[17:02:47.838]                     }
[17:02:47.838]                     invisible(muffled)
[17:02:47.838]                   }
[17:02:47.838]                   muffleCondition(cond)
[17:02:47.838]                 })
[17:02:47.838]             }))
[17:02:47.838]             future::FutureResult(value = ...future.value$value, 
[17:02:47.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.838]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.838]                     ...future.globalenv.names))
[17:02:47.838]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.838]         }, condition = base::local({
[17:02:47.838]             c <- base::c
[17:02:47.838]             inherits <- base::inherits
[17:02:47.838]             invokeRestart <- base::invokeRestart
[17:02:47.838]             length <- base::length
[17:02:47.838]             list <- base::list
[17:02:47.838]             seq.int <- base::seq.int
[17:02:47.838]             signalCondition <- base::signalCondition
[17:02:47.838]             sys.calls <- base::sys.calls
[17:02:47.838]             `[[` <- base::`[[`
[17:02:47.838]             `+` <- base::`+`
[17:02:47.838]             `<<-` <- base::`<<-`
[17:02:47.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.838]                   3L)]
[17:02:47.838]             }
[17:02:47.838]             function(cond) {
[17:02:47.838]                 is_error <- inherits(cond, "error")
[17:02:47.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.838]                   NULL)
[17:02:47.838]                 if (is_error) {
[17:02:47.838]                   sessionInformation <- function() {
[17:02:47.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.838]                       search = base::search(), system = base::Sys.info())
[17:02:47.838]                   }
[17:02:47.838]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.838]                     cond$call), session = sessionInformation(), 
[17:02:47.838]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.838]                   signalCondition(cond)
[17:02:47.838]                 }
[17:02:47.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.838]                 "immediateCondition"))) {
[17:02:47.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.838]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.838]                   if (TRUE && !signal) {
[17:02:47.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.838]                     {
[17:02:47.838]                       inherits <- base::inherits
[17:02:47.838]                       invokeRestart <- base::invokeRestart
[17:02:47.838]                       is.null <- base::is.null
[17:02:47.838]                       muffled <- FALSE
[17:02:47.838]                       if (inherits(cond, "message")) {
[17:02:47.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.838]                         if (muffled) 
[17:02:47.838]                           invokeRestart("muffleMessage")
[17:02:47.838]                       }
[17:02:47.838]                       else if (inherits(cond, "warning")) {
[17:02:47.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.838]                         if (muffled) 
[17:02:47.838]                           invokeRestart("muffleWarning")
[17:02:47.838]                       }
[17:02:47.838]                       else if (inherits(cond, "condition")) {
[17:02:47.838]                         if (!is.null(pattern)) {
[17:02:47.838]                           computeRestarts <- base::computeRestarts
[17:02:47.838]                           grepl <- base::grepl
[17:02:47.838]                           restarts <- computeRestarts(cond)
[17:02:47.838]                           for (restart in restarts) {
[17:02:47.838]                             name <- restart$name
[17:02:47.838]                             if (is.null(name)) 
[17:02:47.838]                               next
[17:02:47.838]                             if (!grepl(pattern, name)) 
[17:02:47.838]                               next
[17:02:47.838]                             invokeRestart(restart)
[17:02:47.838]                             muffled <- TRUE
[17:02:47.838]                             break
[17:02:47.838]                           }
[17:02:47.838]                         }
[17:02:47.838]                       }
[17:02:47.838]                       invisible(muffled)
[17:02:47.838]                     }
[17:02:47.838]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.838]                   }
[17:02:47.838]                 }
[17:02:47.838]                 else {
[17:02:47.838]                   if (TRUE) {
[17:02:47.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.838]                     {
[17:02:47.838]                       inherits <- base::inherits
[17:02:47.838]                       invokeRestart <- base::invokeRestart
[17:02:47.838]                       is.null <- base::is.null
[17:02:47.838]                       muffled <- FALSE
[17:02:47.838]                       if (inherits(cond, "message")) {
[17:02:47.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.838]                         if (muffled) 
[17:02:47.838]                           invokeRestart("muffleMessage")
[17:02:47.838]                       }
[17:02:47.838]                       else if (inherits(cond, "warning")) {
[17:02:47.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.838]                         if (muffled) 
[17:02:47.838]                           invokeRestart("muffleWarning")
[17:02:47.838]                       }
[17:02:47.838]                       else if (inherits(cond, "condition")) {
[17:02:47.838]                         if (!is.null(pattern)) {
[17:02:47.838]                           computeRestarts <- base::computeRestarts
[17:02:47.838]                           grepl <- base::grepl
[17:02:47.838]                           restarts <- computeRestarts(cond)
[17:02:47.838]                           for (restart in restarts) {
[17:02:47.838]                             name <- restart$name
[17:02:47.838]                             if (is.null(name)) 
[17:02:47.838]                               next
[17:02:47.838]                             if (!grepl(pattern, name)) 
[17:02:47.838]                               next
[17:02:47.838]                             invokeRestart(restart)
[17:02:47.838]                             muffled <- TRUE
[17:02:47.838]                             break
[17:02:47.838]                           }
[17:02:47.838]                         }
[17:02:47.838]                       }
[17:02:47.838]                       invisible(muffled)
[17:02:47.838]                     }
[17:02:47.838]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.838]                   }
[17:02:47.838]                 }
[17:02:47.838]             }
[17:02:47.838]         }))
[17:02:47.838]     }, error = function(ex) {
[17:02:47.838]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.838]                 ...future.rng), started = ...future.startTime, 
[17:02:47.838]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.838]             version = "1.8"), class = "FutureResult")
[17:02:47.838]     }, finally = {
[17:02:47.838]         if (!identical(...future.workdir, getwd())) 
[17:02:47.838]             setwd(...future.workdir)
[17:02:47.838]         {
[17:02:47.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.838]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.838]             }
[17:02:47.838]             base::options(...future.oldOptions)
[17:02:47.838]             if (.Platform$OS.type == "windows") {
[17:02:47.838]                 old_names <- names(...future.oldEnvVars)
[17:02:47.838]                 envs <- base::Sys.getenv()
[17:02:47.838]                 names <- names(envs)
[17:02:47.838]                 common <- intersect(names, old_names)
[17:02:47.838]                 added <- setdiff(names, old_names)
[17:02:47.838]                 removed <- setdiff(old_names, names)
[17:02:47.838]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.838]                   envs[common]]
[17:02:47.838]                 NAMES <- toupper(changed)
[17:02:47.838]                 args <- list()
[17:02:47.838]                 for (kk in seq_along(NAMES)) {
[17:02:47.838]                   name <- changed[[kk]]
[17:02:47.838]                   NAME <- NAMES[[kk]]
[17:02:47.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.838]                     next
[17:02:47.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.838]                 }
[17:02:47.838]                 NAMES <- toupper(added)
[17:02:47.838]                 for (kk in seq_along(NAMES)) {
[17:02:47.838]                   name <- added[[kk]]
[17:02:47.838]                   NAME <- NAMES[[kk]]
[17:02:47.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.838]                     next
[17:02:47.838]                   args[[name]] <- ""
[17:02:47.838]                 }
[17:02:47.838]                 NAMES <- toupper(removed)
[17:02:47.838]                 for (kk in seq_along(NAMES)) {
[17:02:47.838]                   name <- removed[[kk]]
[17:02:47.838]                   NAME <- NAMES[[kk]]
[17:02:47.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.838]                     next
[17:02:47.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.838]                 }
[17:02:47.838]                 if (length(args) > 0) 
[17:02:47.838]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.838]             }
[17:02:47.838]             else {
[17:02:47.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.838]             }
[17:02:47.838]             {
[17:02:47.838]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.838]                   0L) {
[17:02:47.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.838]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.838]                   base::options(opts)
[17:02:47.838]                 }
[17:02:47.838]                 {
[17:02:47.838]                   {
[17:02:47.838]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.838]                     NULL
[17:02:47.838]                   }
[17:02:47.838]                   options(future.plan = NULL)
[17:02:47.838]                   if (is.na(NA_character_)) 
[17:02:47.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.838]                     .init = FALSE)
[17:02:47.838]                 }
[17:02:47.838]             }
[17:02:47.838]         }
[17:02:47.838]     })
[17:02:47.838]     if (TRUE) {
[17:02:47.838]         base::sink(type = "output", split = FALSE)
[17:02:47.838]         if (TRUE) {
[17:02:47.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.838]         }
[17:02:47.838]         else {
[17:02:47.838]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.838]         }
[17:02:47.838]         base::close(...future.stdout)
[17:02:47.838]         ...future.stdout <- NULL
[17:02:47.838]     }
[17:02:47.838]     ...future.result$conditions <- ...future.conditions
[17:02:47.838]     ...future.result$finished <- base::Sys.time()
[17:02:47.838]     ...future.result
[17:02:47.838] }
[17:02:47.895] MultisessionFuture started
[17:02:47.895] result() for ClusterFuture ...
[17:02:47.896] receiveMessageFromWorker() for ClusterFuture ...
[17:02:47.896] - Validating connection of MultisessionFuture
[17:02:47.928] - received message: FutureResult
[17:02:47.929] - Received FutureResult
[17:02:47.929] - Erased future from FutureRegistry
[17:02:47.929] result() for ClusterFuture ...
[17:02:47.929] - result already collected: FutureResult
[17:02:47.929] result() for ClusterFuture ... done
[17:02:47.929] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:47.929] result() for ClusterFuture ... done
[17:02:47.929] result() for ClusterFuture ...
[17:02:47.930] - result already collected: FutureResult
[17:02:47.930] result() for ClusterFuture ... done
[17:02:47.930] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:02:47.934] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.934] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.934] Searching for globals...
[17:02:47.937] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:47.937] Searching for globals ... DONE
[17:02:47.937] Resolving globals: TRUE
[17:02:47.937] Resolving any globals that are futures ...
[17:02:47.937] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:47.937] Resolving any globals that are futures ... DONE
[17:02:47.938] Resolving futures part of globals (recursively) ...
[17:02:47.938] resolve() on list ...
[17:02:47.938]  recursive: 99
[17:02:47.938]  length: 1
[17:02:47.939]  elements: ‘x’
[17:02:47.939]  length: 0 (resolved future 1)
[17:02:47.939] resolve() on list ... DONE
[17:02:47.939] - globals: [1] ‘x’
[17:02:47.939] Resolving futures part of globals (recursively) ... DONE
[17:02:47.939] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.940] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.940] - globals: [1] ‘x’
[17:02:47.940] 
[17:02:47.940] getGlobalsAndPackages() ... DONE
[17:02:47.940] run() for ‘Future’ ...
[17:02:47.940] - state: ‘created’
[17:02:47.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:47.955]   - Field: ‘node’
[17:02:47.955]   - Field: ‘label’
[17:02:47.955]   - Field: ‘local’
[17:02:47.955]   - Field: ‘owner’
[17:02:47.956]   - Field: ‘envir’
[17:02:47.956]   - Field: ‘workers’
[17:02:47.956]   - Field: ‘packages’
[17:02:47.956]   - Field: ‘gc’
[17:02:47.956]   - Field: ‘conditions’
[17:02:47.956]   - Field: ‘persistent’
[17:02:47.956]   - Field: ‘expr’
[17:02:47.956]   - Field: ‘uuid’
[17:02:47.956]   - Field: ‘seed’
[17:02:47.957]   - Field: ‘version’
[17:02:47.957]   - Field: ‘result’
[17:02:47.957]   - Field: ‘asynchronous’
[17:02:47.957]   - Field: ‘calls’
[17:02:47.957]   - Field: ‘globals’
[17:02:47.957]   - Field: ‘stdout’
[17:02:47.957]   - Field: ‘earlySignal’
[17:02:47.957]   - Field: ‘lazy’
[17:02:47.957]   - Field: ‘state’
[17:02:47.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:47.958] - Launch lazy future ...
[17:02:47.958] Packages needed by the future expression (n = 0): <none>
[17:02:47.958] Packages needed by future strategies (n = 0): <none>
[17:02:47.959] {
[17:02:47.959]     {
[17:02:47.959]         {
[17:02:47.959]             ...future.startTime <- base::Sys.time()
[17:02:47.959]             {
[17:02:47.959]                 {
[17:02:47.959]                   {
[17:02:47.959]                     {
[17:02:47.959]                       base::local({
[17:02:47.959]                         has_future <- base::requireNamespace("future", 
[17:02:47.959]                           quietly = TRUE)
[17:02:47.959]                         if (has_future) {
[17:02:47.959]                           ns <- base::getNamespace("future")
[17:02:47.959]                           version <- ns[[".package"]][["version"]]
[17:02:47.959]                           if (is.null(version)) 
[17:02:47.959]                             version <- utils::packageVersion("future")
[17:02:47.959]                         }
[17:02:47.959]                         else {
[17:02:47.959]                           version <- NULL
[17:02:47.959]                         }
[17:02:47.959]                         if (!has_future || version < "1.8.0") {
[17:02:47.959]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.959]                             "", base::R.version$version.string), 
[17:02:47.959]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.959]                               "release", "version")], collapse = " "), 
[17:02:47.959]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.959]                             info)
[17:02:47.959]                           info <- base::paste(info, collapse = "; ")
[17:02:47.959]                           if (!has_future) {
[17:02:47.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.959]                               info)
[17:02:47.959]                           }
[17:02:47.959]                           else {
[17:02:47.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.959]                               info, version)
[17:02:47.959]                           }
[17:02:47.959]                           base::stop(msg)
[17:02:47.959]                         }
[17:02:47.959]                       })
[17:02:47.959]                     }
[17:02:47.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.959]                     base::options(mc.cores = 1L)
[17:02:47.959]                   }
[17:02:47.959]                   ...future.strategy.old <- future::plan("list")
[17:02:47.959]                   options(future.plan = NULL)
[17:02:47.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.959]                 }
[17:02:47.959]                 ...future.workdir <- getwd()
[17:02:47.959]             }
[17:02:47.959]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.959]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.959]         }
[17:02:47.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.959]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.959]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.959]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.959]             base::names(...future.oldOptions))
[17:02:47.959]     }
[17:02:47.959]     if (FALSE) {
[17:02:47.959]     }
[17:02:47.959]     else {
[17:02:47.959]         if (TRUE) {
[17:02:47.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.959]                 open = "w")
[17:02:47.959]         }
[17:02:47.959]         else {
[17:02:47.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.959]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.959]         }
[17:02:47.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.959]             base::sink(type = "output", split = FALSE)
[17:02:47.959]             base::close(...future.stdout)
[17:02:47.959]         }, add = TRUE)
[17:02:47.959]     }
[17:02:47.959]     ...future.frame <- base::sys.nframe()
[17:02:47.959]     ...future.conditions <- base::list()
[17:02:47.959]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.959]     if (FALSE) {
[17:02:47.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.959]     }
[17:02:47.959]     ...future.result <- base::tryCatch({
[17:02:47.959]         base::withCallingHandlers({
[17:02:47.959]             ...future.value <- base::withVisible(base::local({
[17:02:47.959]                 ...future.makeSendCondition <- base::local({
[17:02:47.959]                   sendCondition <- NULL
[17:02:47.959]                   function(frame = 1L) {
[17:02:47.959]                     if (is.function(sendCondition)) 
[17:02:47.959]                       return(sendCondition)
[17:02:47.959]                     ns <- getNamespace("parallel")
[17:02:47.959]                     if (exists("sendData", mode = "function", 
[17:02:47.959]                       envir = ns)) {
[17:02:47.959]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:47.959]                         envir = ns)
[17:02:47.959]                       envir <- sys.frame(frame)
[17:02:47.959]                       master <- NULL
[17:02:47.959]                       while (!identical(envir, .GlobalEnv) && 
[17:02:47.959]                         !identical(envir, emptyenv())) {
[17:02:47.959]                         if (exists("master", mode = "list", envir = envir, 
[17:02:47.959]                           inherits = FALSE)) {
[17:02:47.959]                           master <- get("master", mode = "list", 
[17:02:47.959]                             envir = envir, inherits = FALSE)
[17:02:47.959]                           if (inherits(master, c("SOCKnode", 
[17:02:47.959]                             "SOCK0node"))) {
[17:02:47.959]                             sendCondition <<- function(cond) {
[17:02:47.959]                               data <- list(type = "VALUE", value = cond, 
[17:02:47.959]                                 success = TRUE)
[17:02:47.959]                               parallel_sendData(master, data)
[17:02:47.959]                             }
[17:02:47.959]                             return(sendCondition)
[17:02:47.959]                           }
[17:02:47.959]                         }
[17:02:47.959]                         frame <- frame + 1L
[17:02:47.959]                         envir <- sys.frame(frame)
[17:02:47.959]                       }
[17:02:47.959]                     }
[17:02:47.959]                     sendCondition <<- function(cond) NULL
[17:02:47.959]                   }
[17:02:47.959]                 })
[17:02:47.959]                 withCallingHandlers({
[17:02:47.959]                   {
[17:02:47.959]                     x$a <- 1
[17:02:47.959]                     x
[17:02:47.959]                   }
[17:02:47.959]                 }, immediateCondition = function(cond) {
[17:02:47.959]                   sendCondition <- ...future.makeSendCondition()
[17:02:47.959]                   sendCondition(cond)
[17:02:47.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.959]                   {
[17:02:47.959]                     inherits <- base::inherits
[17:02:47.959]                     invokeRestart <- base::invokeRestart
[17:02:47.959]                     is.null <- base::is.null
[17:02:47.959]                     muffled <- FALSE
[17:02:47.959]                     if (inherits(cond, "message")) {
[17:02:47.959]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.959]                       if (muffled) 
[17:02:47.959]                         invokeRestart("muffleMessage")
[17:02:47.959]                     }
[17:02:47.959]                     else if (inherits(cond, "warning")) {
[17:02:47.959]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.959]                       if (muffled) 
[17:02:47.959]                         invokeRestart("muffleWarning")
[17:02:47.959]                     }
[17:02:47.959]                     else if (inherits(cond, "condition")) {
[17:02:47.959]                       if (!is.null(pattern)) {
[17:02:47.959]                         computeRestarts <- base::computeRestarts
[17:02:47.959]                         grepl <- base::grepl
[17:02:47.959]                         restarts <- computeRestarts(cond)
[17:02:47.959]                         for (restart in restarts) {
[17:02:47.959]                           name <- restart$name
[17:02:47.959]                           if (is.null(name)) 
[17:02:47.959]                             next
[17:02:47.959]                           if (!grepl(pattern, name)) 
[17:02:47.959]                             next
[17:02:47.959]                           invokeRestart(restart)
[17:02:47.959]                           muffled <- TRUE
[17:02:47.959]                           break
[17:02:47.959]                         }
[17:02:47.959]                       }
[17:02:47.959]                     }
[17:02:47.959]                     invisible(muffled)
[17:02:47.959]                   }
[17:02:47.959]                   muffleCondition(cond)
[17:02:47.959]                 })
[17:02:47.959]             }))
[17:02:47.959]             future::FutureResult(value = ...future.value$value, 
[17:02:47.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.959]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.959]                     ...future.globalenv.names))
[17:02:47.959]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.959]         }, condition = base::local({
[17:02:47.959]             c <- base::c
[17:02:47.959]             inherits <- base::inherits
[17:02:47.959]             invokeRestart <- base::invokeRestart
[17:02:47.959]             length <- base::length
[17:02:47.959]             list <- base::list
[17:02:47.959]             seq.int <- base::seq.int
[17:02:47.959]             signalCondition <- base::signalCondition
[17:02:47.959]             sys.calls <- base::sys.calls
[17:02:47.959]             `[[` <- base::`[[`
[17:02:47.959]             `+` <- base::`+`
[17:02:47.959]             `<<-` <- base::`<<-`
[17:02:47.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.959]                   3L)]
[17:02:47.959]             }
[17:02:47.959]             function(cond) {
[17:02:47.959]                 is_error <- inherits(cond, "error")
[17:02:47.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.959]                   NULL)
[17:02:47.959]                 if (is_error) {
[17:02:47.959]                   sessionInformation <- function() {
[17:02:47.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.959]                       search = base::search(), system = base::Sys.info())
[17:02:47.959]                   }
[17:02:47.959]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.959]                     cond$call), session = sessionInformation(), 
[17:02:47.959]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.959]                   signalCondition(cond)
[17:02:47.959]                 }
[17:02:47.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.959]                 "immediateCondition"))) {
[17:02:47.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.959]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.959]                   if (TRUE && !signal) {
[17:02:47.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.959]                     {
[17:02:47.959]                       inherits <- base::inherits
[17:02:47.959]                       invokeRestart <- base::invokeRestart
[17:02:47.959]                       is.null <- base::is.null
[17:02:47.959]                       muffled <- FALSE
[17:02:47.959]                       if (inherits(cond, "message")) {
[17:02:47.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.959]                         if (muffled) 
[17:02:47.959]                           invokeRestart("muffleMessage")
[17:02:47.959]                       }
[17:02:47.959]                       else if (inherits(cond, "warning")) {
[17:02:47.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.959]                         if (muffled) 
[17:02:47.959]                           invokeRestart("muffleWarning")
[17:02:47.959]                       }
[17:02:47.959]                       else if (inherits(cond, "condition")) {
[17:02:47.959]                         if (!is.null(pattern)) {
[17:02:47.959]                           computeRestarts <- base::computeRestarts
[17:02:47.959]                           grepl <- base::grepl
[17:02:47.959]                           restarts <- computeRestarts(cond)
[17:02:47.959]                           for (restart in restarts) {
[17:02:47.959]                             name <- restart$name
[17:02:47.959]                             if (is.null(name)) 
[17:02:47.959]                               next
[17:02:47.959]                             if (!grepl(pattern, name)) 
[17:02:47.959]                               next
[17:02:47.959]                             invokeRestart(restart)
[17:02:47.959]                             muffled <- TRUE
[17:02:47.959]                             break
[17:02:47.959]                           }
[17:02:47.959]                         }
[17:02:47.959]                       }
[17:02:47.959]                       invisible(muffled)
[17:02:47.959]                     }
[17:02:47.959]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.959]                   }
[17:02:47.959]                 }
[17:02:47.959]                 else {
[17:02:47.959]                   if (TRUE) {
[17:02:47.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.959]                     {
[17:02:47.959]                       inherits <- base::inherits
[17:02:47.959]                       invokeRestart <- base::invokeRestart
[17:02:47.959]                       is.null <- base::is.null
[17:02:47.959]                       muffled <- FALSE
[17:02:47.959]                       if (inherits(cond, "message")) {
[17:02:47.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.959]                         if (muffled) 
[17:02:47.959]                           invokeRestart("muffleMessage")
[17:02:47.959]                       }
[17:02:47.959]                       else if (inherits(cond, "warning")) {
[17:02:47.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.959]                         if (muffled) 
[17:02:47.959]                           invokeRestart("muffleWarning")
[17:02:47.959]                       }
[17:02:47.959]                       else if (inherits(cond, "condition")) {
[17:02:47.959]                         if (!is.null(pattern)) {
[17:02:47.959]                           computeRestarts <- base::computeRestarts
[17:02:47.959]                           grepl <- base::grepl
[17:02:47.959]                           restarts <- computeRestarts(cond)
[17:02:47.959]                           for (restart in restarts) {
[17:02:47.959]                             name <- restart$name
[17:02:47.959]                             if (is.null(name)) 
[17:02:47.959]                               next
[17:02:47.959]                             if (!grepl(pattern, name)) 
[17:02:47.959]                               next
[17:02:47.959]                             invokeRestart(restart)
[17:02:47.959]                             muffled <- TRUE
[17:02:47.959]                             break
[17:02:47.959]                           }
[17:02:47.959]                         }
[17:02:47.959]                       }
[17:02:47.959]                       invisible(muffled)
[17:02:47.959]                     }
[17:02:47.959]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.959]                   }
[17:02:47.959]                 }
[17:02:47.959]             }
[17:02:47.959]         }))
[17:02:47.959]     }, error = function(ex) {
[17:02:47.959]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.959]                 ...future.rng), started = ...future.startTime, 
[17:02:47.959]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.959]             version = "1.8"), class = "FutureResult")
[17:02:47.959]     }, finally = {
[17:02:47.959]         if (!identical(...future.workdir, getwd())) 
[17:02:47.959]             setwd(...future.workdir)
[17:02:47.959]         {
[17:02:47.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.959]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.959]             }
[17:02:47.959]             base::options(...future.oldOptions)
[17:02:47.959]             if (.Platform$OS.type == "windows") {
[17:02:47.959]                 old_names <- names(...future.oldEnvVars)
[17:02:47.959]                 envs <- base::Sys.getenv()
[17:02:47.959]                 names <- names(envs)
[17:02:47.959]                 common <- intersect(names, old_names)
[17:02:47.959]                 added <- setdiff(names, old_names)
[17:02:47.959]                 removed <- setdiff(old_names, names)
[17:02:47.959]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.959]                   envs[common]]
[17:02:47.959]                 NAMES <- toupper(changed)
[17:02:47.959]                 args <- list()
[17:02:47.959]                 for (kk in seq_along(NAMES)) {
[17:02:47.959]                   name <- changed[[kk]]
[17:02:47.959]                   NAME <- NAMES[[kk]]
[17:02:47.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.959]                     next
[17:02:47.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.959]                 }
[17:02:47.959]                 NAMES <- toupper(added)
[17:02:47.959]                 for (kk in seq_along(NAMES)) {
[17:02:47.959]                   name <- added[[kk]]
[17:02:47.959]                   NAME <- NAMES[[kk]]
[17:02:47.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.959]                     next
[17:02:47.959]                   args[[name]] <- ""
[17:02:47.959]                 }
[17:02:47.959]                 NAMES <- toupper(removed)
[17:02:47.959]                 for (kk in seq_along(NAMES)) {
[17:02:47.959]                   name <- removed[[kk]]
[17:02:47.959]                   NAME <- NAMES[[kk]]
[17:02:47.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.959]                     next
[17:02:47.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.959]                 }
[17:02:47.959]                 if (length(args) > 0) 
[17:02:47.959]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.959]             }
[17:02:47.959]             else {
[17:02:47.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.959]             }
[17:02:47.959]             {
[17:02:47.959]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.959]                   0L) {
[17:02:47.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.959]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.959]                   base::options(opts)
[17:02:47.959]                 }
[17:02:47.959]                 {
[17:02:47.959]                   {
[17:02:47.959]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.959]                     NULL
[17:02:47.959]                   }
[17:02:47.959]                   options(future.plan = NULL)
[17:02:47.959]                   if (is.na(NA_character_)) 
[17:02:47.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.959]                     .init = FALSE)
[17:02:47.959]                 }
[17:02:47.959]             }
[17:02:47.959]         }
[17:02:47.959]     })
[17:02:47.959]     if (TRUE) {
[17:02:47.959]         base::sink(type = "output", split = FALSE)
[17:02:47.959]         if (TRUE) {
[17:02:47.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.959]         }
[17:02:47.959]         else {
[17:02:47.959]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.959]         }
[17:02:47.959]         base::close(...future.stdout)
[17:02:47.959]         ...future.stdout <- NULL
[17:02:47.959]     }
[17:02:47.959]     ...future.result$conditions <- ...future.conditions
[17:02:47.959]     ...future.result$finished <- base::Sys.time()
[17:02:47.959]     ...future.result
[17:02:47.959] }
[17:02:47.962] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:47.962] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:47.962] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:47.962] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:47.963] MultisessionFuture started
[17:02:47.963] - Launch lazy future ... done
[17:02:47.963] run() for ‘MultisessionFuture’ ... done
[17:02:47.963] result() for ClusterFuture ...
[17:02:47.964] receiveMessageFromWorker() for ClusterFuture ...
[17:02:47.964] - Validating connection of MultisessionFuture
[17:02:47.965] - received message: FutureResult
[17:02:47.965] - Received FutureResult
[17:02:47.965] - Erased future from FutureRegistry
[17:02:47.965] result() for ClusterFuture ...
[17:02:47.965] - result already collected: FutureResult
[17:02:47.965] result() for ClusterFuture ... done
[17:02:47.965] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:47.965] result() for ClusterFuture ... done
[17:02:47.966] result() for ClusterFuture ...
[17:02:47.966] - result already collected: FutureResult
[17:02:47.966] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:47.966] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:47.966] Searching for globals...
[17:02:47.969] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:47.969] Searching for globals ... DONE
[17:02:47.969] Resolving globals: TRUE
[17:02:47.969] Resolving any globals that are futures ...
[17:02:47.969] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:47.970] Resolving any globals that are futures ... DONE
[17:02:47.970] Resolving futures part of globals (recursively) ...
[17:02:47.970] resolve() on list ...
[17:02:47.970]  recursive: 99
[17:02:47.970]  length: 1
[17:02:47.971]  elements: ‘x’
[17:02:47.971]  length: 0 (resolved future 1)
[17:02:47.971] resolve() on list ... DONE
[17:02:47.971] - globals: [1] ‘x’
[17:02:47.971] Resolving futures part of globals (recursively) ... DONE
[17:02:47.971] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:47.972] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:47.972] - globals: [1] ‘x’
[17:02:47.972] 
[17:02:47.972] getGlobalsAndPackages() ... DONE
[17:02:47.972] run() for ‘Future’ ...
[17:02:47.973] - state: ‘created’
[17:02:47.973] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:47.987] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:47.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:47.988]   - Field: ‘node’
[17:02:47.988]   - Field: ‘label’
[17:02:47.988]   - Field: ‘local’
[17:02:47.988]   - Field: ‘owner’
[17:02:47.988]   - Field: ‘envir’
[17:02:47.988]   - Field: ‘workers’
[17:02:47.988]   - Field: ‘packages’
[17:02:47.988]   - Field: ‘gc’
[17:02:47.988]   - Field: ‘conditions’
[17:02:47.989]   - Field: ‘persistent’
[17:02:47.989]   - Field: ‘expr’
[17:02:47.989]   - Field: ‘uuid’
[17:02:47.989]   - Field: ‘seed’
[17:02:47.989]   - Field: ‘version’
[17:02:47.989]   - Field: ‘result’
[17:02:47.989]   - Field: ‘asynchronous’
[17:02:47.989]   - Field: ‘calls’
[17:02:47.989]   - Field: ‘globals’
[17:02:47.990]   - Field: ‘stdout’
[17:02:47.990]   - Field: ‘earlySignal’
[17:02:47.990]   - Field: ‘lazy’
[17:02:47.990]   - Field: ‘state’
[17:02:47.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:47.990] - Launch lazy future ...
[17:02:47.990] Packages needed by the future expression (n = 0): <none>
[17:02:47.991] Packages needed by future strategies (n = 0): <none>
[17:02:47.991] {
[17:02:47.991]     {
[17:02:47.991]         {
[17:02:47.991]             ...future.startTime <- base::Sys.time()
[17:02:47.991]             {
[17:02:47.991]                 {
[17:02:47.991]                   {
[17:02:47.991]                     {
[17:02:47.991]                       base::local({
[17:02:47.991]                         has_future <- base::requireNamespace("future", 
[17:02:47.991]                           quietly = TRUE)
[17:02:47.991]                         if (has_future) {
[17:02:47.991]                           ns <- base::getNamespace("future")
[17:02:47.991]                           version <- ns[[".package"]][["version"]]
[17:02:47.991]                           if (is.null(version)) 
[17:02:47.991]                             version <- utils::packageVersion("future")
[17:02:47.991]                         }
[17:02:47.991]                         else {
[17:02:47.991]                           version <- NULL
[17:02:47.991]                         }
[17:02:47.991]                         if (!has_future || version < "1.8.0") {
[17:02:47.991]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:47.991]                             "", base::R.version$version.string), 
[17:02:47.991]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:47.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:47.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:47.991]                               "release", "version")], collapse = " "), 
[17:02:47.991]                             hostname = base::Sys.info()[["nodename"]])
[17:02:47.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:47.991]                             info)
[17:02:47.991]                           info <- base::paste(info, collapse = "; ")
[17:02:47.991]                           if (!has_future) {
[17:02:47.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:47.991]                               info)
[17:02:47.991]                           }
[17:02:47.991]                           else {
[17:02:47.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:47.991]                               info, version)
[17:02:47.991]                           }
[17:02:47.991]                           base::stop(msg)
[17:02:47.991]                         }
[17:02:47.991]                       })
[17:02:47.991]                     }
[17:02:47.991]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:47.991]                     base::options(mc.cores = 1L)
[17:02:47.991]                   }
[17:02:47.991]                   ...future.strategy.old <- future::plan("list")
[17:02:47.991]                   options(future.plan = NULL)
[17:02:47.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:47.991]                 }
[17:02:47.991]                 ...future.workdir <- getwd()
[17:02:47.991]             }
[17:02:47.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:47.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:47.991]         }
[17:02:47.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:47.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:47.991]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:47.991]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:47.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:47.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:47.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:47.991]             base::names(...future.oldOptions))
[17:02:47.991]     }
[17:02:47.991]     if (FALSE) {
[17:02:47.991]     }
[17:02:47.991]     else {
[17:02:47.991]         if (TRUE) {
[17:02:47.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:47.991]                 open = "w")
[17:02:47.991]         }
[17:02:47.991]         else {
[17:02:47.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:47.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:47.991]         }
[17:02:47.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:47.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:47.991]             base::sink(type = "output", split = FALSE)
[17:02:47.991]             base::close(...future.stdout)
[17:02:47.991]         }, add = TRUE)
[17:02:47.991]     }
[17:02:47.991]     ...future.frame <- base::sys.nframe()
[17:02:47.991]     ...future.conditions <- base::list()
[17:02:47.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:47.991]     if (FALSE) {
[17:02:47.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:47.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:47.991]     }
[17:02:47.991]     ...future.result <- base::tryCatch({
[17:02:47.991]         base::withCallingHandlers({
[17:02:47.991]             ...future.value <- base::withVisible(base::local({
[17:02:47.991]                 ...future.makeSendCondition <- base::local({
[17:02:47.991]                   sendCondition <- NULL
[17:02:47.991]                   function(frame = 1L) {
[17:02:47.991]                     if (is.function(sendCondition)) 
[17:02:47.991]                       return(sendCondition)
[17:02:47.991]                     ns <- getNamespace("parallel")
[17:02:47.991]                     if (exists("sendData", mode = "function", 
[17:02:47.991]                       envir = ns)) {
[17:02:47.991]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:47.991]                         envir = ns)
[17:02:47.991]                       envir <- sys.frame(frame)
[17:02:47.991]                       master <- NULL
[17:02:47.991]                       while (!identical(envir, .GlobalEnv) && 
[17:02:47.991]                         !identical(envir, emptyenv())) {
[17:02:47.991]                         if (exists("master", mode = "list", envir = envir, 
[17:02:47.991]                           inherits = FALSE)) {
[17:02:47.991]                           master <- get("master", mode = "list", 
[17:02:47.991]                             envir = envir, inherits = FALSE)
[17:02:47.991]                           if (inherits(master, c("SOCKnode", 
[17:02:47.991]                             "SOCK0node"))) {
[17:02:47.991]                             sendCondition <<- function(cond) {
[17:02:47.991]                               data <- list(type = "VALUE", value = cond, 
[17:02:47.991]                                 success = TRUE)
[17:02:47.991]                               parallel_sendData(master, data)
[17:02:47.991]                             }
[17:02:47.991]                             return(sendCondition)
[17:02:47.991]                           }
[17:02:47.991]                         }
[17:02:47.991]                         frame <- frame + 1L
[17:02:47.991]                         envir <- sys.frame(frame)
[17:02:47.991]                       }
[17:02:47.991]                     }
[17:02:47.991]                     sendCondition <<- function(cond) NULL
[17:02:47.991]                   }
[17:02:47.991]                 })
[17:02:47.991]                 withCallingHandlers({
[17:02:47.991]                   {
[17:02:47.991]                     x$a <- 1
[17:02:47.991]                     x
[17:02:47.991]                   }
[17:02:47.991]                 }, immediateCondition = function(cond) {
[17:02:47.991]                   sendCondition <- ...future.makeSendCondition()
[17:02:47.991]                   sendCondition(cond)
[17:02:47.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.991]                   {
[17:02:47.991]                     inherits <- base::inherits
[17:02:47.991]                     invokeRestart <- base::invokeRestart
[17:02:47.991]                     is.null <- base::is.null
[17:02:47.991]                     muffled <- FALSE
[17:02:47.991]                     if (inherits(cond, "message")) {
[17:02:47.991]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:47.991]                       if (muffled) 
[17:02:47.991]                         invokeRestart("muffleMessage")
[17:02:47.991]                     }
[17:02:47.991]                     else if (inherits(cond, "warning")) {
[17:02:47.991]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:47.991]                       if (muffled) 
[17:02:47.991]                         invokeRestart("muffleWarning")
[17:02:47.991]                     }
[17:02:47.991]                     else if (inherits(cond, "condition")) {
[17:02:47.991]                       if (!is.null(pattern)) {
[17:02:47.991]                         computeRestarts <- base::computeRestarts
[17:02:47.991]                         grepl <- base::grepl
[17:02:47.991]                         restarts <- computeRestarts(cond)
[17:02:47.991]                         for (restart in restarts) {
[17:02:47.991]                           name <- restart$name
[17:02:47.991]                           if (is.null(name)) 
[17:02:47.991]                             next
[17:02:47.991]                           if (!grepl(pattern, name)) 
[17:02:47.991]                             next
[17:02:47.991]                           invokeRestart(restart)
[17:02:47.991]                           muffled <- TRUE
[17:02:47.991]                           break
[17:02:47.991]                         }
[17:02:47.991]                       }
[17:02:47.991]                     }
[17:02:47.991]                     invisible(muffled)
[17:02:47.991]                   }
[17:02:47.991]                   muffleCondition(cond)
[17:02:47.991]                 })
[17:02:47.991]             }))
[17:02:47.991]             future::FutureResult(value = ...future.value$value, 
[17:02:47.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.991]                   ...future.rng), globalenv = if (FALSE) 
[17:02:47.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:47.991]                     ...future.globalenv.names))
[17:02:47.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:47.991]         }, condition = base::local({
[17:02:47.991]             c <- base::c
[17:02:47.991]             inherits <- base::inherits
[17:02:47.991]             invokeRestart <- base::invokeRestart
[17:02:47.991]             length <- base::length
[17:02:47.991]             list <- base::list
[17:02:47.991]             seq.int <- base::seq.int
[17:02:47.991]             signalCondition <- base::signalCondition
[17:02:47.991]             sys.calls <- base::sys.calls
[17:02:47.991]             `[[` <- base::`[[`
[17:02:47.991]             `+` <- base::`+`
[17:02:47.991]             `<<-` <- base::`<<-`
[17:02:47.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:47.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:47.991]                   3L)]
[17:02:47.991]             }
[17:02:47.991]             function(cond) {
[17:02:47.991]                 is_error <- inherits(cond, "error")
[17:02:47.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:47.991]                   NULL)
[17:02:47.991]                 if (is_error) {
[17:02:47.991]                   sessionInformation <- function() {
[17:02:47.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:47.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:47.991]                       search = base::search(), system = base::Sys.info())
[17:02:47.991]                   }
[17:02:47.991]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:47.991]                     cond$call), session = sessionInformation(), 
[17:02:47.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:47.991]                   signalCondition(cond)
[17:02:47.991]                 }
[17:02:47.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:47.991]                 "immediateCondition"))) {
[17:02:47.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:47.991]                   ...future.conditions[[length(...future.conditions) + 
[17:02:47.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:47.991]                   if (TRUE && !signal) {
[17:02:47.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.991]                     {
[17:02:47.991]                       inherits <- base::inherits
[17:02:47.991]                       invokeRestart <- base::invokeRestart
[17:02:47.991]                       is.null <- base::is.null
[17:02:47.991]                       muffled <- FALSE
[17:02:47.991]                       if (inherits(cond, "message")) {
[17:02:47.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.991]                         if (muffled) 
[17:02:47.991]                           invokeRestart("muffleMessage")
[17:02:47.991]                       }
[17:02:47.991]                       else if (inherits(cond, "warning")) {
[17:02:47.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.991]                         if (muffled) 
[17:02:47.991]                           invokeRestart("muffleWarning")
[17:02:47.991]                       }
[17:02:47.991]                       else if (inherits(cond, "condition")) {
[17:02:47.991]                         if (!is.null(pattern)) {
[17:02:47.991]                           computeRestarts <- base::computeRestarts
[17:02:47.991]                           grepl <- base::grepl
[17:02:47.991]                           restarts <- computeRestarts(cond)
[17:02:47.991]                           for (restart in restarts) {
[17:02:47.991]                             name <- restart$name
[17:02:47.991]                             if (is.null(name)) 
[17:02:47.991]                               next
[17:02:47.991]                             if (!grepl(pattern, name)) 
[17:02:47.991]                               next
[17:02:47.991]                             invokeRestart(restart)
[17:02:47.991]                             muffled <- TRUE
[17:02:47.991]                             break
[17:02:47.991]                           }
[17:02:47.991]                         }
[17:02:47.991]                       }
[17:02:47.991]                       invisible(muffled)
[17:02:47.991]                     }
[17:02:47.991]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.991]                   }
[17:02:47.991]                 }
[17:02:47.991]                 else {
[17:02:47.991]                   if (TRUE) {
[17:02:47.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:47.991]                     {
[17:02:47.991]                       inherits <- base::inherits
[17:02:47.991]                       invokeRestart <- base::invokeRestart
[17:02:47.991]                       is.null <- base::is.null
[17:02:47.991]                       muffled <- FALSE
[17:02:47.991]                       if (inherits(cond, "message")) {
[17:02:47.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:47.991]                         if (muffled) 
[17:02:47.991]                           invokeRestart("muffleMessage")
[17:02:47.991]                       }
[17:02:47.991]                       else if (inherits(cond, "warning")) {
[17:02:47.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:47.991]                         if (muffled) 
[17:02:47.991]                           invokeRestart("muffleWarning")
[17:02:47.991]                       }
[17:02:47.991]                       else if (inherits(cond, "condition")) {
[17:02:47.991]                         if (!is.null(pattern)) {
[17:02:47.991]                           computeRestarts <- base::computeRestarts
[17:02:47.991]                           grepl <- base::grepl
[17:02:47.991]                           restarts <- computeRestarts(cond)
[17:02:47.991]                           for (restart in restarts) {
[17:02:47.991]                             name <- restart$name
[17:02:47.991]                             if (is.null(name)) 
[17:02:47.991]                               next
[17:02:47.991]                             if (!grepl(pattern, name)) 
[17:02:47.991]                               next
[17:02:47.991]                             invokeRestart(restart)
[17:02:47.991]                             muffled <- TRUE
[17:02:47.991]                             break
[17:02:47.991]                           }
[17:02:47.991]                         }
[17:02:47.991]                       }
[17:02:47.991]                       invisible(muffled)
[17:02:47.991]                     }
[17:02:47.991]                     muffleCondition(cond, pattern = "^muffle")
[17:02:47.991]                   }
[17:02:47.991]                 }
[17:02:47.991]             }
[17:02:47.991]         }))
[17:02:47.991]     }, error = function(ex) {
[17:02:47.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:47.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:47.991]                 ...future.rng), started = ...future.startTime, 
[17:02:47.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:47.991]             version = "1.8"), class = "FutureResult")
[17:02:47.991]     }, finally = {
[17:02:47.991]         if (!identical(...future.workdir, getwd())) 
[17:02:47.991]             setwd(...future.workdir)
[17:02:47.991]         {
[17:02:47.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:47.991]                 ...future.oldOptions$nwarnings <- NULL
[17:02:47.991]             }
[17:02:47.991]             base::options(...future.oldOptions)
[17:02:47.991]             if (.Platform$OS.type == "windows") {
[17:02:47.991]                 old_names <- names(...future.oldEnvVars)
[17:02:47.991]                 envs <- base::Sys.getenv()
[17:02:47.991]                 names <- names(envs)
[17:02:47.991]                 common <- intersect(names, old_names)
[17:02:47.991]                 added <- setdiff(names, old_names)
[17:02:47.991]                 removed <- setdiff(old_names, names)
[17:02:47.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:47.991]                   envs[common]]
[17:02:47.991]                 NAMES <- toupper(changed)
[17:02:47.991]                 args <- list()
[17:02:47.991]                 for (kk in seq_along(NAMES)) {
[17:02:47.991]                   name <- changed[[kk]]
[17:02:47.991]                   NAME <- NAMES[[kk]]
[17:02:47.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.991]                     next
[17:02:47.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.991]                 }
[17:02:47.991]                 NAMES <- toupper(added)
[17:02:47.991]                 for (kk in seq_along(NAMES)) {
[17:02:47.991]                   name <- added[[kk]]
[17:02:47.991]                   NAME <- NAMES[[kk]]
[17:02:47.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.991]                     next
[17:02:47.991]                   args[[name]] <- ""
[17:02:47.991]                 }
[17:02:47.991]                 NAMES <- toupper(removed)
[17:02:47.991]                 for (kk in seq_along(NAMES)) {
[17:02:47.991]                   name <- removed[[kk]]
[17:02:47.991]                   NAME <- NAMES[[kk]]
[17:02:47.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:47.991]                     next
[17:02:47.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:47.991]                 }
[17:02:47.991]                 if (length(args) > 0) 
[17:02:47.991]                   base::do.call(base::Sys.setenv, args = args)
[17:02:47.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:47.991]             }
[17:02:47.991]             else {
[17:02:47.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:47.991]             }
[17:02:47.991]             {
[17:02:47.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:47.991]                   0L) {
[17:02:47.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:47.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:47.991]                   base::options(opts)
[17:02:47.991]                 }
[17:02:47.991]                 {
[17:02:47.991]                   {
[17:02:47.991]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:47.991]                     NULL
[17:02:47.991]                   }
[17:02:47.991]                   options(future.plan = NULL)
[17:02:47.991]                   if (is.na(NA_character_)) 
[17:02:47.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:47.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:47.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:47.991]                     .init = FALSE)
[17:02:47.991]                 }
[17:02:47.991]             }
[17:02:47.991]         }
[17:02:47.991]     })
[17:02:47.991]     if (TRUE) {
[17:02:47.991]         base::sink(type = "output", split = FALSE)
[17:02:47.991]         if (TRUE) {
[17:02:47.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:47.991]         }
[17:02:47.991]         else {
[17:02:47.991]             ...future.result["stdout"] <- base::list(NULL)
[17:02:47.991]         }
[17:02:47.991]         base::close(...future.stdout)
[17:02:47.991]         ...future.stdout <- NULL
[17:02:47.991]     }
[17:02:47.991]     ...future.result$conditions <- ...future.conditions
[17:02:47.991]     ...future.result$finished <- base::Sys.time()
[17:02:47.991]     ...future.result
[17:02:47.991] }
[17:02:47.994] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:47.994] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:47.995] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:47.995] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:47.996] MultisessionFuture started
[17:02:47.996] - Launch lazy future ... done
[17:02:47.996] run() for ‘MultisessionFuture’ ... done
[17:02:47.996] result() for ClusterFuture ...
[17:02:47.996] receiveMessageFromWorker() for ClusterFuture ...
[17:02:47.997] - Validating connection of MultisessionFuture
[17:02:48.001] - received message: FutureResult
[17:02:48.001] - Received FutureResult
[17:02:48.002] - Erased future from FutureRegistry
[17:02:48.002] result() for ClusterFuture ...
[17:02:48.002] - result already collected: FutureResult
[17:02:48.002] result() for ClusterFuture ... done
[17:02:48.002] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.002] result() for ClusterFuture ... done
[17:02:48.002] result() for ClusterFuture ...
[17:02:48.002] - result already collected: FutureResult
[17:02:48.002] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.003] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.003] Searching for globals...
[17:02:48.006] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:48.006] Searching for globals ... DONE
[17:02:48.006] Resolving globals: TRUE
[17:02:48.006] Resolving any globals that are futures ...
[17:02:48.006] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:48.007] Resolving any globals that are futures ... DONE
[17:02:48.007] Resolving futures part of globals (recursively) ...
[17:02:48.007] resolve() on list ...
[17:02:48.007]  recursive: 99
[17:02:48.008]  length: 1
[17:02:48.008]  elements: ‘x’
[17:02:48.008]  length: 0 (resolved future 1)
[17:02:48.008] resolve() on list ... DONE
[17:02:48.008] - globals: [1] ‘x’
[17:02:48.008] Resolving futures part of globals (recursively) ... DONE
[17:02:48.008] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.009] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.009] - globals: [1] ‘x’
[17:02:48.009] 
[17:02:48.009] getGlobalsAndPackages() ... DONE
[17:02:48.010] run() for ‘Future’ ...
[17:02:48.010] - state: ‘created’
[17:02:48.010] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.027]   - Field: ‘node’
[17:02:48.027]   - Field: ‘label’
[17:02:48.027]   - Field: ‘local’
[17:02:48.027]   - Field: ‘owner’
[17:02:48.028]   - Field: ‘envir’
[17:02:48.028]   - Field: ‘workers’
[17:02:48.028]   - Field: ‘packages’
[17:02:48.028]   - Field: ‘gc’
[17:02:48.028]   - Field: ‘conditions’
[17:02:48.028]   - Field: ‘persistent’
[17:02:48.028]   - Field: ‘expr’
[17:02:48.028]   - Field: ‘uuid’
[17:02:48.028]   - Field: ‘seed’
[17:02:48.028]   - Field: ‘version’
[17:02:48.028]   - Field: ‘result’
[17:02:48.029]   - Field: ‘asynchronous’
[17:02:48.029]   - Field: ‘calls’
[17:02:48.029]   - Field: ‘globals’
[17:02:48.029]   - Field: ‘stdout’
[17:02:48.029]   - Field: ‘earlySignal’
[17:02:48.029]   - Field: ‘lazy’
[17:02:48.029]   - Field: ‘state’
[17:02:48.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.029] - Launch lazy future ...
[17:02:48.030] Packages needed by the future expression (n = 0): <none>
[17:02:48.030] Packages needed by future strategies (n = 0): <none>
[17:02:48.030] {
[17:02:48.030]     {
[17:02:48.030]         {
[17:02:48.030]             ...future.startTime <- base::Sys.time()
[17:02:48.030]             {
[17:02:48.030]                 {
[17:02:48.030]                   {
[17:02:48.030]                     {
[17:02:48.030]                       base::local({
[17:02:48.030]                         has_future <- base::requireNamespace("future", 
[17:02:48.030]                           quietly = TRUE)
[17:02:48.030]                         if (has_future) {
[17:02:48.030]                           ns <- base::getNamespace("future")
[17:02:48.030]                           version <- ns[[".package"]][["version"]]
[17:02:48.030]                           if (is.null(version)) 
[17:02:48.030]                             version <- utils::packageVersion("future")
[17:02:48.030]                         }
[17:02:48.030]                         else {
[17:02:48.030]                           version <- NULL
[17:02:48.030]                         }
[17:02:48.030]                         if (!has_future || version < "1.8.0") {
[17:02:48.030]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.030]                             "", base::R.version$version.string), 
[17:02:48.030]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.030]                               "release", "version")], collapse = " "), 
[17:02:48.030]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.030]                             info)
[17:02:48.030]                           info <- base::paste(info, collapse = "; ")
[17:02:48.030]                           if (!has_future) {
[17:02:48.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.030]                               info)
[17:02:48.030]                           }
[17:02:48.030]                           else {
[17:02:48.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.030]                               info, version)
[17:02:48.030]                           }
[17:02:48.030]                           base::stop(msg)
[17:02:48.030]                         }
[17:02:48.030]                       })
[17:02:48.030]                     }
[17:02:48.030]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.030]                     base::options(mc.cores = 1L)
[17:02:48.030]                   }
[17:02:48.030]                   ...future.strategy.old <- future::plan("list")
[17:02:48.030]                   options(future.plan = NULL)
[17:02:48.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.030]                 }
[17:02:48.030]                 ...future.workdir <- getwd()
[17:02:48.030]             }
[17:02:48.030]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.030]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.030]         }
[17:02:48.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.030]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.030]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.030]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.030]             base::names(...future.oldOptions))
[17:02:48.030]     }
[17:02:48.030]     if (FALSE) {
[17:02:48.030]     }
[17:02:48.030]     else {
[17:02:48.030]         if (TRUE) {
[17:02:48.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.030]                 open = "w")
[17:02:48.030]         }
[17:02:48.030]         else {
[17:02:48.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.030]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.030]         }
[17:02:48.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.030]             base::sink(type = "output", split = FALSE)
[17:02:48.030]             base::close(...future.stdout)
[17:02:48.030]         }, add = TRUE)
[17:02:48.030]     }
[17:02:48.030]     ...future.frame <- base::sys.nframe()
[17:02:48.030]     ...future.conditions <- base::list()
[17:02:48.030]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.030]     if (FALSE) {
[17:02:48.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.030]     }
[17:02:48.030]     ...future.result <- base::tryCatch({
[17:02:48.030]         base::withCallingHandlers({
[17:02:48.030]             ...future.value <- base::withVisible(base::local({
[17:02:48.030]                 ...future.makeSendCondition <- base::local({
[17:02:48.030]                   sendCondition <- NULL
[17:02:48.030]                   function(frame = 1L) {
[17:02:48.030]                     if (is.function(sendCondition)) 
[17:02:48.030]                       return(sendCondition)
[17:02:48.030]                     ns <- getNamespace("parallel")
[17:02:48.030]                     if (exists("sendData", mode = "function", 
[17:02:48.030]                       envir = ns)) {
[17:02:48.030]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.030]                         envir = ns)
[17:02:48.030]                       envir <- sys.frame(frame)
[17:02:48.030]                       master <- NULL
[17:02:48.030]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.030]                         !identical(envir, emptyenv())) {
[17:02:48.030]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.030]                           inherits = FALSE)) {
[17:02:48.030]                           master <- get("master", mode = "list", 
[17:02:48.030]                             envir = envir, inherits = FALSE)
[17:02:48.030]                           if (inherits(master, c("SOCKnode", 
[17:02:48.030]                             "SOCK0node"))) {
[17:02:48.030]                             sendCondition <<- function(cond) {
[17:02:48.030]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.030]                                 success = TRUE)
[17:02:48.030]                               parallel_sendData(master, data)
[17:02:48.030]                             }
[17:02:48.030]                             return(sendCondition)
[17:02:48.030]                           }
[17:02:48.030]                         }
[17:02:48.030]                         frame <- frame + 1L
[17:02:48.030]                         envir <- sys.frame(frame)
[17:02:48.030]                       }
[17:02:48.030]                     }
[17:02:48.030]                     sendCondition <<- function(cond) NULL
[17:02:48.030]                   }
[17:02:48.030]                 })
[17:02:48.030]                 withCallingHandlers({
[17:02:48.030]                   {
[17:02:48.030]                     x$a <- 1
[17:02:48.030]                     x
[17:02:48.030]                   }
[17:02:48.030]                 }, immediateCondition = function(cond) {
[17:02:48.030]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.030]                   sendCondition(cond)
[17:02:48.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.030]                   {
[17:02:48.030]                     inherits <- base::inherits
[17:02:48.030]                     invokeRestart <- base::invokeRestart
[17:02:48.030]                     is.null <- base::is.null
[17:02:48.030]                     muffled <- FALSE
[17:02:48.030]                     if (inherits(cond, "message")) {
[17:02:48.030]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.030]                       if (muffled) 
[17:02:48.030]                         invokeRestart("muffleMessage")
[17:02:48.030]                     }
[17:02:48.030]                     else if (inherits(cond, "warning")) {
[17:02:48.030]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.030]                       if (muffled) 
[17:02:48.030]                         invokeRestart("muffleWarning")
[17:02:48.030]                     }
[17:02:48.030]                     else if (inherits(cond, "condition")) {
[17:02:48.030]                       if (!is.null(pattern)) {
[17:02:48.030]                         computeRestarts <- base::computeRestarts
[17:02:48.030]                         grepl <- base::grepl
[17:02:48.030]                         restarts <- computeRestarts(cond)
[17:02:48.030]                         for (restart in restarts) {
[17:02:48.030]                           name <- restart$name
[17:02:48.030]                           if (is.null(name)) 
[17:02:48.030]                             next
[17:02:48.030]                           if (!grepl(pattern, name)) 
[17:02:48.030]                             next
[17:02:48.030]                           invokeRestart(restart)
[17:02:48.030]                           muffled <- TRUE
[17:02:48.030]                           break
[17:02:48.030]                         }
[17:02:48.030]                       }
[17:02:48.030]                     }
[17:02:48.030]                     invisible(muffled)
[17:02:48.030]                   }
[17:02:48.030]                   muffleCondition(cond)
[17:02:48.030]                 })
[17:02:48.030]             }))
[17:02:48.030]             future::FutureResult(value = ...future.value$value, 
[17:02:48.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.030]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.030]                     ...future.globalenv.names))
[17:02:48.030]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.030]         }, condition = base::local({
[17:02:48.030]             c <- base::c
[17:02:48.030]             inherits <- base::inherits
[17:02:48.030]             invokeRestart <- base::invokeRestart
[17:02:48.030]             length <- base::length
[17:02:48.030]             list <- base::list
[17:02:48.030]             seq.int <- base::seq.int
[17:02:48.030]             signalCondition <- base::signalCondition
[17:02:48.030]             sys.calls <- base::sys.calls
[17:02:48.030]             `[[` <- base::`[[`
[17:02:48.030]             `+` <- base::`+`
[17:02:48.030]             `<<-` <- base::`<<-`
[17:02:48.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.030]                   3L)]
[17:02:48.030]             }
[17:02:48.030]             function(cond) {
[17:02:48.030]                 is_error <- inherits(cond, "error")
[17:02:48.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.030]                   NULL)
[17:02:48.030]                 if (is_error) {
[17:02:48.030]                   sessionInformation <- function() {
[17:02:48.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.030]                       search = base::search(), system = base::Sys.info())
[17:02:48.030]                   }
[17:02:48.030]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.030]                     cond$call), session = sessionInformation(), 
[17:02:48.030]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.030]                   signalCondition(cond)
[17:02:48.030]                 }
[17:02:48.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.030]                 "immediateCondition"))) {
[17:02:48.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.030]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.030]                   if (TRUE && !signal) {
[17:02:48.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.030]                     {
[17:02:48.030]                       inherits <- base::inherits
[17:02:48.030]                       invokeRestart <- base::invokeRestart
[17:02:48.030]                       is.null <- base::is.null
[17:02:48.030]                       muffled <- FALSE
[17:02:48.030]                       if (inherits(cond, "message")) {
[17:02:48.030]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.030]                         if (muffled) 
[17:02:48.030]                           invokeRestart("muffleMessage")
[17:02:48.030]                       }
[17:02:48.030]                       else if (inherits(cond, "warning")) {
[17:02:48.030]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.030]                         if (muffled) 
[17:02:48.030]                           invokeRestart("muffleWarning")
[17:02:48.030]                       }
[17:02:48.030]                       else if (inherits(cond, "condition")) {
[17:02:48.030]                         if (!is.null(pattern)) {
[17:02:48.030]                           computeRestarts <- base::computeRestarts
[17:02:48.030]                           grepl <- base::grepl
[17:02:48.030]                           restarts <- computeRestarts(cond)
[17:02:48.030]                           for (restart in restarts) {
[17:02:48.030]                             name <- restart$name
[17:02:48.030]                             if (is.null(name)) 
[17:02:48.030]                               next
[17:02:48.030]                             if (!grepl(pattern, name)) 
[17:02:48.030]                               next
[17:02:48.030]                             invokeRestart(restart)
[17:02:48.030]                             muffled <- TRUE
[17:02:48.030]                             break
[17:02:48.030]                           }
[17:02:48.030]                         }
[17:02:48.030]                       }
[17:02:48.030]                       invisible(muffled)
[17:02:48.030]                     }
[17:02:48.030]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.030]                   }
[17:02:48.030]                 }
[17:02:48.030]                 else {
[17:02:48.030]                   if (TRUE) {
[17:02:48.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.030]                     {
[17:02:48.030]                       inherits <- base::inherits
[17:02:48.030]                       invokeRestart <- base::invokeRestart
[17:02:48.030]                       is.null <- base::is.null
[17:02:48.030]                       muffled <- FALSE
[17:02:48.030]                       if (inherits(cond, "message")) {
[17:02:48.030]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.030]                         if (muffled) 
[17:02:48.030]                           invokeRestart("muffleMessage")
[17:02:48.030]                       }
[17:02:48.030]                       else if (inherits(cond, "warning")) {
[17:02:48.030]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.030]                         if (muffled) 
[17:02:48.030]                           invokeRestart("muffleWarning")
[17:02:48.030]                       }
[17:02:48.030]                       else if (inherits(cond, "condition")) {
[17:02:48.030]                         if (!is.null(pattern)) {
[17:02:48.030]                           computeRestarts <- base::computeRestarts
[17:02:48.030]                           grepl <- base::grepl
[17:02:48.030]                           restarts <- computeRestarts(cond)
[17:02:48.030]                           for (restart in restarts) {
[17:02:48.030]                             name <- restart$name
[17:02:48.030]                             if (is.null(name)) 
[17:02:48.030]                               next
[17:02:48.030]                             if (!grepl(pattern, name)) 
[17:02:48.030]                               next
[17:02:48.030]                             invokeRestart(restart)
[17:02:48.030]                             muffled <- TRUE
[17:02:48.030]                             break
[17:02:48.030]                           }
[17:02:48.030]                         }
[17:02:48.030]                       }
[17:02:48.030]                       invisible(muffled)
[17:02:48.030]                     }
[17:02:48.030]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.030]                   }
[17:02:48.030]                 }
[17:02:48.030]             }
[17:02:48.030]         }))
[17:02:48.030]     }, error = function(ex) {
[17:02:48.030]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.030]                 ...future.rng), started = ...future.startTime, 
[17:02:48.030]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.030]             version = "1.8"), class = "FutureResult")
[17:02:48.030]     }, finally = {
[17:02:48.030]         if (!identical(...future.workdir, getwd())) 
[17:02:48.030]             setwd(...future.workdir)
[17:02:48.030]         {
[17:02:48.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.030]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.030]             }
[17:02:48.030]             base::options(...future.oldOptions)
[17:02:48.030]             if (.Platform$OS.type == "windows") {
[17:02:48.030]                 old_names <- names(...future.oldEnvVars)
[17:02:48.030]                 envs <- base::Sys.getenv()
[17:02:48.030]                 names <- names(envs)
[17:02:48.030]                 common <- intersect(names, old_names)
[17:02:48.030]                 added <- setdiff(names, old_names)
[17:02:48.030]                 removed <- setdiff(old_names, names)
[17:02:48.030]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.030]                   envs[common]]
[17:02:48.030]                 NAMES <- toupper(changed)
[17:02:48.030]                 args <- list()
[17:02:48.030]                 for (kk in seq_along(NAMES)) {
[17:02:48.030]                   name <- changed[[kk]]
[17:02:48.030]                   NAME <- NAMES[[kk]]
[17:02:48.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.030]                     next
[17:02:48.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.030]                 }
[17:02:48.030]                 NAMES <- toupper(added)
[17:02:48.030]                 for (kk in seq_along(NAMES)) {
[17:02:48.030]                   name <- added[[kk]]
[17:02:48.030]                   NAME <- NAMES[[kk]]
[17:02:48.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.030]                     next
[17:02:48.030]                   args[[name]] <- ""
[17:02:48.030]                 }
[17:02:48.030]                 NAMES <- toupper(removed)
[17:02:48.030]                 for (kk in seq_along(NAMES)) {
[17:02:48.030]                   name <- removed[[kk]]
[17:02:48.030]                   NAME <- NAMES[[kk]]
[17:02:48.030]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.030]                     next
[17:02:48.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.030]                 }
[17:02:48.030]                 if (length(args) > 0) 
[17:02:48.030]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.030]             }
[17:02:48.030]             else {
[17:02:48.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.030]             }
[17:02:48.030]             {
[17:02:48.030]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.030]                   0L) {
[17:02:48.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.030]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.030]                   base::options(opts)
[17:02:48.030]                 }
[17:02:48.030]                 {
[17:02:48.030]                   {
[17:02:48.030]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.030]                     NULL
[17:02:48.030]                   }
[17:02:48.030]                   options(future.plan = NULL)
[17:02:48.030]                   if (is.na(NA_character_)) 
[17:02:48.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.030]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.030]                     .init = FALSE)
[17:02:48.030]                 }
[17:02:48.030]             }
[17:02:48.030]         }
[17:02:48.030]     })
[17:02:48.030]     if (TRUE) {
[17:02:48.030]         base::sink(type = "output", split = FALSE)
[17:02:48.030]         if (TRUE) {
[17:02:48.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.030]         }
[17:02:48.030]         else {
[17:02:48.030]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.030]         }
[17:02:48.030]         base::close(...future.stdout)
[17:02:48.030]         ...future.stdout <- NULL
[17:02:48.030]     }
[17:02:48.030]     ...future.result$conditions <- ...future.conditions
[17:02:48.030]     ...future.result$finished <- base::Sys.time()
[17:02:48.030]     ...future.result
[17:02:48.030] }
[17:02:48.033] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.033] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.033] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.033] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.034] MultisessionFuture started
[17:02:48.034] - Launch lazy future ... done
[17:02:48.034] run() for ‘MultisessionFuture’ ... done
[17:02:48.034] result() for ClusterFuture ...
[17:02:48.034] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.034] - Validating connection of MultisessionFuture
[17:02:48.035] - received message: FutureResult
[17:02:48.036] - Received FutureResult
[17:02:48.036] - Erased future from FutureRegistry
[17:02:48.036] result() for ClusterFuture ...
[17:02:48.036] - result already collected: FutureResult
[17:02:48.036] result() for ClusterFuture ... done
[17:02:48.036] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.036] result() for ClusterFuture ... done
[17:02:48.036] result() for ClusterFuture ...
[17:02:48.036] - result already collected: FutureResult
[17:02:48.036] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.037] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.037] Searching for globals...
[17:02:48.039] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:48.039] Searching for globals ... DONE
[17:02:48.039] Resolving globals: TRUE
[17:02:48.039] Resolving any globals that are futures ...
[17:02:48.039] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[17:02:48.039] Resolving any globals that are futures ... DONE
[17:02:48.040] Resolving futures part of globals (recursively) ...
[17:02:48.040] resolve() on list ...
[17:02:48.040]  recursive: 99
[17:02:48.040]  length: 1
[17:02:48.040]  elements: ‘x’
[17:02:48.040]  length: 0 (resolved future 1)
[17:02:48.041] resolve() on list ... DONE
[17:02:48.041] - globals: [1] ‘x’
[17:02:48.041] Resolving futures part of globals (recursively) ... DONE
[17:02:48.041] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.041] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.041] - globals: [1] ‘x’
[17:02:48.041] 
[17:02:48.042] getGlobalsAndPackages() ... DONE
[17:02:48.042] run() for ‘Future’ ...
[17:02:48.042] - state: ‘created’
[17:02:48.042] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.056] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.056]   - Field: ‘node’
[17:02:48.056]   - Field: ‘label’
[17:02:48.056]   - Field: ‘local’
[17:02:48.056]   - Field: ‘owner’
[17:02:48.056]   - Field: ‘envir’
[17:02:48.056]   - Field: ‘workers’
[17:02:48.056]   - Field: ‘packages’
[17:02:48.057]   - Field: ‘gc’
[17:02:48.057]   - Field: ‘conditions’
[17:02:48.057]   - Field: ‘persistent’
[17:02:48.057]   - Field: ‘expr’
[17:02:48.057]   - Field: ‘uuid’
[17:02:48.057]   - Field: ‘seed’
[17:02:48.057]   - Field: ‘version’
[17:02:48.057]   - Field: ‘result’
[17:02:48.057]   - Field: ‘asynchronous’
[17:02:48.057]   - Field: ‘calls’
[17:02:48.057]   - Field: ‘globals’
[17:02:48.058]   - Field: ‘stdout’
[17:02:48.058]   - Field: ‘earlySignal’
[17:02:48.058]   - Field: ‘lazy’
[17:02:48.058]   - Field: ‘state’
[17:02:48.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.058] - Launch lazy future ...
[17:02:48.058] Packages needed by the future expression (n = 0): <none>
[17:02:48.058] Packages needed by future strategies (n = 0): <none>
[17:02:48.059] {
[17:02:48.059]     {
[17:02:48.059]         {
[17:02:48.059]             ...future.startTime <- base::Sys.time()
[17:02:48.059]             {
[17:02:48.059]                 {
[17:02:48.059]                   {
[17:02:48.059]                     {
[17:02:48.059]                       base::local({
[17:02:48.059]                         has_future <- base::requireNamespace("future", 
[17:02:48.059]                           quietly = TRUE)
[17:02:48.059]                         if (has_future) {
[17:02:48.059]                           ns <- base::getNamespace("future")
[17:02:48.059]                           version <- ns[[".package"]][["version"]]
[17:02:48.059]                           if (is.null(version)) 
[17:02:48.059]                             version <- utils::packageVersion("future")
[17:02:48.059]                         }
[17:02:48.059]                         else {
[17:02:48.059]                           version <- NULL
[17:02:48.059]                         }
[17:02:48.059]                         if (!has_future || version < "1.8.0") {
[17:02:48.059]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.059]                             "", base::R.version$version.string), 
[17:02:48.059]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.059]                               "release", "version")], collapse = " "), 
[17:02:48.059]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.059]                             info)
[17:02:48.059]                           info <- base::paste(info, collapse = "; ")
[17:02:48.059]                           if (!has_future) {
[17:02:48.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.059]                               info)
[17:02:48.059]                           }
[17:02:48.059]                           else {
[17:02:48.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.059]                               info, version)
[17:02:48.059]                           }
[17:02:48.059]                           base::stop(msg)
[17:02:48.059]                         }
[17:02:48.059]                       })
[17:02:48.059]                     }
[17:02:48.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.059]                     base::options(mc.cores = 1L)
[17:02:48.059]                   }
[17:02:48.059]                   ...future.strategy.old <- future::plan("list")
[17:02:48.059]                   options(future.plan = NULL)
[17:02:48.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.059]                 }
[17:02:48.059]                 ...future.workdir <- getwd()
[17:02:48.059]             }
[17:02:48.059]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.059]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.059]         }
[17:02:48.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.059]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.059]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.059]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.059]             base::names(...future.oldOptions))
[17:02:48.059]     }
[17:02:48.059]     if (FALSE) {
[17:02:48.059]     }
[17:02:48.059]     else {
[17:02:48.059]         if (TRUE) {
[17:02:48.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.059]                 open = "w")
[17:02:48.059]         }
[17:02:48.059]         else {
[17:02:48.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.059]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.059]         }
[17:02:48.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.059]             base::sink(type = "output", split = FALSE)
[17:02:48.059]             base::close(...future.stdout)
[17:02:48.059]         }, add = TRUE)
[17:02:48.059]     }
[17:02:48.059]     ...future.frame <- base::sys.nframe()
[17:02:48.059]     ...future.conditions <- base::list()
[17:02:48.059]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.059]     if (FALSE) {
[17:02:48.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.059]     }
[17:02:48.059]     ...future.result <- base::tryCatch({
[17:02:48.059]         base::withCallingHandlers({
[17:02:48.059]             ...future.value <- base::withVisible(base::local({
[17:02:48.059]                 ...future.makeSendCondition <- base::local({
[17:02:48.059]                   sendCondition <- NULL
[17:02:48.059]                   function(frame = 1L) {
[17:02:48.059]                     if (is.function(sendCondition)) 
[17:02:48.059]                       return(sendCondition)
[17:02:48.059]                     ns <- getNamespace("parallel")
[17:02:48.059]                     if (exists("sendData", mode = "function", 
[17:02:48.059]                       envir = ns)) {
[17:02:48.059]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.059]                         envir = ns)
[17:02:48.059]                       envir <- sys.frame(frame)
[17:02:48.059]                       master <- NULL
[17:02:48.059]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.059]                         !identical(envir, emptyenv())) {
[17:02:48.059]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.059]                           inherits = FALSE)) {
[17:02:48.059]                           master <- get("master", mode = "list", 
[17:02:48.059]                             envir = envir, inherits = FALSE)
[17:02:48.059]                           if (inherits(master, c("SOCKnode", 
[17:02:48.059]                             "SOCK0node"))) {
[17:02:48.059]                             sendCondition <<- function(cond) {
[17:02:48.059]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.059]                                 success = TRUE)
[17:02:48.059]                               parallel_sendData(master, data)
[17:02:48.059]                             }
[17:02:48.059]                             return(sendCondition)
[17:02:48.059]                           }
[17:02:48.059]                         }
[17:02:48.059]                         frame <- frame + 1L
[17:02:48.059]                         envir <- sys.frame(frame)
[17:02:48.059]                       }
[17:02:48.059]                     }
[17:02:48.059]                     sendCondition <<- function(cond) NULL
[17:02:48.059]                   }
[17:02:48.059]                 })
[17:02:48.059]                 withCallingHandlers({
[17:02:48.059]                   {
[17:02:48.059]                     x$a <- 1
[17:02:48.059]                     x
[17:02:48.059]                   }
[17:02:48.059]                 }, immediateCondition = function(cond) {
[17:02:48.059]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.059]                   sendCondition(cond)
[17:02:48.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.059]                   {
[17:02:48.059]                     inherits <- base::inherits
[17:02:48.059]                     invokeRestart <- base::invokeRestart
[17:02:48.059]                     is.null <- base::is.null
[17:02:48.059]                     muffled <- FALSE
[17:02:48.059]                     if (inherits(cond, "message")) {
[17:02:48.059]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.059]                       if (muffled) 
[17:02:48.059]                         invokeRestart("muffleMessage")
[17:02:48.059]                     }
[17:02:48.059]                     else if (inherits(cond, "warning")) {
[17:02:48.059]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.059]                       if (muffled) 
[17:02:48.059]                         invokeRestart("muffleWarning")
[17:02:48.059]                     }
[17:02:48.059]                     else if (inherits(cond, "condition")) {
[17:02:48.059]                       if (!is.null(pattern)) {
[17:02:48.059]                         computeRestarts <- base::computeRestarts
[17:02:48.059]                         grepl <- base::grepl
[17:02:48.059]                         restarts <- computeRestarts(cond)
[17:02:48.059]                         for (restart in restarts) {
[17:02:48.059]                           name <- restart$name
[17:02:48.059]                           if (is.null(name)) 
[17:02:48.059]                             next
[17:02:48.059]                           if (!grepl(pattern, name)) 
[17:02:48.059]                             next
[17:02:48.059]                           invokeRestart(restart)
[17:02:48.059]                           muffled <- TRUE
[17:02:48.059]                           break
[17:02:48.059]                         }
[17:02:48.059]                       }
[17:02:48.059]                     }
[17:02:48.059]                     invisible(muffled)
[17:02:48.059]                   }
[17:02:48.059]                   muffleCondition(cond)
[17:02:48.059]                 })
[17:02:48.059]             }))
[17:02:48.059]             future::FutureResult(value = ...future.value$value, 
[17:02:48.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.059]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.059]                     ...future.globalenv.names))
[17:02:48.059]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.059]         }, condition = base::local({
[17:02:48.059]             c <- base::c
[17:02:48.059]             inherits <- base::inherits
[17:02:48.059]             invokeRestart <- base::invokeRestart
[17:02:48.059]             length <- base::length
[17:02:48.059]             list <- base::list
[17:02:48.059]             seq.int <- base::seq.int
[17:02:48.059]             signalCondition <- base::signalCondition
[17:02:48.059]             sys.calls <- base::sys.calls
[17:02:48.059]             `[[` <- base::`[[`
[17:02:48.059]             `+` <- base::`+`
[17:02:48.059]             `<<-` <- base::`<<-`
[17:02:48.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.059]                   3L)]
[17:02:48.059]             }
[17:02:48.059]             function(cond) {
[17:02:48.059]                 is_error <- inherits(cond, "error")
[17:02:48.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.059]                   NULL)
[17:02:48.059]                 if (is_error) {
[17:02:48.059]                   sessionInformation <- function() {
[17:02:48.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.059]                       search = base::search(), system = base::Sys.info())
[17:02:48.059]                   }
[17:02:48.059]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.059]                     cond$call), session = sessionInformation(), 
[17:02:48.059]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.059]                   signalCondition(cond)
[17:02:48.059]                 }
[17:02:48.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.059]                 "immediateCondition"))) {
[17:02:48.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.059]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.059]                   if (TRUE && !signal) {
[17:02:48.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.059]                     {
[17:02:48.059]                       inherits <- base::inherits
[17:02:48.059]                       invokeRestart <- base::invokeRestart
[17:02:48.059]                       is.null <- base::is.null
[17:02:48.059]                       muffled <- FALSE
[17:02:48.059]                       if (inherits(cond, "message")) {
[17:02:48.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.059]                         if (muffled) 
[17:02:48.059]                           invokeRestart("muffleMessage")
[17:02:48.059]                       }
[17:02:48.059]                       else if (inherits(cond, "warning")) {
[17:02:48.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.059]                         if (muffled) 
[17:02:48.059]                           invokeRestart("muffleWarning")
[17:02:48.059]                       }
[17:02:48.059]                       else if (inherits(cond, "condition")) {
[17:02:48.059]                         if (!is.null(pattern)) {
[17:02:48.059]                           computeRestarts <- base::computeRestarts
[17:02:48.059]                           grepl <- base::grepl
[17:02:48.059]                           restarts <- computeRestarts(cond)
[17:02:48.059]                           for (restart in restarts) {
[17:02:48.059]                             name <- restart$name
[17:02:48.059]                             if (is.null(name)) 
[17:02:48.059]                               next
[17:02:48.059]                             if (!grepl(pattern, name)) 
[17:02:48.059]                               next
[17:02:48.059]                             invokeRestart(restart)
[17:02:48.059]                             muffled <- TRUE
[17:02:48.059]                             break
[17:02:48.059]                           }
[17:02:48.059]                         }
[17:02:48.059]                       }
[17:02:48.059]                       invisible(muffled)
[17:02:48.059]                     }
[17:02:48.059]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.059]                   }
[17:02:48.059]                 }
[17:02:48.059]                 else {
[17:02:48.059]                   if (TRUE) {
[17:02:48.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.059]                     {
[17:02:48.059]                       inherits <- base::inherits
[17:02:48.059]                       invokeRestart <- base::invokeRestart
[17:02:48.059]                       is.null <- base::is.null
[17:02:48.059]                       muffled <- FALSE
[17:02:48.059]                       if (inherits(cond, "message")) {
[17:02:48.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.059]                         if (muffled) 
[17:02:48.059]                           invokeRestart("muffleMessage")
[17:02:48.059]                       }
[17:02:48.059]                       else if (inherits(cond, "warning")) {
[17:02:48.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.059]                         if (muffled) 
[17:02:48.059]                           invokeRestart("muffleWarning")
[17:02:48.059]                       }
[17:02:48.059]                       else if (inherits(cond, "condition")) {
[17:02:48.059]                         if (!is.null(pattern)) {
[17:02:48.059]                           computeRestarts <- base::computeRestarts
[17:02:48.059]                           grepl <- base::grepl
[17:02:48.059]                           restarts <- computeRestarts(cond)
[17:02:48.059]                           for (restart in restarts) {
[17:02:48.059]                             name <- restart$name
[17:02:48.059]                             if (is.null(name)) 
[17:02:48.059]                               next
[17:02:48.059]                             if (!grepl(pattern, name)) 
[17:02:48.059]                               next
[17:02:48.059]                             invokeRestart(restart)
[17:02:48.059]                             muffled <- TRUE
[17:02:48.059]                             break
[17:02:48.059]                           }
[17:02:48.059]                         }
[17:02:48.059]                       }
[17:02:48.059]                       invisible(muffled)
[17:02:48.059]                     }
[17:02:48.059]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.059]                   }
[17:02:48.059]                 }
[17:02:48.059]             }
[17:02:48.059]         }))
[17:02:48.059]     }, error = function(ex) {
[17:02:48.059]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.059]                 ...future.rng), started = ...future.startTime, 
[17:02:48.059]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.059]             version = "1.8"), class = "FutureResult")
[17:02:48.059]     }, finally = {
[17:02:48.059]         if (!identical(...future.workdir, getwd())) 
[17:02:48.059]             setwd(...future.workdir)
[17:02:48.059]         {
[17:02:48.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.059]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.059]             }
[17:02:48.059]             base::options(...future.oldOptions)
[17:02:48.059]             if (.Platform$OS.type == "windows") {
[17:02:48.059]                 old_names <- names(...future.oldEnvVars)
[17:02:48.059]                 envs <- base::Sys.getenv()
[17:02:48.059]                 names <- names(envs)
[17:02:48.059]                 common <- intersect(names, old_names)
[17:02:48.059]                 added <- setdiff(names, old_names)
[17:02:48.059]                 removed <- setdiff(old_names, names)
[17:02:48.059]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.059]                   envs[common]]
[17:02:48.059]                 NAMES <- toupper(changed)
[17:02:48.059]                 args <- list()
[17:02:48.059]                 for (kk in seq_along(NAMES)) {
[17:02:48.059]                   name <- changed[[kk]]
[17:02:48.059]                   NAME <- NAMES[[kk]]
[17:02:48.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.059]                     next
[17:02:48.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.059]                 }
[17:02:48.059]                 NAMES <- toupper(added)
[17:02:48.059]                 for (kk in seq_along(NAMES)) {
[17:02:48.059]                   name <- added[[kk]]
[17:02:48.059]                   NAME <- NAMES[[kk]]
[17:02:48.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.059]                     next
[17:02:48.059]                   args[[name]] <- ""
[17:02:48.059]                 }
[17:02:48.059]                 NAMES <- toupper(removed)
[17:02:48.059]                 for (kk in seq_along(NAMES)) {
[17:02:48.059]                   name <- removed[[kk]]
[17:02:48.059]                   NAME <- NAMES[[kk]]
[17:02:48.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.059]                     next
[17:02:48.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.059]                 }
[17:02:48.059]                 if (length(args) > 0) 
[17:02:48.059]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.059]             }
[17:02:48.059]             else {
[17:02:48.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.059]             }
[17:02:48.059]             {
[17:02:48.059]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.059]                   0L) {
[17:02:48.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.059]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.059]                   base::options(opts)
[17:02:48.059]                 }
[17:02:48.059]                 {
[17:02:48.059]                   {
[17:02:48.059]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.059]                     NULL
[17:02:48.059]                   }
[17:02:48.059]                   options(future.plan = NULL)
[17:02:48.059]                   if (is.na(NA_character_)) 
[17:02:48.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.059]                     .init = FALSE)
[17:02:48.059]                 }
[17:02:48.059]             }
[17:02:48.059]         }
[17:02:48.059]     })
[17:02:48.059]     if (TRUE) {
[17:02:48.059]         base::sink(type = "output", split = FALSE)
[17:02:48.059]         if (TRUE) {
[17:02:48.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.059]         }
[17:02:48.059]         else {
[17:02:48.059]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.059]         }
[17:02:48.059]         base::close(...future.stdout)
[17:02:48.059]         ...future.stdout <- NULL
[17:02:48.059]     }
[17:02:48.059]     ...future.result$conditions <- ...future.conditions
[17:02:48.059]     ...future.result$finished <- base::Sys.time()
[17:02:48.059]     ...future.result
[17:02:48.059] }
[17:02:48.061] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.061] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.062] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.062] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.062] MultisessionFuture started
[17:02:48.062] - Launch lazy future ... done
[17:02:48.063] run() for ‘MultisessionFuture’ ... done
[17:02:48.063] result() for ClusterFuture ...
[17:02:48.063] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.063] - Validating connection of MultisessionFuture
[17:02:48.064] - received message: FutureResult
[17:02:48.064] - Received FutureResult
[17:02:48.064] - Erased future from FutureRegistry
[17:02:48.065] result() for ClusterFuture ...
[17:02:48.065] - result already collected: FutureResult
[17:02:48.065] result() for ClusterFuture ... done
[17:02:48.065] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.065] result() for ClusterFuture ... done
[17:02:48.065] result() for ClusterFuture ...
[17:02:48.065] - result already collected: FutureResult
[17:02:48.065] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.066] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.066] Searching for globals...
[17:02:48.068] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:02:48.068] Searching for globals ... DONE
[17:02:48.068] Resolving globals: TRUE
[17:02:48.068] Resolving any globals that are futures ...
[17:02:48.069] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[17:02:48.069] Resolving any globals that are futures ... DONE
[17:02:48.069] 
[17:02:48.069] 
[17:02:48.069] getGlobalsAndPackages() ... DONE
[17:02:48.069] run() for ‘Future’ ...
[17:02:48.070] - state: ‘created’
[17:02:48.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.085] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.086]   - Field: ‘node’
[17:02:48.086]   - Field: ‘label’
[17:02:48.086]   - Field: ‘local’
[17:02:48.086]   - Field: ‘owner’
[17:02:48.086]   - Field: ‘envir’
[17:02:48.086]   - Field: ‘workers’
[17:02:48.086]   - Field: ‘packages’
[17:02:48.086]   - Field: ‘gc’
[17:02:48.086]   - Field: ‘conditions’
[17:02:48.086]   - Field: ‘persistent’
[17:02:48.087]   - Field: ‘expr’
[17:02:48.087]   - Field: ‘uuid’
[17:02:48.087]   - Field: ‘seed’
[17:02:48.087]   - Field: ‘version’
[17:02:48.087]   - Field: ‘result’
[17:02:48.087]   - Field: ‘asynchronous’
[17:02:48.087]   - Field: ‘calls’
[17:02:48.087]   - Field: ‘globals’
[17:02:48.087]   - Field: ‘stdout’
[17:02:48.087]   - Field: ‘earlySignal’
[17:02:48.087]   - Field: ‘lazy’
[17:02:48.088]   - Field: ‘state’
[17:02:48.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.088] - Launch lazy future ...
[17:02:48.088] Packages needed by the future expression (n = 0): <none>
[17:02:48.088] Packages needed by future strategies (n = 0): <none>
[17:02:48.089] {
[17:02:48.089]     {
[17:02:48.089]         {
[17:02:48.089]             ...future.startTime <- base::Sys.time()
[17:02:48.089]             {
[17:02:48.089]                 {
[17:02:48.089]                   {
[17:02:48.089]                     {
[17:02:48.089]                       base::local({
[17:02:48.089]                         has_future <- base::requireNamespace("future", 
[17:02:48.089]                           quietly = TRUE)
[17:02:48.089]                         if (has_future) {
[17:02:48.089]                           ns <- base::getNamespace("future")
[17:02:48.089]                           version <- ns[[".package"]][["version"]]
[17:02:48.089]                           if (is.null(version)) 
[17:02:48.089]                             version <- utils::packageVersion("future")
[17:02:48.089]                         }
[17:02:48.089]                         else {
[17:02:48.089]                           version <- NULL
[17:02:48.089]                         }
[17:02:48.089]                         if (!has_future || version < "1.8.0") {
[17:02:48.089]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.089]                             "", base::R.version$version.string), 
[17:02:48.089]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.089]                               "release", "version")], collapse = " "), 
[17:02:48.089]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.089]                             info)
[17:02:48.089]                           info <- base::paste(info, collapse = "; ")
[17:02:48.089]                           if (!has_future) {
[17:02:48.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.089]                               info)
[17:02:48.089]                           }
[17:02:48.089]                           else {
[17:02:48.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.089]                               info, version)
[17:02:48.089]                           }
[17:02:48.089]                           base::stop(msg)
[17:02:48.089]                         }
[17:02:48.089]                       })
[17:02:48.089]                     }
[17:02:48.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.089]                     base::options(mc.cores = 1L)
[17:02:48.089]                   }
[17:02:48.089]                   ...future.strategy.old <- future::plan("list")
[17:02:48.089]                   options(future.plan = NULL)
[17:02:48.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.089]                 }
[17:02:48.089]                 ...future.workdir <- getwd()
[17:02:48.089]             }
[17:02:48.089]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.089]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.089]         }
[17:02:48.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.089]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.089]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.089]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.089]             base::names(...future.oldOptions))
[17:02:48.089]     }
[17:02:48.089]     if (FALSE) {
[17:02:48.089]     }
[17:02:48.089]     else {
[17:02:48.089]         if (TRUE) {
[17:02:48.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.089]                 open = "w")
[17:02:48.089]         }
[17:02:48.089]         else {
[17:02:48.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.089]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.089]         }
[17:02:48.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.089]             base::sink(type = "output", split = FALSE)
[17:02:48.089]             base::close(...future.stdout)
[17:02:48.089]         }, add = TRUE)
[17:02:48.089]     }
[17:02:48.089]     ...future.frame <- base::sys.nframe()
[17:02:48.089]     ...future.conditions <- base::list()
[17:02:48.089]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.089]     if (FALSE) {
[17:02:48.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.089]     }
[17:02:48.089]     ...future.result <- base::tryCatch({
[17:02:48.089]         base::withCallingHandlers({
[17:02:48.089]             ...future.value <- base::withVisible(base::local({
[17:02:48.089]                 ...future.makeSendCondition <- base::local({
[17:02:48.089]                   sendCondition <- NULL
[17:02:48.089]                   function(frame = 1L) {
[17:02:48.089]                     if (is.function(sendCondition)) 
[17:02:48.089]                       return(sendCondition)
[17:02:48.089]                     ns <- getNamespace("parallel")
[17:02:48.089]                     if (exists("sendData", mode = "function", 
[17:02:48.089]                       envir = ns)) {
[17:02:48.089]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.089]                         envir = ns)
[17:02:48.089]                       envir <- sys.frame(frame)
[17:02:48.089]                       master <- NULL
[17:02:48.089]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.089]                         !identical(envir, emptyenv())) {
[17:02:48.089]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.089]                           inherits = FALSE)) {
[17:02:48.089]                           master <- get("master", mode = "list", 
[17:02:48.089]                             envir = envir, inherits = FALSE)
[17:02:48.089]                           if (inherits(master, c("SOCKnode", 
[17:02:48.089]                             "SOCK0node"))) {
[17:02:48.089]                             sendCondition <<- function(cond) {
[17:02:48.089]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.089]                                 success = TRUE)
[17:02:48.089]                               parallel_sendData(master, data)
[17:02:48.089]                             }
[17:02:48.089]                             return(sendCondition)
[17:02:48.089]                           }
[17:02:48.089]                         }
[17:02:48.089]                         frame <- frame + 1L
[17:02:48.089]                         envir <- sys.frame(frame)
[17:02:48.089]                       }
[17:02:48.089]                     }
[17:02:48.089]                     sendCondition <<- function(cond) NULL
[17:02:48.089]                   }
[17:02:48.089]                 })
[17:02:48.089]                 withCallingHandlers({
[17:02:48.089]                   {
[17:02:48.089]                     x <- list(b = 2)
[17:02:48.089]                     x$a <- 1
[17:02:48.089]                     x
[17:02:48.089]                   }
[17:02:48.089]                 }, immediateCondition = function(cond) {
[17:02:48.089]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.089]                   sendCondition(cond)
[17:02:48.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.089]                   {
[17:02:48.089]                     inherits <- base::inherits
[17:02:48.089]                     invokeRestart <- base::invokeRestart
[17:02:48.089]                     is.null <- base::is.null
[17:02:48.089]                     muffled <- FALSE
[17:02:48.089]                     if (inherits(cond, "message")) {
[17:02:48.089]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.089]                       if (muffled) 
[17:02:48.089]                         invokeRestart("muffleMessage")
[17:02:48.089]                     }
[17:02:48.089]                     else if (inherits(cond, "warning")) {
[17:02:48.089]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.089]                       if (muffled) 
[17:02:48.089]                         invokeRestart("muffleWarning")
[17:02:48.089]                     }
[17:02:48.089]                     else if (inherits(cond, "condition")) {
[17:02:48.089]                       if (!is.null(pattern)) {
[17:02:48.089]                         computeRestarts <- base::computeRestarts
[17:02:48.089]                         grepl <- base::grepl
[17:02:48.089]                         restarts <- computeRestarts(cond)
[17:02:48.089]                         for (restart in restarts) {
[17:02:48.089]                           name <- restart$name
[17:02:48.089]                           if (is.null(name)) 
[17:02:48.089]                             next
[17:02:48.089]                           if (!grepl(pattern, name)) 
[17:02:48.089]                             next
[17:02:48.089]                           invokeRestart(restart)
[17:02:48.089]                           muffled <- TRUE
[17:02:48.089]                           break
[17:02:48.089]                         }
[17:02:48.089]                       }
[17:02:48.089]                     }
[17:02:48.089]                     invisible(muffled)
[17:02:48.089]                   }
[17:02:48.089]                   muffleCondition(cond)
[17:02:48.089]                 })
[17:02:48.089]             }))
[17:02:48.089]             future::FutureResult(value = ...future.value$value, 
[17:02:48.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.089]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.089]                     ...future.globalenv.names))
[17:02:48.089]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.089]         }, condition = base::local({
[17:02:48.089]             c <- base::c
[17:02:48.089]             inherits <- base::inherits
[17:02:48.089]             invokeRestart <- base::invokeRestart
[17:02:48.089]             length <- base::length
[17:02:48.089]             list <- base::list
[17:02:48.089]             seq.int <- base::seq.int
[17:02:48.089]             signalCondition <- base::signalCondition
[17:02:48.089]             sys.calls <- base::sys.calls
[17:02:48.089]             `[[` <- base::`[[`
[17:02:48.089]             `+` <- base::`+`
[17:02:48.089]             `<<-` <- base::`<<-`
[17:02:48.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.089]                   3L)]
[17:02:48.089]             }
[17:02:48.089]             function(cond) {
[17:02:48.089]                 is_error <- inherits(cond, "error")
[17:02:48.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.089]                   NULL)
[17:02:48.089]                 if (is_error) {
[17:02:48.089]                   sessionInformation <- function() {
[17:02:48.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.089]                       search = base::search(), system = base::Sys.info())
[17:02:48.089]                   }
[17:02:48.089]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.089]                     cond$call), session = sessionInformation(), 
[17:02:48.089]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.089]                   signalCondition(cond)
[17:02:48.089]                 }
[17:02:48.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.089]                 "immediateCondition"))) {
[17:02:48.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.089]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.089]                   if (TRUE && !signal) {
[17:02:48.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.089]                     {
[17:02:48.089]                       inherits <- base::inherits
[17:02:48.089]                       invokeRestart <- base::invokeRestart
[17:02:48.089]                       is.null <- base::is.null
[17:02:48.089]                       muffled <- FALSE
[17:02:48.089]                       if (inherits(cond, "message")) {
[17:02:48.089]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.089]                         if (muffled) 
[17:02:48.089]                           invokeRestart("muffleMessage")
[17:02:48.089]                       }
[17:02:48.089]                       else if (inherits(cond, "warning")) {
[17:02:48.089]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.089]                         if (muffled) 
[17:02:48.089]                           invokeRestart("muffleWarning")
[17:02:48.089]                       }
[17:02:48.089]                       else if (inherits(cond, "condition")) {
[17:02:48.089]                         if (!is.null(pattern)) {
[17:02:48.089]                           computeRestarts <- base::computeRestarts
[17:02:48.089]                           grepl <- base::grepl
[17:02:48.089]                           restarts <- computeRestarts(cond)
[17:02:48.089]                           for (restart in restarts) {
[17:02:48.089]                             name <- restart$name
[17:02:48.089]                             if (is.null(name)) 
[17:02:48.089]                               next
[17:02:48.089]                             if (!grepl(pattern, name)) 
[17:02:48.089]                               next
[17:02:48.089]                             invokeRestart(restart)
[17:02:48.089]                             muffled <- TRUE
[17:02:48.089]                             break
[17:02:48.089]                           }
[17:02:48.089]                         }
[17:02:48.089]                       }
[17:02:48.089]                       invisible(muffled)
[17:02:48.089]                     }
[17:02:48.089]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.089]                   }
[17:02:48.089]                 }
[17:02:48.089]                 else {
[17:02:48.089]                   if (TRUE) {
[17:02:48.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.089]                     {
[17:02:48.089]                       inherits <- base::inherits
[17:02:48.089]                       invokeRestart <- base::invokeRestart
[17:02:48.089]                       is.null <- base::is.null
[17:02:48.089]                       muffled <- FALSE
[17:02:48.089]                       if (inherits(cond, "message")) {
[17:02:48.089]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.089]                         if (muffled) 
[17:02:48.089]                           invokeRestart("muffleMessage")
[17:02:48.089]                       }
[17:02:48.089]                       else if (inherits(cond, "warning")) {
[17:02:48.089]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.089]                         if (muffled) 
[17:02:48.089]                           invokeRestart("muffleWarning")
[17:02:48.089]                       }
[17:02:48.089]                       else if (inherits(cond, "condition")) {
[17:02:48.089]                         if (!is.null(pattern)) {
[17:02:48.089]                           computeRestarts <- base::computeRestarts
[17:02:48.089]                           grepl <- base::grepl
[17:02:48.089]                           restarts <- computeRestarts(cond)
[17:02:48.089]                           for (restart in restarts) {
[17:02:48.089]                             name <- restart$name
[17:02:48.089]                             if (is.null(name)) 
[17:02:48.089]                               next
[17:02:48.089]                             if (!grepl(pattern, name)) 
[17:02:48.089]                               next
[17:02:48.089]                             invokeRestart(restart)
[17:02:48.089]                             muffled <- TRUE
[17:02:48.089]                             break
[17:02:48.089]                           }
[17:02:48.089]                         }
[17:02:48.089]                       }
[17:02:48.089]                       invisible(muffled)
[17:02:48.089]                     }
[17:02:48.089]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.089]                   }
[17:02:48.089]                 }
[17:02:48.089]             }
[17:02:48.089]         }))
[17:02:48.089]     }, error = function(ex) {
[17:02:48.089]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.089]                 ...future.rng), started = ...future.startTime, 
[17:02:48.089]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.089]             version = "1.8"), class = "FutureResult")
[17:02:48.089]     }, finally = {
[17:02:48.089]         if (!identical(...future.workdir, getwd())) 
[17:02:48.089]             setwd(...future.workdir)
[17:02:48.089]         {
[17:02:48.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.089]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.089]             }
[17:02:48.089]             base::options(...future.oldOptions)
[17:02:48.089]             if (.Platform$OS.type == "windows") {
[17:02:48.089]                 old_names <- names(...future.oldEnvVars)
[17:02:48.089]                 envs <- base::Sys.getenv()
[17:02:48.089]                 names <- names(envs)
[17:02:48.089]                 common <- intersect(names, old_names)
[17:02:48.089]                 added <- setdiff(names, old_names)
[17:02:48.089]                 removed <- setdiff(old_names, names)
[17:02:48.089]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.089]                   envs[common]]
[17:02:48.089]                 NAMES <- toupper(changed)
[17:02:48.089]                 args <- list()
[17:02:48.089]                 for (kk in seq_along(NAMES)) {
[17:02:48.089]                   name <- changed[[kk]]
[17:02:48.089]                   NAME <- NAMES[[kk]]
[17:02:48.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.089]                     next
[17:02:48.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.089]                 }
[17:02:48.089]                 NAMES <- toupper(added)
[17:02:48.089]                 for (kk in seq_along(NAMES)) {
[17:02:48.089]                   name <- added[[kk]]
[17:02:48.089]                   NAME <- NAMES[[kk]]
[17:02:48.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.089]                     next
[17:02:48.089]                   args[[name]] <- ""
[17:02:48.089]                 }
[17:02:48.089]                 NAMES <- toupper(removed)
[17:02:48.089]                 for (kk in seq_along(NAMES)) {
[17:02:48.089]                   name <- removed[[kk]]
[17:02:48.089]                   NAME <- NAMES[[kk]]
[17:02:48.089]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.089]                     next
[17:02:48.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.089]                 }
[17:02:48.089]                 if (length(args) > 0) 
[17:02:48.089]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.089]             }
[17:02:48.089]             else {
[17:02:48.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.089]             }
[17:02:48.089]             {
[17:02:48.089]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.089]                   0L) {
[17:02:48.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.089]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.089]                   base::options(opts)
[17:02:48.089]                 }
[17:02:48.089]                 {
[17:02:48.089]                   {
[17:02:48.089]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.089]                     NULL
[17:02:48.089]                   }
[17:02:48.089]                   options(future.plan = NULL)
[17:02:48.089]                   if (is.na(NA_character_)) 
[17:02:48.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.089]                     .init = FALSE)
[17:02:48.089]                 }
[17:02:48.089]             }
[17:02:48.089]         }
[17:02:48.089]     })
[17:02:48.089]     if (TRUE) {
[17:02:48.089]         base::sink(type = "output", split = FALSE)
[17:02:48.089]         if (TRUE) {
[17:02:48.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.089]         }
[17:02:48.089]         else {
[17:02:48.089]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.089]         }
[17:02:48.089]         base::close(...future.stdout)
[17:02:48.089]         ...future.stdout <- NULL
[17:02:48.089]     }
[17:02:48.089]     ...future.result$conditions <- ...future.conditions
[17:02:48.089]     ...future.result$finished <- base::Sys.time()
[17:02:48.089]     ...future.result
[17:02:48.089] }
[17:02:48.092] MultisessionFuture started
[17:02:48.092] - Launch lazy future ... done
[17:02:48.092] run() for ‘MultisessionFuture’ ... done
[17:02:48.092] result() for ClusterFuture ...
[17:02:48.092] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.092] - Validating connection of MultisessionFuture
[17:02:48.093] - received message: FutureResult
[17:02:48.093] - Received FutureResult
[17:02:48.094] - Erased future from FutureRegistry
[17:02:48.094] result() for ClusterFuture ...
[17:02:48.094] - result already collected: FutureResult
[17:02:48.094] result() for ClusterFuture ... done
[17:02:48.094] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.094] result() for ClusterFuture ... done
[17:02:48.094] result() for ClusterFuture ...
[17:02:48.094] - result already collected: FutureResult
[17:02:48.094] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.095] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.095] Searching for globals...
[17:02:48.097] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:48.097] Searching for globals ... DONE
[17:02:48.097] Resolving globals: TRUE
[17:02:48.097] Resolving any globals that are futures ...
[17:02:48.097] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:48.097] Resolving any globals that are futures ... DONE
[17:02:48.098] Resolving futures part of globals (recursively) ...
[17:02:48.098] resolve() on list ...
[17:02:48.098]  recursive: 99
[17:02:48.098]  length: 1
[17:02:48.098]  elements: ‘x’
[17:02:48.098]  length: 0 (resolved future 1)
[17:02:48.098] resolve() on list ... DONE
[17:02:48.098] - globals: [1] ‘x’
[17:02:48.098] Resolving futures part of globals (recursively) ... DONE
[17:02:48.099] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.099] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.099] - globals: [1] ‘x’
[17:02:48.099] 
[17:02:48.099] getGlobalsAndPackages() ... DONE
[17:02:48.100] run() for ‘Future’ ...
[17:02:48.100] - state: ‘created’
[17:02:48.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.114]   - Field: ‘node’
[17:02:48.114]   - Field: ‘label’
[17:02:48.114]   - Field: ‘local’
[17:02:48.114]   - Field: ‘owner’
[17:02:48.114]   - Field: ‘envir’
[17:02:48.114]   - Field: ‘workers’
[17:02:48.114]   - Field: ‘packages’
[17:02:48.114]   - Field: ‘gc’
[17:02:48.114]   - Field: ‘conditions’
[17:02:48.115]   - Field: ‘persistent’
[17:02:48.115]   - Field: ‘expr’
[17:02:48.115]   - Field: ‘uuid’
[17:02:48.115]   - Field: ‘seed’
[17:02:48.115]   - Field: ‘version’
[17:02:48.115]   - Field: ‘result’
[17:02:48.115]   - Field: ‘asynchronous’
[17:02:48.115]   - Field: ‘calls’
[17:02:48.115]   - Field: ‘globals’
[17:02:48.115]   - Field: ‘stdout’
[17:02:48.115]   - Field: ‘earlySignal’
[17:02:48.116]   - Field: ‘lazy’
[17:02:48.116]   - Field: ‘state’
[17:02:48.116] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.116] - Launch lazy future ...
[17:02:48.116] Packages needed by the future expression (n = 0): <none>
[17:02:48.116] Packages needed by future strategies (n = 0): <none>
[17:02:48.117] {
[17:02:48.117]     {
[17:02:48.117]         {
[17:02:48.117]             ...future.startTime <- base::Sys.time()
[17:02:48.117]             {
[17:02:48.117]                 {
[17:02:48.117]                   {
[17:02:48.117]                     {
[17:02:48.117]                       base::local({
[17:02:48.117]                         has_future <- base::requireNamespace("future", 
[17:02:48.117]                           quietly = TRUE)
[17:02:48.117]                         if (has_future) {
[17:02:48.117]                           ns <- base::getNamespace("future")
[17:02:48.117]                           version <- ns[[".package"]][["version"]]
[17:02:48.117]                           if (is.null(version)) 
[17:02:48.117]                             version <- utils::packageVersion("future")
[17:02:48.117]                         }
[17:02:48.117]                         else {
[17:02:48.117]                           version <- NULL
[17:02:48.117]                         }
[17:02:48.117]                         if (!has_future || version < "1.8.0") {
[17:02:48.117]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.117]                             "", base::R.version$version.string), 
[17:02:48.117]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.117]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.117]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.117]                               "release", "version")], collapse = " "), 
[17:02:48.117]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.117]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.117]                             info)
[17:02:48.117]                           info <- base::paste(info, collapse = "; ")
[17:02:48.117]                           if (!has_future) {
[17:02:48.117]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.117]                               info)
[17:02:48.117]                           }
[17:02:48.117]                           else {
[17:02:48.117]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.117]                               info, version)
[17:02:48.117]                           }
[17:02:48.117]                           base::stop(msg)
[17:02:48.117]                         }
[17:02:48.117]                       })
[17:02:48.117]                     }
[17:02:48.117]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.117]                     base::options(mc.cores = 1L)
[17:02:48.117]                   }
[17:02:48.117]                   ...future.strategy.old <- future::plan("list")
[17:02:48.117]                   options(future.plan = NULL)
[17:02:48.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.117]                 }
[17:02:48.117]                 ...future.workdir <- getwd()
[17:02:48.117]             }
[17:02:48.117]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.117]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.117]         }
[17:02:48.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.117]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.117]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.117]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.117]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.117]             base::names(...future.oldOptions))
[17:02:48.117]     }
[17:02:48.117]     if (FALSE) {
[17:02:48.117]     }
[17:02:48.117]     else {
[17:02:48.117]         if (TRUE) {
[17:02:48.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.117]                 open = "w")
[17:02:48.117]         }
[17:02:48.117]         else {
[17:02:48.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.117]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.117]         }
[17:02:48.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.117]             base::sink(type = "output", split = FALSE)
[17:02:48.117]             base::close(...future.stdout)
[17:02:48.117]         }, add = TRUE)
[17:02:48.117]     }
[17:02:48.117]     ...future.frame <- base::sys.nframe()
[17:02:48.117]     ...future.conditions <- base::list()
[17:02:48.117]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.117]     if (FALSE) {
[17:02:48.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.117]     }
[17:02:48.117]     ...future.result <- base::tryCatch({
[17:02:48.117]         base::withCallingHandlers({
[17:02:48.117]             ...future.value <- base::withVisible(base::local({
[17:02:48.117]                 ...future.makeSendCondition <- base::local({
[17:02:48.117]                   sendCondition <- NULL
[17:02:48.117]                   function(frame = 1L) {
[17:02:48.117]                     if (is.function(sendCondition)) 
[17:02:48.117]                       return(sendCondition)
[17:02:48.117]                     ns <- getNamespace("parallel")
[17:02:48.117]                     if (exists("sendData", mode = "function", 
[17:02:48.117]                       envir = ns)) {
[17:02:48.117]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.117]                         envir = ns)
[17:02:48.117]                       envir <- sys.frame(frame)
[17:02:48.117]                       master <- NULL
[17:02:48.117]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.117]                         !identical(envir, emptyenv())) {
[17:02:48.117]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.117]                           inherits = FALSE)) {
[17:02:48.117]                           master <- get("master", mode = "list", 
[17:02:48.117]                             envir = envir, inherits = FALSE)
[17:02:48.117]                           if (inherits(master, c("SOCKnode", 
[17:02:48.117]                             "SOCK0node"))) {
[17:02:48.117]                             sendCondition <<- function(cond) {
[17:02:48.117]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.117]                                 success = TRUE)
[17:02:48.117]                               parallel_sendData(master, data)
[17:02:48.117]                             }
[17:02:48.117]                             return(sendCondition)
[17:02:48.117]                           }
[17:02:48.117]                         }
[17:02:48.117]                         frame <- frame + 1L
[17:02:48.117]                         envir <- sys.frame(frame)
[17:02:48.117]                       }
[17:02:48.117]                     }
[17:02:48.117]                     sendCondition <<- function(cond) NULL
[17:02:48.117]                   }
[17:02:48.117]                 })
[17:02:48.117]                 withCallingHandlers({
[17:02:48.117]                   {
[17:02:48.117]                     x[["a"]] <- 1
[17:02:48.117]                     x
[17:02:48.117]                   }
[17:02:48.117]                 }, immediateCondition = function(cond) {
[17:02:48.117]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.117]                   sendCondition(cond)
[17:02:48.117]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.117]                   {
[17:02:48.117]                     inherits <- base::inherits
[17:02:48.117]                     invokeRestart <- base::invokeRestart
[17:02:48.117]                     is.null <- base::is.null
[17:02:48.117]                     muffled <- FALSE
[17:02:48.117]                     if (inherits(cond, "message")) {
[17:02:48.117]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.117]                       if (muffled) 
[17:02:48.117]                         invokeRestart("muffleMessage")
[17:02:48.117]                     }
[17:02:48.117]                     else if (inherits(cond, "warning")) {
[17:02:48.117]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.117]                       if (muffled) 
[17:02:48.117]                         invokeRestart("muffleWarning")
[17:02:48.117]                     }
[17:02:48.117]                     else if (inherits(cond, "condition")) {
[17:02:48.117]                       if (!is.null(pattern)) {
[17:02:48.117]                         computeRestarts <- base::computeRestarts
[17:02:48.117]                         grepl <- base::grepl
[17:02:48.117]                         restarts <- computeRestarts(cond)
[17:02:48.117]                         for (restart in restarts) {
[17:02:48.117]                           name <- restart$name
[17:02:48.117]                           if (is.null(name)) 
[17:02:48.117]                             next
[17:02:48.117]                           if (!grepl(pattern, name)) 
[17:02:48.117]                             next
[17:02:48.117]                           invokeRestart(restart)
[17:02:48.117]                           muffled <- TRUE
[17:02:48.117]                           break
[17:02:48.117]                         }
[17:02:48.117]                       }
[17:02:48.117]                     }
[17:02:48.117]                     invisible(muffled)
[17:02:48.117]                   }
[17:02:48.117]                   muffleCondition(cond)
[17:02:48.117]                 })
[17:02:48.117]             }))
[17:02:48.117]             future::FutureResult(value = ...future.value$value, 
[17:02:48.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.117]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.117]                     ...future.globalenv.names))
[17:02:48.117]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.117]         }, condition = base::local({
[17:02:48.117]             c <- base::c
[17:02:48.117]             inherits <- base::inherits
[17:02:48.117]             invokeRestart <- base::invokeRestart
[17:02:48.117]             length <- base::length
[17:02:48.117]             list <- base::list
[17:02:48.117]             seq.int <- base::seq.int
[17:02:48.117]             signalCondition <- base::signalCondition
[17:02:48.117]             sys.calls <- base::sys.calls
[17:02:48.117]             `[[` <- base::`[[`
[17:02:48.117]             `+` <- base::`+`
[17:02:48.117]             `<<-` <- base::`<<-`
[17:02:48.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.117]                   3L)]
[17:02:48.117]             }
[17:02:48.117]             function(cond) {
[17:02:48.117]                 is_error <- inherits(cond, "error")
[17:02:48.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.117]                   NULL)
[17:02:48.117]                 if (is_error) {
[17:02:48.117]                   sessionInformation <- function() {
[17:02:48.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.117]                       search = base::search(), system = base::Sys.info())
[17:02:48.117]                   }
[17:02:48.117]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.117]                     cond$call), session = sessionInformation(), 
[17:02:48.117]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.117]                   signalCondition(cond)
[17:02:48.117]                 }
[17:02:48.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.117]                 "immediateCondition"))) {
[17:02:48.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.117]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.117]                   if (TRUE && !signal) {
[17:02:48.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.117]                     {
[17:02:48.117]                       inherits <- base::inherits
[17:02:48.117]                       invokeRestart <- base::invokeRestart
[17:02:48.117]                       is.null <- base::is.null
[17:02:48.117]                       muffled <- FALSE
[17:02:48.117]                       if (inherits(cond, "message")) {
[17:02:48.117]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.117]                         if (muffled) 
[17:02:48.117]                           invokeRestart("muffleMessage")
[17:02:48.117]                       }
[17:02:48.117]                       else if (inherits(cond, "warning")) {
[17:02:48.117]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.117]                         if (muffled) 
[17:02:48.117]                           invokeRestart("muffleWarning")
[17:02:48.117]                       }
[17:02:48.117]                       else if (inherits(cond, "condition")) {
[17:02:48.117]                         if (!is.null(pattern)) {
[17:02:48.117]                           computeRestarts <- base::computeRestarts
[17:02:48.117]                           grepl <- base::grepl
[17:02:48.117]                           restarts <- computeRestarts(cond)
[17:02:48.117]                           for (restart in restarts) {
[17:02:48.117]                             name <- restart$name
[17:02:48.117]                             if (is.null(name)) 
[17:02:48.117]                               next
[17:02:48.117]                             if (!grepl(pattern, name)) 
[17:02:48.117]                               next
[17:02:48.117]                             invokeRestart(restart)
[17:02:48.117]                             muffled <- TRUE
[17:02:48.117]                             break
[17:02:48.117]                           }
[17:02:48.117]                         }
[17:02:48.117]                       }
[17:02:48.117]                       invisible(muffled)
[17:02:48.117]                     }
[17:02:48.117]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.117]                   }
[17:02:48.117]                 }
[17:02:48.117]                 else {
[17:02:48.117]                   if (TRUE) {
[17:02:48.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.117]                     {
[17:02:48.117]                       inherits <- base::inherits
[17:02:48.117]                       invokeRestart <- base::invokeRestart
[17:02:48.117]                       is.null <- base::is.null
[17:02:48.117]                       muffled <- FALSE
[17:02:48.117]                       if (inherits(cond, "message")) {
[17:02:48.117]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.117]                         if (muffled) 
[17:02:48.117]                           invokeRestart("muffleMessage")
[17:02:48.117]                       }
[17:02:48.117]                       else if (inherits(cond, "warning")) {
[17:02:48.117]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.117]                         if (muffled) 
[17:02:48.117]                           invokeRestart("muffleWarning")
[17:02:48.117]                       }
[17:02:48.117]                       else if (inherits(cond, "condition")) {
[17:02:48.117]                         if (!is.null(pattern)) {
[17:02:48.117]                           computeRestarts <- base::computeRestarts
[17:02:48.117]                           grepl <- base::grepl
[17:02:48.117]                           restarts <- computeRestarts(cond)
[17:02:48.117]                           for (restart in restarts) {
[17:02:48.117]                             name <- restart$name
[17:02:48.117]                             if (is.null(name)) 
[17:02:48.117]                               next
[17:02:48.117]                             if (!grepl(pattern, name)) 
[17:02:48.117]                               next
[17:02:48.117]                             invokeRestart(restart)
[17:02:48.117]                             muffled <- TRUE
[17:02:48.117]                             break
[17:02:48.117]                           }
[17:02:48.117]                         }
[17:02:48.117]                       }
[17:02:48.117]                       invisible(muffled)
[17:02:48.117]                     }
[17:02:48.117]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.117]                   }
[17:02:48.117]                 }
[17:02:48.117]             }
[17:02:48.117]         }))
[17:02:48.117]     }, error = function(ex) {
[17:02:48.117]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.117]                 ...future.rng), started = ...future.startTime, 
[17:02:48.117]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.117]             version = "1.8"), class = "FutureResult")
[17:02:48.117]     }, finally = {
[17:02:48.117]         if (!identical(...future.workdir, getwd())) 
[17:02:48.117]             setwd(...future.workdir)
[17:02:48.117]         {
[17:02:48.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.117]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.117]             }
[17:02:48.117]             base::options(...future.oldOptions)
[17:02:48.117]             if (.Platform$OS.type == "windows") {
[17:02:48.117]                 old_names <- names(...future.oldEnvVars)
[17:02:48.117]                 envs <- base::Sys.getenv()
[17:02:48.117]                 names <- names(envs)
[17:02:48.117]                 common <- intersect(names, old_names)
[17:02:48.117]                 added <- setdiff(names, old_names)
[17:02:48.117]                 removed <- setdiff(old_names, names)
[17:02:48.117]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.117]                   envs[common]]
[17:02:48.117]                 NAMES <- toupper(changed)
[17:02:48.117]                 args <- list()
[17:02:48.117]                 for (kk in seq_along(NAMES)) {
[17:02:48.117]                   name <- changed[[kk]]
[17:02:48.117]                   NAME <- NAMES[[kk]]
[17:02:48.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.117]                     next
[17:02:48.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.117]                 }
[17:02:48.117]                 NAMES <- toupper(added)
[17:02:48.117]                 for (kk in seq_along(NAMES)) {
[17:02:48.117]                   name <- added[[kk]]
[17:02:48.117]                   NAME <- NAMES[[kk]]
[17:02:48.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.117]                     next
[17:02:48.117]                   args[[name]] <- ""
[17:02:48.117]                 }
[17:02:48.117]                 NAMES <- toupper(removed)
[17:02:48.117]                 for (kk in seq_along(NAMES)) {
[17:02:48.117]                   name <- removed[[kk]]
[17:02:48.117]                   NAME <- NAMES[[kk]]
[17:02:48.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.117]                     next
[17:02:48.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.117]                 }
[17:02:48.117]                 if (length(args) > 0) 
[17:02:48.117]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.117]             }
[17:02:48.117]             else {
[17:02:48.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.117]             }
[17:02:48.117]             {
[17:02:48.117]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.117]                   0L) {
[17:02:48.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.117]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.117]                   base::options(opts)
[17:02:48.117]                 }
[17:02:48.117]                 {
[17:02:48.117]                   {
[17:02:48.117]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.117]                     NULL
[17:02:48.117]                   }
[17:02:48.117]                   options(future.plan = NULL)
[17:02:48.117]                   if (is.na(NA_character_)) 
[17:02:48.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.117]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.117]                     .init = FALSE)
[17:02:48.117]                 }
[17:02:48.117]             }
[17:02:48.117]         }
[17:02:48.117]     })
[17:02:48.117]     if (TRUE) {
[17:02:48.117]         base::sink(type = "output", split = FALSE)
[17:02:48.117]         if (TRUE) {
[17:02:48.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.117]         }
[17:02:48.117]         else {
[17:02:48.117]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.117]         }
[17:02:48.117]         base::close(...future.stdout)
[17:02:48.117]         ...future.stdout <- NULL
[17:02:48.117]     }
[17:02:48.117]     ...future.result$conditions <- ...future.conditions
[17:02:48.117]     ...future.result$finished <- base::Sys.time()
[17:02:48.117]     ...future.result
[17:02:48.117] }
[17:02:48.119] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.120] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.120] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.120] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.121] MultisessionFuture started
[17:02:48.121] - Launch lazy future ... done
[17:02:48.121] run() for ‘MultisessionFuture’ ... done
[17:02:48.121] result() for ClusterFuture ...
[17:02:48.121] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.121] - Validating connection of MultisessionFuture
[17:02:48.122] - received message: FutureResult
[17:02:48.122] - Received FutureResult
[17:02:48.122] - Erased future from FutureRegistry
[17:02:48.123] result() for ClusterFuture ...
[17:02:48.123] - result already collected: FutureResult
[17:02:48.123] result() for ClusterFuture ... done
[17:02:48.123] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.123] result() for ClusterFuture ... done
[17:02:48.123] result() for ClusterFuture ...
[17:02:48.123] - result already collected: FutureResult
[17:02:48.123] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.123] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.124] Searching for globals...
[17:02:48.126] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:48.126] Searching for globals ... DONE
[17:02:48.126] Resolving globals: TRUE
[17:02:48.126] Resolving any globals that are futures ...
[17:02:48.126] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:48.126] Resolving any globals that are futures ... DONE
[17:02:48.126] Resolving futures part of globals (recursively) ...
[17:02:48.127] resolve() on list ...
[17:02:48.127]  recursive: 99
[17:02:48.127]  length: 1
[17:02:48.127]  elements: ‘x’
[17:02:48.127]  length: 0 (resolved future 1)
[17:02:48.127] resolve() on list ... DONE
[17:02:48.127] - globals: [1] ‘x’
[17:02:48.127] Resolving futures part of globals (recursively) ... DONE
[17:02:48.128] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.128] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.128] - globals: [1] ‘x’
[17:02:48.128] 
[17:02:48.128] getGlobalsAndPackages() ... DONE
[17:02:48.128] run() for ‘Future’ ...
[17:02:48.129] - state: ‘created’
[17:02:48.129] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.143] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.143]   - Field: ‘node’
[17:02:48.143]   - Field: ‘label’
[17:02:48.143]   - Field: ‘local’
[17:02:48.144]   - Field: ‘owner’
[17:02:48.144]   - Field: ‘envir’
[17:02:48.144]   - Field: ‘workers’
[17:02:48.144]   - Field: ‘packages’
[17:02:48.144]   - Field: ‘gc’
[17:02:48.144]   - Field: ‘conditions’
[17:02:48.144]   - Field: ‘persistent’
[17:02:48.144]   - Field: ‘expr’
[17:02:48.144]   - Field: ‘uuid’
[17:02:48.144]   - Field: ‘seed’
[17:02:48.144]   - Field: ‘version’
[17:02:48.145]   - Field: ‘result’
[17:02:48.145]   - Field: ‘asynchronous’
[17:02:48.145]   - Field: ‘calls’
[17:02:48.145]   - Field: ‘globals’
[17:02:48.145]   - Field: ‘stdout’
[17:02:48.145]   - Field: ‘earlySignal’
[17:02:48.145]   - Field: ‘lazy’
[17:02:48.145]   - Field: ‘state’
[17:02:48.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.145] - Launch lazy future ...
[17:02:48.146] Packages needed by the future expression (n = 0): <none>
[17:02:48.146] Packages needed by future strategies (n = 0): <none>
[17:02:48.146] {
[17:02:48.146]     {
[17:02:48.146]         {
[17:02:48.146]             ...future.startTime <- base::Sys.time()
[17:02:48.146]             {
[17:02:48.146]                 {
[17:02:48.146]                   {
[17:02:48.146]                     {
[17:02:48.146]                       base::local({
[17:02:48.146]                         has_future <- base::requireNamespace("future", 
[17:02:48.146]                           quietly = TRUE)
[17:02:48.146]                         if (has_future) {
[17:02:48.146]                           ns <- base::getNamespace("future")
[17:02:48.146]                           version <- ns[[".package"]][["version"]]
[17:02:48.146]                           if (is.null(version)) 
[17:02:48.146]                             version <- utils::packageVersion("future")
[17:02:48.146]                         }
[17:02:48.146]                         else {
[17:02:48.146]                           version <- NULL
[17:02:48.146]                         }
[17:02:48.146]                         if (!has_future || version < "1.8.0") {
[17:02:48.146]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.146]                             "", base::R.version$version.string), 
[17:02:48.146]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.146]                               "release", "version")], collapse = " "), 
[17:02:48.146]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.146]                             info)
[17:02:48.146]                           info <- base::paste(info, collapse = "; ")
[17:02:48.146]                           if (!has_future) {
[17:02:48.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.146]                               info)
[17:02:48.146]                           }
[17:02:48.146]                           else {
[17:02:48.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.146]                               info, version)
[17:02:48.146]                           }
[17:02:48.146]                           base::stop(msg)
[17:02:48.146]                         }
[17:02:48.146]                       })
[17:02:48.146]                     }
[17:02:48.146]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.146]                     base::options(mc.cores = 1L)
[17:02:48.146]                   }
[17:02:48.146]                   ...future.strategy.old <- future::plan("list")
[17:02:48.146]                   options(future.plan = NULL)
[17:02:48.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.146]                 }
[17:02:48.146]                 ...future.workdir <- getwd()
[17:02:48.146]             }
[17:02:48.146]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.146]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.146]         }
[17:02:48.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.146]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.146]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.146]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.146]             base::names(...future.oldOptions))
[17:02:48.146]     }
[17:02:48.146]     if (FALSE) {
[17:02:48.146]     }
[17:02:48.146]     else {
[17:02:48.146]         if (TRUE) {
[17:02:48.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.146]                 open = "w")
[17:02:48.146]         }
[17:02:48.146]         else {
[17:02:48.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.146]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.146]         }
[17:02:48.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.146]             base::sink(type = "output", split = FALSE)
[17:02:48.146]             base::close(...future.stdout)
[17:02:48.146]         }, add = TRUE)
[17:02:48.146]     }
[17:02:48.146]     ...future.frame <- base::sys.nframe()
[17:02:48.146]     ...future.conditions <- base::list()
[17:02:48.146]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.146]     if (FALSE) {
[17:02:48.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.146]     }
[17:02:48.146]     ...future.result <- base::tryCatch({
[17:02:48.146]         base::withCallingHandlers({
[17:02:48.146]             ...future.value <- base::withVisible(base::local({
[17:02:48.146]                 ...future.makeSendCondition <- base::local({
[17:02:48.146]                   sendCondition <- NULL
[17:02:48.146]                   function(frame = 1L) {
[17:02:48.146]                     if (is.function(sendCondition)) 
[17:02:48.146]                       return(sendCondition)
[17:02:48.146]                     ns <- getNamespace("parallel")
[17:02:48.146]                     if (exists("sendData", mode = "function", 
[17:02:48.146]                       envir = ns)) {
[17:02:48.146]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.146]                         envir = ns)
[17:02:48.146]                       envir <- sys.frame(frame)
[17:02:48.146]                       master <- NULL
[17:02:48.146]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.146]                         !identical(envir, emptyenv())) {
[17:02:48.146]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.146]                           inherits = FALSE)) {
[17:02:48.146]                           master <- get("master", mode = "list", 
[17:02:48.146]                             envir = envir, inherits = FALSE)
[17:02:48.146]                           if (inherits(master, c("SOCKnode", 
[17:02:48.146]                             "SOCK0node"))) {
[17:02:48.146]                             sendCondition <<- function(cond) {
[17:02:48.146]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.146]                                 success = TRUE)
[17:02:48.146]                               parallel_sendData(master, data)
[17:02:48.146]                             }
[17:02:48.146]                             return(sendCondition)
[17:02:48.146]                           }
[17:02:48.146]                         }
[17:02:48.146]                         frame <- frame + 1L
[17:02:48.146]                         envir <- sys.frame(frame)
[17:02:48.146]                       }
[17:02:48.146]                     }
[17:02:48.146]                     sendCondition <<- function(cond) NULL
[17:02:48.146]                   }
[17:02:48.146]                 })
[17:02:48.146]                 withCallingHandlers({
[17:02:48.146]                   {
[17:02:48.146]                     x[["a"]] <- 1
[17:02:48.146]                     x
[17:02:48.146]                   }
[17:02:48.146]                 }, immediateCondition = function(cond) {
[17:02:48.146]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.146]                   sendCondition(cond)
[17:02:48.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.146]                   {
[17:02:48.146]                     inherits <- base::inherits
[17:02:48.146]                     invokeRestart <- base::invokeRestart
[17:02:48.146]                     is.null <- base::is.null
[17:02:48.146]                     muffled <- FALSE
[17:02:48.146]                     if (inherits(cond, "message")) {
[17:02:48.146]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.146]                       if (muffled) 
[17:02:48.146]                         invokeRestart("muffleMessage")
[17:02:48.146]                     }
[17:02:48.146]                     else if (inherits(cond, "warning")) {
[17:02:48.146]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.146]                       if (muffled) 
[17:02:48.146]                         invokeRestart("muffleWarning")
[17:02:48.146]                     }
[17:02:48.146]                     else if (inherits(cond, "condition")) {
[17:02:48.146]                       if (!is.null(pattern)) {
[17:02:48.146]                         computeRestarts <- base::computeRestarts
[17:02:48.146]                         grepl <- base::grepl
[17:02:48.146]                         restarts <- computeRestarts(cond)
[17:02:48.146]                         for (restart in restarts) {
[17:02:48.146]                           name <- restart$name
[17:02:48.146]                           if (is.null(name)) 
[17:02:48.146]                             next
[17:02:48.146]                           if (!grepl(pattern, name)) 
[17:02:48.146]                             next
[17:02:48.146]                           invokeRestart(restart)
[17:02:48.146]                           muffled <- TRUE
[17:02:48.146]                           break
[17:02:48.146]                         }
[17:02:48.146]                       }
[17:02:48.146]                     }
[17:02:48.146]                     invisible(muffled)
[17:02:48.146]                   }
[17:02:48.146]                   muffleCondition(cond)
[17:02:48.146]                 })
[17:02:48.146]             }))
[17:02:48.146]             future::FutureResult(value = ...future.value$value, 
[17:02:48.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.146]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.146]                     ...future.globalenv.names))
[17:02:48.146]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.146]         }, condition = base::local({
[17:02:48.146]             c <- base::c
[17:02:48.146]             inherits <- base::inherits
[17:02:48.146]             invokeRestart <- base::invokeRestart
[17:02:48.146]             length <- base::length
[17:02:48.146]             list <- base::list
[17:02:48.146]             seq.int <- base::seq.int
[17:02:48.146]             signalCondition <- base::signalCondition
[17:02:48.146]             sys.calls <- base::sys.calls
[17:02:48.146]             `[[` <- base::`[[`
[17:02:48.146]             `+` <- base::`+`
[17:02:48.146]             `<<-` <- base::`<<-`
[17:02:48.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.146]                   3L)]
[17:02:48.146]             }
[17:02:48.146]             function(cond) {
[17:02:48.146]                 is_error <- inherits(cond, "error")
[17:02:48.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.146]                   NULL)
[17:02:48.146]                 if (is_error) {
[17:02:48.146]                   sessionInformation <- function() {
[17:02:48.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.146]                       search = base::search(), system = base::Sys.info())
[17:02:48.146]                   }
[17:02:48.146]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.146]                     cond$call), session = sessionInformation(), 
[17:02:48.146]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.146]                   signalCondition(cond)
[17:02:48.146]                 }
[17:02:48.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.146]                 "immediateCondition"))) {
[17:02:48.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.146]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.146]                   if (TRUE && !signal) {
[17:02:48.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.146]                     {
[17:02:48.146]                       inherits <- base::inherits
[17:02:48.146]                       invokeRestart <- base::invokeRestart
[17:02:48.146]                       is.null <- base::is.null
[17:02:48.146]                       muffled <- FALSE
[17:02:48.146]                       if (inherits(cond, "message")) {
[17:02:48.146]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.146]                         if (muffled) 
[17:02:48.146]                           invokeRestart("muffleMessage")
[17:02:48.146]                       }
[17:02:48.146]                       else if (inherits(cond, "warning")) {
[17:02:48.146]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.146]                         if (muffled) 
[17:02:48.146]                           invokeRestart("muffleWarning")
[17:02:48.146]                       }
[17:02:48.146]                       else if (inherits(cond, "condition")) {
[17:02:48.146]                         if (!is.null(pattern)) {
[17:02:48.146]                           computeRestarts <- base::computeRestarts
[17:02:48.146]                           grepl <- base::grepl
[17:02:48.146]                           restarts <- computeRestarts(cond)
[17:02:48.146]                           for (restart in restarts) {
[17:02:48.146]                             name <- restart$name
[17:02:48.146]                             if (is.null(name)) 
[17:02:48.146]                               next
[17:02:48.146]                             if (!grepl(pattern, name)) 
[17:02:48.146]                               next
[17:02:48.146]                             invokeRestart(restart)
[17:02:48.146]                             muffled <- TRUE
[17:02:48.146]                             break
[17:02:48.146]                           }
[17:02:48.146]                         }
[17:02:48.146]                       }
[17:02:48.146]                       invisible(muffled)
[17:02:48.146]                     }
[17:02:48.146]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.146]                   }
[17:02:48.146]                 }
[17:02:48.146]                 else {
[17:02:48.146]                   if (TRUE) {
[17:02:48.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.146]                     {
[17:02:48.146]                       inherits <- base::inherits
[17:02:48.146]                       invokeRestart <- base::invokeRestart
[17:02:48.146]                       is.null <- base::is.null
[17:02:48.146]                       muffled <- FALSE
[17:02:48.146]                       if (inherits(cond, "message")) {
[17:02:48.146]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.146]                         if (muffled) 
[17:02:48.146]                           invokeRestart("muffleMessage")
[17:02:48.146]                       }
[17:02:48.146]                       else if (inherits(cond, "warning")) {
[17:02:48.146]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.146]                         if (muffled) 
[17:02:48.146]                           invokeRestart("muffleWarning")
[17:02:48.146]                       }
[17:02:48.146]                       else if (inherits(cond, "condition")) {
[17:02:48.146]                         if (!is.null(pattern)) {
[17:02:48.146]                           computeRestarts <- base::computeRestarts
[17:02:48.146]                           grepl <- base::grepl
[17:02:48.146]                           restarts <- computeRestarts(cond)
[17:02:48.146]                           for (restart in restarts) {
[17:02:48.146]                             name <- restart$name
[17:02:48.146]                             if (is.null(name)) 
[17:02:48.146]                               next
[17:02:48.146]                             if (!grepl(pattern, name)) 
[17:02:48.146]                               next
[17:02:48.146]                             invokeRestart(restart)
[17:02:48.146]                             muffled <- TRUE
[17:02:48.146]                             break
[17:02:48.146]                           }
[17:02:48.146]                         }
[17:02:48.146]                       }
[17:02:48.146]                       invisible(muffled)
[17:02:48.146]                     }
[17:02:48.146]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.146]                   }
[17:02:48.146]                 }
[17:02:48.146]             }
[17:02:48.146]         }))
[17:02:48.146]     }, error = function(ex) {
[17:02:48.146]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.146]                 ...future.rng), started = ...future.startTime, 
[17:02:48.146]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.146]             version = "1.8"), class = "FutureResult")
[17:02:48.146]     }, finally = {
[17:02:48.146]         if (!identical(...future.workdir, getwd())) 
[17:02:48.146]             setwd(...future.workdir)
[17:02:48.146]         {
[17:02:48.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.146]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.146]             }
[17:02:48.146]             base::options(...future.oldOptions)
[17:02:48.146]             if (.Platform$OS.type == "windows") {
[17:02:48.146]                 old_names <- names(...future.oldEnvVars)
[17:02:48.146]                 envs <- base::Sys.getenv()
[17:02:48.146]                 names <- names(envs)
[17:02:48.146]                 common <- intersect(names, old_names)
[17:02:48.146]                 added <- setdiff(names, old_names)
[17:02:48.146]                 removed <- setdiff(old_names, names)
[17:02:48.146]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.146]                   envs[common]]
[17:02:48.146]                 NAMES <- toupper(changed)
[17:02:48.146]                 args <- list()
[17:02:48.146]                 for (kk in seq_along(NAMES)) {
[17:02:48.146]                   name <- changed[[kk]]
[17:02:48.146]                   NAME <- NAMES[[kk]]
[17:02:48.146]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.146]                     next
[17:02:48.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.146]                 }
[17:02:48.146]                 NAMES <- toupper(added)
[17:02:48.146]                 for (kk in seq_along(NAMES)) {
[17:02:48.146]                   name <- added[[kk]]
[17:02:48.146]                   NAME <- NAMES[[kk]]
[17:02:48.146]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.146]                     next
[17:02:48.146]                   args[[name]] <- ""
[17:02:48.146]                 }
[17:02:48.146]                 NAMES <- toupper(removed)
[17:02:48.146]                 for (kk in seq_along(NAMES)) {
[17:02:48.146]                   name <- removed[[kk]]
[17:02:48.146]                   NAME <- NAMES[[kk]]
[17:02:48.146]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.146]                     next
[17:02:48.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.146]                 }
[17:02:48.146]                 if (length(args) > 0) 
[17:02:48.146]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.146]             }
[17:02:48.146]             else {
[17:02:48.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.146]             }
[17:02:48.146]             {
[17:02:48.146]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.146]                   0L) {
[17:02:48.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.146]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.146]                   base::options(opts)
[17:02:48.146]                 }
[17:02:48.146]                 {
[17:02:48.146]                   {
[17:02:48.146]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.146]                     NULL
[17:02:48.146]                   }
[17:02:48.146]                   options(future.plan = NULL)
[17:02:48.146]                   if (is.na(NA_character_)) 
[17:02:48.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.146]                     .init = FALSE)
[17:02:48.146]                 }
[17:02:48.146]             }
[17:02:48.146]         }
[17:02:48.146]     })
[17:02:48.146]     if (TRUE) {
[17:02:48.146]         base::sink(type = "output", split = FALSE)
[17:02:48.146]         if (TRUE) {
[17:02:48.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.146]         }
[17:02:48.146]         else {
[17:02:48.146]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.146]         }
[17:02:48.146]         base::close(...future.stdout)
[17:02:48.146]         ...future.stdout <- NULL
[17:02:48.146]     }
[17:02:48.146]     ...future.result$conditions <- ...future.conditions
[17:02:48.146]     ...future.result$finished <- base::Sys.time()
[17:02:48.146]     ...future.result
[17:02:48.146] }
[17:02:48.149] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.149] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.150] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.150] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.150] MultisessionFuture started
[17:02:48.150] - Launch lazy future ... done
[17:02:48.150] run() for ‘MultisessionFuture’ ... done
[17:02:48.151] result() for ClusterFuture ...
[17:02:48.151] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.151] - Validating connection of MultisessionFuture
[17:02:48.152] - received message: FutureResult
[17:02:48.152] - Received FutureResult
[17:02:48.152] - Erased future from FutureRegistry
[17:02:48.152] result() for ClusterFuture ...
[17:02:48.152] - result already collected: FutureResult
[17:02:48.152] result() for ClusterFuture ... done
[17:02:48.152] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.153] result() for ClusterFuture ... done
[17:02:48.153] result() for ClusterFuture ...
[17:02:48.153] - result already collected: FutureResult
[17:02:48.153] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.153] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.154] Searching for globals...
[17:02:48.156] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:48.156] Searching for globals ... DONE
[17:02:48.156] Resolving globals: TRUE
[17:02:48.156] Resolving any globals that are futures ...
[17:02:48.156] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[17:02:48.156] Resolving any globals that are futures ... DONE
[17:02:48.156] Resolving futures part of globals (recursively) ...
[17:02:48.157] resolve() on list ...
[17:02:48.157]  recursive: 99
[17:02:48.157]  length: 1
[17:02:48.157]  elements: ‘x’
[17:02:48.157]  length: 0 (resolved future 1)
[17:02:48.157] resolve() on list ... DONE
[17:02:48.157] - globals: [1] ‘x’
[17:02:48.157] Resolving futures part of globals (recursively) ... DONE
[17:02:48.158] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.158] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.158] - globals: [1] ‘x’
[17:02:48.158] 
[17:02:48.158] getGlobalsAndPackages() ... DONE
[17:02:48.163] run() for ‘Future’ ...
[17:02:48.164] - state: ‘created’
[17:02:48.164] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.177] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.178]   - Field: ‘node’
[17:02:48.178]   - Field: ‘label’
[17:02:48.178]   - Field: ‘local’
[17:02:48.178]   - Field: ‘owner’
[17:02:48.178]   - Field: ‘envir’
[17:02:48.178]   - Field: ‘workers’
[17:02:48.178]   - Field: ‘packages’
[17:02:48.178]   - Field: ‘gc’
[17:02:48.178]   - Field: ‘conditions’
[17:02:48.178]   - Field: ‘persistent’
[17:02:48.179]   - Field: ‘expr’
[17:02:48.179]   - Field: ‘uuid’
[17:02:48.179]   - Field: ‘seed’
[17:02:48.179]   - Field: ‘version’
[17:02:48.179]   - Field: ‘result’
[17:02:48.179]   - Field: ‘asynchronous’
[17:02:48.179]   - Field: ‘calls’
[17:02:48.179]   - Field: ‘globals’
[17:02:48.179]   - Field: ‘stdout’
[17:02:48.179]   - Field: ‘earlySignal’
[17:02:48.179]   - Field: ‘lazy’
[17:02:48.180]   - Field: ‘state’
[17:02:48.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.180] - Launch lazy future ...
[17:02:48.180] Packages needed by the future expression (n = 0): <none>
[17:02:48.180] Packages needed by future strategies (n = 0): <none>
[17:02:48.181] {
[17:02:48.181]     {
[17:02:48.181]         {
[17:02:48.181]             ...future.startTime <- base::Sys.time()
[17:02:48.181]             {
[17:02:48.181]                 {
[17:02:48.181]                   {
[17:02:48.181]                     {
[17:02:48.181]                       base::local({
[17:02:48.181]                         has_future <- base::requireNamespace("future", 
[17:02:48.181]                           quietly = TRUE)
[17:02:48.181]                         if (has_future) {
[17:02:48.181]                           ns <- base::getNamespace("future")
[17:02:48.181]                           version <- ns[[".package"]][["version"]]
[17:02:48.181]                           if (is.null(version)) 
[17:02:48.181]                             version <- utils::packageVersion("future")
[17:02:48.181]                         }
[17:02:48.181]                         else {
[17:02:48.181]                           version <- NULL
[17:02:48.181]                         }
[17:02:48.181]                         if (!has_future || version < "1.8.0") {
[17:02:48.181]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.181]                             "", base::R.version$version.string), 
[17:02:48.181]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.181]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.181]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.181]                               "release", "version")], collapse = " "), 
[17:02:48.181]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.181]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.181]                             info)
[17:02:48.181]                           info <- base::paste(info, collapse = "; ")
[17:02:48.181]                           if (!has_future) {
[17:02:48.181]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.181]                               info)
[17:02:48.181]                           }
[17:02:48.181]                           else {
[17:02:48.181]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.181]                               info, version)
[17:02:48.181]                           }
[17:02:48.181]                           base::stop(msg)
[17:02:48.181]                         }
[17:02:48.181]                       })
[17:02:48.181]                     }
[17:02:48.181]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.181]                     base::options(mc.cores = 1L)
[17:02:48.181]                   }
[17:02:48.181]                   ...future.strategy.old <- future::plan("list")
[17:02:48.181]                   options(future.plan = NULL)
[17:02:48.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.181]                 }
[17:02:48.181]                 ...future.workdir <- getwd()
[17:02:48.181]             }
[17:02:48.181]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.181]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.181]         }
[17:02:48.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.181]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.181]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.181]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.181]             base::names(...future.oldOptions))
[17:02:48.181]     }
[17:02:48.181]     if (FALSE) {
[17:02:48.181]     }
[17:02:48.181]     else {
[17:02:48.181]         if (TRUE) {
[17:02:48.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.181]                 open = "w")
[17:02:48.181]         }
[17:02:48.181]         else {
[17:02:48.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.181]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.181]         }
[17:02:48.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.181]             base::sink(type = "output", split = FALSE)
[17:02:48.181]             base::close(...future.stdout)
[17:02:48.181]         }, add = TRUE)
[17:02:48.181]     }
[17:02:48.181]     ...future.frame <- base::sys.nframe()
[17:02:48.181]     ...future.conditions <- base::list()
[17:02:48.181]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.181]     if (FALSE) {
[17:02:48.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.181]     }
[17:02:48.181]     ...future.result <- base::tryCatch({
[17:02:48.181]         base::withCallingHandlers({
[17:02:48.181]             ...future.value <- base::withVisible(base::local({
[17:02:48.181]                 ...future.makeSendCondition <- base::local({
[17:02:48.181]                   sendCondition <- NULL
[17:02:48.181]                   function(frame = 1L) {
[17:02:48.181]                     if (is.function(sendCondition)) 
[17:02:48.181]                       return(sendCondition)
[17:02:48.181]                     ns <- getNamespace("parallel")
[17:02:48.181]                     if (exists("sendData", mode = "function", 
[17:02:48.181]                       envir = ns)) {
[17:02:48.181]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.181]                         envir = ns)
[17:02:48.181]                       envir <- sys.frame(frame)
[17:02:48.181]                       master <- NULL
[17:02:48.181]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.181]                         !identical(envir, emptyenv())) {
[17:02:48.181]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.181]                           inherits = FALSE)) {
[17:02:48.181]                           master <- get("master", mode = "list", 
[17:02:48.181]                             envir = envir, inherits = FALSE)
[17:02:48.181]                           if (inherits(master, c("SOCKnode", 
[17:02:48.181]                             "SOCK0node"))) {
[17:02:48.181]                             sendCondition <<- function(cond) {
[17:02:48.181]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.181]                                 success = TRUE)
[17:02:48.181]                               parallel_sendData(master, data)
[17:02:48.181]                             }
[17:02:48.181]                             return(sendCondition)
[17:02:48.181]                           }
[17:02:48.181]                         }
[17:02:48.181]                         frame <- frame + 1L
[17:02:48.181]                         envir <- sys.frame(frame)
[17:02:48.181]                       }
[17:02:48.181]                     }
[17:02:48.181]                     sendCondition <<- function(cond) NULL
[17:02:48.181]                   }
[17:02:48.181]                 })
[17:02:48.181]                 withCallingHandlers({
[17:02:48.181]                   {
[17:02:48.181]                     x[["a"]] <- 1
[17:02:48.181]                     x
[17:02:48.181]                   }
[17:02:48.181]                 }, immediateCondition = function(cond) {
[17:02:48.181]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.181]                   sendCondition(cond)
[17:02:48.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.181]                   {
[17:02:48.181]                     inherits <- base::inherits
[17:02:48.181]                     invokeRestart <- base::invokeRestart
[17:02:48.181]                     is.null <- base::is.null
[17:02:48.181]                     muffled <- FALSE
[17:02:48.181]                     if (inherits(cond, "message")) {
[17:02:48.181]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.181]                       if (muffled) 
[17:02:48.181]                         invokeRestart("muffleMessage")
[17:02:48.181]                     }
[17:02:48.181]                     else if (inherits(cond, "warning")) {
[17:02:48.181]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.181]                       if (muffled) 
[17:02:48.181]                         invokeRestart("muffleWarning")
[17:02:48.181]                     }
[17:02:48.181]                     else if (inherits(cond, "condition")) {
[17:02:48.181]                       if (!is.null(pattern)) {
[17:02:48.181]                         computeRestarts <- base::computeRestarts
[17:02:48.181]                         grepl <- base::grepl
[17:02:48.181]                         restarts <- computeRestarts(cond)
[17:02:48.181]                         for (restart in restarts) {
[17:02:48.181]                           name <- restart$name
[17:02:48.181]                           if (is.null(name)) 
[17:02:48.181]                             next
[17:02:48.181]                           if (!grepl(pattern, name)) 
[17:02:48.181]                             next
[17:02:48.181]                           invokeRestart(restart)
[17:02:48.181]                           muffled <- TRUE
[17:02:48.181]                           break
[17:02:48.181]                         }
[17:02:48.181]                       }
[17:02:48.181]                     }
[17:02:48.181]                     invisible(muffled)
[17:02:48.181]                   }
[17:02:48.181]                   muffleCondition(cond)
[17:02:48.181]                 })
[17:02:48.181]             }))
[17:02:48.181]             future::FutureResult(value = ...future.value$value, 
[17:02:48.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.181]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.181]                     ...future.globalenv.names))
[17:02:48.181]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.181]         }, condition = base::local({
[17:02:48.181]             c <- base::c
[17:02:48.181]             inherits <- base::inherits
[17:02:48.181]             invokeRestart <- base::invokeRestart
[17:02:48.181]             length <- base::length
[17:02:48.181]             list <- base::list
[17:02:48.181]             seq.int <- base::seq.int
[17:02:48.181]             signalCondition <- base::signalCondition
[17:02:48.181]             sys.calls <- base::sys.calls
[17:02:48.181]             `[[` <- base::`[[`
[17:02:48.181]             `+` <- base::`+`
[17:02:48.181]             `<<-` <- base::`<<-`
[17:02:48.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.181]                   3L)]
[17:02:48.181]             }
[17:02:48.181]             function(cond) {
[17:02:48.181]                 is_error <- inherits(cond, "error")
[17:02:48.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.181]                   NULL)
[17:02:48.181]                 if (is_error) {
[17:02:48.181]                   sessionInformation <- function() {
[17:02:48.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.181]                       search = base::search(), system = base::Sys.info())
[17:02:48.181]                   }
[17:02:48.181]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.181]                     cond$call), session = sessionInformation(), 
[17:02:48.181]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.181]                   signalCondition(cond)
[17:02:48.181]                 }
[17:02:48.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.181]                 "immediateCondition"))) {
[17:02:48.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.181]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.181]                   if (TRUE && !signal) {
[17:02:48.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.181]                     {
[17:02:48.181]                       inherits <- base::inherits
[17:02:48.181]                       invokeRestart <- base::invokeRestart
[17:02:48.181]                       is.null <- base::is.null
[17:02:48.181]                       muffled <- FALSE
[17:02:48.181]                       if (inherits(cond, "message")) {
[17:02:48.181]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.181]                         if (muffled) 
[17:02:48.181]                           invokeRestart("muffleMessage")
[17:02:48.181]                       }
[17:02:48.181]                       else if (inherits(cond, "warning")) {
[17:02:48.181]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.181]                         if (muffled) 
[17:02:48.181]                           invokeRestart("muffleWarning")
[17:02:48.181]                       }
[17:02:48.181]                       else if (inherits(cond, "condition")) {
[17:02:48.181]                         if (!is.null(pattern)) {
[17:02:48.181]                           computeRestarts <- base::computeRestarts
[17:02:48.181]                           grepl <- base::grepl
[17:02:48.181]                           restarts <- computeRestarts(cond)
[17:02:48.181]                           for (restart in restarts) {
[17:02:48.181]                             name <- restart$name
[17:02:48.181]                             if (is.null(name)) 
[17:02:48.181]                               next
[17:02:48.181]                             if (!grepl(pattern, name)) 
[17:02:48.181]                               next
[17:02:48.181]                             invokeRestart(restart)
[17:02:48.181]                             muffled <- TRUE
[17:02:48.181]                             break
[17:02:48.181]                           }
[17:02:48.181]                         }
[17:02:48.181]                       }
[17:02:48.181]                       invisible(muffled)
[17:02:48.181]                     }
[17:02:48.181]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.181]                   }
[17:02:48.181]                 }
[17:02:48.181]                 else {
[17:02:48.181]                   if (TRUE) {
[17:02:48.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.181]                     {
[17:02:48.181]                       inherits <- base::inherits
[17:02:48.181]                       invokeRestart <- base::invokeRestart
[17:02:48.181]                       is.null <- base::is.null
[17:02:48.181]                       muffled <- FALSE
[17:02:48.181]                       if (inherits(cond, "message")) {
[17:02:48.181]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.181]                         if (muffled) 
[17:02:48.181]                           invokeRestart("muffleMessage")
[17:02:48.181]                       }
[17:02:48.181]                       else if (inherits(cond, "warning")) {
[17:02:48.181]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.181]                         if (muffled) 
[17:02:48.181]                           invokeRestart("muffleWarning")
[17:02:48.181]                       }
[17:02:48.181]                       else if (inherits(cond, "condition")) {
[17:02:48.181]                         if (!is.null(pattern)) {
[17:02:48.181]                           computeRestarts <- base::computeRestarts
[17:02:48.181]                           grepl <- base::grepl
[17:02:48.181]                           restarts <- computeRestarts(cond)
[17:02:48.181]                           for (restart in restarts) {
[17:02:48.181]                             name <- restart$name
[17:02:48.181]                             if (is.null(name)) 
[17:02:48.181]                               next
[17:02:48.181]                             if (!grepl(pattern, name)) 
[17:02:48.181]                               next
[17:02:48.181]                             invokeRestart(restart)
[17:02:48.181]                             muffled <- TRUE
[17:02:48.181]                             break
[17:02:48.181]                           }
[17:02:48.181]                         }
[17:02:48.181]                       }
[17:02:48.181]                       invisible(muffled)
[17:02:48.181]                     }
[17:02:48.181]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.181]                   }
[17:02:48.181]                 }
[17:02:48.181]             }
[17:02:48.181]         }))
[17:02:48.181]     }, error = function(ex) {
[17:02:48.181]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.181]                 ...future.rng), started = ...future.startTime, 
[17:02:48.181]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.181]             version = "1.8"), class = "FutureResult")
[17:02:48.181]     }, finally = {
[17:02:48.181]         if (!identical(...future.workdir, getwd())) 
[17:02:48.181]             setwd(...future.workdir)
[17:02:48.181]         {
[17:02:48.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.181]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.181]             }
[17:02:48.181]             base::options(...future.oldOptions)
[17:02:48.181]             if (.Platform$OS.type == "windows") {
[17:02:48.181]                 old_names <- names(...future.oldEnvVars)
[17:02:48.181]                 envs <- base::Sys.getenv()
[17:02:48.181]                 names <- names(envs)
[17:02:48.181]                 common <- intersect(names, old_names)
[17:02:48.181]                 added <- setdiff(names, old_names)
[17:02:48.181]                 removed <- setdiff(old_names, names)
[17:02:48.181]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.181]                   envs[common]]
[17:02:48.181]                 NAMES <- toupper(changed)
[17:02:48.181]                 args <- list()
[17:02:48.181]                 for (kk in seq_along(NAMES)) {
[17:02:48.181]                   name <- changed[[kk]]
[17:02:48.181]                   NAME <- NAMES[[kk]]
[17:02:48.181]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.181]                     next
[17:02:48.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.181]                 }
[17:02:48.181]                 NAMES <- toupper(added)
[17:02:48.181]                 for (kk in seq_along(NAMES)) {
[17:02:48.181]                   name <- added[[kk]]
[17:02:48.181]                   NAME <- NAMES[[kk]]
[17:02:48.181]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.181]                     next
[17:02:48.181]                   args[[name]] <- ""
[17:02:48.181]                 }
[17:02:48.181]                 NAMES <- toupper(removed)
[17:02:48.181]                 for (kk in seq_along(NAMES)) {
[17:02:48.181]                   name <- removed[[kk]]
[17:02:48.181]                   NAME <- NAMES[[kk]]
[17:02:48.181]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.181]                     next
[17:02:48.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.181]                 }
[17:02:48.181]                 if (length(args) > 0) 
[17:02:48.181]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.181]             }
[17:02:48.181]             else {
[17:02:48.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.181]             }
[17:02:48.181]             {
[17:02:48.181]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.181]                   0L) {
[17:02:48.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.181]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.181]                   base::options(opts)
[17:02:48.181]                 }
[17:02:48.181]                 {
[17:02:48.181]                   {
[17:02:48.181]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.181]                     NULL
[17:02:48.181]                   }
[17:02:48.181]                   options(future.plan = NULL)
[17:02:48.181]                   if (is.na(NA_character_)) 
[17:02:48.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.181]                     .init = FALSE)
[17:02:48.181]                 }
[17:02:48.181]             }
[17:02:48.181]         }
[17:02:48.181]     })
[17:02:48.181]     if (TRUE) {
[17:02:48.181]         base::sink(type = "output", split = FALSE)
[17:02:48.181]         if (TRUE) {
[17:02:48.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.181]         }
[17:02:48.181]         else {
[17:02:48.181]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.181]         }
[17:02:48.181]         base::close(...future.stdout)
[17:02:48.181]         ...future.stdout <- NULL
[17:02:48.181]     }
[17:02:48.181]     ...future.result$conditions <- ...future.conditions
[17:02:48.181]     ...future.result$finished <- base::Sys.time()
[17:02:48.181]     ...future.result
[17:02:48.181] }
[17:02:48.183] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.183] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.184] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.184] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.184] MultisessionFuture started
[17:02:48.184] - Launch lazy future ... done
[17:02:48.184] run() for ‘MultisessionFuture’ ... done
[17:02:48.185] result() for ClusterFuture ...
[17:02:48.185] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.185] - Validating connection of MultisessionFuture
[17:02:48.186] - received message: FutureResult
[17:02:48.186] - Received FutureResult
[17:02:48.186] - Erased future from FutureRegistry
[17:02:48.186] result() for ClusterFuture ...
[17:02:48.186] - result already collected: FutureResult
[17:02:48.186] result() for ClusterFuture ... done
[17:02:48.186] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.186] result() for ClusterFuture ... done
[17:02:48.187] result() for ClusterFuture ...
[17:02:48.187] - result already collected: FutureResult
[17:02:48.187] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.187] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.187] Searching for globals...
[17:02:48.189] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:48.189] Searching for globals ... DONE
[17:02:48.190] Resolving globals: TRUE
[17:02:48.190] Resolving any globals that are futures ...
[17:02:48.190] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:48.190] Resolving any globals that are futures ... DONE
[17:02:48.190] Resolving futures part of globals (recursively) ...
[17:02:48.190] resolve() on list ...
[17:02:48.190]  recursive: 99
[17:02:48.191]  length: 1
[17:02:48.191]  elements: ‘x’
[17:02:48.191]  length: 0 (resolved future 1)
[17:02:48.191] resolve() on list ... DONE
[17:02:48.191] - globals: [1] ‘x’
[17:02:48.191] Resolving futures part of globals (recursively) ... DONE
[17:02:48.191] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.192] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.192] - globals: [1] ‘x’
[17:02:48.192] 
[17:02:48.192] getGlobalsAndPackages() ... DONE
[17:02:48.192] run() for ‘Future’ ...
[17:02:48.192] - state: ‘created’
[17:02:48.192] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.206]   - Field: ‘node’
[17:02:48.207]   - Field: ‘label’
[17:02:48.207]   - Field: ‘local’
[17:02:48.207]   - Field: ‘owner’
[17:02:48.207]   - Field: ‘envir’
[17:02:48.207]   - Field: ‘workers’
[17:02:48.207]   - Field: ‘packages’
[17:02:48.207]   - Field: ‘gc’
[17:02:48.207]   - Field: ‘conditions’
[17:02:48.207]   - Field: ‘persistent’
[17:02:48.207]   - Field: ‘expr’
[17:02:48.207]   - Field: ‘uuid’
[17:02:48.208]   - Field: ‘seed’
[17:02:48.208]   - Field: ‘version’
[17:02:48.208]   - Field: ‘result’
[17:02:48.208]   - Field: ‘asynchronous’
[17:02:48.208]   - Field: ‘calls’
[17:02:48.208]   - Field: ‘globals’
[17:02:48.208]   - Field: ‘stdout’
[17:02:48.208]   - Field: ‘earlySignal’
[17:02:48.208]   - Field: ‘lazy’
[17:02:48.208]   - Field: ‘state’
[17:02:48.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.209] - Launch lazy future ...
[17:02:48.209] Packages needed by the future expression (n = 0): <none>
[17:02:48.209] Packages needed by future strategies (n = 0): <none>
[17:02:48.209] {
[17:02:48.209]     {
[17:02:48.209]         {
[17:02:48.209]             ...future.startTime <- base::Sys.time()
[17:02:48.209]             {
[17:02:48.209]                 {
[17:02:48.209]                   {
[17:02:48.209]                     {
[17:02:48.209]                       base::local({
[17:02:48.209]                         has_future <- base::requireNamespace("future", 
[17:02:48.209]                           quietly = TRUE)
[17:02:48.209]                         if (has_future) {
[17:02:48.209]                           ns <- base::getNamespace("future")
[17:02:48.209]                           version <- ns[[".package"]][["version"]]
[17:02:48.209]                           if (is.null(version)) 
[17:02:48.209]                             version <- utils::packageVersion("future")
[17:02:48.209]                         }
[17:02:48.209]                         else {
[17:02:48.209]                           version <- NULL
[17:02:48.209]                         }
[17:02:48.209]                         if (!has_future || version < "1.8.0") {
[17:02:48.209]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.209]                             "", base::R.version$version.string), 
[17:02:48.209]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.209]                               "release", "version")], collapse = " "), 
[17:02:48.209]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.209]                             info)
[17:02:48.209]                           info <- base::paste(info, collapse = "; ")
[17:02:48.209]                           if (!has_future) {
[17:02:48.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.209]                               info)
[17:02:48.209]                           }
[17:02:48.209]                           else {
[17:02:48.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.209]                               info, version)
[17:02:48.209]                           }
[17:02:48.209]                           base::stop(msg)
[17:02:48.209]                         }
[17:02:48.209]                       })
[17:02:48.209]                     }
[17:02:48.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.209]                     base::options(mc.cores = 1L)
[17:02:48.209]                   }
[17:02:48.209]                   ...future.strategy.old <- future::plan("list")
[17:02:48.209]                   options(future.plan = NULL)
[17:02:48.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.209]                 }
[17:02:48.209]                 ...future.workdir <- getwd()
[17:02:48.209]             }
[17:02:48.209]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.209]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.209]         }
[17:02:48.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.209]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.209]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.209]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.209]             base::names(...future.oldOptions))
[17:02:48.209]     }
[17:02:48.209]     if (FALSE) {
[17:02:48.209]     }
[17:02:48.209]     else {
[17:02:48.209]         if (TRUE) {
[17:02:48.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.209]                 open = "w")
[17:02:48.209]         }
[17:02:48.209]         else {
[17:02:48.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.209]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.209]         }
[17:02:48.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.209]             base::sink(type = "output", split = FALSE)
[17:02:48.209]             base::close(...future.stdout)
[17:02:48.209]         }, add = TRUE)
[17:02:48.209]     }
[17:02:48.209]     ...future.frame <- base::sys.nframe()
[17:02:48.209]     ...future.conditions <- base::list()
[17:02:48.209]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.209]     if (FALSE) {
[17:02:48.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.209]     }
[17:02:48.209]     ...future.result <- base::tryCatch({
[17:02:48.209]         base::withCallingHandlers({
[17:02:48.209]             ...future.value <- base::withVisible(base::local({
[17:02:48.209]                 ...future.makeSendCondition <- base::local({
[17:02:48.209]                   sendCondition <- NULL
[17:02:48.209]                   function(frame = 1L) {
[17:02:48.209]                     if (is.function(sendCondition)) 
[17:02:48.209]                       return(sendCondition)
[17:02:48.209]                     ns <- getNamespace("parallel")
[17:02:48.209]                     if (exists("sendData", mode = "function", 
[17:02:48.209]                       envir = ns)) {
[17:02:48.209]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.209]                         envir = ns)
[17:02:48.209]                       envir <- sys.frame(frame)
[17:02:48.209]                       master <- NULL
[17:02:48.209]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.209]                         !identical(envir, emptyenv())) {
[17:02:48.209]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.209]                           inherits = FALSE)) {
[17:02:48.209]                           master <- get("master", mode = "list", 
[17:02:48.209]                             envir = envir, inherits = FALSE)
[17:02:48.209]                           if (inherits(master, c("SOCKnode", 
[17:02:48.209]                             "SOCK0node"))) {
[17:02:48.209]                             sendCondition <<- function(cond) {
[17:02:48.209]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.209]                                 success = TRUE)
[17:02:48.209]                               parallel_sendData(master, data)
[17:02:48.209]                             }
[17:02:48.209]                             return(sendCondition)
[17:02:48.209]                           }
[17:02:48.209]                         }
[17:02:48.209]                         frame <- frame + 1L
[17:02:48.209]                         envir <- sys.frame(frame)
[17:02:48.209]                       }
[17:02:48.209]                     }
[17:02:48.209]                     sendCondition <<- function(cond) NULL
[17:02:48.209]                   }
[17:02:48.209]                 })
[17:02:48.209]                 withCallingHandlers({
[17:02:48.209]                   {
[17:02:48.209]                     x["a"] <- list(1)
[17:02:48.209]                     x
[17:02:48.209]                   }
[17:02:48.209]                 }, immediateCondition = function(cond) {
[17:02:48.209]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.209]                   sendCondition(cond)
[17:02:48.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.209]                   {
[17:02:48.209]                     inherits <- base::inherits
[17:02:48.209]                     invokeRestart <- base::invokeRestart
[17:02:48.209]                     is.null <- base::is.null
[17:02:48.209]                     muffled <- FALSE
[17:02:48.209]                     if (inherits(cond, "message")) {
[17:02:48.209]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.209]                       if (muffled) 
[17:02:48.209]                         invokeRestart("muffleMessage")
[17:02:48.209]                     }
[17:02:48.209]                     else if (inherits(cond, "warning")) {
[17:02:48.209]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.209]                       if (muffled) 
[17:02:48.209]                         invokeRestart("muffleWarning")
[17:02:48.209]                     }
[17:02:48.209]                     else if (inherits(cond, "condition")) {
[17:02:48.209]                       if (!is.null(pattern)) {
[17:02:48.209]                         computeRestarts <- base::computeRestarts
[17:02:48.209]                         grepl <- base::grepl
[17:02:48.209]                         restarts <- computeRestarts(cond)
[17:02:48.209]                         for (restart in restarts) {
[17:02:48.209]                           name <- restart$name
[17:02:48.209]                           if (is.null(name)) 
[17:02:48.209]                             next
[17:02:48.209]                           if (!grepl(pattern, name)) 
[17:02:48.209]                             next
[17:02:48.209]                           invokeRestart(restart)
[17:02:48.209]                           muffled <- TRUE
[17:02:48.209]                           break
[17:02:48.209]                         }
[17:02:48.209]                       }
[17:02:48.209]                     }
[17:02:48.209]                     invisible(muffled)
[17:02:48.209]                   }
[17:02:48.209]                   muffleCondition(cond)
[17:02:48.209]                 })
[17:02:48.209]             }))
[17:02:48.209]             future::FutureResult(value = ...future.value$value, 
[17:02:48.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.209]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.209]                     ...future.globalenv.names))
[17:02:48.209]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.209]         }, condition = base::local({
[17:02:48.209]             c <- base::c
[17:02:48.209]             inherits <- base::inherits
[17:02:48.209]             invokeRestart <- base::invokeRestart
[17:02:48.209]             length <- base::length
[17:02:48.209]             list <- base::list
[17:02:48.209]             seq.int <- base::seq.int
[17:02:48.209]             signalCondition <- base::signalCondition
[17:02:48.209]             sys.calls <- base::sys.calls
[17:02:48.209]             `[[` <- base::`[[`
[17:02:48.209]             `+` <- base::`+`
[17:02:48.209]             `<<-` <- base::`<<-`
[17:02:48.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.209]                   3L)]
[17:02:48.209]             }
[17:02:48.209]             function(cond) {
[17:02:48.209]                 is_error <- inherits(cond, "error")
[17:02:48.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.209]                   NULL)
[17:02:48.209]                 if (is_error) {
[17:02:48.209]                   sessionInformation <- function() {
[17:02:48.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.209]                       search = base::search(), system = base::Sys.info())
[17:02:48.209]                   }
[17:02:48.209]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.209]                     cond$call), session = sessionInformation(), 
[17:02:48.209]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.209]                   signalCondition(cond)
[17:02:48.209]                 }
[17:02:48.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.209]                 "immediateCondition"))) {
[17:02:48.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.209]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.209]                   if (TRUE && !signal) {
[17:02:48.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.209]                     {
[17:02:48.209]                       inherits <- base::inherits
[17:02:48.209]                       invokeRestart <- base::invokeRestart
[17:02:48.209]                       is.null <- base::is.null
[17:02:48.209]                       muffled <- FALSE
[17:02:48.209]                       if (inherits(cond, "message")) {
[17:02:48.209]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.209]                         if (muffled) 
[17:02:48.209]                           invokeRestart("muffleMessage")
[17:02:48.209]                       }
[17:02:48.209]                       else if (inherits(cond, "warning")) {
[17:02:48.209]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.209]                         if (muffled) 
[17:02:48.209]                           invokeRestart("muffleWarning")
[17:02:48.209]                       }
[17:02:48.209]                       else if (inherits(cond, "condition")) {
[17:02:48.209]                         if (!is.null(pattern)) {
[17:02:48.209]                           computeRestarts <- base::computeRestarts
[17:02:48.209]                           grepl <- base::grepl
[17:02:48.209]                           restarts <- computeRestarts(cond)
[17:02:48.209]                           for (restart in restarts) {
[17:02:48.209]                             name <- restart$name
[17:02:48.209]                             if (is.null(name)) 
[17:02:48.209]                               next
[17:02:48.209]                             if (!grepl(pattern, name)) 
[17:02:48.209]                               next
[17:02:48.209]                             invokeRestart(restart)
[17:02:48.209]                             muffled <- TRUE
[17:02:48.209]                             break
[17:02:48.209]                           }
[17:02:48.209]                         }
[17:02:48.209]                       }
[17:02:48.209]                       invisible(muffled)
[17:02:48.209]                     }
[17:02:48.209]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.209]                   }
[17:02:48.209]                 }
[17:02:48.209]                 else {
[17:02:48.209]                   if (TRUE) {
[17:02:48.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.209]                     {
[17:02:48.209]                       inherits <- base::inherits
[17:02:48.209]                       invokeRestart <- base::invokeRestart
[17:02:48.209]                       is.null <- base::is.null
[17:02:48.209]                       muffled <- FALSE
[17:02:48.209]                       if (inherits(cond, "message")) {
[17:02:48.209]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.209]                         if (muffled) 
[17:02:48.209]                           invokeRestart("muffleMessage")
[17:02:48.209]                       }
[17:02:48.209]                       else if (inherits(cond, "warning")) {
[17:02:48.209]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.209]                         if (muffled) 
[17:02:48.209]                           invokeRestart("muffleWarning")
[17:02:48.209]                       }
[17:02:48.209]                       else if (inherits(cond, "condition")) {
[17:02:48.209]                         if (!is.null(pattern)) {
[17:02:48.209]                           computeRestarts <- base::computeRestarts
[17:02:48.209]                           grepl <- base::grepl
[17:02:48.209]                           restarts <- computeRestarts(cond)
[17:02:48.209]                           for (restart in restarts) {
[17:02:48.209]                             name <- restart$name
[17:02:48.209]                             if (is.null(name)) 
[17:02:48.209]                               next
[17:02:48.209]                             if (!grepl(pattern, name)) 
[17:02:48.209]                               next
[17:02:48.209]                             invokeRestart(restart)
[17:02:48.209]                             muffled <- TRUE
[17:02:48.209]                             break
[17:02:48.209]                           }
[17:02:48.209]                         }
[17:02:48.209]                       }
[17:02:48.209]                       invisible(muffled)
[17:02:48.209]                     }
[17:02:48.209]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.209]                   }
[17:02:48.209]                 }
[17:02:48.209]             }
[17:02:48.209]         }))
[17:02:48.209]     }, error = function(ex) {
[17:02:48.209]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.209]                 ...future.rng), started = ...future.startTime, 
[17:02:48.209]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.209]             version = "1.8"), class = "FutureResult")
[17:02:48.209]     }, finally = {
[17:02:48.209]         if (!identical(...future.workdir, getwd())) 
[17:02:48.209]             setwd(...future.workdir)
[17:02:48.209]         {
[17:02:48.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.209]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.209]             }
[17:02:48.209]             base::options(...future.oldOptions)
[17:02:48.209]             if (.Platform$OS.type == "windows") {
[17:02:48.209]                 old_names <- names(...future.oldEnvVars)
[17:02:48.209]                 envs <- base::Sys.getenv()
[17:02:48.209]                 names <- names(envs)
[17:02:48.209]                 common <- intersect(names, old_names)
[17:02:48.209]                 added <- setdiff(names, old_names)
[17:02:48.209]                 removed <- setdiff(old_names, names)
[17:02:48.209]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.209]                   envs[common]]
[17:02:48.209]                 NAMES <- toupper(changed)
[17:02:48.209]                 args <- list()
[17:02:48.209]                 for (kk in seq_along(NAMES)) {
[17:02:48.209]                   name <- changed[[kk]]
[17:02:48.209]                   NAME <- NAMES[[kk]]
[17:02:48.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.209]                     next
[17:02:48.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.209]                 }
[17:02:48.209]                 NAMES <- toupper(added)
[17:02:48.209]                 for (kk in seq_along(NAMES)) {
[17:02:48.209]                   name <- added[[kk]]
[17:02:48.209]                   NAME <- NAMES[[kk]]
[17:02:48.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.209]                     next
[17:02:48.209]                   args[[name]] <- ""
[17:02:48.209]                 }
[17:02:48.209]                 NAMES <- toupper(removed)
[17:02:48.209]                 for (kk in seq_along(NAMES)) {
[17:02:48.209]                   name <- removed[[kk]]
[17:02:48.209]                   NAME <- NAMES[[kk]]
[17:02:48.209]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.209]                     next
[17:02:48.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.209]                 }
[17:02:48.209]                 if (length(args) > 0) 
[17:02:48.209]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.209]             }
[17:02:48.209]             else {
[17:02:48.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.209]             }
[17:02:48.209]             {
[17:02:48.209]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.209]                   0L) {
[17:02:48.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.209]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.209]                   base::options(opts)
[17:02:48.209]                 }
[17:02:48.209]                 {
[17:02:48.209]                   {
[17:02:48.209]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.209]                     NULL
[17:02:48.209]                   }
[17:02:48.209]                   options(future.plan = NULL)
[17:02:48.209]                   if (is.na(NA_character_)) 
[17:02:48.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.209]                     .init = FALSE)
[17:02:48.209]                 }
[17:02:48.209]             }
[17:02:48.209]         }
[17:02:48.209]     })
[17:02:48.209]     if (TRUE) {
[17:02:48.209]         base::sink(type = "output", split = FALSE)
[17:02:48.209]         if (TRUE) {
[17:02:48.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.209]         }
[17:02:48.209]         else {
[17:02:48.209]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.209]         }
[17:02:48.209]         base::close(...future.stdout)
[17:02:48.209]         ...future.stdout <- NULL
[17:02:48.209]     }
[17:02:48.209]     ...future.result$conditions <- ...future.conditions
[17:02:48.209]     ...future.result$finished <- base::Sys.time()
[17:02:48.209]     ...future.result
[17:02:48.209] }
[17:02:48.212] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.212] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.212] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.213] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.213] MultisessionFuture started
[17:02:48.213] - Launch lazy future ... done
[17:02:48.213] run() for ‘MultisessionFuture’ ... done
[17:02:48.213] result() for ClusterFuture ...
[17:02:48.213] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.214] - Validating connection of MultisessionFuture
[17:02:48.215] - received message: FutureResult
[17:02:48.215] - Received FutureResult
[17:02:48.215] - Erased future from FutureRegistry
[17:02:48.215] result() for ClusterFuture ...
[17:02:48.215] - result already collected: FutureResult
[17:02:48.215] result() for ClusterFuture ... done
[17:02:48.215] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.215] result() for ClusterFuture ... done
[17:02:48.215] result() for ClusterFuture ...
[17:02:48.215] - result already collected: FutureResult
[17:02:48.216] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.216] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.216] Searching for globals...
[17:02:48.218] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:48.218] Searching for globals ... DONE
[17:02:48.218] Resolving globals: TRUE
[17:02:48.218] Resolving any globals that are futures ...
[17:02:48.218] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:48.219] Resolving any globals that are futures ... DONE
[17:02:48.219] Resolving futures part of globals (recursively) ...
[17:02:48.219] resolve() on list ...
[17:02:48.219]  recursive: 99
[17:02:48.219]  length: 1
[17:02:48.219]  elements: ‘x’
[17:02:48.220]  length: 0 (resolved future 1)
[17:02:48.220] resolve() on list ... DONE
[17:02:48.220] - globals: [1] ‘x’
[17:02:48.220] Resolving futures part of globals (recursively) ... DONE
[17:02:48.220] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.220] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.220] - globals: [1] ‘x’
[17:02:48.221] 
[17:02:48.221] getGlobalsAndPackages() ... DONE
[17:02:48.221] run() for ‘Future’ ...
[17:02:48.221] - state: ‘created’
[17:02:48.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.235]   - Field: ‘node’
[17:02:48.235]   - Field: ‘label’
[17:02:48.235]   - Field: ‘local’
[17:02:48.236]   - Field: ‘owner’
[17:02:48.236]   - Field: ‘envir’
[17:02:48.236]   - Field: ‘workers’
[17:02:48.236]   - Field: ‘packages’
[17:02:48.236]   - Field: ‘gc’
[17:02:48.236]   - Field: ‘conditions’
[17:02:48.236]   - Field: ‘persistent’
[17:02:48.236]   - Field: ‘expr’
[17:02:48.236]   - Field: ‘uuid’
[17:02:48.236]   - Field: ‘seed’
[17:02:48.236]   - Field: ‘version’
[17:02:48.237]   - Field: ‘result’
[17:02:48.237]   - Field: ‘asynchronous’
[17:02:48.237]   - Field: ‘calls’
[17:02:48.237]   - Field: ‘globals’
[17:02:48.237]   - Field: ‘stdout’
[17:02:48.237]   - Field: ‘earlySignal’
[17:02:48.237]   - Field: ‘lazy’
[17:02:48.237]   - Field: ‘state’
[17:02:48.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.237] - Launch lazy future ...
[17:02:48.238] Packages needed by the future expression (n = 0): <none>
[17:02:48.238] Packages needed by future strategies (n = 0): <none>
[17:02:48.238] {
[17:02:48.238]     {
[17:02:48.238]         {
[17:02:48.238]             ...future.startTime <- base::Sys.time()
[17:02:48.238]             {
[17:02:48.238]                 {
[17:02:48.238]                   {
[17:02:48.238]                     {
[17:02:48.238]                       base::local({
[17:02:48.238]                         has_future <- base::requireNamespace("future", 
[17:02:48.238]                           quietly = TRUE)
[17:02:48.238]                         if (has_future) {
[17:02:48.238]                           ns <- base::getNamespace("future")
[17:02:48.238]                           version <- ns[[".package"]][["version"]]
[17:02:48.238]                           if (is.null(version)) 
[17:02:48.238]                             version <- utils::packageVersion("future")
[17:02:48.238]                         }
[17:02:48.238]                         else {
[17:02:48.238]                           version <- NULL
[17:02:48.238]                         }
[17:02:48.238]                         if (!has_future || version < "1.8.0") {
[17:02:48.238]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.238]                             "", base::R.version$version.string), 
[17:02:48.238]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.238]                               "release", "version")], collapse = " "), 
[17:02:48.238]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.238]                             info)
[17:02:48.238]                           info <- base::paste(info, collapse = "; ")
[17:02:48.238]                           if (!has_future) {
[17:02:48.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.238]                               info)
[17:02:48.238]                           }
[17:02:48.238]                           else {
[17:02:48.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.238]                               info, version)
[17:02:48.238]                           }
[17:02:48.238]                           base::stop(msg)
[17:02:48.238]                         }
[17:02:48.238]                       })
[17:02:48.238]                     }
[17:02:48.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.238]                     base::options(mc.cores = 1L)
[17:02:48.238]                   }
[17:02:48.238]                   ...future.strategy.old <- future::plan("list")
[17:02:48.238]                   options(future.plan = NULL)
[17:02:48.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.238]                 }
[17:02:48.238]                 ...future.workdir <- getwd()
[17:02:48.238]             }
[17:02:48.238]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.238]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.238]         }
[17:02:48.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.238]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.238]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.238]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.238]             base::names(...future.oldOptions))
[17:02:48.238]     }
[17:02:48.238]     if (FALSE) {
[17:02:48.238]     }
[17:02:48.238]     else {
[17:02:48.238]         if (TRUE) {
[17:02:48.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.238]                 open = "w")
[17:02:48.238]         }
[17:02:48.238]         else {
[17:02:48.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.238]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.238]         }
[17:02:48.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.238]             base::sink(type = "output", split = FALSE)
[17:02:48.238]             base::close(...future.stdout)
[17:02:48.238]         }, add = TRUE)
[17:02:48.238]     }
[17:02:48.238]     ...future.frame <- base::sys.nframe()
[17:02:48.238]     ...future.conditions <- base::list()
[17:02:48.238]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.238]     if (FALSE) {
[17:02:48.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.238]     }
[17:02:48.238]     ...future.result <- base::tryCatch({
[17:02:48.238]         base::withCallingHandlers({
[17:02:48.238]             ...future.value <- base::withVisible(base::local({
[17:02:48.238]                 ...future.makeSendCondition <- base::local({
[17:02:48.238]                   sendCondition <- NULL
[17:02:48.238]                   function(frame = 1L) {
[17:02:48.238]                     if (is.function(sendCondition)) 
[17:02:48.238]                       return(sendCondition)
[17:02:48.238]                     ns <- getNamespace("parallel")
[17:02:48.238]                     if (exists("sendData", mode = "function", 
[17:02:48.238]                       envir = ns)) {
[17:02:48.238]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.238]                         envir = ns)
[17:02:48.238]                       envir <- sys.frame(frame)
[17:02:48.238]                       master <- NULL
[17:02:48.238]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.238]                         !identical(envir, emptyenv())) {
[17:02:48.238]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.238]                           inherits = FALSE)) {
[17:02:48.238]                           master <- get("master", mode = "list", 
[17:02:48.238]                             envir = envir, inherits = FALSE)
[17:02:48.238]                           if (inherits(master, c("SOCKnode", 
[17:02:48.238]                             "SOCK0node"))) {
[17:02:48.238]                             sendCondition <<- function(cond) {
[17:02:48.238]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.238]                                 success = TRUE)
[17:02:48.238]                               parallel_sendData(master, data)
[17:02:48.238]                             }
[17:02:48.238]                             return(sendCondition)
[17:02:48.238]                           }
[17:02:48.238]                         }
[17:02:48.238]                         frame <- frame + 1L
[17:02:48.238]                         envir <- sys.frame(frame)
[17:02:48.238]                       }
[17:02:48.238]                     }
[17:02:48.238]                     sendCondition <<- function(cond) NULL
[17:02:48.238]                   }
[17:02:48.238]                 })
[17:02:48.238]                 withCallingHandlers({
[17:02:48.238]                   {
[17:02:48.238]                     x["a"] <- list(1)
[17:02:48.238]                     x
[17:02:48.238]                   }
[17:02:48.238]                 }, immediateCondition = function(cond) {
[17:02:48.238]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.238]                   sendCondition(cond)
[17:02:48.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.238]                   {
[17:02:48.238]                     inherits <- base::inherits
[17:02:48.238]                     invokeRestart <- base::invokeRestart
[17:02:48.238]                     is.null <- base::is.null
[17:02:48.238]                     muffled <- FALSE
[17:02:48.238]                     if (inherits(cond, "message")) {
[17:02:48.238]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.238]                       if (muffled) 
[17:02:48.238]                         invokeRestart("muffleMessage")
[17:02:48.238]                     }
[17:02:48.238]                     else if (inherits(cond, "warning")) {
[17:02:48.238]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.238]                       if (muffled) 
[17:02:48.238]                         invokeRestart("muffleWarning")
[17:02:48.238]                     }
[17:02:48.238]                     else if (inherits(cond, "condition")) {
[17:02:48.238]                       if (!is.null(pattern)) {
[17:02:48.238]                         computeRestarts <- base::computeRestarts
[17:02:48.238]                         grepl <- base::grepl
[17:02:48.238]                         restarts <- computeRestarts(cond)
[17:02:48.238]                         for (restart in restarts) {
[17:02:48.238]                           name <- restart$name
[17:02:48.238]                           if (is.null(name)) 
[17:02:48.238]                             next
[17:02:48.238]                           if (!grepl(pattern, name)) 
[17:02:48.238]                             next
[17:02:48.238]                           invokeRestart(restart)
[17:02:48.238]                           muffled <- TRUE
[17:02:48.238]                           break
[17:02:48.238]                         }
[17:02:48.238]                       }
[17:02:48.238]                     }
[17:02:48.238]                     invisible(muffled)
[17:02:48.238]                   }
[17:02:48.238]                   muffleCondition(cond)
[17:02:48.238]                 })
[17:02:48.238]             }))
[17:02:48.238]             future::FutureResult(value = ...future.value$value, 
[17:02:48.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.238]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.238]                     ...future.globalenv.names))
[17:02:48.238]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.238]         }, condition = base::local({
[17:02:48.238]             c <- base::c
[17:02:48.238]             inherits <- base::inherits
[17:02:48.238]             invokeRestart <- base::invokeRestart
[17:02:48.238]             length <- base::length
[17:02:48.238]             list <- base::list
[17:02:48.238]             seq.int <- base::seq.int
[17:02:48.238]             signalCondition <- base::signalCondition
[17:02:48.238]             sys.calls <- base::sys.calls
[17:02:48.238]             `[[` <- base::`[[`
[17:02:48.238]             `+` <- base::`+`
[17:02:48.238]             `<<-` <- base::`<<-`
[17:02:48.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.238]                   3L)]
[17:02:48.238]             }
[17:02:48.238]             function(cond) {
[17:02:48.238]                 is_error <- inherits(cond, "error")
[17:02:48.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.238]                   NULL)
[17:02:48.238]                 if (is_error) {
[17:02:48.238]                   sessionInformation <- function() {
[17:02:48.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.238]                       search = base::search(), system = base::Sys.info())
[17:02:48.238]                   }
[17:02:48.238]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.238]                     cond$call), session = sessionInformation(), 
[17:02:48.238]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.238]                   signalCondition(cond)
[17:02:48.238]                 }
[17:02:48.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.238]                 "immediateCondition"))) {
[17:02:48.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.238]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.238]                   if (TRUE && !signal) {
[17:02:48.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.238]                     {
[17:02:48.238]                       inherits <- base::inherits
[17:02:48.238]                       invokeRestart <- base::invokeRestart
[17:02:48.238]                       is.null <- base::is.null
[17:02:48.238]                       muffled <- FALSE
[17:02:48.238]                       if (inherits(cond, "message")) {
[17:02:48.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.238]                         if (muffled) 
[17:02:48.238]                           invokeRestart("muffleMessage")
[17:02:48.238]                       }
[17:02:48.238]                       else if (inherits(cond, "warning")) {
[17:02:48.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.238]                         if (muffled) 
[17:02:48.238]                           invokeRestart("muffleWarning")
[17:02:48.238]                       }
[17:02:48.238]                       else if (inherits(cond, "condition")) {
[17:02:48.238]                         if (!is.null(pattern)) {
[17:02:48.238]                           computeRestarts <- base::computeRestarts
[17:02:48.238]                           grepl <- base::grepl
[17:02:48.238]                           restarts <- computeRestarts(cond)
[17:02:48.238]                           for (restart in restarts) {
[17:02:48.238]                             name <- restart$name
[17:02:48.238]                             if (is.null(name)) 
[17:02:48.238]                               next
[17:02:48.238]                             if (!grepl(pattern, name)) 
[17:02:48.238]                               next
[17:02:48.238]                             invokeRestart(restart)
[17:02:48.238]                             muffled <- TRUE
[17:02:48.238]                             break
[17:02:48.238]                           }
[17:02:48.238]                         }
[17:02:48.238]                       }
[17:02:48.238]                       invisible(muffled)
[17:02:48.238]                     }
[17:02:48.238]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.238]                   }
[17:02:48.238]                 }
[17:02:48.238]                 else {
[17:02:48.238]                   if (TRUE) {
[17:02:48.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.238]                     {
[17:02:48.238]                       inherits <- base::inherits
[17:02:48.238]                       invokeRestart <- base::invokeRestart
[17:02:48.238]                       is.null <- base::is.null
[17:02:48.238]                       muffled <- FALSE
[17:02:48.238]                       if (inherits(cond, "message")) {
[17:02:48.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.238]                         if (muffled) 
[17:02:48.238]                           invokeRestart("muffleMessage")
[17:02:48.238]                       }
[17:02:48.238]                       else if (inherits(cond, "warning")) {
[17:02:48.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.238]                         if (muffled) 
[17:02:48.238]                           invokeRestart("muffleWarning")
[17:02:48.238]                       }
[17:02:48.238]                       else if (inherits(cond, "condition")) {
[17:02:48.238]                         if (!is.null(pattern)) {
[17:02:48.238]                           computeRestarts <- base::computeRestarts
[17:02:48.238]                           grepl <- base::grepl
[17:02:48.238]                           restarts <- computeRestarts(cond)
[17:02:48.238]                           for (restart in restarts) {
[17:02:48.238]                             name <- restart$name
[17:02:48.238]                             if (is.null(name)) 
[17:02:48.238]                               next
[17:02:48.238]                             if (!grepl(pattern, name)) 
[17:02:48.238]                               next
[17:02:48.238]                             invokeRestart(restart)
[17:02:48.238]                             muffled <- TRUE
[17:02:48.238]                             break
[17:02:48.238]                           }
[17:02:48.238]                         }
[17:02:48.238]                       }
[17:02:48.238]                       invisible(muffled)
[17:02:48.238]                     }
[17:02:48.238]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.238]                   }
[17:02:48.238]                 }
[17:02:48.238]             }
[17:02:48.238]         }))
[17:02:48.238]     }, error = function(ex) {
[17:02:48.238]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.238]                 ...future.rng), started = ...future.startTime, 
[17:02:48.238]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.238]             version = "1.8"), class = "FutureResult")
[17:02:48.238]     }, finally = {
[17:02:48.238]         if (!identical(...future.workdir, getwd())) 
[17:02:48.238]             setwd(...future.workdir)
[17:02:48.238]         {
[17:02:48.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.238]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.238]             }
[17:02:48.238]             base::options(...future.oldOptions)
[17:02:48.238]             if (.Platform$OS.type == "windows") {
[17:02:48.238]                 old_names <- names(...future.oldEnvVars)
[17:02:48.238]                 envs <- base::Sys.getenv()
[17:02:48.238]                 names <- names(envs)
[17:02:48.238]                 common <- intersect(names, old_names)
[17:02:48.238]                 added <- setdiff(names, old_names)
[17:02:48.238]                 removed <- setdiff(old_names, names)
[17:02:48.238]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.238]                   envs[common]]
[17:02:48.238]                 NAMES <- toupper(changed)
[17:02:48.238]                 args <- list()
[17:02:48.238]                 for (kk in seq_along(NAMES)) {
[17:02:48.238]                   name <- changed[[kk]]
[17:02:48.238]                   NAME <- NAMES[[kk]]
[17:02:48.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.238]                     next
[17:02:48.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.238]                 }
[17:02:48.238]                 NAMES <- toupper(added)
[17:02:48.238]                 for (kk in seq_along(NAMES)) {
[17:02:48.238]                   name <- added[[kk]]
[17:02:48.238]                   NAME <- NAMES[[kk]]
[17:02:48.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.238]                     next
[17:02:48.238]                   args[[name]] <- ""
[17:02:48.238]                 }
[17:02:48.238]                 NAMES <- toupper(removed)
[17:02:48.238]                 for (kk in seq_along(NAMES)) {
[17:02:48.238]                   name <- removed[[kk]]
[17:02:48.238]                   NAME <- NAMES[[kk]]
[17:02:48.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.238]                     next
[17:02:48.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.238]                 }
[17:02:48.238]                 if (length(args) > 0) 
[17:02:48.238]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.238]             }
[17:02:48.238]             else {
[17:02:48.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.238]             }
[17:02:48.238]             {
[17:02:48.238]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.238]                   0L) {
[17:02:48.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.238]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.238]                   base::options(opts)
[17:02:48.238]                 }
[17:02:48.238]                 {
[17:02:48.238]                   {
[17:02:48.238]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.238]                     NULL
[17:02:48.238]                   }
[17:02:48.238]                   options(future.plan = NULL)
[17:02:48.238]                   if (is.na(NA_character_)) 
[17:02:48.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.238]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.238]                     .init = FALSE)
[17:02:48.238]                 }
[17:02:48.238]             }
[17:02:48.238]         }
[17:02:48.238]     })
[17:02:48.238]     if (TRUE) {
[17:02:48.238]         base::sink(type = "output", split = FALSE)
[17:02:48.238]         if (TRUE) {
[17:02:48.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.238]         }
[17:02:48.238]         else {
[17:02:48.238]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.238]         }
[17:02:48.238]         base::close(...future.stdout)
[17:02:48.238]         ...future.stdout <- NULL
[17:02:48.238]     }
[17:02:48.238]     ...future.result$conditions <- ...future.conditions
[17:02:48.238]     ...future.result$finished <- base::Sys.time()
[17:02:48.238]     ...future.result
[17:02:48.238] }
[17:02:48.241] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.241] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.241] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.241] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.242] MultisessionFuture started
[17:02:48.242] - Launch lazy future ... done
[17:02:48.242] run() for ‘MultisessionFuture’ ... done
[17:02:48.242] result() for ClusterFuture ...
[17:02:48.242] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.242] - Validating connection of MultisessionFuture
[17:02:48.243] - received message: FutureResult
[17:02:48.244] - Received FutureResult
[17:02:48.244] - Erased future from FutureRegistry
[17:02:48.244] result() for ClusterFuture ...
[17:02:48.244] - result already collected: FutureResult
[17:02:48.244] result() for ClusterFuture ... done
[17:02:48.244] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.244] result() for ClusterFuture ... done
[17:02:48.244] result() for ClusterFuture ...
[17:02:48.244] - result already collected: FutureResult
[17:02:48.244] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.245] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.245] Searching for globals...
[17:02:48.247] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:48.247] Searching for globals ... DONE
[17:02:48.247] Resolving globals: TRUE
[17:02:48.248] Resolving any globals that are futures ...
[17:02:48.248] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[17:02:48.248] Resolving any globals that are futures ... DONE
[17:02:48.248] Resolving futures part of globals (recursively) ...
[17:02:48.248] resolve() on list ...
[17:02:48.248]  recursive: 99
[17:02:48.249]  length: 1
[17:02:48.249]  elements: ‘x’
[17:02:48.249]  length: 0 (resolved future 1)
[17:02:48.249] resolve() on list ... DONE
[17:02:48.249] - globals: [1] ‘x’
[17:02:48.249] Resolving futures part of globals (recursively) ... DONE
[17:02:48.249] The total size of the 1 globals is 0 bytes (0 bytes)
[17:02:48.249] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[17:02:48.250] - globals: [1] ‘x’
[17:02:48.250] 
[17:02:48.250] getGlobalsAndPackages() ... DONE
[17:02:48.250] run() for ‘Future’ ...
[17:02:48.250] - state: ‘created’
[17:02:48.250] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.264] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.264]   - Field: ‘node’
[17:02:48.265]   - Field: ‘label’
[17:02:48.265]   - Field: ‘local’
[17:02:48.265]   - Field: ‘owner’
[17:02:48.265]   - Field: ‘envir’
[17:02:48.265]   - Field: ‘workers’
[17:02:48.265]   - Field: ‘packages’
[17:02:48.265]   - Field: ‘gc’
[17:02:48.265]   - Field: ‘conditions’
[17:02:48.265]   - Field: ‘persistent’
[17:02:48.265]   - Field: ‘expr’
[17:02:48.266]   - Field: ‘uuid’
[17:02:48.266]   - Field: ‘seed’
[17:02:48.266]   - Field: ‘version’
[17:02:48.266]   - Field: ‘result’
[17:02:48.266]   - Field: ‘asynchronous’
[17:02:48.266]   - Field: ‘calls’
[17:02:48.266]   - Field: ‘globals’
[17:02:48.266]   - Field: ‘stdout’
[17:02:48.266]   - Field: ‘earlySignal’
[17:02:48.266]   - Field: ‘lazy’
[17:02:48.266]   - Field: ‘state’
[17:02:48.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.267] - Launch lazy future ...
[17:02:48.267] Packages needed by the future expression (n = 0): <none>
[17:02:48.267] Packages needed by future strategies (n = 0): <none>
[17:02:48.267] {
[17:02:48.267]     {
[17:02:48.267]         {
[17:02:48.267]             ...future.startTime <- base::Sys.time()
[17:02:48.267]             {
[17:02:48.267]                 {
[17:02:48.267]                   {
[17:02:48.267]                     {
[17:02:48.267]                       base::local({
[17:02:48.267]                         has_future <- base::requireNamespace("future", 
[17:02:48.267]                           quietly = TRUE)
[17:02:48.267]                         if (has_future) {
[17:02:48.267]                           ns <- base::getNamespace("future")
[17:02:48.267]                           version <- ns[[".package"]][["version"]]
[17:02:48.267]                           if (is.null(version)) 
[17:02:48.267]                             version <- utils::packageVersion("future")
[17:02:48.267]                         }
[17:02:48.267]                         else {
[17:02:48.267]                           version <- NULL
[17:02:48.267]                         }
[17:02:48.267]                         if (!has_future || version < "1.8.0") {
[17:02:48.267]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.267]                             "", base::R.version$version.string), 
[17:02:48.267]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.267]                               "release", "version")], collapse = " "), 
[17:02:48.267]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.267]                             info)
[17:02:48.267]                           info <- base::paste(info, collapse = "; ")
[17:02:48.267]                           if (!has_future) {
[17:02:48.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.267]                               info)
[17:02:48.267]                           }
[17:02:48.267]                           else {
[17:02:48.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.267]                               info, version)
[17:02:48.267]                           }
[17:02:48.267]                           base::stop(msg)
[17:02:48.267]                         }
[17:02:48.267]                       })
[17:02:48.267]                     }
[17:02:48.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.267]                     base::options(mc.cores = 1L)
[17:02:48.267]                   }
[17:02:48.267]                   ...future.strategy.old <- future::plan("list")
[17:02:48.267]                   options(future.plan = NULL)
[17:02:48.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.267]                 }
[17:02:48.267]                 ...future.workdir <- getwd()
[17:02:48.267]             }
[17:02:48.267]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.267]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.267]         }
[17:02:48.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.267]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.267]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.267]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.267]             base::names(...future.oldOptions))
[17:02:48.267]     }
[17:02:48.267]     if (FALSE) {
[17:02:48.267]     }
[17:02:48.267]     else {
[17:02:48.267]         if (TRUE) {
[17:02:48.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.267]                 open = "w")
[17:02:48.267]         }
[17:02:48.267]         else {
[17:02:48.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.267]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.267]         }
[17:02:48.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.267]             base::sink(type = "output", split = FALSE)
[17:02:48.267]             base::close(...future.stdout)
[17:02:48.267]         }, add = TRUE)
[17:02:48.267]     }
[17:02:48.267]     ...future.frame <- base::sys.nframe()
[17:02:48.267]     ...future.conditions <- base::list()
[17:02:48.267]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.267]     if (FALSE) {
[17:02:48.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.267]     }
[17:02:48.267]     ...future.result <- base::tryCatch({
[17:02:48.267]         base::withCallingHandlers({
[17:02:48.267]             ...future.value <- base::withVisible(base::local({
[17:02:48.267]                 ...future.makeSendCondition <- base::local({
[17:02:48.267]                   sendCondition <- NULL
[17:02:48.267]                   function(frame = 1L) {
[17:02:48.267]                     if (is.function(sendCondition)) 
[17:02:48.267]                       return(sendCondition)
[17:02:48.267]                     ns <- getNamespace("parallel")
[17:02:48.267]                     if (exists("sendData", mode = "function", 
[17:02:48.267]                       envir = ns)) {
[17:02:48.267]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.267]                         envir = ns)
[17:02:48.267]                       envir <- sys.frame(frame)
[17:02:48.267]                       master <- NULL
[17:02:48.267]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.267]                         !identical(envir, emptyenv())) {
[17:02:48.267]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.267]                           inherits = FALSE)) {
[17:02:48.267]                           master <- get("master", mode = "list", 
[17:02:48.267]                             envir = envir, inherits = FALSE)
[17:02:48.267]                           if (inherits(master, c("SOCKnode", 
[17:02:48.267]                             "SOCK0node"))) {
[17:02:48.267]                             sendCondition <<- function(cond) {
[17:02:48.267]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.267]                                 success = TRUE)
[17:02:48.267]                               parallel_sendData(master, data)
[17:02:48.267]                             }
[17:02:48.267]                             return(sendCondition)
[17:02:48.267]                           }
[17:02:48.267]                         }
[17:02:48.267]                         frame <- frame + 1L
[17:02:48.267]                         envir <- sys.frame(frame)
[17:02:48.267]                       }
[17:02:48.267]                     }
[17:02:48.267]                     sendCondition <<- function(cond) NULL
[17:02:48.267]                   }
[17:02:48.267]                 })
[17:02:48.267]                 withCallingHandlers({
[17:02:48.267]                   {
[17:02:48.267]                     x["a"] <- list(1)
[17:02:48.267]                     x
[17:02:48.267]                   }
[17:02:48.267]                 }, immediateCondition = function(cond) {
[17:02:48.267]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.267]                   sendCondition(cond)
[17:02:48.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.267]                   {
[17:02:48.267]                     inherits <- base::inherits
[17:02:48.267]                     invokeRestart <- base::invokeRestart
[17:02:48.267]                     is.null <- base::is.null
[17:02:48.267]                     muffled <- FALSE
[17:02:48.267]                     if (inherits(cond, "message")) {
[17:02:48.267]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.267]                       if (muffled) 
[17:02:48.267]                         invokeRestart("muffleMessage")
[17:02:48.267]                     }
[17:02:48.267]                     else if (inherits(cond, "warning")) {
[17:02:48.267]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.267]                       if (muffled) 
[17:02:48.267]                         invokeRestart("muffleWarning")
[17:02:48.267]                     }
[17:02:48.267]                     else if (inherits(cond, "condition")) {
[17:02:48.267]                       if (!is.null(pattern)) {
[17:02:48.267]                         computeRestarts <- base::computeRestarts
[17:02:48.267]                         grepl <- base::grepl
[17:02:48.267]                         restarts <- computeRestarts(cond)
[17:02:48.267]                         for (restart in restarts) {
[17:02:48.267]                           name <- restart$name
[17:02:48.267]                           if (is.null(name)) 
[17:02:48.267]                             next
[17:02:48.267]                           if (!grepl(pattern, name)) 
[17:02:48.267]                             next
[17:02:48.267]                           invokeRestart(restart)
[17:02:48.267]                           muffled <- TRUE
[17:02:48.267]                           break
[17:02:48.267]                         }
[17:02:48.267]                       }
[17:02:48.267]                     }
[17:02:48.267]                     invisible(muffled)
[17:02:48.267]                   }
[17:02:48.267]                   muffleCondition(cond)
[17:02:48.267]                 })
[17:02:48.267]             }))
[17:02:48.267]             future::FutureResult(value = ...future.value$value, 
[17:02:48.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.267]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.267]                     ...future.globalenv.names))
[17:02:48.267]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.267]         }, condition = base::local({
[17:02:48.267]             c <- base::c
[17:02:48.267]             inherits <- base::inherits
[17:02:48.267]             invokeRestart <- base::invokeRestart
[17:02:48.267]             length <- base::length
[17:02:48.267]             list <- base::list
[17:02:48.267]             seq.int <- base::seq.int
[17:02:48.267]             signalCondition <- base::signalCondition
[17:02:48.267]             sys.calls <- base::sys.calls
[17:02:48.267]             `[[` <- base::`[[`
[17:02:48.267]             `+` <- base::`+`
[17:02:48.267]             `<<-` <- base::`<<-`
[17:02:48.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.267]                   3L)]
[17:02:48.267]             }
[17:02:48.267]             function(cond) {
[17:02:48.267]                 is_error <- inherits(cond, "error")
[17:02:48.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.267]                   NULL)
[17:02:48.267]                 if (is_error) {
[17:02:48.267]                   sessionInformation <- function() {
[17:02:48.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.267]                       search = base::search(), system = base::Sys.info())
[17:02:48.267]                   }
[17:02:48.267]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.267]                     cond$call), session = sessionInformation(), 
[17:02:48.267]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.267]                   signalCondition(cond)
[17:02:48.267]                 }
[17:02:48.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.267]                 "immediateCondition"))) {
[17:02:48.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.267]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.267]                   if (TRUE && !signal) {
[17:02:48.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.267]                     {
[17:02:48.267]                       inherits <- base::inherits
[17:02:48.267]                       invokeRestart <- base::invokeRestart
[17:02:48.267]                       is.null <- base::is.null
[17:02:48.267]                       muffled <- FALSE
[17:02:48.267]                       if (inherits(cond, "message")) {
[17:02:48.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.267]                         if (muffled) 
[17:02:48.267]                           invokeRestart("muffleMessage")
[17:02:48.267]                       }
[17:02:48.267]                       else if (inherits(cond, "warning")) {
[17:02:48.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.267]                         if (muffled) 
[17:02:48.267]                           invokeRestart("muffleWarning")
[17:02:48.267]                       }
[17:02:48.267]                       else if (inherits(cond, "condition")) {
[17:02:48.267]                         if (!is.null(pattern)) {
[17:02:48.267]                           computeRestarts <- base::computeRestarts
[17:02:48.267]                           grepl <- base::grepl
[17:02:48.267]                           restarts <- computeRestarts(cond)
[17:02:48.267]                           for (restart in restarts) {
[17:02:48.267]                             name <- restart$name
[17:02:48.267]                             if (is.null(name)) 
[17:02:48.267]                               next
[17:02:48.267]                             if (!grepl(pattern, name)) 
[17:02:48.267]                               next
[17:02:48.267]                             invokeRestart(restart)
[17:02:48.267]                             muffled <- TRUE
[17:02:48.267]                             break
[17:02:48.267]                           }
[17:02:48.267]                         }
[17:02:48.267]                       }
[17:02:48.267]                       invisible(muffled)
[17:02:48.267]                     }
[17:02:48.267]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.267]                   }
[17:02:48.267]                 }
[17:02:48.267]                 else {
[17:02:48.267]                   if (TRUE) {
[17:02:48.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.267]                     {
[17:02:48.267]                       inherits <- base::inherits
[17:02:48.267]                       invokeRestart <- base::invokeRestart
[17:02:48.267]                       is.null <- base::is.null
[17:02:48.267]                       muffled <- FALSE
[17:02:48.267]                       if (inherits(cond, "message")) {
[17:02:48.267]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.267]                         if (muffled) 
[17:02:48.267]                           invokeRestart("muffleMessage")
[17:02:48.267]                       }
[17:02:48.267]                       else if (inherits(cond, "warning")) {
[17:02:48.267]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.267]                         if (muffled) 
[17:02:48.267]                           invokeRestart("muffleWarning")
[17:02:48.267]                       }
[17:02:48.267]                       else if (inherits(cond, "condition")) {
[17:02:48.267]                         if (!is.null(pattern)) {
[17:02:48.267]                           computeRestarts <- base::computeRestarts
[17:02:48.267]                           grepl <- base::grepl
[17:02:48.267]                           restarts <- computeRestarts(cond)
[17:02:48.267]                           for (restart in restarts) {
[17:02:48.267]                             name <- restart$name
[17:02:48.267]                             if (is.null(name)) 
[17:02:48.267]                               next
[17:02:48.267]                             if (!grepl(pattern, name)) 
[17:02:48.267]                               next
[17:02:48.267]                             invokeRestart(restart)
[17:02:48.267]                             muffled <- TRUE
[17:02:48.267]                             break
[17:02:48.267]                           }
[17:02:48.267]                         }
[17:02:48.267]                       }
[17:02:48.267]                       invisible(muffled)
[17:02:48.267]                     }
[17:02:48.267]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.267]                   }
[17:02:48.267]                 }
[17:02:48.267]             }
[17:02:48.267]         }))
[17:02:48.267]     }, error = function(ex) {
[17:02:48.267]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.267]                 ...future.rng), started = ...future.startTime, 
[17:02:48.267]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.267]             version = "1.8"), class = "FutureResult")
[17:02:48.267]     }, finally = {
[17:02:48.267]         if (!identical(...future.workdir, getwd())) 
[17:02:48.267]             setwd(...future.workdir)
[17:02:48.267]         {
[17:02:48.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.267]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.267]             }
[17:02:48.267]             base::options(...future.oldOptions)
[17:02:48.267]             if (.Platform$OS.type == "windows") {
[17:02:48.267]                 old_names <- names(...future.oldEnvVars)
[17:02:48.267]                 envs <- base::Sys.getenv()
[17:02:48.267]                 names <- names(envs)
[17:02:48.267]                 common <- intersect(names, old_names)
[17:02:48.267]                 added <- setdiff(names, old_names)
[17:02:48.267]                 removed <- setdiff(old_names, names)
[17:02:48.267]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.267]                   envs[common]]
[17:02:48.267]                 NAMES <- toupper(changed)
[17:02:48.267]                 args <- list()
[17:02:48.267]                 for (kk in seq_along(NAMES)) {
[17:02:48.267]                   name <- changed[[kk]]
[17:02:48.267]                   NAME <- NAMES[[kk]]
[17:02:48.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.267]                     next
[17:02:48.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.267]                 }
[17:02:48.267]                 NAMES <- toupper(added)
[17:02:48.267]                 for (kk in seq_along(NAMES)) {
[17:02:48.267]                   name <- added[[kk]]
[17:02:48.267]                   NAME <- NAMES[[kk]]
[17:02:48.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.267]                     next
[17:02:48.267]                   args[[name]] <- ""
[17:02:48.267]                 }
[17:02:48.267]                 NAMES <- toupper(removed)
[17:02:48.267]                 for (kk in seq_along(NAMES)) {
[17:02:48.267]                   name <- removed[[kk]]
[17:02:48.267]                   NAME <- NAMES[[kk]]
[17:02:48.267]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.267]                     next
[17:02:48.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.267]                 }
[17:02:48.267]                 if (length(args) > 0) 
[17:02:48.267]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.267]             }
[17:02:48.267]             else {
[17:02:48.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.267]             }
[17:02:48.267]             {
[17:02:48.267]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.267]                   0L) {
[17:02:48.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.267]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.267]                   base::options(opts)
[17:02:48.267]                 }
[17:02:48.267]                 {
[17:02:48.267]                   {
[17:02:48.267]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.267]                     NULL
[17:02:48.267]                   }
[17:02:48.267]                   options(future.plan = NULL)
[17:02:48.267]                   if (is.na(NA_character_)) 
[17:02:48.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.267]                     .init = FALSE)
[17:02:48.267]                 }
[17:02:48.267]             }
[17:02:48.267]         }
[17:02:48.267]     })
[17:02:48.267]     if (TRUE) {
[17:02:48.267]         base::sink(type = "output", split = FALSE)
[17:02:48.267]         if (TRUE) {
[17:02:48.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.267]         }
[17:02:48.267]         else {
[17:02:48.267]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.267]         }
[17:02:48.267]         base::close(...future.stdout)
[17:02:48.267]         ...future.stdout <- NULL
[17:02:48.267]     }
[17:02:48.267]     ...future.result$conditions <- ...future.conditions
[17:02:48.267]     ...future.result$finished <- base::Sys.time()
[17:02:48.267]     ...future.result
[17:02:48.267] }
[17:02:48.270] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[17:02:48.270] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.271] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.271] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[17:02:48.271] MultisessionFuture started
[17:02:48.271] - Launch lazy future ... done
[17:02:48.272] run() for ‘MultisessionFuture’ ... done
[17:02:48.272] result() for ClusterFuture ...
[17:02:48.272] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.272] - Validating connection of MultisessionFuture
[17:02:48.273] - received message: FutureResult
[17:02:48.273] - Received FutureResult
[17:02:48.274] - Erased future from FutureRegistry
[17:02:48.274] result() for ClusterFuture ...
[17:02:48.274] - result already collected: FutureResult
[17:02:48.274] result() for ClusterFuture ... done
[17:02:48.274] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.274] result() for ClusterFuture ... done
[17:02:48.274] result() for ClusterFuture ...
[17:02:48.274] - result already collected: FutureResult
[17:02:48.274] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:02:48.275] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:02:48.275] Searching for globals...
[17:02:48.277] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:02:48.277] Searching for globals ... DONE
[17:02:48.277] Resolving globals: TRUE
[17:02:48.277] Resolving any globals that are futures ...
[17:02:48.277] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[17:02:48.278] Resolving any globals that are futures ... DONE
[17:02:48.278] Resolving futures part of globals (recursively) ...
[17:02:48.278] resolve() on list ...
[17:02:48.278]  recursive: 99
[17:02:48.278]  length: 2
[17:02:48.279]  elements: ‘x’, ‘name’
[17:02:48.279]  length: 1 (resolved future 1)
[17:02:48.279]  length: 0 (resolved future 2)
[17:02:48.279] resolve() on list ... DONE
[17:02:48.279] - globals: [2] ‘x’, ‘name’
[17:02:48.279] Resolving futures part of globals (recursively) ... DONE
[17:02:48.279] The total size of the 2 globals is 112 bytes (112 bytes)
[17:02:48.280] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[17:02:48.280] - globals: [2] ‘x’, ‘name’
[17:02:48.280] 
[17:02:48.280] getGlobalsAndPackages() ... DONE
[17:02:48.280] run() for ‘Future’ ...
[17:02:48.280] - state: ‘created’
[17:02:48.280] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:02:48.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:02:48.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:02:48.294]   - Field: ‘node’
[17:02:48.294]   - Field: ‘label’
[17:02:48.295]   - Field: ‘local’
[17:02:48.295]   - Field: ‘owner’
[17:02:48.295]   - Field: ‘envir’
[17:02:48.295]   - Field: ‘workers’
[17:02:48.295]   - Field: ‘packages’
[17:02:48.295]   - Field: ‘gc’
[17:02:48.295]   - Field: ‘conditions’
[17:02:48.295]   - Field: ‘persistent’
[17:02:48.295]   - Field: ‘expr’
[17:02:48.295]   - Field: ‘uuid’
[17:02:48.296]   - Field: ‘seed’
[17:02:48.296]   - Field: ‘version’
[17:02:48.296]   - Field: ‘result’
[17:02:48.296]   - Field: ‘asynchronous’
[17:02:48.296]   - Field: ‘calls’
[17:02:48.296]   - Field: ‘globals’
[17:02:48.296]   - Field: ‘stdout’
[17:02:48.296]   - Field: ‘earlySignal’
[17:02:48.296]   - Field: ‘lazy’
[17:02:48.296]   - Field: ‘state’
[17:02:48.296] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:02:48.297] - Launch lazy future ...
[17:02:48.297] Packages needed by the future expression (n = 0): <none>
[17:02:48.297] Packages needed by future strategies (n = 0): <none>
[17:02:48.297] {
[17:02:48.297]     {
[17:02:48.297]         {
[17:02:48.297]             ...future.startTime <- base::Sys.time()
[17:02:48.297]             {
[17:02:48.297]                 {
[17:02:48.297]                   {
[17:02:48.297]                     {
[17:02:48.297]                       base::local({
[17:02:48.297]                         has_future <- base::requireNamespace("future", 
[17:02:48.297]                           quietly = TRUE)
[17:02:48.297]                         if (has_future) {
[17:02:48.297]                           ns <- base::getNamespace("future")
[17:02:48.297]                           version <- ns[[".package"]][["version"]]
[17:02:48.297]                           if (is.null(version)) 
[17:02:48.297]                             version <- utils::packageVersion("future")
[17:02:48.297]                         }
[17:02:48.297]                         else {
[17:02:48.297]                           version <- NULL
[17:02:48.297]                         }
[17:02:48.297]                         if (!has_future || version < "1.8.0") {
[17:02:48.297]                           info <- base::c(r_version = base::gsub("R version ", 
[17:02:48.297]                             "", base::R.version$version.string), 
[17:02:48.297]                             platform = base::sprintf("%s (%s-bit)", 
[17:02:48.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:02:48.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:02:48.297]                               "release", "version")], collapse = " "), 
[17:02:48.297]                             hostname = base::Sys.info()[["nodename"]])
[17:02:48.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:02:48.297]                             info)
[17:02:48.297]                           info <- base::paste(info, collapse = "; ")
[17:02:48.297]                           if (!has_future) {
[17:02:48.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:02:48.297]                               info)
[17:02:48.297]                           }
[17:02:48.297]                           else {
[17:02:48.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:02:48.297]                               info, version)
[17:02:48.297]                           }
[17:02:48.297]                           base::stop(msg)
[17:02:48.297]                         }
[17:02:48.297]                       })
[17:02:48.297]                     }
[17:02:48.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:02:48.297]                     base::options(mc.cores = 1L)
[17:02:48.297]                   }
[17:02:48.297]                   ...future.strategy.old <- future::plan("list")
[17:02:48.297]                   options(future.plan = NULL)
[17:02:48.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:02:48.297]                 }
[17:02:48.297]                 ...future.workdir <- getwd()
[17:02:48.297]             }
[17:02:48.297]             ...future.oldOptions <- base::as.list(base::.Options)
[17:02:48.297]             ...future.oldEnvVars <- base::Sys.getenv()
[17:02:48.297]         }
[17:02:48.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:02:48.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:02:48.297]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:02:48.297]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:02:48.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:02:48.297]             future.stdout.windows.reencode = NULL, width = 80L)
[17:02:48.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:02:48.297]             base::names(...future.oldOptions))
[17:02:48.297]     }
[17:02:48.297]     if (FALSE) {
[17:02:48.297]     }
[17:02:48.297]     else {
[17:02:48.297]         if (TRUE) {
[17:02:48.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:02:48.297]                 open = "w")
[17:02:48.297]         }
[17:02:48.297]         else {
[17:02:48.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:02:48.297]                 windows = "NUL", "/dev/null"), open = "w")
[17:02:48.297]         }
[17:02:48.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:02:48.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:02:48.297]             base::sink(type = "output", split = FALSE)
[17:02:48.297]             base::close(...future.stdout)
[17:02:48.297]         }, add = TRUE)
[17:02:48.297]     }
[17:02:48.297]     ...future.frame <- base::sys.nframe()
[17:02:48.297]     ...future.conditions <- base::list()
[17:02:48.297]     ...future.rng <- base::globalenv()$.Random.seed
[17:02:48.297]     if (FALSE) {
[17:02:48.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:02:48.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:02:48.297]     }
[17:02:48.297]     ...future.result <- base::tryCatch({
[17:02:48.297]         base::withCallingHandlers({
[17:02:48.297]             ...future.value <- base::withVisible(base::local({
[17:02:48.297]                 ...future.makeSendCondition <- base::local({
[17:02:48.297]                   sendCondition <- NULL
[17:02:48.297]                   function(frame = 1L) {
[17:02:48.297]                     if (is.function(sendCondition)) 
[17:02:48.297]                       return(sendCondition)
[17:02:48.297]                     ns <- getNamespace("parallel")
[17:02:48.297]                     if (exists("sendData", mode = "function", 
[17:02:48.297]                       envir = ns)) {
[17:02:48.297]                       parallel_sendData <- get("sendData", mode = "function", 
[17:02:48.297]                         envir = ns)
[17:02:48.297]                       envir <- sys.frame(frame)
[17:02:48.297]                       master <- NULL
[17:02:48.297]                       while (!identical(envir, .GlobalEnv) && 
[17:02:48.297]                         !identical(envir, emptyenv())) {
[17:02:48.297]                         if (exists("master", mode = "list", envir = envir, 
[17:02:48.297]                           inherits = FALSE)) {
[17:02:48.297]                           master <- get("master", mode = "list", 
[17:02:48.297]                             envir = envir, inherits = FALSE)
[17:02:48.297]                           if (inherits(master, c("SOCKnode", 
[17:02:48.297]                             "SOCK0node"))) {
[17:02:48.297]                             sendCondition <<- function(cond) {
[17:02:48.297]                               data <- list(type = "VALUE", value = cond, 
[17:02:48.297]                                 success = TRUE)
[17:02:48.297]                               parallel_sendData(master, data)
[17:02:48.297]                             }
[17:02:48.297]                             return(sendCondition)
[17:02:48.297]                           }
[17:02:48.297]                         }
[17:02:48.297]                         frame <- frame + 1L
[17:02:48.297]                         envir <- sys.frame(frame)
[17:02:48.297]                       }
[17:02:48.297]                     }
[17:02:48.297]                     sendCondition <<- function(cond) NULL
[17:02:48.297]                   }
[17:02:48.297]                 })
[17:02:48.297]                 withCallingHandlers({
[17:02:48.297]                   {
[17:02:48.297]                     x[name] <- list(1)
[17:02:48.297]                     x
[17:02:48.297]                   }
[17:02:48.297]                 }, immediateCondition = function(cond) {
[17:02:48.297]                   sendCondition <- ...future.makeSendCondition()
[17:02:48.297]                   sendCondition(cond)
[17:02:48.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.297]                   {
[17:02:48.297]                     inherits <- base::inherits
[17:02:48.297]                     invokeRestart <- base::invokeRestart
[17:02:48.297]                     is.null <- base::is.null
[17:02:48.297]                     muffled <- FALSE
[17:02:48.297]                     if (inherits(cond, "message")) {
[17:02:48.297]                       muffled <- grepl(pattern, "muffleMessage")
[17:02:48.297]                       if (muffled) 
[17:02:48.297]                         invokeRestart("muffleMessage")
[17:02:48.297]                     }
[17:02:48.297]                     else if (inherits(cond, "warning")) {
[17:02:48.297]                       muffled <- grepl(pattern, "muffleWarning")
[17:02:48.297]                       if (muffled) 
[17:02:48.297]                         invokeRestart("muffleWarning")
[17:02:48.297]                     }
[17:02:48.297]                     else if (inherits(cond, "condition")) {
[17:02:48.297]                       if (!is.null(pattern)) {
[17:02:48.297]                         computeRestarts <- base::computeRestarts
[17:02:48.297]                         grepl <- base::grepl
[17:02:48.297]                         restarts <- computeRestarts(cond)
[17:02:48.297]                         for (restart in restarts) {
[17:02:48.297]                           name <- restart$name
[17:02:48.297]                           if (is.null(name)) 
[17:02:48.297]                             next
[17:02:48.297]                           if (!grepl(pattern, name)) 
[17:02:48.297]                             next
[17:02:48.297]                           invokeRestart(restart)
[17:02:48.297]                           muffled <- TRUE
[17:02:48.297]                           break
[17:02:48.297]                         }
[17:02:48.297]                       }
[17:02:48.297]                     }
[17:02:48.297]                     invisible(muffled)
[17:02:48.297]                   }
[17:02:48.297]                   muffleCondition(cond)
[17:02:48.297]                 })
[17:02:48.297]             }))
[17:02:48.297]             future::FutureResult(value = ...future.value$value, 
[17:02:48.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.297]                   ...future.rng), globalenv = if (FALSE) 
[17:02:48.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:02:48.297]                     ...future.globalenv.names))
[17:02:48.297]                 else NULL, started = ...future.startTime, version = "1.8")
[17:02:48.297]         }, condition = base::local({
[17:02:48.297]             c <- base::c
[17:02:48.297]             inherits <- base::inherits
[17:02:48.297]             invokeRestart <- base::invokeRestart
[17:02:48.297]             length <- base::length
[17:02:48.297]             list <- base::list
[17:02:48.297]             seq.int <- base::seq.int
[17:02:48.297]             signalCondition <- base::signalCondition
[17:02:48.297]             sys.calls <- base::sys.calls
[17:02:48.297]             `[[` <- base::`[[`
[17:02:48.297]             `+` <- base::`+`
[17:02:48.297]             `<<-` <- base::`<<-`
[17:02:48.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:02:48.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:02:48.297]                   3L)]
[17:02:48.297]             }
[17:02:48.297]             function(cond) {
[17:02:48.297]                 is_error <- inherits(cond, "error")
[17:02:48.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:02:48.297]                   NULL)
[17:02:48.297]                 if (is_error) {
[17:02:48.297]                   sessionInformation <- function() {
[17:02:48.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:02:48.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:02:48.297]                       search = base::search(), system = base::Sys.info())
[17:02:48.297]                   }
[17:02:48.297]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:02:48.297]                     cond$call), session = sessionInformation(), 
[17:02:48.297]                     timestamp = base::Sys.time(), signaled = 0L)
[17:02:48.297]                   signalCondition(cond)
[17:02:48.297]                 }
[17:02:48.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:02:48.297]                 "immediateCondition"))) {
[17:02:48.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:02:48.297]                   ...future.conditions[[length(...future.conditions) + 
[17:02:48.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:02:48.297]                   if (TRUE && !signal) {
[17:02:48.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.297]                     {
[17:02:48.297]                       inherits <- base::inherits
[17:02:48.297]                       invokeRestart <- base::invokeRestart
[17:02:48.297]                       is.null <- base::is.null
[17:02:48.297]                       muffled <- FALSE
[17:02:48.297]                       if (inherits(cond, "message")) {
[17:02:48.297]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.297]                         if (muffled) 
[17:02:48.297]                           invokeRestart("muffleMessage")
[17:02:48.297]                       }
[17:02:48.297]                       else if (inherits(cond, "warning")) {
[17:02:48.297]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.297]                         if (muffled) 
[17:02:48.297]                           invokeRestart("muffleWarning")
[17:02:48.297]                       }
[17:02:48.297]                       else if (inherits(cond, "condition")) {
[17:02:48.297]                         if (!is.null(pattern)) {
[17:02:48.297]                           computeRestarts <- base::computeRestarts
[17:02:48.297]                           grepl <- base::grepl
[17:02:48.297]                           restarts <- computeRestarts(cond)
[17:02:48.297]                           for (restart in restarts) {
[17:02:48.297]                             name <- restart$name
[17:02:48.297]                             if (is.null(name)) 
[17:02:48.297]                               next
[17:02:48.297]                             if (!grepl(pattern, name)) 
[17:02:48.297]                               next
[17:02:48.297]                             invokeRestart(restart)
[17:02:48.297]                             muffled <- TRUE
[17:02:48.297]                             break
[17:02:48.297]                           }
[17:02:48.297]                         }
[17:02:48.297]                       }
[17:02:48.297]                       invisible(muffled)
[17:02:48.297]                     }
[17:02:48.297]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.297]                   }
[17:02:48.297]                 }
[17:02:48.297]                 else {
[17:02:48.297]                   if (TRUE) {
[17:02:48.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:02:48.297]                     {
[17:02:48.297]                       inherits <- base::inherits
[17:02:48.297]                       invokeRestart <- base::invokeRestart
[17:02:48.297]                       is.null <- base::is.null
[17:02:48.297]                       muffled <- FALSE
[17:02:48.297]                       if (inherits(cond, "message")) {
[17:02:48.297]                         muffled <- grepl(pattern, "muffleMessage")
[17:02:48.297]                         if (muffled) 
[17:02:48.297]                           invokeRestart("muffleMessage")
[17:02:48.297]                       }
[17:02:48.297]                       else if (inherits(cond, "warning")) {
[17:02:48.297]                         muffled <- grepl(pattern, "muffleWarning")
[17:02:48.297]                         if (muffled) 
[17:02:48.297]                           invokeRestart("muffleWarning")
[17:02:48.297]                       }
[17:02:48.297]                       else if (inherits(cond, "condition")) {
[17:02:48.297]                         if (!is.null(pattern)) {
[17:02:48.297]                           computeRestarts <- base::computeRestarts
[17:02:48.297]                           grepl <- base::grepl
[17:02:48.297]                           restarts <- computeRestarts(cond)
[17:02:48.297]                           for (restart in restarts) {
[17:02:48.297]                             name <- restart$name
[17:02:48.297]                             if (is.null(name)) 
[17:02:48.297]                               next
[17:02:48.297]                             if (!grepl(pattern, name)) 
[17:02:48.297]                               next
[17:02:48.297]                             invokeRestart(restart)
[17:02:48.297]                             muffled <- TRUE
[17:02:48.297]                             break
[17:02:48.297]                           }
[17:02:48.297]                         }
[17:02:48.297]                       }
[17:02:48.297]                       invisible(muffled)
[17:02:48.297]                     }
[17:02:48.297]                     muffleCondition(cond, pattern = "^muffle")
[17:02:48.297]                   }
[17:02:48.297]                 }
[17:02:48.297]             }
[17:02:48.297]         }))
[17:02:48.297]     }, error = function(ex) {
[17:02:48.297]         base::structure(base::list(value = NULL, visible = NULL, 
[17:02:48.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:02:48.297]                 ...future.rng), started = ...future.startTime, 
[17:02:48.297]             finished = Sys.time(), session_uuid = NA_character_, 
[17:02:48.297]             version = "1.8"), class = "FutureResult")
[17:02:48.297]     }, finally = {
[17:02:48.297]         if (!identical(...future.workdir, getwd())) 
[17:02:48.297]             setwd(...future.workdir)
[17:02:48.297]         {
[17:02:48.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:02:48.297]                 ...future.oldOptions$nwarnings <- NULL
[17:02:48.297]             }
[17:02:48.297]             base::options(...future.oldOptions)
[17:02:48.297]             if (.Platform$OS.type == "windows") {
[17:02:48.297]                 old_names <- names(...future.oldEnvVars)
[17:02:48.297]                 envs <- base::Sys.getenv()
[17:02:48.297]                 names <- names(envs)
[17:02:48.297]                 common <- intersect(names, old_names)
[17:02:48.297]                 added <- setdiff(names, old_names)
[17:02:48.297]                 removed <- setdiff(old_names, names)
[17:02:48.297]                 changed <- common[...future.oldEnvVars[common] != 
[17:02:48.297]                   envs[common]]
[17:02:48.297]                 NAMES <- toupper(changed)
[17:02:48.297]                 args <- list()
[17:02:48.297]                 for (kk in seq_along(NAMES)) {
[17:02:48.297]                   name <- changed[[kk]]
[17:02:48.297]                   NAME <- NAMES[[kk]]
[17:02:48.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.297]                     next
[17:02:48.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.297]                 }
[17:02:48.297]                 NAMES <- toupper(added)
[17:02:48.297]                 for (kk in seq_along(NAMES)) {
[17:02:48.297]                   name <- added[[kk]]
[17:02:48.297]                   NAME <- NAMES[[kk]]
[17:02:48.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.297]                     next
[17:02:48.297]                   args[[name]] <- ""
[17:02:48.297]                 }
[17:02:48.297]                 NAMES <- toupper(removed)
[17:02:48.297]                 for (kk in seq_along(NAMES)) {
[17:02:48.297]                   name <- removed[[kk]]
[17:02:48.297]                   NAME <- NAMES[[kk]]
[17:02:48.297]                   if (name != NAME && is.element(NAME, old_names)) 
[17:02:48.297]                     next
[17:02:48.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:02:48.297]                 }
[17:02:48.297]                 if (length(args) > 0) 
[17:02:48.297]                   base::do.call(base::Sys.setenv, args = args)
[17:02:48.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:02:48.297]             }
[17:02:48.297]             else {
[17:02:48.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:02:48.297]             }
[17:02:48.297]             {
[17:02:48.297]                 if (base::length(...future.futureOptionsAdded) > 
[17:02:48.297]                   0L) {
[17:02:48.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:02:48.297]                   base::names(opts) <- ...future.futureOptionsAdded
[17:02:48.297]                   base::options(opts)
[17:02:48.297]                 }
[17:02:48.297]                 {
[17:02:48.297]                   {
[17:02:48.297]                     base::options(mc.cores = ...future.mc.cores.old)
[17:02:48.297]                     NULL
[17:02:48.297]                   }
[17:02:48.297]                   options(future.plan = NULL)
[17:02:48.297]                   if (is.na(NA_character_)) 
[17:02:48.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:02:48.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:02:48.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:02:48.297]                     .init = FALSE)
[17:02:48.297]                 }
[17:02:48.297]             }
[17:02:48.297]         }
[17:02:48.297]     })
[17:02:48.297]     if (TRUE) {
[17:02:48.297]         base::sink(type = "output", split = FALSE)
[17:02:48.297]         if (TRUE) {
[17:02:48.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:02:48.297]         }
[17:02:48.297]         else {
[17:02:48.297]             ...future.result["stdout"] <- base::list(NULL)
[17:02:48.297]         }
[17:02:48.297]         base::close(...future.stdout)
[17:02:48.297]         ...future.stdout <- NULL
[17:02:48.297]     }
[17:02:48.297]     ...future.result$conditions <- ...future.conditions
[17:02:48.297]     ...future.result$finished <- base::Sys.time()
[17:02:48.297]     ...future.result
[17:02:48.297] }
[17:02:48.300] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:02:48.300] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[17:02:48.300] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[17:02:48.301] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[17:02:48.301] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[17:02:48.301] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:02:48.301] MultisessionFuture started
[17:02:48.302] - Launch lazy future ... done
[17:02:48.302] run() for ‘MultisessionFuture’ ... done
[17:02:48.302] result() for ClusterFuture ...
[17:02:48.302] receiveMessageFromWorker() for ClusterFuture ...
[17:02:48.302] - Validating connection of MultisessionFuture
[17:02:48.303] - received message: FutureResult
[17:02:48.303] - Received FutureResult
[17:02:48.303] - Erased future from FutureRegistry
[17:02:48.303] result() for ClusterFuture ...
[17:02:48.304] - result already collected: FutureResult
[17:02:48.304] result() for ClusterFuture ... done
[17:02:48.304] receiveMessageFromWorker() for ClusterFuture ... done
[17:02:48.304] result() for ClusterFuture ... done
[17:02:48.304] result() for ClusterFuture ...
[17:02:48.304] - result already collected: FutureResult
[17:02:48.304] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[17:02:48.307] plan(): Setting new future strategy stack:
[17:02:48.307] List of future strategies:
[17:02:48.307] 1. FutureStrategy:
[17:02:48.307]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:02:48.307]    - tweaked: FALSE
[17:02:48.307]    - call: future::plan(oplan)
[17:02:48.308] plan(): nbrOfWorkers() = 1
> 
