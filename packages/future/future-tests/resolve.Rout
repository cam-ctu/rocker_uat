
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[18:06:03.282] plan(): Setting new future strategy stack:
[18:06:03.283] List of future strategies:
[18:06:03.283] 1. sequential:
[18:06:03.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.283]    - tweaked: FALSE
[18:06:03.283]    - call: future::plan("sequential")
[18:06:03.307] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[18:06:03.709] plan(): Setting new future strategy stack:
[18:06:03.709] List of future strategies:
[18:06:03.709] 1. sequential:
[18:06:03.709]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.709]    - tweaked: FALSE
[18:06:03.709]    - call: plan(strategy)
[18:06:03.732] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[18:06:03.733] resolve() on list ...
[18:06:03.733]  recursive: 0
[18:06:03.734]  length: 2
[18:06:03.734]  elements: ‘a’, ‘b’
[18:06:03.737]  length: 1 (resolved future 1)
[18:06:03.737]  length: 0 (resolved future 2)
[18:06:03.737] resolve() on list ... DONE
[18:06:03.739] getGlobalsAndPackages() ...
[18:06:03.739] Searching for globals...
[18:06:03.743] 
[18:06:03.743] Searching for globals ... DONE
[18:06:03.744] - globals: [0] <none>
[18:06:03.744] getGlobalsAndPackages() ... DONE
[18:06:03.745] run() for ‘Future’ ...
[18:06:03.745] - state: ‘created’
[18:06:03.746] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.747] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.747]   - Field: ‘label’
[18:06:03.747]   - Field: ‘local’
[18:06:03.748]   - Field: ‘owner’
[18:06:03.748]   - Field: ‘envir’
[18:06:03.748]   - Field: ‘packages’
[18:06:03.748]   - Field: ‘gc’
[18:06:03.748]   - Field: ‘conditions’
[18:06:03.749]   - Field: ‘expr’
[18:06:03.749]   - Field: ‘uuid’
[18:06:03.749]   - Field: ‘seed’
[18:06:03.749]   - Field: ‘version’
[18:06:03.749]   - Field: ‘result’
[18:06:03.750]   - Field: ‘asynchronous’
[18:06:03.750]   - Field: ‘calls’
[18:06:03.750]   - Field: ‘globals’
[18:06:03.750]   - Field: ‘stdout’
[18:06:03.750]   - Field: ‘earlySignal’
[18:06:03.751]   - Field: ‘lazy’
[18:06:03.751]   - Field: ‘state’
[18:06:03.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.751] - Launch lazy future ...
[18:06:03.753] Packages needed by the future expression (n = 0): <none>
[18:06:03.753] Packages needed by future strategies (n = 0): <none>
[18:06:03.755] {
[18:06:03.755]     {
[18:06:03.755]         {
[18:06:03.755]             ...future.startTime <- base::Sys.time()
[18:06:03.755]             {
[18:06:03.755]                 {
[18:06:03.755]                   {
[18:06:03.755]                     base::local({
[18:06:03.755]                       has_future <- base::requireNamespace("future", 
[18:06:03.755]                         quietly = TRUE)
[18:06:03.755]                       if (has_future) {
[18:06:03.755]                         ns <- base::getNamespace("future")
[18:06:03.755]                         version <- ns[[".package"]][["version"]]
[18:06:03.755]                         if (is.null(version)) 
[18:06:03.755]                           version <- utils::packageVersion("future")
[18:06:03.755]                       }
[18:06:03.755]                       else {
[18:06:03.755]                         version <- NULL
[18:06:03.755]                       }
[18:06:03.755]                       if (!has_future || version < "1.8.0") {
[18:06:03.755]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.755]                           "", base::R.version$version.string), 
[18:06:03.755]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.755]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.755]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.755]                             "release", "version")], collapse = " "), 
[18:06:03.755]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.755]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.755]                           info)
[18:06:03.755]                         info <- base::paste(info, collapse = "; ")
[18:06:03.755]                         if (!has_future) {
[18:06:03.755]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.755]                             info)
[18:06:03.755]                         }
[18:06:03.755]                         else {
[18:06:03.755]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.755]                             info, version)
[18:06:03.755]                         }
[18:06:03.755]                         base::stop(msg)
[18:06:03.755]                       }
[18:06:03.755]                     })
[18:06:03.755]                   }
[18:06:03.755]                   ...future.strategy.old <- future::plan("list")
[18:06:03.755]                   options(future.plan = NULL)
[18:06:03.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.755]                 }
[18:06:03.755]                 ...future.workdir <- getwd()
[18:06:03.755]             }
[18:06:03.755]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.755]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.755]         }
[18:06:03.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.755]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.755]             base::names(...future.oldOptions))
[18:06:03.755]     }
[18:06:03.755]     if (FALSE) {
[18:06:03.755]     }
[18:06:03.755]     else {
[18:06:03.755]         if (TRUE) {
[18:06:03.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.755]                 open = "w")
[18:06:03.755]         }
[18:06:03.755]         else {
[18:06:03.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.755]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.755]         }
[18:06:03.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.755]             base::sink(type = "output", split = FALSE)
[18:06:03.755]             base::close(...future.stdout)
[18:06:03.755]         }, add = TRUE)
[18:06:03.755]     }
[18:06:03.755]     ...future.frame <- base::sys.nframe()
[18:06:03.755]     ...future.conditions <- base::list()
[18:06:03.755]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.755]     if (FALSE) {
[18:06:03.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.755]     }
[18:06:03.755]     ...future.result <- base::tryCatch({
[18:06:03.755]         base::withCallingHandlers({
[18:06:03.755]             ...future.value <- base::withVisible(base::local(1))
[18:06:03.755]             future::FutureResult(value = ...future.value$value, 
[18:06:03.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.755]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.755]                     ...future.globalenv.names))
[18:06:03.755]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.755]         }, condition = base::local({
[18:06:03.755]             c <- base::c
[18:06:03.755]             inherits <- base::inherits
[18:06:03.755]             invokeRestart <- base::invokeRestart
[18:06:03.755]             length <- base::length
[18:06:03.755]             list <- base::list
[18:06:03.755]             seq.int <- base::seq.int
[18:06:03.755]             signalCondition <- base::signalCondition
[18:06:03.755]             sys.calls <- base::sys.calls
[18:06:03.755]             `[[` <- base::`[[`
[18:06:03.755]             `+` <- base::`+`
[18:06:03.755]             `<<-` <- base::`<<-`
[18:06:03.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.755]                   3L)]
[18:06:03.755]             }
[18:06:03.755]             function(cond) {
[18:06:03.755]                 is_error <- inherits(cond, "error")
[18:06:03.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.755]                   NULL)
[18:06:03.755]                 if (is_error) {
[18:06:03.755]                   sessionInformation <- function() {
[18:06:03.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.755]                       search = base::search(), system = base::Sys.info())
[18:06:03.755]                   }
[18:06:03.755]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.755]                     cond$call), session = sessionInformation(), 
[18:06:03.755]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.755]                   signalCondition(cond)
[18:06:03.755]                 }
[18:06:03.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.755]                 "immediateCondition"))) {
[18:06:03.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.755]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.755]                   if (TRUE && !signal) {
[18:06:03.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.755]                     {
[18:06:03.755]                       inherits <- base::inherits
[18:06:03.755]                       invokeRestart <- base::invokeRestart
[18:06:03.755]                       is.null <- base::is.null
[18:06:03.755]                       muffled <- FALSE
[18:06:03.755]                       if (inherits(cond, "message")) {
[18:06:03.755]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.755]                         if (muffled) 
[18:06:03.755]                           invokeRestart("muffleMessage")
[18:06:03.755]                       }
[18:06:03.755]                       else if (inherits(cond, "warning")) {
[18:06:03.755]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.755]                         if (muffled) 
[18:06:03.755]                           invokeRestart("muffleWarning")
[18:06:03.755]                       }
[18:06:03.755]                       else if (inherits(cond, "condition")) {
[18:06:03.755]                         if (!is.null(pattern)) {
[18:06:03.755]                           computeRestarts <- base::computeRestarts
[18:06:03.755]                           grepl <- base::grepl
[18:06:03.755]                           restarts <- computeRestarts(cond)
[18:06:03.755]                           for (restart in restarts) {
[18:06:03.755]                             name <- restart$name
[18:06:03.755]                             if (is.null(name)) 
[18:06:03.755]                               next
[18:06:03.755]                             if (!grepl(pattern, name)) 
[18:06:03.755]                               next
[18:06:03.755]                             invokeRestart(restart)
[18:06:03.755]                             muffled <- TRUE
[18:06:03.755]                             break
[18:06:03.755]                           }
[18:06:03.755]                         }
[18:06:03.755]                       }
[18:06:03.755]                       invisible(muffled)
[18:06:03.755]                     }
[18:06:03.755]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.755]                   }
[18:06:03.755]                 }
[18:06:03.755]                 else {
[18:06:03.755]                   if (TRUE) {
[18:06:03.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.755]                     {
[18:06:03.755]                       inherits <- base::inherits
[18:06:03.755]                       invokeRestart <- base::invokeRestart
[18:06:03.755]                       is.null <- base::is.null
[18:06:03.755]                       muffled <- FALSE
[18:06:03.755]                       if (inherits(cond, "message")) {
[18:06:03.755]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.755]                         if (muffled) 
[18:06:03.755]                           invokeRestart("muffleMessage")
[18:06:03.755]                       }
[18:06:03.755]                       else if (inherits(cond, "warning")) {
[18:06:03.755]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.755]                         if (muffled) 
[18:06:03.755]                           invokeRestart("muffleWarning")
[18:06:03.755]                       }
[18:06:03.755]                       else if (inherits(cond, "condition")) {
[18:06:03.755]                         if (!is.null(pattern)) {
[18:06:03.755]                           computeRestarts <- base::computeRestarts
[18:06:03.755]                           grepl <- base::grepl
[18:06:03.755]                           restarts <- computeRestarts(cond)
[18:06:03.755]                           for (restart in restarts) {
[18:06:03.755]                             name <- restart$name
[18:06:03.755]                             if (is.null(name)) 
[18:06:03.755]                               next
[18:06:03.755]                             if (!grepl(pattern, name)) 
[18:06:03.755]                               next
[18:06:03.755]                             invokeRestart(restart)
[18:06:03.755]                             muffled <- TRUE
[18:06:03.755]                             break
[18:06:03.755]                           }
[18:06:03.755]                         }
[18:06:03.755]                       }
[18:06:03.755]                       invisible(muffled)
[18:06:03.755]                     }
[18:06:03.755]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.755]                   }
[18:06:03.755]                 }
[18:06:03.755]             }
[18:06:03.755]         }))
[18:06:03.755]     }, error = function(ex) {
[18:06:03.755]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.755]                 ...future.rng), started = ...future.startTime, 
[18:06:03.755]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.755]             version = "1.8"), class = "FutureResult")
[18:06:03.755]     }, finally = {
[18:06:03.755]         if (!identical(...future.workdir, getwd())) 
[18:06:03.755]             setwd(...future.workdir)
[18:06:03.755]         {
[18:06:03.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.755]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.755]             }
[18:06:03.755]             base::options(...future.oldOptions)
[18:06:03.755]             if (.Platform$OS.type == "windows") {
[18:06:03.755]                 old_names <- names(...future.oldEnvVars)
[18:06:03.755]                 envs <- base::Sys.getenv()
[18:06:03.755]                 names <- names(envs)
[18:06:03.755]                 common <- intersect(names, old_names)
[18:06:03.755]                 added <- setdiff(names, old_names)
[18:06:03.755]                 removed <- setdiff(old_names, names)
[18:06:03.755]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.755]                   envs[common]]
[18:06:03.755]                 NAMES <- toupper(changed)
[18:06:03.755]                 args <- list()
[18:06:03.755]                 for (kk in seq_along(NAMES)) {
[18:06:03.755]                   name <- changed[[kk]]
[18:06:03.755]                   NAME <- NAMES[[kk]]
[18:06:03.755]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.755]                     next
[18:06:03.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.755]                 }
[18:06:03.755]                 NAMES <- toupper(added)
[18:06:03.755]                 for (kk in seq_along(NAMES)) {
[18:06:03.755]                   name <- added[[kk]]
[18:06:03.755]                   NAME <- NAMES[[kk]]
[18:06:03.755]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.755]                     next
[18:06:03.755]                   args[[name]] <- ""
[18:06:03.755]                 }
[18:06:03.755]                 NAMES <- toupper(removed)
[18:06:03.755]                 for (kk in seq_along(NAMES)) {
[18:06:03.755]                   name <- removed[[kk]]
[18:06:03.755]                   NAME <- NAMES[[kk]]
[18:06:03.755]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.755]                     next
[18:06:03.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.755]                 }
[18:06:03.755]                 if (length(args) > 0) 
[18:06:03.755]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.755]             }
[18:06:03.755]             else {
[18:06:03.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.755]             }
[18:06:03.755]             {
[18:06:03.755]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.755]                   0L) {
[18:06:03.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.755]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.755]                   base::options(opts)
[18:06:03.755]                 }
[18:06:03.755]                 {
[18:06:03.755]                   {
[18:06:03.755]                     NULL
[18:06:03.755]                     RNGkind("Mersenne-Twister")
[18:06:03.755]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.755]                       inherits = FALSE)
[18:06:03.755]                   }
[18:06:03.755]                   options(future.plan = NULL)
[18:06:03.755]                   if (is.na(NA_character_)) 
[18:06:03.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.755]                     .init = FALSE)
[18:06:03.755]                 }
[18:06:03.755]             }
[18:06:03.755]         }
[18:06:03.755]     })
[18:06:03.755]     if (TRUE) {
[18:06:03.755]         base::sink(type = "output", split = FALSE)
[18:06:03.755]         if (TRUE) {
[18:06:03.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.755]         }
[18:06:03.755]         else {
[18:06:03.755]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.755]         }
[18:06:03.755]         base::close(...future.stdout)
[18:06:03.755]         ...future.stdout <- NULL
[18:06:03.755]     }
[18:06:03.755]     ...future.result$conditions <- ...future.conditions
[18:06:03.755]     ...future.result$finished <- base::Sys.time()
[18:06:03.755]     ...future.result
[18:06:03.755] }
[18:06:03.759] plan(): Setting new future strategy stack:
[18:06:03.759] List of future strategies:
[18:06:03.759] 1. sequential:
[18:06:03.759]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.759]    - tweaked: FALSE
[18:06:03.759]    - call: NULL
[18:06:03.760] plan(): nbrOfWorkers() = 1
[18:06:03.762] plan(): Setting new future strategy stack:
[18:06:03.763] List of future strategies:
[18:06:03.763] 1. sequential:
[18:06:03.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.763]    - tweaked: FALSE
[18:06:03.763]    - call: plan(strategy)
[18:06:03.764] plan(): nbrOfWorkers() = 1
[18:06:03.764] SequentialFuture started (and completed)
[18:06:03.765] - Launch lazy future ... done
[18:06:03.765] run() for ‘SequentialFuture’ ... done
[18:06:03.766] getGlobalsAndPackages() ...
[18:06:03.766] Searching for globals...
[18:06:03.766] 
[18:06:03.767] Searching for globals ... DONE
[18:06:03.767] - globals: [0] <none>
[18:06:03.767] getGlobalsAndPackages() ... DONE
[18:06:03.768] run() for ‘Future’ ...
[18:06:03.768] - state: ‘created’
[18:06:03.768] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.769] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.769]   - Field: ‘label’
[18:06:03.769]   - Field: ‘local’
[18:06:03.770]   - Field: ‘owner’
[18:06:03.770]   - Field: ‘envir’
[18:06:03.770]   - Field: ‘packages’
[18:06:03.770]   - Field: ‘gc’
[18:06:03.770]   - Field: ‘conditions’
[18:06:03.771]   - Field: ‘expr’
[18:06:03.771]   - Field: ‘uuid’
[18:06:03.771]   - Field: ‘seed’
[18:06:03.771]   - Field: ‘version’
[18:06:03.771]   - Field: ‘result’
[18:06:03.772]   - Field: ‘asynchronous’
[18:06:03.772]   - Field: ‘calls’
[18:06:03.772]   - Field: ‘globals’
[18:06:03.772]   - Field: ‘stdout’
[18:06:03.772]   - Field: ‘earlySignal’
[18:06:03.773]   - Field: ‘lazy’
[18:06:03.773]   - Field: ‘state’
[18:06:03.773] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.773] - Launch lazy future ...
[18:06:03.774] Packages needed by the future expression (n = 0): <none>
[18:06:03.774] Packages needed by future strategies (n = 0): <none>
[18:06:03.775] {
[18:06:03.775]     {
[18:06:03.775]         {
[18:06:03.775]             ...future.startTime <- base::Sys.time()
[18:06:03.775]             {
[18:06:03.775]                 {
[18:06:03.775]                   {
[18:06:03.775]                     base::local({
[18:06:03.775]                       has_future <- base::requireNamespace("future", 
[18:06:03.775]                         quietly = TRUE)
[18:06:03.775]                       if (has_future) {
[18:06:03.775]                         ns <- base::getNamespace("future")
[18:06:03.775]                         version <- ns[[".package"]][["version"]]
[18:06:03.775]                         if (is.null(version)) 
[18:06:03.775]                           version <- utils::packageVersion("future")
[18:06:03.775]                       }
[18:06:03.775]                       else {
[18:06:03.775]                         version <- NULL
[18:06:03.775]                       }
[18:06:03.775]                       if (!has_future || version < "1.8.0") {
[18:06:03.775]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.775]                           "", base::R.version$version.string), 
[18:06:03.775]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.775]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.775]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.775]                             "release", "version")], collapse = " "), 
[18:06:03.775]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.775]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.775]                           info)
[18:06:03.775]                         info <- base::paste(info, collapse = "; ")
[18:06:03.775]                         if (!has_future) {
[18:06:03.775]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.775]                             info)
[18:06:03.775]                         }
[18:06:03.775]                         else {
[18:06:03.775]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.775]                             info, version)
[18:06:03.775]                         }
[18:06:03.775]                         base::stop(msg)
[18:06:03.775]                       }
[18:06:03.775]                     })
[18:06:03.775]                   }
[18:06:03.775]                   ...future.strategy.old <- future::plan("list")
[18:06:03.775]                   options(future.plan = NULL)
[18:06:03.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.775]                 }
[18:06:03.775]                 ...future.workdir <- getwd()
[18:06:03.775]             }
[18:06:03.775]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.775]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.775]         }
[18:06:03.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.775]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.775]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.775]             base::names(...future.oldOptions))
[18:06:03.775]     }
[18:06:03.775]     if (FALSE) {
[18:06:03.775]     }
[18:06:03.775]     else {
[18:06:03.775]         if (TRUE) {
[18:06:03.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.775]                 open = "w")
[18:06:03.775]         }
[18:06:03.775]         else {
[18:06:03.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.775]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.775]         }
[18:06:03.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.775]             base::sink(type = "output", split = FALSE)
[18:06:03.775]             base::close(...future.stdout)
[18:06:03.775]         }, add = TRUE)
[18:06:03.775]     }
[18:06:03.775]     ...future.frame <- base::sys.nframe()
[18:06:03.775]     ...future.conditions <- base::list()
[18:06:03.775]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.775]     if (FALSE) {
[18:06:03.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.775]     }
[18:06:03.775]     ...future.result <- base::tryCatch({
[18:06:03.775]         base::withCallingHandlers({
[18:06:03.775]             ...future.value <- base::withVisible(base::local(2))
[18:06:03.775]             future::FutureResult(value = ...future.value$value, 
[18:06:03.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.775]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.775]                     ...future.globalenv.names))
[18:06:03.775]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.775]         }, condition = base::local({
[18:06:03.775]             c <- base::c
[18:06:03.775]             inherits <- base::inherits
[18:06:03.775]             invokeRestart <- base::invokeRestart
[18:06:03.775]             length <- base::length
[18:06:03.775]             list <- base::list
[18:06:03.775]             seq.int <- base::seq.int
[18:06:03.775]             signalCondition <- base::signalCondition
[18:06:03.775]             sys.calls <- base::sys.calls
[18:06:03.775]             `[[` <- base::`[[`
[18:06:03.775]             `+` <- base::`+`
[18:06:03.775]             `<<-` <- base::`<<-`
[18:06:03.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.775]                   3L)]
[18:06:03.775]             }
[18:06:03.775]             function(cond) {
[18:06:03.775]                 is_error <- inherits(cond, "error")
[18:06:03.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.775]                   NULL)
[18:06:03.775]                 if (is_error) {
[18:06:03.775]                   sessionInformation <- function() {
[18:06:03.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.775]                       search = base::search(), system = base::Sys.info())
[18:06:03.775]                   }
[18:06:03.775]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.775]                     cond$call), session = sessionInformation(), 
[18:06:03.775]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.775]                   signalCondition(cond)
[18:06:03.775]                 }
[18:06:03.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.775]                 "immediateCondition"))) {
[18:06:03.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.775]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.775]                   if (TRUE && !signal) {
[18:06:03.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.775]                     {
[18:06:03.775]                       inherits <- base::inherits
[18:06:03.775]                       invokeRestart <- base::invokeRestart
[18:06:03.775]                       is.null <- base::is.null
[18:06:03.775]                       muffled <- FALSE
[18:06:03.775]                       if (inherits(cond, "message")) {
[18:06:03.775]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.775]                         if (muffled) 
[18:06:03.775]                           invokeRestart("muffleMessage")
[18:06:03.775]                       }
[18:06:03.775]                       else if (inherits(cond, "warning")) {
[18:06:03.775]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.775]                         if (muffled) 
[18:06:03.775]                           invokeRestart("muffleWarning")
[18:06:03.775]                       }
[18:06:03.775]                       else if (inherits(cond, "condition")) {
[18:06:03.775]                         if (!is.null(pattern)) {
[18:06:03.775]                           computeRestarts <- base::computeRestarts
[18:06:03.775]                           grepl <- base::grepl
[18:06:03.775]                           restarts <- computeRestarts(cond)
[18:06:03.775]                           for (restart in restarts) {
[18:06:03.775]                             name <- restart$name
[18:06:03.775]                             if (is.null(name)) 
[18:06:03.775]                               next
[18:06:03.775]                             if (!grepl(pattern, name)) 
[18:06:03.775]                               next
[18:06:03.775]                             invokeRestart(restart)
[18:06:03.775]                             muffled <- TRUE
[18:06:03.775]                             break
[18:06:03.775]                           }
[18:06:03.775]                         }
[18:06:03.775]                       }
[18:06:03.775]                       invisible(muffled)
[18:06:03.775]                     }
[18:06:03.775]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.775]                   }
[18:06:03.775]                 }
[18:06:03.775]                 else {
[18:06:03.775]                   if (TRUE) {
[18:06:03.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.775]                     {
[18:06:03.775]                       inherits <- base::inherits
[18:06:03.775]                       invokeRestart <- base::invokeRestart
[18:06:03.775]                       is.null <- base::is.null
[18:06:03.775]                       muffled <- FALSE
[18:06:03.775]                       if (inherits(cond, "message")) {
[18:06:03.775]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.775]                         if (muffled) 
[18:06:03.775]                           invokeRestart("muffleMessage")
[18:06:03.775]                       }
[18:06:03.775]                       else if (inherits(cond, "warning")) {
[18:06:03.775]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.775]                         if (muffled) 
[18:06:03.775]                           invokeRestart("muffleWarning")
[18:06:03.775]                       }
[18:06:03.775]                       else if (inherits(cond, "condition")) {
[18:06:03.775]                         if (!is.null(pattern)) {
[18:06:03.775]                           computeRestarts <- base::computeRestarts
[18:06:03.775]                           grepl <- base::grepl
[18:06:03.775]                           restarts <- computeRestarts(cond)
[18:06:03.775]                           for (restart in restarts) {
[18:06:03.775]                             name <- restart$name
[18:06:03.775]                             if (is.null(name)) 
[18:06:03.775]                               next
[18:06:03.775]                             if (!grepl(pattern, name)) 
[18:06:03.775]                               next
[18:06:03.775]                             invokeRestart(restart)
[18:06:03.775]                             muffled <- TRUE
[18:06:03.775]                             break
[18:06:03.775]                           }
[18:06:03.775]                         }
[18:06:03.775]                       }
[18:06:03.775]                       invisible(muffled)
[18:06:03.775]                     }
[18:06:03.775]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.775]                   }
[18:06:03.775]                 }
[18:06:03.775]             }
[18:06:03.775]         }))
[18:06:03.775]     }, error = function(ex) {
[18:06:03.775]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.775]                 ...future.rng), started = ...future.startTime, 
[18:06:03.775]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.775]             version = "1.8"), class = "FutureResult")
[18:06:03.775]     }, finally = {
[18:06:03.775]         if (!identical(...future.workdir, getwd())) 
[18:06:03.775]             setwd(...future.workdir)
[18:06:03.775]         {
[18:06:03.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.775]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.775]             }
[18:06:03.775]             base::options(...future.oldOptions)
[18:06:03.775]             if (.Platform$OS.type == "windows") {
[18:06:03.775]                 old_names <- names(...future.oldEnvVars)
[18:06:03.775]                 envs <- base::Sys.getenv()
[18:06:03.775]                 names <- names(envs)
[18:06:03.775]                 common <- intersect(names, old_names)
[18:06:03.775]                 added <- setdiff(names, old_names)
[18:06:03.775]                 removed <- setdiff(old_names, names)
[18:06:03.775]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.775]                   envs[common]]
[18:06:03.775]                 NAMES <- toupper(changed)
[18:06:03.775]                 args <- list()
[18:06:03.775]                 for (kk in seq_along(NAMES)) {
[18:06:03.775]                   name <- changed[[kk]]
[18:06:03.775]                   NAME <- NAMES[[kk]]
[18:06:03.775]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.775]                     next
[18:06:03.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.775]                 }
[18:06:03.775]                 NAMES <- toupper(added)
[18:06:03.775]                 for (kk in seq_along(NAMES)) {
[18:06:03.775]                   name <- added[[kk]]
[18:06:03.775]                   NAME <- NAMES[[kk]]
[18:06:03.775]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.775]                     next
[18:06:03.775]                   args[[name]] <- ""
[18:06:03.775]                 }
[18:06:03.775]                 NAMES <- toupper(removed)
[18:06:03.775]                 for (kk in seq_along(NAMES)) {
[18:06:03.775]                   name <- removed[[kk]]
[18:06:03.775]                   NAME <- NAMES[[kk]]
[18:06:03.775]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.775]                     next
[18:06:03.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.775]                 }
[18:06:03.775]                 if (length(args) > 0) 
[18:06:03.775]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.775]             }
[18:06:03.775]             else {
[18:06:03.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.775]             }
[18:06:03.775]             {
[18:06:03.775]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.775]                   0L) {
[18:06:03.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.775]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.775]                   base::options(opts)
[18:06:03.775]                 }
[18:06:03.775]                 {
[18:06:03.775]                   {
[18:06:03.775]                     NULL
[18:06:03.775]                     RNGkind("Mersenne-Twister")
[18:06:03.775]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.775]                       inherits = FALSE)
[18:06:03.775]                   }
[18:06:03.775]                   options(future.plan = NULL)
[18:06:03.775]                   if (is.na(NA_character_)) 
[18:06:03.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.775]                     .init = FALSE)
[18:06:03.775]                 }
[18:06:03.775]             }
[18:06:03.775]         }
[18:06:03.775]     })
[18:06:03.775]     if (TRUE) {
[18:06:03.775]         base::sink(type = "output", split = FALSE)
[18:06:03.775]         if (TRUE) {
[18:06:03.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.775]         }
[18:06:03.775]         else {
[18:06:03.775]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.775]         }
[18:06:03.775]         base::close(...future.stdout)
[18:06:03.775]         ...future.stdout <- NULL
[18:06:03.775]     }
[18:06:03.775]     ...future.result$conditions <- ...future.conditions
[18:06:03.775]     ...future.result$finished <- base::Sys.time()
[18:06:03.775]     ...future.result
[18:06:03.775] }
[18:06:03.779] plan(): Setting new future strategy stack:
[18:06:03.779] List of future strategies:
[18:06:03.779] 1. sequential:
[18:06:03.779]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.779]    - tweaked: FALSE
[18:06:03.779]    - call: NULL
[18:06:03.780] plan(): nbrOfWorkers() = 1
[18:06:03.781] plan(): Setting new future strategy stack:
[18:06:03.782] List of future strategies:
[18:06:03.782] 1. sequential:
[18:06:03.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.782]    - tweaked: FALSE
[18:06:03.782]    - call: plan(strategy)
[18:06:03.783] plan(): nbrOfWorkers() = 1
[18:06:03.783] SequentialFuture started (and completed)
[18:06:03.784] - Launch lazy future ... done
[18:06:03.784] run() for ‘SequentialFuture’ ... done
[18:06:03.784] resolve() on list ...
[18:06:03.784]  recursive: 0
[18:06:03.784]  length: 3
[18:06:03.785]  elements: ‘a’, ‘b’, ‘’
[18:06:03.785] resolved() for ‘SequentialFuture’ ...
[18:06:03.785] - state: ‘finished’
[18:06:03.786] - run: TRUE
[18:06:03.786] - result: ‘FutureResult’
[18:06:03.786] resolved() for ‘SequentialFuture’ ... done
[18:06:03.786] Future #1
[18:06:03.787]  length: 2 (resolved future 1)
[18:06:03.787] resolved() for ‘SequentialFuture’ ...
[18:06:03.787] - state: ‘finished’
[18:06:03.787] - run: TRUE
[18:06:03.787] - result: ‘FutureResult’
[18:06:03.788] resolved() for ‘SequentialFuture’ ... done
[18:06:03.788] Future #2
[18:06:03.788]  length: 1 (resolved future 2)
[18:06:03.788]  length: 0 (resolved future 3)
[18:06:03.788] resolve() on list ... DONE
[18:06:03.789] resolved() for ‘SequentialFuture’ ...
[18:06:03.789] - state: ‘finished’
[18:06:03.789] - run: TRUE
[18:06:03.789] - result: ‘FutureResult’
[18:06:03.789] resolved() for ‘SequentialFuture’ ... done
[18:06:03.790] resolved() for ‘SequentialFuture’ ...
[18:06:03.790] - state: ‘finished’
[18:06:03.790] - run: TRUE
[18:06:03.790] - result: ‘FutureResult’
[18:06:03.790] resolved() for ‘SequentialFuture’ ... done
[18:06:03.791] getGlobalsAndPackages() ...
[18:06:03.791] Searching for globals...
[18:06:03.792] 
[18:06:03.792] Searching for globals ... DONE
[18:06:03.792] - globals: [0] <none>
[18:06:03.792] getGlobalsAndPackages() ... DONE
[18:06:03.793] getGlobalsAndPackages() ...
[18:06:03.793] Searching for globals...
[18:06:03.794] 
[18:06:03.794] Searching for globals ... DONE
[18:06:03.794] - globals: [0] <none>
[18:06:03.794] getGlobalsAndPackages() ... DONE
[18:06:03.795] run() for ‘Future’ ...
[18:06:03.795] - state: ‘created’
[18:06:03.795] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.796] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.796]   - Field: ‘label’
[18:06:03.796]   - Field: ‘local’
[18:06:03.797]   - Field: ‘owner’
[18:06:03.797]   - Field: ‘envir’
[18:06:03.797]   - Field: ‘packages’
[18:06:03.797]   - Field: ‘gc’
[18:06:03.797]   - Field: ‘conditions’
[18:06:03.798]   - Field: ‘expr’
[18:06:03.798]   - Field: ‘uuid’
[18:06:03.798]   - Field: ‘seed’
[18:06:03.798]   - Field: ‘version’
[18:06:03.798]   - Field: ‘result’
[18:06:03.799]   - Field: ‘asynchronous’
[18:06:03.799]   - Field: ‘calls’
[18:06:03.799]   - Field: ‘globals’
[18:06:03.799]   - Field: ‘stdout’
[18:06:03.799]   - Field: ‘earlySignal’
[18:06:03.800]   - Field: ‘lazy’
[18:06:03.800]   - Field: ‘state’
[18:06:03.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.800] - Launch lazy future ...
[18:06:03.801] Packages needed by the future expression (n = 0): <none>
[18:06:03.801] Packages needed by future strategies (n = 0): <none>
[18:06:03.802] {
[18:06:03.802]     {
[18:06:03.802]         {
[18:06:03.802]             ...future.startTime <- base::Sys.time()
[18:06:03.802]             {
[18:06:03.802]                 {
[18:06:03.802]                   {
[18:06:03.802]                     base::local({
[18:06:03.802]                       has_future <- base::requireNamespace("future", 
[18:06:03.802]                         quietly = TRUE)
[18:06:03.802]                       if (has_future) {
[18:06:03.802]                         ns <- base::getNamespace("future")
[18:06:03.802]                         version <- ns[[".package"]][["version"]]
[18:06:03.802]                         if (is.null(version)) 
[18:06:03.802]                           version <- utils::packageVersion("future")
[18:06:03.802]                       }
[18:06:03.802]                       else {
[18:06:03.802]                         version <- NULL
[18:06:03.802]                       }
[18:06:03.802]                       if (!has_future || version < "1.8.0") {
[18:06:03.802]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.802]                           "", base::R.version$version.string), 
[18:06:03.802]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.802]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.802]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.802]                             "release", "version")], collapse = " "), 
[18:06:03.802]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.802]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.802]                           info)
[18:06:03.802]                         info <- base::paste(info, collapse = "; ")
[18:06:03.802]                         if (!has_future) {
[18:06:03.802]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.802]                             info)
[18:06:03.802]                         }
[18:06:03.802]                         else {
[18:06:03.802]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.802]                             info, version)
[18:06:03.802]                         }
[18:06:03.802]                         base::stop(msg)
[18:06:03.802]                       }
[18:06:03.802]                     })
[18:06:03.802]                   }
[18:06:03.802]                   ...future.strategy.old <- future::plan("list")
[18:06:03.802]                   options(future.plan = NULL)
[18:06:03.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.802]                 }
[18:06:03.802]                 ...future.workdir <- getwd()
[18:06:03.802]             }
[18:06:03.802]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.802]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.802]         }
[18:06:03.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.802]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.802]             base::names(...future.oldOptions))
[18:06:03.802]     }
[18:06:03.802]     if (FALSE) {
[18:06:03.802]     }
[18:06:03.802]     else {
[18:06:03.802]         if (TRUE) {
[18:06:03.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.802]                 open = "w")
[18:06:03.802]         }
[18:06:03.802]         else {
[18:06:03.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.802]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.802]         }
[18:06:03.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.802]             base::sink(type = "output", split = FALSE)
[18:06:03.802]             base::close(...future.stdout)
[18:06:03.802]         }, add = TRUE)
[18:06:03.802]     }
[18:06:03.802]     ...future.frame <- base::sys.nframe()
[18:06:03.802]     ...future.conditions <- base::list()
[18:06:03.802]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.802]     if (FALSE) {
[18:06:03.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.802]     }
[18:06:03.802]     ...future.result <- base::tryCatch({
[18:06:03.802]         base::withCallingHandlers({
[18:06:03.802]             ...future.value <- base::withVisible(base::local(2))
[18:06:03.802]             future::FutureResult(value = ...future.value$value, 
[18:06:03.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.802]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.802]                     ...future.globalenv.names))
[18:06:03.802]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.802]         }, condition = base::local({
[18:06:03.802]             c <- base::c
[18:06:03.802]             inherits <- base::inherits
[18:06:03.802]             invokeRestart <- base::invokeRestart
[18:06:03.802]             length <- base::length
[18:06:03.802]             list <- base::list
[18:06:03.802]             seq.int <- base::seq.int
[18:06:03.802]             signalCondition <- base::signalCondition
[18:06:03.802]             sys.calls <- base::sys.calls
[18:06:03.802]             `[[` <- base::`[[`
[18:06:03.802]             `+` <- base::`+`
[18:06:03.802]             `<<-` <- base::`<<-`
[18:06:03.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.802]                   3L)]
[18:06:03.802]             }
[18:06:03.802]             function(cond) {
[18:06:03.802]                 is_error <- inherits(cond, "error")
[18:06:03.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.802]                   NULL)
[18:06:03.802]                 if (is_error) {
[18:06:03.802]                   sessionInformation <- function() {
[18:06:03.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.802]                       search = base::search(), system = base::Sys.info())
[18:06:03.802]                   }
[18:06:03.802]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.802]                     cond$call), session = sessionInformation(), 
[18:06:03.802]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.802]                   signalCondition(cond)
[18:06:03.802]                 }
[18:06:03.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.802]                 "immediateCondition"))) {
[18:06:03.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.802]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.802]                   if (TRUE && !signal) {
[18:06:03.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.802]                     {
[18:06:03.802]                       inherits <- base::inherits
[18:06:03.802]                       invokeRestart <- base::invokeRestart
[18:06:03.802]                       is.null <- base::is.null
[18:06:03.802]                       muffled <- FALSE
[18:06:03.802]                       if (inherits(cond, "message")) {
[18:06:03.802]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.802]                         if (muffled) 
[18:06:03.802]                           invokeRestart("muffleMessage")
[18:06:03.802]                       }
[18:06:03.802]                       else if (inherits(cond, "warning")) {
[18:06:03.802]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.802]                         if (muffled) 
[18:06:03.802]                           invokeRestart("muffleWarning")
[18:06:03.802]                       }
[18:06:03.802]                       else if (inherits(cond, "condition")) {
[18:06:03.802]                         if (!is.null(pattern)) {
[18:06:03.802]                           computeRestarts <- base::computeRestarts
[18:06:03.802]                           grepl <- base::grepl
[18:06:03.802]                           restarts <- computeRestarts(cond)
[18:06:03.802]                           for (restart in restarts) {
[18:06:03.802]                             name <- restart$name
[18:06:03.802]                             if (is.null(name)) 
[18:06:03.802]                               next
[18:06:03.802]                             if (!grepl(pattern, name)) 
[18:06:03.802]                               next
[18:06:03.802]                             invokeRestart(restart)
[18:06:03.802]                             muffled <- TRUE
[18:06:03.802]                             break
[18:06:03.802]                           }
[18:06:03.802]                         }
[18:06:03.802]                       }
[18:06:03.802]                       invisible(muffled)
[18:06:03.802]                     }
[18:06:03.802]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.802]                   }
[18:06:03.802]                 }
[18:06:03.802]                 else {
[18:06:03.802]                   if (TRUE) {
[18:06:03.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.802]                     {
[18:06:03.802]                       inherits <- base::inherits
[18:06:03.802]                       invokeRestart <- base::invokeRestart
[18:06:03.802]                       is.null <- base::is.null
[18:06:03.802]                       muffled <- FALSE
[18:06:03.802]                       if (inherits(cond, "message")) {
[18:06:03.802]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.802]                         if (muffled) 
[18:06:03.802]                           invokeRestart("muffleMessage")
[18:06:03.802]                       }
[18:06:03.802]                       else if (inherits(cond, "warning")) {
[18:06:03.802]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.802]                         if (muffled) 
[18:06:03.802]                           invokeRestart("muffleWarning")
[18:06:03.802]                       }
[18:06:03.802]                       else if (inherits(cond, "condition")) {
[18:06:03.802]                         if (!is.null(pattern)) {
[18:06:03.802]                           computeRestarts <- base::computeRestarts
[18:06:03.802]                           grepl <- base::grepl
[18:06:03.802]                           restarts <- computeRestarts(cond)
[18:06:03.802]                           for (restart in restarts) {
[18:06:03.802]                             name <- restart$name
[18:06:03.802]                             if (is.null(name)) 
[18:06:03.802]                               next
[18:06:03.802]                             if (!grepl(pattern, name)) 
[18:06:03.802]                               next
[18:06:03.802]                             invokeRestart(restart)
[18:06:03.802]                             muffled <- TRUE
[18:06:03.802]                             break
[18:06:03.802]                           }
[18:06:03.802]                         }
[18:06:03.802]                       }
[18:06:03.802]                       invisible(muffled)
[18:06:03.802]                     }
[18:06:03.802]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.802]                   }
[18:06:03.802]                 }
[18:06:03.802]             }
[18:06:03.802]         }))
[18:06:03.802]     }, error = function(ex) {
[18:06:03.802]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.802]                 ...future.rng), started = ...future.startTime, 
[18:06:03.802]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.802]             version = "1.8"), class = "FutureResult")
[18:06:03.802]     }, finally = {
[18:06:03.802]         if (!identical(...future.workdir, getwd())) 
[18:06:03.802]             setwd(...future.workdir)
[18:06:03.802]         {
[18:06:03.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.802]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.802]             }
[18:06:03.802]             base::options(...future.oldOptions)
[18:06:03.802]             if (.Platform$OS.type == "windows") {
[18:06:03.802]                 old_names <- names(...future.oldEnvVars)
[18:06:03.802]                 envs <- base::Sys.getenv()
[18:06:03.802]                 names <- names(envs)
[18:06:03.802]                 common <- intersect(names, old_names)
[18:06:03.802]                 added <- setdiff(names, old_names)
[18:06:03.802]                 removed <- setdiff(old_names, names)
[18:06:03.802]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.802]                   envs[common]]
[18:06:03.802]                 NAMES <- toupper(changed)
[18:06:03.802]                 args <- list()
[18:06:03.802]                 for (kk in seq_along(NAMES)) {
[18:06:03.802]                   name <- changed[[kk]]
[18:06:03.802]                   NAME <- NAMES[[kk]]
[18:06:03.802]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.802]                     next
[18:06:03.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.802]                 }
[18:06:03.802]                 NAMES <- toupper(added)
[18:06:03.802]                 for (kk in seq_along(NAMES)) {
[18:06:03.802]                   name <- added[[kk]]
[18:06:03.802]                   NAME <- NAMES[[kk]]
[18:06:03.802]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.802]                     next
[18:06:03.802]                   args[[name]] <- ""
[18:06:03.802]                 }
[18:06:03.802]                 NAMES <- toupper(removed)
[18:06:03.802]                 for (kk in seq_along(NAMES)) {
[18:06:03.802]                   name <- removed[[kk]]
[18:06:03.802]                   NAME <- NAMES[[kk]]
[18:06:03.802]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.802]                     next
[18:06:03.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.802]                 }
[18:06:03.802]                 if (length(args) > 0) 
[18:06:03.802]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.802]             }
[18:06:03.802]             else {
[18:06:03.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.802]             }
[18:06:03.802]             {
[18:06:03.802]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.802]                   0L) {
[18:06:03.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.802]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.802]                   base::options(opts)
[18:06:03.802]                 }
[18:06:03.802]                 {
[18:06:03.802]                   {
[18:06:03.802]                     NULL
[18:06:03.802]                     RNGkind("Mersenne-Twister")
[18:06:03.802]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.802]                       inherits = FALSE)
[18:06:03.802]                   }
[18:06:03.802]                   options(future.plan = NULL)
[18:06:03.802]                   if (is.na(NA_character_)) 
[18:06:03.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.802]                     .init = FALSE)
[18:06:03.802]                 }
[18:06:03.802]             }
[18:06:03.802]         }
[18:06:03.802]     })
[18:06:03.802]     if (TRUE) {
[18:06:03.802]         base::sink(type = "output", split = FALSE)
[18:06:03.802]         if (TRUE) {
[18:06:03.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.802]         }
[18:06:03.802]         else {
[18:06:03.802]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.802]         }
[18:06:03.802]         base::close(...future.stdout)
[18:06:03.802]         ...future.stdout <- NULL
[18:06:03.802]     }
[18:06:03.802]     ...future.result$conditions <- ...future.conditions
[18:06:03.802]     ...future.result$finished <- base::Sys.time()
[18:06:03.802]     ...future.result
[18:06:03.802] }
[18:06:03.806] plan(): Setting new future strategy stack:
[18:06:03.806] List of future strategies:
[18:06:03.806] 1. sequential:
[18:06:03.806]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.806]    - tweaked: FALSE
[18:06:03.806]    - call: NULL
[18:06:03.807] plan(): nbrOfWorkers() = 1
[18:06:03.808] plan(): Setting new future strategy stack:
[18:06:03.809] List of future strategies:
[18:06:03.809] 1. sequential:
[18:06:03.809]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.809]    - tweaked: FALSE
[18:06:03.809]    - call: plan(strategy)
[18:06:03.810] plan(): nbrOfWorkers() = 1
[18:06:03.810] SequentialFuture started (and completed)
[18:06:03.810] - Launch lazy future ... done
[18:06:03.811] run() for ‘SequentialFuture’ ... done
[18:06:03.811] resolve() on list ...
[18:06:03.811]  recursive: 0
[18:06:03.811]  length: 3
[18:06:03.811]  elements: ‘a’, ‘b’, ‘’
[18:06:03.812] run() for ‘Future’ ...
[18:06:03.812] - state: ‘created’
[18:06:03.812] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.813] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.813]   - Field: ‘label’
[18:06:03.813]   - Field: ‘local’
[18:06:03.814]   - Field: ‘owner’
[18:06:03.814]   - Field: ‘envir’
[18:06:03.814]   - Field: ‘packages’
[18:06:03.814]   - Field: ‘gc’
[18:06:03.814]   - Field: ‘conditions’
[18:06:03.815]   - Field: ‘expr’
[18:06:03.815]   - Field: ‘uuid’
[18:06:03.815]   - Field: ‘seed’
[18:06:03.815]   - Field: ‘version’
[18:06:03.816]   - Field: ‘result’
[18:06:03.816]   - Field: ‘asynchronous’
[18:06:03.816]   - Field: ‘calls’
[18:06:03.816]   - Field: ‘globals’
[18:06:03.816]   - Field: ‘stdout’
[18:06:03.817]   - Field: ‘earlySignal’
[18:06:03.817]   - Field: ‘lazy’
[18:06:03.817]   - Field: ‘state’
[18:06:03.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.817] - Launch lazy future ...
[18:06:03.818] Packages needed by the future expression (n = 0): <none>
[18:06:03.818] Packages needed by future strategies (n = 0): <none>
[18:06:03.819] {
[18:06:03.819]     {
[18:06:03.819]         {
[18:06:03.819]             ...future.startTime <- base::Sys.time()
[18:06:03.819]             {
[18:06:03.819]                 {
[18:06:03.819]                   {
[18:06:03.819]                     base::local({
[18:06:03.819]                       has_future <- base::requireNamespace("future", 
[18:06:03.819]                         quietly = TRUE)
[18:06:03.819]                       if (has_future) {
[18:06:03.819]                         ns <- base::getNamespace("future")
[18:06:03.819]                         version <- ns[[".package"]][["version"]]
[18:06:03.819]                         if (is.null(version)) 
[18:06:03.819]                           version <- utils::packageVersion("future")
[18:06:03.819]                       }
[18:06:03.819]                       else {
[18:06:03.819]                         version <- NULL
[18:06:03.819]                       }
[18:06:03.819]                       if (!has_future || version < "1.8.0") {
[18:06:03.819]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.819]                           "", base::R.version$version.string), 
[18:06:03.819]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.819]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.819]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.819]                             "release", "version")], collapse = " "), 
[18:06:03.819]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.819]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.819]                           info)
[18:06:03.819]                         info <- base::paste(info, collapse = "; ")
[18:06:03.819]                         if (!has_future) {
[18:06:03.819]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.819]                             info)
[18:06:03.819]                         }
[18:06:03.819]                         else {
[18:06:03.819]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.819]                             info, version)
[18:06:03.819]                         }
[18:06:03.819]                         base::stop(msg)
[18:06:03.819]                       }
[18:06:03.819]                     })
[18:06:03.819]                   }
[18:06:03.819]                   ...future.strategy.old <- future::plan("list")
[18:06:03.819]                   options(future.plan = NULL)
[18:06:03.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.819]                 }
[18:06:03.819]                 ...future.workdir <- getwd()
[18:06:03.819]             }
[18:06:03.819]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.819]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.819]         }
[18:06:03.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.819]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.819]             base::names(...future.oldOptions))
[18:06:03.819]     }
[18:06:03.819]     if (FALSE) {
[18:06:03.819]     }
[18:06:03.819]     else {
[18:06:03.819]         if (TRUE) {
[18:06:03.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.819]                 open = "w")
[18:06:03.819]         }
[18:06:03.819]         else {
[18:06:03.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.819]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.819]         }
[18:06:03.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.819]             base::sink(type = "output", split = FALSE)
[18:06:03.819]             base::close(...future.stdout)
[18:06:03.819]         }, add = TRUE)
[18:06:03.819]     }
[18:06:03.819]     ...future.frame <- base::sys.nframe()
[18:06:03.819]     ...future.conditions <- base::list()
[18:06:03.819]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.819]     if (FALSE) {
[18:06:03.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.819]     }
[18:06:03.819]     ...future.result <- base::tryCatch({
[18:06:03.819]         base::withCallingHandlers({
[18:06:03.819]             ...future.value <- base::withVisible(base::local(1))
[18:06:03.819]             future::FutureResult(value = ...future.value$value, 
[18:06:03.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.819]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.819]                     ...future.globalenv.names))
[18:06:03.819]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.819]         }, condition = base::local({
[18:06:03.819]             c <- base::c
[18:06:03.819]             inherits <- base::inherits
[18:06:03.819]             invokeRestart <- base::invokeRestart
[18:06:03.819]             length <- base::length
[18:06:03.819]             list <- base::list
[18:06:03.819]             seq.int <- base::seq.int
[18:06:03.819]             signalCondition <- base::signalCondition
[18:06:03.819]             sys.calls <- base::sys.calls
[18:06:03.819]             `[[` <- base::`[[`
[18:06:03.819]             `+` <- base::`+`
[18:06:03.819]             `<<-` <- base::`<<-`
[18:06:03.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.819]                   3L)]
[18:06:03.819]             }
[18:06:03.819]             function(cond) {
[18:06:03.819]                 is_error <- inherits(cond, "error")
[18:06:03.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.819]                   NULL)
[18:06:03.819]                 if (is_error) {
[18:06:03.819]                   sessionInformation <- function() {
[18:06:03.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.819]                       search = base::search(), system = base::Sys.info())
[18:06:03.819]                   }
[18:06:03.819]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.819]                     cond$call), session = sessionInformation(), 
[18:06:03.819]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.819]                   signalCondition(cond)
[18:06:03.819]                 }
[18:06:03.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.819]                 "immediateCondition"))) {
[18:06:03.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.819]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.819]                   if (TRUE && !signal) {
[18:06:03.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.819]                     {
[18:06:03.819]                       inherits <- base::inherits
[18:06:03.819]                       invokeRestart <- base::invokeRestart
[18:06:03.819]                       is.null <- base::is.null
[18:06:03.819]                       muffled <- FALSE
[18:06:03.819]                       if (inherits(cond, "message")) {
[18:06:03.819]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.819]                         if (muffled) 
[18:06:03.819]                           invokeRestart("muffleMessage")
[18:06:03.819]                       }
[18:06:03.819]                       else if (inherits(cond, "warning")) {
[18:06:03.819]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.819]                         if (muffled) 
[18:06:03.819]                           invokeRestart("muffleWarning")
[18:06:03.819]                       }
[18:06:03.819]                       else if (inherits(cond, "condition")) {
[18:06:03.819]                         if (!is.null(pattern)) {
[18:06:03.819]                           computeRestarts <- base::computeRestarts
[18:06:03.819]                           grepl <- base::grepl
[18:06:03.819]                           restarts <- computeRestarts(cond)
[18:06:03.819]                           for (restart in restarts) {
[18:06:03.819]                             name <- restart$name
[18:06:03.819]                             if (is.null(name)) 
[18:06:03.819]                               next
[18:06:03.819]                             if (!grepl(pattern, name)) 
[18:06:03.819]                               next
[18:06:03.819]                             invokeRestart(restart)
[18:06:03.819]                             muffled <- TRUE
[18:06:03.819]                             break
[18:06:03.819]                           }
[18:06:03.819]                         }
[18:06:03.819]                       }
[18:06:03.819]                       invisible(muffled)
[18:06:03.819]                     }
[18:06:03.819]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.819]                   }
[18:06:03.819]                 }
[18:06:03.819]                 else {
[18:06:03.819]                   if (TRUE) {
[18:06:03.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.819]                     {
[18:06:03.819]                       inherits <- base::inherits
[18:06:03.819]                       invokeRestart <- base::invokeRestart
[18:06:03.819]                       is.null <- base::is.null
[18:06:03.819]                       muffled <- FALSE
[18:06:03.819]                       if (inherits(cond, "message")) {
[18:06:03.819]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.819]                         if (muffled) 
[18:06:03.819]                           invokeRestart("muffleMessage")
[18:06:03.819]                       }
[18:06:03.819]                       else if (inherits(cond, "warning")) {
[18:06:03.819]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.819]                         if (muffled) 
[18:06:03.819]                           invokeRestart("muffleWarning")
[18:06:03.819]                       }
[18:06:03.819]                       else if (inherits(cond, "condition")) {
[18:06:03.819]                         if (!is.null(pattern)) {
[18:06:03.819]                           computeRestarts <- base::computeRestarts
[18:06:03.819]                           grepl <- base::grepl
[18:06:03.819]                           restarts <- computeRestarts(cond)
[18:06:03.819]                           for (restart in restarts) {
[18:06:03.819]                             name <- restart$name
[18:06:03.819]                             if (is.null(name)) 
[18:06:03.819]                               next
[18:06:03.819]                             if (!grepl(pattern, name)) 
[18:06:03.819]                               next
[18:06:03.819]                             invokeRestart(restart)
[18:06:03.819]                             muffled <- TRUE
[18:06:03.819]                             break
[18:06:03.819]                           }
[18:06:03.819]                         }
[18:06:03.819]                       }
[18:06:03.819]                       invisible(muffled)
[18:06:03.819]                     }
[18:06:03.819]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.819]                   }
[18:06:03.819]                 }
[18:06:03.819]             }
[18:06:03.819]         }))
[18:06:03.819]     }, error = function(ex) {
[18:06:03.819]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.819]                 ...future.rng), started = ...future.startTime, 
[18:06:03.819]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.819]             version = "1.8"), class = "FutureResult")
[18:06:03.819]     }, finally = {
[18:06:03.819]         if (!identical(...future.workdir, getwd())) 
[18:06:03.819]             setwd(...future.workdir)
[18:06:03.819]         {
[18:06:03.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.819]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.819]             }
[18:06:03.819]             base::options(...future.oldOptions)
[18:06:03.819]             if (.Platform$OS.type == "windows") {
[18:06:03.819]                 old_names <- names(...future.oldEnvVars)
[18:06:03.819]                 envs <- base::Sys.getenv()
[18:06:03.819]                 names <- names(envs)
[18:06:03.819]                 common <- intersect(names, old_names)
[18:06:03.819]                 added <- setdiff(names, old_names)
[18:06:03.819]                 removed <- setdiff(old_names, names)
[18:06:03.819]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.819]                   envs[common]]
[18:06:03.819]                 NAMES <- toupper(changed)
[18:06:03.819]                 args <- list()
[18:06:03.819]                 for (kk in seq_along(NAMES)) {
[18:06:03.819]                   name <- changed[[kk]]
[18:06:03.819]                   NAME <- NAMES[[kk]]
[18:06:03.819]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.819]                     next
[18:06:03.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.819]                 }
[18:06:03.819]                 NAMES <- toupper(added)
[18:06:03.819]                 for (kk in seq_along(NAMES)) {
[18:06:03.819]                   name <- added[[kk]]
[18:06:03.819]                   NAME <- NAMES[[kk]]
[18:06:03.819]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.819]                     next
[18:06:03.819]                   args[[name]] <- ""
[18:06:03.819]                 }
[18:06:03.819]                 NAMES <- toupper(removed)
[18:06:03.819]                 for (kk in seq_along(NAMES)) {
[18:06:03.819]                   name <- removed[[kk]]
[18:06:03.819]                   NAME <- NAMES[[kk]]
[18:06:03.819]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.819]                     next
[18:06:03.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.819]                 }
[18:06:03.819]                 if (length(args) > 0) 
[18:06:03.819]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.819]             }
[18:06:03.819]             else {
[18:06:03.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.819]             }
[18:06:03.819]             {
[18:06:03.819]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.819]                   0L) {
[18:06:03.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.819]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.819]                   base::options(opts)
[18:06:03.819]                 }
[18:06:03.819]                 {
[18:06:03.819]                   {
[18:06:03.819]                     NULL
[18:06:03.819]                     RNGkind("Mersenne-Twister")
[18:06:03.819]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.819]                       inherits = FALSE)
[18:06:03.819]                   }
[18:06:03.819]                   options(future.plan = NULL)
[18:06:03.819]                   if (is.na(NA_character_)) 
[18:06:03.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.819]                     .init = FALSE)
[18:06:03.819]                 }
[18:06:03.819]             }
[18:06:03.819]         }
[18:06:03.819]     })
[18:06:03.819]     if (TRUE) {
[18:06:03.819]         base::sink(type = "output", split = FALSE)
[18:06:03.819]         if (TRUE) {
[18:06:03.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.819]         }
[18:06:03.819]         else {
[18:06:03.819]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.819]         }
[18:06:03.819]         base::close(...future.stdout)
[18:06:03.819]         ...future.stdout <- NULL
[18:06:03.819]     }
[18:06:03.819]     ...future.result$conditions <- ...future.conditions
[18:06:03.819]     ...future.result$finished <- base::Sys.time()
[18:06:03.819]     ...future.result
[18:06:03.819] }
[18:06:03.822] plan(): Setting new future strategy stack:
[18:06:03.823] List of future strategies:
[18:06:03.823] 1. sequential:
[18:06:03.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.823]    - tweaked: FALSE
[18:06:03.823]    - call: NULL
[18:06:03.827] plan(): nbrOfWorkers() = 1
[18:06:03.829] plan(): Setting new future strategy stack:
[18:06:03.829] List of future strategies:
[18:06:03.829] 1. sequential:
[18:06:03.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.829]    - tweaked: FALSE
[18:06:03.829]    - call: plan(strategy)
[18:06:03.830] plan(): nbrOfWorkers() = 1
[18:06:03.831] SequentialFuture started (and completed)
[18:06:03.831] - Launch lazy future ... done
[18:06:03.831] run() for ‘SequentialFuture’ ... done
[18:06:03.831] resolved() for ‘SequentialFuture’ ...
[18:06:03.832] - state: ‘finished’
[18:06:03.832] - run: TRUE
[18:06:03.832] - result: ‘FutureResult’
[18:06:03.832] resolved() for ‘SequentialFuture’ ... done
[18:06:03.832] Future #1
[18:06:03.833]  length: 2 (resolved future 1)
[18:06:03.833] resolved() for ‘SequentialFuture’ ...
[18:06:03.833] - state: ‘finished’
[18:06:03.833] - run: TRUE
[18:06:03.834] - result: ‘FutureResult’
[18:06:03.834] resolved() for ‘SequentialFuture’ ... done
[18:06:03.834] Future #2
[18:06:03.834]  length: 1 (resolved future 2)
[18:06:03.834]  length: 0 (resolved future 3)
[18:06:03.835] resolve() on list ... DONE
[18:06:03.835] resolved() for ‘SequentialFuture’ ...
[18:06:03.835] - state: ‘finished’
[18:06:03.835] - run: TRUE
[18:06:03.835] - result: ‘FutureResult’
[18:06:03.836] resolved() for ‘SequentialFuture’ ... done
[18:06:03.836] resolved() for ‘SequentialFuture’ ...
[18:06:03.836] - state: ‘finished’
[18:06:03.836] - run: TRUE
[18:06:03.836] - result: ‘FutureResult’
[18:06:03.837] resolved() for ‘SequentialFuture’ ... done
[18:06:03.837] getGlobalsAndPackages() ...
[18:06:03.837] Searching for globals...
[18:06:03.838] 
[18:06:03.838] Searching for globals ... DONE
[18:06:03.838] - globals: [0] <none>
[18:06:03.838] getGlobalsAndPackages() ... DONE
[18:06:03.839] getGlobalsAndPackages() ...
[18:06:03.839] Searching for globals...
[18:06:03.840] 
[18:06:03.840] Searching for globals ... DONE
[18:06:03.840] - globals: [0] <none>
[18:06:03.840] getGlobalsAndPackages() ... DONE
[18:06:03.841] resolve() on list ...
[18:06:03.841]  recursive: 0
[18:06:03.841]  length: 3
[18:06:03.841]  elements: ‘a’, ‘b’, ‘’
[18:06:03.842] run() for ‘Future’ ...
[18:06:03.842] - state: ‘created’
[18:06:03.842] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.843] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.843]   - Field: ‘label’
[18:06:03.843]   - Field: ‘local’
[18:06:03.844]   - Field: ‘owner’
[18:06:03.844]   - Field: ‘envir’
[18:06:03.844]   - Field: ‘packages’
[18:06:03.844]   - Field: ‘gc’
[18:06:03.844]   - Field: ‘conditions’
[18:06:03.845]   - Field: ‘expr’
[18:06:03.845]   - Field: ‘uuid’
[18:06:03.845]   - Field: ‘seed’
[18:06:03.845]   - Field: ‘version’
[18:06:03.845]   - Field: ‘result’
[18:06:03.846]   - Field: ‘asynchronous’
[18:06:03.846]   - Field: ‘calls’
[18:06:03.846]   - Field: ‘globals’
[18:06:03.846]   - Field: ‘stdout’
[18:06:03.846]   - Field: ‘earlySignal’
[18:06:03.847]   - Field: ‘lazy’
[18:06:03.847]   - Field: ‘state’
[18:06:03.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.847] - Launch lazy future ...
[18:06:03.848] Packages needed by the future expression (n = 0): <none>
[18:06:03.848] Packages needed by future strategies (n = 0): <none>
[18:06:03.849] {
[18:06:03.849]     {
[18:06:03.849]         {
[18:06:03.849]             ...future.startTime <- base::Sys.time()
[18:06:03.849]             {
[18:06:03.849]                 {
[18:06:03.849]                   {
[18:06:03.849]                     base::local({
[18:06:03.849]                       has_future <- base::requireNamespace("future", 
[18:06:03.849]                         quietly = TRUE)
[18:06:03.849]                       if (has_future) {
[18:06:03.849]                         ns <- base::getNamespace("future")
[18:06:03.849]                         version <- ns[[".package"]][["version"]]
[18:06:03.849]                         if (is.null(version)) 
[18:06:03.849]                           version <- utils::packageVersion("future")
[18:06:03.849]                       }
[18:06:03.849]                       else {
[18:06:03.849]                         version <- NULL
[18:06:03.849]                       }
[18:06:03.849]                       if (!has_future || version < "1.8.0") {
[18:06:03.849]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.849]                           "", base::R.version$version.string), 
[18:06:03.849]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.849]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.849]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.849]                             "release", "version")], collapse = " "), 
[18:06:03.849]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.849]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.849]                           info)
[18:06:03.849]                         info <- base::paste(info, collapse = "; ")
[18:06:03.849]                         if (!has_future) {
[18:06:03.849]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.849]                             info)
[18:06:03.849]                         }
[18:06:03.849]                         else {
[18:06:03.849]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.849]                             info, version)
[18:06:03.849]                         }
[18:06:03.849]                         base::stop(msg)
[18:06:03.849]                       }
[18:06:03.849]                     })
[18:06:03.849]                   }
[18:06:03.849]                   ...future.strategy.old <- future::plan("list")
[18:06:03.849]                   options(future.plan = NULL)
[18:06:03.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.849]                 }
[18:06:03.849]                 ...future.workdir <- getwd()
[18:06:03.849]             }
[18:06:03.849]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.849]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.849]         }
[18:06:03.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.849]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.849]             base::names(...future.oldOptions))
[18:06:03.849]     }
[18:06:03.849]     if (FALSE) {
[18:06:03.849]     }
[18:06:03.849]     else {
[18:06:03.849]         if (TRUE) {
[18:06:03.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.849]                 open = "w")
[18:06:03.849]         }
[18:06:03.849]         else {
[18:06:03.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.849]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.849]         }
[18:06:03.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.849]             base::sink(type = "output", split = FALSE)
[18:06:03.849]             base::close(...future.stdout)
[18:06:03.849]         }, add = TRUE)
[18:06:03.849]     }
[18:06:03.849]     ...future.frame <- base::sys.nframe()
[18:06:03.849]     ...future.conditions <- base::list()
[18:06:03.849]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.849]     if (FALSE) {
[18:06:03.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.849]     }
[18:06:03.849]     ...future.result <- base::tryCatch({
[18:06:03.849]         base::withCallingHandlers({
[18:06:03.849]             ...future.value <- base::withVisible(base::local(1))
[18:06:03.849]             future::FutureResult(value = ...future.value$value, 
[18:06:03.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.849]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.849]                     ...future.globalenv.names))
[18:06:03.849]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.849]         }, condition = base::local({
[18:06:03.849]             c <- base::c
[18:06:03.849]             inherits <- base::inherits
[18:06:03.849]             invokeRestart <- base::invokeRestart
[18:06:03.849]             length <- base::length
[18:06:03.849]             list <- base::list
[18:06:03.849]             seq.int <- base::seq.int
[18:06:03.849]             signalCondition <- base::signalCondition
[18:06:03.849]             sys.calls <- base::sys.calls
[18:06:03.849]             `[[` <- base::`[[`
[18:06:03.849]             `+` <- base::`+`
[18:06:03.849]             `<<-` <- base::`<<-`
[18:06:03.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.849]                   3L)]
[18:06:03.849]             }
[18:06:03.849]             function(cond) {
[18:06:03.849]                 is_error <- inherits(cond, "error")
[18:06:03.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.849]                   NULL)
[18:06:03.849]                 if (is_error) {
[18:06:03.849]                   sessionInformation <- function() {
[18:06:03.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.849]                       search = base::search(), system = base::Sys.info())
[18:06:03.849]                   }
[18:06:03.849]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.849]                     cond$call), session = sessionInformation(), 
[18:06:03.849]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.849]                   signalCondition(cond)
[18:06:03.849]                 }
[18:06:03.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.849]                 "immediateCondition"))) {
[18:06:03.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.849]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.849]                   if (TRUE && !signal) {
[18:06:03.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.849]                     {
[18:06:03.849]                       inherits <- base::inherits
[18:06:03.849]                       invokeRestart <- base::invokeRestart
[18:06:03.849]                       is.null <- base::is.null
[18:06:03.849]                       muffled <- FALSE
[18:06:03.849]                       if (inherits(cond, "message")) {
[18:06:03.849]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.849]                         if (muffled) 
[18:06:03.849]                           invokeRestart("muffleMessage")
[18:06:03.849]                       }
[18:06:03.849]                       else if (inherits(cond, "warning")) {
[18:06:03.849]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.849]                         if (muffled) 
[18:06:03.849]                           invokeRestart("muffleWarning")
[18:06:03.849]                       }
[18:06:03.849]                       else if (inherits(cond, "condition")) {
[18:06:03.849]                         if (!is.null(pattern)) {
[18:06:03.849]                           computeRestarts <- base::computeRestarts
[18:06:03.849]                           grepl <- base::grepl
[18:06:03.849]                           restarts <- computeRestarts(cond)
[18:06:03.849]                           for (restart in restarts) {
[18:06:03.849]                             name <- restart$name
[18:06:03.849]                             if (is.null(name)) 
[18:06:03.849]                               next
[18:06:03.849]                             if (!grepl(pattern, name)) 
[18:06:03.849]                               next
[18:06:03.849]                             invokeRestart(restart)
[18:06:03.849]                             muffled <- TRUE
[18:06:03.849]                             break
[18:06:03.849]                           }
[18:06:03.849]                         }
[18:06:03.849]                       }
[18:06:03.849]                       invisible(muffled)
[18:06:03.849]                     }
[18:06:03.849]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.849]                   }
[18:06:03.849]                 }
[18:06:03.849]                 else {
[18:06:03.849]                   if (TRUE) {
[18:06:03.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.849]                     {
[18:06:03.849]                       inherits <- base::inherits
[18:06:03.849]                       invokeRestart <- base::invokeRestart
[18:06:03.849]                       is.null <- base::is.null
[18:06:03.849]                       muffled <- FALSE
[18:06:03.849]                       if (inherits(cond, "message")) {
[18:06:03.849]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.849]                         if (muffled) 
[18:06:03.849]                           invokeRestart("muffleMessage")
[18:06:03.849]                       }
[18:06:03.849]                       else if (inherits(cond, "warning")) {
[18:06:03.849]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.849]                         if (muffled) 
[18:06:03.849]                           invokeRestart("muffleWarning")
[18:06:03.849]                       }
[18:06:03.849]                       else if (inherits(cond, "condition")) {
[18:06:03.849]                         if (!is.null(pattern)) {
[18:06:03.849]                           computeRestarts <- base::computeRestarts
[18:06:03.849]                           grepl <- base::grepl
[18:06:03.849]                           restarts <- computeRestarts(cond)
[18:06:03.849]                           for (restart in restarts) {
[18:06:03.849]                             name <- restart$name
[18:06:03.849]                             if (is.null(name)) 
[18:06:03.849]                               next
[18:06:03.849]                             if (!grepl(pattern, name)) 
[18:06:03.849]                               next
[18:06:03.849]                             invokeRestart(restart)
[18:06:03.849]                             muffled <- TRUE
[18:06:03.849]                             break
[18:06:03.849]                           }
[18:06:03.849]                         }
[18:06:03.849]                       }
[18:06:03.849]                       invisible(muffled)
[18:06:03.849]                     }
[18:06:03.849]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.849]                   }
[18:06:03.849]                 }
[18:06:03.849]             }
[18:06:03.849]         }))
[18:06:03.849]     }, error = function(ex) {
[18:06:03.849]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.849]                 ...future.rng), started = ...future.startTime, 
[18:06:03.849]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.849]             version = "1.8"), class = "FutureResult")
[18:06:03.849]     }, finally = {
[18:06:03.849]         if (!identical(...future.workdir, getwd())) 
[18:06:03.849]             setwd(...future.workdir)
[18:06:03.849]         {
[18:06:03.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.849]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.849]             }
[18:06:03.849]             base::options(...future.oldOptions)
[18:06:03.849]             if (.Platform$OS.type == "windows") {
[18:06:03.849]                 old_names <- names(...future.oldEnvVars)
[18:06:03.849]                 envs <- base::Sys.getenv()
[18:06:03.849]                 names <- names(envs)
[18:06:03.849]                 common <- intersect(names, old_names)
[18:06:03.849]                 added <- setdiff(names, old_names)
[18:06:03.849]                 removed <- setdiff(old_names, names)
[18:06:03.849]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.849]                   envs[common]]
[18:06:03.849]                 NAMES <- toupper(changed)
[18:06:03.849]                 args <- list()
[18:06:03.849]                 for (kk in seq_along(NAMES)) {
[18:06:03.849]                   name <- changed[[kk]]
[18:06:03.849]                   NAME <- NAMES[[kk]]
[18:06:03.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.849]                     next
[18:06:03.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.849]                 }
[18:06:03.849]                 NAMES <- toupper(added)
[18:06:03.849]                 for (kk in seq_along(NAMES)) {
[18:06:03.849]                   name <- added[[kk]]
[18:06:03.849]                   NAME <- NAMES[[kk]]
[18:06:03.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.849]                     next
[18:06:03.849]                   args[[name]] <- ""
[18:06:03.849]                 }
[18:06:03.849]                 NAMES <- toupper(removed)
[18:06:03.849]                 for (kk in seq_along(NAMES)) {
[18:06:03.849]                   name <- removed[[kk]]
[18:06:03.849]                   NAME <- NAMES[[kk]]
[18:06:03.849]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.849]                     next
[18:06:03.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.849]                 }
[18:06:03.849]                 if (length(args) > 0) 
[18:06:03.849]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.849]             }
[18:06:03.849]             else {
[18:06:03.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.849]             }
[18:06:03.849]             {
[18:06:03.849]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.849]                   0L) {
[18:06:03.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.849]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.849]                   base::options(opts)
[18:06:03.849]                 }
[18:06:03.849]                 {
[18:06:03.849]                   {
[18:06:03.849]                     NULL
[18:06:03.849]                     RNGkind("Mersenne-Twister")
[18:06:03.849]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.849]                       inherits = FALSE)
[18:06:03.849]                   }
[18:06:03.849]                   options(future.plan = NULL)
[18:06:03.849]                   if (is.na(NA_character_)) 
[18:06:03.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.849]                     .init = FALSE)
[18:06:03.849]                 }
[18:06:03.849]             }
[18:06:03.849]         }
[18:06:03.849]     })
[18:06:03.849]     if (TRUE) {
[18:06:03.849]         base::sink(type = "output", split = FALSE)
[18:06:03.849]         if (TRUE) {
[18:06:03.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.849]         }
[18:06:03.849]         else {
[18:06:03.849]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.849]         }
[18:06:03.849]         base::close(...future.stdout)
[18:06:03.849]         ...future.stdout <- NULL
[18:06:03.849]     }
[18:06:03.849]     ...future.result$conditions <- ...future.conditions
[18:06:03.849]     ...future.result$finished <- base::Sys.time()
[18:06:03.849]     ...future.result
[18:06:03.849] }
[18:06:03.852] plan(): Setting new future strategy stack:
[18:06:03.853] List of future strategies:
[18:06:03.853] 1. sequential:
[18:06:03.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.853]    - tweaked: FALSE
[18:06:03.853]    - call: NULL
[18:06:03.854] plan(): nbrOfWorkers() = 1
[18:06:03.855] plan(): Setting new future strategy stack:
[18:06:03.856] List of future strategies:
[18:06:03.856] 1. sequential:
[18:06:03.856]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.856]    - tweaked: FALSE
[18:06:03.856]    - call: plan(strategy)
[18:06:03.857] plan(): nbrOfWorkers() = 1
[18:06:03.857] SequentialFuture started (and completed)
[18:06:03.857] - Launch lazy future ... done
[18:06:03.858] run() for ‘SequentialFuture’ ... done
[18:06:03.858] resolved() for ‘SequentialFuture’ ...
[18:06:03.858] - state: ‘finished’
[18:06:03.858] - run: TRUE
[18:06:03.859] - result: ‘FutureResult’
[18:06:03.859] resolved() for ‘SequentialFuture’ ... done
[18:06:03.859] Future #1
[18:06:03.859]  length: 2 (resolved future 1)
[18:06:03.859] run() for ‘Future’ ...
[18:06:03.860] - state: ‘created’
[18:06:03.860] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.860] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.861]   - Field: ‘label’
[18:06:03.861]   - Field: ‘local’
[18:06:03.861]   - Field: ‘owner’
[18:06:03.862]   - Field: ‘envir’
[18:06:03.862]   - Field: ‘packages’
[18:06:03.862]   - Field: ‘gc’
[18:06:03.862]   - Field: ‘conditions’
[18:06:03.862]   - Field: ‘expr’
[18:06:03.863]   - Field: ‘uuid’
[18:06:03.863]   - Field: ‘seed’
[18:06:03.863]   - Field: ‘version’
[18:06:03.863]   - Field: ‘result’
[18:06:03.863]   - Field: ‘asynchronous’
[18:06:03.864]   - Field: ‘calls’
[18:06:03.864]   - Field: ‘globals’
[18:06:03.864]   - Field: ‘stdout’
[18:06:03.864]   - Field: ‘earlySignal’
[18:06:03.864]   - Field: ‘lazy’
[18:06:03.865]   - Field: ‘state’
[18:06:03.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.865] - Launch lazy future ...
[18:06:03.865] Packages needed by the future expression (n = 0): <none>
[18:06:03.866] Packages needed by future strategies (n = 0): <none>
[18:06:03.867] {
[18:06:03.867]     {
[18:06:03.867]         {
[18:06:03.867]             ...future.startTime <- base::Sys.time()
[18:06:03.867]             {
[18:06:03.867]                 {
[18:06:03.867]                   {
[18:06:03.867]                     base::local({
[18:06:03.867]                       has_future <- base::requireNamespace("future", 
[18:06:03.867]                         quietly = TRUE)
[18:06:03.867]                       if (has_future) {
[18:06:03.867]                         ns <- base::getNamespace("future")
[18:06:03.867]                         version <- ns[[".package"]][["version"]]
[18:06:03.867]                         if (is.null(version)) 
[18:06:03.867]                           version <- utils::packageVersion("future")
[18:06:03.867]                       }
[18:06:03.867]                       else {
[18:06:03.867]                         version <- NULL
[18:06:03.867]                       }
[18:06:03.867]                       if (!has_future || version < "1.8.0") {
[18:06:03.867]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.867]                           "", base::R.version$version.string), 
[18:06:03.867]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.867]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.867]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.867]                             "release", "version")], collapse = " "), 
[18:06:03.867]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.867]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.867]                           info)
[18:06:03.867]                         info <- base::paste(info, collapse = "; ")
[18:06:03.867]                         if (!has_future) {
[18:06:03.867]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.867]                             info)
[18:06:03.867]                         }
[18:06:03.867]                         else {
[18:06:03.867]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.867]                             info, version)
[18:06:03.867]                         }
[18:06:03.867]                         base::stop(msg)
[18:06:03.867]                       }
[18:06:03.867]                     })
[18:06:03.867]                   }
[18:06:03.867]                   ...future.strategy.old <- future::plan("list")
[18:06:03.867]                   options(future.plan = NULL)
[18:06:03.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.867]                 }
[18:06:03.867]                 ...future.workdir <- getwd()
[18:06:03.867]             }
[18:06:03.867]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.867]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.867]         }
[18:06:03.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.867]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.867]             base::names(...future.oldOptions))
[18:06:03.867]     }
[18:06:03.867]     if (FALSE) {
[18:06:03.867]     }
[18:06:03.867]     else {
[18:06:03.867]         if (TRUE) {
[18:06:03.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.867]                 open = "w")
[18:06:03.867]         }
[18:06:03.867]         else {
[18:06:03.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.867]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.867]         }
[18:06:03.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.867]             base::sink(type = "output", split = FALSE)
[18:06:03.867]             base::close(...future.stdout)
[18:06:03.867]         }, add = TRUE)
[18:06:03.867]     }
[18:06:03.867]     ...future.frame <- base::sys.nframe()
[18:06:03.867]     ...future.conditions <- base::list()
[18:06:03.867]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.867]     if (FALSE) {
[18:06:03.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.867]     }
[18:06:03.867]     ...future.result <- base::tryCatch({
[18:06:03.867]         base::withCallingHandlers({
[18:06:03.867]             ...future.value <- base::withVisible(base::local(2))
[18:06:03.867]             future::FutureResult(value = ...future.value$value, 
[18:06:03.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.867]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.867]                     ...future.globalenv.names))
[18:06:03.867]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.867]         }, condition = base::local({
[18:06:03.867]             c <- base::c
[18:06:03.867]             inherits <- base::inherits
[18:06:03.867]             invokeRestart <- base::invokeRestart
[18:06:03.867]             length <- base::length
[18:06:03.867]             list <- base::list
[18:06:03.867]             seq.int <- base::seq.int
[18:06:03.867]             signalCondition <- base::signalCondition
[18:06:03.867]             sys.calls <- base::sys.calls
[18:06:03.867]             `[[` <- base::`[[`
[18:06:03.867]             `+` <- base::`+`
[18:06:03.867]             `<<-` <- base::`<<-`
[18:06:03.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.867]                   3L)]
[18:06:03.867]             }
[18:06:03.867]             function(cond) {
[18:06:03.867]                 is_error <- inherits(cond, "error")
[18:06:03.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.867]                   NULL)
[18:06:03.867]                 if (is_error) {
[18:06:03.867]                   sessionInformation <- function() {
[18:06:03.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.867]                       search = base::search(), system = base::Sys.info())
[18:06:03.867]                   }
[18:06:03.867]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.867]                     cond$call), session = sessionInformation(), 
[18:06:03.867]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.867]                   signalCondition(cond)
[18:06:03.867]                 }
[18:06:03.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.867]                 "immediateCondition"))) {
[18:06:03.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.867]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.867]                   if (TRUE && !signal) {
[18:06:03.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.867]                     {
[18:06:03.867]                       inherits <- base::inherits
[18:06:03.867]                       invokeRestart <- base::invokeRestart
[18:06:03.867]                       is.null <- base::is.null
[18:06:03.867]                       muffled <- FALSE
[18:06:03.867]                       if (inherits(cond, "message")) {
[18:06:03.867]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.867]                         if (muffled) 
[18:06:03.867]                           invokeRestart("muffleMessage")
[18:06:03.867]                       }
[18:06:03.867]                       else if (inherits(cond, "warning")) {
[18:06:03.867]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.867]                         if (muffled) 
[18:06:03.867]                           invokeRestart("muffleWarning")
[18:06:03.867]                       }
[18:06:03.867]                       else if (inherits(cond, "condition")) {
[18:06:03.867]                         if (!is.null(pattern)) {
[18:06:03.867]                           computeRestarts <- base::computeRestarts
[18:06:03.867]                           grepl <- base::grepl
[18:06:03.867]                           restarts <- computeRestarts(cond)
[18:06:03.867]                           for (restart in restarts) {
[18:06:03.867]                             name <- restart$name
[18:06:03.867]                             if (is.null(name)) 
[18:06:03.867]                               next
[18:06:03.867]                             if (!grepl(pattern, name)) 
[18:06:03.867]                               next
[18:06:03.867]                             invokeRestart(restart)
[18:06:03.867]                             muffled <- TRUE
[18:06:03.867]                             break
[18:06:03.867]                           }
[18:06:03.867]                         }
[18:06:03.867]                       }
[18:06:03.867]                       invisible(muffled)
[18:06:03.867]                     }
[18:06:03.867]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.867]                   }
[18:06:03.867]                 }
[18:06:03.867]                 else {
[18:06:03.867]                   if (TRUE) {
[18:06:03.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.867]                     {
[18:06:03.867]                       inherits <- base::inherits
[18:06:03.867]                       invokeRestart <- base::invokeRestart
[18:06:03.867]                       is.null <- base::is.null
[18:06:03.867]                       muffled <- FALSE
[18:06:03.867]                       if (inherits(cond, "message")) {
[18:06:03.867]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.867]                         if (muffled) 
[18:06:03.867]                           invokeRestart("muffleMessage")
[18:06:03.867]                       }
[18:06:03.867]                       else if (inherits(cond, "warning")) {
[18:06:03.867]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.867]                         if (muffled) 
[18:06:03.867]                           invokeRestart("muffleWarning")
[18:06:03.867]                       }
[18:06:03.867]                       else if (inherits(cond, "condition")) {
[18:06:03.867]                         if (!is.null(pattern)) {
[18:06:03.867]                           computeRestarts <- base::computeRestarts
[18:06:03.867]                           grepl <- base::grepl
[18:06:03.867]                           restarts <- computeRestarts(cond)
[18:06:03.867]                           for (restart in restarts) {
[18:06:03.867]                             name <- restart$name
[18:06:03.867]                             if (is.null(name)) 
[18:06:03.867]                               next
[18:06:03.867]                             if (!grepl(pattern, name)) 
[18:06:03.867]                               next
[18:06:03.867]                             invokeRestart(restart)
[18:06:03.867]                             muffled <- TRUE
[18:06:03.867]                             break
[18:06:03.867]                           }
[18:06:03.867]                         }
[18:06:03.867]                       }
[18:06:03.867]                       invisible(muffled)
[18:06:03.867]                     }
[18:06:03.867]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.867]                   }
[18:06:03.867]                 }
[18:06:03.867]             }
[18:06:03.867]         }))
[18:06:03.867]     }, error = function(ex) {
[18:06:03.867]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.867]                 ...future.rng), started = ...future.startTime, 
[18:06:03.867]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.867]             version = "1.8"), class = "FutureResult")
[18:06:03.867]     }, finally = {
[18:06:03.867]         if (!identical(...future.workdir, getwd())) 
[18:06:03.867]             setwd(...future.workdir)
[18:06:03.867]         {
[18:06:03.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.867]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.867]             }
[18:06:03.867]             base::options(...future.oldOptions)
[18:06:03.867]             if (.Platform$OS.type == "windows") {
[18:06:03.867]                 old_names <- names(...future.oldEnvVars)
[18:06:03.867]                 envs <- base::Sys.getenv()
[18:06:03.867]                 names <- names(envs)
[18:06:03.867]                 common <- intersect(names, old_names)
[18:06:03.867]                 added <- setdiff(names, old_names)
[18:06:03.867]                 removed <- setdiff(old_names, names)
[18:06:03.867]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.867]                   envs[common]]
[18:06:03.867]                 NAMES <- toupper(changed)
[18:06:03.867]                 args <- list()
[18:06:03.867]                 for (kk in seq_along(NAMES)) {
[18:06:03.867]                   name <- changed[[kk]]
[18:06:03.867]                   NAME <- NAMES[[kk]]
[18:06:03.867]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.867]                     next
[18:06:03.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.867]                 }
[18:06:03.867]                 NAMES <- toupper(added)
[18:06:03.867]                 for (kk in seq_along(NAMES)) {
[18:06:03.867]                   name <- added[[kk]]
[18:06:03.867]                   NAME <- NAMES[[kk]]
[18:06:03.867]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.867]                     next
[18:06:03.867]                   args[[name]] <- ""
[18:06:03.867]                 }
[18:06:03.867]                 NAMES <- toupper(removed)
[18:06:03.867]                 for (kk in seq_along(NAMES)) {
[18:06:03.867]                   name <- removed[[kk]]
[18:06:03.867]                   NAME <- NAMES[[kk]]
[18:06:03.867]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.867]                     next
[18:06:03.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.867]                 }
[18:06:03.867]                 if (length(args) > 0) 
[18:06:03.867]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.867]             }
[18:06:03.867]             else {
[18:06:03.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.867]             }
[18:06:03.867]             {
[18:06:03.867]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.867]                   0L) {
[18:06:03.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.867]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.867]                   base::options(opts)
[18:06:03.867]                 }
[18:06:03.867]                 {
[18:06:03.867]                   {
[18:06:03.867]                     NULL
[18:06:03.867]                     RNGkind("Mersenne-Twister")
[18:06:03.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.867]                       inherits = FALSE)
[18:06:03.867]                   }
[18:06:03.867]                   options(future.plan = NULL)
[18:06:03.867]                   if (is.na(NA_character_)) 
[18:06:03.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.867]                     .init = FALSE)
[18:06:03.867]                 }
[18:06:03.867]             }
[18:06:03.867]         }
[18:06:03.867]     })
[18:06:03.867]     if (TRUE) {
[18:06:03.867]         base::sink(type = "output", split = FALSE)
[18:06:03.867]         if (TRUE) {
[18:06:03.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.867]         }
[18:06:03.867]         else {
[18:06:03.867]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.867]         }
[18:06:03.867]         base::close(...future.stdout)
[18:06:03.867]         ...future.stdout <- NULL
[18:06:03.867]     }
[18:06:03.867]     ...future.result$conditions <- ...future.conditions
[18:06:03.867]     ...future.result$finished <- base::Sys.time()
[18:06:03.867]     ...future.result
[18:06:03.867] }
[18:06:03.870] plan(): Setting new future strategy stack:
[18:06:03.870] List of future strategies:
[18:06:03.870] 1. sequential:
[18:06:03.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.870]    - tweaked: FALSE
[18:06:03.870]    - call: NULL
[18:06:03.871] plan(): nbrOfWorkers() = 1
[18:06:03.873] plan(): Setting new future strategy stack:
[18:06:03.873] List of future strategies:
[18:06:03.873] 1. sequential:
[18:06:03.873]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.873]    - tweaked: FALSE
[18:06:03.873]    - call: plan(strategy)
[18:06:03.874] plan(): nbrOfWorkers() = 1
[18:06:03.875] SequentialFuture started (and completed)
[18:06:03.875] - Launch lazy future ... done
[18:06:03.875] run() for ‘SequentialFuture’ ... done
[18:06:03.876] resolved() for ‘SequentialFuture’ ...
[18:06:03.876] - state: ‘finished’
[18:06:03.876] - run: TRUE
[18:06:03.876] - result: ‘FutureResult’
[18:06:03.876] resolved() for ‘SequentialFuture’ ... done
[18:06:03.877] Future #2
[18:06:03.877]  length: 1 (resolved future 2)
[18:06:03.877]  length: 0 (resolved future 3)
[18:06:03.877] resolve() on list ... DONE
[18:06:03.877] resolved() for ‘SequentialFuture’ ...
[18:06:03.878] - state: ‘finished’
[18:06:03.878] - run: TRUE
[18:06:03.878] - result: ‘FutureResult’
[18:06:03.878] resolved() for ‘SequentialFuture’ ... done
[18:06:03.878] resolved() for ‘SequentialFuture’ ...
[18:06:03.879] - state: ‘finished’
[18:06:03.879] - run: TRUE
[18:06:03.879] - result: ‘FutureResult’
[18:06:03.879] resolved() for ‘SequentialFuture’ ... done
[18:06:03.879] getGlobalsAndPackages() ...
[18:06:03.880] Searching for globals...
[18:06:03.880] 
[18:06:03.881] Searching for globals ... DONE
[18:06:03.881] - globals: [0] <none>
[18:06:03.881] getGlobalsAndPackages() ... DONE
[18:06:03.882] run() for ‘Future’ ...
[18:06:03.882] - state: ‘created’
[18:06:03.882] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.883] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.883]   - Field: ‘label’
[18:06:03.883]   - Field: ‘local’
[18:06:03.884]   - Field: ‘owner’
[18:06:03.884]   - Field: ‘envir’
[18:06:03.884]   - Field: ‘packages’
[18:06:03.884]   - Field: ‘gc’
[18:06:03.884]   - Field: ‘conditions’
[18:06:03.885]   - Field: ‘expr’
[18:06:03.885]   - Field: ‘uuid’
[18:06:03.885]   - Field: ‘seed’
[18:06:03.885]   - Field: ‘version’
[18:06:03.885]   - Field: ‘result’
[18:06:03.886]   - Field: ‘asynchronous’
[18:06:03.886]   - Field: ‘calls’
[18:06:03.886]   - Field: ‘globals’
[18:06:03.886]   - Field: ‘stdout’
[18:06:03.886]   - Field: ‘earlySignal’
[18:06:03.886]   - Field: ‘lazy’
[18:06:03.887]   - Field: ‘state’
[18:06:03.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.887] - Launch lazy future ...
[18:06:03.887] Packages needed by the future expression (n = 0): <none>
[18:06:03.888] Packages needed by future strategies (n = 0): <none>
[18:06:03.889] {
[18:06:03.889]     {
[18:06:03.889]         {
[18:06:03.889]             ...future.startTime <- base::Sys.time()
[18:06:03.889]             {
[18:06:03.889]                 {
[18:06:03.889]                   {
[18:06:03.889]                     base::local({
[18:06:03.889]                       has_future <- base::requireNamespace("future", 
[18:06:03.889]                         quietly = TRUE)
[18:06:03.889]                       if (has_future) {
[18:06:03.889]                         ns <- base::getNamespace("future")
[18:06:03.889]                         version <- ns[[".package"]][["version"]]
[18:06:03.889]                         if (is.null(version)) 
[18:06:03.889]                           version <- utils::packageVersion("future")
[18:06:03.889]                       }
[18:06:03.889]                       else {
[18:06:03.889]                         version <- NULL
[18:06:03.889]                       }
[18:06:03.889]                       if (!has_future || version < "1.8.0") {
[18:06:03.889]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.889]                           "", base::R.version$version.string), 
[18:06:03.889]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.889]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.889]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.889]                             "release", "version")], collapse = " "), 
[18:06:03.889]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.889]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.889]                           info)
[18:06:03.889]                         info <- base::paste(info, collapse = "; ")
[18:06:03.889]                         if (!has_future) {
[18:06:03.889]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.889]                             info)
[18:06:03.889]                         }
[18:06:03.889]                         else {
[18:06:03.889]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.889]                             info, version)
[18:06:03.889]                         }
[18:06:03.889]                         base::stop(msg)
[18:06:03.889]                       }
[18:06:03.889]                     })
[18:06:03.889]                   }
[18:06:03.889]                   ...future.strategy.old <- future::plan("list")
[18:06:03.889]                   options(future.plan = NULL)
[18:06:03.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.889]                 }
[18:06:03.889]                 ...future.workdir <- getwd()
[18:06:03.889]             }
[18:06:03.889]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.889]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.889]         }
[18:06:03.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.889]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.889]             base::names(...future.oldOptions))
[18:06:03.889]     }
[18:06:03.889]     if (FALSE) {
[18:06:03.889]     }
[18:06:03.889]     else {
[18:06:03.889]         if (TRUE) {
[18:06:03.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.889]                 open = "w")
[18:06:03.889]         }
[18:06:03.889]         else {
[18:06:03.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.889]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.889]         }
[18:06:03.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.889]             base::sink(type = "output", split = FALSE)
[18:06:03.889]             base::close(...future.stdout)
[18:06:03.889]         }, add = TRUE)
[18:06:03.889]     }
[18:06:03.889]     ...future.frame <- base::sys.nframe()
[18:06:03.889]     ...future.conditions <- base::list()
[18:06:03.889]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.889]     if (FALSE) {
[18:06:03.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.889]     }
[18:06:03.889]     ...future.result <- base::tryCatch({
[18:06:03.889]         base::withCallingHandlers({
[18:06:03.889]             ...future.value <- base::withVisible(base::local(1))
[18:06:03.889]             future::FutureResult(value = ...future.value$value, 
[18:06:03.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.889]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.889]                     ...future.globalenv.names))
[18:06:03.889]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.889]         }, condition = base::local({
[18:06:03.889]             c <- base::c
[18:06:03.889]             inherits <- base::inherits
[18:06:03.889]             invokeRestart <- base::invokeRestart
[18:06:03.889]             length <- base::length
[18:06:03.889]             list <- base::list
[18:06:03.889]             seq.int <- base::seq.int
[18:06:03.889]             signalCondition <- base::signalCondition
[18:06:03.889]             sys.calls <- base::sys.calls
[18:06:03.889]             `[[` <- base::`[[`
[18:06:03.889]             `+` <- base::`+`
[18:06:03.889]             `<<-` <- base::`<<-`
[18:06:03.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.889]                   3L)]
[18:06:03.889]             }
[18:06:03.889]             function(cond) {
[18:06:03.889]                 is_error <- inherits(cond, "error")
[18:06:03.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.889]                   NULL)
[18:06:03.889]                 if (is_error) {
[18:06:03.889]                   sessionInformation <- function() {
[18:06:03.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.889]                       search = base::search(), system = base::Sys.info())
[18:06:03.889]                   }
[18:06:03.889]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.889]                     cond$call), session = sessionInformation(), 
[18:06:03.889]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.889]                   signalCondition(cond)
[18:06:03.889]                 }
[18:06:03.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.889]                 "immediateCondition"))) {
[18:06:03.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.889]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.889]                   if (TRUE && !signal) {
[18:06:03.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.889]                     {
[18:06:03.889]                       inherits <- base::inherits
[18:06:03.889]                       invokeRestart <- base::invokeRestart
[18:06:03.889]                       is.null <- base::is.null
[18:06:03.889]                       muffled <- FALSE
[18:06:03.889]                       if (inherits(cond, "message")) {
[18:06:03.889]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.889]                         if (muffled) 
[18:06:03.889]                           invokeRestart("muffleMessage")
[18:06:03.889]                       }
[18:06:03.889]                       else if (inherits(cond, "warning")) {
[18:06:03.889]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.889]                         if (muffled) 
[18:06:03.889]                           invokeRestart("muffleWarning")
[18:06:03.889]                       }
[18:06:03.889]                       else if (inherits(cond, "condition")) {
[18:06:03.889]                         if (!is.null(pattern)) {
[18:06:03.889]                           computeRestarts <- base::computeRestarts
[18:06:03.889]                           grepl <- base::grepl
[18:06:03.889]                           restarts <- computeRestarts(cond)
[18:06:03.889]                           for (restart in restarts) {
[18:06:03.889]                             name <- restart$name
[18:06:03.889]                             if (is.null(name)) 
[18:06:03.889]                               next
[18:06:03.889]                             if (!grepl(pattern, name)) 
[18:06:03.889]                               next
[18:06:03.889]                             invokeRestart(restart)
[18:06:03.889]                             muffled <- TRUE
[18:06:03.889]                             break
[18:06:03.889]                           }
[18:06:03.889]                         }
[18:06:03.889]                       }
[18:06:03.889]                       invisible(muffled)
[18:06:03.889]                     }
[18:06:03.889]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.889]                   }
[18:06:03.889]                 }
[18:06:03.889]                 else {
[18:06:03.889]                   if (TRUE) {
[18:06:03.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.889]                     {
[18:06:03.889]                       inherits <- base::inherits
[18:06:03.889]                       invokeRestart <- base::invokeRestart
[18:06:03.889]                       is.null <- base::is.null
[18:06:03.889]                       muffled <- FALSE
[18:06:03.889]                       if (inherits(cond, "message")) {
[18:06:03.889]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.889]                         if (muffled) 
[18:06:03.889]                           invokeRestart("muffleMessage")
[18:06:03.889]                       }
[18:06:03.889]                       else if (inherits(cond, "warning")) {
[18:06:03.889]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.889]                         if (muffled) 
[18:06:03.889]                           invokeRestart("muffleWarning")
[18:06:03.889]                       }
[18:06:03.889]                       else if (inherits(cond, "condition")) {
[18:06:03.889]                         if (!is.null(pattern)) {
[18:06:03.889]                           computeRestarts <- base::computeRestarts
[18:06:03.889]                           grepl <- base::grepl
[18:06:03.889]                           restarts <- computeRestarts(cond)
[18:06:03.889]                           for (restart in restarts) {
[18:06:03.889]                             name <- restart$name
[18:06:03.889]                             if (is.null(name)) 
[18:06:03.889]                               next
[18:06:03.889]                             if (!grepl(pattern, name)) 
[18:06:03.889]                               next
[18:06:03.889]                             invokeRestart(restart)
[18:06:03.889]                             muffled <- TRUE
[18:06:03.889]                             break
[18:06:03.889]                           }
[18:06:03.889]                         }
[18:06:03.889]                       }
[18:06:03.889]                       invisible(muffled)
[18:06:03.889]                     }
[18:06:03.889]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.889]                   }
[18:06:03.889]                 }
[18:06:03.889]             }
[18:06:03.889]         }))
[18:06:03.889]     }, error = function(ex) {
[18:06:03.889]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.889]                 ...future.rng), started = ...future.startTime, 
[18:06:03.889]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.889]             version = "1.8"), class = "FutureResult")
[18:06:03.889]     }, finally = {
[18:06:03.889]         if (!identical(...future.workdir, getwd())) 
[18:06:03.889]             setwd(...future.workdir)
[18:06:03.889]         {
[18:06:03.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.889]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.889]             }
[18:06:03.889]             base::options(...future.oldOptions)
[18:06:03.889]             if (.Platform$OS.type == "windows") {
[18:06:03.889]                 old_names <- names(...future.oldEnvVars)
[18:06:03.889]                 envs <- base::Sys.getenv()
[18:06:03.889]                 names <- names(envs)
[18:06:03.889]                 common <- intersect(names, old_names)
[18:06:03.889]                 added <- setdiff(names, old_names)
[18:06:03.889]                 removed <- setdiff(old_names, names)
[18:06:03.889]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.889]                   envs[common]]
[18:06:03.889]                 NAMES <- toupper(changed)
[18:06:03.889]                 args <- list()
[18:06:03.889]                 for (kk in seq_along(NAMES)) {
[18:06:03.889]                   name <- changed[[kk]]
[18:06:03.889]                   NAME <- NAMES[[kk]]
[18:06:03.889]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.889]                     next
[18:06:03.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.889]                 }
[18:06:03.889]                 NAMES <- toupper(added)
[18:06:03.889]                 for (kk in seq_along(NAMES)) {
[18:06:03.889]                   name <- added[[kk]]
[18:06:03.889]                   NAME <- NAMES[[kk]]
[18:06:03.889]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.889]                     next
[18:06:03.889]                   args[[name]] <- ""
[18:06:03.889]                 }
[18:06:03.889]                 NAMES <- toupper(removed)
[18:06:03.889]                 for (kk in seq_along(NAMES)) {
[18:06:03.889]                   name <- removed[[kk]]
[18:06:03.889]                   NAME <- NAMES[[kk]]
[18:06:03.889]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.889]                     next
[18:06:03.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.889]                 }
[18:06:03.889]                 if (length(args) > 0) 
[18:06:03.889]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.889]             }
[18:06:03.889]             else {
[18:06:03.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.889]             }
[18:06:03.889]             {
[18:06:03.889]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.889]                   0L) {
[18:06:03.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.889]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.889]                   base::options(opts)
[18:06:03.889]                 }
[18:06:03.889]                 {
[18:06:03.889]                   {
[18:06:03.889]                     NULL
[18:06:03.889]                     RNGkind("Mersenne-Twister")
[18:06:03.889]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.889]                       inherits = FALSE)
[18:06:03.889]                   }
[18:06:03.889]                   options(future.plan = NULL)
[18:06:03.889]                   if (is.na(NA_character_)) 
[18:06:03.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.889]                     .init = FALSE)
[18:06:03.889]                 }
[18:06:03.889]             }
[18:06:03.889]         }
[18:06:03.889]     })
[18:06:03.889]     if (TRUE) {
[18:06:03.889]         base::sink(type = "output", split = FALSE)
[18:06:03.889]         if (TRUE) {
[18:06:03.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.889]         }
[18:06:03.889]         else {
[18:06:03.889]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.889]         }
[18:06:03.889]         base::close(...future.stdout)
[18:06:03.889]         ...future.stdout <- NULL
[18:06:03.889]     }
[18:06:03.889]     ...future.result$conditions <- ...future.conditions
[18:06:03.889]     ...future.result$finished <- base::Sys.time()
[18:06:03.889]     ...future.result
[18:06:03.889] }
[18:06:03.892] plan(): Setting new future strategy stack:
[18:06:03.893] List of future strategies:
[18:06:03.893] 1. sequential:
[18:06:03.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.893]    - tweaked: FALSE
[18:06:03.893]    - call: NULL
[18:06:03.894] plan(): nbrOfWorkers() = 1
[18:06:03.895] plan(): Setting new future strategy stack:
[18:06:03.895] List of future strategies:
[18:06:03.895] 1. sequential:
[18:06:03.895]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.895]    - tweaked: FALSE
[18:06:03.895]    - call: plan(strategy)
[18:06:03.897] plan(): nbrOfWorkers() = 1
[18:06:03.897] SequentialFuture started (and completed)
[18:06:03.897] - Launch lazy future ... done
[18:06:03.898] run() for ‘SequentialFuture’ ... done
[18:06:03.898] getGlobalsAndPackages() ...
[18:06:03.898] Searching for globals...
[18:06:03.910] - globals found: [2] ‘{’, ‘Sys.sleep’
[18:06:03.911] Searching for globals ... DONE
[18:06:03.911] Resolving globals: FALSE
[18:06:03.912] 
[18:06:03.912] 
[18:06:03.912] getGlobalsAndPackages() ... DONE
[18:06:03.913] run() for ‘Future’ ...
[18:06:03.913] - state: ‘created’
[18:06:03.913] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:03.914] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:03.914] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:03.915]   - Field: ‘label’
[18:06:03.915]   - Field: ‘local’
[18:06:03.915]   - Field: ‘owner’
[18:06:03.915]   - Field: ‘envir’
[18:06:03.915]   - Field: ‘packages’
[18:06:03.916]   - Field: ‘gc’
[18:06:03.916]   - Field: ‘conditions’
[18:06:03.916]   - Field: ‘expr’
[18:06:03.916]   - Field: ‘uuid’
[18:06:03.916]   - Field: ‘seed’
[18:06:03.917]   - Field: ‘version’
[18:06:03.917]   - Field: ‘result’
[18:06:03.917]   - Field: ‘asynchronous’
[18:06:03.917]   - Field: ‘calls’
[18:06:03.917]   - Field: ‘globals’
[18:06:03.918]   - Field: ‘stdout’
[18:06:03.918]   - Field: ‘earlySignal’
[18:06:03.918]   - Field: ‘lazy’
[18:06:03.918]   - Field: ‘state’
[18:06:03.918] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:03.919] - Launch lazy future ...
[18:06:03.919] Packages needed by the future expression (n = 0): <none>
[18:06:03.919] Packages needed by future strategies (n = 0): <none>
[18:06:03.920] {
[18:06:03.920]     {
[18:06:03.920]         {
[18:06:03.920]             ...future.startTime <- base::Sys.time()
[18:06:03.920]             {
[18:06:03.920]                 {
[18:06:03.920]                   {
[18:06:03.920]                     base::local({
[18:06:03.920]                       has_future <- base::requireNamespace("future", 
[18:06:03.920]                         quietly = TRUE)
[18:06:03.920]                       if (has_future) {
[18:06:03.920]                         ns <- base::getNamespace("future")
[18:06:03.920]                         version <- ns[[".package"]][["version"]]
[18:06:03.920]                         if (is.null(version)) 
[18:06:03.920]                           version <- utils::packageVersion("future")
[18:06:03.920]                       }
[18:06:03.920]                       else {
[18:06:03.920]                         version <- NULL
[18:06:03.920]                       }
[18:06:03.920]                       if (!has_future || version < "1.8.0") {
[18:06:03.920]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:03.920]                           "", base::R.version$version.string), 
[18:06:03.920]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:03.920]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:03.920]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:03.920]                             "release", "version")], collapse = " "), 
[18:06:03.920]                           hostname = base::Sys.info()[["nodename"]])
[18:06:03.920]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:03.920]                           info)
[18:06:03.920]                         info <- base::paste(info, collapse = "; ")
[18:06:03.920]                         if (!has_future) {
[18:06:03.920]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:03.920]                             info)
[18:06:03.920]                         }
[18:06:03.920]                         else {
[18:06:03.920]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:03.920]                             info, version)
[18:06:03.920]                         }
[18:06:03.920]                         base::stop(msg)
[18:06:03.920]                       }
[18:06:03.920]                     })
[18:06:03.920]                   }
[18:06:03.920]                   ...future.strategy.old <- future::plan("list")
[18:06:03.920]                   options(future.plan = NULL)
[18:06:03.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:03.920]                 }
[18:06:03.920]                 ...future.workdir <- getwd()
[18:06:03.920]             }
[18:06:03.920]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:03.920]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:03.920]         }
[18:06:03.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:03.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:03.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:03.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:03.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:03.920]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:03.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:03.920]             base::names(...future.oldOptions))
[18:06:03.920]     }
[18:06:03.920]     if (FALSE) {
[18:06:03.920]     }
[18:06:03.920]     else {
[18:06:03.920]         if (TRUE) {
[18:06:03.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:03.920]                 open = "w")
[18:06:03.920]         }
[18:06:03.920]         else {
[18:06:03.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:03.920]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:03.920]         }
[18:06:03.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:03.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:03.920]             base::sink(type = "output", split = FALSE)
[18:06:03.920]             base::close(...future.stdout)
[18:06:03.920]         }, add = TRUE)
[18:06:03.920]     }
[18:06:03.920]     ...future.frame <- base::sys.nframe()
[18:06:03.920]     ...future.conditions <- base::list()
[18:06:03.920]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:03.920]     if (FALSE) {
[18:06:03.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:03.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:03.920]     }
[18:06:03.920]     ...future.result <- base::tryCatch({
[18:06:03.920]         base::withCallingHandlers({
[18:06:03.920]             ...future.value <- base::withVisible(base::local({
[18:06:03.920]                 Sys.sleep(0.5)
[18:06:03.920]                 2
[18:06:03.920]             }))
[18:06:03.920]             future::FutureResult(value = ...future.value$value, 
[18:06:03.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.920]                   ...future.rng), globalenv = if (FALSE) 
[18:06:03.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:03.920]                     ...future.globalenv.names))
[18:06:03.920]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:03.920]         }, condition = base::local({
[18:06:03.920]             c <- base::c
[18:06:03.920]             inherits <- base::inherits
[18:06:03.920]             invokeRestart <- base::invokeRestart
[18:06:03.920]             length <- base::length
[18:06:03.920]             list <- base::list
[18:06:03.920]             seq.int <- base::seq.int
[18:06:03.920]             signalCondition <- base::signalCondition
[18:06:03.920]             sys.calls <- base::sys.calls
[18:06:03.920]             `[[` <- base::`[[`
[18:06:03.920]             `+` <- base::`+`
[18:06:03.920]             `<<-` <- base::`<<-`
[18:06:03.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:03.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:03.920]                   3L)]
[18:06:03.920]             }
[18:06:03.920]             function(cond) {
[18:06:03.920]                 is_error <- inherits(cond, "error")
[18:06:03.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:03.920]                   NULL)
[18:06:03.920]                 if (is_error) {
[18:06:03.920]                   sessionInformation <- function() {
[18:06:03.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:03.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:03.920]                       search = base::search(), system = base::Sys.info())
[18:06:03.920]                   }
[18:06:03.920]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:03.920]                     cond$call), session = sessionInformation(), 
[18:06:03.920]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:03.920]                   signalCondition(cond)
[18:06:03.920]                 }
[18:06:03.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:03.920]                 "immediateCondition"))) {
[18:06:03.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:03.920]                   ...future.conditions[[length(...future.conditions) + 
[18:06:03.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:03.920]                   if (TRUE && !signal) {
[18:06:03.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.920]                     {
[18:06:03.920]                       inherits <- base::inherits
[18:06:03.920]                       invokeRestart <- base::invokeRestart
[18:06:03.920]                       is.null <- base::is.null
[18:06:03.920]                       muffled <- FALSE
[18:06:03.920]                       if (inherits(cond, "message")) {
[18:06:03.920]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.920]                         if (muffled) 
[18:06:03.920]                           invokeRestart("muffleMessage")
[18:06:03.920]                       }
[18:06:03.920]                       else if (inherits(cond, "warning")) {
[18:06:03.920]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.920]                         if (muffled) 
[18:06:03.920]                           invokeRestart("muffleWarning")
[18:06:03.920]                       }
[18:06:03.920]                       else if (inherits(cond, "condition")) {
[18:06:03.920]                         if (!is.null(pattern)) {
[18:06:03.920]                           computeRestarts <- base::computeRestarts
[18:06:03.920]                           grepl <- base::grepl
[18:06:03.920]                           restarts <- computeRestarts(cond)
[18:06:03.920]                           for (restart in restarts) {
[18:06:03.920]                             name <- restart$name
[18:06:03.920]                             if (is.null(name)) 
[18:06:03.920]                               next
[18:06:03.920]                             if (!grepl(pattern, name)) 
[18:06:03.920]                               next
[18:06:03.920]                             invokeRestart(restart)
[18:06:03.920]                             muffled <- TRUE
[18:06:03.920]                             break
[18:06:03.920]                           }
[18:06:03.920]                         }
[18:06:03.920]                       }
[18:06:03.920]                       invisible(muffled)
[18:06:03.920]                     }
[18:06:03.920]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.920]                   }
[18:06:03.920]                 }
[18:06:03.920]                 else {
[18:06:03.920]                   if (TRUE) {
[18:06:03.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:03.920]                     {
[18:06:03.920]                       inherits <- base::inherits
[18:06:03.920]                       invokeRestart <- base::invokeRestart
[18:06:03.920]                       is.null <- base::is.null
[18:06:03.920]                       muffled <- FALSE
[18:06:03.920]                       if (inherits(cond, "message")) {
[18:06:03.920]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:03.920]                         if (muffled) 
[18:06:03.920]                           invokeRestart("muffleMessage")
[18:06:03.920]                       }
[18:06:03.920]                       else if (inherits(cond, "warning")) {
[18:06:03.920]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:03.920]                         if (muffled) 
[18:06:03.920]                           invokeRestart("muffleWarning")
[18:06:03.920]                       }
[18:06:03.920]                       else if (inherits(cond, "condition")) {
[18:06:03.920]                         if (!is.null(pattern)) {
[18:06:03.920]                           computeRestarts <- base::computeRestarts
[18:06:03.920]                           grepl <- base::grepl
[18:06:03.920]                           restarts <- computeRestarts(cond)
[18:06:03.920]                           for (restart in restarts) {
[18:06:03.920]                             name <- restart$name
[18:06:03.920]                             if (is.null(name)) 
[18:06:03.920]                               next
[18:06:03.920]                             if (!grepl(pattern, name)) 
[18:06:03.920]                               next
[18:06:03.920]                             invokeRestart(restart)
[18:06:03.920]                             muffled <- TRUE
[18:06:03.920]                             break
[18:06:03.920]                           }
[18:06:03.920]                         }
[18:06:03.920]                       }
[18:06:03.920]                       invisible(muffled)
[18:06:03.920]                     }
[18:06:03.920]                     muffleCondition(cond, pattern = "^muffle")
[18:06:03.920]                   }
[18:06:03.920]                 }
[18:06:03.920]             }
[18:06:03.920]         }))
[18:06:03.920]     }, error = function(ex) {
[18:06:03.920]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:03.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:03.920]                 ...future.rng), started = ...future.startTime, 
[18:06:03.920]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:03.920]             version = "1.8"), class = "FutureResult")
[18:06:03.920]     }, finally = {
[18:06:03.920]         if (!identical(...future.workdir, getwd())) 
[18:06:03.920]             setwd(...future.workdir)
[18:06:03.920]         {
[18:06:03.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:03.920]                 ...future.oldOptions$nwarnings <- NULL
[18:06:03.920]             }
[18:06:03.920]             base::options(...future.oldOptions)
[18:06:03.920]             if (.Platform$OS.type == "windows") {
[18:06:03.920]                 old_names <- names(...future.oldEnvVars)
[18:06:03.920]                 envs <- base::Sys.getenv()
[18:06:03.920]                 names <- names(envs)
[18:06:03.920]                 common <- intersect(names, old_names)
[18:06:03.920]                 added <- setdiff(names, old_names)
[18:06:03.920]                 removed <- setdiff(old_names, names)
[18:06:03.920]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:03.920]                   envs[common]]
[18:06:03.920]                 NAMES <- toupper(changed)
[18:06:03.920]                 args <- list()
[18:06:03.920]                 for (kk in seq_along(NAMES)) {
[18:06:03.920]                   name <- changed[[kk]]
[18:06:03.920]                   NAME <- NAMES[[kk]]
[18:06:03.920]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.920]                     next
[18:06:03.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.920]                 }
[18:06:03.920]                 NAMES <- toupper(added)
[18:06:03.920]                 for (kk in seq_along(NAMES)) {
[18:06:03.920]                   name <- added[[kk]]
[18:06:03.920]                   NAME <- NAMES[[kk]]
[18:06:03.920]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.920]                     next
[18:06:03.920]                   args[[name]] <- ""
[18:06:03.920]                 }
[18:06:03.920]                 NAMES <- toupper(removed)
[18:06:03.920]                 for (kk in seq_along(NAMES)) {
[18:06:03.920]                   name <- removed[[kk]]
[18:06:03.920]                   NAME <- NAMES[[kk]]
[18:06:03.920]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:03.920]                     next
[18:06:03.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:03.920]                 }
[18:06:03.920]                 if (length(args) > 0) 
[18:06:03.920]                   base::do.call(base::Sys.setenv, args = args)
[18:06:03.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:03.920]             }
[18:06:03.920]             else {
[18:06:03.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:03.920]             }
[18:06:03.920]             {
[18:06:03.920]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:03.920]                   0L) {
[18:06:03.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:03.920]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:03.920]                   base::options(opts)
[18:06:03.920]                 }
[18:06:03.920]                 {
[18:06:03.920]                   {
[18:06:03.920]                     NULL
[18:06:03.920]                     RNGkind("Mersenne-Twister")
[18:06:03.920]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:03.920]                       inherits = FALSE)
[18:06:03.920]                   }
[18:06:03.920]                   options(future.plan = NULL)
[18:06:03.920]                   if (is.na(NA_character_)) 
[18:06:03.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:03.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:03.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:03.920]                     .init = FALSE)
[18:06:03.920]                 }
[18:06:03.920]             }
[18:06:03.920]         }
[18:06:03.920]     })
[18:06:03.920]     if (TRUE) {
[18:06:03.920]         base::sink(type = "output", split = FALSE)
[18:06:03.920]         if (TRUE) {
[18:06:03.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:03.920]         }
[18:06:03.920]         else {
[18:06:03.920]             ...future.result["stdout"] <- base::list(NULL)
[18:06:03.920]         }
[18:06:03.920]         base::close(...future.stdout)
[18:06:03.920]         ...future.stdout <- NULL
[18:06:03.920]     }
[18:06:03.920]     ...future.result$conditions <- ...future.conditions
[18:06:03.920]     ...future.result$finished <- base::Sys.time()
[18:06:03.920]     ...future.result
[18:06:03.920] }
[18:06:03.924] plan(): Setting new future strategy stack:
[18:06:03.924] List of future strategies:
[18:06:03.924] 1. sequential:
[18:06:03.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:03.924]    - tweaked: FALSE
[18:06:03.924]    - call: NULL
[18:06:03.926] plan(): nbrOfWorkers() = 1
[18:06:04.428] plan(): Setting new future strategy stack:
[18:06:04.428] List of future strategies:
[18:06:04.428] 1. sequential:
[18:06:04.428]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.428]    - tweaked: FALSE
[18:06:04.428]    - call: plan(strategy)
[18:06:04.429] plan(): nbrOfWorkers() = 1
[18:06:04.429] SequentialFuture started (and completed)
[18:06:04.429] - Launch lazy future ... done
[18:06:04.430] run() for ‘SequentialFuture’ ... done
[18:06:04.430] resolve() on list ...
[18:06:04.431]  recursive: 0
[18:06:04.431]  length: 1
[18:06:04.431] 
[18:06:04.431] resolved() for ‘SequentialFuture’ ...
[18:06:04.431] - state: ‘finished’
[18:06:04.432] - run: TRUE
[18:06:04.432] - result: ‘FutureResult’
[18:06:04.432] resolved() for ‘SequentialFuture’ ... done
[18:06:04.432] Future #1
[18:06:04.432]  length: 0 (resolved future 1)
[18:06:04.433] resolve() on list ... DONE
[18:06:04.433] resolved() for ‘SequentialFuture’ ...
[18:06:04.433] - state: ‘finished’
[18:06:04.433] - run: TRUE
[18:06:04.433] - result: ‘FutureResult’
[18:06:04.434] resolved() for ‘SequentialFuture’ ... done
[18:06:04.434] resolve() on list ...
[18:06:04.434]  recursive: 0
[18:06:04.434]  length: 1
[18:06:04.435] 
[18:06:04.435] resolved() for ‘SequentialFuture’ ...
[18:06:04.435] - state: ‘finished’
[18:06:04.435] - run: TRUE
[18:06:04.435] - result: ‘FutureResult’
[18:06:04.436] resolved() for ‘SequentialFuture’ ... done
[18:06:04.436] Future #1
[18:06:04.436]  length: 0 (resolved future 1)
[18:06:04.436] resolve() on list ... DONE
[18:06:04.436] resolved() for ‘SequentialFuture’ ...
[18:06:04.437] - state: ‘finished’
[18:06:04.437] - run: TRUE
[18:06:04.437] - result: ‘FutureResult’
[18:06:04.437] resolved() for ‘SequentialFuture’ ... done
[18:06:04.438] resolve() on list ...
[18:06:04.438]  recursive: 0
[18:06:04.438]  length: 1
[18:06:04.438] 
[18:06:04.438]  length: 0 (resolved future 1)
[18:06:04.439] resolve() on list ... DONE
[18:06:04.439] resolve() on list ...
[18:06:04.439]  recursive: 0
[18:06:04.440]  length: 4
[18:06:04.440] 
[18:06:04.440] resolved() for ‘SequentialFuture’ ...
[18:06:04.440] - state: ‘finished’
[18:06:04.440] - run: TRUE
[18:06:04.441] - result: ‘FutureResult’
[18:06:04.441] resolved() for ‘SequentialFuture’ ... done
[18:06:04.441] Future #1
[18:06:04.441]  length: 3 (resolved future 1)
[18:06:04.441] resolved() for ‘SequentialFuture’ ...
[18:06:04.442] - state: ‘finished’
[18:06:04.442] - run: TRUE
[18:06:04.442] - result: ‘FutureResult’
[18:06:04.442] resolved() for ‘SequentialFuture’ ... done
[18:06:04.442] Future #2
[18:06:04.443]  length: 2 (resolved future 2)
[18:06:04.443]  length: 1 (resolved future 3)
[18:06:04.443]  length: 0 (resolved future 4)
[18:06:04.443] resolve() on list ... DONE
[18:06:04.444] resolve() on list ...
[18:06:04.444]  recursive: 0
[18:06:04.444]  length: 4
[18:06:04.444] 
[18:06:04.444] resolved() for ‘SequentialFuture’ ...
[18:06:04.445] - state: ‘finished’
[18:06:04.445] - run: TRUE
[18:06:04.445] - result: ‘FutureResult’
[18:06:04.445] resolved() for ‘SequentialFuture’ ... done
[18:06:04.445] Future #1
[18:06:04.446]  length: 3 (resolved future 1)
[18:06:04.446] resolved() for ‘SequentialFuture’ ...
[18:06:04.446] - state: ‘finished’
[18:06:04.446] - run: TRUE
[18:06:04.447] - result: ‘FutureResult’
[18:06:04.447] resolved() for ‘SequentialFuture’ ... done
[18:06:04.447] Future #2
[18:06:04.447]  length: 2 (resolved future 2)
[18:06:04.447]  length: 1 (resolved future 3)
[18:06:04.448]  length: 0 (resolved future 4)
[18:06:04.448] resolve() on list ... DONE
[18:06:04.448] resolve() on list ...
[18:06:04.449]  recursive: 0
[18:06:04.449]  length: 1
[18:06:04.449] 
[18:06:04.449]  length: 0 (resolved future 1)
[18:06:04.449] resolve() on list ... DONE
[18:06:04.450] getGlobalsAndPackages() ...
[18:06:04.450] Searching for globals...
[18:06:04.452] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:04.452] Searching for globals ... DONE
[18:06:04.453] Resolving globals: FALSE
[18:06:04.454] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:04.455] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:04.455] - globals: [1] ‘kk’
[18:06:04.456] 
[18:06:04.456] getGlobalsAndPackages() ... DONE
[18:06:04.456] run() for ‘Future’ ...
[18:06:04.457] - state: ‘created’
[18:06:04.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:04.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:04.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:04.458]   - Field: ‘label’
[18:06:04.458]   - Field: ‘local’
[18:06:04.458]   - Field: ‘owner’
[18:06:04.458]   - Field: ‘envir’
[18:06:04.459]   - Field: ‘packages’
[18:06:04.459]   - Field: ‘gc’
[18:06:04.459]   - Field: ‘conditions’
[18:06:04.459]   - Field: ‘expr’
[18:06:04.460]   - Field: ‘uuid’
[18:06:04.460]   - Field: ‘seed’
[18:06:04.460]   - Field: ‘version’
[18:06:04.460]   - Field: ‘result’
[18:06:04.460]   - Field: ‘asynchronous’
[18:06:04.460]   - Field: ‘calls’
[18:06:04.461]   - Field: ‘globals’
[18:06:04.461]   - Field: ‘stdout’
[18:06:04.461]   - Field: ‘earlySignal’
[18:06:04.461]   - Field: ‘lazy’
[18:06:04.461]   - Field: ‘state’
[18:06:04.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:04.462] - Launch lazy future ...
[18:06:04.462] Packages needed by the future expression (n = 0): <none>
[18:06:04.463] Packages needed by future strategies (n = 0): <none>
[18:06:04.463] {
[18:06:04.463]     {
[18:06:04.463]         {
[18:06:04.463]             ...future.startTime <- base::Sys.time()
[18:06:04.463]             {
[18:06:04.463]                 {
[18:06:04.463]                   {
[18:06:04.463]                     base::local({
[18:06:04.463]                       has_future <- base::requireNamespace("future", 
[18:06:04.463]                         quietly = TRUE)
[18:06:04.463]                       if (has_future) {
[18:06:04.463]                         ns <- base::getNamespace("future")
[18:06:04.463]                         version <- ns[[".package"]][["version"]]
[18:06:04.463]                         if (is.null(version)) 
[18:06:04.463]                           version <- utils::packageVersion("future")
[18:06:04.463]                       }
[18:06:04.463]                       else {
[18:06:04.463]                         version <- NULL
[18:06:04.463]                       }
[18:06:04.463]                       if (!has_future || version < "1.8.0") {
[18:06:04.463]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:04.463]                           "", base::R.version$version.string), 
[18:06:04.463]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:04.463]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:04.463]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:04.463]                             "release", "version")], collapse = " "), 
[18:06:04.463]                           hostname = base::Sys.info()[["nodename"]])
[18:06:04.463]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:04.463]                           info)
[18:06:04.463]                         info <- base::paste(info, collapse = "; ")
[18:06:04.463]                         if (!has_future) {
[18:06:04.463]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:04.463]                             info)
[18:06:04.463]                         }
[18:06:04.463]                         else {
[18:06:04.463]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:04.463]                             info, version)
[18:06:04.463]                         }
[18:06:04.463]                         base::stop(msg)
[18:06:04.463]                       }
[18:06:04.463]                     })
[18:06:04.463]                   }
[18:06:04.463]                   ...future.strategy.old <- future::plan("list")
[18:06:04.463]                   options(future.plan = NULL)
[18:06:04.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:04.463]                 }
[18:06:04.463]                 ...future.workdir <- getwd()
[18:06:04.463]             }
[18:06:04.463]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:04.463]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:04.463]         }
[18:06:04.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:04.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:04.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:04.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:04.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:04.463]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:04.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:04.463]             base::names(...future.oldOptions))
[18:06:04.463]     }
[18:06:04.463]     if (FALSE) {
[18:06:04.463]     }
[18:06:04.463]     else {
[18:06:04.463]         if (TRUE) {
[18:06:04.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:04.463]                 open = "w")
[18:06:04.463]         }
[18:06:04.463]         else {
[18:06:04.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:04.463]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:04.463]         }
[18:06:04.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:04.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:04.463]             base::sink(type = "output", split = FALSE)
[18:06:04.463]             base::close(...future.stdout)
[18:06:04.463]         }, add = TRUE)
[18:06:04.463]     }
[18:06:04.463]     ...future.frame <- base::sys.nframe()
[18:06:04.463]     ...future.conditions <- base::list()
[18:06:04.463]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:04.463]     if (FALSE) {
[18:06:04.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:04.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:04.463]     }
[18:06:04.463]     ...future.result <- base::tryCatch({
[18:06:04.463]         base::withCallingHandlers({
[18:06:04.463]             ...future.value <- base::withVisible(base::local({
[18:06:04.463]                 Sys.sleep(0.1)
[18:06:04.463]                 kk
[18:06:04.463]             }))
[18:06:04.463]             future::FutureResult(value = ...future.value$value, 
[18:06:04.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.463]                   ...future.rng), globalenv = if (FALSE) 
[18:06:04.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:04.463]                     ...future.globalenv.names))
[18:06:04.463]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:04.463]         }, condition = base::local({
[18:06:04.463]             c <- base::c
[18:06:04.463]             inherits <- base::inherits
[18:06:04.463]             invokeRestart <- base::invokeRestart
[18:06:04.463]             length <- base::length
[18:06:04.463]             list <- base::list
[18:06:04.463]             seq.int <- base::seq.int
[18:06:04.463]             signalCondition <- base::signalCondition
[18:06:04.463]             sys.calls <- base::sys.calls
[18:06:04.463]             `[[` <- base::`[[`
[18:06:04.463]             `+` <- base::`+`
[18:06:04.463]             `<<-` <- base::`<<-`
[18:06:04.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:04.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:04.463]                   3L)]
[18:06:04.463]             }
[18:06:04.463]             function(cond) {
[18:06:04.463]                 is_error <- inherits(cond, "error")
[18:06:04.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:04.463]                   NULL)
[18:06:04.463]                 if (is_error) {
[18:06:04.463]                   sessionInformation <- function() {
[18:06:04.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:04.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:04.463]                       search = base::search(), system = base::Sys.info())
[18:06:04.463]                   }
[18:06:04.463]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:04.463]                     cond$call), session = sessionInformation(), 
[18:06:04.463]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:04.463]                   signalCondition(cond)
[18:06:04.463]                 }
[18:06:04.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:04.463]                 "immediateCondition"))) {
[18:06:04.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:04.463]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:04.463]                   if (TRUE && !signal) {
[18:06:04.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.463]                     {
[18:06:04.463]                       inherits <- base::inherits
[18:06:04.463]                       invokeRestart <- base::invokeRestart
[18:06:04.463]                       is.null <- base::is.null
[18:06:04.463]                       muffled <- FALSE
[18:06:04.463]                       if (inherits(cond, "message")) {
[18:06:04.463]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.463]                         if (muffled) 
[18:06:04.463]                           invokeRestart("muffleMessage")
[18:06:04.463]                       }
[18:06:04.463]                       else if (inherits(cond, "warning")) {
[18:06:04.463]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.463]                         if (muffled) 
[18:06:04.463]                           invokeRestart("muffleWarning")
[18:06:04.463]                       }
[18:06:04.463]                       else if (inherits(cond, "condition")) {
[18:06:04.463]                         if (!is.null(pattern)) {
[18:06:04.463]                           computeRestarts <- base::computeRestarts
[18:06:04.463]                           grepl <- base::grepl
[18:06:04.463]                           restarts <- computeRestarts(cond)
[18:06:04.463]                           for (restart in restarts) {
[18:06:04.463]                             name <- restart$name
[18:06:04.463]                             if (is.null(name)) 
[18:06:04.463]                               next
[18:06:04.463]                             if (!grepl(pattern, name)) 
[18:06:04.463]                               next
[18:06:04.463]                             invokeRestart(restart)
[18:06:04.463]                             muffled <- TRUE
[18:06:04.463]                             break
[18:06:04.463]                           }
[18:06:04.463]                         }
[18:06:04.463]                       }
[18:06:04.463]                       invisible(muffled)
[18:06:04.463]                     }
[18:06:04.463]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.463]                   }
[18:06:04.463]                 }
[18:06:04.463]                 else {
[18:06:04.463]                   if (TRUE) {
[18:06:04.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.463]                     {
[18:06:04.463]                       inherits <- base::inherits
[18:06:04.463]                       invokeRestart <- base::invokeRestart
[18:06:04.463]                       is.null <- base::is.null
[18:06:04.463]                       muffled <- FALSE
[18:06:04.463]                       if (inherits(cond, "message")) {
[18:06:04.463]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.463]                         if (muffled) 
[18:06:04.463]                           invokeRestart("muffleMessage")
[18:06:04.463]                       }
[18:06:04.463]                       else if (inherits(cond, "warning")) {
[18:06:04.463]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.463]                         if (muffled) 
[18:06:04.463]                           invokeRestart("muffleWarning")
[18:06:04.463]                       }
[18:06:04.463]                       else if (inherits(cond, "condition")) {
[18:06:04.463]                         if (!is.null(pattern)) {
[18:06:04.463]                           computeRestarts <- base::computeRestarts
[18:06:04.463]                           grepl <- base::grepl
[18:06:04.463]                           restarts <- computeRestarts(cond)
[18:06:04.463]                           for (restart in restarts) {
[18:06:04.463]                             name <- restart$name
[18:06:04.463]                             if (is.null(name)) 
[18:06:04.463]                               next
[18:06:04.463]                             if (!grepl(pattern, name)) 
[18:06:04.463]                               next
[18:06:04.463]                             invokeRestart(restart)
[18:06:04.463]                             muffled <- TRUE
[18:06:04.463]                             break
[18:06:04.463]                           }
[18:06:04.463]                         }
[18:06:04.463]                       }
[18:06:04.463]                       invisible(muffled)
[18:06:04.463]                     }
[18:06:04.463]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.463]                   }
[18:06:04.463]                 }
[18:06:04.463]             }
[18:06:04.463]         }))
[18:06:04.463]     }, error = function(ex) {
[18:06:04.463]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:04.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.463]                 ...future.rng), started = ...future.startTime, 
[18:06:04.463]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:04.463]             version = "1.8"), class = "FutureResult")
[18:06:04.463]     }, finally = {
[18:06:04.463]         if (!identical(...future.workdir, getwd())) 
[18:06:04.463]             setwd(...future.workdir)
[18:06:04.463]         {
[18:06:04.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:04.463]                 ...future.oldOptions$nwarnings <- NULL
[18:06:04.463]             }
[18:06:04.463]             base::options(...future.oldOptions)
[18:06:04.463]             if (.Platform$OS.type == "windows") {
[18:06:04.463]                 old_names <- names(...future.oldEnvVars)
[18:06:04.463]                 envs <- base::Sys.getenv()
[18:06:04.463]                 names <- names(envs)
[18:06:04.463]                 common <- intersect(names, old_names)
[18:06:04.463]                 added <- setdiff(names, old_names)
[18:06:04.463]                 removed <- setdiff(old_names, names)
[18:06:04.463]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:04.463]                   envs[common]]
[18:06:04.463]                 NAMES <- toupper(changed)
[18:06:04.463]                 args <- list()
[18:06:04.463]                 for (kk in seq_along(NAMES)) {
[18:06:04.463]                   name <- changed[[kk]]
[18:06:04.463]                   NAME <- NAMES[[kk]]
[18:06:04.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.463]                     next
[18:06:04.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.463]                 }
[18:06:04.463]                 NAMES <- toupper(added)
[18:06:04.463]                 for (kk in seq_along(NAMES)) {
[18:06:04.463]                   name <- added[[kk]]
[18:06:04.463]                   NAME <- NAMES[[kk]]
[18:06:04.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.463]                     next
[18:06:04.463]                   args[[name]] <- ""
[18:06:04.463]                 }
[18:06:04.463]                 NAMES <- toupper(removed)
[18:06:04.463]                 for (kk in seq_along(NAMES)) {
[18:06:04.463]                   name <- removed[[kk]]
[18:06:04.463]                   NAME <- NAMES[[kk]]
[18:06:04.463]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.463]                     next
[18:06:04.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.463]                 }
[18:06:04.463]                 if (length(args) > 0) 
[18:06:04.463]                   base::do.call(base::Sys.setenv, args = args)
[18:06:04.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:04.463]             }
[18:06:04.463]             else {
[18:06:04.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:04.463]             }
[18:06:04.463]             {
[18:06:04.463]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:04.463]                   0L) {
[18:06:04.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:04.463]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:04.463]                   base::options(opts)
[18:06:04.463]                 }
[18:06:04.463]                 {
[18:06:04.463]                   {
[18:06:04.463]                     NULL
[18:06:04.463]                     RNGkind("Mersenne-Twister")
[18:06:04.463]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:04.463]                       inherits = FALSE)
[18:06:04.463]                   }
[18:06:04.463]                   options(future.plan = NULL)
[18:06:04.463]                   if (is.na(NA_character_)) 
[18:06:04.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:04.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:04.463]                     .init = FALSE)
[18:06:04.463]                 }
[18:06:04.463]             }
[18:06:04.463]         }
[18:06:04.463]     })
[18:06:04.463]     if (TRUE) {
[18:06:04.463]         base::sink(type = "output", split = FALSE)
[18:06:04.463]         if (TRUE) {
[18:06:04.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:04.463]         }
[18:06:04.463]         else {
[18:06:04.463]             ...future.result["stdout"] <- base::list(NULL)
[18:06:04.463]         }
[18:06:04.463]         base::close(...future.stdout)
[18:06:04.463]         ...future.stdout <- NULL
[18:06:04.463]     }
[18:06:04.463]     ...future.result$conditions <- ...future.conditions
[18:06:04.463]     ...future.result$finished <- base::Sys.time()
[18:06:04.463]     ...future.result
[18:06:04.463] }
[18:06:04.467] assign_globals() ...
[18:06:04.467] List of 1
[18:06:04.467]  $ kk: int 1
[18:06:04.467]  - attr(*, "where")=List of 1
[18:06:04.467]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:04.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:04.467]  - attr(*, "resolved")= logi FALSE
[18:06:04.467]  - attr(*, "total_size")= num 56
[18:06:04.467]  - attr(*, "already-done")= logi TRUE
[18:06:04.480] - copied ‘kk’ to environment
[18:06:04.481] assign_globals() ... done
[18:06:04.481] plan(): Setting new future strategy stack:
[18:06:04.481] List of future strategies:
[18:06:04.481] 1. sequential:
[18:06:04.481]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.481]    - tweaked: FALSE
[18:06:04.481]    - call: NULL
[18:06:04.482] plan(): nbrOfWorkers() = 1
[18:06:04.584] plan(): Setting new future strategy stack:
[18:06:04.584] List of future strategies:
[18:06:04.584] 1. sequential:
[18:06:04.584]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.584]    - tweaked: FALSE
[18:06:04.584]    - call: plan(strategy)
[18:06:04.585] plan(): nbrOfWorkers() = 1
[18:06:04.586] SequentialFuture started (and completed)
[18:06:04.586] - Launch lazy future ... done
[18:06:04.586] run() for ‘SequentialFuture’ ... done
[18:06:04.586] getGlobalsAndPackages() ...
[18:06:04.587] Searching for globals...
[18:06:04.588] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:04.589] Searching for globals ... DONE
[18:06:04.589] Resolving globals: FALSE
[18:06:04.590] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:04.590] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:04.591] - globals: [1] ‘kk’
[18:06:04.591] 
[18:06:04.591] getGlobalsAndPackages() ... DONE
[18:06:04.591] run() for ‘Future’ ...
[18:06:04.592] - state: ‘created’
[18:06:04.592] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:04.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:04.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:04.593]   - Field: ‘label’
[18:06:04.593]   - Field: ‘local’
[18:06:04.593]   - Field: ‘owner’
[18:06:04.593]   - Field: ‘envir’
[18:06:04.594]   - Field: ‘packages’
[18:06:04.594]   - Field: ‘gc’
[18:06:04.594]   - Field: ‘conditions’
[18:06:04.594]   - Field: ‘expr’
[18:06:04.594]   - Field: ‘uuid’
[18:06:04.595]   - Field: ‘seed’
[18:06:04.595]   - Field: ‘version’
[18:06:04.595]   - Field: ‘result’
[18:06:04.595]   - Field: ‘asynchronous’
[18:06:04.595]   - Field: ‘calls’
[18:06:04.596]   - Field: ‘globals’
[18:06:04.596]   - Field: ‘stdout’
[18:06:04.596]   - Field: ‘earlySignal’
[18:06:04.596]   - Field: ‘lazy’
[18:06:04.596]   - Field: ‘state’
[18:06:04.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:04.597] - Launch lazy future ...
[18:06:04.597] Packages needed by the future expression (n = 0): <none>
[18:06:04.597] Packages needed by future strategies (n = 0): <none>
[18:06:04.598] {
[18:06:04.598]     {
[18:06:04.598]         {
[18:06:04.598]             ...future.startTime <- base::Sys.time()
[18:06:04.598]             {
[18:06:04.598]                 {
[18:06:04.598]                   {
[18:06:04.598]                     base::local({
[18:06:04.598]                       has_future <- base::requireNamespace("future", 
[18:06:04.598]                         quietly = TRUE)
[18:06:04.598]                       if (has_future) {
[18:06:04.598]                         ns <- base::getNamespace("future")
[18:06:04.598]                         version <- ns[[".package"]][["version"]]
[18:06:04.598]                         if (is.null(version)) 
[18:06:04.598]                           version <- utils::packageVersion("future")
[18:06:04.598]                       }
[18:06:04.598]                       else {
[18:06:04.598]                         version <- NULL
[18:06:04.598]                       }
[18:06:04.598]                       if (!has_future || version < "1.8.0") {
[18:06:04.598]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:04.598]                           "", base::R.version$version.string), 
[18:06:04.598]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:04.598]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:04.598]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:04.598]                             "release", "version")], collapse = " "), 
[18:06:04.598]                           hostname = base::Sys.info()[["nodename"]])
[18:06:04.598]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:04.598]                           info)
[18:06:04.598]                         info <- base::paste(info, collapse = "; ")
[18:06:04.598]                         if (!has_future) {
[18:06:04.598]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:04.598]                             info)
[18:06:04.598]                         }
[18:06:04.598]                         else {
[18:06:04.598]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:04.598]                             info, version)
[18:06:04.598]                         }
[18:06:04.598]                         base::stop(msg)
[18:06:04.598]                       }
[18:06:04.598]                     })
[18:06:04.598]                   }
[18:06:04.598]                   ...future.strategy.old <- future::plan("list")
[18:06:04.598]                   options(future.plan = NULL)
[18:06:04.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:04.598]                 }
[18:06:04.598]                 ...future.workdir <- getwd()
[18:06:04.598]             }
[18:06:04.598]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:04.598]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:04.598]         }
[18:06:04.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:04.598]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:04.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:04.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:04.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:04.598]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:04.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:04.598]             base::names(...future.oldOptions))
[18:06:04.598]     }
[18:06:04.598]     if (FALSE) {
[18:06:04.598]     }
[18:06:04.598]     else {
[18:06:04.598]         if (TRUE) {
[18:06:04.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:04.598]                 open = "w")
[18:06:04.598]         }
[18:06:04.598]         else {
[18:06:04.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:04.598]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:04.598]         }
[18:06:04.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:04.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:04.598]             base::sink(type = "output", split = FALSE)
[18:06:04.598]             base::close(...future.stdout)
[18:06:04.598]         }, add = TRUE)
[18:06:04.598]     }
[18:06:04.598]     ...future.frame <- base::sys.nframe()
[18:06:04.598]     ...future.conditions <- base::list()
[18:06:04.598]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:04.598]     if (FALSE) {
[18:06:04.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:04.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:04.598]     }
[18:06:04.598]     ...future.result <- base::tryCatch({
[18:06:04.598]         base::withCallingHandlers({
[18:06:04.598]             ...future.value <- base::withVisible(base::local({
[18:06:04.598]                 Sys.sleep(0.1)
[18:06:04.598]                 kk
[18:06:04.598]             }))
[18:06:04.598]             future::FutureResult(value = ...future.value$value, 
[18:06:04.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.598]                   ...future.rng), globalenv = if (FALSE) 
[18:06:04.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:04.598]                     ...future.globalenv.names))
[18:06:04.598]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:04.598]         }, condition = base::local({
[18:06:04.598]             c <- base::c
[18:06:04.598]             inherits <- base::inherits
[18:06:04.598]             invokeRestart <- base::invokeRestart
[18:06:04.598]             length <- base::length
[18:06:04.598]             list <- base::list
[18:06:04.598]             seq.int <- base::seq.int
[18:06:04.598]             signalCondition <- base::signalCondition
[18:06:04.598]             sys.calls <- base::sys.calls
[18:06:04.598]             `[[` <- base::`[[`
[18:06:04.598]             `+` <- base::`+`
[18:06:04.598]             `<<-` <- base::`<<-`
[18:06:04.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:04.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:04.598]                   3L)]
[18:06:04.598]             }
[18:06:04.598]             function(cond) {
[18:06:04.598]                 is_error <- inherits(cond, "error")
[18:06:04.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:04.598]                   NULL)
[18:06:04.598]                 if (is_error) {
[18:06:04.598]                   sessionInformation <- function() {
[18:06:04.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:04.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:04.598]                       search = base::search(), system = base::Sys.info())
[18:06:04.598]                   }
[18:06:04.598]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:04.598]                     cond$call), session = sessionInformation(), 
[18:06:04.598]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:04.598]                   signalCondition(cond)
[18:06:04.598]                 }
[18:06:04.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:04.598]                 "immediateCondition"))) {
[18:06:04.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:04.598]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:04.598]                   if (TRUE && !signal) {
[18:06:04.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.598]                     {
[18:06:04.598]                       inherits <- base::inherits
[18:06:04.598]                       invokeRestart <- base::invokeRestart
[18:06:04.598]                       is.null <- base::is.null
[18:06:04.598]                       muffled <- FALSE
[18:06:04.598]                       if (inherits(cond, "message")) {
[18:06:04.598]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.598]                         if (muffled) 
[18:06:04.598]                           invokeRestart("muffleMessage")
[18:06:04.598]                       }
[18:06:04.598]                       else if (inherits(cond, "warning")) {
[18:06:04.598]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.598]                         if (muffled) 
[18:06:04.598]                           invokeRestart("muffleWarning")
[18:06:04.598]                       }
[18:06:04.598]                       else if (inherits(cond, "condition")) {
[18:06:04.598]                         if (!is.null(pattern)) {
[18:06:04.598]                           computeRestarts <- base::computeRestarts
[18:06:04.598]                           grepl <- base::grepl
[18:06:04.598]                           restarts <- computeRestarts(cond)
[18:06:04.598]                           for (restart in restarts) {
[18:06:04.598]                             name <- restart$name
[18:06:04.598]                             if (is.null(name)) 
[18:06:04.598]                               next
[18:06:04.598]                             if (!grepl(pattern, name)) 
[18:06:04.598]                               next
[18:06:04.598]                             invokeRestart(restart)
[18:06:04.598]                             muffled <- TRUE
[18:06:04.598]                             break
[18:06:04.598]                           }
[18:06:04.598]                         }
[18:06:04.598]                       }
[18:06:04.598]                       invisible(muffled)
[18:06:04.598]                     }
[18:06:04.598]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.598]                   }
[18:06:04.598]                 }
[18:06:04.598]                 else {
[18:06:04.598]                   if (TRUE) {
[18:06:04.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.598]                     {
[18:06:04.598]                       inherits <- base::inherits
[18:06:04.598]                       invokeRestart <- base::invokeRestart
[18:06:04.598]                       is.null <- base::is.null
[18:06:04.598]                       muffled <- FALSE
[18:06:04.598]                       if (inherits(cond, "message")) {
[18:06:04.598]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.598]                         if (muffled) 
[18:06:04.598]                           invokeRestart("muffleMessage")
[18:06:04.598]                       }
[18:06:04.598]                       else if (inherits(cond, "warning")) {
[18:06:04.598]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.598]                         if (muffled) 
[18:06:04.598]                           invokeRestart("muffleWarning")
[18:06:04.598]                       }
[18:06:04.598]                       else if (inherits(cond, "condition")) {
[18:06:04.598]                         if (!is.null(pattern)) {
[18:06:04.598]                           computeRestarts <- base::computeRestarts
[18:06:04.598]                           grepl <- base::grepl
[18:06:04.598]                           restarts <- computeRestarts(cond)
[18:06:04.598]                           for (restart in restarts) {
[18:06:04.598]                             name <- restart$name
[18:06:04.598]                             if (is.null(name)) 
[18:06:04.598]                               next
[18:06:04.598]                             if (!grepl(pattern, name)) 
[18:06:04.598]                               next
[18:06:04.598]                             invokeRestart(restart)
[18:06:04.598]                             muffled <- TRUE
[18:06:04.598]                             break
[18:06:04.598]                           }
[18:06:04.598]                         }
[18:06:04.598]                       }
[18:06:04.598]                       invisible(muffled)
[18:06:04.598]                     }
[18:06:04.598]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.598]                   }
[18:06:04.598]                 }
[18:06:04.598]             }
[18:06:04.598]         }))
[18:06:04.598]     }, error = function(ex) {
[18:06:04.598]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:04.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.598]                 ...future.rng), started = ...future.startTime, 
[18:06:04.598]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:04.598]             version = "1.8"), class = "FutureResult")
[18:06:04.598]     }, finally = {
[18:06:04.598]         if (!identical(...future.workdir, getwd())) 
[18:06:04.598]             setwd(...future.workdir)
[18:06:04.598]         {
[18:06:04.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:04.598]                 ...future.oldOptions$nwarnings <- NULL
[18:06:04.598]             }
[18:06:04.598]             base::options(...future.oldOptions)
[18:06:04.598]             if (.Platform$OS.type == "windows") {
[18:06:04.598]                 old_names <- names(...future.oldEnvVars)
[18:06:04.598]                 envs <- base::Sys.getenv()
[18:06:04.598]                 names <- names(envs)
[18:06:04.598]                 common <- intersect(names, old_names)
[18:06:04.598]                 added <- setdiff(names, old_names)
[18:06:04.598]                 removed <- setdiff(old_names, names)
[18:06:04.598]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:04.598]                   envs[common]]
[18:06:04.598]                 NAMES <- toupper(changed)
[18:06:04.598]                 args <- list()
[18:06:04.598]                 for (kk in seq_along(NAMES)) {
[18:06:04.598]                   name <- changed[[kk]]
[18:06:04.598]                   NAME <- NAMES[[kk]]
[18:06:04.598]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.598]                     next
[18:06:04.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.598]                 }
[18:06:04.598]                 NAMES <- toupper(added)
[18:06:04.598]                 for (kk in seq_along(NAMES)) {
[18:06:04.598]                   name <- added[[kk]]
[18:06:04.598]                   NAME <- NAMES[[kk]]
[18:06:04.598]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.598]                     next
[18:06:04.598]                   args[[name]] <- ""
[18:06:04.598]                 }
[18:06:04.598]                 NAMES <- toupper(removed)
[18:06:04.598]                 for (kk in seq_along(NAMES)) {
[18:06:04.598]                   name <- removed[[kk]]
[18:06:04.598]                   NAME <- NAMES[[kk]]
[18:06:04.598]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.598]                     next
[18:06:04.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.598]                 }
[18:06:04.598]                 if (length(args) > 0) 
[18:06:04.598]                   base::do.call(base::Sys.setenv, args = args)
[18:06:04.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:04.598]             }
[18:06:04.598]             else {
[18:06:04.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:04.598]             }
[18:06:04.598]             {
[18:06:04.598]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:04.598]                   0L) {
[18:06:04.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:04.598]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:04.598]                   base::options(opts)
[18:06:04.598]                 }
[18:06:04.598]                 {
[18:06:04.598]                   {
[18:06:04.598]                     NULL
[18:06:04.598]                     RNGkind("Mersenne-Twister")
[18:06:04.598]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:04.598]                       inherits = FALSE)
[18:06:04.598]                   }
[18:06:04.598]                   options(future.plan = NULL)
[18:06:04.598]                   if (is.na(NA_character_)) 
[18:06:04.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:04.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:04.598]                     .init = FALSE)
[18:06:04.598]                 }
[18:06:04.598]             }
[18:06:04.598]         }
[18:06:04.598]     })
[18:06:04.598]     if (TRUE) {
[18:06:04.598]         base::sink(type = "output", split = FALSE)
[18:06:04.598]         if (TRUE) {
[18:06:04.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:04.598]         }
[18:06:04.598]         else {
[18:06:04.598]             ...future.result["stdout"] <- base::list(NULL)
[18:06:04.598]         }
[18:06:04.598]         base::close(...future.stdout)
[18:06:04.598]         ...future.stdout <- NULL
[18:06:04.598]     }
[18:06:04.598]     ...future.result$conditions <- ...future.conditions
[18:06:04.598]     ...future.result$finished <- base::Sys.time()
[18:06:04.598]     ...future.result
[18:06:04.598] }
[18:06:04.601] assign_globals() ...
[18:06:04.602] List of 1
[18:06:04.602]  $ kk: int 2
[18:06:04.602]  - attr(*, "where")=List of 1
[18:06:04.602]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:04.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:04.602]  - attr(*, "resolved")= logi FALSE
[18:06:04.602]  - attr(*, "total_size")= num 56
[18:06:04.602]  - attr(*, "already-done")= logi TRUE
[18:06:04.606] - copied ‘kk’ to environment
[18:06:04.607] assign_globals() ... done
[18:06:04.607] plan(): Setting new future strategy stack:
[18:06:04.607] List of future strategies:
[18:06:04.607] 1. sequential:
[18:06:04.607]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.607]    - tweaked: FALSE
[18:06:04.607]    - call: NULL
[18:06:04.608] plan(): nbrOfWorkers() = 1
[18:06:04.710] plan(): Setting new future strategy stack:
[18:06:04.710] List of future strategies:
[18:06:04.710] 1. sequential:
[18:06:04.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.710]    - tweaked: FALSE
[18:06:04.710]    - call: plan(strategy)
[18:06:04.711] plan(): nbrOfWorkers() = 1
[18:06:04.711] SequentialFuture started (and completed)
[18:06:04.712] - Launch lazy future ... done
[18:06:04.712] run() for ‘SequentialFuture’ ... done
[18:06:04.712] getGlobalsAndPackages() ...
[18:06:04.712] Searching for globals...
[18:06:04.714] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:04.715] Searching for globals ... DONE
[18:06:04.715] Resolving globals: FALSE
[18:06:04.716] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:04.716] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:04.716] - globals: [1] ‘kk’
[18:06:04.717] 
[18:06:04.717] getGlobalsAndPackages() ... DONE
[18:06:04.717] run() for ‘Future’ ...
[18:06:04.718] - state: ‘created’
[18:06:04.718] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:04.718] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:04.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:04.719]   - Field: ‘label’
[18:06:04.719]   - Field: ‘local’
[18:06:04.719]   - Field: ‘owner’
[18:06:04.719]   - Field: ‘envir’
[18:06:04.720]   - Field: ‘packages’
[18:06:04.720]   - Field: ‘gc’
[18:06:04.720]   - Field: ‘conditions’
[18:06:04.720]   - Field: ‘expr’
[18:06:04.720]   - Field: ‘uuid’
[18:06:04.721]   - Field: ‘seed’
[18:06:04.721]   - Field: ‘version’
[18:06:04.721]   - Field: ‘result’
[18:06:04.721]   - Field: ‘asynchronous’
[18:06:04.721]   - Field: ‘calls’
[18:06:04.721]   - Field: ‘globals’
[18:06:04.722]   - Field: ‘stdout’
[18:06:04.722]   - Field: ‘earlySignal’
[18:06:04.722]   - Field: ‘lazy’
[18:06:04.722]   - Field: ‘state’
[18:06:04.722] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:04.723] - Launch lazy future ...
[18:06:04.723] Packages needed by the future expression (n = 0): <none>
[18:06:04.723] Packages needed by future strategies (n = 0): <none>
[18:06:04.724] {
[18:06:04.724]     {
[18:06:04.724]         {
[18:06:04.724]             ...future.startTime <- base::Sys.time()
[18:06:04.724]             {
[18:06:04.724]                 {
[18:06:04.724]                   {
[18:06:04.724]                     base::local({
[18:06:04.724]                       has_future <- base::requireNamespace("future", 
[18:06:04.724]                         quietly = TRUE)
[18:06:04.724]                       if (has_future) {
[18:06:04.724]                         ns <- base::getNamespace("future")
[18:06:04.724]                         version <- ns[[".package"]][["version"]]
[18:06:04.724]                         if (is.null(version)) 
[18:06:04.724]                           version <- utils::packageVersion("future")
[18:06:04.724]                       }
[18:06:04.724]                       else {
[18:06:04.724]                         version <- NULL
[18:06:04.724]                       }
[18:06:04.724]                       if (!has_future || version < "1.8.0") {
[18:06:04.724]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:04.724]                           "", base::R.version$version.string), 
[18:06:04.724]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:04.724]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:04.724]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:04.724]                             "release", "version")], collapse = " "), 
[18:06:04.724]                           hostname = base::Sys.info()[["nodename"]])
[18:06:04.724]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:04.724]                           info)
[18:06:04.724]                         info <- base::paste(info, collapse = "; ")
[18:06:04.724]                         if (!has_future) {
[18:06:04.724]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:04.724]                             info)
[18:06:04.724]                         }
[18:06:04.724]                         else {
[18:06:04.724]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:04.724]                             info, version)
[18:06:04.724]                         }
[18:06:04.724]                         base::stop(msg)
[18:06:04.724]                       }
[18:06:04.724]                     })
[18:06:04.724]                   }
[18:06:04.724]                   ...future.strategy.old <- future::plan("list")
[18:06:04.724]                   options(future.plan = NULL)
[18:06:04.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:04.724]                 }
[18:06:04.724]                 ...future.workdir <- getwd()
[18:06:04.724]             }
[18:06:04.724]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:04.724]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:04.724]         }
[18:06:04.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:04.724]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:04.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:04.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:04.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:04.724]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:04.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:04.724]             base::names(...future.oldOptions))
[18:06:04.724]     }
[18:06:04.724]     if (FALSE) {
[18:06:04.724]     }
[18:06:04.724]     else {
[18:06:04.724]         if (TRUE) {
[18:06:04.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:04.724]                 open = "w")
[18:06:04.724]         }
[18:06:04.724]         else {
[18:06:04.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:04.724]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:04.724]         }
[18:06:04.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:04.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:04.724]             base::sink(type = "output", split = FALSE)
[18:06:04.724]             base::close(...future.stdout)
[18:06:04.724]         }, add = TRUE)
[18:06:04.724]     }
[18:06:04.724]     ...future.frame <- base::sys.nframe()
[18:06:04.724]     ...future.conditions <- base::list()
[18:06:04.724]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:04.724]     if (FALSE) {
[18:06:04.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:04.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:04.724]     }
[18:06:04.724]     ...future.result <- base::tryCatch({
[18:06:04.724]         base::withCallingHandlers({
[18:06:04.724]             ...future.value <- base::withVisible(base::local({
[18:06:04.724]                 Sys.sleep(0.1)
[18:06:04.724]                 kk
[18:06:04.724]             }))
[18:06:04.724]             future::FutureResult(value = ...future.value$value, 
[18:06:04.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.724]                   ...future.rng), globalenv = if (FALSE) 
[18:06:04.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:04.724]                     ...future.globalenv.names))
[18:06:04.724]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:04.724]         }, condition = base::local({
[18:06:04.724]             c <- base::c
[18:06:04.724]             inherits <- base::inherits
[18:06:04.724]             invokeRestart <- base::invokeRestart
[18:06:04.724]             length <- base::length
[18:06:04.724]             list <- base::list
[18:06:04.724]             seq.int <- base::seq.int
[18:06:04.724]             signalCondition <- base::signalCondition
[18:06:04.724]             sys.calls <- base::sys.calls
[18:06:04.724]             `[[` <- base::`[[`
[18:06:04.724]             `+` <- base::`+`
[18:06:04.724]             `<<-` <- base::`<<-`
[18:06:04.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:04.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:04.724]                   3L)]
[18:06:04.724]             }
[18:06:04.724]             function(cond) {
[18:06:04.724]                 is_error <- inherits(cond, "error")
[18:06:04.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:04.724]                   NULL)
[18:06:04.724]                 if (is_error) {
[18:06:04.724]                   sessionInformation <- function() {
[18:06:04.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:04.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:04.724]                       search = base::search(), system = base::Sys.info())
[18:06:04.724]                   }
[18:06:04.724]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:04.724]                     cond$call), session = sessionInformation(), 
[18:06:04.724]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:04.724]                   signalCondition(cond)
[18:06:04.724]                 }
[18:06:04.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:04.724]                 "immediateCondition"))) {
[18:06:04.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:04.724]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:04.724]                   if (TRUE && !signal) {
[18:06:04.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.724]                     {
[18:06:04.724]                       inherits <- base::inherits
[18:06:04.724]                       invokeRestart <- base::invokeRestart
[18:06:04.724]                       is.null <- base::is.null
[18:06:04.724]                       muffled <- FALSE
[18:06:04.724]                       if (inherits(cond, "message")) {
[18:06:04.724]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.724]                         if (muffled) 
[18:06:04.724]                           invokeRestart("muffleMessage")
[18:06:04.724]                       }
[18:06:04.724]                       else if (inherits(cond, "warning")) {
[18:06:04.724]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.724]                         if (muffled) 
[18:06:04.724]                           invokeRestart("muffleWarning")
[18:06:04.724]                       }
[18:06:04.724]                       else if (inherits(cond, "condition")) {
[18:06:04.724]                         if (!is.null(pattern)) {
[18:06:04.724]                           computeRestarts <- base::computeRestarts
[18:06:04.724]                           grepl <- base::grepl
[18:06:04.724]                           restarts <- computeRestarts(cond)
[18:06:04.724]                           for (restart in restarts) {
[18:06:04.724]                             name <- restart$name
[18:06:04.724]                             if (is.null(name)) 
[18:06:04.724]                               next
[18:06:04.724]                             if (!grepl(pattern, name)) 
[18:06:04.724]                               next
[18:06:04.724]                             invokeRestart(restart)
[18:06:04.724]                             muffled <- TRUE
[18:06:04.724]                             break
[18:06:04.724]                           }
[18:06:04.724]                         }
[18:06:04.724]                       }
[18:06:04.724]                       invisible(muffled)
[18:06:04.724]                     }
[18:06:04.724]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.724]                   }
[18:06:04.724]                 }
[18:06:04.724]                 else {
[18:06:04.724]                   if (TRUE) {
[18:06:04.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.724]                     {
[18:06:04.724]                       inherits <- base::inherits
[18:06:04.724]                       invokeRestart <- base::invokeRestart
[18:06:04.724]                       is.null <- base::is.null
[18:06:04.724]                       muffled <- FALSE
[18:06:04.724]                       if (inherits(cond, "message")) {
[18:06:04.724]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.724]                         if (muffled) 
[18:06:04.724]                           invokeRestart("muffleMessage")
[18:06:04.724]                       }
[18:06:04.724]                       else if (inherits(cond, "warning")) {
[18:06:04.724]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.724]                         if (muffled) 
[18:06:04.724]                           invokeRestart("muffleWarning")
[18:06:04.724]                       }
[18:06:04.724]                       else if (inherits(cond, "condition")) {
[18:06:04.724]                         if (!is.null(pattern)) {
[18:06:04.724]                           computeRestarts <- base::computeRestarts
[18:06:04.724]                           grepl <- base::grepl
[18:06:04.724]                           restarts <- computeRestarts(cond)
[18:06:04.724]                           for (restart in restarts) {
[18:06:04.724]                             name <- restart$name
[18:06:04.724]                             if (is.null(name)) 
[18:06:04.724]                               next
[18:06:04.724]                             if (!grepl(pattern, name)) 
[18:06:04.724]                               next
[18:06:04.724]                             invokeRestart(restart)
[18:06:04.724]                             muffled <- TRUE
[18:06:04.724]                             break
[18:06:04.724]                           }
[18:06:04.724]                         }
[18:06:04.724]                       }
[18:06:04.724]                       invisible(muffled)
[18:06:04.724]                     }
[18:06:04.724]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.724]                   }
[18:06:04.724]                 }
[18:06:04.724]             }
[18:06:04.724]         }))
[18:06:04.724]     }, error = function(ex) {
[18:06:04.724]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:04.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.724]                 ...future.rng), started = ...future.startTime, 
[18:06:04.724]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:04.724]             version = "1.8"), class = "FutureResult")
[18:06:04.724]     }, finally = {
[18:06:04.724]         if (!identical(...future.workdir, getwd())) 
[18:06:04.724]             setwd(...future.workdir)
[18:06:04.724]         {
[18:06:04.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:04.724]                 ...future.oldOptions$nwarnings <- NULL
[18:06:04.724]             }
[18:06:04.724]             base::options(...future.oldOptions)
[18:06:04.724]             if (.Platform$OS.type == "windows") {
[18:06:04.724]                 old_names <- names(...future.oldEnvVars)
[18:06:04.724]                 envs <- base::Sys.getenv()
[18:06:04.724]                 names <- names(envs)
[18:06:04.724]                 common <- intersect(names, old_names)
[18:06:04.724]                 added <- setdiff(names, old_names)
[18:06:04.724]                 removed <- setdiff(old_names, names)
[18:06:04.724]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:04.724]                   envs[common]]
[18:06:04.724]                 NAMES <- toupper(changed)
[18:06:04.724]                 args <- list()
[18:06:04.724]                 for (kk in seq_along(NAMES)) {
[18:06:04.724]                   name <- changed[[kk]]
[18:06:04.724]                   NAME <- NAMES[[kk]]
[18:06:04.724]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.724]                     next
[18:06:04.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.724]                 }
[18:06:04.724]                 NAMES <- toupper(added)
[18:06:04.724]                 for (kk in seq_along(NAMES)) {
[18:06:04.724]                   name <- added[[kk]]
[18:06:04.724]                   NAME <- NAMES[[kk]]
[18:06:04.724]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.724]                     next
[18:06:04.724]                   args[[name]] <- ""
[18:06:04.724]                 }
[18:06:04.724]                 NAMES <- toupper(removed)
[18:06:04.724]                 for (kk in seq_along(NAMES)) {
[18:06:04.724]                   name <- removed[[kk]]
[18:06:04.724]                   NAME <- NAMES[[kk]]
[18:06:04.724]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.724]                     next
[18:06:04.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.724]                 }
[18:06:04.724]                 if (length(args) > 0) 
[18:06:04.724]                   base::do.call(base::Sys.setenv, args = args)
[18:06:04.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:04.724]             }
[18:06:04.724]             else {
[18:06:04.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:04.724]             }
[18:06:04.724]             {
[18:06:04.724]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:04.724]                   0L) {
[18:06:04.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:04.724]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:04.724]                   base::options(opts)
[18:06:04.724]                 }
[18:06:04.724]                 {
[18:06:04.724]                   {
[18:06:04.724]                     NULL
[18:06:04.724]                     RNGkind("Mersenne-Twister")
[18:06:04.724]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:04.724]                       inherits = FALSE)
[18:06:04.724]                   }
[18:06:04.724]                   options(future.plan = NULL)
[18:06:04.724]                   if (is.na(NA_character_)) 
[18:06:04.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:04.724]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:04.724]                     .init = FALSE)
[18:06:04.724]                 }
[18:06:04.724]             }
[18:06:04.724]         }
[18:06:04.724]     })
[18:06:04.724]     if (TRUE) {
[18:06:04.724]         base::sink(type = "output", split = FALSE)
[18:06:04.724]         if (TRUE) {
[18:06:04.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:04.724]         }
[18:06:04.724]         else {
[18:06:04.724]             ...future.result["stdout"] <- base::list(NULL)
[18:06:04.724]         }
[18:06:04.724]         base::close(...future.stdout)
[18:06:04.724]         ...future.stdout <- NULL
[18:06:04.724]     }
[18:06:04.724]     ...future.result$conditions <- ...future.conditions
[18:06:04.724]     ...future.result$finished <- base::Sys.time()
[18:06:04.724]     ...future.result
[18:06:04.724] }
[18:06:04.727] assign_globals() ...
[18:06:04.727] List of 1
[18:06:04.727]  $ kk: int 3
[18:06:04.727]  - attr(*, "where")=List of 1
[18:06:04.727]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:04.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:04.727]  - attr(*, "resolved")= logi FALSE
[18:06:04.727]  - attr(*, "total_size")= num 56
[18:06:04.727]  - attr(*, "already-done")= logi TRUE
[18:06:04.733] - copied ‘kk’ to environment
[18:06:04.733] assign_globals() ... done
[18:06:04.734] plan(): Setting new future strategy stack:
[18:06:04.734] List of future strategies:
[18:06:04.734] 1. sequential:
[18:06:04.734]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.734]    - tweaked: FALSE
[18:06:04.734]    - call: NULL
[18:06:04.735] plan(): nbrOfWorkers() = 1
[18:06:04.839] plan(): Setting new future strategy stack:
[18:06:04.840] List of future strategies:
[18:06:04.840] 1. sequential:
[18:06:04.840]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.840]    - tweaked: FALSE
[18:06:04.840]    - call: plan(strategy)
[18:06:04.841] plan(): nbrOfWorkers() = 1
[18:06:04.841] SequentialFuture started (and completed)
[18:06:04.841] - Launch lazy future ... done
[18:06:04.842] run() for ‘SequentialFuture’ ... done
[18:06:04.842] resolve() on list ...
[18:06:04.842]  recursive: 0
[18:06:04.842]  length: 3
[18:06:04.842] 
[18:06:04.843] resolved() for ‘SequentialFuture’ ...
[18:06:04.843] - state: ‘finished’
[18:06:04.843] - run: TRUE
[18:06:04.843] - result: ‘FutureResult’
[18:06:04.844] resolved() for ‘SequentialFuture’ ... done
[18:06:04.844] Future #1
[18:06:04.844]  length: 2 (resolved future 1)
[18:06:04.844] resolved() for ‘SequentialFuture’ ...
[18:06:04.844] - state: ‘finished’
[18:06:04.845] - run: TRUE
[18:06:04.845] - result: ‘FutureResult’
[18:06:04.845] resolved() for ‘SequentialFuture’ ... done
[18:06:04.845] Future #2
[18:06:04.845]  length: 1 (resolved future 2)
[18:06:04.846] resolved() for ‘SequentialFuture’ ...
[18:06:04.846] - state: ‘finished’
[18:06:04.846] - run: TRUE
[18:06:04.846] - result: ‘FutureResult’
[18:06:04.846] resolved() for ‘SequentialFuture’ ... done
[18:06:04.847] Future #3
[18:06:04.847]  length: 0 (resolved future 3)
[18:06:04.847] resolve() on list ... DONE
[18:06:04.847] getGlobalsAndPackages() ...
[18:06:04.848] Searching for globals...
[18:06:04.850] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:04.850] Searching for globals ... DONE
[18:06:04.850] Resolving globals: FALSE
[18:06:04.851] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:04.852] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:04.852] - globals: [1] ‘kk’
[18:06:04.852] 
[18:06:04.852] getGlobalsAndPackages() ... DONE
[18:06:04.853] getGlobalsAndPackages() ...
[18:06:04.853] Searching for globals...
[18:06:04.856] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:04.856] Searching for globals ... DONE
[18:06:04.856] Resolving globals: FALSE
[18:06:04.857] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:04.857] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:04.858] - globals: [1] ‘kk’
[18:06:04.858] 
[18:06:04.858] getGlobalsAndPackages() ... DONE
[18:06:04.859] getGlobalsAndPackages() ...
[18:06:04.859] Searching for globals...
[18:06:04.861] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:04.861] Searching for globals ... DONE
[18:06:04.861] Resolving globals: FALSE
[18:06:04.862] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:04.863] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:04.863] - globals: [1] ‘kk’
[18:06:04.863] 
[18:06:04.864] getGlobalsAndPackages() ... DONE
[18:06:04.864] resolve() on list ...
[18:06:04.864]  recursive: 0
[18:06:04.864]  length: 3
[18:06:04.865] 
[18:06:04.865] run() for ‘Future’ ...
[18:06:04.865] - state: ‘created’
[18:06:04.865] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:04.866] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:04.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:04.866]   - Field: ‘label’
[18:06:04.867]   - Field: ‘local’
[18:06:04.867]   - Field: ‘owner’
[18:06:04.867]   - Field: ‘envir’
[18:06:04.867]   - Field: ‘packages’
[18:06:04.867]   - Field: ‘gc’
[18:06:04.868]   - Field: ‘conditions’
[18:06:04.868]   - Field: ‘expr’
[18:06:04.868]   - Field: ‘uuid’
[18:06:04.868]   - Field: ‘seed’
[18:06:04.868]   - Field: ‘version’
[18:06:04.869]   - Field: ‘result’
[18:06:04.869]   - Field: ‘asynchronous’
[18:06:04.869]   - Field: ‘calls’
[18:06:04.869]   - Field: ‘globals’
[18:06:04.869]   - Field: ‘stdout’
[18:06:04.870]   - Field: ‘earlySignal’
[18:06:04.870]   - Field: ‘lazy’
[18:06:04.870]   - Field: ‘state’
[18:06:04.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:04.871] - Launch lazy future ...
[18:06:04.871] Packages needed by the future expression (n = 0): <none>
[18:06:04.871] Packages needed by future strategies (n = 0): <none>
[18:06:04.872] {
[18:06:04.872]     {
[18:06:04.872]         {
[18:06:04.872]             ...future.startTime <- base::Sys.time()
[18:06:04.872]             {
[18:06:04.872]                 {
[18:06:04.872]                   {
[18:06:04.872]                     base::local({
[18:06:04.872]                       has_future <- base::requireNamespace("future", 
[18:06:04.872]                         quietly = TRUE)
[18:06:04.872]                       if (has_future) {
[18:06:04.872]                         ns <- base::getNamespace("future")
[18:06:04.872]                         version <- ns[[".package"]][["version"]]
[18:06:04.872]                         if (is.null(version)) 
[18:06:04.872]                           version <- utils::packageVersion("future")
[18:06:04.872]                       }
[18:06:04.872]                       else {
[18:06:04.872]                         version <- NULL
[18:06:04.872]                       }
[18:06:04.872]                       if (!has_future || version < "1.8.0") {
[18:06:04.872]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:04.872]                           "", base::R.version$version.string), 
[18:06:04.872]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:04.872]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:04.872]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:04.872]                             "release", "version")], collapse = " "), 
[18:06:04.872]                           hostname = base::Sys.info()[["nodename"]])
[18:06:04.872]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:04.872]                           info)
[18:06:04.872]                         info <- base::paste(info, collapse = "; ")
[18:06:04.872]                         if (!has_future) {
[18:06:04.872]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:04.872]                             info)
[18:06:04.872]                         }
[18:06:04.872]                         else {
[18:06:04.872]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:04.872]                             info, version)
[18:06:04.872]                         }
[18:06:04.872]                         base::stop(msg)
[18:06:04.872]                       }
[18:06:04.872]                     })
[18:06:04.872]                   }
[18:06:04.872]                   ...future.strategy.old <- future::plan("list")
[18:06:04.872]                   options(future.plan = NULL)
[18:06:04.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:04.872]                 }
[18:06:04.872]                 ...future.workdir <- getwd()
[18:06:04.872]             }
[18:06:04.872]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:04.872]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:04.872]         }
[18:06:04.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:04.872]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:04.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:04.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:04.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:04.872]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:04.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:04.872]             base::names(...future.oldOptions))
[18:06:04.872]     }
[18:06:04.872]     if (FALSE) {
[18:06:04.872]     }
[18:06:04.872]     else {
[18:06:04.872]         if (TRUE) {
[18:06:04.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:04.872]                 open = "w")
[18:06:04.872]         }
[18:06:04.872]         else {
[18:06:04.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:04.872]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:04.872]         }
[18:06:04.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:04.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:04.872]             base::sink(type = "output", split = FALSE)
[18:06:04.872]             base::close(...future.stdout)
[18:06:04.872]         }, add = TRUE)
[18:06:04.872]     }
[18:06:04.872]     ...future.frame <- base::sys.nframe()
[18:06:04.872]     ...future.conditions <- base::list()
[18:06:04.872]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:04.872]     if (FALSE) {
[18:06:04.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:04.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:04.872]     }
[18:06:04.872]     ...future.result <- base::tryCatch({
[18:06:04.872]         base::withCallingHandlers({
[18:06:04.872]             ...future.value <- base::withVisible(base::local({
[18:06:04.872]                 Sys.sleep(0.1)
[18:06:04.872]                 kk
[18:06:04.872]             }))
[18:06:04.872]             future::FutureResult(value = ...future.value$value, 
[18:06:04.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.872]                   ...future.rng), globalenv = if (FALSE) 
[18:06:04.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:04.872]                     ...future.globalenv.names))
[18:06:04.872]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:04.872]         }, condition = base::local({
[18:06:04.872]             c <- base::c
[18:06:04.872]             inherits <- base::inherits
[18:06:04.872]             invokeRestart <- base::invokeRestart
[18:06:04.872]             length <- base::length
[18:06:04.872]             list <- base::list
[18:06:04.872]             seq.int <- base::seq.int
[18:06:04.872]             signalCondition <- base::signalCondition
[18:06:04.872]             sys.calls <- base::sys.calls
[18:06:04.872]             `[[` <- base::`[[`
[18:06:04.872]             `+` <- base::`+`
[18:06:04.872]             `<<-` <- base::`<<-`
[18:06:04.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:04.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:04.872]                   3L)]
[18:06:04.872]             }
[18:06:04.872]             function(cond) {
[18:06:04.872]                 is_error <- inherits(cond, "error")
[18:06:04.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:04.872]                   NULL)
[18:06:04.872]                 if (is_error) {
[18:06:04.872]                   sessionInformation <- function() {
[18:06:04.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:04.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:04.872]                       search = base::search(), system = base::Sys.info())
[18:06:04.872]                   }
[18:06:04.872]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:04.872]                     cond$call), session = sessionInformation(), 
[18:06:04.872]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:04.872]                   signalCondition(cond)
[18:06:04.872]                 }
[18:06:04.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:04.872]                 "immediateCondition"))) {
[18:06:04.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:04.872]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:04.872]                   if (TRUE && !signal) {
[18:06:04.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.872]                     {
[18:06:04.872]                       inherits <- base::inherits
[18:06:04.872]                       invokeRestart <- base::invokeRestart
[18:06:04.872]                       is.null <- base::is.null
[18:06:04.872]                       muffled <- FALSE
[18:06:04.872]                       if (inherits(cond, "message")) {
[18:06:04.872]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.872]                         if (muffled) 
[18:06:04.872]                           invokeRestart("muffleMessage")
[18:06:04.872]                       }
[18:06:04.872]                       else if (inherits(cond, "warning")) {
[18:06:04.872]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.872]                         if (muffled) 
[18:06:04.872]                           invokeRestart("muffleWarning")
[18:06:04.872]                       }
[18:06:04.872]                       else if (inherits(cond, "condition")) {
[18:06:04.872]                         if (!is.null(pattern)) {
[18:06:04.872]                           computeRestarts <- base::computeRestarts
[18:06:04.872]                           grepl <- base::grepl
[18:06:04.872]                           restarts <- computeRestarts(cond)
[18:06:04.872]                           for (restart in restarts) {
[18:06:04.872]                             name <- restart$name
[18:06:04.872]                             if (is.null(name)) 
[18:06:04.872]                               next
[18:06:04.872]                             if (!grepl(pattern, name)) 
[18:06:04.872]                               next
[18:06:04.872]                             invokeRestart(restart)
[18:06:04.872]                             muffled <- TRUE
[18:06:04.872]                             break
[18:06:04.872]                           }
[18:06:04.872]                         }
[18:06:04.872]                       }
[18:06:04.872]                       invisible(muffled)
[18:06:04.872]                     }
[18:06:04.872]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.872]                   }
[18:06:04.872]                 }
[18:06:04.872]                 else {
[18:06:04.872]                   if (TRUE) {
[18:06:04.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.872]                     {
[18:06:04.872]                       inherits <- base::inherits
[18:06:04.872]                       invokeRestart <- base::invokeRestart
[18:06:04.872]                       is.null <- base::is.null
[18:06:04.872]                       muffled <- FALSE
[18:06:04.872]                       if (inherits(cond, "message")) {
[18:06:04.872]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.872]                         if (muffled) 
[18:06:04.872]                           invokeRestart("muffleMessage")
[18:06:04.872]                       }
[18:06:04.872]                       else if (inherits(cond, "warning")) {
[18:06:04.872]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.872]                         if (muffled) 
[18:06:04.872]                           invokeRestart("muffleWarning")
[18:06:04.872]                       }
[18:06:04.872]                       else if (inherits(cond, "condition")) {
[18:06:04.872]                         if (!is.null(pattern)) {
[18:06:04.872]                           computeRestarts <- base::computeRestarts
[18:06:04.872]                           grepl <- base::grepl
[18:06:04.872]                           restarts <- computeRestarts(cond)
[18:06:04.872]                           for (restart in restarts) {
[18:06:04.872]                             name <- restart$name
[18:06:04.872]                             if (is.null(name)) 
[18:06:04.872]                               next
[18:06:04.872]                             if (!grepl(pattern, name)) 
[18:06:04.872]                               next
[18:06:04.872]                             invokeRestart(restart)
[18:06:04.872]                             muffled <- TRUE
[18:06:04.872]                             break
[18:06:04.872]                           }
[18:06:04.872]                         }
[18:06:04.872]                       }
[18:06:04.872]                       invisible(muffled)
[18:06:04.872]                     }
[18:06:04.872]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.872]                   }
[18:06:04.872]                 }
[18:06:04.872]             }
[18:06:04.872]         }))
[18:06:04.872]     }, error = function(ex) {
[18:06:04.872]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:04.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.872]                 ...future.rng), started = ...future.startTime, 
[18:06:04.872]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:04.872]             version = "1.8"), class = "FutureResult")
[18:06:04.872]     }, finally = {
[18:06:04.872]         if (!identical(...future.workdir, getwd())) 
[18:06:04.872]             setwd(...future.workdir)
[18:06:04.872]         {
[18:06:04.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:04.872]                 ...future.oldOptions$nwarnings <- NULL
[18:06:04.872]             }
[18:06:04.872]             base::options(...future.oldOptions)
[18:06:04.872]             if (.Platform$OS.type == "windows") {
[18:06:04.872]                 old_names <- names(...future.oldEnvVars)
[18:06:04.872]                 envs <- base::Sys.getenv()
[18:06:04.872]                 names <- names(envs)
[18:06:04.872]                 common <- intersect(names, old_names)
[18:06:04.872]                 added <- setdiff(names, old_names)
[18:06:04.872]                 removed <- setdiff(old_names, names)
[18:06:04.872]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:04.872]                   envs[common]]
[18:06:04.872]                 NAMES <- toupper(changed)
[18:06:04.872]                 args <- list()
[18:06:04.872]                 for (kk in seq_along(NAMES)) {
[18:06:04.872]                   name <- changed[[kk]]
[18:06:04.872]                   NAME <- NAMES[[kk]]
[18:06:04.872]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.872]                     next
[18:06:04.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.872]                 }
[18:06:04.872]                 NAMES <- toupper(added)
[18:06:04.872]                 for (kk in seq_along(NAMES)) {
[18:06:04.872]                   name <- added[[kk]]
[18:06:04.872]                   NAME <- NAMES[[kk]]
[18:06:04.872]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.872]                     next
[18:06:04.872]                   args[[name]] <- ""
[18:06:04.872]                 }
[18:06:04.872]                 NAMES <- toupper(removed)
[18:06:04.872]                 for (kk in seq_along(NAMES)) {
[18:06:04.872]                   name <- removed[[kk]]
[18:06:04.872]                   NAME <- NAMES[[kk]]
[18:06:04.872]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.872]                     next
[18:06:04.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.872]                 }
[18:06:04.872]                 if (length(args) > 0) 
[18:06:04.872]                   base::do.call(base::Sys.setenv, args = args)
[18:06:04.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:04.872]             }
[18:06:04.872]             else {
[18:06:04.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:04.872]             }
[18:06:04.872]             {
[18:06:04.872]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:04.872]                   0L) {
[18:06:04.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:04.872]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:04.872]                   base::options(opts)
[18:06:04.872]                 }
[18:06:04.872]                 {
[18:06:04.872]                   {
[18:06:04.872]                     NULL
[18:06:04.872]                     RNGkind("Mersenne-Twister")
[18:06:04.872]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:04.872]                       inherits = FALSE)
[18:06:04.872]                   }
[18:06:04.872]                   options(future.plan = NULL)
[18:06:04.872]                   if (is.na(NA_character_)) 
[18:06:04.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:04.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:04.872]                     .init = FALSE)
[18:06:04.872]                 }
[18:06:04.872]             }
[18:06:04.872]         }
[18:06:04.872]     })
[18:06:04.872]     if (TRUE) {
[18:06:04.872]         base::sink(type = "output", split = FALSE)
[18:06:04.872]         if (TRUE) {
[18:06:04.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:04.872]         }
[18:06:04.872]         else {
[18:06:04.872]             ...future.result["stdout"] <- base::list(NULL)
[18:06:04.872]         }
[18:06:04.872]         base::close(...future.stdout)
[18:06:04.872]         ...future.stdout <- NULL
[18:06:04.872]     }
[18:06:04.872]     ...future.result$conditions <- ...future.conditions
[18:06:04.872]     ...future.result$finished <- base::Sys.time()
[18:06:04.872]     ...future.result
[18:06:04.872] }
[18:06:04.875] assign_globals() ...
[18:06:04.876] List of 1
[18:06:04.876]  $ kk: int 1
[18:06:04.876]  - attr(*, "where")=List of 1
[18:06:04.876]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:04.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:04.876]  - attr(*, "resolved")= logi FALSE
[18:06:04.876]  - attr(*, "total_size")= num 56
[18:06:04.876]  - attr(*, "already-done")= logi TRUE
[18:06:04.881] - copied ‘kk’ to environment
[18:06:04.881] assign_globals() ... done
[18:06:04.882] plan(): Setting new future strategy stack:
[18:06:04.882] List of future strategies:
[18:06:04.882] 1. sequential:
[18:06:04.882]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.882]    - tweaked: FALSE
[18:06:04.882]    - call: NULL
[18:06:04.883] plan(): nbrOfWorkers() = 1
[18:06:04.984] plan(): Setting new future strategy stack:
[18:06:04.985] List of future strategies:
[18:06:04.985] 1. sequential:
[18:06:04.985]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:04.985]    - tweaked: FALSE
[18:06:04.985]    - call: plan(strategy)
[18:06:04.986] plan(): nbrOfWorkers() = 1
[18:06:04.986] SequentialFuture started (and completed)
[18:06:04.987] - Launch lazy future ... done
[18:06:04.987] run() for ‘SequentialFuture’ ... done
[18:06:04.987] resolved() for ‘SequentialFuture’ ...
[18:06:04.987] - state: ‘finished’
[18:06:04.987] - run: TRUE
[18:06:04.988] - result: ‘FutureResult’
[18:06:04.988] resolved() for ‘SequentialFuture’ ... done
[18:06:04.988] Future #1
[18:06:04.988]  length: 2 (resolved future 1)
[18:06:04.989] run() for ‘Future’ ...
[18:06:04.989] - state: ‘created’
[18:06:04.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:04.990] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:04.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:04.990]   - Field: ‘label’
[18:06:04.990]   - Field: ‘local’
[18:06:04.991]   - Field: ‘owner’
[18:06:04.991]   - Field: ‘envir’
[18:06:04.991]   - Field: ‘packages’
[18:06:04.991]   - Field: ‘gc’
[18:06:04.992]   - Field: ‘conditions’
[18:06:04.992]   - Field: ‘expr’
[18:06:04.992]   - Field: ‘uuid’
[18:06:04.992]   - Field: ‘seed’
[18:06:04.992]   - Field: ‘version’
[18:06:04.993]   - Field: ‘result’
[18:06:04.993]   - Field: ‘asynchronous’
[18:06:04.993]   - Field: ‘calls’
[18:06:04.993]   - Field: ‘globals’
[18:06:04.994]   - Field: ‘stdout’
[18:06:04.994]   - Field: ‘earlySignal’
[18:06:04.994]   - Field: ‘lazy’
[18:06:04.994]   - Field: ‘state’
[18:06:04.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:04.995] - Launch lazy future ...
[18:06:04.995] Packages needed by the future expression (n = 0): <none>
[18:06:04.995] Packages needed by future strategies (n = 0): <none>
[18:06:04.996] {
[18:06:04.996]     {
[18:06:04.996]         {
[18:06:04.996]             ...future.startTime <- base::Sys.time()
[18:06:04.996]             {
[18:06:04.996]                 {
[18:06:04.996]                   {
[18:06:04.996]                     base::local({
[18:06:04.996]                       has_future <- base::requireNamespace("future", 
[18:06:04.996]                         quietly = TRUE)
[18:06:04.996]                       if (has_future) {
[18:06:04.996]                         ns <- base::getNamespace("future")
[18:06:04.996]                         version <- ns[[".package"]][["version"]]
[18:06:04.996]                         if (is.null(version)) 
[18:06:04.996]                           version <- utils::packageVersion("future")
[18:06:04.996]                       }
[18:06:04.996]                       else {
[18:06:04.996]                         version <- NULL
[18:06:04.996]                       }
[18:06:04.996]                       if (!has_future || version < "1.8.0") {
[18:06:04.996]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:04.996]                           "", base::R.version$version.string), 
[18:06:04.996]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:04.996]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:04.996]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:04.996]                             "release", "version")], collapse = " "), 
[18:06:04.996]                           hostname = base::Sys.info()[["nodename"]])
[18:06:04.996]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:04.996]                           info)
[18:06:04.996]                         info <- base::paste(info, collapse = "; ")
[18:06:04.996]                         if (!has_future) {
[18:06:04.996]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:04.996]                             info)
[18:06:04.996]                         }
[18:06:04.996]                         else {
[18:06:04.996]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:04.996]                             info, version)
[18:06:04.996]                         }
[18:06:04.996]                         base::stop(msg)
[18:06:04.996]                       }
[18:06:04.996]                     })
[18:06:04.996]                   }
[18:06:04.996]                   ...future.strategy.old <- future::plan("list")
[18:06:04.996]                   options(future.plan = NULL)
[18:06:04.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:04.996]                 }
[18:06:04.996]                 ...future.workdir <- getwd()
[18:06:04.996]             }
[18:06:04.996]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:04.996]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:04.996]         }
[18:06:04.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:04.996]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:04.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:04.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:04.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:04.996]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:04.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:04.996]             base::names(...future.oldOptions))
[18:06:04.996]     }
[18:06:04.996]     if (FALSE) {
[18:06:04.996]     }
[18:06:04.996]     else {
[18:06:04.996]         if (TRUE) {
[18:06:04.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:04.996]                 open = "w")
[18:06:04.996]         }
[18:06:04.996]         else {
[18:06:04.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:04.996]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:04.996]         }
[18:06:04.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:04.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:04.996]             base::sink(type = "output", split = FALSE)
[18:06:04.996]             base::close(...future.stdout)
[18:06:04.996]         }, add = TRUE)
[18:06:04.996]     }
[18:06:04.996]     ...future.frame <- base::sys.nframe()
[18:06:04.996]     ...future.conditions <- base::list()
[18:06:04.996]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:04.996]     if (FALSE) {
[18:06:04.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:04.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:04.996]     }
[18:06:04.996]     ...future.result <- base::tryCatch({
[18:06:04.996]         base::withCallingHandlers({
[18:06:04.996]             ...future.value <- base::withVisible(base::local({
[18:06:04.996]                 Sys.sleep(0.1)
[18:06:04.996]                 kk
[18:06:04.996]             }))
[18:06:04.996]             future::FutureResult(value = ...future.value$value, 
[18:06:04.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.996]                   ...future.rng), globalenv = if (FALSE) 
[18:06:04.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:04.996]                     ...future.globalenv.names))
[18:06:04.996]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:04.996]         }, condition = base::local({
[18:06:04.996]             c <- base::c
[18:06:04.996]             inherits <- base::inherits
[18:06:04.996]             invokeRestart <- base::invokeRestart
[18:06:04.996]             length <- base::length
[18:06:04.996]             list <- base::list
[18:06:04.996]             seq.int <- base::seq.int
[18:06:04.996]             signalCondition <- base::signalCondition
[18:06:04.996]             sys.calls <- base::sys.calls
[18:06:04.996]             `[[` <- base::`[[`
[18:06:04.996]             `+` <- base::`+`
[18:06:04.996]             `<<-` <- base::`<<-`
[18:06:04.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:04.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:04.996]                   3L)]
[18:06:04.996]             }
[18:06:04.996]             function(cond) {
[18:06:04.996]                 is_error <- inherits(cond, "error")
[18:06:04.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:04.996]                   NULL)
[18:06:04.996]                 if (is_error) {
[18:06:04.996]                   sessionInformation <- function() {
[18:06:04.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:04.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:04.996]                       search = base::search(), system = base::Sys.info())
[18:06:04.996]                   }
[18:06:04.996]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:04.996]                     cond$call), session = sessionInformation(), 
[18:06:04.996]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:04.996]                   signalCondition(cond)
[18:06:04.996]                 }
[18:06:04.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:04.996]                 "immediateCondition"))) {
[18:06:04.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:04.996]                   ...future.conditions[[length(...future.conditions) + 
[18:06:04.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:04.996]                   if (TRUE && !signal) {
[18:06:04.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.996]                     {
[18:06:04.996]                       inherits <- base::inherits
[18:06:04.996]                       invokeRestart <- base::invokeRestart
[18:06:04.996]                       is.null <- base::is.null
[18:06:04.996]                       muffled <- FALSE
[18:06:04.996]                       if (inherits(cond, "message")) {
[18:06:04.996]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.996]                         if (muffled) 
[18:06:04.996]                           invokeRestart("muffleMessage")
[18:06:04.996]                       }
[18:06:04.996]                       else if (inherits(cond, "warning")) {
[18:06:04.996]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.996]                         if (muffled) 
[18:06:04.996]                           invokeRestart("muffleWarning")
[18:06:04.996]                       }
[18:06:04.996]                       else if (inherits(cond, "condition")) {
[18:06:04.996]                         if (!is.null(pattern)) {
[18:06:04.996]                           computeRestarts <- base::computeRestarts
[18:06:04.996]                           grepl <- base::grepl
[18:06:04.996]                           restarts <- computeRestarts(cond)
[18:06:04.996]                           for (restart in restarts) {
[18:06:04.996]                             name <- restart$name
[18:06:04.996]                             if (is.null(name)) 
[18:06:04.996]                               next
[18:06:04.996]                             if (!grepl(pattern, name)) 
[18:06:04.996]                               next
[18:06:04.996]                             invokeRestart(restart)
[18:06:04.996]                             muffled <- TRUE
[18:06:04.996]                             break
[18:06:04.996]                           }
[18:06:04.996]                         }
[18:06:04.996]                       }
[18:06:04.996]                       invisible(muffled)
[18:06:04.996]                     }
[18:06:04.996]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.996]                   }
[18:06:04.996]                 }
[18:06:04.996]                 else {
[18:06:04.996]                   if (TRUE) {
[18:06:04.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:04.996]                     {
[18:06:04.996]                       inherits <- base::inherits
[18:06:04.996]                       invokeRestart <- base::invokeRestart
[18:06:04.996]                       is.null <- base::is.null
[18:06:04.996]                       muffled <- FALSE
[18:06:04.996]                       if (inherits(cond, "message")) {
[18:06:04.996]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:04.996]                         if (muffled) 
[18:06:04.996]                           invokeRestart("muffleMessage")
[18:06:04.996]                       }
[18:06:04.996]                       else if (inherits(cond, "warning")) {
[18:06:04.996]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:04.996]                         if (muffled) 
[18:06:04.996]                           invokeRestart("muffleWarning")
[18:06:04.996]                       }
[18:06:04.996]                       else if (inherits(cond, "condition")) {
[18:06:04.996]                         if (!is.null(pattern)) {
[18:06:04.996]                           computeRestarts <- base::computeRestarts
[18:06:04.996]                           grepl <- base::grepl
[18:06:04.996]                           restarts <- computeRestarts(cond)
[18:06:04.996]                           for (restart in restarts) {
[18:06:04.996]                             name <- restart$name
[18:06:04.996]                             if (is.null(name)) 
[18:06:04.996]                               next
[18:06:04.996]                             if (!grepl(pattern, name)) 
[18:06:04.996]                               next
[18:06:04.996]                             invokeRestart(restart)
[18:06:04.996]                             muffled <- TRUE
[18:06:04.996]                             break
[18:06:04.996]                           }
[18:06:04.996]                         }
[18:06:04.996]                       }
[18:06:04.996]                       invisible(muffled)
[18:06:04.996]                     }
[18:06:04.996]                     muffleCondition(cond, pattern = "^muffle")
[18:06:04.996]                   }
[18:06:04.996]                 }
[18:06:04.996]             }
[18:06:04.996]         }))
[18:06:04.996]     }, error = function(ex) {
[18:06:04.996]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:04.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:04.996]                 ...future.rng), started = ...future.startTime, 
[18:06:04.996]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:04.996]             version = "1.8"), class = "FutureResult")
[18:06:04.996]     }, finally = {
[18:06:04.996]         if (!identical(...future.workdir, getwd())) 
[18:06:04.996]             setwd(...future.workdir)
[18:06:04.996]         {
[18:06:04.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:04.996]                 ...future.oldOptions$nwarnings <- NULL
[18:06:04.996]             }
[18:06:04.996]             base::options(...future.oldOptions)
[18:06:04.996]             if (.Platform$OS.type == "windows") {
[18:06:04.996]                 old_names <- names(...future.oldEnvVars)
[18:06:04.996]                 envs <- base::Sys.getenv()
[18:06:04.996]                 names <- names(envs)
[18:06:04.996]                 common <- intersect(names, old_names)
[18:06:04.996]                 added <- setdiff(names, old_names)
[18:06:04.996]                 removed <- setdiff(old_names, names)
[18:06:04.996]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:04.996]                   envs[common]]
[18:06:04.996]                 NAMES <- toupper(changed)
[18:06:04.996]                 args <- list()
[18:06:04.996]                 for (kk in seq_along(NAMES)) {
[18:06:04.996]                   name <- changed[[kk]]
[18:06:04.996]                   NAME <- NAMES[[kk]]
[18:06:04.996]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.996]                     next
[18:06:04.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.996]                 }
[18:06:04.996]                 NAMES <- toupper(added)
[18:06:04.996]                 for (kk in seq_along(NAMES)) {
[18:06:04.996]                   name <- added[[kk]]
[18:06:04.996]                   NAME <- NAMES[[kk]]
[18:06:04.996]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.996]                     next
[18:06:04.996]                   args[[name]] <- ""
[18:06:04.996]                 }
[18:06:04.996]                 NAMES <- toupper(removed)
[18:06:04.996]                 for (kk in seq_along(NAMES)) {
[18:06:04.996]                   name <- removed[[kk]]
[18:06:04.996]                   NAME <- NAMES[[kk]]
[18:06:04.996]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:04.996]                     next
[18:06:04.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:04.996]                 }
[18:06:04.996]                 if (length(args) > 0) 
[18:06:04.996]                   base::do.call(base::Sys.setenv, args = args)
[18:06:04.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:04.996]             }
[18:06:04.996]             else {
[18:06:04.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:04.996]             }
[18:06:04.996]             {
[18:06:04.996]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:04.996]                   0L) {
[18:06:04.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:04.996]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:04.996]                   base::options(opts)
[18:06:04.996]                 }
[18:06:04.996]                 {
[18:06:04.996]                   {
[18:06:04.996]                     NULL
[18:06:04.996]                     RNGkind("Mersenne-Twister")
[18:06:04.996]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:04.996]                       inherits = FALSE)
[18:06:04.996]                   }
[18:06:04.996]                   options(future.plan = NULL)
[18:06:04.996]                   if (is.na(NA_character_)) 
[18:06:04.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:04.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:04.996]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:04.996]                     .init = FALSE)
[18:06:04.996]                 }
[18:06:04.996]             }
[18:06:04.996]         }
[18:06:04.996]     })
[18:06:04.996]     if (TRUE) {
[18:06:04.996]         base::sink(type = "output", split = FALSE)
[18:06:04.996]         if (TRUE) {
[18:06:04.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:04.996]         }
[18:06:04.996]         else {
[18:06:04.996]             ...future.result["stdout"] <- base::list(NULL)
[18:06:04.996]         }
[18:06:04.996]         base::close(...future.stdout)
[18:06:04.996]         ...future.stdout <- NULL
[18:06:04.996]     }
[18:06:04.996]     ...future.result$conditions <- ...future.conditions
[18:06:04.996]     ...future.result$finished <- base::Sys.time()
[18:06:04.996]     ...future.result
[18:06:04.996] }
[18:06:05.000] assign_globals() ...
[18:06:05.000] List of 1
[18:06:05.000]  $ kk: int 2
[18:06:05.000]  - attr(*, "where")=List of 1
[18:06:05.000]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:05.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:05.000]  - attr(*, "resolved")= logi FALSE
[18:06:05.000]  - attr(*, "total_size")= num 56
[18:06:05.000]  - attr(*, "already-done")= logi TRUE
[18:06:05.009] - copied ‘kk’ to environment
[18:06:05.010] assign_globals() ... done
[18:06:05.010] plan(): Setting new future strategy stack:
[18:06:05.010] List of future strategies:
[18:06:05.010] 1. sequential:
[18:06:05.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.010]    - tweaked: FALSE
[18:06:05.010]    - call: NULL
[18:06:05.012] plan(): nbrOfWorkers() = 1
[18:06:05.114] plan(): Setting new future strategy stack:
[18:06:05.114] List of future strategies:
[18:06:05.114] 1. sequential:
[18:06:05.114]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.114]    - tweaked: FALSE
[18:06:05.114]    - call: plan(strategy)
[18:06:05.115] plan(): nbrOfWorkers() = 1
[18:06:05.116] SequentialFuture started (and completed)
[18:06:05.116] - Launch lazy future ... done
[18:06:05.116] run() for ‘SequentialFuture’ ... done
[18:06:05.116] resolved() for ‘SequentialFuture’ ...
[18:06:05.117] - state: ‘finished’
[18:06:05.117] - run: TRUE
[18:06:05.117] - result: ‘FutureResult’
[18:06:05.117] resolved() for ‘SequentialFuture’ ... done
[18:06:05.118] Future #2
[18:06:05.118]  length: 1 (resolved future 2)
[18:06:05.118] run() for ‘Future’ ...
[18:06:05.118] - state: ‘created’
[18:06:05.119] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.119] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.120] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.120]   - Field: ‘label’
[18:06:05.120]   - Field: ‘local’
[18:06:05.120]   - Field: ‘owner’
[18:06:05.121]   - Field: ‘envir’
[18:06:05.121]   - Field: ‘packages’
[18:06:05.121]   - Field: ‘gc’
[18:06:05.121]   - Field: ‘conditions’
[18:06:05.122]   - Field: ‘expr’
[18:06:05.122]   - Field: ‘uuid’
[18:06:05.122]   - Field: ‘seed’
[18:06:05.122]   - Field: ‘version’
[18:06:05.122]   - Field: ‘result’
[18:06:05.123]   - Field: ‘asynchronous’
[18:06:05.123]   - Field: ‘calls’
[18:06:05.123]   - Field: ‘globals’
[18:06:05.123]   - Field: ‘stdout’
[18:06:05.124]   - Field: ‘earlySignal’
[18:06:05.124]   - Field: ‘lazy’
[18:06:05.124]   - Field: ‘state’
[18:06:05.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.125] - Launch lazy future ...
[18:06:05.125] Packages needed by the future expression (n = 0): <none>
[18:06:05.125] Packages needed by future strategies (n = 0): <none>
[18:06:05.126] {
[18:06:05.126]     {
[18:06:05.126]         {
[18:06:05.126]             ...future.startTime <- base::Sys.time()
[18:06:05.126]             {
[18:06:05.126]                 {
[18:06:05.126]                   {
[18:06:05.126]                     base::local({
[18:06:05.126]                       has_future <- base::requireNamespace("future", 
[18:06:05.126]                         quietly = TRUE)
[18:06:05.126]                       if (has_future) {
[18:06:05.126]                         ns <- base::getNamespace("future")
[18:06:05.126]                         version <- ns[[".package"]][["version"]]
[18:06:05.126]                         if (is.null(version)) 
[18:06:05.126]                           version <- utils::packageVersion("future")
[18:06:05.126]                       }
[18:06:05.126]                       else {
[18:06:05.126]                         version <- NULL
[18:06:05.126]                       }
[18:06:05.126]                       if (!has_future || version < "1.8.0") {
[18:06:05.126]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.126]                           "", base::R.version$version.string), 
[18:06:05.126]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.126]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.126]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.126]                             "release", "version")], collapse = " "), 
[18:06:05.126]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.126]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.126]                           info)
[18:06:05.126]                         info <- base::paste(info, collapse = "; ")
[18:06:05.126]                         if (!has_future) {
[18:06:05.126]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.126]                             info)
[18:06:05.126]                         }
[18:06:05.126]                         else {
[18:06:05.126]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.126]                             info, version)
[18:06:05.126]                         }
[18:06:05.126]                         base::stop(msg)
[18:06:05.126]                       }
[18:06:05.126]                     })
[18:06:05.126]                   }
[18:06:05.126]                   ...future.strategy.old <- future::plan("list")
[18:06:05.126]                   options(future.plan = NULL)
[18:06:05.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.126]                 }
[18:06:05.126]                 ...future.workdir <- getwd()
[18:06:05.126]             }
[18:06:05.126]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.126]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.126]         }
[18:06:05.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.126]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.126]             base::names(...future.oldOptions))
[18:06:05.126]     }
[18:06:05.126]     if (FALSE) {
[18:06:05.126]     }
[18:06:05.126]     else {
[18:06:05.126]         if (TRUE) {
[18:06:05.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.126]                 open = "w")
[18:06:05.126]         }
[18:06:05.126]         else {
[18:06:05.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.126]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.126]         }
[18:06:05.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.126]             base::sink(type = "output", split = FALSE)
[18:06:05.126]             base::close(...future.stdout)
[18:06:05.126]         }, add = TRUE)
[18:06:05.126]     }
[18:06:05.126]     ...future.frame <- base::sys.nframe()
[18:06:05.126]     ...future.conditions <- base::list()
[18:06:05.126]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.126]     if (FALSE) {
[18:06:05.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.126]     }
[18:06:05.126]     ...future.result <- base::tryCatch({
[18:06:05.126]         base::withCallingHandlers({
[18:06:05.126]             ...future.value <- base::withVisible(base::local({
[18:06:05.126]                 Sys.sleep(0.1)
[18:06:05.126]                 kk
[18:06:05.126]             }))
[18:06:05.126]             future::FutureResult(value = ...future.value$value, 
[18:06:05.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.126]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.126]                     ...future.globalenv.names))
[18:06:05.126]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.126]         }, condition = base::local({
[18:06:05.126]             c <- base::c
[18:06:05.126]             inherits <- base::inherits
[18:06:05.126]             invokeRestart <- base::invokeRestart
[18:06:05.126]             length <- base::length
[18:06:05.126]             list <- base::list
[18:06:05.126]             seq.int <- base::seq.int
[18:06:05.126]             signalCondition <- base::signalCondition
[18:06:05.126]             sys.calls <- base::sys.calls
[18:06:05.126]             `[[` <- base::`[[`
[18:06:05.126]             `+` <- base::`+`
[18:06:05.126]             `<<-` <- base::`<<-`
[18:06:05.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.126]                   3L)]
[18:06:05.126]             }
[18:06:05.126]             function(cond) {
[18:06:05.126]                 is_error <- inherits(cond, "error")
[18:06:05.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.126]                   NULL)
[18:06:05.126]                 if (is_error) {
[18:06:05.126]                   sessionInformation <- function() {
[18:06:05.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.126]                       search = base::search(), system = base::Sys.info())
[18:06:05.126]                   }
[18:06:05.126]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.126]                     cond$call), session = sessionInformation(), 
[18:06:05.126]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.126]                   signalCondition(cond)
[18:06:05.126]                 }
[18:06:05.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.126]                 "immediateCondition"))) {
[18:06:05.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.126]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.126]                   if (TRUE && !signal) {
[18:06:05.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.126]                     {
[18:06:05.126]                       inherits <- base::inherits
[18:06:05.126]                       invokeRestart <- base::invokeRestart
[18:06:05.126]                       is.null <- base::is.null
[18:06:05.126]                       muffled <- FALSE
[18:06:05.126]                       if (inherits(cond, "message")) {
[18:06:05.126]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.126]                         if (muffled) 
[18:06:05.126]                           invokeRestart("muffleMessage")
[18:06:05.126]                       }
[18:06:05.126]                       else if (inherits(cond, "warning")) {
[18:06:05.126]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.126]                         if (muffled) 
[18:06:05.126]                           invokeRestart("muffleWarning")
[18:06:05.126]                       }
[18:06:05.126]                       else if (inherits(cond, "condition")) {
[18:06:05.126]                         if (!is.null(pattern)) {
[18:06:05.126]                           computeRestarts <- base::computeRestarts
[18:06:05.126]                           grepl <- base::grepl
[18:06:05.126]                           restarts <- computeRestarts(cond)
[18:06:05.126]                           for (restart in restarts) {
[18:06:05.126]                             name <- restart$name
[18:06:05.126]                             if (is.null(name)) 
[18:06:05.126]                               next
[18:06:05.126]                             if (!grepl(pattern, name)) 
[18:06:05.126]                               next
[18:06:05.126]                             invokeRestart(restart)
[18:06:05.126]                             muffled <- TRUE
[18:06:05.126]                             break
[18:06:05.126]                           }
[18:06:05.126]                         }
[18:06:05.126]                       }
[18:06:05.126]                       invisible(muffled)
[18:06:05.126]                     }
[18:06:05.126]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.126]                   }
[18:06:05.126]                 }
[18:06:05.126]                 else {
[18:06:05.126]                   if (TRUE) {
[18:06:05.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.126]                     {
[18:06:05.126]                       inherits <- base::inherits
[18:06:05.126]                       invokeRestart <- base::invokeRestart
[18:06:05.126]                       is.null <- base::is.null
[18:06:05.126]                       muffled <- FALSE
[18:06:05.126]                       if (inherits(cond, "message")) {
[18:06:05.126]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.126]                         if (muffled) 
[18:06:05.126]                           invokeRestart("muffleMessage")
[18:06:05.126]                       }
[18:06:05.126]                       else if (inherits(cond, "warning")) {
[18:06:05.126]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.126]                         if (muffled) 
[18:06:05.126]                           invokeRestart("muffleWarning")
[18:06:05.126]                       }
[18:06:05.126]                       else if (inherits(cond, "condition")) {
[18:06:05.126]                         if (!is.null(pattern)) {
[18:06:05.126]                           computeRestarts <- base::computeRestarts
[18:06:05.126]                           grepl <- base::grepl
[18:06:05.126]                           restarts <- computeRestarts(cond)
[18:06:05.126]                           for (restart in restarts) {
[18:06:05.126]                             name <- restart$name
[18:06:05.126]                             if (is.null(name)) 
[18:06:05.126]                               next
[18:06:05.126]                             if (!grepl(pattern, name)) 
[18:06:05.126]                               next
[18:06:05.126]                             invokeRestart(restart)
[18:06:05.126]                             muffled <- TRUE
[18:06:05.126]                             break
[18:06:05.126]                           }
[18:06:05.126]                         }
[18:06:05.126]                       }
[18:06:05.126]                       invisible(muffled)
[18:06:05.126]                     }
[18:06:05.126]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.126]                   }
[18:06:05.126]                 }
[18:06:05.126]             }
[18:06:05.126]         }))
[18:06:05.126]     }, error = function(ex) {
[18:06:05.126]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.126]                 ...future.rng), started = ...future.startTime, 
[18:06:05.126]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.126]             version = "1.8"), class = "FutureResult")
[18:06:05.126]     }, finally = {
[18:06:05.126]         if (!identical(...future.workdir, getwd())) 
[18:06:05.126]             setwd(...future.workdir)
[18:06:05.126]         {
[18:06:05.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.126]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.126]             }
[18:06:05.126]             base::options(...future.oldOptions)
[18:06:05.126]             if (.Platform$OS.type == "windows") {
[18:06:05.126]                 old_names <- names(...future.oldEnvVars)
[18:06:05.126]                 envs <- base::Sys.getenv()
[18:06:05.126]                 names <- names(envs)
[18:06:05.126]                 common <- intersect(names, old_names)
[18:06:05.126]                 added <- setdiff(names, old_names)
[18:06:05.126]                 removed <- setdiff(old_names, names)
[18:06:05.126]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.126]                   envs[common]]
[18:06:05.126]                 NAMES <- toupper(changed)
[18:06:05.126]                 args <- list()
[18:06:05.126]                 for (kk in seq_along(NAMES)) {
[18:06:05.126]                   name <- changed[[kk]]
[18:06:05.126]                   NAME <- NAMES[[kk]]
[18:06:05.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.126]                     next
[18:06:05.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.126]                 }
[18:06:05.126]                 NAMES <- toupper(added)
[18:06:05.126]                 for (kk in seq_along(NAMES)) {
[18:06:05.126]                   name <- added[[kk]]
[18:06:05.126]                   NAME <- NAMES[[kk]]
[18:06:05.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.126]                     next
[18:06:05.126]                   args[[name]] <- ""
[18:06:05.126]                 }
[18:06:05.126]                 NAMES <- toupper(removed)
[18:06:05.126]                 for (kk in seq_along(NAMES)) {
[18:06:05.126]                   name <- removed[[kk]]
[18:06:05.126]                   NAME <- NAMES[[kk]]
[18:06:05.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.126]                     next
[18:06:05.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.126]                 }
[18:06:05.126]                 if (length(args) > 0) 
[18:06:05.126]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.126]             }
[18:06:05.126]             else {
[18:06:05.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.126]             }
[18:06:05.126]             {
[18:06:05.126]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.126]                   0L) {
[18:06:05.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.126]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.126]                   base::options(opts)
[18:06:05.126]                 }
[18:06:05.126]                 {
[18:06:05.126]                   {
[18:06:05.126]                     NULL
[18:06:05.126]                     RNGkind("Mersenne-Twister")
[18:06:05.126]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.126]                       inherits = FALSE)
[18:06:05.126]                   }
[18:06:05.126]                   options(future.plan = NULL)
[18:06:05.126]                   if (is.na(NA_character_)) 
[18:06:05.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.126]                     .init = FALSE)
[18:06:05.126]                 }
[18:06:05.126]             }
[18:06:05.126]         }
[18:06:05.126]     })
[18:06:05.126]     if (TRUE) {
[18:06:05.126]         base::sink(type = "output", split = FALSE)
[18:06:05.126]         if (TRUE) {
[18:06:05.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.126]         }
[18:06:05.126]         else {
[18:06:05.126]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.126]         }
[18:06:05.126]         base::close(...future.stdout)
[18:06:05.126]         ...future.stdout <- NULL
[18:06:05.126]     }
[18:06:05.126]     ...future.result$conditions <- ...future.conditions
[18:06:05.126]     ...future.result$finished <- base::Sys.time()
[18:06:05.126]     ...future.result
[18:06:05.126] }
[18:06:05.130] assign_globals() ...
[18:06:05.130] List of 1
[18:06:05.130]  $ kk: int 3
[18:06:05.130]  - attr(*, "where")=List of 1
[18:06:05.130]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:05.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:05.130]  - attr(*, "resolved")= logi FALSE
[18:06:05.130]  - attr(*, "total_size")= num 56
[18:06:05.130]  - attr(*, "already-done")= logi TRUE
[18:06:05.136] - copied ‘kk’ to environment
[18:06:05.136] assign_globals() ... done
[18:06:05.137] plan(): Setting new future strategy stack:
[18:06:05.137] List of future strategies:
[18:06:05.137] 1. sequential:
[18:06:05.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.137]    - tweaked: FALSE
[18:06:05.137]    - call: NULL
[18:06:05.138] plan(): nbrOfWorkers() = 1
[18:06:05.240] plan(): Setting new future strategy stack:
[18:06:05.241] List of future strategies:
[18:06:05.241] 1. sequential:
[18:06:05.241]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.241]    - tweaked: FALSE
[18:06:05.241]    - call: plan(strategy)
[18:06:05.242] plan(): nbrOfWorkers() = 1
[18:06:05.242] SequentialFuture started (and completed)
[18:06:05.243] - Launch lazy future ... done
[18:06:05.243] run() for ‘SequentialFuture’ ... done
[18:06:05.243] resolved() for ‘SequentialFuture’ ...
[18:06:05.244] - state: ‘finished’
[18:06:05.244] - run: TRUE
[18:06:05.244] - result: ‘FutureResult’
[18:06:05.244] resolved() for ‘SequentialFuture’ ... done
[18:06:05.245] Future #3
[18:06:05.245]  length: 0 (resolved future 3)
[18:06:05.245] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[18:06:05.247] resolve() on environment ...
[18:06:05.247]  recursive: 0
[18:06:05.250]  elements: [2] ‘a’, ‘b’
[18:06:05.250]  length: 1 (resolved future 1)
[18:06:05.251]  length: 0 (resolved future 2)
[18:06:05.251] resolve() on environment ... DONE
[18:06:05.252] getGlobalsAndPackages() ...
[18:06:05.252] Searching for globals...
[18:06:05.253] 
[18:06:05.253] Searching for globals ... DONE
[18:06:05.254] - globals: [0] <none>
[18:06:05.254] getGlobalsAndPackages() ... DONE
[18:06:05.254] run() for ‘Future’ ...
[18:06:05.255] - state: ‘created’
[18:06:05.255] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.256]   - Field: ‘label’
[18:06:05.256]   - Field: ‘local’
[18:06:05.257]   - Field: ‘owner’
[18:06:05.257]   - Field: ‘envir’
[18:06:05.257]   - Field: ‘packages’
[18:06:05.258]   - Field: ‘gc’
[18:06:05.258]   - Field: ‘conditions’
[18:06:05.258]   - Field: ‘expr’
[18:06:05.258]   - Field: ‘uuid’
[18:06:05.259]   - Field: ‘seed’
[18:06:05.259]   - Field: ‘version’
[18:06:05.259]   - Field: ‘result’
[18:06:05.259]   - Field: ‘asynchronous’
[18:06:05.260]   - Field: ‘calls’
[18:06:05.260]   - Field: ‘globals’
[18:06:05.260]   - Field: ‘stdout’
[18:06:05.260]   - Field: ‘earlySignal’
[18:06:05.261]   - Field: ‘lazy’
[18:06:05.261]   - Field: ‘state’
[18:06:05.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.261] - Launch lazy future ...
[18:06:05.262] Packages needed by the future expression (n = 0): <none>
[18:06:05.262] Packages needed by future strategies (n = 0): <none>
[18:06:05.263] {
[18:06:05.263]     {
[18:06:05.263]         {
[18:06:05.263]             ...future.startTime <- base::Sys.time()
[18:06:05.263]             {
[18:06:05.263]                 {
[18:06:05.263]                   {
[18:06:05.263]                     base::local({
[18:06:05.263]                       has_future <- base::requireNamespace("future", 
[18:06:05.263]                         quietly = TRUE)
[18:06:05.263]                       if (has_future) {
[18:06:05.263]                         ns <- base::getNamespace("future")
[18:06:05.263]                         version <- ns[[".package"]][["version"]]
[18:06:05.263]                         if (is.null(version)) 
[18:06:05.263]                           version <- utils::packageVersion("future")
[18:06:05.263]                       }
[18:06:05.263]                       else {
[18:06:05.263]                         version <- NULL
[18:06:05.263]                       }
[18:06:05.263]                       if (!has_future || version < "1.8.0") {
[18:06:05.263]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.263]                           "", base::R.version$version.string), 
[18:06:05.263]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.263]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.263]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.263]                             "release", "version")], collapse = " "), 
[18:06:05.263]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.263]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.263]                           info)
[18:06:05.263]                         info <- base::paste(info, collapse = "; ")
[18:06:05.263]                         if (!has_future) {
[18:06:05.263]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.263]                             info)
[18:06:05.263]                         }
[18:06:05.263]                         else {
[18:06:05.263]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.263]                             info, version)
[18:06:05.263]                         }
[18:06:05.263]                         base::stop(msg)
[18:06:05.263]                       }
[18:06:05.263]                     })
[18:06:05.263]                   }
[18:06:05.263]                   ...future.strategy.old <- future::plan("list")
[18:06:05.263]                   options(future.plan = NULL)
[18:06:05.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.263]                 }
[18:06:05.263]                 ...future.workdir <- getwd()
[18:06:05.263]             }
[18:06:05.263]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.263]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.263]         }
[18:06:05.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.263]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.263]             base::names(...future.oldOptions))
[18:06:05.263]     }
[18:06:05.263]     if (FALSE) {
[18:06:05.263]     }
[18:06:05.263]     else {
[18:06:05.263]         if (TRUE) {
[18:06:05.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.263]                 open = "w")
[18:06:05.263]         }
[18:06:05.263]         else {
[18:06:05.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.263]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.263]         }
[18:06:05.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.263]             base::sink(type = "output", split = FALSE)
[18:06:05.263]             base::close(...future.stdout)
[18:06:05.263]         }, add = TRUE)
[18:06:05.263]     }
[18:06:05.263]     ...future.frame <- base::sys.nframe()
[18:06:05.263]     ...future.conditions <- base::list()
[18:06:05.263]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.263]     if (FALSE) {
[18:06:05.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.263]     }
[18:06:05.263]     ...future.result <- base::tryCatch({
[18:06:05.263]         base::withCallingHandlers({
[18:06:05.263]             ...future.value <- base::withVisible(base::local(1))
[18:06:05.263]             future::FutureResult(value = ...future.value$value, 
[18:06:05.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.263]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.263]                     ...future.globalenv.names))
[18:06:05.263]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.263]         }, condition = base::local({
[18:06:05.263]             c <- base::c
[18:06:05.263]             inherits <- base::inherits
[18:06:05.263]             invokeRestart <- base::invokeRestart
[18:06:05.263]             length <- base::length
[18:06:05.263]             list <- base::list
[18:06:05.263]             seq.int <- base::seq.int
[18:06:05.263]             signalCondition <- base::signalCondition
[18:06:05.263]             sys.calls <- base::sys.calls
[18:06:05.263]             `[[` <- base::`[[`
[18:06:05.263]             `+` <- base::`+`
[18:06:05.263]             `<<-` <- base::`<<-`
[18:06:05.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.263]                   3L)]
[18:06:05.263]             }
[18:06:05.263]             function(cond) {
[18:06:05.263]                 is_error <- inherits(cond, "error")
[18:06:05.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.263]                   NULL)
[18:06:05.263]                 if (is_error) {
[18:06:05.263]                   sessionInformation <- function() {
[18:06:05.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.263]                       search = base::search(), system = base::Sys.info())
[18:06:05.263]                   }
[18:06:05.263]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.263]                     cond$call), session = sessionInformation(), 
[18:06:05.263]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.263]                   signalCondition(cond)
[18:06:05.263]                 }
[18:06:05.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.263]                 "immediateCondition"))) {
[18:06:05.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.263]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.263]                   if (TRUE && !signal) {
[18:06:05.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.263]                     {
[18:06:05.263]                       inherits <- base::inherits
[18:06:05.263]                       invokeRestart <- base::invokeRestart
[18:06:05.263]                       is.null <- base::is.null
[18:06:05.263]                       muffled <- FALSE
[18:06:05.263]                       if (inherits(cond, "message")) {
[18:06:05.263]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.263]                         if (muffled) 
[18:06:05.263]                           invokeRestart("muffleMessage")
[18:06:05.263]                       }
[18:06:05.263]                       else if (inherits(cond, "warning")) {
[18:06:05.263]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.263]                         if (muffled) 
[18:06:05.263]                           invokeRestart("muffleWarning")
[18:06:05.263]                       }
[18:06:05.263]                       else if (inherits(cond, "condition")) {
[18:06:05.263]                         if (!is.null(pattern)) {
[18:06:05.263]                           computeRestarts <- base::computeRestarts
[18:06:05.263]                           grepl <- base::grepl
[18:06:05.263]                           restarts <- computeRestarts(cond)
[18:06:05.263]                           for (restart in restarts) {
[18:06:05.263]                             name <- restart$name
[18:06:05.263]                             if (is.null(name)) 
[18:06:05.263]                               next
[18:06:05.263]                             if (!grepl(pattern, name)) 
[18:06:05.263]                               next
[18:06:05.263]                             invokeRestart(restart)
[18:06:05.263]                             muffled <- TRUE
[18:06:05.263]                             break
[18:06:05.263]                           }
[18:06:05.263]                         }
[18:06:05.263]                       }
[18:06:05.263]                       invisible(muffled)
[18:06:05.263]                     }
[18:06:05.263]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.263]                   }
[18:06:05.263]                 }
[18:06:05.263]                 else {
[18:06:05.263]                   if (TRUE) {
[18:06:05.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.263]                     {
[18:06:05.263]                       inherits <- base::inherits
[18:06:05.263]                       invokeRestart <- base::invokeRestart
[18:06:05.263]                       is.null <- base::is.null
[18:06:05.263]                       muffled <- FALSE
[18:06:05.263]                       if (inherits(cond, "message")) {
[18:06:05.263]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.263]                         if (muffled) 
[18:06:05.263]                           invokeRestart("muffleMessage")
[18:06:05.263]                       }
[18:06:05.263]                       else if (inherits(cond, "warning")) {
[18:06:05.263]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.263]                         if (muffled) 
[18:06:05.263]                           invokeRestart("muffleWarning")
[18:06:05.263]                       }
[18:06:05.263]                       else if (inherits(cond, "condition")) {
[18:06:05.263]                         if (!is.null(pattern)) {
[18:06:05.263]                           computeRestarts <- base::computeRestarts
[18:06:05.263]                           grepl <- base::grepl
[18:06:05.263]                           restarts <- computeRestarts(cond)
[18:06:05.263]                           for (restart in restarts) {
[18:06:05.263]                             name <- restart$name
[18:06:05.263]                             if (is.null(name)) 
[18:06:05.263]                               next
[18:06:05.263]                             if (!grepl(pattern, name)) 
[18:06:05.263]                               next
[18:06:05.263]                             invokeRestart(restart)
[18:06:05.263]                             muffled <- TRUE
[18:06:05.263]                             break
[18:06:05.263]                           }
[18:06:05.263]                         }
[18:06:05.263]                       }
[18:06:05.263]                       invisible(muffled)
[18:06:05.263]                     }
[18:06:05.263]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.263]                   }
[18:06:05.263]                 }
[18:06:05.263]             }
[18:06:05.263]         }))
[18:06:05.263]     }, error = function(ex) {
[18:06:05.263]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.263]                 ...future.rng), started = ...future.startTime, 
[18:06:05.263]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.263]             version = "1.8"), class = "FutureResult")
[18:06:05.263]     }, finally = {
[18:06:05.263]         if (!identical(...future.workdir, getwd())) 
[18:06:05.263]             setwd(...future.workdir)
[18:06:05.263]         {
[18:06:05.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.263]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.263]             }
[18:06:05.263]             base::options(...future.oldOptions)
[18:06:05.263]             if (.Platform$OS.type == "windows") {
[18:06:05.263]                 old_names <- names(...future.oldEnvVars)
[18:06:05.263]                 envs <- base::Sys.getenv()
[18:06:05.263]                 names <- names(envs)
[18:06:05.263]                 common <- intersect(names, old_names)
[18:06:05.263]                 added <- setdiff(names, old_names)
[18:06:05.263]                 removed <- setdiff(old_names, names)
[18:06:05.263]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.263]                   envs[common]]
[18:06:05.263]                 NAMES <- toupper(changed)
[18:06:05.263]                 args <- list()
[18:06:05.263]                 for (kk in seq_along(NAMES)) {
[18:06:05.263]                   name <- changed[[kk]]
[18:06:05.263]                   NAME <- NAMES[[kk]]
[18:06:05.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.263]                     next
[18:06:05.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.263]                 }
[18:06:05.263]                 NAMES <- toupper(added)
[18:06:05.263]                 for (kk in seq_along(NAMES)) {
[18:06:05.263]                   name <- added[[kk]]
[18:06:05.263]                   NAME <- NAMES[[kk]]
[18:06:05.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.263]                     next
[18:06:05.263]                   args[[name]] <- ""
[18:06:05.263]                 }
[18:06:05.263]                 NAMES <- toupper(removed)
[18:06:05.263]                 for (kk in seq_along(NAMES)) {
[18:06:05.263]                   name <- removed[[kk]]
[18:06:05.263]                   NAME <- NAMES[[kk]]
[18:06:05.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.263]                     next
[18:06:05.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.263]                 }
[18:06:05.263]                 if (length(args) > 0) 
[18:06:05.263]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.263]             }
[18:06:05.263]             else {
[18:06:05.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.263]             }
[18:06:05.263]             {
[18:06:05.263]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.263]                   0L) {
[18:06:05.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.263]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.263]                   base::options(opts)
[18:06:05.263]                 }
[18:06:05.263]                 {
[18:06:05.263]                   {
[18:06:05.263]                     NULL
[18:06:05.263]                     RNGkind("Mersenne-Twister")
[18:06:05.263]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.263]                       inherits = FALSE)
[18:06:05.263]                   }
[18:06:05.263]                   options(future.plan = NULL)
[18:06:05.263]                   if (is.na(NA_character_)) 
[18:06:05.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.263]                     .init = FALSE)
[18:06:05.263]                 }
[18:06:05.263]             }
[18:06:05.263]         }
[18:06:05.263]     })
[18:06:05.263]     if (TRUE) {
[18:06:05.263]         base::sink(type = "output", split = FALSE)
[18:06:05.263]         if (TRUE) {
[18:06:05.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.263]         }
[18:06:05.263]         else {
[18:06:05.263]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.263]         }
[18:06:05.263]         base::close(...future.stdout)
[18:06:05.263]         ...future.stdout <- NULL
[18:06:05.263]     }
[18:06:05.263]     ...future.result$conditions <- ...future.conditions
[18:06:05.263]     ...future.result$finished <- base::Sys.time()
[18:06:05.263]     ...future.result
[18:06:05.263] }
[18:06:05.268] plan(): Setting new future strategy stack:
[18:06:05.268] List of future strategies:
[18:06:05.268] 1. sequential:
[18:06:05.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.268]    - tweaked: FALSE
[18:06:05.268]    - call: NULL
[18:06:05.269] plan(): nbrOfWorkers() = 1
[18:06:05.271] plan(): Setting new future strategy stack:
[18:06:05.271] List of future strategies:
[18:06:05.271] 1. sequential:
[18:06:05.271]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.271]    - tweaked: FALSE
[18:06:05.271]    - call: plan(strategy)
[18:06:05.272] plan(): nbrOfWorkers() = 1
[18:06:05.273] SequentialFuture started (and completed)
[18:06:05.273] - Launch lazy future ... done
[18:06:05.274] run() for ‘SequentialFuture’ ... done
[18:06:05.274] getGlobalsAndPackages() ...
[18:06:05.274] Searching for globals...
[18:06:05.275] 
[18:06:05.276] Searching for globals ... DONE
[18:06:05.276] - globals: [0] <none>
[18:06:05.276] getGlobalsAndPackages() ... DONE
[18:06:05.277] run() for ‘Future’ ...
[18:06:05.277] - state: ‘created’
[18:06:05.277] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.278] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.279]   - Field: ‘label’
[18:06:05.282]   - Field: ‘local’
[18:06:05.282]   - Field: ‘owner’
[18:06:05.283]   - Field: ‘envir’
[18:06:05.283]   - Field: ‘packages’
[18:06:05.283]   - Field: ‘gc’
[18:06:05.284]   - Field: ‘conditions’
[18:06:05.284]   - Field: ‘expr’
[18:06:05.284]   - Field: ‘uuid’
[18:06:05.284]   - Field: ‘seed’
[18:06:05.285]   - Field: ‘version’
[18:06:05.285]   - Field: ‘result’
[18:06:05.285]   - Field: ‘asynchronous’
[18:06:05.286]   - Field: ‘calls’
[18:06:05.286]   - Field: ‘globals’
[18:06:05.286]   - Field: ‘stdout’
[18:06:05.286]   - Field: ‘earlySignal’
[18:06:05.287]   - Field: ‘lazy’
[18:06:05.287]   - Field: ‘state’
[18:06:05.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.287] - Launch lazy future ...
[18:06:05.288] Packages needed by the future expression (n = 0): <none>
[18:06:05.288] Packages needed by future strategies (n = 0): <none>
[18:06:05.289] {
[18:06:05.289]     {
[18:06:05.289]         {
[18:06:05.289]             ...future.startTime <- base::Sys.time()
[18:06:05.289]             {
[18:06:05.289]                 {
[18:06:05.289]                   {
[18:06:05.289]                     base::local({
[18:06:05.289]                       has_future <- base::requireNamespace("future", 
[18:06:05.289]                         quietly = TRUE)
[18:06:05.289]                       if (has_future) {
[18:06:05.289]                         ns <- base::getNamespace("future")
[18:06:05.289]                         version <- ns[[".package"]][["version"]]
[18:06:05.289]                         if (is.null(version)) 
[18:06:05.289]                           version <- utils::packageVersion("future")
[18:06:05.289]                       }
[18:06:05.289]                       else {
[18:06:05.289]                         version <- NULL
[18:06:05.289]                       }
[18:06:05.289]                       if (!has_future || version < "1.8.0") {
[18:06:05.289]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.289]                           "", base::R.version$version.string), 
[18:06:05.289]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.289]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.289]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.289]                             "release", "version")], collapse = " "), 
[18:06:05.289]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.289]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.289]                           info)
[18:06:05.289]                         info <- base::paste(info, collapse = "; ")
[18:06:05.289]                         if (!has_future) {
[18:06:05.289]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.289]                             info)
[18:06:05.289]                         }
[18:06:05.289]                         else {
[18:06:05.289]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.289]                             info, version)
[18:06:05.289]                         }
[18:06:05.289]                         base::stop(msg)
[18:06:05.289]                       }
[18:06:05.289]                     })
[18:06:05.289]                   }
[18:06:05.289]                   ...future.strategy.old <- future::plan("list")
[18:06:05.289]                   options(future.plan = NULL)
[18:06:05.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.289]                 }
[18:06:05.289]                 ...future.workdir <- getwd()
[18:06:05.289]             }
[18:06:05.289]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.289]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.289]         }
[18:06:05.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.289]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.289]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.289]             base::names(...future.oldOptions))
[18:06:05.289]     }
[18:06:05.289]     if (FALSE) {
[18:06:05.289]     }
[18:06:05.289]     else {
[18:06:05.289]         if (TRUE) {
[18:06:05.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.289]                 open = "w")
[18:06:05.289]         }
[18:06:05.289]         else {
[18:06:05.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.289]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.289]         }
[18:06:05.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.289]             base::sink(type = "output", split = FALSE)
[18:06:05.289]             base::close(...future.stdout)
[18:06:05.289]         }, add = TRUE)
[18:06:05.289]     }
[18:06:05.289]     ...future.frame <- base::sys.nframe()
[18:06:05.289]     ...future.conditions <- base::list()
[18:06:05.289]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.289]     if (FALSE) {
[18:06:05.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.289]     }
[18:06:05.289]     ...future.result <- base::tryCatch({
[18:06:05.289]         base::withCallingHandlers({
[18:06:05.289]             ...future.value <- base::withVisible(base::local(2))
[18:06:05.289]             future::FutureResult(value = ...future.value$value, 
[18:06:05.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.289]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.289]                     ...future.globalenv.names))
[18:06:05.289]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.289]         }, condition = base::local({
[18:06:05.289]             c <- base::c
[18:06:05.289]             inherits <- base::inherits
[18:06:05.289]             invokeRestart <- base::invokeRestart
[18:06:05.289]             length <- base::length
[18:06:05.289]             list <- base::list
[18:06:05.289]             seq.int <- base::seq.int
[18:06:05.289]             signalCondition <- base::signalCondition
[18:06:05.289]             sys.calls <- base::sys.calls
[18:06:05.289]             `[[` <- base::`[[`
[18:06:05.289]             `+` <- base::`+`
[18:06:05.289]             `<<-` <- base::`<<-`
[18:06:05.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.289]                   3L)]
[18:06:05.289]             }
[18:06:05.289]             function(cond) {
[18:06:05.289]                 is_error <- inherits(cond, "error")
[18:06:05.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.289]                   NULL)
[18:06:05.289]                 if (is_error) {
[18:06:05.289]                   sessionInformation <- function() {
[18:06:05.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.289]                       search = base::search(), system = base::Sys.info())
[18:06:05.289]                   }
[18:06:05.289]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.289]                     cond$call), session = sessionInformation(), 
[18:06:05.289]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.289]                   signalCondition(cond)
[18:06:05.289]                 }
[18:06:05.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.289]                 "immediateCondition"))) {
[18:06:05.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.289]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.289]                   if (TRUE && !signal) {
[18:06:05.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.289]                     {
[18:06:05.289]                       inherits <- base::inherits
[18:06:05.289]                       invokeRestart <- base::invokeRestart
[18:06:05.289]                       is.null <- base::is.null
[18:06:05.289]                       muffled <- FALSE
[18:06:05.289]                       if (inherits(cond, "message")) {
[18:06:05.289]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.289]                         if (muffled) 
[18:06:05.289]                           invokeRestart("muffleMessage")
[18:06:05.289]                       }
[18:06:05.289]                       else if (inherits(cond, "warning")) {
[18:06:05.289]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.289]                         if (muffled) 
[18:06:05.289]                           invokeRestart("muffleWarning")
[18:06:05.289]                       }
[18:06:05.289]                       else if (inherits(cond, "condition")) {
[18:06:05.289]                         if (!is.null(pattern)) {
[18:06:05.289]                           computeRestarts <- base::computeRestarts
[18:06:05.289]                           grepl <- base::grepl
[18:06:05.289]                           restarts <- computeRestarts(cond)
[18:06:05.289]                           for (restart in restarts) {
[18:06:05.289]                             name <- restart$name
[18:06:05.289]                             if (is.null(name)) 
[18:06:05.289]                               next
[18:06:05.289]                             if (!grepl(pattern, name)) 
[18:06:05.289]                               next
[18:06:05.289]                             invokeRestart(restart)
[18:06:05.289]                             muffled <- TRUE
[18:06:05.289]                             break
[18:06:05.289]                           }
[18:06:05.289]                         }
[18:06:05.289]                       }
[18:06:05.289]                       invisible(muffled)
[18:06:05.289]                     }
[18:06:05.289]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.289]                   }
[18:06:05.289]                 }
[18:06:05.289]                 else {
[18:06:05.289]                   if (TRUE) {
[18:06:05.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.289]                     {
[18:06:05.289]                       inherits <- base::inherits
[18:06:05.289]                       invokeRestart <- base::invokeRestart
[18:06:05.289]                       is.null <- base::is.null
[18:06:05.289]                       muffled <- FALSE
[18:06:05.289]                       if (inherits(cond, "message")) {
[18:06:05.289]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.289]                         if (muffled) 
[18:06:05.289]                           invokeRestart("muffleMessage")
[18:06:05.289]                       }
[18:06:05.289]                       else if (inherits(cond, "warning")) {
[18:06:05.289]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.289]                         if (muffled) 
[18:06:05.289]                           invokeRestart("muffleWarning")
[18:06:05.289]                       }
[18:06:05.289]                       else if (inherits(cond, "condition")) {
[18:06:05.289]                         if (!is.null(pattern)) {
[18:06:05.289]                           computeRestarts <- base::computeRestarts
[18:06:05.289]                           grepl <- base::grepl
[18:06:05.289]                           restarts <- computeRestarts(cond)
[18:06:05.289]                           for (restart in restarts) {
[18:06:05.289]                             name <- restart$name
[18:06:05.289]                             if (is.null(name)) 
[18:06:05.289]                               next
[18:06:05.289]                             if (!grepl(pattern, name)) 
[18:06:05.289]                               next
[18:06:05.289]                             invokeRestart(restart)
[18:06:05.289]                             muffled <- TRUE
[18:06:05.289]                             break
[18:06:05.289]                           }
[18:06:05.289]                         }
[18:06:05.289]                       }
[18:06:05.289]                       invisible(muffled)
[18:06:05.289]                     }
[18:06:05.289]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.289]                   }
[18:06:05.289]                 }
[18:06:05.289]             }
[18:06:05.289]         }))
[18:06:05.289]     }, error = function(ex) {
[18:06:05.289]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.289]                 ...future.rng), started = ...future.startTime, 
[18:06:05.289]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.289]             version = "1.8"), class = "FutureResult")
[18:06:05.289]     }, finally = {
[18:06:05.289]         if (!identical(...future.workdir, getwd())) 
[18:06:05.289]             setwd(...future.workdir)
[18:06:05.289]         {
[18:06:05.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.289]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.289]             }
[18:06:05.289]             base::options(...future.oldOptions)
[18:06:05.289]             if (.Platform$OS.type == "windows") {
[18:06:05.289]                 old_names <- names(...future.oldEnvVars)
[18:06:05.289]                 envs <- base::Sys.getenv()
[18:06:05.289]                 names <- names(envs)
[18:06:05.289]                 common <- intersect(names, old_names)
[18:06:05.289]                 added <- setdiff(names, old_names)
[18:06:05.289]                 removed <- setdiff(old_names, names)
[18:06:05.289]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.289]                   envs[common]]
[18:06:05.289]                 NAMES <- toupper(changed)
[18:06:05.289]                 args <- list()
[18:06:05.289]                 for (kk in seq_along(NAMES)) {
[18:06:05.289]                   name <- changed[[kk]]
[18:06:05.289]                   NAME <- NAMES[[kk]]
[18:06:05.289]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.289]                     next
[18:06:05.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.289]                 }
[18:06:05.289]                 NAMES <- toupper(added)
[18:06:05.289]                 for (kk in seq_along(NAMES)) {
[18:06:05.289]                   name <- added[[kk]]
[18:06:05.289]                   NAME <- NAMES[[kk]]
[18:06:05.289]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.289]                     next
[18:06:05.289]                   args[[name]] <- ""
[18:06:05.289]                 }
[18:06:05.289]                 NAMES <- toupper(removed)
[18:06:05.289]                 for (kk in seq_along(NAMES)) {
[18:06:05.289]                   name <- removed[[kk]]
[18:06:05.289]                   NAME <- NAMES[[kk]]
[18:06:05.289]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.289]                     next
[18:06:05.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.289]                 }
[18:06:05.289]                 if (length(args) > 0) 
[18:06:05.289]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.289]             }
[18:06:05.289]             else {
[18:06:05.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.289]             }
[18:06:05.289]             {
[18:06:05.289]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.289]                   0L) {
[18:06:05.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.289]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.289]                   base::options(opts)
[18:06:05.289]                 }
[18:06:05.289]                 {
[18:06:05.289]                   {
[18:06:05.289]                     NULL
[18:06:05.289]                     RNGkind("Mersenne-Twister")
[18:06:05.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.289]                       inherits = FALSE)
[18:06:05.289]                   }
[18:06:05.289]                   options(future.plan = NULL)
[18:06:05.289]                   if (is.na(NA_character_)) 
[18:06:05.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.289]                     .init = FALSE)
[18:06:05.289]                 }
[18:06:05.289]             }
[18:06:05.289]         }
[18:06:05.289]     })
[18:06:05.289]     if (TRUE) {
[18:06:05.289]         base::sink(type = "output", split = FALSE)
[18:06:05.289]         if (TRUE) {
[18:06:05.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.289]         }
[18:06:05.289]         else {
[18:06:05.289]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.289]         }
[18:06:05.289]         base::close(...future.stdout)
[18:06:05.289]         ...future.stdout <- NULL
[18:06:05.289]     }
[18:06:05.289]     ...future.result$conditions <- ...future.conditions
[18:06:05.289]     ...future.result$finished <- base::Sys.time()
[18:06:05.289]     ...future.result
[18:06:05.289] }
[18:06:05.295] plan(): Setting new future strategy stack:
[18:06:05.295] List of future strategies:
[18:06:05.295] 1. sequential:
[18:06:05.295]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.295]    - tweaked: FALSE
[18:06:05.295]    - call: NULL
[18:06:05.296] plan(): nbrOfWorkers() = 1
[18:06:05.298] plan(): Setting new future strategy stack:
[18:06:05.299] List of future strategies:
[18:06:05.299] 1. sequential:
[18:06:05.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.299]    - tweaked: FALSE
[18:06:05.299]    - call: plan(strategy)
[18:06:05.300] plan(): nbrOfWorkers() = 1
[18:06:05.300] SequentialFuture started (and completed)
[18:06:05.301] - Launch lazy future ... done
[18:06:05.301] run() for ‘SequentialFuture’ ... done
[18:06:05.302] resolve() on environment ...
[18:06:05.303]  recursive: 0
[18:06:05.304]  elements: [3] ‘a’, ‘b’, ‘c’
[18:06:05.305] resolved() for ‘SequentialFuture’ ...
[18:06:05.305] - state: ‘finished’
[18:06:05.305] - run: TRUE
[18:06:05.305] - result: ‘FutureResult’
[18:06:05.305] resolved() for ‘SequentialFuture’ ... done
[18:06:05.306] Future #1
[18:06:05.306]  length: 2 (resolved future 1)
[18:06:05.306] resolved() for ‘SequentialFuture’ ...
[18:06:05.307] - state: ‘finished’
[18:06:05.307] - run: TRUE
[18:06:05.307] - result: ‘FutureResult’
[18:06:05.307] resolved() for ‘SequentialFuture’ ... done
[18:06:05.307] Future #2
[18:06:05.308]  length: 1 (resolved future 2)
[18:06:05.308]  length: 0 (resolved future 3)
[18:06:05.309] resolve() on environment ... DONE
[18:06:05.309] resolved() for ‘SequentialFuture’ ...
[18:06:05.309] - state: ‘finished’
[18:06:05.309] - run: TRUE
[18:06:05.309] - result: ‘FutureResult’
[18:06:05.310] resolved() for ‘SequentialFuture’ ... done
[18:06:05.310] resolved() for ‘SequentialFuture’ ...
[18:06:05.310] - state: ‘finished’
[18:06:05.310] - run: TRUE
[18:06:05.311] - result: ‘FutureResult’
[18:06:05.311] resolved() for ‘SequentialFuture’ ... done
[18:06:05.313] getGlobalsAndPackages() ...
[18:06:05.314] Searching for globals...
[18:06:05.315] - globals found: [1] ‘{’
[18:06:05.315] Searching for globals ... DONE
[18:06:05.315] Resolving globals: FALSE
[18:06:05.316] 
[18:06:05.316] 
[18:06:05.316] getGlobalsAndPackages() ... DONE
[18:06:05.317] run() for ‘Future’ ...
[18:06:05.317] - state: ‘created’
[18:06:05.317] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.318] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.318]   - Field: ‘label’
[18:06:05.319]   - Field: ‘local’
[18:06:05.319]   - Field: ‘owner’
[18:06:05.319]   - Field: ‘envir’
[18:06:05.319]   - Field: ‘packages’
[18:06:05.319]   - Field: ‘gc’
[18:06:05.320]   - Field: ‘conditions’
[18:06:05.320]   - Field: ‘expr’
[18:06:05.320]   - Field: ‘uuid’
[18:06:05.320]   - Field: ‘seed’
[18:06:05.320]   - Field: ‘version’
[18:06:05.321]   - Field: ‘result’
[18:06:05.321]   - Field: ‘asynchronous’
[18:06:05.321]   - Field: ‘calls’
[18:06:05.321]   - Field: ‘globals’
[18:06:05.321]   - Field: ‘stdout’
[18:06:05.322]   - Field: ‘earlySignal’
[18:06:05.322]   - Field: ‘lazy’
[18:06:05.322]   - Field: ‘state’
[18:06:05.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.322] - Launch lazy future ...
[18:06:05.323] Packages needed by the future expression (n = 0): <none>
[18:06:05.323] Packages needed by future strategies (n = 0): <none>
[18:06:05.324] {
[18:06:05.324]     {
[18:06:05.324]         {
[18:06:05.324]             ...future.startTime <- base::Sys.time()
[18:06:05.324]             {
[18:06:05.324]                 {
[18:06:05.324]                   {
[18:06:05.324]                     base::local({
[18:06:05.324]                       has_future <- base::requireNamespace("future", 
[18:06:05.324]                         quietly = TRUE)
[18:06:05.324]                       if (has_future) {
[18:06:05.324]                         ns <- base::getNamespace("future")
[18:06:05.324]                         version <- ns[[".package"]][["version"]]
[18:06:05.324]                         if (is.null(version)) 
[18:06:05.324]                           version <- utils::packageVersion("future")
[18:06:05.324]                       }
[18:06:05.324]                       else {
[18:06:05.324]                         version <- NULL
[18:06:05.324]                       }
[18:06:05.324]                       if (!has_future || version < "1.8.0") {
[18:06:05.324]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.324]                           "", base::R.version$version.string), 
[18:06:05.324]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.324]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.324]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.324]                             "release", "version")], collapse = " "), 
[18:06:05.324]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.324]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.324]                           info)
[18:06:05.324]                         info <- base::paste(info, collapse = "; ")
[18:06:05.324]                         if (!has_future) {
[18:06:05.324]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.324]                             info)
[18:06:05.324]                         }
[18:06:05.324]                         else {
[18:06:05.324]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.324]                             info, version)
[18:06:05.324]                         }
[18:06:05.324]                         base::stop(msg)
[18:06:05.324]                       }
[18:06:05.324]                     })
[18:06:05.324]                   }
[18:06:05.324]                   ...future.strategy.old <- future::plan("list")
[18:06:05.324]                   options(future.plan = NULL)
[18:06:05.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.324]                 }
[18:06:05.324]                 ...future.workdir <- getwd()
[18:06:05.324]             }
[18:06:05.324]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.324]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.324]         }
[18:06:05.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.324]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.324]             base::names(...future.oldOptions))
[18:06:05.324]     }
[18:06:05.324]     if (FALSE) {
[18:06:05.324]     }
[18:06:05.324]     else {
[18:06:05.324]         if (TRUE) {
[18:06:05.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.324]                 open = "w")
[18:06:05.324]         }
[18:06:05.324]         else {
[18:06:05.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.324]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.324]         }
[18:06:05.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.324]             base::sink(type = "output", split = FALSE)
[18:06:05.324]             base::close(...future.stdout)
[18:06:05.324]         }, add = TRUE)
[18:06:05.324]     }
[18:06:05.324]     ...future.frame <- base::sys.nframe()
[18:06:05.324]     ...future.conditions <- base::list()
[18:06:05.324]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.324]     if (FALSE) {
[18:06:05.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.324]     }
[18:06:05.324]     ...future.result <- base::tryCatch({
[18:06:05.324]         base::withCallingHandlers({
[18:06:05.324]             ...future.value <- base::withVisible(base::local({
[18:06:05.324]                 1
[18:06:05.324]             }))
[18:06:05.324]             future::FutureResult(value = ...future.value$value, 
[18:06:05.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.324]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.324]                     ...future.globalenv.names))
[18:06:05.324]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.324]         }, condition = base::local({
[18:06:05.324]             c <- base::c
[18:06:05.324]             inherits <- base::inherits
[18:06:05.324]             invokeRestart <- base::invokeRestart
[18:06:05.324]             length <- base::length
[18:06:05.324]             list <- base::list
[18:06:05.324]             seq.int <- base::seq.int
[18:06:05.324]             signalCondition <- base::signalCondition
[18:06:05.324]             sys.calls <- base::sys.calls
[18:06:05.324]             `[[` <- base::`[[`
[18:06:05.324]             `+` <- base::`+`
[18:06:05.324]             `<<-` <- base::`<<-`
[18:06:05.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.324]                   3L)]
[18:06:05.324]             }
[18:06:05.324]             function(cond) {
[18:06:05.324]                 is_error <- inherits(cond, "error")
[18:06:05.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.324]                   NULL)
[18:06:05.324]                 if (is_error) {
[18:06:05.324]                   sessionInformation <- function() {
[18:06:05.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.324]                       search = base::search(), system = base::Sys.info())
[18:06:05.324]                   }
[18:06:05.324]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.324]                     cond$call), session = sessionInformation(), 
[18:06:05.324]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.324]                   signalCondition(cond)
[18:06:05.324]                 }
[18:06:05.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.324]                 "immediateCondition"))) {
[18:06:05.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.324]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.324]                   if (TRUE && !signal) {
[18:06:05.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.324]                     {
[18:06:05.324]                       inherits <- base::inherits
[18:06:05.324]                       invokeRestart <- base::invokeRestart
[18:06:05.324]                       is.null <- base::is.null
[18:06:05.324]                       muffled <- FALSE
[18:06:05.324]                       if (inherits(cond, "message")) {
[18:06:05.324]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.324]                         if (muffled) 
[18:06:05.324]                           invokeRestart("muffleMessage")
[18:06:05.324]                       }
[18:06:05.324]                       else if (inherits(cond, "warning")) {
[18:06:05.324]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.324]                         if (muffled) 
[18:06:05.324]                           invokeRestart("muffleWarning")
[18:06:05.324]                       }
[18:06:05.324]                       else if (inherits(cond, "condition")) {
[18:06:05.324]                         if (!is.null(pattern)) {
[18:06:05.324]                           computeRestarts <- base::computeRestarts
[18:06:05.324]                           grepl <- base::grepl
[18:06:05.324]                           restarts <- computeRestarts(cond)
[18:06:05.324]                           for (restart in restarts) {
[18:06:05.324]                             name <- restart$name
[18:06:05.324]                             if (is.null(name)) 
[18:06:05.324]                               next
[18:06:05.324]                             if (!grepl(pattern, name)) 
[18:06:05.324]                               next
[18:06:05.324]                             invokeRestart(restart)
[18:06:05.324]                             muffled <- TRUE
[18:06:05.324]                             break
[18:06:05.324]                           }
[18:06:05.324]                         }
[18:06:05.324]                       }
[18:06:05.324]                       invisible(muffled)
[18:06:05.324]                     }
[18:06:05.324]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.324]                   }
[18:06:05.324]                 }
[18:06:05.324]                 else {
[18:06:05.324]                   if (TRUE) {
[18:06:05.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.324]                     {
[18:06:05.324]                       inherits <- base::inherits
[18:06:05.324]                       invokeRestart <- base::invokeRestart
[18:06:05.324]                       is.null <- base::is.null
[18:06:05.324]                       muffled <- FALSE
[18:06:05.324]                       if (inherits(cond, "message")) {
[18:06:05.324]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.324]                         if (muffled) 
[18:06:05.324]                           invokeRestart("muffleMessage")
[18:06:05.324]                       }
[18:06:05.324]                       else if (inherits(cond, "warning")) {
[18:06:05.324]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.324]                         if (muffled) 
[18:06:05.324]                           invokeRestart("muffleWarning")
[18:06:05.324]                       }
[18:06:05.324]                       else if (inherits(cond, "condition")) {
[18:06:05.324]                         if (!is.null(pattern)) {
[18:06:05.324]                           computeRestarts <- base::computeRestarts
[18:06:05.324]                           grepl <- base::grepl
[18:06:05.324]                           restarts <- computeRestarts(cond)
[18:06:05.324]                           for (restart in restarts) {
[18:06:05.324]                             name <- restart$name
[18:06:05.324]                             if (is.null(name)) 
[18:06:05.324]                               next
[18:06:05.324]                             if (!grepl(pattern, name)) 
[18:06:05.324]                               next
[18:06:05.324]                             invokeRestart(restart)
[18:06:05.324]                             muffled <- TRUE
[18:06:05.324]                             break
[18:06:05.324]                           }
[18:06:05.324]                         }
[18:06:05.324]                       }
[18:06:05.324]                       invisible(muffled)
[18:06:05.324]                     }
[18:06:05.324]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.324]                   }
[18:06:05.324]                 }
[18:06:05.324]             }
[18:06:05.324]         }))
[18:06:05.324]     }, error = function(ex) {
[18:06:05.324]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.324]                 ...future.rng), started = ...future.startTime, 
[18:06:05.324]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.324]             version = "1.8"), class = "FutureResult")
[18:06:05.324]     }, finally = {
[18:06:05.324]         if (!identical(...future.workdir, getwd())) 
[18:06:05.324]             setwd(...future.workdir)
[18:06:05.324]         {
[18:06:05.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.324]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.324]             }
[18:06:05.324]             base::options(...future.oldOptions)
[18:06:05.324]             if (.Platform$OS.type == "windows") {
[18:06:05.324]                 old_names <- names(...future.oldEnvVars)
[18:06:05.324]                 envs <- base::Sys.getenv()
[18:06:05.324]                 names <- names(envs)
[18:06:05.324]                 common <- intersect(names, old_names)
[18:06:05.324]                 added <- setdiff(names, old_names)
[18:06:05.324]                 removed <- setdiff(old_names, names)
[18:06:05.324]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.324]                   envs[common]]
[18:06:05.324]                 NAMES <- toupper(changed)
[18:06:05.324]                 args <- list()
[18:06:05.324]                 for (kk in seq_along(NAMES)) {
[18:06:05.324]                   name <- changed[[kk]]
[18:06:05.324]                   NAME <- NAMES[[kk]]
[18:06:05.324]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.324]                     next
[18:06:05.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.324]                 }
[18:06:05.324]                 NAMES <- toupper(added)
[18:06:05.324]                 for (kk in seq_along(NAMES)) {
[18:06:05.324]                   name <- added[[kk]]
[18:06:05.324]                   NAME <- NAMES[[kk]]
[18:06:05.324]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.324]                     next
[18:06:05.324]                   args[[name]] <- ""
[18:06:05.324]                 }
[18:06:05.324]                 NAMES <- toupper(removed)
[18:06:05.324]                 for (kk in seq_along(NAMES)) {
[18:06:05.324]                   name <- removed[[kk]]
[18:06:05.324]                   NAME <- NAMES[[kk]]
[18:06:05.324]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.324]                     next
[18:06:05.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.324]                 }
[18:06:05.324]                 if (length(args) > 0) 
[18:06:05.324]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.324]             }
[18:06:05.324]             else {
[18:06:05.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.324]             }
[18:06:05.324]             {
[18:06:05.324]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.324]                   0L) {
[18:06:05.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.324]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.324]                   base::options(opts)
[18:06:05.324]                 }
[18:06:05.324]                 {
[18:06:05.324]                   {
[18:06:05.324]                     NULL
[18:06:05.324]                     RNGkind("Mersenne-Twister")
[18:06:05.324]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.324]                       inherits = FALSE)
[18:06:05.324]                   }
[18:06:05.324]                   options(future.plan = NULL)
[18:06:05.324]                   if (is.na(NA_character_)) 
[18:06:05.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.324]                     .init = FALSE)
[18:06:05.324]                 }
[18:06:05.324]             }
[18:06:05.324]         }
[18:06:05.324]     })
[18:06:05.324]     if (TRUE) {
[18:06:05.324]         base::sink(type = "output", split = FALSE)
[18:06:05.324]         if (TRUE) {
[18:06:05.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.324]         }
[18:06:05.324]         else {
[18:06:05.324]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.324]         }
[18:06:05.324]         base::close(...future.stdout)
[18:06:05.324]         ...future.stdout <- NULL
[18:06:05.324]     }
[18:06:05.324]     ...future.result$conditions <- ...future.conditions
[18:06:05.324]     ...future.result$finished <- base::Sys.time()
[18:06:05.324]     ...future.result
[18:06:05.324] }
[18:06:05.328] plan(): Setting new future strategy stack:
[18:06:05.328] List of future strategies:
[18:06:05.328] 1. sequential:
[18:06:05.328]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.328]    - tweaked: FALSE
[18:06:05.328]    - call: NULL
[18:06:05.329] plan(): nbrOfWorkers() = 1
[18:06:05.331] plan(): Setting new future strategy stack:
[18:06:05.331] List of future strategies:
[18:06:05.331] 1. sequential:
[18:06:05.331]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.331]    - tweaked: FALSE
[18:06:05.331]    - call: plan(strategy)
[18:06:05.332] plan(): nbrOfWorkers() = 1
[18:06:05.332] SequentialFuture started (and completed)
[18:06:05.333] - Launch lazy future ... done
[18:06:05.333] run() for ‘SequentialFuture’ ... done
[18:06:05.334] getGlobalsAndPackages() ...
[18:06:05.334] Searching for globals...
[18:06:05.335] - globals found: [1] ‘{’
[18:06:05.335] Searching for globals ... DONE
[18:06:05.336] Resolving globals: FALSE
[18:06:05.336] 
[18:06:05.336] 
[18:06:05.337] getGlobalsAndPackages() ... DONE
[18:06:05.337] run() for ‘Future’ ...
[18:06:05.337] - state: ‘created’
[18:06:05.338] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.338] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.339] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.339]   - Field: ‘label’
[18:06:05.339]   - Field: ‘local’
[18:06:05.339]   - Field: ‘owner’
[18:06:05.339]   - Field: ‘envir’
[18:06:05.340]   - Field: ‘packages’
[18:06:05.340]   - Field: ‘gc’
[18:06:05.340]   - Field: ‘conditions’
[18:06:05.340]   - Field: ‘expr’
[18:06:05.340]   - Field: ‘uuid’
[18:06:05.341]   - Field: ‘seed’
[18:06:05.341]   - Field: ‘version’
[18:06:05.341]   - Field: ‘result’
[18:06:05.342]   - Field: ‘asynchronous’
[18:06:05.342]   - Field: ‘calls’
[18:06:05.342]   - Field: ‘globals’
[18:06:05.344]   - Field: ‘stdout’
[18:06:05.344]   - Field: ‘earlySignal’
[18:06:05.345]   - Field: ‘lazy’
[18:06:05.347]   - Field: ‘state’
[18:06:05.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.347] - Launch lazy future ...
[18:06:05.348] Packages needed by the future expression (n = 0): <none>
[18:06:05.348] Packages needed by future strategies (n = 0): <none>
[18:06:05.349] {
[18:06:05.349]     {
[18:06:05.349]         {
[18:06:05.349]             ...future.startTime <- base::Sys.time()
[18:06:05.349]             {
[18:06:05.349]                 {
[18:06:05.349]                   {
[18:06:05.349]                     base::local({
[18:06:05.349]                       has_future <- base::requireNamespace("future", 
[18:06:05.349]                         quietly = TRUE)
[18:06:05.349]                       if (has_future) {
[18:06:05.349]                         ns <- base::getNamespace("future")
[18:06:05.349]                         version <- ns[[".package"]][["version"]]
[18:06:05.349]                         if (is.null(version)) 
[18:06:05.349]                           version <- utils::packageVersion("future")
[18:06:05.349]                       }
[18:06:05.349]                       else {
[18:06:05.349]                         version <- NULL
[18:06:05.349]                       }
[18:06:05.349]                       if (!has_future || version < "1.8.0") {
[18:06:05.349]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.349]                           "", base::R.version$version.string), 
[18:06:05.349]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.349]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.349]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.349]                             "release", "version")], collapse = " "), 
[18:06:05.349]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.349]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.349]                           info)
[18:06:05.349]                         info <- base::paste(info, collapse = "; ")
[18:06:05.349]                         if (!has_future) {
[18:06:05.349]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.349]                             info)
[18:06:05.349]                         }
[18:06:05.349]                         else {
[18:06:05.349]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.349]                             info, version)
[18:06:05.349]                         }
[18:06:05.349]                         base::stop(msg)
[18:06:05.349]                       }
[18:06:05.349]                     })
[18:06:05.349]                   }
[18:06:05.349]                   ...future.strategy.old <- future::plan("list")
[18:06:05.349]                   options(future.plan = NULL)
[18:06:05.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.349]                 }
[18:06:05.349]                 ...future.workdir <- getwd()
[18:06:05.349]             }
[18:06:05.349]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.349]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.349]         }
[18:06:05.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.349]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.349]             base::names(...future.oldOptions))
[18:06:05.349]     }
[18:06:05.349]     if (FALSE) {
[18:06:05.349]     }
[18:06:05.349]     else {
[18:06:05.349]         if (TRUE) {
[18:06:05.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.349]                 open = "w")
[18:06:05.349]         }
[18:06:05.349]         else {
[18:06:05.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.349]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.349]         }
[18:06:05.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.349]             base::sink(type = "output", split = FALSE)
[18:06:05.349]             base::close(...future.stdout)
[18:06:05.349]         }, add = TRUE)
[18:06:05.349]     }
[18:06:05.349]     ...future.frame <- base::sys.nframe()
[18:06:05.349]     ...future.conditions <- base::list()
[18:06:05.349]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.349]     if (FALSE) {
[18:06:05.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.349]     }
[18:06:05.349]     ...future.result <- base::tryCatch({
[18:06:05.349]         base::withCallingHandlers({
[18:06:05.349]             ...future.value <- base::withVisible(base::local({
[18:06:05.349]                 2
[18:06:05.349]             }))
[18:06:05.349]             future::FutureResult(value = ...future.value$value, 
[18:06:05.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.349]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.349]                     ...future.globalenv.names))
[18:06:05.349]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.349]         }, condition = base::local({
[18:06:05.349]             c <- base::c
[18:06:05.349]             inherits <- base::inherits
[18:06:05.349]             invokeRestart <- base::invokeRestart
[18:06:05.349]             length <- base::length
[18:06:05.349]             list <- base::list
[18:06:05.349]             seq.int <- base::seq.int
[18:06:05.349]             signalCondition <- base::signalCondition
[18:06:05.349]             sys.calls <- base::sys.calls
[18:06:05.349]             `[[` <- base::`[[`
[18:06:05.349]             `+` <- base::`+`
[18:06:05.349]             `<<-` <- base::`<<-`
[18:06:05.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.349]                   3L)]
[18:06:05.349]             }
[18:06:05.349]             function(cond) {
[18:06:05.349]                 is_error <- inherits(cond, "error")
[18:06:05.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.349]                   NULL)
[18:06:05.349]                 if (is_error) {
[18:06:05.349]                   sessionInformation <- function() {
[18:06:05.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.349]                       search = base::search(), system = base::Sys.info())
[18:06:05.349]                   }
[18:06:05.349]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.349]                     cond$call), session = sessionInformation(), 
[18:06:05.349]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.349]                   signalCondition(cond)
[18:06:05.349]                 }
[18:06:05.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.349]                 "immediateCondition"))) {
[18:06:05.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.349]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.349]                   if (TRUE && !signal) {
[18:06:05.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.349]                     {
[18:06:05.349]                       inherits <- base::inherits
[18:06:05.349]                       invokeRestart <- base::invokeRestart
[18:06:05.349]                       is.null <- base::is.null
[18:06:05.349]                       muffled <- FALSE
[18:06:05.349]                       if (inherits(cond, "message")) {
[18:06:05.349]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.349]                         if (muffled) 
[18:06:05.349]                           invokeRestart("muffleMessage")
[18:06:05.349]                       }
[18:06:05.349]                       else if (inherits(cond, "warning")) {
[18:06:05.349]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.349]                         if (muffled) 
[18:06:05.349]                           invokeRestart("muffleWarning")
[18:06:05.349]                       }
[18:06:05.349]                       else if (inherits(cond, "condition")) {
[18:06:05.349]                         if (!is.null(pattern)) {
[18:06:05.349]                           computeRestarts <- base::computeRestarts
[18:06:05.349]                           grepl <- base::grepl
[18:06:05.349]                           restarts <- computeRestarts(cond)
[18:06:05.349]                           for (restart in restarts) {
[18:06:05.349]                             name <- restart$name
[18:06:05.349]                             if (is.null(name)) 
[18:06:05.349]                               next
[18:06:05.349]                             if (!grepl(pattern, name)) 
[18:06:05.349]                               next
[18:06:05.349]                             invokeRestart(restart)
[18:06:05.349]                             muffled <- TRUE
[18:06:05.349]                             break
[18:06:05.349]                           }
[18:06:05.349]                         }
[18:06:05.349]                       }
[18:06:05.349]                       invisible(muffled)
[18:06:05.349]                     }
[18:06:05.349]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.349]                   }
[18:06:05.349]                 }
[18:06:05.349]                 else {
[18:06:05.349]                   if (TRUE) {
[18:06:05.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.349]                     {
[18:06:05.349]                       inherits <- base::inherits
[18:06:05.349]                       invokeRestart <- base::invokeRestart
[18:06:05.349]                       is.null <- base::is.null
[18:06:05.349]                       muffled <- FALSE
[18:06:05.349]                       if (inherits(cond, "message")) {
[18:06:05.349]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.349]                         if (muffled) 
[18:06:05.349]                           invokeRestart("muffleMessage")
[18:06:05.349]                       }
[18:06:05.349]                       else if (inherits(cond, "warning")) {
[18:06:05.349]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.349]                         if (muffled) 
[18:06:05.349]                           invokeRestart("muffleWarning")
[18:06:05.349]                       }
[18:06:05.349]                       else if (inherits(cond, "condition")) {
[18:06:05.349]                         if (!is.null(pattern)) {
[18:06:05.349]                           computeRestarts <- base::computeRestarts
[18:06:05.349]                           grepl <- base::grepl
[18:06:05.349]                           restarts <- computeRestarts(cond)
[18:06:05.349]                           for (restart in restarts) {
[18:06:05.349]                             name <- restart$name
[18:06:05.349]                             if (is.null(name)) 
[18:06:05.349]                               next
[18:06:05.349]                             if (!grepl(pattern, name)) 
[18:06:05.349]                               next
[18:06:05.349]                             invokeRestart(restart)
[18:06:05.349]                             muffled <- TRUE
[18:06:05.349]                             break
[18:06:05.349]                           }
[18:06:05.349]                         }
[18:06:05.349]                       }
[18:06:05.349]                       invisible(muffled)
[18:06:05.349]                     }
[18:06:05.349]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.349]                   }
[18:06:05.349]                 }
[18:06:05.349]             }
[18:06:05.349]         }))
[18:06:05.349]     }, error = function(ex) {
[18:06:05.349]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.349]                 ...future.rng), started = ...future.startTime, 
[18:06:05.349]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.349]             version = "1.8"), class = "FutureResult")
[18:06:05.349]     }, finally = {
[18:06:05.349]         if (!identical(...future.workdir, getwd())) 
[18:06:05.349]             setwd(...future.workdir)
[18:06:05.349]         {
[18:06:05.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.349]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.349]             }
[18:06:05.349]             base::options(...future.oldOptions)
[18:06:05.349]             if (.Platform$OS.type == "windows") {
[18:06:05.349]                 old_names <- names(...future.oldEnvVars)
[18:06:05.349]                 envs <- base::Sys.getenv()
[18:06:05.349]                 names <- names(envs)
[18:06:05.349]                 common <- intersect(names, old_names)
[18:06:05.349]                 added <- setdiff(names, old_names)
[18:06:05.349]                 removed <- setdiff(old_names, names)
[18:06:05.349]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.349]                   envs[common]]
[18:06:05.349]                 NAMES <- toupper(changed)
[18:06:05.349]                 args <- list()
[18:06:05.349]                 for (kk in seq_along(NAMES)) {
[18:06:05.349]                   name <- changed[[kk]]
[18:06:05.349]                   NAME <- NAMES[[kk]]
[18:06:05.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.349]                     next
[18:06:05.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.349]                 }
[18:06:05.349]                 NAMES <- toupper(added)
[18:06:05.349]                 for (kk in seq_along(NAMES)) {
[18:06:05.349]                   name <- added[[kk]]
[18:06:05.349]                   NAME <- NAMES[[kk]]
[18:06:05.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.349]                     next
[18:06:05.349]                   args[[name]] <- ""
[18:06:05.349]                 }
[18:06:05.349]                 NAMES <- toupper(removed)
[18:06:05.349]                 for (kk in seq_along(NAMES)) {
[18:06:05.349]                   name <- removed[[kk]]
[18:06:05.349]                   NAME <- NAMES[[kk]]
[18:06:05.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.349]                     next
[18:06:05.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.349]                 }
[18:06:05.349]                 if (length(args) > 0) 
[18:06:05.349]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.349]             }
[18:06:05.349]             else {
[18:06:05.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.349]             }
[18:06:05.349]             {
[18:06:05.349]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.349]                   0L) {
[18:06:05.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.349]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.349]                   base::options(opts)
[18:06:05.349]                 }
[18:06:05.349]                 {
[18:06:05.349]                   {
[18:06:05.349]                     NULL
[18:06:05.349]                     RNGkind("Mersenne-Twister")
[18:06:05.349]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.349]                       inherits = FALSE)
[18:06:05.349]                   }
[18:06:05.349]                   options(future.plan = NULL)
[18:06:05.349]                   if (is.na(NA_character_)) 
[18:06:05.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.349]                     .init = FALSE)
[18:06:05.349]                 }
[18:06:05.349]             }
[18:06:05.349]         }
[18:06:05.349]     })
[18:06:05.349]     if (TRUE) {
[18:06:05.349]         base::sink(type = "output", split = FALSE)
[18:06:05.349]         if (TRUE) {
[18:06:05.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.349]         }
[18:06:05.349]         else {
[18:06:05.349]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.349]         }
[18:06:05.349]         base::close(...future.stdout)
[18:06:05.349]         ...future.stdout <- NULL
[18:06:05.349]     }
[18:06:05.349]     ...future.result$conditions <- ...future.conditions
[18:06:05.349]     ...future.result$finished <- base::Sys.time()
[18:06:05.349]     ...future.result
[18:06:05.349] }
[18:06:05.353] plan(): Setting new future strategy stack:
[18:06:05.353] List of future strategies:
[18:06:05.353] 1. sequential:
[18:06:05.353]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.353]    - tweaked: FALSE
[18:06:05.353]    - call: NULL
[18:06:05.354] plan(): nbrOfWorkers() = 1
[18:06:05.355] plan(): Setting new future strategy stack:
[18:06:05.356] List of future strategies:
[18:06:05.356] 1. sequential:
[18:06:05.356]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.356]    - tweaked: FALSE
[18:06:05.356]    - call: plan(strategy)
[18:06:05.357] plan(): nbrOfWorkers() = 1
[18:06:05.357] SequentialFuture started (and completed)
[18:06:05.358] - Launch lazy future ... done
[18:06:05.358] run() for ‘SequentialFuture’ ... done
[18:06:05.362] resolve() on environment ...
[18:06:05.362]  recursive: 0
[18:06:05.363]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[18:06:05.363] resolved() for ‘SequentialFuture’ ...
[18:06:05.364] - state: ‘finished’
[18:06:05.364] - run: TRUE
[18:06:05.364] - result: ‘FutureResult’
[18:06:05.364] resolved() for ‘SequentialFuture’ ... done
[18:06:05.364] Future #1
[18:06:05.365]  length: 2 (resolved future 1)
[18:06:05.365] resolved() for ‘SequentialFuture’ ...
[18:06:05.365] - state: ‘finished’
[18:06:05.365] - run: TRUE
[18:06:05.366] - result: ‘FutureResult’
[18:06:05.366] resolved() for ‘SequentialFuture’ ... done
[18:06:05.366] Future #2
[18:06:05.366]  length: 1 (resolved future 2)
[18:06:05.366]  length: 0 (resolved future 3)
[18:06:05.367] resolve() on environment ... DONE
[18:06:05.368] getGlobalsAndPackages() ...
[18:06:05.368] Searching for globals...
[18:06:05.369] - globals found: [1] ‘{’
[18:06:05.369] Searching for globals ... DONE
[18:06:05.370] Resolving globals: FALSE
[18:06:05.370] 
[18:06:05.370] 
[18:06:05.370] getGlobalsAndPackages() ... DONE
[18:06:05.371] run() for ‘Future’ ...
[18:06:05.372] - state: ‘created’
[18:06:05.373] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.375] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.375]   - Field: ‘label’
[18:06:05.376]   - Field: ‘local’
[18:06:05.379]   - Field: ‘owner’
[18:06:05.379]   - Field: ‘envir’
[18:06:05.380]   - Field: ‘packages’
[18:06:05.380]   - Field: ‘gc’
[18:06:05.380]   - Field: ‘conditions’
[18:06:05.380]   - Field: ‘expr’
[18:06:05.380]   - Field: ‘uuid’
[18:06:05.381]   - Field: ‘seed’
[18:06:05.383]   - Field: ‘version’
[18:06:05.383]   - Field: ‘result’
[18:06:05.383]   - Field: ‘asynchronous’
[18:06:05.383]   - Field: ‘calls’
[18:06:05.384]   - Field: ‘globals’
[18:06:05.384]   - Field: ‘stdout’
[18:06:05.384]   - Field: ‘earlySignal’
[18:06:05.384]   - Field: ‘lazy’
[18:06:05.385]   - Field: ‘state’
[18:06:05.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.385] - Launch lazy future ...
[18:06:05.385] Packages needed by the future expression (n = 0): <none>
[18:06:05.386] Packages needed by future strategies (n = 0): <none>
[18:06:05.387] {
[18:06:05.387]     {
[18:06:05.387]         {
[18:06:05.387]             ...future.startTime <- base::Sys.time()
[18:06:05.387]             {
[18:06:05.387]                 {
[18:06:05.387]                   {
[18:06:05.387]                     base::local({
[18:06:05.387]                       has_future <- base::requireNamespace("future", 
[18:06:05.387]                         quietly = TRUE)
[18:06:05.387]                       if (has_future) {
[18:06:05.387]                         ns <- base::getNamespace("future")
[18:06:05.387]                         version <- ns[[".package"]][["version"]]
[18:06:05.387]                         if (is.null(version)) 
[18:06:05.387]                           version <- utils::packageVersion("future")
[18:06:05.387]                       }
[18:06:05.387]                       else {
[18:06:05.387]                         version <- NULL
[18:06:05.387]                       }
[18:06:05.387]                       if (!has_future || version < "1.8.0") {
[18:06:05.387]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.387]                           "", base::R.version$version.string), 
[18:06:05.387]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.387]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.387]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.387]                             "release", "version")], collapse = " "), 
[18:06:05.387]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.387]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.387]                           info)
[18:06:05.387]                         info <- base::paste(info, collapse = "; ")
[18:06:05.387]                         if (!has_future) {
[18:06:05.387]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.387]                             info)
[18:06:05.387]                         }
[18:06:05.387]                         else {
[18:06:05.387]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.387]                             info, version)
[18:06:05.387]                         }
[18:06:05.387]                         base::stop(msg)
[18:06:05.387]                       }
[18:06:05.387]                     })
[18:06:05.387]                   }
[18:06:05.387]                   ...future.strategy.old <- future::plan("list")
[18:06:05.387]                   options(future.plan = NULL)
[18:06:05.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.387]                 }
[18:06:05.387]                 ...future.workdir <- getwd()
[18:06:05.387]             }
[18:06:05.387]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.387]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.387]         }
[18:06:05.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.387]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.387]             base::names(...future.oldOptions))
[18:06:05.387]     }
[18:06:05.387]     if (FALSE) {
[18:06:05.387]     }
[18:06:05.387]     else {
[18:06:05.387]         if (TRUE) {
[18:06:05.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.387]                 open = "w")
[18:06:05.387]         }
[18:06:05.387]         else {
[18:06:05.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.387]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.387]         }
[18:06:05.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.387]             base::sink(type = "output", split = FALSE)
[18:06:05.387]             base::close(...future.stdout)
[18:06:05.387]         }, add = TRUE)
[18:06:05.387]     }
[18:06:05.387]     ...future.frame <- base::sys.nframe()
[18:06:05.387]     ...future.conditions <- base::list()
[18:06:05.387]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.387]     if (FALSE) {
[18:06:05.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.387]     }
[18:06:05.387]     ...future.result <- base::tryCatch({
[18:06:05.387]         base::withCallingHandlers({
[18:06:05.387]             ...future.value <- base::withVisible(base::local({
[18:06:05.387]                 1
[18:06:05.387]             }))
[18:06:05.387]             future::FutureResult(value = ...future.value$value, 
[18:06:05.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.387]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.387]                     ...future.globalenv.names))
[18:06:05.387]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.387]         }, condition = base::local({
[18:06:05.387]             c <- base::c
[18:06:05.387]             inherits <- base::inherits
[18:06:05.387]             invokeRestart <- base::invokeRestart
[18:06:05.387]             length <- base::length
[18:06:05.387]             list <- base::list
[18:06:05.387]             seq.int <- base::seq.int
[18:06:05.387]             signalCondition <- base::signalCondition
[18:06:05.387]             sys.calls <- base::sys.calls
[18:06:05.387]             `[[` <- base::`[[`
[18:06:05.387]             `+` <- base::`+`
[18:06:05.387]             `<<-` <- base::`<<-`
[18:06:05.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.387]                   3L)]
[18:06:05.387]             }
[18:06:05.387]             function(cond) {
[18:06:05.387]                 is_error <- inherits(cond, "error")
[18:06:05.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.387]                   NULL)
[18:06:05.387]                 if (is_error) {
[18:06:05.387]                   sessionInformation <- function() {
[18:06:05.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.387]                       search = base::search(), system = base::Sys.info())
[18:06:05.387]                   }
[18:06:05.387]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.387]                     cond$call), session = sessionInformation(), 
[18:06:05.387]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.387]                   signalCondition(cond)
[18:06:05.387]                 }
[18:06:05.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.387]                 "immediateCondition"))) {
[18:06:05.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.387]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.387]                   if (TRUE && !signal) {
[18:06:05.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.387]                     {
[18:06:05.387]                       inherits <- base::inherits
[18:06:05.387]                       invokeRestart <- base::invokeRestart
[18:06:05.387]                       is.null <- base::is.null
[18:06:05.387]                       muffled <- FALSE
[18:06:05.387]                       if (inherits(cond, "message")) {
[18:06:05.387]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.387]                         if (muffled) 
[18:06:05.387]                           invokeRestart("muffleMessage")
[18:06:05.387]                       }
[18:06:05.387]                       else if (inherits(cond, "warning")) {
[18:06:05.387]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.387]                         if (muffled) 
[18:06:05.387]                           invokeRestart("muffleWarning")
[18:06:05.387]                       }
[18:06:05.387]                       else if (inherits(cond, "condition")) {
[18:06:05.387]                         if (!is.null(pattern)) {
[18:06:05.387]                           computeRestarts <- base::computeRestarts
[18:06:05.387]                           grepl <- base::grepl
[18:06:05.387]                           restarts <- computeRestarts(cond)
[18:06:05.387]                           for (restart in restarts) {
[18:06:05.387]                             name <- restart$name
[18:06:05.387]                             if (is.null(name)) 
[18:06:05.387]                               next
[18:06:05.387]                             if (!grepl(pattern, name)) 
[18:06:05.387]                               next
[18:06:05.387]                             invokeRestart(restart)
[18:06:05.387]                             muffled <- TRUE
[18:06:05.387]                             break
[18:06:05.387]                           }
[18:06:05.387]                         }
[18:06:05.387]                       }
[18:06:05.387]                       invisible(muffled)
[18:06:05.387]                     }
[18:06:05.387]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.387]                   }
[18:06:05.387]                 }
[18:06:05.387]                 else {
[18:06:05.387]                   if (TRUE) {
[18:06:05.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.387]                     {
[18:06:05.387]                       inherits <- base::inherits
[18:06:05.387]                       invokeRestart <- base::invokeRestart
[18:06:05.387]                       is.null <- base::is.null
[18:06:05.387]                       muffled <- FALSE
[18:06:05.387]                       if (inherits(cond, "message")) {
[18:06:05.387]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.387]                         if (muffled) 
[18:06:05.387]                           invokeRestart("muffleMessage")
[18:06:05.387]                       }
[18:06:05.387]                       else if (inherits(cond, "warning")) {
[18:06:05.387]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.387]                         if (muffled) 
[18:06:05.387]                           invokeRestart("muffleWarning")
[18:06:05.387]                       }
[18:06:05.387]                       else if (inherits(cond, "condition")) {
[18:06:05.387]                         if (!is.null(pattern)) {
[18:06:05.387]                           computeRestarts <- base::computeRestarts
[18:06:05.387]                           grepl <- base::grepl
[18:06:05.387]                           restarts <- computeRestarts(cond)
[18:06:05.387]                           for (restart in restarts) {
[18:06:05.387]                             name <- restart$name
[18:06:05.387]                             if (is.null(name)) 
[18:06:05.387]                               next
[18:06:05.387]                             if (!grepl(pattern, name)) 
[18:06:05.387]                               next
[18:06:05.387]                             invokeRestart(restart)
[18:06:05.387]                             muffled <- TRUE
[18:06:05.387]                             break
[18:06:05.387]                           }
[18:06:05.387]                         }
[18:06:05.387]                       }
[18:06:05.387]                       invisible(muffled)
[18:06:05.387]                     }
[18:06:05.387]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.387]                   }
[18:06:05.387]                 }
[18:06:05.387]             }
[18:06:05.387]         }))
[18:06:05.387]     }, error = function(ex) {
[18:06:05.387]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.387]                 ...future.rng), started = ...future.startTime, 
[18:06:05.387]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.387]             version = "1.8"), class = "FutureResult")
[18:06:05.387]     }, finally = {
[18:06:05.387]         if (!identical(...future.workdir, getwd())) 
[18:06:05.387]             setwd(...future.workdir)
[18:06:05.387]         {
[18:06:05.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.387]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.387]             }
[18:06:05.387]             base::options(...future.oldOptions)
[18:06:05.387]             if (.Platform$OS.type == "windows") {
[18:06:05.387]                 old_names <- names(...future.oldEnvVars)
[18:06:05.387]                 envs <- base::Sys.getenv()
[18:06:05.387]                 names <- names(envs)
[18:06:05.387]                 common <- intersect(names, old_names)
[18:06:05.387]                 added <- setdiff(names, old_names)
[18:06:05.387]                 removed <- setdiff(old_names, names)
[18:06:05.387]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.387]                   envs[common]]
[18:06:05.387]                 NAMES <- toupper(changed)
[18:06:05.387]                 args <- list()
[18:06:05.387]                 for (kk in seq_along(NAMES)) {
[18:06:05.387]                   name <- changed[[kk]]
[18:06:05.387]                   NAME <- NAMES[[kk]]
[18:06:05.387]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.387]                     next
[18:06:05.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.387]                 }
[18:06:05.387]                 NAMES <- toupper(added)
[18:06:05.387]                 for (kk in seq_along(NAMES)) {
[18:06:05.387]                   name <- added[[kk]]
[18:06:05.387]                   NAME <- NAMES[[kk]]
[18:06:05.387]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.387]                     next
[18:06:05.387]                   args[[name]] <- ""
[18:06:05.387]                 }
[18:06:05.387]                 NAMES <- toupper(removed)
[18:06:05.387]                 for (kk in seq_along(NAMES)) {
[18:06:05.387]                   name <- removed[[kk]]
[18:06:05.387]                   NAME <- NAMES[[kk]]
[18:06:05.387]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.387]                     next
[18:06:05.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.387]                 }
[18:06:05.387]                 if (length(args) > 0) 
[18:06:05.387]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.387]             }
[18:06:05.387]             else {
[18:06:05.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.387]             }
[18:06:05.387]             {
[18:06:05.387]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.387]                   0L) {
[18:06:05.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.387]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.387]                   base::options(opts)
[18:06:05.387]                 }
[18:06:05.387]                 {
[18:06:05.387]                   {
[18:06:05.387]                     NULL
[18:06:05.387]                     RNGkind("Mersenne-Twister")
[18:06:05.387]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.387]                       inherits = FALSE)
[18:06:05.387]                   }
[18:06:05.387]                   options(future.plan = NULL)
[18:06:05.387]                   if (is.na(NA_character_)) 
[18:06:05.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.387]                     .init = FALSE)
[18:06:05.387]                 }
[18:06:05.387]             }
[18:06:05.387]         }
[18:06:05.387]     })
[18:06:05.387]     if (TRUE) {
[18:06:05.387]         base::sink(type = "output", split = FALSE)
[18:06:05.387]         if (TRUE) {
[18:06:05.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.387]         }
[18:06:05.387]         else {
[18:06:05.387]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.387]         }
[18:06:05.387]         base::close(...future.stdout)
[18:06:05.387]         ...future.stdout <- NULL
[18:06:05.387]     }
[18:06:05.387]     ...future.result$conditions <- ...future.conditions
[18:06:05.387]     ...future.result$finished <- base::Sys.time()
[18:06:05.387]     ...future.result
[18:06:05.387] }
[18:06:05.390] plan(): Setting new future strategy stack:
[18:06:05.390] List of future strategies:
[18:06:05.390] 1. sequential:
[18:06:05.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.390]    - tweaked: FALSE
[18:06:05.390]    - call: NULL
[18:06:05.392] plan(): nbrOfWorkers() = 1
[18:06:05.393] plan(): Setting new future strategy stack:
[18:06:05.393] List of future strategies:
[18:06:05.393] 1. sequential:
[18:06:05.393]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.393]    - tweaked: FALSE
[18:06:05.393]    - call: plan(strategy)
[18:06:05.394] plan(): nbrOfWorkers() = 1
[18:06:05.395] SequentialFuture started (and completed)
[18:06:05.395] - Launch lazy future ... done
[18:06:05.395] run() for ‘SequentialFuture’ ... done
[18:06:05.396] getGlobalsAndPackages() ...
[18:06:05.396] Searching for globals...
[18:06:05.397] - globals found: [1] ‘{’
[18:06:05.398] Searching for globals ... DONE
[18:06:05.398] Resolving globals: FALSE
[18:06:05.399] 
[18:06:05.399] 
[18:06:05.399] getGlobalsAndPackages() ... DONE
[18:06:05.400] run() for ‘Future’ ...
[18:06:05.400] - state: ‘created’
[18:06:05.400] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.401] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.401] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.401]   - Field: ‘label’
[18:06:05.401]   - Field: ‘local’
[18:06:05.402]   - Field: ‘owner’
[18:06:05.402]   - Field: ‘envir’
[18:06:05.402]   - Field: ‘packages’
[18:06:05.402]   - Field: ‘gc’
[18:06:05.402]   - Field: ‘conditions’
[18:06:05.403]   - Field: ‘expr’
[18:06:05.403]   - Field: ‘uuid’
[18:06:05.403]   - Field: ‘seed’
[18:06:05.403]   - Field: ‘version’
[18:06:05.403]   - Field: ‘result’
[18:06:05.404]   - Field: ‘asynchronous’
[18:06:05.404]   - Field: ‘calls’
[18:06:05.404]   - Field: ‘globals’
[18:06:05.404]   - Field: ‘stdout’
[18:06:05.404]   - Field: ‘earlySignal’
[18:06:05.405]   - Field: ‘lazy’
[18:06:05.405]   - Field: ‘state’
[18:06:05.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.405] - Launch lazy future ...
[18:06:05.406] Packages needed by the future expression (n = 0): <none>
[18:06:05.406] Packages needed by future strategies (n = 0): <none>
[18:06:05.407] {
[18:06:05.407]     {
[18:06:05.407]         {
[18:06:05.407]             ...future.startTime <- base::Sys.time()
[18:06:05.407]             {
[18:06:05.407]                 {
[18:06:05.407]                   {
[18:06:05.407]                     base::local({
[18:06:05.407]                       has_future <- base::requireNamespace("future", 
[18:06:05.407]                         quietly = TRUE)
[18:06:05.407]                       if (has_future) {
[18:06:05.407]                         ns <- base::getNamespace("future")
[18:06:05.407]                         version <- ns[[".package"]][["version"]]
[18:06:05.407]                         if (is.null(version)) 
[18:06:05.407]                           version <- utils::packageVersion("future")
[18:06:05.407]                       }
[18:06:05.407]                       else {
[18:06:05.407]                         version <- NULL
[18:06:05.407]                       }
[18:06:05.407]                       if (!has_future || version < "1.8.0") {
[18:06:05.407]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.407]                           "", base::R.version$version.string), 
[18:06:05.407]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.407]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.407]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.407]                             "release", "version")], collapse = " "), 
[18:06:05.407]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.407]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.407]                           info)
[18:06:05.407]                         info <- base::paste(info, collapse = "; ")
[18:06:05.407]                         if (!has_future) {
[18:06:05.407]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.407]                             info)
[18:06:05.407]                         }
[18:06:05.407]                         else {
[18:06:05.407]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.407]                             info, version)
[18:06:05.407]                         }
[18:06:05.407]                         base::stop(msg)
[18:06:05.407]                       }
[18:06:05.407]                     })
[18:06:05.407]                   }
[18:06:05.407]                   ...future.strategy.old <- future::plan("list")
[18:06:05.407]                   options(future.plan = NULL)
[18:06:05.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.407]                 }
[18:06:05.407]                 ...future.workdir <- getwd()
[18:06:05.407]             }
[18:06:05.407]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.407]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.407]         }
[18:06:05.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.407]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.407]             base::names(...future.oldOptions))
[18:06:05.407]     }
[18:06:05.407]     if (FALSE) {
[18:06:05.407]     }
[18:06:05.407]     else {
[18:06:05.407]         if (TRUE) {
[18:06:05.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.407]                 open = "w")
[18:06:05.407]         }
[18:06:05.407]         else {
[18:06:05.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.407]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.407]         }
[18:06:05.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.407]             base::sink(type = "output", split = FALSE)
[18:06:05.407]             base::close(...future.stdout)
[18:06:05.407]         }, add = TRUE)
[18:06:05.407]     }
[18:06:05.407]     ...future.frame <- base::sys.nframe()
[18:06:05.407]     ...future.conditions <- base::list()
[18:06:05.407]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.407]     if (FALSE) {
[18:06:05.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.407]     }
[18:06:05.407]     ...future.result <- base::tryCatch({
[18:06:05.407]         base::withCallingHandlers({
[18:06:05.407]             ...future.value <- base::withVisible(base::local({
[18:06:05.407]                 2
[18:06:05.407]             }))
[18:06:05.407]             future::FutureResult(value = ...future.value$value, 
[18:06:05.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.407]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.407]                     ...future.globalenv.names))
[18:06:05.407]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.407]         }, condition = base::local({
[18:06:05.407]             c <- base::c
[18:06:05.407]             inherits <- base::inherits
[18:06:05.407]             invokeRestart <- base::invokeRestart
[18:06:05.407]             length <- base::length
[18:06:05.407]             list <- base::list
[18:06:05.407]             seq.int <- base::seq.int
[18:06:05.407]             signalCondition <- base::signalCondition
[18:06:05.407]             sys.calls <- base::sys.calls
[18:06:05.407]             `[[` <- base::`[[`
[18:06:05.407]             `+` <- base::`+`
[18:06:05.407]             `<<-` <- base::`<<-`
[18:06:05.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.407]                   3L)]
[18:06:05.407]             }
[18:06:05.407]             function(cond) {
[18:06:05.407]                 is_error <- inherits(cond, "error")
[18:06:05.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.407]                   NULL)
[18:06:05.407]                 if (is_error) {
[18:06:05.407]                   sessionInformation <- function() {
[18:06:05.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.407]                       search = base::search(), system = base::Sys.info())
[18:06:05.407]                   }
[18:06:05.407]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.407]                     cond$call), session = sessionInformation(), 
[18:06:05.407]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.407]                   signalCondition(cond)
[18:06:05.407]                 }
[18:06:05.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.407]                 "immediateCondition"))) {
[18:06:05.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.407]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.407]                   if (TRUE && !signal) {
[18:06:05.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.407]                     {
[18:06:05.407]                       inherits <- base::inherits
[18:06:05.407]                       invokeRestart <- base::invokeRestart
[18:06:05.407]                       is.null <- base::is.null
[18:06:05.407]                       muffled <- FALSE
[18:06:05.407]                       if (inherits(cond, "message")) {
[18:06:05.407]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.407]                         if (muffled) 
[18:06:05.407]                           invokeRestart("muffleMessage")
[18:06:05.407]                       }
[18:06:05.407]                       else if (inherits(cond, "warning")) {
[18:06:05.407]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.407]                         if (muffled) 
[18:06:05.407]                           invokeRestart("muffleWarning")
[18:06:05.407]                       }
[18:06:05.407]                       else if (inherits(cond, "condition")) {
[18:06:05.407]                         if (!is.null(pattern)) {
[18:06:05.407]                           computeRestarts <- base::computeRestarts
[18:06:05.407]                           grepl <- base::grepl
[18:06:05.407]                           restarts <- computeRestarts(cond)
[18:06:05.407]                           for (restart in restarts) {
[18:06:05.407]                             name <- restart$name
[18:06:05.407]                             if (is.null(name)) 
[18:06:05.407]                               next
[18:06:05.407]                             if (!grepl(pattern, name)) 
[18:06:05.407]                               next
[18:06:05.407]                             invokeRestart(restart)
[18:06:05.407]                             muffled <- TRUE
[18:06:05.407]                             break
[18:06:05.407]                           }
[18:06:05.407]                         }
[18:06:05.407]                       }
[18:06:05.407]                       invisible(muffled)
[18:06:05.407]                     }
[18:06:05.407]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.407]                   }
[18:06:05.407]                 }
[18:06:05.407]                 else {
[18:06:05.407]                   if (TRUE) {
[18:06:05.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.407]                     {
[18:06:05.407]                       inherits <- base::inherits
[18:06:05.407]                       invokeRestart <- base::invokeRestart
[18:06:05.407]                       is.null <- base::is.null
[18:06:05.407]                       muffled <- FALSE
[18:06:05.407]                       if (inherits(cond, "message")) {
[18:06:05.407]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.407]                         if (muffled) 
[18:06:05.407]                           invokeRestart("muffleMessage")
[18:06:05.407]                       }
[18:06:05.407]                       else if (inherits(cond, "warning")) {
[18:06:05.407]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.407]                         if (muffled) 
[18:06:05.407]                           invokeRestart("muffleWarning")
[18:06:05.407]                       }
[18:06:05.407]                       else if (inherits(cond, "condition")) {
[18:06:05.407]                         if (!is.null(pattern)) {
[18:06:05.407]                           computeRestarts <- base::computeRestarts
[18:06:05.407]                           grepl <- base::grepl
[18:06:05.407]                           restarts <- computeRestarts(cond)
[18:06:05.407]                           for (restart in restarts) {
[18:06:05.407]                             name <- restart$name
[18:06:05.407]                             if (is.null(name)) 
[18:06:05.407]                               next
[18:06:05.407]                             if (!grepl(pattern, name)) 
[18:06:05.407]                               next
[18:06:05.407]                             invokeRestart(restart)
[18:06:05.407]                             muffled <- TRUE
[18:06:05.407]                             break
[18:06:05.407]                           }
[18:06:05.407]                         }
[18:06:05.407]                       }
[18:06:05.407]                       invisible(muffled)
[18:06:05.407]                     }
[18:06:05.407]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.407]                   }
[18:06:05.407]                 }
[18:06:05.407]             }
[18:06:05.407]         }))
[18:06:05.407]     }, error = function(ex) {
[18:06:05.407]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.407]                 ...future.rng), started = ...future.startTime, 
[18:06:05.407]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.407]             version = "1.8"), class = "FutureResult")
[18:06:05.407]     }, finally = {
[18:06:05.407]         if (!identical(...future.workdir, getwd())) 
[18:06:05.407]             setwd(...future.workdir)
[18:06:05.407]         {
[18:06:05.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.407]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.407]             }
[18:06:05.407]             base::options(...future.oldOptions)
[18:06:05.407]             if (.Platform$OS.type == "windows") {
[18:06:05.407]                 old_names <- names(...future.oldEnvVars)
[18:06:05.407]                 envs <- base::Sys.getenv()
[18:06:05.407]                 names <- names(envs)
[18:06:05.407]                 common <- intersect(names, old_names)
[18:06:05.407]                 added <- setdiff(names, old_names)
[18:06:05.407]                 removed <- setdiff(old_names, names)
[18:06:05.407]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.407]                   envs[common]]
[18:06:05.407]                 NAMES <- toupper(changed)
[18:06:05.407]                 args <- list()
[18:06:05.407]                 for (kk in seq_along(NAMES)) {
[18:06:05.407]                   name <- changed[[kk]]
[18:06:05.407]                   NAME <- NAMES[[kk]]
[18:06:05.407]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.407]                     next
[18:06:05.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.407]                 }
[18:06:05.407]                 NAMES <- toupper(added)
[18:06:05.407]                 for (kk in seq_along(NAMES)) {
[18:06:05.407]                   name <- added[[kk]]
[18:06:05.407]                   NAME <- NAMES[[kk]]
[18:06:05.407]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.407]                     next
[18:06:05.407]                   args[[name]] <- ""
[18:06:05.407]                 }
[18:06:05.407]                 NAMES <- toupper(removed)
[18:06:05.407]                 for (kk in seq_along(NAMES)) {
[18:06:05.407]                   name <- removed[[kk]]
[18:06:05.407]                   NAME <- NAMES[[kk]]
[18:06:05.407]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.407]                     next
[18:06:05.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.407]                 }
[18:06:05.407]                 if (length(args) > 0) 
[18:06:05.407]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.407]             }
[18:06:05.407]             else {
[18:06:05.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.407]             }
[18:06:05.407]             {
[18:06:05.407]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.407]                   0L) {
[18:06:05.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.407]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.407]                   base::options(opts)
[18:06:05.407]                 }
[18:06:05.407]                 {
[18:06:05.407]                   {
[18:06:05.407]                     NULL
[18:06:05.407]                     RNGkind("Mersenne-Twister")
[18:06:05.407]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.407]                       inherits = FALSE)
[18:06:05.407]                   }
[18:06:05.407]                   options(future.plan = NULL)
[18:06:05.407]                   if (is.na(NA_character_)) 
[18:06:05.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.407]                     .init = FALSE)
[18:06:05.407]                 }
[18:06:05.407]             }
[18:06:05.407]         }
[18:06:05.407]     })
[18:06:05.407]     if (TRUE) {
[18:06:05.407]         base::sink(type = "output", split = FALSE)
[18:06:05.407]         if (TRUE) {
[18:06:05.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.407]         }
[18:06:05.407]         else {
[18:06:05.407]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.407]         }
[18:06:05.407]         base::close(...future.stdout)
[18:06:05.407]         ...future.stdout <- NULL
[18:06:05.407]     }
[18:06:05.407]     ...future.result$conditions <- ...future.conditions
[18:06:05.407]     ...future.result$finished <- base::Sys.time()
[18:06:05.407]     ...future.result
[18:06:05.407] }
[18:06:05.410] plan(): Setting new future strategy stack:
[18:06:05.411] List of future strategies:
[18:06:05.411] 1. sequential:
[18:06:05.411]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.411]    - tweaked: FALSE
[18:06:05.411]    - call: NULL
[18:06:05.412] plan(): nbrOfWorkers() = 1
[18:06:05.413] plan(): Setting new future strategy stack:
[18:06:05.414] List of future strategies:
[18:06:05.414] 1. sequential:
[18:06:05.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.414]    - tweaked: FALSE
[18:06:05.414]    - call: plan(strategy)
[18:06:05.415] plan(): nbrOfWorkers() = 1
[18:06:05.415] SequentialFuture started (and completed)
[18:06:05.415] - Launch lazy future ... done
[18:06:05.416] run() for ‘SequentialFuture’ ... done
[18:06:05.417] resolve() on environment ...
[18:06:05.417]  recursive: 0
[18:06:05.418]  elements: [3] ‘a’
[18:06:05.418] resolved() for ‘SequentialFuture’ ...
[18:06:05.419] - state: ‘finished’
[18:06:05.419] - run: TRUE
[18:06:05.419] - result: ‘FutureResult’
[18:06:05.419] resolved() for ‘SequentialFuture’ ... done
[18:06:05.419] Future #1
[18:06:05.420]  length: 2 (resolved future 1)
[18:06:05.420] resolved() for ‘SequentialFuture’ ...
[18:06:05.420] - state: ‘finished’
[18:06:05.420] - run: TRUE
[18:06:05.421] - result: ‘FutureResult’
[18:06:05.421] resolved() for ‘SequentialFuture’ ... done
[18:06:05.421] Future #2
[18:06:05.421]  length: 1 (resolved future 2)
[18:06:05.421]  length: 0 (resolved future 3)
[18:06:05.422] resolve() on environment ... DONE
[18:06:05.422] resolved() for ‘SequentialFuture’ ...
[18:06:05.422] - state: ‘finished’
[18:06:05.422] - run: TRUE
[18:06:05.422] - result: ‘FutureResult’
[18:06:05.423] resolved() for ‘SequentialFuture’ ... done
[18:06:05.424] resolve() on environment ...
[18:06:05.424]  recursive: 0
[18:06:05.425]  elements: [3] ‘b’
[18:06:05.425] resolved() for ‘SequentialFuture’ ...
[18:06:05.426] - state: ‘finished’
[18:06:05.426] - run: TRUE
[18:06:05.426] - result: ‘FutureResult’
[18:06:05.426] resolved() for ‘SequentialFuture’ ... done
[18:06:05.426] Future #1
[18:06:05.427]  length: 2 (resolved future 1)
[18:06:05.427] resolved() for ‘SequentialFuture’ ...
[18:06:05.427] - state: ‘finished’
[18:06:05.427] - run: TRUE
[18:06:05.427] - result: ‘FutureResult’
[18:06:05.428] resolved() for ‘SequentialFuture’ ... done
[18:06:05.428] Future #2
[18:06:05.428]  length: 1 (resolved future 2)
[18:06:05.428]  length: 0 (resolved future 3)
[18:06:05.429] resolve() on environment ... DONE
[18:06:05.432] resolve() on environment ...
[18:06:05.433]  recursive: 0
[18:06:05.434]  elements: [3] ‘c’
[18:06:05.434] resolved() for ‘SequentialFuture’ ...
[18:06:05.435] - state: ‘finished’
[18:06:05.435] - run: TRUE
[18:06:05.435] - result: ‘FutureResult’
[18:06:05.435] resolved() for ‘SequentialFuture’ ... done
[18:06:05.435] Future #1
[18:06:05.436]  length: 2 (resolved future 1)
[18:06:05.436] resolved() for ‘SequentialFuture’ ...
[18:06:05.436] - state: ‘finished’
[18:06:05.436] - run: TRUE
[18:06:05.437] - result: ‘FutureResult’
[18:06:05.437] resolved() for ‘SequentialFuture’ ... done
[18:06:05.437] Future #2
[18:06:05.437]  length: 1 (resolved future 2)
[18:06:05.437]  length: 0 (resolved future 3)
[18:06:05.438] resolve() on environment ... DONE
[18:06:05.439] resolve() on environment ...
[18:06:05.439]  recursive: 0
[18:06:05.440]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[18:06:05.440] resolved() for ‘SequentialFuture’ ...
[18:06:05.441] - state: ‘finished’
[18:06:05.441] - run: TRUE
[18:06:05.441] - result: ‘FutureResult’
[18:06:05.441] resolved() for ‘SequentialFuture’ ... done
[18:06:05.441] Future #1
[18:06:05.442]  length: 2 (resolved future 1)
[18:06:05.443] resolved() for ‘SequentialFuture’ ...
[18:06:05.443] - state: ‘finished’
[18:06:05.443] - run: TRUE
[18:06:05.443] - result: ‘FutureResult’
[18:06:05.443] resolved() for ‘SequentialFuture’ ... done
[18:06:05.444] Future #2
[18:06:05.444]  length: 1 (resolved future 2)
[18:06:05.444]  length: 0 (resolved future 3)
[18:06:05.444] resolve() on environment ... DONE
[18:06:05.445] resolve() on environment ...
[18:06:05.446]  recursive: 99
[18:06:05.447]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[18:06:05.447] resolved() for ‘SequentialFuture’ ...
[18:06:05.447] - state: ‘finished’
[18:06:05.448] - run: TRUE
[18:06:05.448] - result: ‘FutureResult’
[18:06:05.448] resolved() for ‘SequentialFuture’ ... done
[18:06:05.448] Future #1
[18:06:05.449] resolved() for ‘SequentialFuture’ ...
[18:06:05.449] - state: ‘finished’
[18:06:05.449] - run: TRUE
[18:06:05.449] - result: ‘FutureResult’
[18:06:05.449] resolved() for ‘SequentialFuture’ ... done
[18:06:05.450] A SequentialFuture was resolved
[18:06:05.450]  length: 2 (resolved future 1)
[18:06:05.450] resolved() for ‘SequentialFuture’ ...
[18:06:05.450] - state: ‘finished’
[18:06:05.451] - run: TRUE
[18:06:05.451] - result: ‘FutureResult’
[18:06:05.451] resolved() for ‘SequentialFuture’ ... done
[18:06:05.451] Future #2
[18:06:05.451] resolved() for ‘SequentialFuture’ ...
[18:06:05.452] - state: ‘finished’
[18:06:05.452] - run: TRUE
[18:06:05.452] - result: ‘FutureResult’
[18:06:05.452] resolved() for ‘SequentialFuture’ ... done
[18:06:05.452] A SequentialFuture was resolved
[18:06:05.453]  length: 1 (resolved future 2)
[18:06:05.453]  length: 0 (resolved future 3)
[18:06:05.453] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[18:06:05.456] resolve() on list environment ...
[18:06:05.456]  recursive: 0
[18:06:05.458]  length: 2
[18:06:05.458]  elements: ‘a’, ‘b’
[18:06:05.458]  length: 1 (resolved future 1)
[18:06:05.459]  length: 0 (resolved future 2)
[18:06:05.459] resolve() on list environment ... DONE
[18:06:05.459] getGlobalsAndPackages() ...
[18:06:05.459] Searching for globals...
[18:06:05.460] 
[18:06:05.460] Searching for globals ... DONE
[18:06:05.461] - globals: [0] <none>
[18:06:05.461] getGlobalsAndPackages() ... DONE
[18:06:05.461] run() for ‘Future’ ...
[18:06:05.461] - state: ‘created’
[18:06:05.462] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.463]   - Field: ‘label’
[18:06:05.463]   - Field: ‘local’
[18:06:05.463]   - Field: ‘owner’
[18:06:05.464]   - Field: ‘envir’
[18:06:05.464]   - Field: ‘packages’
[18:06:05.464]   - Field: ‘gc’
[18:06:05.464]   - Field: ‘conditions’
[18:06:05.464]   - Field: ‘expr’
[18:06:05.465]   - Field: ‘uuid’
[18:06:05.465]   - Field: ‘seed’
[18:06:05.465]   - Field: ‘version’
[18:06:05.465]   - Field: ‘result’
[18:06:05.465]   - Field: ‘asynchronous’
[18:06:05.466]   - Field: ‘calls’
[18:06:05.466]   - Field: ‘globals’
[18:06:05.466]   - Field: ‘stdout’
[18:06:05.466]   - Field: ‘earlySignal’
[18:06:05.466]   - Field: ‘lazy’
[18:06:05.466]   - Field: ‘state’
[18:06:05.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.467] - Launch lazy future ...
[18:06:05.467] Packages needed by the future expression (n = 0): <none>
[18:06:05.468] Packages needed by future strategies (n = 0): <none>
[18:06:05.468] {
[18:06:05.468]     {
[18:06:05.468]         {
[18:06:05.468]             ...future.startTime <- base::Sys.time()
[18:06:05.468]             {
[18:06:05.468]                 {
[18:06:05.468]                   {
[18:06:05.468]                     base::local({
[18:06:05.468]                       has_future <- base::requireNamespace("future", 
[18:06:05.468]                         quietly = TRUE)
[18:06:05.468]                       if (has_future) {
[18:06:05.468]                         ns <- base::getNamespace("future")
[18:06:05.468]                         version <- ns[[".package"]][["version"]]
[18:06:05.468]                         if (is.null(version)) 
[18:06:05.468]                           version <- utils::packageVersion("future")
[18:06:05.468]                       }
[18:06:05.468]                       else {
[18:06:05.468]                         version <- NULL
[18:06:05.468]                       }
[18:06:05.468]                       if (!has_future || version < "1.8.0") {
[18:06:05.468]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.468]                           "", base::R.version$version.string), 
[18:06:05.468]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.468]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.468]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.468]                             "release", "version")], collapse = " "), 
[18:06:05.468]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.468]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.468]                           info)
[18:06:05.468]                         info <- base::paste(info, collapse = "; ")
[18:06:05.468]                         if (!has_future) {
[18:06:05.468]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.468]                             info)
[18:06:05.468]                         }
[18:06:05.468]                         else {
[18:06:05.468]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.468]                             info, version)
[18:06:05.468]                         }
[18:06:05.468]                         base::stop(msg)
[18:06:05.468]                       }
[18:06:05.468]                     })
[18:06:05.468]                   }
[18:06:05.468]                   ...future.strategy.old <- future::plan("list")
[18:06:05.468]                   options(future.plan = NULL)
[18:06:05.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.468]                 }
[18:06:05.468]                 ...future.workdir <- getwd()
[18:06:05.468]             }
[18:06:05.468]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.468]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.468]         }
[18:06:05.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.468]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.468]             base::names(...future.oldOptions))
[18:06:05.468]     }
[18:06:05.468]     if (FALSE) {
[18:06:05.468]     }
[18:06:05.468]     else {
[18:06:05.468]         if (TRUE) {
[18:06:05.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.468]                 open = "w")
[18:06:05.468]         }
[18:06:05.468]         else {
[18:06:05.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.468]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.468]         }
[18:06:05.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.468]             base::sink(type = "output", split = FALSE)
[18:06:05.468]             base::close(...future.stdout)
[18:06:05.468]         }, add = TRUE)
[18:06:05.468]     }
[18:06:05.468]     ...future.frame <- base::sys.nframe()
[18:06:05.468]     ...future.conditions <- base::list()
[18:06:05.468]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.468]     if (FALSE) {
[18:06:05.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.468]     }
[18:06:05.468]     ...future.result <- base::tryCatch({
[18:06:05.468]         base::withCallingHandlers({
[18:06:05.468]             ...future.value <- base::withVisible(base::local(1))
[18:06:05.468]             future::FutureResult(value = ...future.value$value, 
[18:06:05.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.468]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.468]                     ...future.globalenv.names))
[18:06:05.468]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.468]         }, condition = base::local({
[18:06:05.468]             c <- base::c
[18:06:05.468]             inherits <- base::inherits
[18:06:05.468]             invokeRestart <- base::invokeRestart
[18:06:05.468]             length <- base::length
[18:06:05.468]             list <- base::list
[18:06:05.468]             seq.int <- base::seq.int
[18:06:05.468]             signalCondition <- base::signalCondition
[18:06:05.468]             sys.calls <- base::sys.calls
[18:06:05.468]             `[[` <- base::`[[`
[18:06:05.468]             `+` <- base::`+`
[18:06:05.468]             `<<-` <- base::`<<-`
[18:06:05.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.468]                   3L)]
[18:06:05.468]             }
[18:06:05.468]             function(cond) {
[18:06:05.468]                 is_error <- inherits(cond, "error")
[18:06:05.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.468]                   NULL)
[18:06:05.468]                 if (is_error) {
[18:06:05.468]                   sessionInformation <- function() {
[18:06:05.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.468]                       search = base::search(), system = base::Sys.info())
[18:06:05.468]                   }
[18:06:05.468]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.468]                     cond$call), session = sessionInformation(), 
[18:06:05.468]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.468]                   signalCondition(cond)
[18:06:05.468]                 }
[18:06:05.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.468]                 "immediateCondition"))) {
[18:06:05.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.468]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.468]                   if (TRUE && !signal) {
[18:06:05.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.468]                     {
[18:06:05.468]                       inherits <- base::inherits
[18:06:05.468]                       invokeRestart <- base::invokeRestart
[18:06:05.468]                       is.null <- base::is.null
[18:06:05.468]                       muffled <- FALSE
[18:06:05.468]                       if (inherits(cond, "message")) {
[18:06:05.468]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.468]                         if (muffled) 
[18:06:05.468]                           invokeRestart("muffleMessage")
[18:06:05.468]                       }
[18:06:05.468]                       else if (inherits(cond, "warning")) {
[18:06:05.468]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.468]                         if (muffled) 
[18:06:05.468]                           invokeRestart("muffleWarning")
[18:06:05.468]                       }
[18:06:05.468]                       else if (inherits(cond, "condition")) {
[18:06:05.468]                         if (!is.null(pattern)) {
[18:06:05.468]                           computeRestarts <- base::computeRestarts
[18:06:05.468]                           grepl <- base::grepl
[18:06:05.468]                           restarts <- computeRestarts(cond)
[18:06:05.468]                           for (restart in restarts) {
[18:06:05.468]                             name <- restart$name
[18:06:05.468]                             if (is.null(name)) 
[18:06:05.468]                               next
[18:06:05.468]                             if (!grepl(pattern, name)) 
[18:06:05.468]                               next
[18:06:05.468]                             invokeRestart(restart)
[18:06:05.468]                             muffled <- TRUE
[18:06:05.468]                             break
[18:06:05.468]                           }
[18:06:05.468]                         }
[18:06:05.468]                       }
[18:06:05.468]                       invisible(muffled)
[18:06:05.468]                     }
[18:06:05.468]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.468]                   }
[18:06:05.468]                 }
[18:06:05.468]                 else {
[18:06:05.468]                   if (TRUE) {
[18:06:05.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.468]                     {
[18:06:05.468]                       inherits <- base::inherits
[18:06:05.468]                       invokeRestart <- base::invokeRestart
[18:06:05.468]                       is.null <- base::is.null
[18:06:05.468]                       muffled <- FALSE
[18:06:05.468]                       if (inherits(cond, "message")) {
[18:06:05.468]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.468]                         if (muffled) 
[18:06:05.468]                           invokeRestart("muffleMessage")
[18:06:05.468]                       }
[18:06:05.468]                       else if (inherits(cond, "warning")) {
[18:06:05.468]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.468]                         if (muffled) 
[18:06:05.468]                           invokeRestart("muffleWarning")
[18:06:05.468]                       }
[18:06:05.468]                       else if (inherits(cond, "condition")) {
[18:06:05.468]                         if (!is.null(pattern)) {
[18:06:05.468]                           computeRestarts <- base::computeRestarts
[18:06:05.468]                           grepl <- base::grepl
[18:06:05.468]                           restarts <- computeRestarts(cond)
[18:06:05.468]                           for (restart in restarts) {
[18:06:05.468]                             name <- restart$name
[18:06:05.468]                             if (is.null(name)) 
[18:06:05.468]                               next
[18:06:05.468]                             if (!grepl(pattern, name)) 
[18:06:05.468]                               next
[18:06:05.468]                             invokeRestart(restart)
[18:06:05.468]                             muffled <- TRUE
[18:06:05.468]                             break
[18:06:05.468]                           }
[18:06:05.468]                         }
[18:06:05.468]                       }
[18:06:05.468]                       invisible(muffled)
[18:06:05.468]                     }
[18:06:05.468]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.468]                   }
[18:06:05.468]                 }
[18:06:05.468]             }
[18:06:05.468]         }))
[18:06:05.468]     }, error = function(ex) {
[18:06:05.468]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.468]                 ...future.rng), started = ...future.startTime, 
[18:06:05.468]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.468]             version = "1.8"), class = "FutureResult")
[18:06:05.468]     }, finally = {
[18:06:05.468]         if (!identical(...future.workdir, getwd())) 
[18:06:05.468]             setwd(...future.workdir)
[18:06:05.468]         {
[18:06:05.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.468]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.468]             }
[18:06:05.468]             base::options(...future.oldOptions)
[18:06:05.468]             if (.Platform$OS.type == "windows") {
[18:06:05.468]                 old_names <- names(...future.oldEnvVars)
[18:06:05.468]                 envs <- base::Sys.getenv()
[18:06:05.468]                 names <- names(envs)
[18:06:05.468]                 common <- intersect(names, old_names)
[18:06:05.468]                 added <- setdiff(names, old_names)
[18:06:05.468]                 removed <- setdiff(old_names, names)
[18:06:05.468]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.468]                   envs[common]]
[18:06:05.468]                 NAMES <- toupper(changed)
[18:06:05.468]                 args <- list()
[18:06:05.468]                 for (kk in seq_along(NAMES)) {
[18:06:05.468]                   name <- changed[[kk]]
[18:06:05.468]                   NAME <- NAMES[[kk]]
[18:06:05.468]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.468]                     next
[18:06:05.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.468]                 }
[18:06:05.468]                 NAMES <- toupper(added)
[18:06:05.468]                 for (kk in seq_along(NAMES)) {
[18:06:05.468]                   name <- added[[kk]]
[18:06:05.468]                   NAME <- NAMES[[kk]]
[18:06:05.468]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.468]                     next
[18:06:05.468]                   args[[name]] <- ""
[18:06:05.468]                 }
[18:06:05.468]                 NAMES <- toupper(removed)
[18:06:05.468]                 for (kk in seq_along(NAMES)) {
[18:06:05.468]                   name <- removed[[kk]]
[18:06:05.468]                   NAME <- NAMES[[kk]]
[18:06:05.468]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.468]                     next
[18:06:05.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.468]                 }
[18:06:05.468]                 if (length(args) > 0) 
[18:06:05.468]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.468]             }
[18:06:05.468]             else {
[18:06:05.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.468]             }
[18:06:05.468]             {
[18:06:05.468]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.468]                   0L) {
[18:06:05.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.468]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.468]                   base::options(opts)
[18:06:05.468]                 }
[18:06:05.468]                 {
[18:06:05.468]                   {
[18:06:05.468]                     NULL
[18:06:05.468]                     RNGkind("Mersenne-Twister")
[18:06:05.468]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.468]                       inherits = FALSE)
[18:06:05.468]                   }
[18:06:05.468]                   options(future.plan = NULL)
[18:06:05.468]                   if (is.na(NA_character_)) 
[18:06:05.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.468]                     .init = FALSE)
[18:06:05.468]                 }
[18:06:05.468]             }
[18:06:05.468]         }
[18:06:05.468]     })
[18:06:05.468]     if (TRUE) {
[18:06:05.468]         base::sink(type = "output", split = FALSE)
[18:06:05.468]         if (TRUE) {
[18:06:05.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.468]         }
[18:06:05.468]         else {
[18:06:05.468]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.468]         }
[18:06:05.468]         base::close(...future.stdout)
[18:06:05.468]         ...future.stdout <- NULL
[18:06:05.468]     }
[18:06:05.468]     ...future.result$conditions <- ...future.conditions
[18:06:05.468]     ...future.result$finished <- base::Sys.time()
[18:06:05.468]     ...future.result
[18:06:05.468] }
[18:06:05.472] plan(): Setting new future strategy stack:
[18:06:05.472] List of future strategies:
[18:06:05.472] 1. sequential:
[18:06:05.472]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.472]    - tweaked: FALSE
[18:06:05.472]    - call: NULL
[18:06:05.473] plan(): nbrOfWorkers() = 1
[18:06:05.475] plan(): Setting new future strategy stack:
[18:06:05.475] List of future strategies:
[18:06:05.475] 1. sequential:
[18:06:05.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.475]    - tweaked: FALSE
[18:06:05.475]    - call: plan(strategy)
[18:06:05.476] plan(): nbrOfWorkers() = 1
[18:06:05.477] SequentialFuture started (and completed)
[18:06:05.477] - Launch lazy future ... done
[18:06:05.477] run() for ‘SequentialFuture’ ... done
[18:06:05.478] getGlobalsAndPackages() ...
[18:06:05.478] Searching for globals...
[18:06:05.479] 
[18:06:05.479] Searching for globals ... DONE
[18:06:05.479] - globals: [0] <none>
[18:06:05.480] getGlobalsAndPackages() ... DONE
[18:06:05.480] run() for ‘Future’ ...
[18:06:05.480] - state: ‘created’
[18:06:05.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.482]   - Field: ‘label’
[18:06:05.482]   - Field: ‘local’
[18:06:05.482]   - Field: ‘owner’
[18:06:05.482]   - Field: ‘envir’
[18:06:05.483]   - Field: ‘packages’
[18:06:05.483]   - Field: ‘gc’
[18:06:05.483]   - Field: ‘conditions’
[18:06:05.483]   - Field: ‘expr’
[18:06:05.483]   - Field: ‘uuid’
[18:06:05.484]   - Field: ‘seed’
[18:06:05.484]   - Field: ‘version’
[18:06:05.484]   - Field: ‘result’
[18:06:05.484]   - Field: ‘asynchronous’
[18:06:05.484]   - Field: ‘calls’
[18:06:05.485]   - Field: ‘globals’
[18:06:05.485]   - Field: ‘stdout’
[18:06:05.485]   - Field: ‘earlySignal’
[18:06:05.486]   - Field: ‘lazy’
[18:06:05.486]   - Field: ‘state’
[18:06:05.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.486] - Launch lazy future ...
[18:06:05.487] Packages needed by the future expression (n = 0): <none>
[18:06:05.487] Packages needed by future strategies (n = 0): <none>
[18:06:05.488] {
[18:06:05.488]     {
[18:06:05.488]         {
[18:06:05.488]             ...future.startTime <- base::Sys.time()
[18:06:05.488]             {
[18:06:05.488]                 {
[18:06:05.488]                   {
[18:06:05.488]                     base::local({
[18:06:05.488]                       has_future <- base::requireNamespace("future", 
[18:06:05.488]                         quietly = TRUE)
[18:06:05.488]                       if (has_future) {
[18:06:05.488]                         ns <- base::getNamespace("future")
[18:06:05.488]                         version <- ns[[".package"]][["version"]]
[18:06:05.488]                         if (is.null(version)) 
[18:06:05.488]                           version <- utils::packageVersion("future")
[18:06:05.488]                       }
[18:06:05.488]                       else {
[18:06:05.488]                         version <- NULL
[18:06:05.488]                       }
[18:06:05.488]                       if (!has_future || version < "1.8.0") {
[18:06:05.488]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.488]                           "", base::R.version$version.string), 
[18:06:05.488]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.488]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.488]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.488]                             "release", "version")], collapse = " "), 
[18:06:05.488]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.488]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.488]                           info)
[18:06:05.488]                         info <- base::paste(info, collapse = "; ")
[18:06:05.488]                         if (!has_future) {
[18:06:05.488]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.488]                             info)
[18:06:05.488]                         }
[18:06:05.488]                         else {
[18:06:05.488]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.488]                             info, version)
[18:06:05.488]                         }
[18:06:05.488]                         base::stop(msg)
[18:06:05.488]                       }
[18:06:05.488]                     })
[18:06:05.488]                   }
[18:06:05.488]                   ...future.strategy.old <- future::plan("list")
[18:06:05.488]                   options(future.plan = NULL)
[18:06:05.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.488]                 }
[18:06:05.488]                 ...future.workdir <- getwd()
[18:06:05.488]             }
[18:06:05.488]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.488]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.488]         }
[18:06:05.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.488]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.488]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.488]             base::names(...future.oldOptions))
[18:06:05.488]     }
[18:06:05.488]     if (FALSE) {
[18:06:05.488]     }
[18:06:05.488]     else {
[18:06:05.488]         if (TRUE) {
[18:06:05.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.488]                 open = "w")
[18:06:05.488]         }
[18:06:05.488]         else {
[18:06:05.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.488]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.488]         }
[18:06:05.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.488]             base::sink(type = "output", split = FALSE)
[18:06:05.488]             base::close(...future.stdout)
[18:06:05.488]         }, add = TRUE)
[18:06:05.488]     }
[18:06:05.488]     ...future.frame <- base::sys.nframe()
[18:06:05.488]     ...future.conditions <- base::list()
[18:06:05.488]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.488]     if (FALSE) {
[18:06:05.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.488]     }
[18:06:05.488]     ...future.result <- base::tryCatch({
[18:06:05.488]         base::withCallingHandlers({
[18:06:05.488]             ...future.value <- base::withVisible(base::local(2))
[18:06:05.488]             future::FutureResult(value = ...future.value$value, 
[18:06:05.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.488]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.488]                     ...future.globalenv.names))
[18:06:05.488]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.488]         }, condition = base::local({
[18:06:05.488]             c <- base::c
[18:06:05.488]             inherits <- base::inherits
[18:06:05.488]             invokeRestart <- base::invokeRestart
[18:06:05.488]             length <- base::length
[18:06:05.488]             list <- base::list
[18:06:05.488]             seq.int <- base::seq.int
[18:06:05.488]             signalCondition <- base::signalCondition
[18:06:05.488]             sys.calls <- base::sys.calls
[18:06:05.488]             `[[` <- base::`[[`
[18:06:05.488]             `+` <- base::`+`
[18:06:05.488]             `<<-` <- base::`<<-`
[18:06:05.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.488]                   3L)]
[18:06:05.488]             }
[18:06:05.488]             function(cond) {
[18:06:05.488]                 is_error <- inherits(cond, "error")
[18:06:05.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.488]                   NULL)
[18:06:05.488]                 if (is_error) {
[18:06:05.488]                   sessionInformation <- function() {
[18:06:05.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.488]                       search = base::search(), system = base::Sys.info())
[18:06:05.488]                   }
[18:06:05.488]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.488]                     cond$call), session = sessionInformation(), 
[18:06:05.488]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.488]                   signalCondition(cond)
[18:06:05.488]                 }
[18:06:05.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.488]                 "immediateCondition"))) {
[18:06:05.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.488]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.488]                   if (TRUE && !signal) {
[18:06:05.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.488]                     {
[18:06:05.488]                       inherits <- base::inherits
[18:06:05.488]                       invokeRestart <- base::invokeRestart
[18:06:05.488]                       is.null <- base::is.null
[18:06:05.488]                       muffled <- FALSE
[18:06:05.488]                       if (inherits(cond, "message")) {
[18:06:05.488]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.488]                         if (muffled) 
[18:06:05.488]                           invokeRestart("muffleMessage")
[18:06:05.488]                       }
[18:06:05.488]                       else if (inherits(cond, "warning")) {
[18:06:05.488]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.488]                         if (muffled) 
[18:06:05.488]                           invokeRestart("muffleWarning")
[18:06:05.488]                       }
[18:06:05.488]                       else if (inherits(cond, "condition")) {
[18:06:05.488]                         if (!is.null(pattern)) {
[18:06:05.488]                           computeRestarts <- base::computeRestarts
[18:06:05.488]                           grepl <- base::grepl
[18:06:05.488]                           restarts <- computeRestarts(cond)
[18:06:05.488]                           for (restart in restarts) {
[18:06:05.488]                             name <- restart$name
[18:06:05.488]                             if (is.null(name)) 
[18:06:05.488]                               next
[18:06:05.488]                             if (!grepl(pattern, name)) 
[18:06:05.488]                               next
[18:06:05.488]                             invokeRestart(restart)
[18:06:05.488]                             muffled <- TRUE
[18:06:05.488]                             break
[18:06:05.488]                           }
[18:06:05.488]                         }
[18:06:05.488]                       }
[18:06:05.488]                       invisible(muffled)
[18:06:05.488]                     }
[18:06:05.488]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.488]                   }
[18:06:05.488]                 }
[18:06:05.488]                 else {
[18:06:05.488]                   if (TRUE) {
[18:06:05.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.488]                     {
[18:06:05.488]                       inherits <- base::inherits
[18:06:05.488]                       invokeRestart <- base::invokeRestart
[18:06:05.488]                       is.null <- base::is.null
[18:06:05.488]                       muffled <- FALSE
[18:06:05.488]                       if (inherits(cond, "message")) {
[18:06:05.488]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.488]                         if (muffled) 
[18:06:05.488]                           invokeRestart("muffleMessage")
[18:06:05.488]                       }
[18:06:05.488]                       else if (inherits(cond, "warning")) {
[18:06:05.488]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.488]                         if (muffled) 
[18:06:05.488]                           invokeRestart("muffleWarning")
[18:06:05.488]                       }
[18:06:05.488]                       else if (inherits(cond, "condition")) {
[18:06:05.488]                         if (!is.null(pattern)) {
[18:06:05.488]                           computeRestarts <- base::computeRestarts
[18:06:05.488]                           grepl <- base::grepl
[18:06:05.488]                           restarts <- computeRestarts(cond)
[18:06:05.488]                           for (restart in restarts) {
[18:06:05.488]                             name <- restart$name
[18:06:05.488]                             if (is.null(name)) 
[18:06:05.488]                               next
[18:06:05.488]                             if (!grepl(pattern, name)) 
[18:06:05.488]                               next
[18:06:05.488]                             invokeRestart(restart)
[18:06:05.488]                             muffled <- TRUE
[18:06:05.488]                             break
[18:06:05.488]                           }
[18:06:05.488]                         }
[18:06:05.488]                       }
[18:06:05.488]                       invisible(muffled)
[18:06:05.488]                     }
[18:06:05.488]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.488]                   }
[18:06:05.488]                 }
[18:06:05.488]             }
[18:06:05.488]         }))
[18:06:05.488]     }, error = function(ex) {
[18:06:05.488]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.488]                 ...future.rng), started = ...future.startTime, 
[18:06:05.488]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.488]             version = "1.8"), class = "FutureResult")
[18:06:05.488]     }, finally = {
[18:06:05.488]         if (!identical(...future.workdir, getwd())) 
[18:06:05.488]             setwd(...future.workdir)
[18:06:05.488]         {
[18:06:05.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.488]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.488]             }
[18:06:05.488]             base::options(...future.oldOptions)
[18:06:05.488]             if (.Platform$OS.type == "windows") {
[18:06:05.488]                 old_names <- names(...future.oldEnvVars)
[18:06:05.488]                 envs <- base::Sys.getenv()
[18:06:05.488]                 names <- names(envs)
[18:06:05.488]                 common <- intersect(names, old_names)
[18:06:05.488]                 added <- setdiff(names, old_names)
[18:06:05.488]                 removed <- setdiff(old_names, names)
[18:06:05.488]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.488]                   envs[common]]
[18:06:05.488]                 NAMES <- toupper(changed)
[18:06:05.488]                 args <- list()
[18:06:05.488]                 for (kk in seq_along(NAMES)) {
[18:06:05.488]                   name <- changed[[kk]]
[18:06:05.488]                   NAME <- NAMES[[kk]]
[18:06:05.488]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.488]                     next
[18:06:05.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.488]                 }
[18:06:05.488]                 NAMES <- toupper(added)
[18:06:05.488]                 for (kk in seq_along(NAMES)) {
[18:06:05.488]                   name <- added[[kk]]
[18:06:05.488]                   NAME <- NAMES[[kk]]
[18:06:05.488]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.488]                     next
[18:06:05.488]                   args[[name]] <- ""
[18:06:05.488]                 }
[18:06:05.488]                 NAMES <- toupper(removed)
[18:06:05.488]                 for (kk in seq_along(NAMES)) {
[18:06:05.488]                   name <- removed[[kk]]
[18:06:05.488]                   NAME <- NAMES[[kk]]
[18:06:05.488]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.488]                     next
[18:06:05.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.488]                 }
[18:06:05.488]                 if (length(args) > 0) 
[18:06:05.488]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.488]             }
[18:06:05.488]             else {
[18:06:05.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.488]             }
[18:06:05.488]             {
[18:06:05.488]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.488]                   0L) {
[18:06:05.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.488]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.488]                   base::options(opts)
[18:06:05.488]                 }
[18:06:05.488]                 {
[18:06:05.488]                   {
[18:06:05.488]                     NULL
[18:06:05.488]                     RNGkind("Mersenne-Twister")
[18:06:05.488]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.488]                       inherits = FALSE)
[18:06:05.488]                   }
[18:06:05.488]                   options(future.plan = NULL)
[18:06:05.488]                   if (is.na(NA_character_)) 
[18:06:05.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.488]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.488]                     .init = FALSE)
[18:06:05.488]                 }
[18:06:05.488]             }
[18:06:05.488]         }
[18:06:05.488]     })
[18:06:05.488]     if (TRUE) {
[18:06:05.488]         base::sink(type = "output", split = FALSE)
[18:06:05.488]         if (TRUE) {
[18:06:05.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.488]         }
[18:06:05.488]         else {
[18:06:05.488]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.488]         }
[18:06:05.488]         base::close(...future.stdout)
[18:06:05.488]         ...future.stdout <- NULL
[18:06:05.488]     }
[18:06:05.488]     ...future.result$conditions <- ...future.conditions
[18:06:05.488]     ...future.result$finished <- base::Sys.time()
[18:06:05.488]     ...future.result
[18:06:05.488] }
[18:06:05.492] plan(): Setting new future strategy stack:
[18:06:05.492] List of future strategies:
[18:06:05.492] 1. sequential:
[18:06:05.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.492]    - tweaked: FALSE
[18:06:05.492]    - call: NULL
[18:06:05.493] plan(): nbrOfWorkers() = 1
[18:06:05.498] plan(): Setting new future strategy stack:
[18:06:05.498] List of future strategies:
[18:06:05.498] 1. sequential:
[18:06:05.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.498]    - tweaked: FALSE
[18:06:05.498]    - call: plan(strategy)
[18:06:05.499] plan(): nbrOfWorkers() = 1
[18:06:05.499] SequentialFuture started (and completed)
[18:06:05.500] - Launch lazy future ... done
[18:06:05.500] run() for ‘SequentialFuture’ ... done
[18:06:05.501] resolve() on list environment ...
[18:06:05.501]  recursive: 0
[18:06:05.503]  length: 3
[18:06:05.503]  elements: ‘a’, ‘b’, ‘c’
[18:06:05.503] resolved() for ‘SequentialFuture’ ...
[18:06:05.503] - state: ‘finished’
[18:06:05.504] - run: TRUE
[18:06:05.504] - result: ‘FutureResult’
[18:06:05.504] resolved() for ‘SequentialFuture’ ... done
[18:06:05.504] Future #1
[18:06:05.505]  length: 2 (resolved future 1)
[18:06:05.505] resolved() for ‘SequentialFuture’ ...
[18:06:05.505] - state: ‘finished’
[18:06:05.505] - run: TRUE
[18:06:05.506] - result: ‘FutureResult’
[18:06:05.506] resolved() for ‘SequentialFuture’ ... done
[18:06:05.506] Future #2
[18:06:05.506]  length: 1 (resolved future 2)
[18:06:05.506]  length: 0 (resolved future 3)
[18:06:05.507] resolve() on list environment ... DONE
[18:06:05.508] getGlobalsAndPackages() ...
[18:06:05.508] Searching for globals...
[18:06:05.510] - globals found: [1] ‘{’
[18:06:05.510] Searching for globals ... DONE
[18:06:05.510] Resolving globals: FALSE
[18:06:05.511] 
[18:06:05.511] 
[18:06:05.511] getGlobalsAndPackages() ... DONE
[18:06:05.512] run() for ‘Future’ ...
[18:06:05.512] - state: ‘created’
[18:06:05.512] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.513]   - Field: ‘label’
[18:06:05.514]   - Field: ‘local’
[18:06:05.514]   - Field: ‘owner’
[18:06:05.514]   - Field: ‘envir’
[18:06:05.514]   - Field: ‘packages’
[18:06:05.515]   - Field: ‘gc’
[18:06:05.515]   - Field: ‘conditions’
[18:06:05.515]   - Field: ‘expr’
[18:06:05.515]   - Field: ‘uuid’
[18:06:05.515]   - Field: ‘seed’
[18:06:05.516]   - Field: ‘version’
[18:06:05.516]   - Field: ‘result’
[18:06:05.516]   - Field: ‘asynchronous’
[18:06:05.516]   - Field: ‘calls’
[18:06:05.516]   - Field: ‘globals’
[18:06:05.517]   - Field: ‘stdout’
[18:06:05.517]   - Field: ‘earlySignal’
[18:06:05.517]   - Field: ‘lazy’
[18:06:05.517]   - Field: ‘state’
[18:06:05.517] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.518] - Launch lazy future ...
[18:06:05.518] Packages needed by the future expression (n = 0): <none>
[18:06:05.518] Packages needed by future strategies (n = 0): <none>
[18:06:05.519] {
[18:06:05.519]     {
[18:06:05.519]         {
[18:06:05.519]             ...future.startTime <- base::Sys.time()
[18:06:05.519]             {
[18:06:05.519]                 {
[18:06:05.519]                   {
[18:06:05.519]                     base::local({
[18:06:05.519]                       has_future <- base::requireNamespace("future", 
[18:06:05.519]                         quietly = TRUE)
[18:06:05.519]                       if (has_future) {
[18:06:05.519]                         ns <- base::getNamespace("future")
[18:06:05.519]                         version <- ns[[".package"]][["version"]]
[18:06:05.519]                         if (is.null(version)) 
[18:06:05.519]                           version <- utils::packageVersion("future")
[18:06:05.519]                       }
[18:06:05.519]                       else {
[18:06:05.519]                         version <- NULL
[18:06:05.519]                       }
[18:06:05.519]                       if (!has_future || version < "1.8.0") {
[18:06:05.519]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.519]                           "", base::R.version$version.string), 
[18:06:05.519]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.519]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.519]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.519]                             "release", "version")], collapse = " "), 
[18:06:05.519]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.519]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.519]                           info)
[18:06:05.519]                         info <- base::paste(info, collapse = "; ")
[18:06:05.519]                         if (!has_future) {
[18:06:05.519]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.519]                             info)
[18:06:05.519]                         }
[18:06:05.519]                         else {
[18:06:05.519]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.519]                             info, version)
[18:06:05.519]                         }
[18:06:05.519]                         base::stop(msg)
[18:06:05.519]                       }
[18:06:05.519]                     })
[18:06:05.519]                   }
[18:06:05.519]                   ...future.strategy.old <- future::plan("list")
[18:06:05.519]                   options(future.plan = NULL)
[18:06:05.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.519]                 }
[18:06:05.519]                 ...future.workdir <- getwd()
[18:06:05.519]             }
[18:06:05.519]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.519]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.519]         }
[18:06:05.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.519]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.519]             base::names(...future.oldOptions))
[18:06:05.519]     }
[18:06:05.519]     if (FALSE) {
[18:06:05.519]     }
[18:06:05.519]     else {
[18:06:05.519]         if (TRUE) {
[18:06:05.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.519]                 open = "w")
[18:06:05.519]         }
[18:06:05.519]         else {
[18:06:05.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.519]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.519]         }
[18:06:05.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.519]             base::sink(type = "output", split = FALSE)
[18:06:05.519]             base::close(...future.stdout)
[18:06:05.519]         }, add = TRUE)
[18:06:05.519]     }
[18:06:05.519]     ...future.frame <- base::sys.nframe()
[18:06:05.519]     ...future.conditions <- base::list()
[18:06:05.519]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.519]     if (FALSE) {
[18:06:05.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.519]     }
[18:06:05.519]     ...future.result <- base::tryCatch({
[18:06:05.519]         base::withCallingHandlers({
[18:06:05.519]             ...future.value <- base::withVisible(base::local({
[18:06:05.519]                 1
[18:06:05.519]             }))
[18:06:05.519]             future::FutureResult(value = ...future.value$value, 
[18:06:05.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.519]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.519]                     ...future.globalenv.names))
[18:06:05.519]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.519]         }, condition = base::local({
[18:06:05.519]             c <- base::c
[18:06:05.519]             inherits <- base::inherits
[18:06:05.519]             invokeRestart <- base::invokeRestart
[18:06:05.519]             length <- base::length
[18:06:05.519]             list <- base::list
[18:06:05.519]             seq.int <- base::seq.int
[18:06:05.519]             signalCondition <- base::signalCondition
[18:06:05.519]             sys.calls <- base::sys.calls
[18:06:05.519]             `[[` <- base::`[[`
[18:06:05.519]             `+` <- base::`+`
[18:06:05.519]             `<<-` <- base::`<<-`
[18:06:05.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.519]                   3L)]
[18:06:05.519]             }
[18:06:05.519]             function(cond) {
[18:06:05.519]                 is_error <- inherits(cond, "error")
[18:06:05.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.519]                   NULL)
[18:06:05.519]                 if (is_error) {
[18:06:05.519]                   sessionInformation <- function() {
[18:06:05.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.519]                       search = base::search(), system = base::Sys.info())
[18:06:05.519]                   }
[18:06:05.519]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.519]                     cond$call), session = sessionInformation(), 
[18:06:05.519]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.519]                   signalCondition(cond)
[18:06:05.519]                 }
[18:06:05.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.519]                 "immediateCondition"))) {
[18:06:05.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.519]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.519]                   if (TRUE && !signal) {
[18:06:05.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.519]                     {
[18:06:05.519]                       inherits <- base::inherits
[18:06:05.519]                       invokeRestart <- base::invokeRestart
[18:06:05.519]                       is.null <- base::is.null
[18:06:05.519]                       muffled <- FALSE
[18:06:05.519]                       if (inherits(cond, "message")) {
[18:06:05.519]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.519]                         if (muffled) 
[18:06:05.519]                           invokeRestart("muffleMessage")
[18:06:05.519]                       }
[18:06:05.519]                       else if (inherits(cond, "warning")) {
[18:06:05.519]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.519]                         if (muffled) 
[18:06:05.519]                           invokeRestart("muffleWarning")
[18:06:05.519]                       }
[18:06:05.519]                       else if (inherits(cond, "condition")) {
[18:06:05.519]                         if (!is.null(pattern)) {
[18:06:05.519]                           computeRestarts <- base::computeRestarts
[18:06:05.519]                           grepl <- base::grepl
[18:06:05.519]                           restarts <- computeRestarts(cond)
[18:06:05.519]                           for (restart in restarts) {
[18:06:05.519]                             name <- restart$name
[18:06:05.519]                             if (is.null(name)) 
[18:06:05.519]                               next
[18:06:05.519]                             if (!grepl(pattern, name)) 
[18:06:05.519]                               next
[18:06:05.519]                             invokeRestart(restart)
[18:06:05.519]                             muffled <- TRUE
[18:06:05.519]                             break
[18:06:05.519]                           }
[18:06:05.519]                         }
[18:06:05.519]                       }
[18:06:05.519]                       invisible(muffled)
[18:06:05.519]                     }
[18:06:05.519]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.519]                   }
[18:06:05.519]                 }
[18:06:05.519]                 else {
[18:06:05.519]                   if (TRUE) {
[18:06:05.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.519]                     {
[18:06:05.519]                       inherits <- base::inherits
[18:06:05.519]                       invokeRestart <- base::invokeRestart
[18:06:05.519]                       is.null <- base::is.null
[18:06:05.519]                       muffled <- FALSE
[18:06:05.519]                       if (inherits(cond, "message")) {
[18:06:05.519]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.519]                         if (muffled) 
[18:06:05.519]                           invokeRestart("muffleMessage")
[18:06:05.519]                       }
[18:06:05.519]                       else if (inherits(cond, "warning")) {
[18:06:05.519]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.519]                         if (muffled) 
[18:06:05.519]                           invokeRestart("muffleWarning")
[18:06:05.519]                       }
[18:06:05.519]                       else if (inherits(cond, "condition")) {
[18:06:05.519]                         if (!is.null(pattern)) {
[18:06:05.519]                           computeRestarts <- base::computeRestarts
[18:06:05.519]                           grepl <- base::grepl
[18:06:05.519]                           restarts <- computeRestarts(cond)
[18:06:05.519]                           for (restart in restarts) {
[18:06:05.519]                             name <- restart$name
[18:06:05.519]                             if (is.null(name)) 
[18:06:05.519]                               next
[18:06:05.519]                             if (!grepl(pattern, name)) 
[18:06:05.519]                               next
[18:06:05.519]                             invokeRestart(restart)
[18:06:05.519]                             muffled <- TRUE
[18:06:05.519]                             break
[18:06:05.519]                           }
[18:06:05.519]                         }
[18:06:05.519]                       }
[18:06:05.519]                       invisible(muffled)
[18:06:05.519]                     }
[18:06:05.519]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.519]                   }
[18:06:05.519]                 }
[18:06:05.519]             }
[18:06:05.519]         }))
[18:06:05.519]     }, error = function(ex) {
[18:06:05.519]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.519]                 ...future.rng), started = ...future.startTime, 
[18:06:05.519]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.519]             version = "1.8"), class = "FutureResult")
[18:06:05.519]     }, finally = {
[18:06:05.519]         if (!identical(...future.workdir, getwd())) 
[18:06:05.519]             setwd(...future.workdir)
[18:06:05.519]         {
[18:06:05.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.519]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.519]             }
[18:06:05.519]             base::options(...future.oldOptions)
[18:06:05.519]             if (.Platform$OS.type == "windows") {
[18:06:05.519]                 old_names <- names(...future.oldEnvVars)
[18:06:05.519]                 envs <- base::Sys.getenv()
[18:06:05.519]                 names <- names(envs)
[18:06:05.519]                 common <- intersect(names, old_names)
[18:06:05.519]                 added <- setdiff(names, old_names)
[18:06:05.519]                 removed <- setdiff(old_names, names)
[18:06:05.519]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.519]                   envs[common]]
[18:06:05.519]                 NAMES <- toupper(changed)
[18:06:05.519]                 args <- list()
[18:06:05.519]                 for (kk in seq_along(NAMES)) {
[18:06:05.519]                   name <- changed[[kk]]
[18:06:05.519]                   NAME <- NAMES[[kk]]
[18:06:05.519]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.519]                     next
[18:06:05.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.519]                 }
[18:06:05.519]                 NAMES <- toupper(added)
[18:06:05.519]                 for (kk in seq_along(NAMES)) {
[18:06:05.519]                   name <- added[[kk]]
[18:06:05.519]                   NAME <- NAMES[[kk]]
[18:06:05.519]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.519]                     next
[18:06:05.519]                   args[[name]] <- ""
[18:06:05.519]                 }
[18:06:05.519]                 NAMES <- toupper(removed)
[18:06:05.519]                 for (kk in seq_along(NAMES)) {
[18:06:05.519]                   name <- removed[[kk]]
[18:06:05.519]                   NAME <- NAMES[[kk]]
[18:06:05.519]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.519]                     next
[18:06:05.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.519]                 }
[18:06:05.519]                 if (length(args) > 0) 
[18:06:05.519]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.519]             }
[18:06:05.519]             else {
[18:06:05.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.519]             }
[18:06:05.519]             {
[18:06:05.519]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.519]                   0L) {
[18:06:05.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.519]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.519]                   base::options(opts)
[18:06:05.519]                 }
[18:06:05.519]                 {
[18:06:05.519]                   {
[18:06:05.519]                     NULL
[18:06:05.519]                     RNGkind("Mersenne-Twister")
[18:06:05.519]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.519]                       inherits = FALSE)
[18:06:05.519]                   }
[18:06:05.519]                   options(future.plan = NULL)
[18:06:05.519]                   if (is.na(NA_character_)) 
[18:06:05.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.519]                     .init = FALSE)
[18:06:05.519]                 }
[18:06:05.519]             }
[18:06:05.519]         }
[18:06:05.519]     })
[18:06:05.519]     if (TRUE) {
[18:06:05.519]         base::sink(type = "output", split = FALSE)
[18:06:05.519]         if (TRUE) {
[18:06:05.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.519]         }
[18:06:05.519]         else {
[18:06:05.519]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.519]         }
[18:06:05.519]         base::close(...future.stdout)
[18:06:05.519]         ...future.stdout <- NULL
[18:06:05.519]     }
[18:06:05.519]     ...future.result$conditions <- ...future.conditions
[18:06:05.519]     ...future.result$finished <- base::Sys.time()
[18:06:05.519]     ...future.result
[18:06:05.519] }
[18:06:05.523] plan(): Setting new future strategy stack:
[18:06:05.523] List of future strategies:
[18:06:05.523] 1. sequential:
[18:06:05.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.523]    - tweaked: FALSE
[18:06:05.523]    - call: NULL
[18:06:05.524] plan(): nbrOfWorkers() = 1
[18:06:05.526] plan(): Setting new future strategy stack:
[18:06:05.526] List of future strategies:
[18:06:05.526] 1. sequential:
[18:06:05.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.526]    - tweaked: FALSE
[18:06:05.526]    - call: plan(strategy)
[18:06:05.527] plan(): nbrOfWorkers() = 1
[18:06:05.528] SequentialFuture started (and completed)
[18:06:05.528] - Launch lazy future ... done
[18:06:05.528] run() for ‘SequentialFuture’ ... done
[18:06:05.529] getGlobalsAndPackages() ...
[18:06:05.529] Searching for globals...
[18:06:05.530] - globals found: [1] ‘{’
[18:06:05.531] Searching for globals ... DONE
[18:06:05.531] Resolving globals: FALSE
[18:06:05.531] 
[18:06:05.532] 
[18:06:05.532] getGlobalsAndPackages() ... DONE
[18:06:05.532] run() for ‘Future’ ...
[18:06:05.533] - state: ‘created’
[18:06:05.533] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.534] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.534]   - Field: ‘label’
[18:06:05.534]   - Field: ‘local’
[18:06:05.534]   - Field: ‘owner’
[18:06:05.535]   - Field: ‘envir’
[18:06:05.535]   - Field: ‘packages’
[18:06:05.535]   - Field: ‘gc’
[18:06:05.535]   - Field: ‘conditions’
[18:06:05.535]   - Field: ‘expr’
[18:06:05.536]   - Field: ‘uuid’
[18:06:05.536]   - Field: ‘seed’
[18:06:05.536]   - Field: ‘version’
[18:06:05.536]   - Field: ‘result’
[18:06:05.536]   - Field: ‘asynchronous’
[18:06:05.537]   - Field: ‘calls’
[18:06:05.537]   - Field: ‘globals’
[18:06:05.537]   - Field: ‘stdout’
[18:06:05.537]   - Field: ‘earlySignal’
[18:06:05.537]   - Field: ‘lazy’
[18:06:05.538]   - Field: ‘state’
[18:06:05.538] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.538] - Launch lazy future ...
[18:06:05.539] Packages needed by the future expression (n = 0): <none>
[18:06:05.539] Packages needed by future strategies (n = 0): <none>
[18:06:05.540] {
[18:06:05.540]     {
[18:06:05.540]         {
[18:06:05.540]             ...future.startTime <- base::Sys.time()
[18:06:05.540]             {
[18:06:05.540]                 {
[18:06:05.540]                   {
[18:06:05.540]                     base::local({
[18:06:05.540]                       has_future <- base::requireNamespace("future", 
[18:06:05.540]                         quietly = TRUE)
[18:06:05.540]                       if (has_future) {
[18:06:05.540]                         ns <- base::getNamespace("future")
[18:06:05.540]                         version <- ns[[".package"]][["version"]]
[18:06:05.540]                         if (is.null(version)) 
[18:06:05.540]                           version <- utils::packageVersion("future")
[18:06:05.540]                       }
[18:06:05.540]                       else {
[18:06:05.540]                         version <- NULL
[18:06:05.540]                       }
[18:06:05.540]                       if (!has_future || version < "1.8.0") {
[18:06:05.540]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.540]                           "", base::R.version$version.string), 
[18:06:05.540]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.540]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.540]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.540]                             "release", "version")], collapse = " "), 
[18:06:05.540]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.540]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.540]                           info)
[18:06:05.540]                         info <- base::paste(info, collapse = "; ")
[18:06:05.540]                         if (!has_future) {
[18:06:05.540]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.540]                             info)
[18:06:05.540]                         }
[18:06:05.540]                         else {
[18:06:05.540]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.540]                             info, version)
[18:06:05.540]                         }
[18:06:05.540]                         base::stop(msg)
[18:06:05.540]                       }
[18:06:05.540]                     })
[18:06:05.540]                   }
[18:06:05.540]                   ...future.strategy.old <- future::plan("list")
[18:06:05.540]                   options(future.plan = NULL)
[18:06:05.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.540]                 }
[18:06:05.540]                 ...future.workdir <- getwd()
[18:06:05.540]             }
[18:06:05.540]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.540]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.540]         }
[18:06:05.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.540]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.540]             base::names(...future.oldOptions))
[18:06:05.540]     }
[18:06:05.540]     if (FALSE) {
[18:06:05.540]     }
[18:06:05.540]     else {
[18:06:05.540]         if (TRUE) {
[18:06:05.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.540]                 open = "w")
[18:06:05.540]         }
[18:06:05.540]         else {
[18:06:05.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.540]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.540]         }
[18:06:05.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.540]             base::sink(type = "output", split = FALSE)
[18:06:05.540]             base::close(...future.stdout)
[18:06:05.540]         }, add = TRUE)
[18:06:05.540]     }
[18:06:05.540]     ...future.frame <- base::sys.nframe()
[18:06:05.540]     ...future.conditions <- base::list()
[18:06:05.540]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.540]     if (FALSE) {
[18:06:05.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.540]     }
[18:06:05.540]     ...future.result <- base::tryCatch({
[18:06:05.540]         base::withCallingHandlers({
[18:06:05.540]             ...future.value <- base::withVisible(base::local({
[18:06:05.540]                 2
[18:06:05.540]             }))
[18:06:05.540]             future::FutureResult(value = ...future.value$value, 
[18:06:05.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.540]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.540]                     ...future.globalenv.names))
[18:06:05.540]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.540]         }, condition = base::local({
[18:06:05.540]             c <- base::c
[18:06:05.540]             inherits <- base::inherits
[18:06:05.540]             invokeRestart <- base::invokeRestart
[18:06:05.540]             length <- base::length
[18:06:05.540]             list <- base::list
[18:06:05.540]             seq.int <- base::seq.int
[18:06:05.540]             signalCondition <- base::signalCondition
[18:06:05.540]             sys.calls <- base::sys.calls
[18:06:05.540]             `[[` <- base::`[[`
[18:06:05.540]             `+` <- base::`+`
[18:06:05.540]             `<<-` <- base::`<<-`
[18:06:05.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.540]                   3L)]
[18:06:05.540]             }
[18:06:05.540]             function(cond) {
[18:06:05.540]                 is_error <- inherits(cond, "error")
[18:06:05.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.540]                   NULL)
[18:06:05.540]                 if (is_error) {
[18:06:05.540]                   sessionInformation <- function() {
[18:06:05.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.540]                       search = base::search(), system = base::Sys.info())
[18:06:05.540]                   }
[18:06:05.540]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.540]                     cond$call), session = sessionInformation(), 
[18:06:05.540]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.540]                   signalCondition(cond)
[18:06:05.540]                 }
[18:06:05.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.540]                 "immediateCondition"))) {
[18:06:05.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.540]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.540]                   if (TRUE && !signal) {
[18:06:05.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.540]                     {
[18:06:05.540]                       inherits <- base::inherits
[18:06:05.540]                       invokeRestart <- base::invokeRestart
[18:06:05.540]                       is.null <- base::is.null
[18:06:05.540]                       muffled <- FALSE
[18:06:05.540]                       if (inherits(cond, "message")) {
[18:06:05.540]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.540]                         if (muffled) 
[18:06:05.540]                           invokeRestart("muffleMessage")
[18:06:05.540]                       }
[18:06:05.540]                       else if (inherits(cond, "warning")) {
[18:06:05.540]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.540]                         if (muffled) 
[18:06:05.540]                           invokeRestart("muffleWarning")
[18:06:05.540]                       }
[18:06:05.540]                       else if (inherits(cond, "condition")) {
[18:06:05.540]                         if (!is.null(pattern)) {
[18:06:05.540]                           computeRestarts <- base::computeRestarts
[18:06:05.540]                           grepl <- base::grepl
[18:06:05.540]                           restarts <- computeRestarts(cond)
[18:06:05.540]                           for (restart in restarts) {
[18:06:05.540]                             name <- restart$name
[18:06:05.540]                             if (is.null(name)) 
[18:06:05.540]                               next
[18:06:05.540]                             if (!grepl(pattern, name)) 
[18:06:05.540]                               next
[18:06:05.540]                             invokeRestart(restart)
[18:06:05.540]                             muffled <- TRUE
[18:06:05.540]                             break
[18:06:05.540]                           }
[18:06:05.540]                         }
[18:06:05.540]                       }
[18:06:05.540]                       invisible(muffled)
[18:06:05.540]                     }
[18:06:05.540]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.540]                   }
[18:06:05.540]                 }
[18:06:05.540]                 else {
[18:06:05.540]                   if (TRUE) {
[18:06:05.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.540]                     {
[18:06:05.540]                       inherits <- base::inherits
[18:06:05.540]                       invokeRestart <- base::invokeRestart
[18:06:05.540]                       is.null <- base::is.null
[18:06:05.540]                       muffled <- FALSE
[18:06:05.540]                       if (inherits(cond, "message")) {
[18:06:05.540]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.540]                         if (muffled) 
[18:06:05.540]                           invokeRestart("muffleMessage")
[18:06:05.540]                       }
[18:06:05.540]                       else if (inherits(cond, "warning")) {
[18:06:05.540]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.540]                         if (muffled) 
[18:06:05.540]                           invokeRestart("muffleWarning")
[18:06:05.540]                       }
[18:06:05.540]                       else if (inherits(cond, "condition")) {
[18:06:05.540]                         if (!is.null(pattern)) {
[18:06:05.540]                           computeRestarts <- base::computeRestarts
[18:06:05.540]                           grepl <- base::grepl
[18:06:05.540]                           restarts <- computeRestarts(cond)
[18:06:05.540]                           for (restart in restarts) {
[18:06:05.540]                             name <- restart$name
[18:06:05.540]                             if (is.null(name)) 
[18:06:05.540]                               next
[18:06:05.540]                             if (!grepl(pattern, name)) 
[18:06:05.540]                               next
[18:06:05.540]                             invokeRestart(restart)
[18:06:05.540]                             muffled <- TRUE
[18:06:05.540]                             break
[18:06:05.540]                           }
[18:06:05.540]                         }
[18:06:05.540]                       }
[18:06:05.540]                       invisible(muffled)
[18:06:05.540]                     }
[18:06:05.540]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.540]                   }
[18:06:05.540]                 }
[18:06:05.540]             }
[18:06:05.540]         }))
[18:06:05.540]     }, error = function(ex) {
[18:06:05.540]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.540]                 ...future.rng), started = ...future.startTime, 
[18:06:05.540]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.540]             version = "1.8"), class = "FutureResult")
[18:06:05.540]     }, finally = {
[18:06:05.540]         if (!identical(...future.workdir, getwd())) 
[18:06:05.540]             setwd(...future.workdir)
[18:06:05.540]         {
[18:06:05.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.540]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.540]             }
[18:06:05.540]             base::options(...future.oldOptions)
[18:06:05.540]             if (.Platform$OS.type == "windows") {
[18:06:05.540]                 old_names <- names(...future.oldEnvVars)
[18:06:05.540]                 envs <- base::Sys.getenv()
[18:06:05.540]                 names <- names(envs)
[18:06:05.540]                 common <- intersect(names, old_names)
[18:06:05.540]                 added <- setdiff(names, old_names)
[18:06:05.540]                 removed <- setdiff(old_names, names)
[18:06:05.540]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.540]                   envs[common]]
[18:06:05.540]                 NAMES <- toupper(changed)
[18:06:05.540]                 args <- list()
[18:06:05.540]                 for (kk in seq_along(NAMES)) {
[18:06:05.540]                   name <- changed[[kk]]
[18:06:05.540]                   NAME <- NAMES[[kk]]
[18:06:05.540]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.540]                     next
[18:06:05.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.540]                 }
[18:06:05.540]                 NAMES <- toupper(added)
[18:06:05.540]                 for (kk in seq_along(NAMES)) {
[18:06:05.540]                   name <- added[[kk]]
[18:06:05.540]                   NAME <- NAMES[[kk]]
[18:06:05.540]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.540]                     next
[18:06:05.540]                   args[[name]] <- ""
[18:06:05.540]                 }
[18:06:05.540]                 NAMES <- toupper(removed)
[18:06:05.540]                 for (kk in seq_along(NAMES)) {
[18:06:05.540]                   name <- removed[[kk]]
[18:06:05.540]                   NAME <- NAMES[[kk]]
[18:06:05.540]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.540]                     next
[18:06:05.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.540]                 }
[18:06:05.540]                 if (length(args) > 0) 
[18:06:05.540]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.540]             }
[18:06:05.540]             else {
[18:06:05.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.540]             }
[18:06:05.540]             {
[18:06:05.540]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.540]                   0L) {
[18:06:05.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.540]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.540]                   base::options(opts)
[18:06:05.540]                 }
[18:06:05.540]                 {
[18:06:05.540]                   {
[18:06:05.540]                     NULL
[18:06:05.540]                     RNGkind("Mersenne-Twister")
[18:06:05.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.540]                       inherits = FALSE)
[18:06:05.540]                   }
[18:06:05.540]                   options(future.plan = NULL)
[18:06:05.540]                   if (is.na(NA_character_)) 
[18:06:05.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.540]                     .init = FALSE)
[18:06:05.540]                 }
[18:06:05.540]             }
[18:06:05.540]         }
[18:06:05.540]     })
[18:06:05.540]     if (TRUE) {
[18:06:05.540]         base::sink(type = "output", split = FALSE)
[18:06:05.540]         if (TRUE) {
[18:06:05.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.540]         }
[18:06:05.540]         else {
[18:06:05.540]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.540]         }
[18:06:05.540]         base::close(...future.stdout)
[18:06:05.540]         ...future.stdout <- NULL
[18:06:05.540]     }
[18:06:05.540]     ...future.result$conditions <- ...future.conditions
[18:06:05.540]     ...future.result$finished <- base::Sys.time()
[18:06:05.540]     ...future.result
[18:06:05.540] }
[18:06:05.543] plan(): Setting new future strategy stack:
[18:06:05.544] List of future strategies:
[18:06:05.544] 1. sequential:
[18:06:05.544]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.544]    - tweaked: FALSE
[18:06:05.544]    - call: NULL
[18:06:05.545] plan(): nbrOfWorkers() = 1
[18:06:05.546] plan(): Setting new future strategy stack:
[18:06:05.547] List of future strategies:
[18:06:05.547] 1. sequential:
[18:06:05.547]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.547]    - tweaked: FALSE
[18:06:05.547]    - call: plan(strategy)
[18:06:05.548] plan(): nbrOfWorkers() = 1
[18:06:05.548] SequentialFuture started (and completed)
[18:06:05.548] - Launch lazy future ... done
[18:06:05.549] run() for ‘SequentialFuture’ ... done
[18:06:05.550] resolve() on list environment ...
[18:06:05.550]  recursive: 0
[18:06:05.551]  length: 3
[18:06:05.551]  elements: ‘a’, ‘b’, ‘c’
[18:06:05.552] resolved() for ‘SequentialFuture’ ...
[18:06:05.552] - state: ‘finished’
[18:06:05.552] - run: TRUE
[18:06:05.552] - result: ‘FutureResult’
[18:06:05.552] resolved() for ‘SequentialFuture’ ... done
[18:06:05.553] Future #1
[18:06:05.553]  length: 2 (resolved future 1)
[18:06:05.553] resolved() for ‘SequentialFuture’ ...
[18:06:05.553] - state: ‘finished’
[18:06:05.554] - run: TRUE
[18:06:05.554] - result: ‘FutureResult’
[18:06:05.554] resolved() for ‘SequentialFuture’ ... done
[18:06:05.554] Future #2
[18:06:05.555]  length: 1 (resolved future 2)
[18:06:05.555]  length: 0 (resolved future 3)
[18:06:05.555] resolve() on list environment ... DONE
[18:06:05.559] getGlobalsAndPackages() ...
[18:06:05.559] Searching for globals...
[18:06:05.560] - globals found: [1] ‘{’
[18:06:05.561] Searching for globals ... DONE
[18:06:05.561] Resolving globals: FALSE
[18:06:05.561] 
[18:06:05.562] 
[18:06:05.562] getGlobalsAndPackages() ... DONE
[18:06:05.562] run() for ‘Future’ ...
[18:06:05.563] - state: ‘created’
[18:06:05.563] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.564] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.564]   - Field: ‘label’
[18:06:05.564]   - Field: ‘local’
[18:06:05.564]   - Field: ‘owner’
[18:06:05.565]   - Field: ‘envir’
[18:06:05.565]   - Field: ‘packages’
[18:06:05.565]   - Field: ‘gc’
[18:06:05.565]   - Field: ‘conditions’
[18:06:05.565]   - Field: ‘expr’
[18:06:05.566]   - Field: ‘uuid’
[18:06:05.566]   - Field: ‘seed’
[18:06:05.566]   - Field: ‘version’
[18:06:05.566]   - Field: ‘result’
[18:06:05.566]   - Field: ‘asynchronous’
[18:06:05.567]   - Field: ‘calls’
[18:06:05.567]   - Field: ‘globals’
[18:06:05.567]   - Field: ‘stdout’
[18:06:05.567]   - Field: ‘earlySignal’
[18:06:05.567]   - Field: ‘lazy’
[18:06:05.568]   - Field: ‘state’
[18:06:05.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.568] - Launch lazy future ...
[18:06:05.568] Packages needed by the future expression (n = 0): <none>
[18:06:05.569] Packages needed by future strategies (n = 0): <none>
[18:06:05.570] {
[18:06:05.570]     {
[18:06:05.570]         {
[18:06:05.570]             ...future.startTime <- base::Sys.time()
[18:06:05.570]             {
[18:06:05.570]                 {
[18:06:05.570]                   {
[18:06:05.570]                     base::local({
[18:06:05.570]                       has_future <- base::requireNamespace("future", 
[18:06:05.570]                         quietly = TRUE)
[18:06:05.570]                       if (has_future) {
[18:06:05.570]                         ns <- base::getNamespace("future")
[18:06:05.570]                         version <- ns[[".package"]][["version"]]
[18:06:05.570]                         if (is.null(version)) 
[18:06:05.570]                           version <- utils::packageVersion("future")
[18:06:05.570]                       }
[18:06:05.570]                       else {
[18:06:05.570]                         version <- NULL
[18:06:05.570]                       }
[18:06:05.570]                       if (!has_future || version < "1.8.0") {
[18:06:05.570]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.570]                           "", base::R.version$version.string), 
[18:06:05.570]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.570]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.570]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.570]                             "release", "version")], collapse = " "), 
[18:06:05.570]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.570]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.570]                           info)
[18:06:05.570]                         info <- base::paste(info, collapse = "; ")
[18:06:05.570]                         if (!has_future) {
[18:06:05.570]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.570]                             info)
[18:06:05.570]                         }
[18:06:05.570]                         else {
[18:06:05.570]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.570]                             info, version)
[18:06:05.570]                         }
[18:06:05.570]                         base::stop(msg)
[18:06:05.570]                       }
[18:06:05.570]                     })
[18:06:05.570]                   }
[18:06:05.570]                   ...future.strategy.old <- future::plan("list")
[18:06:05.570]                   options(future.plan = NULL)
[18:06:05.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.570]                 }
[18:06:05.570]                 ...future.workdir <- getwd()
[18:06:05.570]             }
[18:06:05.570]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.570]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.570]         }
[18:06:05.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.570]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.570]             base::names(...future.oldOptions))
[18:06:05.570]     }
[18:06:05.570]     if (FALSE) {
[18:06:05.570]     }
[18:06:05.570]     else {
[18:06:05.570]         if (TRUE) {
[18:06:05.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.570]                 open = "w")
[18:06:05.570]         }
[18:06:05.570]         else {
[18:06:05.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.570]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.570]         }
[18:06:05.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.570]             base::sink(type = "output", split = FALSE)
[18:06:05.570]             base::close(...future.stdout)
[18:06:05.570]         }, add = TRUE)
[18:06:05.570]     }
[18:06:05.570]     ...future.frame <- base::sys.nframe()
[18:06:05.570]     ...future.conditions <- base::list()
[18:06:05.570]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.570]     if (FALSE) {
[18:06:05.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.570]     }
[18:06:05.570]     ...future.result <- base::tryCatch({
[18:06:05.570]         base::withCallingHandlers({
[18:06:05.570]             ...future.value <- base::withVisible(base::local({
[18:06:05.570]                 1
[18:06:05.570]             }))
[18:06:05.570]             future::FutureResult(value = ...future.value$value, 
[18:06:05.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.570]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.570]                     ...future.globalenv.names))
[18:06:05.570]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.570]         }, condition = base::local({
[18:06:05.570]             c <- base::c
[18:06:05.570]             inherits <- base::inherits
[18:06:05.570]             invokeRestart <- base::invokeRestart
[18:06:05.570]             length <- base::length
[18:06:05.570]             list <- base::list
[18:06:05.570]             seq.int <- base::seq.int
[18:06:05.570]             signalCondition <- base::signalCondition
[18:06:05.570]             sys.calls <- base::sys.calls
[18:06:05.570]             `[[` <- base::`[[`
[18:06:05.570]             `+` <- base::`+`
[18:06:05.570]             `<<-` <- base::`<<-`
[18:06:05.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.570]                   3L)]
[18:06:05.570]             }
[18:06:05.570]             function(cond) {
[18:06:05.570]                 is_error <- inherits(cond, "error")
[18:06:05.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.570]                   NULL)
[18:06:05.570]                 if (is_error) {
[18:06:05.570]                   sessionInformation <- function() {
[18:06:05.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.570]                       search = base::search(), system = base::Sys.info())
[18:06:05.570]                   }
[18:06:05.570]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.570]                     cond$call), session = sessionInformation(), 
[18:06:05.570]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.570]                   signalCondition(cond)
[18:06:05.570]                 }
[18:06:05.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.570]                 "immediateCondition"))) {
[18:06:05.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.570]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.570]                   if (TRUE && !signal) {
[18:06:05.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.570]                     {
[18:06:05.570]                       inherits <- base::inherits
[18:06:05.570]                       invokeRestart <- base::invokeRestart
[18:06:05.570]                       is.null <- base::is.null
[18:06:05.570]                       muffled <- FALSE
[18:06:05.570]                       if (inherits(cond, "message")) {
[18:06:05.570]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.570]                         if (muffled) 
[18:06:05.570]                           invokeRestart("muffleMessage")
[18:06:05.570]                       }
[18:06:05.570]                       else if (inherits(cond, "warning")) {
[18:06:05.570]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.570]                         if (muffled) 
[18:06:05.570]                           invokeRestart("muffleWarning")
[18:06:05.570]                       }
[18:06:05.570]                       else if (inherits(cond, "condition")) {
[18:06:05.570]                         if (!is.null(pattern)) {
[18:06:05.570]                           computeRestarts <- base::computeRestarts
[18:06:05.570]                           grepl <- base::grepl
[18:06:05.570]                           restarts <- computeRestarts(cond)
[18:06:05.570]                           for (restart in restarts) {
[18:06:05.570]                             name <- restart$name
[18:06:05.570]                             if (is.null(name)) 
[18:06:05.570]                               next
[18:06:05.570]                             if (!grepl(pattern, name)) 
[18:06:05.570]                               next
[18:06:05.570]                             invokeRestart(restart)
[18:06:05.570]                             muffled <- TRUE
[18:06:05.570]                             break
[18:06:05.570]                           }
[18:06:05.570]                         }
[18:06:05.570]                       }
[18:06:05.570]                       invisible(muffled)
[18:06:05.570]                     }
[18:06:05.570]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.570]                   }
[18:06:05.570]                 }
[18:06:05.570]                 else {
[18:06:05.570]                   if (TRUE) {
[18:06:05.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.570]                     {
[18:06:05.570]                       inherits <- base::inherits
[18:06:05.570]                       invokeRestart <- base::invokeRestart
[18:06:05.570]                       is.null <- base::is.null
[18:06:05.570]                       muffled <- FALSE
[18:06:05.570]                       if (inherits(cond, "message")) {
[18:06:05.570]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.570]                         if (muffled) 
[18:06:05.570]                           invokeRestart("muffleMessage")
[18:06:05.570]                       }
[18:06:05.570]                       else if (inherits(cond, "warning")) {
[18:06:05.570]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.570]                         if (muffled) 
[18:06:05.570]                           invokeRestart("muffleWarning")
[18:06:05.570]                       }
[18:06:05.570]                       else if (inherits(cond, "condition")) {
[18:06:05.570]                         if (!is.null(pattern)) {
[18:06:05.570]                           computeRestarts <- base::computeRestarts
[18:06:05.570]                           grepl <- base::grepl
[18:06:05.570]                           restarts <- computeRestarts(cond)
[18:06:05.570]                           for (restart in restarts) {
[18:06:05.570]                             name <- restart$name
[18:06:05.570]                             if (is.null(name)) 
[18:06:05.570]                               next
[18:06:05.570]                             if (!grepl(pattern, name)) 
[18:06:05.570]                               next
[18:06:05.570]                             invokeRestart(restart)
[18:06:05.570]                             muffled <- TRUE
[18:06:05.570]                             break
[18:06:05.570]                           }
[18:06:05.570]                         }
[18:06:05.570]                       }
[18:06:05.570]                       invisible(muffled)
[18:06:05.570]                     }
[18:06:05.570]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.570]                   }
[18:06:05.570]                 }
[18:06:05.570]             }
[18:06:05.570]         }))
[18:06:05.570]     }, error = function(ex) {
[18:06:05.570]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.570]                 ...future.rng), started = ...future.startTime, 
[18:06:05.570]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.570]             version = "1.8"), class = "FutureResult")
[18:06:05.570]     }, finally = {
[18:06:05.570]         if (!identical(...future.workdir, getwd())) 
[18:06:05.570]             setwd(...future.workdir)
[18:06:05.570]         {
[18:06:05.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.570]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.570]             }
[18:06:05.570]             base::options(...future.oldOptions)
[18:06:05.570]             if (.Platform$OS.type == "windows") {
[18:06:05.570]                 old_names <- names(...future.oldEnvVars)
[18:06:05.570]                 envs <- base::Sys.getenv()
[18:06:05.570]                 names <- names(envs)
[18:06:05.570]                 common <- intersect(names, old_names)
[18:06:05.570]                 added <- setdiff(names, old_names)
[18:06:05.570]                 removed <- setdiff(old_names, names)
[18:06:05.570]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.570]                   envs[common]]
[18:06:05.570]                 NAMES <- toupper(changed)
[18:06:05.570]                 args <- list()
[18:06:05.570]                 for (kk in seq_along(NAMES)) {
[18:06:05.570]                   name <- changed[[kk]]
[18:06:05.570]                   NAME <- NAMES[[kk]]
[18:06:05.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.570]                     next
[18:06:05.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.570]                 }
[18:06:05.570]                 NAMES <- toupper(added)
[18:06:05.570]                 for (kk in seq_along(NAMES)) {
[18:06:05.570]                   name <- added[[kk]]
[18:06:05.570]                   NAME <- NAMES[[kk]]
[18:06:05.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.570]                     next
[18:06:05.570]                   args[[name]] <- ""
[18:06:05.570]                 }
[18:06:05.570]                 NAMES <- toupper(removed)
[18:06:05.570]                 for (kk in seq_along(NAMES)) {
[18:06:05.570]                   name <- removed[[kk]]
[18:06:05.570]                   NAME <- NAMES[[kk]]
[18:06:05.570]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.570]                     next
[18:06:05.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.570]                 }
[18:06:05.570]                 if (length(args) > 0) 
[18:06:05.570]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.570]             }
[18:06:05.570]             else {
[18:06:05.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.570]             }
[18:06:05.570]             {
[18:06:05.570]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.570]                   0L) {
[18:06:05.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.570]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.570]                   base::options(opts)
[18:06:05.570]                 }
[18:06:05.570]                 {
[18:06:05.570]                   {
[18:06:05.570]                     NULL
[18:06:05.570]                     RNGkind("Mersenne-Twister")
[18:06:05.570]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.570]                       inherits = FALSE)
[18:06:05.570]                   }
[18:06:05.570]                   options(future.plan = NULL)
[18:06:05.570]                   if (is.na(NA_character_)) 
[18:06:05.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.570]                     .init = FALSE)
[18:06:05.570]                 }
[18:06:05.570]             }
[18:06:05.570]         }
[18:06:05.570]     })
[18:06:05.570]     if (TRUE) {
[18:06:05.570]         base::sink(type = "output", split = FALSE)
[18:06:05.570]         if (TRUE) {
[18:06:05.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.570]         }
[18:06:05.570]         else {
[18:06:05.570]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.570]         }
[18:06:05.570]         base::close(...future.stdout)
[18:06:05.570]         ...future.stdout <- NULL
[18:06:05.570]     }
[18:06:05.570]     ...future.result$conditions <- ...future.conditions
[18:06:05.570]     ...future.result$finished <- base::Sys.time()
[18:06:05.570]     ...future.result
[18:06:05.570] }
[18:06:05.573] plan(): Setting new future strategy stack:
[18:06:05.574] List of future strategies:
[18:06:05.574] 1. sequential:
[18:06:05.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.574]    - tweaked: FALSE
[18:06:05.574]    - call: NULL
[18:06:05.575] plan(): nbrOfWorkers() = 1
[18:06:05.576] plan(): Setting new future strategy stack:
[18:06:05.576] List of future strategies:
[18:06:05.576] 1. sequential:
[18:06:05.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.576]    - tweaked: FALSE
[18:06:05.576]    - call: plan(strategy)
[18:06:05.578] plan(): nbrOfWorkers() = 1
[18:06:05.578] SequentialFuture started (and completed)
[18:06:05.578] - Launch lazy future ... done
[18:06:05.579] run() for ‘SequentialFuture’ ... done
[18:06:05.579] getGlobalsAndPackages() ...
[18:06:05.580] Searching for globals...
[18:06:05.582] - globals found: [2] ‘{’, ‘Sys.sleep’
[18:06:05.582] Searching for globals ... DONE
[18:06:05.582] Resolving globals: FALSE
[18:06:05.583] 
[18:06:05.583] 
[18:06:05.583] getGlobalsAndPackages() ... DONE
[18:06:05.584] run() for ‘Future’ ...
[18:06:05.584] - state: ‘created’
[18:06:05.584] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:05.585] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:05.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:05.585]   - Field: ‘label’
[18:06:05.585]   - Field: ‘local’
[18:06:05.586]   - Field: ‘owner’
[18:06:05.586]   - Field: ‘envir’
[18:06:05.586]   - Field: ‘packages’
[18:06:05.586]   - Field: ‘gc’
[18:06:05.586]   - Field: ‘conditions’
[18:06:05.587]   - Field: ‘expr’
[18:06:05.587]   - Field: ‘uuid’
[18:06:05.587]   - Field: ‘seed’
[18:06:05.587]   - Field: ‘version’
[18:06:05.588]   - Field: ‘result’
[18:06:05.588]   - Field: ‘asynchronous’
[18:06:05.588]   - Field: ‘calls’
[18:06:05.588]   - Field: ‘globals’
[18:06:05.588]   - Field: ‘stdout’
[18:06:05.588]   - Field: ‘earlySignal’
[18:06:05.589]   - Field: ‘lazy’
[18:06:05.589]   - Field: ‘state’
[18:06:05.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:05.589] - Launch lazy future ...
[18:06:05.590] Packages needed by the future expression (n = 0): <none>
[18:06:05.590] Packages needed by future strategies (n = 0): <none>
[18:06:05.591] {
[18:06:05.591]     {
[18:06:05.591]         {
[18:06:05.591]             ...future.startTime <- base::Sys.time()
[18:06:05.591]             {
[18:06:05.591]                 {
[18:06:05.591]                   {
[18:06:05.591]                     base::local({
[18:06:05.591]                       has_future <- base::requireNamespace("future", 
[18:06:05.591]                         quietly = TRUE)
[18:06:05.591]                       if (has_future) {
[18:06:05.591]                         ns <- base::getNamespace("future")
[18:06:05.591]                         version <- ns[[".package"]][["version"]]
[18:06:05.591]                         if (is.null(version)) 
[18:06:05.591]                           version <- utils::packageVersion("future")
[18:06:05.591]                       }
[18:06:05.591]                       else {
[18:06:05.591]                         version <- NULL
[18:06:05.591]                       }
[18:06:05.591]                       if (!has_future || version < "1.8.0") {
[18:06:05.591]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:05.591]                           "", base::R.version$version.string), 
[18:06:05.591]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:05.591]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:05.591]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:05.591]                             "release", "version")], collapse = " "), 
[18:06:05.591]                           hostname = base::Sys.info()[["nodename"]])
[18:06:05.591]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:05.591]                           info)
[18:06:05.591]                         info <- base::paste(info, collapse = "; ")
[18:06:05.591]                         if (!has_future) {
[18:06:05.591]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:05.591]                             info)
[18:06:05.591]                         }
[18:06:05.591]                         else {
[18:06:05.591]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:05.591]                             info, version)
[18:06:05.591]                         }
[18:06:05.591]                         base::stop(msg)
[18:06:05.591]                       }
[18:06:05.591]                     })
[18:06:05.591]                   }
[18:06:05.591]                   ...future.strategy.old <- future::plan("list")
[18:06:05.591]                   options(future.plan = NULL)
[18:06:05.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:05.591]                 }
[18:06:05.591]                 ...future.workdir <- getwd()
[18:06:05.591]             }
[18:06:05.591]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:05.591]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:05.591]         }
[18:06:05.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:05.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:05.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:05.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:05.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:05.591]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:05.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:05.591]             base::names(...future.oldOptions))
[18:06:05.591]     }
[18:06:05.591]     if (FALSE) {
[18:06:05.591]     }
[18:06:05.591]     else {
[18:06:05.591]         if (TRUE) {
[18:06:05.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:05.591]                 open = "w")
[18:06:05.591]         }
[18:06:05.591]         else {
[18:06:05.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:05.591]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:05.591]         }
[18:06:05.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:05.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:05.591]             base::sink(type = "output", split = FALSE)
[18:06:05.591]             base::close(...future.stdout)
[18:06:05.591]         }, add = TRUE)
[18:06:05.591]     }
[18:06:05.591]     ...future.frame <- base::sys.nframe()
[18:06:05.591]     ...future.conditions <- base::list()
[18:06:05.591]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:05.591]     if (FALSE) {
[18:06:05.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:05.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:05.591]     }
[18:06:05.591]     ...future.result <- base::tryCatch({
[18:06:05.591]         base::withCallingHandlers({
[18:06:05.591]             ...future.value <- base::withVisible(base::local({
[18:06:05.591]                 Sys.sleep(0.5)
[18:06:05.591]                 2
[18:06:05.591]             }))
[18:06:05.591]             future::FutureResult(value = ...future.value$value, 
[18:06:05.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.591]                   ...future.rng), globalenv = if (FALSE) 
[18:06:05.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:05.591]                     ...future.globalenv.names))
[18:06:05.591]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:05.591]         }, condition = base::local({
[18:06:05.591]             c <- base::c
[18:06:05.591]             inherits <- base::inherits
[18:06:05.591]             invokeRestart <- base::invokeRestart
[18:06:05.591]             length <- base::length
[18:06:05.591]             list <- base::list
[18:06:05.591]             seq.int <- base::seq.int
[18:06:05.591]             signalCondition <- base::signalCondition
[18:06:05.591]             sys.calls <- base::sys.calls
[18:06:05.591]             `[[` <- base::`[[`
[18:06:05.591]             `+` <- base::`+`
[18:06:05.591]             `<<-` <- base::`<<-`
[18:06:05.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:05.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:05.591]                   3L)]
[18:06:05.591]             }
[18:06:05.591]             function(cond) {
[18:06:05.591]                 is_error <- inherits(cond, "error")
[18:06:05.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:05.591]                   NULL)
[18:06:05.591]                 if (is_error) {
[18:06:05.591]                   sessionInformation <- function() {
[18:06:05.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:05.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:05.591]                       search = base::search(), system = base::Sys.info())
[18:06:05.591]                   }
[18:06:05.591]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:05.591]                     cond$call), session = sessionInformation(), 
[18:06:05.591]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:05.591]                   signalCondition(cond)
[18:06:05.591]                 }
[18:06:05.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:05.591]                 "immediateCondition"))) {
[18:06:05.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:05.591]                   ...future.conditions[[length(...future.conditions) + 
[18:06:05.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:05.591]                   if (TRUE && !signal) {
[18:06:05.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.591]                     {
[18:06:05.591]                       inherits <- base::inherits
[18:06:05.591]                       invokeRestart <- base::invokeRestart
[18:06:05.591]                       is.null <- base::is.null
[18:06:05.591]                       muffled <- FALSE
[18:06:05.591]                       if (inherits(cond, "message")) {
[18:06:05.591]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.591]                         if (muffled) 
[18:06:05.591]                           invokeRestart("muffleMessage")
[18:06:05.591]                       }
[18:06:05.591]                       else if (inherits(cond, "warning")) {
[18:06:05.591]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.591]                         if (muffled) 
[18:06:05.591]                           invokeRestart("muffleWarning")
[18:06:05.591]                       }
[18:06:05.591]                       else if (inherits(cond, "condition")) {
[18:06:05.591]                         if (!is.null(pattern)) {
[18:06:05.591]                           computeRestarts <- base::computeRestarts
[18:06:05.591]                           grepl <- base::grepl
[18:06:05.591]                           restarts <- computeRestarts(cond)
[18:06:05.591]                           for (restart in restarts) {
[18:06:05.591]                             name <- restart$name
[18:06:05.591]                             if (is.null(name)) 
[18:06:05.591]                               next
[18:06:05.591]                             if (!grepl(pattern, name)) 
[18:06:05.591]                               next
[18:06:05.591]                             invokeRestart(restart)
[18:06:05.591]                             muffled <- TRUE
[18:06:05.591]                             break
[18:06:05.591]                           }
[18:06:05.591]                         }
[18:06:05.591]                       }
[18:06:05.591]                       invisible(muffled)
[18:06:05.591]                     }
[18:06:05.591]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.591]                   }
[18:06:05.591]                 }
[18:06:05.591]                 else {
[18:06:05.591]                   if (TRUE) {
[18:06:05.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:05.591]                     {
[18:06:05.591]                       inherits <- base::inherits
[18:06:05.591]                       invokeRestart <- base::invokeRestart
[18:06:05.591]                       is.null <- base::is.null
[18:06:05.591]                       muffled <- FALSE
[18:06:05.591]                       if (inherits(cond, "message")) {
[18:06:05.591]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:05.591]                         if (muffled) 
[18:06:05.591]                           invokeRestart("muffleMessage")
[18:06:05.591]                       }
[18:06:05.591]                       else if (inherits(cond, "warning")) {
[18:06:05.591]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:05.591]                         if (muffled) 
[18:06:05.591]                           invokeRestart("muffleWarning")
[18:06:05.591]                       }
[18:06:05.591]                       else if (inherits(cond, "condition")) {
[18:06:05.591]                         if (!is.null(pattern)) {
[18:06:05.591]                           computeRestarts <- base::computeRestarts
[18:06:05.591]                           grepl <- base::grepl
[18:06:05.591]                           restarts <- computeRestarts(cond)
[18:06:05.591]                           for (restart in restarts) {
[18:06:05.591]                             name <- restart$name
[18:06:05.591]                             if (is.null(name)) 
[18:06:05.591]                               next
[18:06:05.591]                             if (!grepl(pattern, name)) 
[18:06:05.591]                               next
[18:06:05.591]                             invokeRestart(restart)
[18:06:05.591]                             muffled <- TRUE
[18:06:05.591]                             break
[18:06:05.591]                           }
[18:06:05.591]                         }
[18:06:05.591]                       }
[18:06:05.591]                       invisible(muffled)
[18:06:05.591]                     }
[18:06:05.591]                     muffleCondition(cond, pattern = "^muffle")
[18:06:05.591]                   }
[18:06:05.591]                 }
[18:06:05.591]             }
[18:06:05.591]         }))
[18:06:05.591]     }, error = function(ex) {
[18:06:05.591]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:05.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:05.591]                 ...future.rng), started = ...future.startTime, 
[18:06:05.591]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:05.591]             version = "1.8"), class = "FutureResult")
[18:06:05.591]     }, finally = {
[18:06:05.591]         if (!identical(...future.workdir, getwd())) 
[18:06:05.591]             setwd(...future.workdir)
[18:06:05.591]         {
[18:06:05.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:05.591]                 ...future.oldOptions$nwarnings <- NULL
[18:06:05.591]             }
[18:06:05.591]             base::options(...future.oldOptions)
[18:06:05.591]             if (.Platform$OS.type == "windows") {
[18:06:05.591]                 old_names <- names(...future.oldEnvVars)
[18:06:05.591]                 envs <- base::Sys.getenv()
[18:06:05.591]                 names <- names(envs)
[18:06:05.591]                 common <- intersect(names, old_names)
[18:06:05.591]                 added <- setdiff(names, old_names)
[18:06:05.591]                 removed <- setdiff(old_names, names)
[18:06:05.591]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:05.591]                   envs[common]]
[18:06:05.591]                 NAMES <- toupper(changed)
[18:06:05.591]                 args <- list()
[18:06:05.591]                 for (kk in seq_along(NAMES)) {
[18:06:05.591]                   name <- changed[[kk]]
[18:06:05.591]                   NAME <- NAMES[[kk]]
[18:06:05.591]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.591]                     next
[18:06:05.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.591]                 }
[18:06:05.591]                 NAMES <- toupper(added)
[18:06:05.591]                 for (kk in seq_along(NAMES)) {
[18:06:05.591]                   name <- added[[kk]]
[18:06:05.591]                   NAME <- NAMES[[kk]]
[18:06:05.591]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.591]                     next
[18:06:05.591]                   args[[name]] <- ""
[18:06:05.591]                 }
[18:06:05.591]                 NAMES <- toupper(removed)
[18:06:05.591]                 for (kk in seq_along(NAMES)) {
[18:06:05.591]                   name <- removed[[kk]]
[18:06:05.591]                   NAME <- NAMES[[kk]]
[18:06:05.591]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:05.591]                     next
[18:06:05.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:05.591]                 }
[18:06:05.591]                 if (length(args) > 0) 
[18:06:05.591]                   base::do.call(base::Sys.setenv, args = args)
[18:06:05.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:05.591]             }
[18:06:05.591]             else {
[18:06:05.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:05.591]             }
[18:06:05.591]             {
[18:06:05.591]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:05.591]                   0L) {
[18:06:05.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:05.591]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:05.591]                   base::options(opts)
[18:06:05.591]                 }
[18:06:05.591]                 {
[18:06:05.591]                   {
[18:06:05.591]                     NULL
[18:06:05.591]                     RNGkind("Mersenne-Twister")
[18:06:05.591]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:05.591]                       inherits = FALSE)
[18:06:05.591]                   }
[18:06:05.591]                   options(future.plan = NULL)
[18:06:05.591]                   if (is.na(NA_character_)) 
[18:06:05.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:05.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:05.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:05.591]                     .init = FALSE)
[18:06:05.591]                 }
[18:06:05.591]             }
[18:06:05.591]         }
[18:06:05.591]     })
[18:06:05.591]     if (TRUE) {
[18:06:05.591]         base::sink(type = "output", split = FALSE)
[18:06:05.591]         if (TRUE) {
[18:06:05.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:05.591]         }
[18:06:05.591]         else {
[18:06:05.591]             ...future.result["stdout"] <- base::list(NULL)
[18:06:05.591]         }
[18:06:05.591]         base::close(...future.stdout)
[18:06:05.591]         ...future.stdout <- NULL
[18:06:05.591]     }
[18:06:05.591]     ...future.result$conditions <- ...future.conditions
[18:06:05.591]     ...future.result$finished <- base::Sys.time()
[18:06:05.591]     ...future.result
[18:06:05.591] }
[18:06:05.595] plan(): Setting new future strategy stack:
[18:06:05.595] List of future strategies:
[18:06:05.595] 1. sequential:
[18:06:05.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:05.595]    - tweaked: FALSE
[18:06:05.595]    - call: NULL
[18:06:05.596] plan(): nbrOfWorkers() = 1
[18:06:06.098] plan(): Setting new future strategy stack:
[18:06:06.098] List of future strategies:
[18:06:06.098] 1. sequential:
[18:06:06.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.098]    - tweaked: FALSE
[18:06:06.098]    - call: plan(strategy)
[18:06:06.099] plan(): nbrOfWorkers() = 1
[18:06:06.100] SequentialFuture started (and completed)
[18:06:06.100] - Launch lazy future ... done
[18:06:06.100] run() for ‘SequentialFuture’ ... done
[18:06:06.101] getGlobalsAndPackages() ...
[18:06:06.101] Searching for globals...
[18:06:06.102] - globals found: [1] ‘{’
[18:06:06.103] Searching for globals ... DONE
[18:06:06.103] Resolving globals: FALSE
[18:06:06.103] 
[18:06:06.104] 
[18:06:06.104] getGlobalsAndPackages() ... DONE
[18:06:06.104] run() for ‘Future’ ...
[18:06:06.104] - state: ‘created’
[18:06:06.105] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:06:06.105] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:06:06.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:06:06.106]   - Field: ‘label’
[18:06:06.106]   - Field: ‘local’
[18:06:06.106]   - Field: ‘owner’
[18:06:06.106]   - Field: ‘envir’
[18:06:06.106]   - Field: ‘packages’
[18:06:06.107]   - Field: ‘gc’
[18:06:06.107]   - Field: ‘conditions’
[18:06:06.107]   - Field: ‘expr’
[18:06:06.107]   - Field: ‘uuid’
[18:06:06.107]   - Field: ‘seed’
[18:06:06.108]   - Field: ‘version’
[18:06:06.108]   - Field: ‘result’
[18:06:06.108]   - Field: ‘asynchronous’
[18:06:06.108]   - Field: ‘calls’
[18:06:06.108]   - Field: ‘globals’
[18:06:06.109]   - Field: ‘stdout’
[18:06:06.109]   - Field: ‘earlySignal’
[18:06:06.109]   - Field: ‘lazy’
[18:06:06.109]   - Field: ‘state’
[18:06:06.109] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:06:06.110] - Launch lazy future ...
[18:06:06.110] Packages needed by the future expression (n = 0): <none>
[18:06:06.110] Packages needed by future strategies (n = 0): <none>
[18:06:06.111] {
[18:06:06.111]     {
[18:06:06.111]         {
[18:06:06.111]             ...future.startTime <- base::Sys.time()
[18:06:06.111]             {
[18:06:06.111]                 {
[18:06:06.111]                   {
[18:06:06.111]                     base::local({
[18:06:06.111]                       has_future <- base::requireNamespace("future", 
[18:06:06.111]                         quietly = TRUE)
[18:06:06.111]                       if (has_future) {
[18:06:06.111]                         ns <- base::getNamespace("future")
[18:06:06.111]                         version <- ns[[".package"]][["version"]]
[18:06:06.111]                         if (is.null(version)) 
[18:06:06.111]                           version <- utils::packageVersion("future")
[18:06:06.111]                       }
[18:06:06.111]                       else {
[18:06:06.111]                         version <- NULL
[18:06:06.111]                       }
[18:06:06.111]                       if (!has_future || version < "1.8.0") {
[18:06:06.111]                         info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.111]                           "", base::R.version$version.string), 
[18:06:06.111]                           platform = base::sprintf("%s (%s-bit)", 
[18:06:06.111]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.111]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.111]                             "release", "version")], collapse = " "), 
[18:06:06.111]                           hostname = base::Sys.info()[["nodename"]])
[18:06:06.111]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.111]                           info)
[18:06:06.111]                         info <- base::paste(info, collapse = "; ")
[18:06:06.111]                         if (!has_future) {
[18:06:06.111]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.111]                             info)
[18:06:06.111]                         }
[18:06:06.111]                         else {
[18:06:06.111]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.111]                             info, version)
[18:06:06.111]                         }
[18:06:06.111]                         base::stop(msg)
[18:06:06.111]                       }
[18:06:06.111]                     })
[18:06:06.111]                   }
[18:06:06.111]                   ...future.strategy.old <- future::plan("list")
[18:06:06.111]                   options(future.plan = NULL)
[18:06:06.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.111]                 }
[18:06:06.111]                 ...future.workdir <- getwd()
[18:06:06.111]             }
[18:06:06.111]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.111]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.111]         }
[18:06:06.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.111]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.111]             base::names(...future.oldOptions))
[18:06:06.111]     }
[18:06:06.111]     if (FALSE) {
[18:06:06.111]     }
[18:06:06.111]     else {
[18:06:06.111]         if (TRUE) {
[18:06:06.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.111]                 open = "w")
[18:06:06.111]         }
[18:06:06.111]         else {
[18:06:06.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.111]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.111]         }
[18:06:06.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.111]             base::sink(type = "output", split = FALSE)
[18:06:06.111]             base::close(...future.stdout)
[18:06:06.111]         }, add = TRUE)
[18:06:06.111]     }
[18:06:06.111]     ...future.frame <- base::sys.nframe()
[18:06:06.111]     ...future.conditions <- base::list()
[18:06:06.111]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.111]     if (FALSE) {
[18:06:06.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.111]     }
[18:06:06.111]     ...future.result <- base::tryCatch({
[18:06:06.111]         base::withCallingHandlers({
[18:06:06.111]             ...future.value <- base::withVisible(base::local({
[18:06:06.111]                 3
[18:06:06.111]             }))
[18:06:06.111]             future::FutureResult(value = ...future.value$value, 
[18:06:06.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.111]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.111]                     ...future.globalenv.names))
[18:06:06.111]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.111]         }, condition = base::local({
[18:06:06.111]             c <- base::c
[18:06:06.111]             inherits <- base::inherits
[18:06:06.111]             invokeRestart <- base::invokeRestart
[18:06:06.111]             length <- base::length
[18:06:06.111]             list <- base::list
[18:06:06.111]             seq.int <- base::seq.int
[18:06:06.111]             signalCondition <- base::signalCondition
[18:06:06.111]             sys.calls <- base::sys.calls
[18:06:06.111]             `[[` <- base::`[[`
[18:06:06.111]             `+` <- base::`+`
[18:06:06.111]             `<<-` <- base::`<<-`
[18:06:06.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.111]                   3L)]
[18:06:06.111]             }
[18:06:06.111]             function(cond) {
[18:06:06.111]                 is_error <- inherits(cond, "error")
[18:06:06.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.111]                   NULL)
[18:06:06.111]                 if (is_error) {
[18:06:06.111]                   sessionInformation <- function() {
[18:06:06.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.111]                       search = base::search(), system = base::Sys.info())
[18:06:06.111]                   }
[18:06:06.111]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.111]                     cond$call), session = sessionInformation(), 
[18:06:06.111]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.111]                   signalCondition(cond)
[18:06:06.111]                 }
[18:06:06.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.111]                 "immediateCondition"))) {
[18:06:06.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.111]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.111]                   if (TRUE && !signal) {
[18:06:06.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.111]                     {
[18:06:06.111]                       inherits <- base::inherits
[18:06:06.111]                       invokeRestart <- base::invokeRestart
[18:06:06.111]                       is.null <- base::is.null
[18:06:06.111]                       muffled <- FALSE
[18:06:06.111]                       if (inherits(cond, "message")) {
[18:06:06.111]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.111]                         if (muffled) 
[18:06:06.111]                           invokeRestart("muffleMessage")
[18:06:06.111]                       }
[18:06:06.111]                       else if (inherits(cond, "warning")) {
[18:06:06.111]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.111]                         if (muffled) 
[18:06:06.111]                           invokeRestart("muffleWarning")
[18:06:06.111]                       }
[18:06:06.111]                       else if (inherits(cond, "condition")) {
[18:06:06.111]                         if (!is.null(pattern)) {
[18:06:06.111]                           computeRestarts <- base::computeRestarts
[18:06:06.111]                           grepl <- base::grepl
[18:06:06.111]                           restarts <- computeRestarts(cond)
[18:06:06.111]                           for (restart in restarts) {
[18:06:06.111]                             name <- restart$name
[18:06:06.111]                             if (is.null(name)) 
[18:06:06.111]                               next
[18:06:06.111]                             if (!grepl(pattern, name)) 
[18:06:06.111]                               next
[18:06:06.111]                             invokeRestart(restart)
[18:06:06.111]                             muffled <- TRUE
[18:06:06.111]                             break
[18:06:06.111]                           }
[18:06:06.111]                         }
[18:06:06.111]                       }
[18:06:06.111]                       invisible(muffled)
[18:06:06.111]                     }
[18:06:06.111]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.111]                   }
[18:06:06.111]                 }
[18:06:06.111]                 else {
[18:06:06.111]                   if (TRUE) {
[18:06:06.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.111]                     {
[18:06:06.111]                       inherits <- base::inherits
[18:06:06.111]                       invokeRestart <- base::invokeRestart
[18:06:06.111]                       is.null <- base::is.null
[18:06:06.111]                       muffled <- FALSE
[18:06:06.111]                       if (inherits(cond, "message")) {
[18:06:06.111]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.111]                         if (muffled) 
[18:06:06.111]                           invokeRestart("muffleMessage")
[18:06:06.111]                       }
[18:06:06.111]                       else if (inherits(cond, "warning")) {
[18:06:06.111]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.111]                         if (muffled) 
[18:06:06.111]                           invokeRestart("muffleWarning")
[18:06:06.111]                       }
[18:06:06.111]                       else if (inherits(cond, "condition")) {
[18:06:06.111]                         if (!is.null(pattern)) {
[18:06:06.111]                           computeRestarts <- base::computeRestarts
[18:06:06.111]                           grepl <- base::grepl
[18:06:06.111]                           restarts <- computeRestarts(cond)
[18:06:06.111]                           for (restart in restarts) {
[18:06:06.111]                             name <- restart$name
[18:06:06.111]                             if (is.null(name)) 
[18:06:06.111]                               next
[18:06:06.111]                             if (!grepl(pattern, name)) 
[18:06:06.111]                               next
[18:06:06.111]                             invokeRestart(restart)
[18:06:06.111]                             muffled <- TRUE
[18:06:06.111]                             break
[18:06:06.111]                           }
[18:06:06.111]                         }
[18:06:06.111]                       }
[18:06:06.111]                       invisible(muffled)
[18:06:06.111]                     }
[18:06:06.111]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.111]                   }
[18:06:06.111]                 }
[18:06:06.111]             }
[18:06:06.111]         }))
[18:06:06.111]     }, error = function(ex) {
[18:06:06.111]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.111]                 ...future.rng), started = ...future.startTime, 
[18:06:06.111]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.111]             version = "1.8"), class = "FutureResult")
[18:06:06.111]     }, finally = {
[18:06:06.111]         if (!identical(...future.workdir, getwd())) 
[18:06:06.111]             setwd(...future.workdir)
[18:06:06.111]         {
[18:06:06.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.111]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.111]             }
[18:06:06.111]             base::options(...future.oldOptions)
[18:06:06.111]             if (.Platform$OS.type == "windows") {
[18:06:06.111]                 old_names <- names(...future.oldEnvVars)
[18:06:06.111]                 envs <- base::Sys.getenv()
[18:06:06.111]                 names <- names(envs)
[18:06:06.111]                 common <- intersect(names, old_names)
[18:06:06.111]                 added <- setdiff(names, old_names)
[18:06:06.111]                 removed <- setdiff(old_names, names)
[18:06:06.111]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.111]                   envs[common]]
[18:06:06.111]                 NAMES <- toupper(changed)
[18:06:06.111]                 args <- list()
[18:06:06.111]                 for (kk in seq_along(NAMES)) {
[18:06:06.111]                   name <- changed[[kk]]
[18:06:06.111]                   NAME <- NAMES[[kk]]
[18:06:06.111]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.111]                     next
[18:06:06.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.111]                 }
[18:06:06.111]                 NAMES <- toupper(added)
[18:06:06.111]                 for (kk in seq_along(NAMES)) {
[18:06:06.111]                   name <- added[[kk]]
[18:06:06.111]                   NAME <- NAMES[[kk]]
[18:06:06.111]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.111]                     next
[18:06:06.111]                   args[[name]] <- ""
[18:06:06.111]                 }
[18:06:06.111]                 NAMES <- toupper(removed)
[18:06:06.111]                 for (kk in seq_along(NAMES)) {
[18:06:06.111]                   name <- removed[[kk]]
[18:06:06.111]                   NAME <- NAMES[[kk]]
[18:06:06.111]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.111]                     next
[18:06:06.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.111]                 }
[18:06:06.111]                 if (length(args) > 0) 
[18:06:06.111]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.111]             }
[18:06:06.111]             else {
[18:06:06.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.111]             }
[18:06:06.111]             {
[18:06:06.111]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.111]                   0L) {
[18:06:06.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.111]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.111]                   base::options(opts)
[18:06:06.111]                 }
[18:06:06.111]                 {
[18:06:06.111]                   {
[18:06:06.111]                     NULL
[18:06:06.111]                     RNGkind("Mersenne-Twister")
[18:06:06.111]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:06:06.111]                       inherits = FALSE)
[18:06:06.111]                   }
[18:06:06.111]                   options(future.plan = NULL)
[18:06:06.111]                   if (is.na(NA_character_)) 
[18:06:06.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.111]                     .init = FALSE)
[18:06:06.111]                 }
[18:06:06.111]             }
[18:06:06.111]         }
[18:06:06.111]     })
[18:06:06.111]     if (TRUE) {
[18:06:06.111]         base::sink(type = "output", split = FALSE)
[18:06:06.111]         if (TRUE) {
[18:06:06.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.111]         }
[18:06:06.111]         else {
[18:06:06.111]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.111]         }
[18:06:06.111]         base::close(...future.stdout)
[18:06:06.111]         ...future.stdout <- NULL
[18:06:06.111]     }
[18:06:06.111]     ...future.result$conditions <- ...future.conditions
[18:06:06.111]     ...future.result$finished <- base::Sys.time()
[18:06:06.111]     ...future.result
[18:06:06.111] }
[18:06:06.115] plan(): Setting new future strategy stack:
[18:06:06.115] List of future strategies:
[18:06:06.115] 1. sequential:
[18:06:06.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.115]    - tweaked: FALSE
[18:06:06.115]    - call: NULL
[18:06:06.117] plan(): nbrOfWorkers() = 1
[18:06:06.118] plan(): Setting new future strategy stack:
[18:06:06.118] List of future strategies:
[18:06:06.118] 1. sequential:
[18:06:06.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.118]    - tweaked: FALSE
[18:06:06.118]    - call: plan(strategy)
[18:06:06.120] plan(): nbrOfWorkers() = 1
[18:06:06.120] SequentialFuture started (and completed)
[18:06:06.123] - Launch lazy future ... done
[18:06:06.123] run() for ‘SequentialFuture’ ... done
[18:06:06.125] resolve() on list environment ...
[18:06:06.125]  recursive: 0
[18:06:06.127]  length: 4
[18:06:06.127]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:06.127] resolved() for ‘SequentialFuture’ ...
[18:06:06.127] - state: ‘finished’
[18:06:06.128] - run: TRUE
[18:06:06.128] - result: ‘FutureResult’
[18:06:06.128] resolved() for ‘SequentialFuture’ ... done
[18:06:06.128] Future #1
[18:06:06.128]  length: 3 (resolved future 1)
[18:06:06.129] resolved() for ‘SequentialFuture’ ...
[18:06:06.129] - state: ‘finished’
[18:06:06.129] - run: TRUE
[18:06:06.129] - result: ‘FutureResult’
[18:06:06.130] resolved() for ‘SequentialFuture’ ... done
[18:06:06.130] Future #2
[18:06:06.130]  length: 2 (resolved future 2)
[18:06:06.130] resolved() for ‘SequentialFuture’ ...
[18:06:06.131] - state: ‘finished’
[18:06:06.131] - run: TRUE
[18:06:06.131] - result: ‘FutureResult’
[18:06:06.131] resolved() for ‘SequentialFuture’ ... done
[18:06:06.131] Future #3
[18:06:06.132]  length: 1 (resolved future 3)
[18:06:06.132]  length: 0 (resolved future 4)
[18:06:06.132] resolve() on list environment ... DONE
[18:06:06.133] resolved() for ‘SequentialFuture’ ...
[18:06:06.133] - state: ‘finished’
[18:06:06.133] - run: TRUE
[18:06:06.133] - result: ‘FutureResult’
[18:06:06.134] resolved() for ‘SequentialFuture’ ... done
[18:06:06.134] resolve() on list environment ...
[18:06:06.134]  recursive: 0
[18:06:06.135]  length: 4
[18:06:06.136]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:06.136] resolved() for ‘SequentialFuture’ ...
[18:06:06.136] - state: ‘finished’
[18:06:06.137] - run: TRUE
[18:06:06.137] - result: ‘FutureResult’
[18:06:06.137] resolved() for ‘SequentialFuture’ ... done
[18:06:06.137] Future #1
[18:06:06.137]  length: 3 (resolved future 1)
[18:06:06.138] resolved() for ‘SequentialFuture’ ...
[18:06:06.138] - state: ‘finished’
[18:06:06.138] - run: TRUE
[18:06:06.138] - result: ‘FutureResult’
[18:06:06.138] resolved() for ‘SequentialFuture’ ... done
[18:06:06.139] Future #2
[18:06:06.139]  length: 2 (resolved future 2)
[18:06:06.139] resolved() for ‘SequentialFuture’ ...
[18:06:06.139] - state: ‘finished’
[18:06:06.140] - run: TRUE
[18:06:06.140] - result: ‘FutureResult’
[18:06:06.140] resolved() for ‘SequentialFuture’ ... done
[18:06:06.140] Future #3
[18:06:06.140]  length: 1 (resolved future 3)
[18:06:06.141]  length: 0 (resolved future 4)
[18:06:06.141] resolve() on list environment ... DONE
[18:06:06.142] resolve() on list environment ...
[18:06:06.142]  recursive: 0
[18:06:06.144]  length: 4
[18:06:06.144]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:06.144] resolved() for ‘SequentialFuture’ ...
[18:06:06.145] - state: ‘finished’
[18:06:06.145] - run: TRUE
[18:06:06.145] - result: ‘FutureResult’
[18:06:06.145] resolved() for ‘SequentialFuture’ ... done
[18:06:06.145] Future #1
[18:06:06.146]  length: 3 (resolved future 1)
[18:06:06.146] resolved() for ‘SequentialFuture’ ...
[18:06:06.146] - state: ‘finished’
[18:06:06.146] - run: TRUE
[18:06:06.147] - result: ‘FutureResult’
[18:06:06.147] resolved() for ‘SequentialFuture’ ... done
[18:06:06.147] Future #2
[18:06:06.147]  length: 2 (resolved future 2)
[18:06:06.147] resolved() for ‘SequentialFuture’ ...
[18:06:06.148] - state: ‘finished’
[18:06:06.148] - run: TRUE
[18:06:06.148] - result: ‘FutureResult’
[18:06:06.148] resolved() for ‘SequentialFuture’ ... done
[18:06:06.148] Future #3
[18:06:06.149]  length: 1 (resolved future 3)
[18:06:06.149]  length: 0 (resolved future 4)
[18:06:06.149] resolve() on list environment ... DONE
[18:06:06.150] resolve() on list environment ...
[18:06:06.151]  recursive: 0
[18:06:06.153]  length: 4
[18:06:06.154]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:06.154] resolved() for ‘SequentialFuture’ ...
[18:06:06.154] - state: ‘finished’
[18:06:06.154] - run: TRUE
[18:06:06.154] - result: ‘FutureResult’
[18:06:06.155] resolved() for ‘SequentialFuture’ ... done
[18:06:06.155] Future #1
[18:06:06.155]  length: 3 (resolved future 1)
[18:06:06.155] resolved() for ‘SequentialFuture’ ...
[18:06:06.156] - state: ‘finished’
[18:06:06.156] - run: TRUE
[18:06:06.156] - result: ‘FutureResult’
[18:06:06.156] resolved() for ‘SequentialFuture’ ... done
[18:06:06.156] Future #2
[18:06:06.157]  length: 2 (resolved future 2)
[18:06:06.157] resolved() for ‘SequentialFuture’ ...
[18:06:06.157] - state: ‘finished’
[18:06:06.157] - run: TRUE
[18:06:06.158] - result: ‘FutureResult’
[18:06:06.158] resolved() for ‘SequentialFuture’ ... done
[18:06:06.158] Future #3
[18:06:06.158]  length: 1 (resolved future 3)
[18:06:06.158]  length: 0 (resolved future 4)
[18:06:06.159] resolve() on list environment ... DONE
[18:06:06.160] resolve() on list environment ...
[18:06:06.160]  recursive: 0
[18:06:06.162]  length: 4
[18:06:06.162]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:06.162] resolved() for ‘SequentialFuture’ ...
[18:06:06.162] - state: ‘finished’
[18:06:06.163] - run: TRUE
[18:06:06.163] - result: ‘FutureResult’
[18:06:06.163] resolved() for ‘SequentialFuture’ ... done
[18:06:06.163] Future #1
[18:06:06.164]  length: 3 (resolved future 1)
[18:06:06.164] resolved() for ‘SequentialFuture’ ...
[18:06:06.164] - state: ‘finished’
[18:06:06.164] - run: TRUE
[18:06:06.164] - result: ‘FutureResult’
[18:06:06.165] resolved() for ‘SequentialFuture’ ... done
[18:06:06.165] Future #2
[18:06:06.165]  length: 2 (resolved future 2)
[18:06:06.165] resolved() for ‘SequentialFuture’ ...
[18:06:06.166] - state: ‘finished’
[18:06:06.166] - run: TRUE
[18:06:06.166] - result: ‘FutureResult’
[18:06:06.166] resolved() for ‘SequentialFuture’ ... done
[18:06:06.166] Future #3
[18:06:06.167]  length: 1 (resolved future 3)
[18:06:06.167]  length: 0 (resolved future 4)
[18:06:06.167] resolve() on list environment ... DONE
[18:06:06.169] resolve() on list environment ...
[18:06:06.169]  recursive: 99
[18:06:06.171]  length: 4
[18:06:06.171]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:06.171] resolved() for ‘SequentialFuture’ ...
[18:06:06.171] - state: ‘finished’
[18:06:06.172] - run: TRUE
[18:06:06.172] - result: ‘FutureResult’
[18:06:06.172] resolved() for ‘SequentialFuture’ ... done
[18:06:06.172] Future #1
[18:06:06.175] resolved() for ‘SequentialFuture’ ...
[18:06:06.175] - state: ‘finished’
[18:06:06.176] - run: TRUE
[18:06:06.176] - result: ‘FutureResult’
[18:06:06.176] resolved() for ‘SequentialFuture’ ... done
[18:06:06.176] A SequentialFuture was resolved
[18:06:06.177]  length: 3 (resolved future 1)
[18:06:06.177] resolved() for ‘SequentialFuture’ ...
[18:06:06.177] - state: ‘finished’
[18:06:06.177] - run: TRUE
[18:06:06.178] - result: ‘FutureResult’
[18:06:06.178] resolved() for ‘SequentialFuture’ ... done
[18:06:06.178] Future #2
[18:06:06.178] resolved() for ‘SequentialFuture’ ...
[18:06:06.179] - state: ‘finished’
[18:06:06.179] - run: TRUE
[18:06:06.179] - result: ‘FutureResult’
[18:06:06.179] resolved() for ‘SequentialFuture’ ... done
[18:06:06.179] A SequentialFuture was resolved
[18:06:06.180]  length: 2 (resolved future 2)
[18:06:06.180] resolved() for ‘SequentialFuture’ ...
[18:06:06.180] - state: ‘finished’
[18:06:06.180] - run: TRUE
[18:06:06.180] - result: ‘FutureResult’
[18:06:06.181] resolved() for ‘SequentialFuture’ ... done
[18:06:06.181] Future #3
[18:06:06.181] resolved() for ‘SequentialFuture’ ...
[18:06:06.181] - state: ‘finished’
[18:06:06.182] - run: TRUE
[18:06:06.182] - result: ‘FutureResult’
[18:06:06.182] resolved() for ‘SequentialFuture’ ... done
[18:06:06.182] A SequentialFuture was resolved
[18:06:06.182]  length: 1 (resolved future 3)
[18:06:06.183]  length: 0 (resolved future 4)
[18:06:06.183] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[18:06:06.184] plan(): Setting new future strategy stack:
[18:06:06.184] List of future strategies:
[18:06:06.184] 1. multicore:
[18:06:06.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.184]    - tweaked: FALSE
[18:06:06.184]    - call: plan(strategy)
[18:06:06.191] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[18:06:06.192] resolve() on list ...
[18:06:06.192]  recursive: 0
[18:06:06.192]  length: 2
[18:06:06.192]  elements: ‘a’, ‘b’
[18:06:06.193]  length: 1 (resolved future 1)
[18:06:06.193]  length: 0 (resolved future 2)
[18:06:06.194] resolve() on list ... DONE
[18:06:06.194] getGlobalsAndPackages() ...
[18:06:06.194] Searching for globals...
[18:06:06.195] 
[18:06:06.195] Searching for globals ... DONE
[18:06:06.196] - globals: [0] <none>
[18:06:06.196] getGlobalsAndPackages() ... DONE
[18:06:06.196] run() for ‘Future’ ...
[18:06:06.196] - state: ‘created’
[18:06:06.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.203] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.204]   - Field: ‘label’
[18:06:06.204]   - Field: ‘local’
[18:06:06.204]   - Field: ‘owner’
[18:06:06.205]   - Field: ‘envir’
[18:06:06.205]   - Field: ‘workers’
[18:06:06.205]   - Field: ‘packages’
[18:06:06.205]   - Field: ‘gc’
[18:06:06.205]   - Field: ‘job’
[18:06:06.206]   - Field: ‘conditions’
[18:06:06.206]   - Field: ‘expr’
[18:06:06.206]   - Field: ‘uuid’
[18:06:06.206]   - Field: ‘seed’
[18:06:06.207]   - Field: ‘version’
[18:06:06.207]   - Field: ‘result’
[18:06:06.207]   - Field: ‘asynchronous’
[18:06:06.207]   - Field: ‘calls’
[18:06:06.207]   - Field: ‘globals’
[18:06:06.208]   - Field: ‘stdout’
[18:06:06.208]   - Field: ‘earlySignal’
[18:06:06.208]   - Field: ‘lazy’
[18:06:06.208]   - Field: ‘state’
[18:06:06.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.209] - Launch lazy future ...
[18:06:06.210] Packages needed by the future expression (n = 0): <none>
[18:06:06.211] Packages needed by future strategies (n = 0): <none>
[18:06:06.212] {
[18:06:06.212]     {
[18:06:06.212]         {
[18:06:06.212]             ...future.startTime <- base::Sys.time()
[18:06:06.212]             {
[18:06:06.212]                 {
[18:06:06.212]                   {
[18:06:06.212]                     {
[18:06:06.212]                       base::local({
[18:06:06.212]                         has_future <- base::requireNamespace("future", 
[18:06:06.212]                           quietly = TRUE)
[18:06:06.212]                         if (has_future) {
[18:06:06.212]                           ns <- base::getNamespace("future")
[18:06:06.212]                           version <- ns[[".package"]][["version"]]
[18:06:06.212]                           if (is.null(version)) 
[18:06:06.212]                             version <- utils::packageVersion("future")
[18:06:06.212]                         }
[18:06:06.212]                         else {
[18:06:06.212]                           version <- NULL
[18:06:06.212]                         }
[18:06:06.212]                         if (!has_future || version < "1.8.0") {
[18:06:06.212]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.212]                             "", base::R.version$version.string), 
[18:06:06.212]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.212]                               "release", "version")], collapse = " "), 
[18:06:06.212]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.212]                             info)
[18:06:06.212]                           info <- base::paste(info, collapse = "; ")
[18:06:06.212]                           if (!has_future) {
[18:06:06.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.212]                               info)
[18:06:06.212]                           }
[18:06:06.212]                           else {
[18:06:06.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.212]                               info, version)
[18:06:06.212]                           }
[18:06:06.212]                           base::stop(msg)
[18:06:06.212]                         }
[18:06:06.212]                       })
[18:06:06.212]                     }
[18:06:06.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.212]                     base::options(mc.cores = 1L)
[18:06:06.212]                   }
[18:06:06.212]                   ...future.strategy.old <- future::plan("list")
[18:06:06.212]                   options(future.plan = NULL)
[18:06:06.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.212]                 }
[18:06:06.212]                 ...future.workdir <- getwd()
[18:06:06.212]             }
[18:06:06.212]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.212]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.212]         }
[18:06:06.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.212]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.212]             base::names(...future.oldOptions))
[18:06:06.212]     }
[18:06:06.212]     if (FALSE) {
[18:06:06.212]     }
[18:06:06.212]     else {
[18:06:06.212]         if (TRUE) {
[18:06:06.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.212]                 open = "w")
[18:06:06.212]         }
[18:06:06.212]         else {
[18:06:06.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.212]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.212]         }
[18:06:06.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.212]             base::sink(type = "output", split = FALSE)
[18:06:06.212]             base::close(...future.stdout)
[18:06:06.212]         }, add = TRUE)
[18:06:06.212]     }
[18:06:06.212]     ...future.frame <- base::sys.nframe()
[18:06:06.212]     ...future.conditions <- base::list()
[18:06:06.212]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.212]     if (FALSE) {
[18:06:06.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.212]     }
[18:06:06.212]     ...future.result <- base::tryCatch({
[18:06:06.212]         base::withCallingHandlers({
[18:06:06.212]             ...future.value <- base::withVisible(base::local({
[18:06:06.212]                 withCallingHandlers({
[18:06:06.212]                   1
[18:06:06.212]                 }, immediateCondition = function(cond) {
[18:06:06.212]                   save_rds <- function (object, pathname, ...) 
[18:06:06.212]                   {
[18:06:06.212]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.212]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.212]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.212]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.212]                         fi_tmp[["mtime"]])
[18:06:06.212]                     }
[18:06:06.212]                     tryCatch({
[18:06:06.212]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.212]                     }, error = function(ex) {
[18:06:06.212]                       msg <- conditionMessage(ex)
[18:06:06.212]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.212]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.212]                         fi_tmp[["mtime"]], msg)
[18:06:06.212]                       ex$message <- msg
[18:06:06.212]                       stop(ex)
[18:06:06.212]                     })
[18:06:06.212]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.212]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.212]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.212]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.212]                       fi <- file.info(pathname)
[18:06:06.212]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.212]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.212]                         fi[["size"]], fi[["mtime"]])
[18:06:06.212]                       stop(msg)
[18:06:06.212]                     }
[18:06:06.212]                     invisible(pathname)
[18:06:06.212]                   }
[18:06:06.212]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.212]                     rootPath = tempdir()) 
[18:06:06.212]                   {
[18:06:06.212]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.212]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.212]                       tmpdir = path, fileext = ".rds")
[18:06:06.212]                     save_rds(obj, file)
[18:06:06.212]                   }
[18:06:06.212]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.212]                   {
[18:06:06.212]                     inherits <- base::inherits
[18:06:06.212]                     invokeRestart <- base::invokeRestart
[18:06:06.212]                     is.null <- base::is.null
[18:06:06.212]                     muffled <- FALSE
[18:06:06.212]                     if (inherits(cond, "message")) {
[18:06:06.212]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.212]                       if (muffled) 
[18:06:06.212]                         invokeRestart("muffleMessage")
[18:06:06.212]                     }
[18:06:06.212]                     else if (inherits(cond, "warning")) {
[18:06:06.212]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.212]                       if (muffled) 
[18:06:06.212]                         invokeRestart("muffleWarning")
[18:06:06.212]                     }
[18:06:06.212]                     else if (inherits(cond, "condition")) {
[18:06:06.212]                       if (!is.null(pattern)) {
[18:06:06.212]                         computeRestarts <- base::computeRestarts
[18:06:06.212]                         grepl <- base::grepl
[18:06:06.212]                         restarts <- computeRestarts(cond)
[18:06:06.212]                         for (restart in restarts) {
[18:06:06.212]                           name <- restart$name
[18:06:06.212]                           if (is.null(name)) 
[18:06:06.212]                             next
[18:06:06.212]                           if (!grepl(pattern, name)) 
[18:06:06.212]                             next
[18:06:06.212]                           invokeRestart(restart)
[18:06:06.212]                           muffled <- TRUE
[18:06:06.212]                           break
[18:06:06.212]                         }
[18:06:06.212]                       }
[18:06:06.212]                     }
[18:06:06.212]                     invisible(muffled)
[18:06:06.212]                   }
[18:06:06.212]                   muffleCondition(cond)
[18:06:06.212]                 })
[18:06:06.212]             }))
[18:06:06.212]             future::FutureResult(value = ...future.value$value, 
[18:06:06.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.212]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.212]                     ...future.globalenv.names))
[18:06:06.212]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.212]         }, condition = base::local({
[18:06:06.212]             c <- base::c
[18:06:06.212]             inherits <- base::inherits
[18:06:06.212]             invokeRestart <- base::invokeRestart
[18:06:06.212]             length <- base::length
[18:06:06.212]             list <- base::list
[18:06:06.212]             seq.int <- base::seq.int
[18:06:06.212]             signalCondition <- base::signalCondition
[18:06:06.212]             sys.calls <- base::sys.calls
[18:06:06.212]             `[[` <- base::`[[`
[18:06:06.212]             `+` <- base::`+`
[18:06:06.212]             `<<-` <- base::`<<-`
[18:06:06.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.212]                   3L)]
[18:06:06.212]             }
[18:06:06.212]             function(cond) {
[18:06:06.212]                 is_error <- inherits(cond, "error")
[18:06:06.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.212]                   NULL)
[18:06:06.212]                 if (is_error) {
[18:06:06.212]                   sessionInformation <- function() {
[18:06:06.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.212]                       search = base::search(), system = base::Sys.info())
[18:06:06.212]                   }
[18:06:06.212]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.212]                     cond$call), session = sessionInformation(), 
[18:06:06.212]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.212]                   signalCondition(cond)
[18:06:06.212]                 }
[18:06:06.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.212]                 "immediateCondition"))) {
[18:06:06.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.212]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.212]                   if (TRUE && !signal) {
[18:06:06.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.212]                     {
[18:06:06.212]                       inherits <- base::inherits
[18:06:06.212]                       invokeRestart <- base::invokeRestart
[18:06:06.212]                       is.null <- base::is.null
[18:06:06.212]                       muffled <- FALSE
[18:06:06.212]                       if (inherits(cond, "message")) {
[18:06:06.212]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.212]                         if (muffled) 
[18:06:06.212]                           invokeRestart("muffleMessage")
[18:06:06.212]                       }
[18:06:06.212]                       else if (inherits(cond, "warning")) {
[18:06:06.212]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.212]                         if (muffled) 
[18:06:06.212]                           invokeRestart("muffleWarning")
[18:06:06.212]                       }
[18:06:06.212]                       else if (inherits(cond, "condition")) {
[18:06:06.212]                         if (!is.null(pattern)) {
[18:06:06.212]                           computeRestarts <- base::computeRestarts
[18:06:06.212]                           grepl <- base::grepl
[18:06:06.212]                           restarts <- computeRestarts(cond)
[18:06:06.212]                           for (restart in restarts) {
[18:06:06.212]                             name <- restart$name
[18:06:06.212]                             if (is.null(name)) 
[18:06:06.212]                               next
[18:06:06.212]                             if (!grepl(pattern, name)) 
[18:06:06.212]                               next
[18:06:06.212]                             invokeRestart(restart)
[18:06:06.212]                             muffled <- TRUE
[18:06:06.212]                             break
[18:06:06.212]                           }
[18:06:06.212]                         }
[18:06:06.212]                       }
[18:06:06.212]                       invisible(muffled)
[18:06:06.212]                     }
[18:06:06.212]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.212]                   }
[18:06:06.212]                 }
[18:06:06.212]                 else {
[18:06:06.212]                   if (TRUE) {
[18:06:06.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.212]                     {
[18:06:06.212]                       inherits <- base::inherits
[18:06:06.212]                       invokeRestart <- base::invokeRestart
[18:06:06.212]                       is.null <- base::is.null
[18:06:06.212]                       muffled <- FALSE
[18:06:06.212]                       if (inherits(cond, "message")) {
[18:06:06.212]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.212]                         if (muffled) 
[18:06:06.212]                           invokeRestart("muffleMessage")
[18:06:06.212]                       }
[18:06:06.212]                       else if (inherits(cond, "warning")) {
[18:06:06.212]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.212]                         if (muffled) 
[18:06:06.212]                           invokeRestart("muffleWarning")
[18:06:06.212]                       }
[18:06:06.212]                       else if (inherits(cond, "condition")) {
[18:06:06.212]                         if (!is.null(pattern)) {
[18:06:06.212]                           computeRestarts <- base::computeRestarts
[18:06:06.212]                           grepl <- base::grepl
[18:06:06.212]                           restarts <- computeRestarts(cond)
[18:06:06.212]                           for (restart in restarts) {
[18:06:06.212]                             name <- restart$name
[18:06:06.212]                             if (is.null(name)) 
[18:06:06.212]                               next
[18:06:06.212]                             if (!grepl(pattern, name)) 
[18:06:06.212]                               next
[18:06:06.212]                             invokeRestart(restart)
[18:06:06.212]                             muffled <- TRUE
[18:06:06.212]                             break
[18:06:06.212]                           }
[18:06:06.212]                         }
[18:06:06.212]                       }
[18:06:06.212]                       invisible(muffled)
[18:06:06.212]                     }
[18:06:06.212]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.212]                   }
[18:06:06.212]                 }
[18:06:06.212]             }
[18:06:06.212]         }))
[18:06:06.212]     }, error = function(ex) {
[18:06:06.212]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.212]                 ...future.rng), started = ...future.startTime, 
[18:06:06.212]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.212]             version = "1.8"), class = "FutureResult")
[18:06:06.212]     }, finally = {
[18:06:06.212]         if (!identical(...future.workdir, getwd())) 
[18:06:06.212]             setwd(...future.workdir)
[18:06:06.212]         {
[18:06:06.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.212]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.212]             }
[18:06:06.212]             base::options(...future.oldOptions)
[18:06:06.212]             if (.Platform$OS.type == "windows") {
[18:06:06.212]                 old_names <- names(...future.oldEnvVars)
[18:06:06.212]                 envs <- base::Sys.getenv()
[18:06:06.212]                 names <- names(envs)
[18:06:06.212]                 common <- intersect(names, old_names)
[18:06:06.212]                 added <- setdiff(names, old_names)
[18:06:06.212]                 removed <- setdiff(old_names, names)
[18:06:06.212]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.212]                   envs[common]]
[18:06:06.212]                 NAMES <- toupper(changed)
[18:06:06.212]                 args <- list()
[18:06:06.212]                 for (kk in seq_along(NAMES)) {
[18:06:06.212]                   name <- changed[[kk]]
[18:06:06.212]                   NAME <- NAMES[[kk]]
[18:06:06.212]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.212]                     next
[18:06:06.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.212]                 }
[18:06:06.212]                 NAMES <- toupper(added)
[18:06:06.212]                 for (kk in seq_along(NAMES)) {
[18:06:06.212]                   name <- added[[kk]]
[18:06:06.212]                   NAME <- NAMES[[kk]]
[18:06:06.212]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.212]                     next
[18:06:06.212]                   args[[name]] <- ""
[18:06:06.212]                 }
[18:06:06.212]                 NAMES <- toupper(removed)
[18:06:06.212]                 for (kk in seq_along(NAMES)) {
[18:06:06.212]                   name <- removed[[kk]]
[18:06:06.212]                   NAME <- NAMES[[kk]]
[18:06:06.212]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.212]                     next
[18:06:06.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.212]                 }
[18:06:06.212]                 if (length(args) > 0) 
[18:06:06.212]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.212]             }
[18:06:06.212]             else {
[18:06:06.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.212]             }
[18:06:06.212]             {
[18:06:06.212]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.212]                   0L) {
[18:06:06.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.212]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.212]                   base::options(opts)
[18:06:06.212]                 }
[18:06:06.212]                 {
[18:06:06.212]                   {
[18:06:06.212]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.212]                     NULL
[18:06:06.212]                   }
[18:06:06.212]                   options(future.plan = NULL)
[18:06:06.212]                   if (is.na(NA_character_)) 
[18:06:06.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.212]                     .init = FALSE)
[18:06:06.212]                 }
[18:06:06.212]             }
[18:06:06.212]         }
[18:06:06.212]     })
[18:06:06.212]     if (TRUE) {
[18:06:06.212]         base::sink(type = "output", split = FALSE)
[18:06:06.212]         if (TRUE) {
[18:06:06.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.212]         }
[18:06:06.212]         else {
[18:06:06.212]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.212]         }
[18:06:06.212]         base::close(...future.stdout)
[18:06:06.212]         ...future.stdout <- NULL
[18:06:06.212]     }
[18:06:06.212]     ...future.result$conditions <- ...future.conditions
[18:06:06.212]     ...future.result$finished <- base::Sys.time()
[18:06:06.212]     ...future.result
[18:06:06.212] }
[18:06:06.216] requestCore(): workers = 2
[18:06:06.221] MulticoreFuture started
[18:06:06.224] - Launch lazy future ... done
[18:06:06.224] run() for ‘MulticoreFuture’ ... done
[18:06:06.225] getGlobalsAndPackages() ...
[18:06:06.225] Searching for globals...
[18:06:06.227] plan(): Setting new future strategy stack:
[18:06:06.230] 
[18:06:06.227] List of future strategies:
[18:06:06.227] 1. sequential:
[18:06:06.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.227]    - tweaked: FALSE
[18:06:06.227]    - call: NULL
[18:06:06.231] plan(): nbrOfWorkers() = 1
[18:06:06.231] Searching for globals ... DONE
[18:06:06.233] - globals: [0] <none>
[18:06:06.233] getGlobalsAndPackages() ... DONE
[18:06:06.235] run() for ‘Future’ ...
[18:06:06.237] - state: ‘created’
[18:06:06.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.239] plan(): Setting new future strategy stack:
[18:06:06.240] List of future strategies:
[18:06:06.240] 1. multicore:
[18:06:06.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.240]    - tweaked: FALSE
[18:06:06.240]    - call: plan(strategy)
[18:06:06.253] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.253] plan(): nbrOfWorkers() = 2
[18:06:06.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.254]   - Field: ‘label’
[18:06:06.254]   - Field: ‘local’
[18:06:06.254]   - Field: ‘owner’
[18:06:06.255]   - Field: ‘envir’
[18:06:06.255]   - Field: ‘workers’
[18:06:06.255]   - Field: ‘packages’
[18:06:06.256]   - Field: ‘gc’
[18:06:06.256]   - Field: ‘job’
[18:06:06.256]   - Field: ‘conditions’
[18:06:06.257]   - Field: ‘expr’
[18:06:06.257]   - Field: ‘uuid’
[18:06:06.257]   - Field: ‘seed’
[18:06:06.258]   - Field: ‘version’
[18:06:06.258]   - Field: ‘result’
[18:06:06.258]   - Field: ‘asynchronous’
[18:06:06.258]   - Field: ‘calls’
[18:06:06.259]   - Field: ‘globals’
[18:06:06.259]   - Field: ‘stdout’
[18:06:06.259]   - Field: ‘earlySignal’
[18:06:06.260]   - Field: ‘lazy’
[18:06:06.260]   - Field: ‘state’
[18:06:06.260] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.261] - Launch lazy future ...
[18:06:06.262] Packages needed by the future expression (n = 0): <none>
[18:06:06.262] Packages needed by future strategies (n = 0): <none>
[18:06:06.263] {
[18:06:06.263]     {
[18:06:06.263]         {
[18:06:06.263]             ...future.startTime <- base::Sys.time()
[18:06:06.263]             {
[18:06:06.263]                 {
[18:06:06.263]                   {
[18:06:06.263]                     {
[18:06:06.263]                       base::local({
[18:06:06.263]                         has_future <- base::requireNamespace("future", 
[18:06:06.263]                           quietly = TRUE)
[18:06:06.263]                         if (has_future) {
[18:06:06.263]                           ns <- base::getNamespace("future")
[18:06:06.263]                           version <- ns[[".package"]][["version"]]
[18:06:06.263]                           if (is.null(version)) 
[18:06:06.263]                             version <- utils::packageVersion("future")
[18:06:06.263]                         }
[18:06:06.263]                         else {
[18:06:06.263]                           version <- NULL
[18:06:06.263]                         }
[18:06:06.263]                         if (!has_future || version < "1.8.0") {
[18:06:06.263]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.263]                             "", base::R.version$version.string), 
[18:06:06.263]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.263]                               "release", "version")], collapse = " "), 
[18:06:06.263]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.263]                             info)
[18:06:06.263]                           info <- base::paste(info, collapse = "; ")
[18:06:06.263]                           if (!has_future) {
[18:06:06.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.263]                               info)
[18:06:06.263]                           }
[18:06:06.263]                           else {
[18:06:06.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.263]                               info, version)
[18:06:06.263]                           }
[18:06:06.263]                           base::stop(msg)
[18:06:06.263]                         }
[18:06:06.263]                       })
[18:06:06.263]                     }
[18:06:06.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.263]                     base::options(mc.cores = 1L)
[18:06:06.263]                   }
[18:06:06.263]                   ...future.strategy.old <- future::plan("list")
[18:06:06.263]                   options(future.plan = NULL)
[18:06:06.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.263]                 }
[18:06:06.263]                 ...future.workdir <- getwd()
[18:06:06.263]             }
[18:06:06.263]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.263]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.263]         }
[18:06:06.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.263]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.263]             base::names(...future.oldOptions))
[18:06:06.263]     }
[18:06:06.263]     if (FALSE) {
[18:06:06.263]     }
[18:06:06.263]     else {
[18:06:06.263]         if (TRUE) {
[18:06:06.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.263]                 open = "w")
[18:06:06.263]         }
[18:06:06.263]         else {
[18:06:06.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.263]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.263]         }
[18:06:06.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.263]             base::sink(type = "output", split = FALSE)
[18:06:06.263]             base::close(...future.stdout)
[18:06:06.263]         }, add = TRUE)
[18:06:06.263]     }
[18:06:06.263]     ...future.frame <- base::sys.nframe()
[18:06:06.263]     ...future.conditions <- base::list()
[18:06:06.263]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.263]     if (FALSE) {
[18:06:06.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.263]     }
[18:06:06.263]     ...future.result <- base::tryCatch({
[18:06:06.263]         base::withCallingHandlers({
[18:06:06.263]             ...future.value <- base::withVisible(base::local({
[18:06:06.263]                 withCallingHandlers({
[18:06:06.263]                   2
[18:06:06.263]                 }, immediateCondition = function(cond) {
[18:06:06.263]                   save_rds <- function (object, pathname, ...) 
[18:06:06.263]                   {
[18:06:06.263]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.263]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.263]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.263]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.263]                         fi_tmp[["mtime"]])
[18:06:06.263]                     }
[18:06:06.263]                     tryCatch({
[18:06:06.263]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.263]                     }, error = function(ex) {
[18:06:06.263]                       msg <- conditionMessage(ex)
[18:06:06.263]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.263]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.263]                         fi_tmp[["mtime"]], msg)
[18:06:06.263]                       ex$message <- msg
[18:06:06.263]                       stop(ex)
[18:06:06.263]                     })
[18:06:06.263]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.263]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.263]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.263]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.263]                       fi <- file.info(pathname)
[18:06:06.263]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.263]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.263]                         fi[["size"]], fi[["mtime"]])
[18:06:06.263]                       stop(msg)
[18:06:06.263]                     }
[18:06:06.263]                     invisible(pathname)
[18:06:06.263]                   }
[18:06:06.263]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.263]                     rootPath = tempdir()) 
[18:06:06.263]                   {
[18:06:06.263]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.263]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.263]                       tmpdir = path, fileext = ".rds")
[18:06:06.263]                     save_rds(obj, file)
[18:06:06.263]                   }
[18:06:06.263]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.263]                   {
[18:06:06.263]                     inherits <- base::inherits
[18:06:06.263]                     invokeRestart <- base::invokeRestart
[18:06:06.263]                     is.null <- base::is.null
[18:06:06.263]                     muffled <- FALSE
[18:06:06.263]                     if (inherits(cond, "message")) {
[18:06:06.263]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.263]                       if (muffled) 
[18:06:06.263]                         invokeRestart("muffleMessage")
[18:06:06.263]                     }
[18:06:06.263]                     else if (inherits(cond, "warning")) {
[18:06:06.263]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.263]                       if (muffled) 
[18:06:06.263]                         invokeRestart("muffleWarning")
[18:06:06.263]                     }
[18:06:06.263]                     else if (inherits(cond, "condition")) {
[18:06:06.263]                       if (!is.null(pattern)) {
[18:06:06.263]                         computeRestarts <- base::computeRestarts
[18:06:06.263]                         grepl <- base::grepl
[18:06:06.263]                         restarts <- computeRestarts(cond)
[18:06:06.263]                         for (restart in restarts) {
[18:06:06.263]                           name <- restart$name
[18:06:06.263]                           if (is.null(name)) 
[18:06:06.263]                             next
[18:06:06.263]                           if (!grepl(pattern, name)) 
[18:06:06.263]                             next
[18:06:06.263]                           invokeRestart(restart)
[18:06:06.263]                           muffled <- TRUE
[18:06:06.263]                           break
[18:06:06.263]                         }
[18:06:06.263]                       }
[18:06:06.263]                     }
[18:06:06.263]                     invisible(muffled)
[18:06:06.263]                   }
[18:06:06.263]                   muffleCondition(cond)
[18:06:06.263]                 })
[18:06:06.263]             }))
[18:06:06.263]             future::FutureResult(value = ...future.value$value, 
[18:06:06.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.263]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.263]                     ...future.globalenv.names))
[18:06:06.263]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.263]         }, condition = base::local({
[18:06:06.263]             c <- base::c
[18:06:06.263]             inherits <- base::inherits
[18:06:06.263]             invokeRestart <- base::invokeRestart
[18:06:06.263]             length <- base::length
[18:06:06.263]             list <- base::list
[18:06:06.263]             seq.int <- base::seq.int
[18:06:06.263]             signalCondition <- base::signalCondition
[18:06:06.263]             sys.calls <- base::sys.calls
[18:06:06.263]             `[[` <- base::`[[`
[18:06:06.263]             `+` <- base::`+`
[18:06:06.263]             `<<-` <- base::`<<-`
[18:06:06.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.263]                   3L)]
[18:06:06.263]             }
[18:06:06.263]             function(cond) {
[18:06:06.263]                 is_error <- inherits(cond, "error")
[18:06:06.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.263]                   NULL)
[18:06:06.263]                 if (is_error) {
[18:06:06.263]                   sessionInformation <- function() {
[18:06:06.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.263]                       search = base::search(), system = base::Sys.info())
[18:06:06.263]                   }
[18:06:06.263]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.263]                     cond$call), session = sessionInformation(), 
[18:06:06.263]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.263]                   signalCondition(cond)
[18:06:06.263]                 }
[18:06:06.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.263]                 "immediateCondition"))) {
[18:06:06.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.263]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.263]                   if (TRUE && !signal) {
[18:06:06.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.263]                     {
[18:06:06.263]                       inherits <- base::inherits
[18:06:06.263]                       invokeRestart <- base::invokeRestart
[18:06:06.263]                       is.null <- base::is.null
[18:06:06.263]                       muffled <- FALSE
[18:06:06.263]                       if (inherits(cond, "message")) {
[18:06:06.263]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.263]                         if (muffled) 
[18:06:06.263]                           invokeRestart("muffleMessage")
[18:06:06.263]                       }
[18:06:06.263]                       else if (inherits(cond, "warning")) {
[18:06:06.263]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.263]                         if (muffled) 
[18:06:06.263]                           invokeRestart("muffleWarning")
[18:06:06.263]                       }
[18:06:06.263]                       else if (inherits(cond, "condition")) {
[18:06:06.263]                         if (!is.null(pattern)) {
[18:06:06.263]                           computeRestarts <- base::computeRestarts
[18:06:06.263]                           grepl <- base::grepl
[18:06:06.263]                           restarts <- computeRestarts(cond)
[18:06:06.263]                           for (restart in restarts) {
[18:06:06.263]                             name <- restart$name
[18:06:06.263]                             if (is.null(name)) 
[18:06:06.263]                               next
[18:06:06.263]                             if (!grepl(pattern, name)) 
[18:06:06.263]                               next
[18:06:06.263]                             invokeRestart(restart)
[18:06:06.263]                             muffled <- TRUE
[18:06:06.263]                             break
[18:06:06.263]                           }
[18:06:06.263]                         }
[18:06:06.263]                       }
[18:06:06.263]                       invisible(muffled)
[18:06:06.263]                     }
[18:06:06.263]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.263]                   }
[18:06:06.263]                 }
[18:06:06.263]                 else {
[18:06:06.263]                   if (TRUE) {
[18:06:06.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.263]                     {
[18:06:06.263]                       inherits <- base::inherits
[18:06:06.263]                       invokeRestart <- base::invokeRestart
[18:06:06.263]                       is.null <- base::is.null
[18:06:06.263]                       muffled <- FALSE
[18:06:06.263]                       if (inherits(cond, "message")) {
[18:06:06.263]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.263]                         if (muffled) 
[18:06:06.263]                           invokeRestart("muffleMessage")
[18:06:06.263]                       }
[18:06:06.263]                       else if (inherits(cond, "warning")) {
[18:06:06.263]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.263]                         if (muffled) 
[18:06:06.263]                           invokeRestart("muffleWarning")
[18:06:06.263]                       }
[18:06:06.263]                       else if (inherits(cond, "condition")) {
[18:06:06.263]                         if (!is.null(pattern)) {
[18:06:06.263]                           computeRestarts <- base::computeRestarts
[18:06:06.263]                           grepl <- base::grepl
[18:06:06.263]                           restarts <- computeRestarts(cond)
[18:06:06.263]                           for (restart in restarts) {
[18:06:06.263]                             name <- restart$name
[18:06:06.263]                             if (is.null(name)) 
[18:06:06.263]                               next
[18:06:06.263]                             if (!grepl(pattern, name)) 
[18:06:06.263]                               next
[18:06:06.263]                             invokeRestart(restart)
[18:06:06.263]                             muffled <- TRUE
[18:06:06.263]                             break
[18:06:06.263]                           }
[18:06:06.263]                         }
[18:06:06.263]                       }
[18:06:06.263]                       invisible(muffled)
[18:06:06.263]                     }
[18:06:06.263]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.263]                   }
[18:06:06.263]                 }
[18:06:06.263]             }
[18:06:06.263]         }))
[18:06:06.263]     }, error = function(ex) {
[18:06:06.263]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.263]                 ...future.rng), started = ...future.startTime, 
[18:06:06.263]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.263]             version = "1.8"), class = "FutureResult")
[18:06:06.263]     }, finally = {
[18:06:06.263]         if (!identical(...future.workdir, getwd())) 
[18:06:06.263]             setwd(...future.workdir)
[18:06:06.263]         {
[18:06:06.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.263]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.263]             }
[18:06:06.263]             base::options(...future.oldOptions)
[18:06:06.263]             if (.Platform$OS.type == "windows") {
[18:06:06.263]                 old_names <- names(...future.oldEnvVars)
[18:06:06.263]                 envs <- base::Sys.getenv()
[18:06:06.263]                 names <- names(envs)
[18:06:06.263]                 common <- intersect(names, old_names)
[18:06:06.263]                 added <- setdiff(names, old_names)
[18:06:06.263]                 removed <- setdiff(old_names, names)
[18:06:06.263]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.263]                   envs[common]]
[18:06:06.263]                 NAMES <- toupper(changed)
[18:06:06.263]                 args <- list()
[18:06:06.263]                 for (kk in seq_along(NAMES)) {
[18:06:06.263]                   name <- changed[[kk]]
[18:06:06.263]                   NAME <- NAMES[[kk]]
[18:06:06.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.263]                     next
[18:06:06.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.263]                 }
[18:06:06.263]                 NAMES <- toupper(added)
[18:06:06.263]                 for (kk in seq_along(NAMES)) {
[18:06:06.263]                   name <- added[[kk]]
[18:06:06.263]                   NAME <- NAMES[[kk]]
[18:06:06.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.263]                     next
[18:06:06.263]                   args[[name]] <- ""
[18:06:06.263]                 }
[18:06:06.263]                 NAMES <- toupper(removed)
[18:06:06.263]                 for (kk in seq_along(NAMES)) {
[18:06:06.263]                   name <- removed[[kk]]
[18:06:06.263]                   NAME <- NAMES[[kk]]
[18:06:06.263]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.263]                     next
[18:06:06.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.263]                 }
[18:06:06.263]                 if (length(args) > 0) 
[18:06:06.263]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.263]             }
[18:06:06.263]             else {
[18:06:06.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.263]             }
[18:06:06.263]             {
[18:06:06.263]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.263]                   0L) {
[18:06:06.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.263]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.263]                   base::options(opts)
[18:06:06.263]                 }
[18:06:06.263]                 {
[18:06:06.263]                   {
[18:06:06.263]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.263]                     NULL
[18:06:06.263]                   }
[18:06:06.263]                   options(future.plan = NULL)
[18:06:06.263]                   if (is.na(NA_character_)) 
[18:06:06.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.263]                     .init = FALSE)
[18:06:06.263]                 }
[18:06:06.263]             }
[18:06:06.263]         }
[18:06:06.263]     })
[18:06:06.263]     if (TRUE) {
[18:06:06.263]         base::sink(type = "output", split = FALSE)
[18:06:06.263]         if (TRUE) {
[18:06:06.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.263]         }
[18:06:06.263]         else {
[18:06:06.263]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.263]         }
[18:06:06.263]         base::close(...future.stdout)
[18:06:06.263]         ...future.stdout <- NULL
[18:06:06.263]     }
[18:06:06.263]     ...future.result$conditions <- ...future.conditions
[18:06:06.263]     ...future.result$finished <- base::Sys.time()
[18:06:06.263]     ...future.result
[18:06:06.263] }
[18:06:06.270] requestCore(): workers = 2
[18:06:06.284] MulticoreFuture started
[18:06:06.285] - Launch lazy future ... done
[18:06:06.285] run() for ‘MulticoreFuture’ ... done
[18:06:06.286] resolve() on list ...
[18:06:06.286]  recursive: 0
[18:06:06.288] plan(): Setting new future strategy stack:
[18:06:06.288] List of future strategies:
[18:06:06.288] 1. sequential:
[18:06:06.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.288]    - tweaked: FALSE
[18:06:06.288]    - call: NULL
[18:06:06.363] plan(): nbrOfWorkers() = 1
[18:06:06.287]  length: 3
[18:06:06.365]  elements: ‘a’, ‘b’, ‘’
[18:06:06.366] plan(): Setting new future strategy stack:
[18:06:06.366] List of future strategies:
[18:06:06.366] 1. multicore:
[18:06:06.366]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.366]    - tweaked: FALSE
[18:06:06.366]    - call: plan(strategy)
[18:06:06.367] Future #1
[18:06:06.367]  length: 2 (resolved future 1)
[18:06:06.374] plan(): nbrOfWorkers() = 2
[18:06:06.375] Future #2
[18:06:06.375]  length: 1 (resolved future 2)
[18:06:06.376]  length: 0 (resolved future 3)
[18:06:06.376] resolve() on list ... DONE
[18:06:06.377] getGlobalsAndPackages() ...
[18:06:06.377] Searching for globals...
[18:06:06.377] 
[18:06:06.378] Searching for globals ... DONE
[18:06:06.378] - globals: [0] <none>
[18:06:06.378] getGlobalsAndPackages() ... DONE
[18:06:06.379] getGlobalsAndPackages() ...
[18:06:06.379] Searching for globals...
[18:06:06.379] 
[18:06:06.379] Searching for globals ... DONE
[18:06:06.380] - globals: [0] <none>
[18:06:06.380] getGlobalsAndPackages() ... DONE
[18:06:06.380] run() for ‘Future’ ...
[18:06:06.381] - state: ‘created’
[18:06:06.381] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.387] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.387]   - Field: ‘label’
[18:06:06.388]   - Field: ‘local’
[18:06:06.388]   - Field: ‘owner’
[18:06:06.388]   - Field: ‘envir’
[18:06:06.388]   - Field: ‘workers’
[18:06:06.388]   - Field: ‘packages’
[18:06:06.389]   - Field: ‘gc’
[18:06:06.389]   - Field: ‘job’
[18:06:06.389]   - Field: ‘conditions’
[18:06:06.389]   - Field: ‘expr’
[18:06:06.389]   - Field: ‘uuid’
[18:06:06.390]   - Field: ‘seed’
[18:06:06.390]   - Field: ‘version’
[18:06:06.390]   - Field: ‘result’
[18:06:06.390]   - Field: ‘asynchronous’
[18:06:06.390]   - Field: ‘calls’
[18:06:06.391]   - Field: ‘globals’
[18:06:06.391]   - Field: ‘stdout’
[18:06:06.391]   - Field: ‘earlySignal’
[18:06:06.391]   - Field: ‘lazy’
[18:06:06.392]   - Field: ‘state’
[18:06:06.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.392] - Launch lazy future ...
[18:06:06.393] Packages needed by the future expression (n = 0): <none>
[18:06:06.393] Packages needed by future strategies (n = 0): <none>
[18:06:06.394] {
[18:06:06.394]     {
[18:06:06.394]         {
[18:06:06.394]             ...future.startTime <- base::Sys.time()
[18:06:06.394]             {
[18:06:06.394]                 {
[18:06:06.394]                   {
[18:06:06.394]                     {
[18:06:06.394]                       base::local({
[18:06:06.394]                         has_future <- base::requireNamespace("future", 
[18:06:06.394]                           quietly = TRUE)
[18:06:06.394]                         if (has_future) {
[18:06:06.394]                           ns <- base::getNamespace("future")
[18:06:06.394]                           version <- ns[[".package"]][["version"]]
[18:06:06.394]                           if (is.null(version)) 
[18:06:06.394]                             version <- utils::packageVersion("future")
[18:06:06.394]                         }
[18:06:06.394]                         else {
[18:06:06.394]                           version <- NULL
[18:06:06.394]                         }
[18:06:06.394]                         if (!has_future || version < "1.8.0") {
[18:06:06.394]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.394]                             "", base::R.version$version.string), 
[18:06:06.394]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.394]                               "release", "version")], collapse = " "), 
[18:06:06.394]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.394]                             info)
[18:06:06.394]                           info <- base::paste(info, collapse = "; ")
[18:06:06.394]                           if (!has_future) {
[18:06:06.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.394]                               info)
[18:06:06.394]                           }
[18:06:06.394]                           else {
[18:06:06.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.394]                               info, version)
[18:06:06.394]                           }
[18:06:06.394]                           base::stop(msg)
[18:06:06.394]                         }
[18:06:06.394]                       })
[18:06:06.394]                     }
[18:06:06.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.394]                     base::options(mc.cores = 1L)
[18:06:06.394]                   }
[18:06:06.394]                   ...future.strategy.old <- future::plan("list")
[18:06:06.394]                   options(future.plan = NULL)
[18:06:06.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.394]                 }
[18:06:06.394]                 ...future.workdir <- getwd()
[18:06:06.394]             }
[18:06:06.394]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.394]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.394]         }
[18:06:06.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.394]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.394]             base::names(...future.oldOptions))
[18:06:06.394]     }
[18:06:06.394]     if (FALSE) {
[18:06:06.394]     }
[18:06:06.394]     else {
[18:06:06.394]         if (TRUE) {
[18:06:06.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.394]                 open = "w")
[18:06:06.394]         }
[18:06:06.394]         else {
[18:06:06.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.394]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.394]         }
[18:06:06.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.394]             base::sink(type = "output", split = FALSE)
[18:06:06.394]             base::close(...future.stdout)
[18:06:06.394]         }, add = TRUE)
[18:06:06.394]     }
[18:06:06.394]     ...future.frame <- base::sys.nframe()
[18:06:06.394]     ...future.conditions <- base::list()
[18:06:06.394]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.394]     if (FALSE) {
[18:06:06.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.394]     }
[18:06:06.394]     ...future.result <- base::tryCatch({
[18:06:06.394]         base::withCallingHandlers({
[18:06:06.394]             ...future.value <- base::withVisible(base::local({
[18:06:06.394]                 withCallingHandlers({
[18:06:06.394]                   2
[18:06:06.394]                 }, immediateCondition = function(cond) {
[18:06:06.394]                   save_rds <- function (object, pathname, ...) 
[18:06:06.394]                   {
[18:06:06.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.394]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.394]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.394]                         fi_tmp[["mtime"]])
[18:06:06.394]                     }
[18:06:06.394]                     tryCatch({
[18:06:06.394]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.394]                     }, error = function(ex) {
[18:06:06.394]                       msg <- conditionMessage(ex)
[18:06:06.394]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.394]                         fi_tmp[["mtime"]], msg)
[18:06:06.394]                       ex$message <- msg
[18:06:06.394]                       stop(ex)
[18:06:06.394]                     })
[18:06:06.394]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.394]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.394]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.394]                       fi <- file.info(pathname)
[18:06:06.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.394]                         fi[["size"]], fi[["mtime"]])
[18:06:06.394]                       stop(msg)
[18:06:06.394]                     }
[18:06:06.394]                     invisible(pathname)
[18:06:06.394]                   }
[18:06:06.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.394]                     rootPath = tempdir()) 
[18:06:06.394]                   {
[18:06:06.394]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.394]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.394]                       tmpdir = path, fileext = ".rds")
[18:06:06.394]                     save_rds(obj, file)
[18:06:06.394]                   }
[18:06:06.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.394]                   {
[18:06:06.394]                     inherits <- base::inherits
[18:06:06.394]                     invokeRestart <- base::invokeRestart
[18:06:06.394]                     is.null <- base::is.null
[18:06:06.394]                     muffled <- FALSE
[18:06:06.394]                     if (inherits(cond, "message")) {
[18:06:06.394]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.394]                       if (muffled) 
[18:06:06.394]                         invokeRestart("muffleMessage")
[18:06:06.394]                     }
[18:06:06.394]                     else if (inherits(cond, "warning")) {
[18:06:06.394]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.394]                       if (muffled) 
[18:06:06.394]                         invokeRestart("muffleWarning")
[18:06:06.394]                     }
[18:06:06.394]                     else if (inherits(cond, "condition")) {
[18:06:06.394]                       if (!is.null(pattern)) {
[18:06:06.394]                         computeRestarts <- base::computeRestarts
[18:06:06.394]                         grepl <- base::grepl
[18:06:06.394]                         restarts <- computeRestarts(cond)
[18:06:06.394]                         for (restart in restarts) {
[18:06:06.394]                           name <- restart$name
[18:06:06.394]                           if (is.null(name)) 
[18:06:06.394]                             next
[18:06:06.394]                           if (!grepl(pattern, name)) 
[18:06:06.394]                             next
[18:06:06.394]                           invokeRestart(restart)
[18:06:06.394]                           muffled <- TRUE
[18:06:06.394]                           break
[18:06:06.394]                         }
[18:06:06.394]                       }
[18:06:06.394]                     }
[18:06:06.394]                     invisible(muffled)
[18:06:06.394]                   }
[18:06:06.394]                   muffleCondition(cond)
[18:06:06.394]                 })
[18:06:06.394]             }))
[18:06:06.394]             future::FutureResult(value = ...future.value$value, 
[18:06:06.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.394]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.394]                     ...future.globalenv.names))
[18:06:06.394]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.394]         }, condition = base::local({
[18:06:06.394]             c <- base::c
[18:06:06.394]             inherits <- base::inherits
[18:06:06.394]             invokeRestart <- base::invokeRestart
[18:06:06.394]             length <- base::length
[18:06:06.394]             list <- base::list
[18:06:06.394]             seq.int <- base::seq.int
[18:06:06.394]             signalCondition <- base::signalCondition
[18:06:06.394]             sys.calls <- base::sys.calls
[18:06:06.394]             `[[` <- base::`[[`
[18:06:06.394]             `+` <- base::`+`
[18:06:06.394]             `<<-` <- base::`<<-`
[18:06:06.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.394]                   3L)]
[18:06:06.394]             }
[18:06:06.394]             function(cond) {
[18:06:06.394]                 is_error <- inherits(cond, "error")
[18:06:06.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.394]                   NULL)
[18:06:06.394]                 if (is_error) {
[18:06:06.394]                   sessionInformation <- function() {
[18:06:06.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.394]                       search = base::search(), system = base::Sys.info())
[18:06:06.394]                   }
[18:06:06.394]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.394]                     cond$call), session = sessionInformation(), 
[18:06:06.394]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.394]                   signalCondition(cond)
[18:06:06.394]                 }
[18:06:06.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.394]                 "immediateCondition"))) {
[18:06:06.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.394]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.394]                   if (TRUE && !signal) {
[18:06:06.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.394]                     {
[18:06:06.394]                       inherits <- base::inherits
[18:06:06.394]                       invokeRestart <- base::invokeRestart
[18:06:06.394]                       is.null <- base::is.null
[18:06:06.394]                       muffled <- FALSE
[18:06:06.394]                       if (inherits(cond, "message")) {
[18:06:06.394]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.394]                         if (muffled) 
[18:06:06.394]                           invokeRestart("muffleMessage")
[18:06:06.394]                       }
[18:06:06.394]                       else if (inherits(cond, "warning")) {
[18:06:06.394]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.394]                         if (muffled) 
[18:06:06.394]                           invokeRestart("muffleWarning")
[18:06:06.394]                       }
[18:06:06.394]                       else if (inherits(cond, "condition")) {
[18:06:06.394]                         if (!is.null(pattern)) {
[18:06:06.394]                           computeRestarts <- base::computeRestarts
[18:06:06.394]                           grepl <- base::grepl
[18:06:06.394]                           restarts <- computeRestarts(cond)
[18:06:06.394]                           for (restart in restarts) {
[18:06:06.394]                             name <- restart$name
[18:06:06.394]                             if (is.null(name)) 
[18:06:06.394]                               next
[18:06:06.394]                             if (!grepl(pattern, name)) 
[18:06:06.394]                               next
[18:06:06.394]                             invokeRestart(restart)
[18:06:06.394]                             muffled <- TRUE
[18:06:06.394]                             break
[18:06:06.394]                           }
[18:06:06.394]                         }
[18:06:06.394]                       }
[18:06:06.394]                       invisible(muffled)
[18:06:06.394]                     }
[18:06:06.394]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.394]                   }
[18:06:06.394]                 }
[18:06:06.394]                 else {
[18:06:06.394]                   if (TRUE) {
[18:06:06.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.394]                     {
[18:06:06.394]                       inherits <- base::inherits
[18:06:06.394]                       invokeRestart <- base::invokeRestart
[18:06:06.394]                       is.null <- base::is.null
[18:06:06.394]                       muffled <- FALSE
[18:06:06.394]                       if (inherits(cond, "message")) {
[18:06:06.394]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.394]                         if (muffled) 
[18:06:06.394]                           invokeRestart("muffleMessage")
[18:06:06.394]                       }
[18:06:06.394]                       else if (inherits(cond, "warning")) {
[18:06:06.394]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.394]                         if (muffled) 
[18:06:06.394]                           invokeRestart("muffleWarning")
[18:06:06.394]                       }
[18:06:06.394]                       else if (inherits(cond, "condition")) {
[18:06:06.394]                         if (!is.null(pattern)) {
[18:06:06.394]                           computeRestarts <- base::computeRestarts
[18:06:06.394]                           grepl <- base::grepl
[18:06:06.394]                           restarts <- computeRestarts(cond)
[18:06:06.394]                           for (restart in restarts) {
[18:06:06.394]                             name <- restart$name
[18:06:06.394]                             if (is.null(name)) 
[18:06:06.394]                               next
[18:06:06.394]                             if (!grepl(pattern, name)) 
[18:06:06.394]                               next
[18:06:06.394]                             invokeRestart(restart)
[18:06:06.394]                             muffled <- TRUE
[18:06:06.394]                             break
[18:06:06.394]                           }
[18:06:06.394]                         }
[18:06:06.394]                       }
[18:06:06.394]                       invisible(muffled)
[18:06:06.394]                     }
[18:06:06.394]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.394]                   }
[18:06:06.394]                 }
[18:06:06.394]             }
[18:06:06.394]         }))
[18:06:06.394]     }, error = function(ex) {
[18:06:06.394]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.394]                 ...future.rng), started = ...future.startTime, 
[18:06:06.394]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.394]             version = "1.8"), class = "FutureResult")
[18:06:06.394]     }, finally = {
[18:06:06.394]         if (!identical(...future.workdir, getwd())) 
[18:06:06.394]             setwd(...future.workdir)
[18:06:06.394]         {
[18:06:06.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.394]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.394]             }
[18:06:06.394]             base::options(...future.oldOptions)
[18:06:06.394]             if (.Platform$OS.type == "windows") {
[18:06:06.394]                 old_names <- names(...future.oldEnvVars)
[18:06:06.394]                 envs <- base::Sys.getenv()
[18:06:06.394]                 names <- names(envs)
[18:06:06.394]                 common <- intersect(names, old_names)
[18:06:06.394]                 added <- setdiff(names, old_names)
[18:06:06.394]                 removed <- setdiff(old_names, names)
[18:06:06.394]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.394]                   envs[common]]
[18:06:06.394]                 NAMES <- toupper(changed)
[18:06:06.394]                 args <- list()
[18:06:06.394]                 for (kk in seq_along(NAMES)) {
[18:06:06.394]                   name <- changed[[kk]]
[18:06:06.394]                   NAME <- NAMES[[kk]]
[18:06:06.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.394]                     next
[18:06:06.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.394]                 }
[18:06:06.394]                 NAMES <- toupper(added)
[18:06:06.394]                 for (kk in seq_along(NAMES)) {
[18:06:06.394]                   name <- added[[kk]]
[18:06:06.394]                   NAME <- NAMES[[kk]]
[18:06:06.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.394]                     next
[18:06:06.394]                   args[[name]] <- ""
[18:06:06.394]                 }
[18:06:06.394]                 NAMES <- toupper(removed)
[18:06:06.394]                 for (kk in seq_along(NAMES)) {
[18:06:06.394]                   name <- removed[[kk]]
[18:06:06.394]                   NAME <- NAMES[[kk]]
[18:06:06.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.394]                     next
[18:06:06.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.394]                 }
[18:06:06.394]                 if (length(args) > 0) 
[18:06:06.394]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.394]             }
[18:06:06.394]             else {
[18:06:06.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.394]             }
[18:06:06.394]             {
[18:06:06.394]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.394]                   0L) {
[18:06:06.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.394]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.394]                   base::options(opts)
[18:06:06.394]                 }
[18:06:06.394]                 {
[18:06:06.394]                   {
[18:06:06.394]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.394]                     NULL
[18:06:06.394]                   }
[18:06:06.394]                   options(future.plan = NULL)
[18:06:06.394]                   if (is.na(NA_character_)) 
[18:06:06.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.394]                     .init = FALSE)
[18:06:06.394]                 }
[18:06:06.394]             }
[18:06:06.394]         }
[18:06:06.394]     })
[18:06:06.394]     if (TRUE) {
[18:06:06.394]         base::sink(type = "output", split = FALSE)
[18:06:06.394]         if (TRUE) {
[18:06:06.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.394]         }
[18:06:06.394]         else {
[18:06:06.394]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.394]         }
[18:06:06.394]         base::close(...future.stdout)
[18:06:06.394]         ...future.stdout <- NULL
[18:06:06.394]     }
[18:06:06.394]     ...future.result$conditions <- ...future.conditions
[18:06:06.394]     ...future.result$finished <- base::Sys.time()
[18:06:06.394]     ...future.result
[18:06:06.394] }
[18:06:06.398] requestCore(): workers = 2
[18:06:06.399] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:06.410] result() for MulticoreFuture ...
[18:06:06.412] result() for MulticoreFuture ...
[18:06:06.413] result() for MulticoreFuture ... done
[18:06:06.413] result() for MulticoreFuture ... done
[18:06:06.413] result() for MulticoreFuture ...
[18:06:06.413] result() for MulticoreFuture ... done
[18:06:06.418] MulticoreFuture started
[18:06:06.419] - Launch lazy future ... done
[18:06:06.419] run() for ‘MulticoreFuture’ ... done
[18:06:06.420] resolve() on list ...
[18:06:06.420] plan(): Setting new future strategy stack:
[18:06:06.420]  recursive: 0
[18:06:06.421]  length: 3
[18:06:06.421]  elements: ‘a’, ‘b’, ‘’
[18:06:06.422] run() for ‘Future’ ...
[18:06:06.422] - state: ‘created’
[18:06:06.421] List of future strategies:
[18:06:06.421] 1. sequential:
[18:06:06.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.421]    - tweaked: FALSE
[18:06:06.421]    - call: NULL
[18:06:06.422] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.423] plan(): nbrOfWorkers() = 1
[18:06:06.427] plan(): Setting new future strategy stack:
[18:06:06.427] List of future strategies:
[18:06:06.427] 1. multicore:
[18:06:06.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.427]    - tweaked: FALSE
[18:06:06.427]    - call: plan(strategy)
[18:06:06.432] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.432]   - Field: ‘label’
[18:06:06.433]   - Field: ‘local’
[18:06:06.433]   - Field: ‘owner’
[18:06:06.434]   - Field: ‘envir’
[18:06:06.434]   - Field: ‘workers’
[18:06:06.434]   - Field: ‘packages’
[18:06:06.435]   - Field: ‘gc’
[18:06:06.435]   - Field: ‘job’
[18:06:06.435]   - Field: ‘conditions’
[18:06:06.436] plan(): nbrOfWorkers() = 2
[18:06:06.436]   - Field: ‘expr’
[18:06:06.436]   - Field: ‘uuid’
[18:06:06.436]   - Field: ‘seed’
[18:06:06.437]   - Field: ‘version’
[18:06:06.437]   - Field: ‘result’
[18:06:06.437]   - Field: ‘asynchronous’
[18:06:06.438]   - Field: ‘calls’
[18:06:06.438]   - Field: ‘globals’
[18:06:06.438]   - Field: ‘stdout’
[18:06:06.439]   - Field: ‘earlySignal’
[18:06:06.439]   - Field: ‘lazy’
[18:06:06.439]   - Field: ‘state’
[18:06:06.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.440] - Launch lazy future ...
[18:06:06.441] Packages needed by the future expression (n = 0): <none>
[18:06:06.441] Packages needed by future strategies (n = 0): <none>
[18:06:06.443] {
[18:06:06.443]     {
[18:06:06.443]         {
[18:06:06.443]             ...future.startTime <- base::Sys.time()
[18:06:06.443]             {
[18:06:06.443]                 {
[18:06:06.443]                   {
[18:06:06.443]                     {
[18:06:06.443]                       base::local({
[18:06:06.443]                         has_future <- base::requireNamespace("future", 
[18:06:06.443]                           quietly = TRUE)
[18:06:06.443]                         if (has_future) {
[18:06:06.443]                           ns <- base::getNamespace("future")
[18:06:06.443]                           version <- ns[[".package"]][["version"]]
[18:06:06.443]                           if (is.null(version)) 
[18:06:06.443]                             version <- utils::packageVersion("future")
[18:06:06.443]                         }
[18:06:06.443]                         else {
[18:06:06.443]                           version <- NULL
[18:06:06.443]                         }
[18:06:06.443]                         if (!has_future || version < "1.8.0") {
[18:06:06.443]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.443]                             "", base::R.version$version.string), 
[18:06:06.443]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.443]                               "release", "version")], collapse = " "), 
[18:06:06.443]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.443]                             info)
[18:06:06.443]                           info <- base::paste(info, collapse = "; ")
[18:06:06.443]                           if (!has_future) {
[18:06:06.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.443]                               info)
[18:06:06.443]                           }
[18:06:06.443]                           else {
[18:06:06.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.443]                               info, version)
[18:06:06.443]                           }
[18:06:06.443]                           base::stop(msg)
[18:06:06.443]                         }
[18:06:06.443]                       })
[18:06:06.443]                     }
[18:06:06.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.443]                     base::options(mc.cores = 1L)
[18:06:06.443]                   }
[18:06:06.443]                   ...future.strategy.old <- future::plan("list")
[18:06:06.443]                   options(future.plan = NULL)
[18:06:06.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.443]                 }
[18:06:06.443]                 ...future.workdir <- getwd()
[18:06:06.443]             }
[18:06:06.443]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.443]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.443]         }
[18:06:06.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.443]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.443]             base::names(...future.oldOptions))
[18:06:06.443]     }
[18:06:06.443]     if (FALSE) {
[18:06:06.443]     }
[18:06:06.443]     else {
[18:06:06.443]         if (TRUE) {
[18:06:06.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.443]                 open = "w")
[18:06:06.443]         }
[18:06:06.443]         else {
[18:06:06.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.443]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.443]         }
[18:06:06.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.443]             base::sink(type = "output", split = FALSE)
[18:06:06.443]             base::close(...future.stdout)
[18:06:06.443]         }, add = TRUE)
[18:06:06.443]     }
[18:06:06.443]     ...future.frame <- base::sys.nframe()
[18:06:06.443]     ...future.conditions <- base::list()
[18:06:06.443]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.443]     if (FALSE) {
[18:06:06.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.443]     }
[18:06:06.443]     ...future.result <- base::tryCatch({
[18:06:06.443]         base::withCallingHandlers({
[18:06:06.443]             ...future.value <- base::withVisible(base::local({
[18:06:06.443]                 withCallingHandlers({
[18:06:06.443]                   1
[18:06:06.443]                 }, immediateCondition = function(cond) {
[18:06:06.443]                   save_rds <- function (object, pathname, ...) 
[18:06:06.443]                   {
[18:06:06.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.443]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.443]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.443]                         fi_tmp[["mtime"]])
[18:06:06.443]                     }
[18:06:06.443]                     tryCatch({
[18:06:06.443]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.443]                     }, error = function(ex) {
[18:06:06.443]                       msg <- conditionMessage(ex)
[18:06:06.443]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.443]                         fi_tmp[["mtime"]], msg)
[18:06:06.443]                       ex$message <- msg
[18:06:06.443]                       stop(ex)
[18:06:06.443]                     })
[18:06:06.443]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.443]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.443]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.443]                       fi <- file.info(pathname)
[18:06:06.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.443]                         fi[["size"]], fi[["mtime"]])
[18:06:06.443]                       stop(msg)
[18:06:06.443]                     }
[18:06:06.443]                     invisible(pathname)
[18:06:06.443]                   }
[18:06:06.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.443]                     rootPath = tempdir()) 
[18:06:06.443]                   {
[18:06:06.443]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.443]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.443]                       tmpdir = path, fileext = ".rds")
[18:06:06.443]                     save_rds(obj, file)
[18:06:06.443]                   }
[18:06:06.443]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.443]                   {
[18:06:06.443]                     inherits <- base::inherits
[18:06:06.443]                     invokeRestart <- base::invokeRestart
[18:06:06.443]                     is.null <- base::is.null
[18:06:06.443]                     muffled <- FALSE
[18:06:06.443]                     if (inherits(cond, "message")) {
[18:06:06.443]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.443]                       if (muffled) 
[18:06:06.443]                         invokeRestart("muffleMessage")
[18:06:06.443]                     }
[18:06:06.443]                     else if (inherits(cond, "warning")) {
[18:06:06.443]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.443]                       if (muffled) 
[18:06:06.443]                         invokeRestart("muffleWarning")
[18:06:06.443]                     }
[18:06:06.443]                     else if (inherits(cond, "condition")) {
[18:06:06.443]                       if (!is.null(pattern)) {
[18:06:06.443]                         computeRestarts <- base::computeRestarts
[18:06:06.443]                         grepl <- base::grepl
[18:06:06.443]                         restarts <- computeRestarts(cond)
[18:06:06.443]                         for (restart in restarts) {
[18:06:06.443]                           name <- restart$name
[18:06:06.443]                           if (is.null(name)) 
[18:06:06.443]                             next
[18:06:06.443]                           if (!grepl(pattern, name)) 
[18:06:06.443]                             next
[18:06:06.443]                           invokeRestart(restart)
[18:06:06.443]                           muffled <- TRUE
[18:06:06.443]                           break
[18:06:06.443]                         }
[18:06:06.443]                       }
[18:06:06.443]                     }
[18:06:06.443]                     invisible(muffled)
[18:06:06.443]                   }
[18:06:06.443]                   muffleCondition(cond)
[18:06:06.443]                 })
[18:06:06.443]             }))
[18:06:06.443]             future::FutureResult(value = ...future.value$value, 
[18:06:06.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.443]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.443]                     ...future.globalenv.names))
[18:06:06.443]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.443]         }, condition = base::local({
[18:06:06.443]             c <- base::c
[18:06:06.443]             inherits <- base::inherits
[18:06:06.443]             invokeRestart <- base::invokeRestart
[18:06:06.443]             length <- base::length
[18:06:06.443]             list <- base::list
[18:06:06.443]             seq.int <- base::seq.int
[18:06:06.443]             signalCondition <- base::signalCondition
[18:06:06.443]             sys.calls <- base::sys.calls
[18:06:06.443]             `[[` <- base::`[[`
[18:06:06.443]             `+` <- base::`+`
[18:06:06.443]             `<<-` <- base::`<<-`
[18:06:06.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.443]                   3L)]
[18:06:06.443]             }
[18:06:06.443]             function(cond) {
[18:06:06.443]                 is_error <- inherits(cond, "error")
[18:06:06.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.443]                   NULL)
[18:06:06.443]                 if (is_error) {
[18:06:06.443]                   sessionInformation <- function() {
[18:06:06.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.443]                       search = base::search(), system = base::Sys.info())
[18:06:06.443]                   }
[18:06:06.443]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.443]                     cond$call), session = sessionInformation(), 
[18:06:06.443]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.443]                   signalCondition(cond)
[18:06:06.443]                 }
[18:06:06.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.443]                 "immediateCondition"))) {
[18:06:06.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.443]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.443]                   if (TRUE && !signal) {
[18:06:06.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.443]                     {
[18:06:06.443]                       inherits <- base::inherits
[18:06:06.443]                       invokeRestart <- base::invokeRestart
[18:06:06.443]                       is.null <- base::is.null
[18:06:06.443]                       muffled <- FALSE
[18:06:06.443]                       if (inherits(cond, "message")) {
[18:06:06.443]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.443]                         if (muffled) 
[18:06:06.443]                           invokeRestart("muffleMessage")
[18:06:06.443]                       }
[18:06:06.443]                       else if (inherits(cond, "warning")) {
[18:06:06.443]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.443]                         if (muffled) 
[18:06:06.443]                           invokeRestart("muffleWarning")
[18:06:06.443]                       }
[18:06:06.443]                       else if (inherits(cond, "condition")) {
[18:06:06.443]                         if (!is.null(pattern)) {
[18:06:06.443]                           computeRestarts <- base::computeRestarts
[18:06:06.443]                           grepl <- base::grepl
[18:06:06.443]                           restarts <- computeRestarts(cond)
[18:06:06.443]                           for (restart in restarts) {
[18:06:06.443]                             name <- restart$name
[18:06:06.443]                             if (is.null(name)) 
[18:06:06.443]                               next
[18:06:06.443]                             if (!grepl(pattern, name)) 
[18:06:06.443]                               next
[18:06:06.443]                             invokeRestart(restart)
[18:06:06.443]                             muffled <- TRUE
[18:06:06.443]                             break
[18:06:06.443]                           }
[18:06:06.443]                         }
[18:06:06.443]                       }
[18:06:06.443]                       invisible(muffled)
[18:06:06.443]                     }
[18:06:06.443]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.443]                   }
[18:06:06.443]                 }
[18:06:06.443]                 else {
[18:06:06.443]                   if (TRUE) {
[18:06:06.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.443]                     {
[18:06:06.443]                       inherits <- base::inherits
[18:06:06.443]                       invokeRestart <- base::invokeRestart
[18:06:06.443]                       is.null <- base::is.null
[18:06:06.443]                       muffled <- FALSE
[18:06:06.443]                       if (inherits(cond, "message")) {
[18:06:06.443]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.443]                         if (muffled) 
[18:06:06.443]                           invokeRestart("muffleMessage")
[18:06:06.443]                       }
[18:06:06.443]                       else if (inherits(cond, "warning")) {
[18:06:06.443]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.443]                         if (muffled) 
[18:06:06.443]                           invokeRestart("muffleWarning")
[18:06:06.443]                       }
[18:06:06.443]                       else if (inherits(cond, "condition")) {
[18:06:06.443]                         if (!is.null(pattern)) {
[18:06:06.443]                           computeRestarts <- base::computeRestarts
[18:06:06.443]                           grepl <- base::grepl
[18:06:06.443]                           restarts <- computeRestarts(cond)
[18:06:06.443]                           for (restart in restarts) {
[18:06:06.443]                             name <- restart$name
[18:06:06.443]                             if (is.null(name)) 
[18:06:06.443]                               next
[18:06:06.443]                             if (!grepl(pattern, name)) 
[18:06:06.443]                               next
[18:06:06.443]                             invokeRestart(restart)
[18:06:06.443]                             muffled <- TRUE
[18:06:06.443]                             break
[18:06:06.443]                           }
[18:06:06.443]                         }
[18:06:06.443]                       }
[18:06:06.443]                       invisible(muffled)
[18:06:06.443]                     }
[18:06:06.443]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.443]                   }
[18:06:06.443]                 }
[18:06:06.443]             }
[18:06:06.443]         }))
[18:06:06.443]     }, error = function(ex) {
[18:06:06.443]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.443]                 ...future.rng), started = ...future.startTime, 
[18:06:06.443]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.443]             version = "1.8"), class = "FutureResult")
[18:06:06.443]     }, finally = {
[18:06:06.443]         if (!identical(...future.workdir, getwd())) 
[18:06:06.443]             setwd(...future.workdir)
[18:06:06.443]         {
[18:06:06.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.443]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.443]             }
[18:06:06.443]             base::options(...future.oldOptions)
[18:06:06.443]             if (.Platform$OS.type == "windows") {
[18:06:06.443]                 old_names <- names(...future.oldEnvVars)
[18:06:06.443]                 envs <- base::Sys.getenv()
[18:06:06.443]                 names <- names(envs)
[18:06:06.443]                 common <- intersect(names, old_names)
[18:06:06.443]                 added <- setdiff(names, old_names)
[18:06:06.443]                 removed <- setdiff(old_names, names)
[18:06:06.443]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.443]                   envs[common]]
[18:06:06.443]                 NAMES <- toupper(changed)
[18:06:06.443]                 args <- list()
[18:06:06.443]                 for (kk in seq_along(NAMES)) {
[18:06:06.443]                   name <- changed[[kk]]
[18:06:06.443]                   NAME <- NAMES[[kk]]
[18:06:06.443]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.443]                     next
[18:06:06.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.443]                 }
[18:06:06.443]                 NAMES <- toupper(added)
[18:06:06.443]                 for (kk in seq_along(NAMES)) {
[18:06:06.443]                   name <- added[[kk]]
[18:06:06.443]                   NAME <- NAMES[[kk]]
[18:06:06.443]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.443]                     next
[18:06:06.443]                   args[[name]] <- ""
[18:06:06.443]                 }
[18:06:06.443]                 NAMES <- toupper(removed)
[18:06:06.443]                 for (kk in seq_along(NAMES)) {
[18:06:06.443]                   name <- removed[[kk]]
[18:06:06.443]                   NAME <- NAMES[[kk]]
[18:06:06.443]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.443]                     next
[18:06:06.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.443]                 }
[18:06:06.443]                 if (length(args) > 0) 
[18:06:06.443]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.443]             }
[18:06:06.443]             else {
[18:06:06.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.443]             }
[18:06:06.443]             {
[18:06:06.443]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.443]                   0L) {
[18:06:06.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.443]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.443]                   base::options(opts)
[18:06:06.443]                 }
[18:06:06.443]                 {
[18:06:06.443]                   {
[18:06:06.443]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.443]                     NULL
[18:06:06.443]                   }
[18:06:06.443]                   options(future.plan = NULL)
[18:06:06.443]                   if (is.na(NA_character_)) 
[18:06:06.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.443]                     .init = FALSE)
[18:06:06.443]                 }
[18:06:06.443]             }
[18:06:06.443]         }
[18:06:06.443]     })
[18:06:06.443]     if (TRUE) {
[18:06:06.443]         base::sink(type = "output", split = FALSE)
[18:06:06.443]         if (TRUE) {
[18:06:06.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.443]         }
[18:06:06.443]         else {
[18:06:06.443]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.443]         }
[18:06:06.443]         base::close(...future.stdout)
[18:06:06.443]         ...future.stdout <- NULL
[18:06:06.443]     }
[18:06:06.443]     ...future.result$conditions <- ...future.conditions
[18:06:06.443]     ...future.result$finished <- base::Sys.time()
[18:06:06.443]     ...future.result
[18:06:06.443] }
[18:06:06.449] requestCore(): workers = 2
[18:06:06.450] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:06.496] result() for MulticoreFuture ...
[18:06:06.498] result() for MulticoreFuture ...
[18:06:06.498] result() for MulticoreFuture ... done
[18:06:06.498] result() for MulticoreFuture ... done
[18:06:06.499] result() for MulticoreFuture ...
[18:06:06.499] result() for MulticoreFuture ... done
[18:06:06.505] MulticoreFuture started
[18:06:06.506] - Launch lazy future ... done
[18:06:06.506] run() for ‘MulticoreFuture’ ... done
[18:06:06.509] plan(): Setting new future strategy stack:
[18:06:06.509] List of future strategies:
[18:06:06.509] 1. sequential:
[18:06:06.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.509]    - tweaked: FALSE
[18:06:06.509]    - call: NULL
[18:06:06.513] plan(): nbrOfWorkers() = 1
[18:06:06.518] plan(): Setting new future strategy stack:
[18:06:06.520] Future #2
[18:06:06.519] List of future strategies:
[18:06:06.519] 1. multicore:
[18:06:06.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.519]    - tweaked: FALSE
[18:06:06.519]    - call: plan(strategy)
[18:06:06.520]  length: 2 (resolved future 2)
[18:06:06.523]  length: 1 (resolved future 3)
[18:06:06.528] plan(): nbrOfWorkers() = 2
[18:06:06.534] Future #1
[18:06:06.535]  length: 0 (resolved future 1)
[18:06:06.535] resolve() on list ... DONE
[18:06:06.537] getGlobalsAndPackages() ...
[18:06:06.537] Searching for globals...
[18:06:06.539] 
[18:06:06.539] Searching for globals ... DONE
[18:06:06.540] - globals: [0] <none>
[18:06:06.540] getGlobalsAndPackages() ... DONE
[18:06:06.541] getGlobalsAndPackages() ...
[18:06:06.541] Searching for globals...
[18:06:06.542] 
[18:06:06.543] Searching for globals ... DONE
[18:06:06.543] - globals: [0] <none>
[18:06:06.543] getGlobalsAndPackages() ... DONE
[18:06:06.544] resolve() on list ...
[18:06:06.545]  recursive: 0
[18:06:06.545]  length: 3
[18:06:06.545]  elements: ‘a’, ‘b’, ‘’
[18:06:06.546] run() for ‘Future’ ...
[18:06:06.546] - state: ‘created’
[18:06:06.547] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.555] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.556]   - Field: ‘label’
[18:06:06.557]   - Field: ‘local’
[18:06:06.557]   - Field: ‘owner’
[18:06:06.557]   - Field: ‘envir’
[18:06:06.558]   - Field: ‘workers’
[18:06:06.558]   - Field: ‘packages’
[18:06:06.558]   - Field: ‘gc’
[18:06:06.559]   - Field: ‘job’
[18:06:06.559]   - Field: ‘conditions’
[18:06:06.560]   - Field: ‘expr’
[18:06:06.560]   - Field: ‘uuid’
[18:06:06.560]   - Field: ‘seed’
[18:06:06.561]   - Field: ‘version’
[18:06:06.561]   - Field: ‘result’
[18:06:06.561]   - Field: ‘asynchronous’
[18:06:06.562]   - Field: ‘calls’
[18:06:06.562]   - Field: ‘globals’
[18:06:06.562]   - Field: ‘stdout’
[18:06:06.563]   - Field: ‘earlySignal’
[18:06:06.563]   - Field: ‘lazy’
[18:06:06.563]   - Field: ‘state’
[18:06:06.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.564] - Launch lazy future ...
[18:06:06.565] Packages needed by the future expression (n = 0): <none>
[18:06:06.565] Packages needed by future strategies (n = 0): <none>
[18:06:06.567] {
[18:06:06.567]     {
[18:06:06.567]         {
[18:06:06.567]             ...future.startTime <- base::Sys.time()
[18:06:06.567]             {
[18:06:06.567]                 {
[18:06:06.567]                   {
[18:06:06.567]                     {
[18:06:06.567]                       base::local({
[18:06:06.567]                         has_future <- base::requireNamespace("future", 
[18:06:06.567]                           quietly = TRUE)
[18:06:06.567]                         if (has_future) {
[18:06:06.567]                           ns <- base::getNamespace("future")
[18:06:06.567]                           version <- ns[[".package"]][["version"]]
[18:06:06.567]                           if (is.null(version)) 
[18:06:06.567]                             version <- utils::packageVersion("future")
[18:06:06.567]                         }
[18:06:06.567]                         else {
[18:06:06.567]                           version <- NULL
[18:06:06.567]                         }
[18:06:06.567]                         if (!has_future || version < "1.8.0") {
[18:06:06.567]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.567]                             "", base::R.version$version.string), 
[18:06:06.567]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.567]                               "release", "version")], collapse = " "), 
[18:06:06.567]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.567]                             info)
[18:06:06.567]                           info <- base::paste(info, collapse = "; ")
[18:06:06.567]                           if (!has_future) {
[18:06:06.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.567]                               info)
[18:06:06.567]                           }
[18:06:06.567]                           else {
[18:06:06.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.567]                               info, version)
[18:06:06.567]                           }
[18:06:06.567]                           base::stop(msg)
[18:06:06.567]                         }
[18:06:06.567]                       })
[18:06:06.567]                     }
[18:06:06.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.567]                     base::options(mc.cores = 1L)
[18:06:06.567]                   }
[18:06:06.567]                   ...future.strategy.old <- future::plan("list")
[18:06:06.567]                   options(future.plan = NULL)
[18:06:06.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.567]                 }
[18:06:06.567]                 ...future.workdir <- getwd()
[18:06:06.567]             }
[18:06:06.567]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.567]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.567]         }
[18:06:06.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.567]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.567]             base::names(...future.oldOptions))
[18:06:06.567]     }
[18:06:06.567]     if (FALSE) {
[18:06:06.567]     }
[18:06:06.567]     else {
[18:06:06.567]         if (TRUE) {
[18:06:06.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.567]                 open = "w")
[18:06:06.567]         }
[18:06:06.567]         else {
[18:06:06.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.567]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.567]         }
[18:06:06.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.567]             base::sink(type = "output", split = FALSE)
[18:06:06.567]             base::close(...future.stdout)
[18:06:06.567]         }, add = TRUE)
[18:06:06.567]     }
[18:06:06.567]     ...future.frame <- base::sys.nframe()
[18:06:06.567]     ...future.conditions <- base::list()
[18:06:06.567]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.567]     if (FALSE) {
[18:06:06.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.567]     }
[18:06:06.567]     ...future.result <- base::tryCatch({
[18:06:06.567]         base::withCallingHandlers({
[18:06:06.567]             ...future.value <- base::withVisible(base::local({
[18:06:06.567]                 withCallingHandlers({
[18:06:06.567]                   1
[18:06:06.567]                 }, immediateCondition = function(cond) {
[18:06:06.567]                   save_rds <- function (object, pathname, ...) 
[18:06:06.567]                   {
[18:06:06.567]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.567]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.567]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.567]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.567]                         fi_tmp[["mtime"]])
[18:06:06.567]                     }
[18:06:06.567]                     tryCatch({
[18:06:06.567]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.567]                     }, error = function(ex) {
[18:06:06.567]                       msg <- conditionMessage(ex)
[18:06:06.567]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.567]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.567]                         fi_tmp[["mtime"]], msg)
[18:06:06.567]                       ex$message <- msg
[18:06:06.567]                       stop(ex)
[18:06:06.567]                     })
[18:06:06.567]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.567]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.567]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.567]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.567]                       fi <- file.info(pathname)
[18:06:06.567]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.567]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.567]                         fi[["size"]], fi[["mtime"]])
[18:06:06.567]                       stop(msg)
[18:06:06.567]                     }
[18:06:06.567]                     invisible(pathname)
[18:06:06.567]                   }
[18:06:06.567]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.567]                     rootPath = tempdir()) 
[18:06:06.567]                   {
[18:06:06.567]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.567]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.567]                       tmpdir = path, fileext = ".rds")
[18:06:06.567]                     save_rds(obj, file)
[18:06:06.567]                   }
[18:06:06.567]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.567]                   {
[18:06:06.567]                     inherits <- base::inherits
[18:06:06.567]                     invokeRestart <- base::invokeRestart
[18:06:06.567]                     is.null <- base::is.null
[18:06:06.567]                     muffled <- FALSE
[18:06:06.567]                     if (inherits(cond, "message")) {
[18:06:06.567]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.567]                       if (muffled) 
[18:06:06.567]                         invokeRestart("muffleMessage")
[18:06:06.567]                     }
[18:06:06.567]                     else if (inherits(cond, "warning")) {
[18:06:06.567]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.567]                       if (muffled) 
[18:06:06.567]                         invokeRestart("muffleWarning")
[18:06:06.567]                     }
[18:06:06.567]                     else if (inherits(cond, "condition")) {
[18:06:06.567]                       if (!is.null(pattern)) {
[18:06:06.567]                         computeRestarts <- base::computeRestarts
[18:06:06.567]                         grepl <- base::grepl
[18:06:06.567]                         restarts <- computeRestarts(cond)
[18:06:06.567]                         for (restart in restarts) {
[18:06:06.567]                           name <- restart$name
[18:06:06.567]                           if (is.null(name)) 
[18:06:06.567]                             next
[18:06:06.567]                           if (!grepl(pattern, name)) 
[18:06:06.567]                             next
[18:06:06.567]                           invokeRestart(restart)
[18:06:06.567]                           muffled <- TRUE
[18:06:06.567]                           break
[18:06:06.567]                         }
[18:06:06.567]                       }
[18:06:06.567]                     }
[18:06:06.567]                     invisible(muffled)
[18:06:06.567]                   }
[18:06:06.567]                   muffleCondition(cond)
[18:06:06.567]                 })
[18:06:06.567]             }))
[18:06:06.567]             future::FutureResult(value = ...future.value$value, 
[18:06:06.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.567]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.567]                     ...future.globalenv.names))
[18:06:06.567]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.567]         }, condition = base::local({
[18:06:06.567]             c <- base::c
[18:06:06.567]             inherits <- base::inherits
[18:06:06.567]             invokeRestart <- base::invokeRestart
[18:06:06.567]             length <- base::length
[18:06:06.567]             list <- base::list
[18:06:06.567]             seq.int <- base::seq.int
[18:06:06.567]             signalCondition <- base::signalCondition
[18:06:06.567]             sys.calls <- base::sys.calls
[18:06:06.567]             `[[` <- base::`[[`
[18:06:06.567]             `+` <- base::`+`
[18:06:06.567]             `<<-` <- base::`<<-`
[18:06:06.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.567]                   3L)]
[18:06:06.567]             }
[18:06:06.567]             function(cond) {
[18:06:06.567]                 is_error <- inherits(cond, "error")
[18:06:06.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.567]                   NULL)
[18:06:06.567]                 if (is_error) {
[18:06:06.567]                   sessionInformation <- function() {
[18:06:06.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.567]                       search = base::search(), system = base::Sys.info())
[18:06:06.567]                   }
[18:06:06.567]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.567]                     cond$call), session = sessionInformation(), 
[18:06:06.567]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.567]                   signalCondition(cond)
[18:06:06.567]                 }
[18:06:06.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.567]                 "immediateCondition"))) {
[18:06:06.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.567]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.567]                   if (TRUE && !signal) {
[18:06:06.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.567]                     {
[18:06:06.567]                       inherits <- base::inherits
[18:06:06.567]                       invokeRestart <- base::invokeRestart
[18:06:06.567]                       is.null <- base::is.null
[18:06:06.567]                       muffled <- FALSE
[18:06:06.567]                       if (inherits(cond, "message")) {
[18:06:06.567]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.567]                         if (muffled) 
[18:06:06.567]                           invokeRestart("muffleMessage")
[18:06:06.567]                       }
[18:06:06.567]                       else if (inherits(cond, "warning")) {
[18:06:06.567]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.567]                         if (muffled) 
[18:06:06.567]                           invokeRestart("muffleWarning")
[18:06:06.567]                       }
[18:06:06.567]                       else if (inherits(cond, "condition")) {
[18:06:06.567]                         if (!is.null(pattern)) {
[18:06:06.567]                           computeRestarts <- base::computeRestarts
[18:06:06.567]                           grepl <- base::grepl
[18:06:06.567]                           restarts <- computeRestarts(cond)
[18:06:06.567]                           for (restart in restarts) {
[18:06:06.567]                             name <- restart$name
[18:06:06.567]                             if (is.null(name)) 
[18:06:06.567]                               next
[18:06:06.567]                             if (!grepl(pattern, name)) 
[18:06:06.567]                               next
[18:06:06.567]                             invokeRestart(restart)
[18:06:06.567]                             muffled <- TRUE
[18:06:06.567]                             break
[18:06:06.567]                           }
[18:06:06.567]                         }
[18:06:06.567]                       }
[18:06:06.567]                       invisible(muffled)
[18:06:06.567]                     }
[18:06:06.567]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.567]                   }
[18:06:06.567]                 }
[18:06:06.567]                 else {
[18:06:06.567]                   if (TRUE) {
[18:06:06.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.567]                     {
[18:06:06.567]                       inherits <- base::inherits
[18:06:06.567]                       invokeRestart <- base::invokeRestart
[18:06:06.567]                       is.null <- base::is.null
[18:06:06.567]                       muffled <- FALSE
[18:06:06.567]                       if (inherits(cond, "message")) {
[18:06:06.567]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.567]                         if (muffled) 
[18:06:06.567]                           invokeRestart("muffleMessage")
[18:06:06.567]                       }
[18:06:06.567]                       else if (inherits(cond, "warning")) {
[18:06:06.567]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.567]                         if (muffled) 
[18:06:06.567]                           invokeRestart("muffleWarning")
[18:06:06.567]                       }
[18:06:06.567]                       else if (inherits(cond, "condition")) {
[18:06:06.567]                         if (!is.null(pattern)) {
[18:06:06.567]                           computeRestarts <- base::computeRestarts
[18:06:06.567]                           grepl <- base::grepl
[18:06:06.567]                           restarts <- computeRestarts(cond)
[18:06:06.567]                           for (restart in restarts) {
[18:06:06.567]                             name <- restart$name
[18:06:06.567]                             if (is.null(name)) 
[18:06:06.567]                               next
[18:06:06.567]                             if (!grepl(pattern, name)) 
[18:06:06.567]                               next
[18:06:06.567]                             invokeRestart(restart)
[18:06:06.567]                             muffled <- TRUE
[18:06:06.567]                             break
[18:06:06.567]                           }
[18:06:06.567]                         }
[18:06:06.567]                       }
[18:06:06.567]                       invisible(muffled)
[18:06:06.567]                     }
[18:06:06.567]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.567]                   }
[18:06:06.567]                 }
[18:06:06.567]             }
[18:06:06.567]         }))
[18:06:06.567]     }, error = function(ex) {
[18:06:06.567]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.567]                 ...future.rng), started = ...future.startTime, 
[18:06:06.567]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.567]             version = "1.8"), class = "FutureResult")
[18:06:06.567]     }, finally = {
[18:06:06.567]         if (!identical(...future.workdir, getwd())) 
[18:06:06.567]             setwd(...future.workdir)
[18:06:06.567]         {
[18:06:06.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.567]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.567]             }
[18:06:06.567]             base::options(...future.oldOptions)
[18:06:06.567]             if (.Platform$OS.type == "windows") {
[18:06:06.567]                 old_names <- names(...future.oldEnvVars)
[18:06:06.567]                 envs <- base::Sys.getenv()
[18:06:06.567]                 names <- names(envs)
[18:06:06.567]                 common <- intersect(names, old_names)
[18:06:06.567]                 added <- setdiff(names, old_names)
[18:06:06.567]                 removed <- setdiff(old_names, names)
[18:06:06.567]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.567]                   envs[common]]
[18:06:06.567]                 NAMES <- toupper(changed)
[18:06:06.567]                 args <- list()
[18:06:06.567]                 for (kk in seq_along(NAMES)) {
[18:06:06.567]                   name <- changed[[kk]]
[18:06:06.567]                   NAME <- NAMES[[kk]]
[18:06:06.567]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.567]                     next
[18:06:06.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.567]                 }
[18:06:06.567]                 NAMES <- toupper(added)
[18:06:06.567]                 for (kk in seq_along(NAMES)) {
[18:06:06.567]                   name <- added[[kk]]
[18:06:06.567]                   NAME <- NAMES[[kk]]
[18:06:06.567]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.567]                     next
[18:06:06.567]                   args[[name]] <- ""
[18:06:06.567]                 }
[18:06:06.567]                 NAMES <- toupper(removed)
[18:06:06.567]                 for (kk in seq_along(NAMES)) {
[18:06:06.567]                   name <- removed[[kk]]
[18:06:06.567]                   NAME <- NAMES[[kk]]
[18:06:06.567]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.567]                     next
[18:06:06.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.567]                 }
[18:06:06.567]                 if (length(args) > 0) 
[18:06:06.567]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.567]             }
[18:06:06.567]             else {
[18:06:06.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.567]             }
[18:06:06.567]             {
[18:06:06.567]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.567]                   0L) {
[18:06:06.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.567]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.567]                   base::options(opts)
[18:06:06.567]                 }
[18:06:06.567]                 {
[18:06:06.567]                   {
[18:06:06.567]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.567]                     NULL
[18:06:06.567]                   }
[18:06:06.567]                   options(future.plan = NULL)
[18:06:06.567]                   if (is.na(NA_character_)) 
[18:06:06.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.567]                     .init = FALSE)
[18:06:06.567]                 }
[18:06:06.567]             }
[18:06:06.567]         }
[18:06:06.567]     })
[18:06:06.567]     if (TRUE) {
[18:06:06.567]         base::sink(type = "output", split = FALSE)
[18:06:06.567]         if (TRUE) {
[18:06:06.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.567]         }
[18:06:06.567]         else {
[18:06:06.567]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.567]         }
[18:06:06.567]         base::close(...future.stdout)
[18:06:06.567]         ...future.stdout <- NULL
[18:06:06.567]     }
[18:06:06.567]     ...future.result$conditions <- ...future.conditions
[18:06:06.567]     ...future.result$finished <- base::Sys.time()
[18:06:06.567]     ...future.result
[18:06:06.567] }
[18:06:06.574] requestCore(): workers = 2
[18:06:06.575] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:06.586] result() for MulticoreFuture ...
[18:06:06.590] result() for MulticoreFuture ...
[18:06:06.591] result() for MulticoreFuture ... done
[18:06:06.591] result() for MulticoreFuture ... done
[18:06:06.592] result() for MulticoreFuture ...
[18:06:06.592] result() for MulticoreFuture ... done
[18:06:06.599] MulticoreFuture started
[18:06:06.599] - Launch lazy future ... done
[18:06:06.601] run() for ‘MulticoreFuture’ ... done
[18:06:06.603] plan(): Setting new future strategy stack:
[18:06:06.603] List of future strategies:
[18:06:06.603] 1. sequential:
[18:06:06.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.603]    - tweaked: FALSE
[18:06:06.603]    - call: NULL
[18:06:06.606] plan(): nbrOfWorkers() = 1
[18:06:06.610] plan(): Setting new future strategy stack:
[18:06:06.611] List of future strategies:
[18:06:06.611] 1. multicore:
[18:06:06.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.611]    - tweaked: FALSE
[18:06:06.611]    - call: plan(strategy)
[18:06:06.615] run() for ‘Future’ ...
[18:06:06.615] - state: ‘created’
[18:06:06.616] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.627] plan(): nbrOfWorkers() = 2
[18:06:06.630] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.631]   - Field: ‘label’
[18:06:06.632]   - Field: ‘local’
[18:06:06.632]   - Field: ‘owner’
[18:06:06.632]   - Field: ‘envir’
[18:06:06.633]   - Field: ‘workers’
[18:06:06.633]   - Field: ‘packages’
[18:06:06.633]   - Field: ‘gc’
[18:06:06.634]   - Field: ‘job’
[18:06:06.634]   - Field: ‘conditions’
[18:06:06.634]   - Field: ‘expr’
[18:06:06.635]   - Field: ‘uuid’
[18:06:06.635]   - Field: ‘seed’
[18:06:06.635]   - Field: ‘version’
[18:06:06.636]   - Field: ‘result’
[18:06:06.636]   - Field: ‘asynchronous’
[18:06:06.636]   - Field: ‘calls’
[18:06:06.637]   - Field: ‘globals’
[18:06:06.637]   - Field: ‘stdout’
[18:06:06.637]   - Field: ‘earlySignal’
[18:06:06.638]   - Field: ‘lazy’
[18:06:06.638]   - Field: ‘state’
[18:06:06.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.639] - Launch lazy future ...
[18:06:06.640] Packages needed by the future expression (n = 0): <none>
[18:06:06.640] Packages needed by future strategies (n = 0): <none>
[18:06:06.642] {
[18:06:06.642]     {
[18:06:06.642]         {
[18:06:06.642]             ...future.startTime <- base::Sys.time()
[18:06:06.642]             {
[18:06:06.642]                 {
[18:06:06.642]                   {
[18:06:06.642]                     {
[18:06:06.642]                       base::local({
[18:06:06.642]                         has_future <- base::requireNamespace("future", 
[18:06:06.642]                           quietly = TRUE)
[18:06:06.642]                         if (has_future) {
[18:06:06.642]                           ns <- base::getNamespace("future")
[18:06:06.642]                           version <- ns[[".package"]][["version"]]
[18:06:06.642]                           if (is.null(version)) 
[18:06:06.642]                             version <- utils::packageVersion("future")
[18:06:06.642]                         }
[18:06:06.642]                         else {
[18:06:06.642]                           version <- NULL
[18:06:06.642]                         }
[18:06:06.642]                         if (!has_future || version < "1.8.0") {
[18:06:06.642]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.642]                             "", base::R.version$version.string), 
[18:06:06.642]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.642]                               "release", "version")], collapse = " "), 
[18:06:06.642]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.642]                             info)
[18:06:06.642]                           info <- base::paste(info, collapse = "; ")
[18:06:06.642]                           if (!has_future) {
[18:06:06.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.642]                               info)
[18:06:06.642]                           }
[18:06:06.642]                           else {
[18:06:06.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.642]                               info, version)
[18:06:06.642]                           }
[18:06:06.642]                           base::stop(msg)
[18:06:06.642]                         }
[18:06:06.642]                       })
[18:06:06.642]                     }
[18:06:06.642]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.642]                     base::options(mc.cores = 1L)
[18:06:06.642]                   }
[18:06:06.642]                   ...future.strategy.old <- future::plan("list")
[18:06:06.642]                   options(future.plan = NULL)
[18:06:06.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.642]                 }
[18:06:06.642]                 ...future.workdir <- getwd()
[18:06:06.642]             }
[18:06:06.642]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.642]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.642]         }
[18:06:06.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.642]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.642]             base::names(...future.oldOptions))
[18:06:06.642]     }
[18:06:06.642]     if (FALSE) {
[18:06:06.642]     }
[18:06:06.642]     else {
[18:06:06.642]         if (TRUE) {
[18:06:06.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.642]                 open = "w")
[18:06:06.642]         }
[18:06:06.642]         else {
[18:06:06.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.642]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.642]         }
[18:06:06.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.642]             base::sink(type = "output", split = FALSE)
[18:06:06.642]             base::close(...future.stdout)
[18:06:06.642]         }, add = TRUE)
[18:06:06.642]     }
[18:06:06.642]     ...future.frame <- base::sys.nframe()
[18:06:06.642]     ...future.conditions <- base::list()
[18:06:06.642]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.642]     if (FALSE) {
[18:06:06.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.642]     }
[18:06:06.642]     ...future.result <- base::tryCatch({
[18:06:06.642]         base::withCallingHandlers({
[18:06:06.642]             ...future.value <- base::withVisible(base::local({
[18:06:06.642]                 withCallingHandlers({
[18:06:06.642]                   2
[18:06:06.642]                 }, immediateCondition = function(cond) {
[18:06:06.642]                   save_rds <- function (object, pathname, ...) 
[18:06:06.642]                   {
[18:06:06.642]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.642]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.642]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.642]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.642]                         fi_tmp[["mtime"]])
[18:06:06.642]                     }
[18:06:06.642]                     tryCatch({
[18:06:06.642]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.642]                     }, error = function(ex) {
[18:06:06.642]                       msg <- conditionMessage(ex)
[18:06:06.642]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.642]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.642]                         fi_tmp[["mtime"]], msg)
[18:06:06.642]                       ex$message <- msg
[18:06:06.642]                       stop(ex)
[18:06:06.642]                     })
[18:06:06.642]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.642]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.642]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.642]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.642]                       fi <- file.info(pathname)
[18:06:06.642]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.642]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.642]                         fi[["size"]], fi[["mtime"]])
[18:06:06.642]                       stop(msg)
[18:06:06.642]                     }
[18:06:06.642]                     invisible(pathname)
[18:06:06.642]                   }
[18:06:06.642]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.642]                     rootPath = tempdir()) 
[18:06:06.642]                   {
[18:06:06.642]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.642]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.642]                       tmpdir = path, fileext = ".rds")
[18:06:06.642]                     save_rds(obj, file)
[18:06:06.642]                   }
[18:06:06.642]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.642]                   {
[18:06:06.642]                     inherits <- base::inherits
[18:06:06.642]                     invokeRestart <- base::invokeRestart
[18:06:06.642]                     is.null <- base::is.null
[18:06:06.642]                     muffled <- FALSE
[18:06:06.642]                     if (inherits(cond, "message")) {
[18:06:06.642]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.642]                       if (muffled) 
[18:06:06.642]                         invokeRestart("muffleMessage")
[18:06:06.642]                     }
[18:06:06.642]                     else if (inherits(cond, "warning")) {
[18:06:06.642]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.642]                       if (muffled) 
[18:06:06.642]                         invokeRestart("muffleWarning")
[18:06:06.642]                     }
[18:06:06.642]                     else if (inherits(cond, "condition")) {
[18:06:06.642]                       if (!is.null(pattern)) {
[18:06:06.642]                         computeRestarts <- base::computeRestarts
[18:06:06.642]                         grepl <- base::grepl
[18:06:06.642]                         restarts <- computeRestarts(cond)
[18:06:06.642]                         for (restart in restarts) {
[18:06:06.642]                           name <- restart$name
[18:06:06.642]                           if (is.null(name)) 
[18:06:06.642]                             next
[18:06:06.642]                           if (!grepl(pattern, name)) 
[18:06:06.642]                             next
[18:06:06.642]                           invokeRestart(restart)
[18:06:06.642]                           muffled <- TRUE
[18:06:06.642]                           break
[18:06:06.642]                         }
[18:06:06.642]                       }
[18:06:06.642]                     }
[18:06:06.642]                     invisible(muffled)
[18:06:06.642]                   }
[18:06:06.642]                   muffleCondition(cond)
[18:06:06.642]                 })
[18:06:06.642]             }))
[18:06:06.642]             future::FutureResult(value = ...future.value$value, 
[18:06:06.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.642]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.642]                     ...future.globalenv.names))
[18:06:06.642]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.642]         }, condition = base::local({
[18:06:06.642]             c <- base::c
[18:06:06.642]             inherits <- base::inherits
[18:06:06.642]             invokeRestart <- base::invokeRestart
[18:06:06.642]             length <- base::length
[18:06:06.642]             list <- base::list
[18:06:06.642]             seq.int <- base::seq.int
[18:06:06.642]             signalCondition <- base::signalCondition
[18:06:06.642]             sys.calls <- base::sys.calls
[18:06:06.642]             `[[` <- base::`[[`
[18:06:06.642]             `+` <- base::`+`
[18:06:06.642]             `<<-` <- base::`<<-`
[18:06:06.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.642]                   3L)]
[18:06:06.642]             }
[18:06:06.642]             function(cond) {
[18:06:06.642]                 is_error <- inherits(cond, "error")
[18:06:06.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.642]                   NULL)
[18:06:06.642]                 if (is_error) {
[18:06:06.642]                   sessionInformation <- function() {
[18:06:06.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.642]                       search = base::search(), system = base::Sys.info())
[18:06:06.642]                   }
[18:06:06.642]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.642]                     cond$call), session = sessionInformation(), 
[18:06:06.642]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.642]                   signalCondition(cond)
[18:06:06.642]                 }
[18:06:06.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.642]                 "immediateCondition"))) {
[18:06:06.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.642]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.642]                   if (TRUE && !signal) {
[18:06:06.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.642]                     {
[18:06:06.642]                       inherits <- base::inherits
[18:06:06.642]                       invokeRestart <- base::invokeRestart
[18:06:06.642]                       is.null <- base::is.null
[18:06:06.642]                       muffled <- FALSE
[18:06:06.642]                       if (inherits(cond, "message")) {
[18:06:06.642]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.642]                         if (muffled) 
[18:06:06.642]                           invokeRestart("muffleMessage")
[18:06:06.642]                       }
[18:06:06.642]                       else if (inherits(cond, "warning")) {
[18:06:06.642]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.642]                         if (muffled) 
[18:06:06.642]                           invokeRestart("muffleWarning")
[18:06:06.642]                       }
[18:06:06.642]                       else if (inherits(cond, "condition")) {
[18:06:06.642]                         if (!is.null(pattern)) {
[18:06:06.642]                           computeRestarts <- base::computeRestarts
[18:06:06.642]                           grepl <- base::grepl
[18:06:06.642]                           restarts <- computeRestarts(cond)
[18:06:06.642]                           for (restart in restarts) {
[18:06:06.642]                             name <- restart$name
[18:06:06.642]                             if (is.null(name)) 
[18:06:06.642]                               next
[18:06:06.642]                             if (!grepl(pattern, name)) 
[18:06:06.642]                               next
[18:06:06.642]                             invokeRestart(restart)
[18:06:06.642]                             muffled <- TRUE
[18:06:06.642]                             break
[18:06:06.642]                           }
[18:06:06.642]                         }
[18:06:06.642]                       }
[18:06:06.642]                       invisible(muffled)
[18:06:06.642]                     }
[18:06:06.642]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.642]                   }
[18:06:06.642]                 }
[18:06:06.642]                 else {
[18:06:06.642]                   if (TRUE) {
[18:06:06.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.642]                     {
[18:06:06.642]                       inherits <- base::inherits
[18:06:06.642]                       invokeRestart <- base::invokeRestart
[18:06:06.642]                       is.null <- base::is.null
[18:06:06.642]                       muffled <- FALSE
[18:06:06.642]                       if (inherits(cond, "message")) {
[18:06:06.642]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.642]                         if (muffled) 
[18:06:06.642]                           invokeRestart("muffleMessage")
[18:06:06.642]                       }
[18:06:06.642]                       else if (inherits(cond, "warning")) {
[18:06:06.642]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.642]                         if (muffled) 
[18:06:06.642]                           invokeRestart("muffleWarning")
[18:06:06.642]                       }
[18:06:06.642]                       else if (inherits(cond, "condition")) {
[18:06:06.642]                         if (!is.null(pattern)) {
[18:06:06.642]                           computeRestarts <- base::computeRestarts
[18:06:06.642]                           grepl <- base::grepl
[18:06:06.642]                           restarts <- computeRestarts(cond)
[18:06:06.642]                           for (restart in restarts) {
[18:06:06.642]                             name <- restart$name
[18:06:06.642]                             if (is.null(name)) 
[18:06:06.642]                               next
[18:06:06.642]                             if (!grepl(pattern, name)) 
[18:06:06.642]                               next
[18:06:06.642]                             invokeRestart(restart)
[18:06:06.642]                             muffled <- TRUE
[18:06:06.642]                             break
[18:06:06.642]                           }
[18:06:06.642]                         }
[18:06:06.642]                       }
[18:06:06.642]                       invisible(muffled)
[18:06:06.642]                     }
[18:06:06.642]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.642]                   }
[18:06:06.642]                 }
[18:06:06.642]             }
[18:06:06.642]         }))
[18:06:06.642]     }, error = function(ex) {
[18:06:06.642]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.642]                 ...future.rng), started = ...future.startTime, 
[18:06:06.642]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.642]             version = "1.8"), class = "FutureResult")
[18:06:06.642]     }, finally = {
[18:06:06.642]         if (!identical(...future.workdir, getwd())) 
[18:06:06.642]             setwd(...future.workdir)
[18:06:06.642]         {
[18:06:06.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.642]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.642]             }
[18:06:06.642]             base::options(...future.oldOptions)
[18:06:06.642]             if (.Platform$OS.type == "windows") {
[18:06:06.642]                 old_names <- names(...future.oldEnvVars)
[18:06:06.642]                 envs <- base::Sys.getenv()
[18:06:06.642]                 names <- names(envs)
[18:06:06.642]                 common <- intersect(names, old_names)
[18:06:06.642]                 added <- setdiff(names, old_names)
[18:06:06.642]                 removed <- setdiff(old_names, names)
[18:06:06.642]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.642]                   envs[common]]
[18:06:06.642]                 NAMES <- toupper(changed)
[18:06:06.642]                 args <- list()
[18:06:06.642]                 for (kk in seq_along(NAMES)) {
[18:06:06.642]                   name <- changed[[kk]]
[18:06:06.642]                   NAME <- NAMES[[kk]]
[18:06:06.642]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.642]                     next
[18:06:06.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.642]                 }
[18:06:06.642]                 NAMES <- toupper(added)
[18:06:06.642]                 for (kk in seq_along(NAMES)) {
[18:06:06.642]                   name <- added[[kk]]
[18:06:06.642]                   NAME <- NAMES[[kk]]
[18:06:06.642]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.642]                     next
[18:06:06.642]                   args[[name]] <- ""
[18:06:06.642]                 }
[18:06:06.642]                 NAMES <- toupper(removed)
[18:06:06.642]                 for (kk in seq_along(NAMES)) {
[18:06:06.642]                   name <- removed[[kk]]
[18:06:06.642]                   NAME <- NAMES[[kk]]
[18:06:06.642]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.642]                     next
[18:06:06.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.642]                 }
[18:06:06.642]                 if (length(args) > 0) 
[18:06:06.642]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.642]             }
[18:06:06.642]             else {
[18:06:06.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.642]             }
[18:06:06.642]             {
[18:06:06.642]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.642]                   0L) {
[18:06:06.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.642]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.642]                   base::options(opts)
[18:06:06.642]                 }
[18:06:06.642]                 {
[18:06:06.642]                   {
[18:06:06.642]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.642]                     NULL
[18:06:06.642]                   }
[18:06:06.642]                   options(future.plan = NULL)
[18:06:06.642]                   if (is.na(NA_character_)) 
[18:06:06.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.642]                     .init = FALSE)
[18:06:06.642]                 }
[18:06:06.642]             }
[18:06:06.642]         }
[18:06:06.642]     })
[18:06:06.642]     if (TRUE) {
[18:06:06.642]         base::sink(type = "output", split = FALSE)
[18:06:06.642]         if (TRUE) {
[18:06:06.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.642]         }
[18:06:06.642]         else {
[18:06:06.642]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.642]         }
[18:06:06.642]         base::close(...future.stdout)
[18:06:06.642]         ...future.stdout <- NULL
[18:06:06.642]     }
[18:06:06.642]     ...future.result$conditions <- ...future.conditions
[18:06:06.642]     ...future.result$finished <- base::Sys.time()
[18:06:06.642]     ...future.result
[18:06:06.642] }
[18:06:06.649] requestCore(): workers = 2
[18:06:06.650] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:06.662] result() for MulticoreFuture ...
[18:06:06.664] result() for MulticoreFuture ...
[18:06:06.664] result() for MulticoreFuture ... done
[18:06:06.664] result() for MulticoreFuture ... done
[18:06:06.665] result() for MulticoreFuture ...
[18:06:06.665] result() for MulticoreFuture ... done
[18:06:06.669] MulticoreFuture started
[18:06:06.672] - Launch lazy future ... done
[18:06:06.673] run() for ‘MulticoreFuture’ ... done
[18:06:06.674] plan(): Setting new future strategy stack:
[18:06:06.675] List of future strategies:
[18:06:06.675] 1. sequential:
[18:06:06.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.675]    - tweaked: FALSE
[18:06:06.675]    - call: NULL
[18:06:06.677] plan(): nbrOfWorkers() = 1
[18:06:06.682] plan(): Setting new future strategy stack:
[18:06:06.682] List of future strategies:
[18:06:06.682] 1. multicore:
[18:06:06.682]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.682]    - tweaked: FALSE
[18:06:06.682]    - call: plan(strategy)
[18:06:06.686]  length: 2 (resolved future 3)
[18:06:06.693] plan(): nbrOfWorkers() = 2
[18:06:06.697] Future #1
[18:06:06.698]  length: 1 (resolved future 1)
[18:06:06.699] Future #2
[18:06:06.699]  length: 0 (resolved future 2)
[18:06:06.700] resolve() on list ... DONE
[18:06:06.701] getGlobalsAndPackages() ...
[18:06:06.701] Searching for globals...
[18:06:06.703] 
[18:06:06.703] Searching for globals ... DONE
[18:06:06.704] - globals: [0] <none>
[18:06:06.704] getGlobalsAndPackages() ... DONE
[18:06:06.705] run() for ‘Future’ ...
[18:06:06.705] - state: ‘created’
[18:06:06.706] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.715]   - Field: ‘label’
[18:06:06.716]   - Field: ‘local’
[18:06:06.716]   - Field: ‘owner’
[18:06:06.716]   - Field: ‘envir’
[18:06:06.717]   - Field: ‘workers’
[18:06:06.717]   - Field: ‘packages’
[18:06:06.717]   - Field: ‘gc’
[18:06:06.718]   - Field: ‘job’
[18:06:06.718]   - Field: ‘conditions’
[18:06:06.718]   - Field: ‘expr’
[18:06:06.719]   - Field: ‘uuid’
[18:06:06.719]   - Field: ‘seed’
[18:06:06.719]   - Field: ‘version’
[18:06:06.720]   - Field: ‘result’
[18:06:06.720]   - Field: ‘asynchronous’
[18:06:06.720]   - Field: ‘calls’
[18:06:06.721]   - Field: ‘globals’
[18:06:06.721]   - Field: ‘stdout’
[18:06:06.721]   - Field: ‘earlySignal’
[18:06:06.722]   - Field: ‘lazy’
[18:06:06.722]   - Field: ‘state’
[18:06:06.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.723] - Launch lazy future ...
[18:06:06.730] Packages needed by the future expression (n = 0): <none>
[18:06:06.731] Packages needed by future strategies (n = 0): <none>
[18:06:06.734] {
[18:06:06.734]     {
[18:06:06.734]         {
[18:06:06.734]             ...future.startTime <- base::Sys.time()
[18:06:06.734]             {
[18:06:06.734]                 {
[18:06:06.734]                   {
[18:06:06.734]                     {
[18:06:06.734]                       base::local({
[18:06:06.734]                         has_future <- base::requireNamespace("future", 
[18:06:06.734]                           quietly = TRUE)
[18:06:06.734]                         if (has_future) {
[18:06:06.734]                           ns <- base::getNamespace("future")
[18:06:06.734]                           version <- ns[[".package"]][["version"]]
[18:06:06.734]                           if (is.null(version)) 
[18:06:06.734]                             version <- utils::packageVersion("future")
[18:06:06.734]                         }
[18:06:06.734]                         else {
[18:06:06.734]                           version <- NULL
[18:06:06.734]                         }
[18:06:06.734]                         if (!has_future || version < "1.8.0") {
[18:06:06.734]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.734]                             "", base::R.version$version.string), 
[18:06:06.734]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.734]                               "release", "version")], collapse = " "), 
[18:06:06.734]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.734]                             info)
[18:06:06.734]                           info <- base::paste(info, collapse = "; ")
[18:06:06.734]                           if (!has_future) {
[18:06:06.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.734]                               info)
[18:06:06.734]                           }
[18:06:06.734]                           else {
[18:06:06.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.734]                               info, version)
[18:06:06.734]                           }
[18:06:06.734]                           base::stop(msg)
[18:06:06.734]                         }
[18:06:06.734]                       })
[18:06:06.734]                     }
[18:06:06.734]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.734]                     base::options(mc.cores = 1L)
[18:06:06.734]                   }
[18:06:06.734]                   ...future.strategy.old <- future::plan("list")
[18:06:06.734]                   options(future.plan = NULL)
[18:06:06.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.734]                 }
[18:06:06.734]                 ...future.workdir <- getwd()
[18:06:06.734]             }
[18:06:06.734]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.734]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.734]         }
[18:06:06.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.734]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.734]             base::names(...future.oldOptions))
[18:06:06.734]     }
[18:06:06.734]     if (FALSE) {
[18:06:06.734]     }
[18:06:06.734]     else {
[18:06:06.734]         if (TRUE) {
[18:06:06.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.734]                 open = "w")
[18:06:06.734]         }
[18:06:06.734]         else {
[18:06:06.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.734]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.734]         }
[18:06:06.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.734]             base::sink(type = "output", split = FALSE)
[18:06:06.734]             base::close(...future.stdout)
[18:06:06.734]         }, add = TRUE)
[18:06:06.734]     }
[18:06:06.734]     ...future.frame <- base::sys.nframe()
[18:06:06.734]     ...future.conditions <- base::list()
[18:06:06.734]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.734]     if (FALSE) {
[18:06:06.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.734]     }
[18:06:06.734]     ...future.result <- base::tryCatch({
[18:06:06.734]         base::withCallingHandlers({
[18:06:06.734]             ...future.value <- base::withVisible(base::local({
[18:06:06.734]                 withCallingHandlers({
[18:06:06.734]                   1
[18:06:06.734]                 }, immediateCondition = function(cond) {
[18:06:06.734]                   save_rds <- function (object, pathname, ...) 
[18:06:06.734]                   {
[18:06:06.734]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.734]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.734]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.734]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.734]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.734]                         fi_tmp[["mtime"]])
[18:06:06.734]                     }
[18:06:06.734]                     tryCatch({
[18:06:06.734]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.734]                     }, error = function(ex) {
[18:06:06.734]                       msg <- conditionMessage(ex)
[18:06:06.734]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.734]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.734]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.734]                         fi_tmp[["mtime"]], msg)
[18:06:06.734]                       ex$message <- msg
[18:06:06.734]                       stop(ex)
[18:06:06.734]                     })
[18:06:06.734]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.734]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.734]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.734]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.734]                       fi <- file.info(pathname)
[18:06:06.734]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.734]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.734]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.734]                         fi[["size"]], fi[["mtime"]])
[18:06:06.734]                       stop(msg)
[18:06:06.734]                     }
[18:06:06.734]                     invisible(pathname)
[18:06:06.734]                   }
[18:06:06.734]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.734]                     rootPath = tempdir()) 
[18:06:06.734]                   {
[18:06:06.734]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.734]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.734]                       tmpdir = path, fileext = ".rds")
[18:06:06.734]                     save_rds(obj, file)
[18:06:06.734]                   }
[18:06:06.734]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.734]                   {
[18:06:06.734]                     inherits <- base::inherits
[18:06:06.734]                     invokeRestart <- base::invokeRestart
[18:06:06.734]                     is.null <- base::is.null
[18:06:06.734]                     muffled <- FALSE
[18:06:06.734]                     if (inherits(cond, "message")) {
[18:06:06.734]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.734]                       if (muffled) 
[18:06:06.734]                         invokeRestart("muffleMessage")
[18:06:06.734]                     }
[18:06:06.734]                     else if (inherits(cond, "warning")) {
[18:06:06.734]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.734]                       if (muffled) 
[18:06:06.734]                         invokeRestart("muffleWarning")
[18:06:06.734]                     }
[18:06:06.734]                     else if (inherits(cond, "condition")) {
[18:06:06.734]                       if (!is.null(pattern)) {
[18:06:06.734]                         computeRestarts <- base::computeRestarts
[18:06:06.734]                         grepl <- base::grepl
[18:06:06.734]                         restarts <- computeRestarts(cond)
[18:06:06.734]                         for (restart in restarts) {
[18:06:06.734]                           name <- restart$name
[18:06:06.734]                           if (is.null(name)) 
[18:06:06.734]                             next
[18:06:06.734]                           if (!grepl(pattern, name)) 
[18:06:06.734]                             next
[18:06:06.734]                           invokeRestart(restart)
[18:06:06.734]                           muffled <- TRUE
[18:06:06.734]                           break
[18:06:06.734]                         }
[18:06:06.734]                       }
[18:06:06.734]                     }
[18:06:06.734]                     invisible(muffled)
[18:06:06.734]                   }
[18:06:06.734]                   muffleCondition(cond)
[18:06:06.734]                 })
[18:06:06.734]             }))
[18:06:06.734]             future::FutureResult(value = ...future.value$value, 
[18:06:06.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.734]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.734]                     ...future.globalenv.names))
[18:06:06.734]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.734]         }, condition = base::local({
[18:06:06.734]             c <- base::c
[18:06:06.734]             inherits <- base::inherits
[18:06:06.734]             invokeRestart <- base::invokeRestart
[18:06:06.734]             length <- base::length
[18:06:06.734]             list <- base::list
[18:06:06.734]             seq.int <- base::seq.int
[18:06:06.734]             signalCondition <- base::signalCondition
[18:06:06.734]             sys.calls <- base::sys.calls
[18:06:06.734]             `[[` <- base::`[[`
[18:06:06.734]             `+` <- base::`+`
[18:06:06.734]             `<<-` <- base::`<<-`
[18:06:06.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.734]                   3L)]
[18:06:06.734]             }
[18:06:06.734]             function(cond) {
[18:06:06.734]                 is_error <- inherits(cond, "error")
[18:06:06.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.734]                   NULL)
[18:06:06.734]                 if (is_error) {
[18:06:06.734]                   sessionInformation <- function() {
[18:06:06.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.734]                       search = base::search(), system = base::Sys.info())
[18:06:06.734]                   }
[18:06:06.734]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.734]                     cond$call), session = sessionInformation(), 
[18:06:06.734]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.734]                   signalCondition(cond)
[18:06:06.734]                 }
[18:06:06.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.734]                 "immediateCondition"))) {
[18:06:06.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.734]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.734]                   if (TRUE && !signal) {
[18:06:06.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.734]                     {
[18:06:06.734]                       inherits <- base::inherits
[18:06:06.734]                       invokeRestart <- base::invokeRestart
[18:06:06.734]                       is.null <- base::is.null
[18:06:06.734]                       muffled <- FALSE
[18:06:06.734]                       if (inherits(cond, "message")) {
[18:06:06.734]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.734]                         if (muffled) 
[18:06:06.734]                           invokeRestart("muffleMessage")
[18:06:06.734]                       }
[18:06:06.734]                       else if (inherits(cond, "warning")) {
[18:06:06.734]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.734]                         if (muffled) 
[18:06:06.734]                           invokeRestart("muffleWarning")
[18:06:06.734]                       }
[18:06:06.734]                       else if (inherits(cond, "condition")) {
[18:06:06.734]                         if (!is.null(pattern)) {
[18:06:06.734]                           computeRestarts <- base::computeRestarts
[18:06:06.734]                           grepl <- base::grepl
[18:06:06.734]                           restarts <- computeRestarts(cond)
[18:06:06.734]                           for (restart in restarts) {
[18:06:06.734]                             name <- restart$name
[18:06:06.734]                             if (is.null(name)) 
[18:06:06.734]                               next
[18:06:06.734]                             if (!grepl(pattern, name)) 
[18:06:06.734]                               next
[18:06:06.734]                             invokeRestart(restart)
[18:06:06.734]                             muffled <- TRUE
[18:06:06.734]                             break
[18:06:06.734]                           }
[18:06:06.734]                         }
[18:06:06.734]                       }
[18:06:06.734]                       invisible(muffled)
[18:06:06.734]                     }
[18:06:06.734]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.734]                   }
[18:06:06.734]                 }
[18:06:06.734]                 else {
[18:06:06.734]                   if (TRUE) {
[18:06:06.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.734]                     {
[18:06:06.734]                       inherits <- base::inherits
[18:06:06.734]                       invokeRestart <- base::invokeRestart
[18:06:06.734]                       is.null <- base::is.null
[18:06:06.734]                       muffled <- FALSE
[18:06:06.734]                       if (inherits(cond, "message")) {
[18:06:06.734]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.734]                         if (muffled) 
[18:06:06.734]                           invokeRestart("muffleMessage")
[18:06:06.734]                       }
[18:06:06.734]                       else if (inherits(cond, "warning")) {
[18:06:06.734]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.734]                         if (muffled) 
[18:06:06.734]                           invokeRestart("muffleWarning")
[18:06:06.734]                       }
[18:06:06.734]                       else if (inherits(cond, "condition")) {
[18:06:06.734]                         if (!is.null(pattern)) {
[18:06:06.734]                           computeRestarts <- base::computeRestarts
[18:06:06.734]                           grepl <- base::grepl
[18:06:06.734]                           restarts <- computeRestarts(cond)
[18:06:06.734]                           for (restart in restarts) {
[18:06:06.734]                             name <- restart$name
[18:06:06.734]                             if (is.null(name)) 
[18:06:06.734]                               next
[18:06:06.734]                             if (!grepl(pattern, name)) 
[18:06:06.734]                               next
[18:06:06.734]                             invokeRestart(restart)
[18:06:06.734]                             muffled <- TRUE
[18:06:06.734]                             break
[18:06:06.734]                           }
[18:06:06.734]                         }
[18:06:06.734]                       }
[18:06:06.734]                       invisible(muffled)
[18:06:06.734]                     }
[18:06:06.734]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.734]                   }
[18:06:06.734]                 }
[18:06:06.734]             }
[18:06:06.734]         }))
[18:06:06.734]     }, error = function(ex) {
[18:06:06.734]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.734]                 ...future.rng), started = ...future.startTime, 
[18:06:06.734]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.734]             version = "1.8"), class = "FutureResult")
[18:06:06.734]     }, finally = {
[18:06:06.734]         if (!identical(...future.workdir, getwd())) 
[18:06:06.734]             setwd(...future.workdir)
[18:06:06.734]         {
[18:06:06.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.734]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.734]             }
[18:06:06.734]             base::options(...future.oldOptions)
[18:06:06.734]             if (.Platform$OS.type == "windows") {
[18:06:06.734]                 old_names <- names(...future.oldEnvVars)
[18:06:06.734]                 envs <- base::Sys.getenv()
[18:06:06.734]                 names <- names(envs)
[18:06:06.734]                 common <- intersect(names, old_names)
[18:06:06.734]                 added <- setdiff(names, old_names)
[18:06:06.734]                 removed <- setdiff(old_names, names)
[18:06:06.734]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.734]                   envs[common]]
[18:06:06.734]                 NAMES <- toupper(changed)
[18:06:06.734]                 args <- list()
[18:06:06.734]                 for (kk in seq_along(NAMES)) {
[18:06:06.734]                   name <- changed[[kk]]
[18:06:06.734]                   NAME <- NAMES[[kk]]
[18:06:06.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.734]                     next
[18:06:06.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.734]                 }
[18:06:06.734]                 NAMES <- toupper(added)
[18:06:06.734]                 for (kk in seq_along(NAMES)) {
[18:06:06.734]                   name <- added[[kk]]
[18:06:06.734]                   NAME <- NAMES[[kk]]
[18:06:06.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.734]                     next
[18:06:06.734]                   args[[name]] <- ""
[18:06:06.734]                 }
[18:06:06.734]                 NAMES <- toupper(removed)
[18:06:06.734]                 for (kk in seq_along(NAMES)) {
[18:06:06.734]                   name <- removed[[kk]]
[18:06:06.734]                   NAME <- NAMES[[kk]]
[18:06:06.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.734]                     next
[18:06:06.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.734]                 }
[18:06:06.734]                 if (length(args) > 0) 
[18:06:06.734]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.734]             }
[18:06:06.734]             else {
[18:06:06.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.734]             }
[18:06:06.734]             {
[18:06:06.734]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.734]                   0L) {
[18:06:06.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.734]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.734]                   base::options(opts)
[18:06:06.734]                 }
[18:06:06.734]                 {
[18:06:06.734]                   {
[18:06:06.734]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.734]                     NULL
[18:06:06.734]                   }
[18:06:06.734]                   options(future.plan = NULL)
[18:06:06.734]                   if (is.na(NA_character_)) 
[18:06:06.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.734]                     .init = FALSE)
[18:06:06.734]                 }
[18:06:06.734]             }
[18:06:06.734]         }
[18:06:06.734]     })
[18:06:06.734]     if (TRUE) {
[18:06:06.734]         base::sink(type = "output", split = FALSE)
[18:06:06.734]         if (TRUE) {
[18:06:06.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.734]         }
[18:06:06.734]         else {
[18:06:06.734]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.734]         }
[18:06:06.734]         base::close(...future.stdout)
[18:06:06.734]         ...future.stdout <- NULL
[18:06:06.734]     }
[18:06:06.734]     ...future.result$conditions <- ...future.conditions
[18:06:06.734]     ...future.result$finished <- base::Sys.time()
[18:06:06.734]     ...future.result
[18:06:06.734] }
[18:06:06.740] requestCore(): workers = 2
[18:06:06.741] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:06.753] result() for MulticoreFuture ...
[18:06:06.757] result() for MulticoreFuture ...
[18:06:06.758] result() for MulticoreFuture ... done
[18:06:06.758] result() for MulticoreFuture ... done
[18:06:06.759] result() for MulticoreFuture ...
[18:06:06.759] result() for MulticoreFuture ... done
[18:06:06.763] MulticoreFuture started
[18:06:06.764] - Launch lazy future ... done
[18:06:06.765] run() for ‘MulticoreFuture’ ... done
[18:06:06.765] plan(): Setting new future strategy stack:
[18:06:06.766] getGlobalsAndPackages() ...
[18:06:06.767] Searching for globals...
[18:06:06.766] List of future strategies:
[18:06:06.766] 1. sequential:
[18:06:06.766]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.766]    - tweaked: FALSE
[18:06:06.766]    - call: NULL
[18:06:06.769] plan(): nbrOfWorkers() = 1
[18:06:06.772] - globals found: [2] ‘{’, ‘Sys.sleep’
[18:06:06.772] Searching for globals ... DONE
[18:06:06.773] Resolving globals: FALSE
[18:06:06.773] plan(): Setting new future strategy stack:
[18:06:06.774] 
[18:06:06.774] List of future strategies:
[18:06:06.774] 1. multicore:
[18:06:06.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:06.774]    - tweaked: FALSE
[18:06:06.774]    - call: plan(strategy)
[18:06:06.775] 
[18:06:06.775] getGlobalsAndPackages() ... DONE
[18:06:06.776] run() for ‘Future’ ...
[18:06:06.776] - state: ‘created’
[18:06:06.777] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:06.783] plan(): nbrOfWorkers() = 2
[18:06:06.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:06.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:06.786]   - Field: ‘label’
[18:06:06.786]   - Field: ‘local’
[18:06:06.787]   - Field: ‘owner’
[18:06:06.787]   - Field: ‘envir’
[18:06:06.787]   - Field: ‘workers’
[18:06:06.787]   - Field: ‘packages’
[18:06:06.788]   - Field: ‘gc’
[18:06:06.788]   - Field: ‘job’
[18:06:06.788]   - Field: ‘conditions’
[18:06:06.789]   - Field: ‘expr’
[18:06:06.789]   - Field: ‘uuid’
[18:06:06.789]   - Field: ‘seed’
[18:06:06.790]   - Field: ‘version’
[18:06:06.790]   - Field: ‘result’
[18:06:06.790]   - Field: ‘asynchronous’
[18:06:06.791]   - Field: ‘calls’
[18:06:06.791]   - Field: ‘globals’
[18:06:06.791]   - Field: ‘stdout’
[18:06:06.792]   - Field: ‘earlySignal’
[18:06:06.792]   - Field: ‘lazy’
[18:06:06.792]   - Field: ‘state’
[18:06:06.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:06.793] - Launch lazy future ...
[18:06:06.794] Packages needed by the future expression (n = 0): <none>
[18:06:06.794] Packages needed by future strategies (n = 0): <none>
[18:06:06.796] {
[18:06:06.796]     {
[18:06:06.796]         {
[18:06:06.796]             ...future.startTime <- base::Sys.time()
[18:06:06.796]             {
[18:06:06.796]                 {
[18:06:06.796]                   {
[18:06:06.796]                     {
[18:06:06.796]                       base::local({
[18:06:06.796]                         has_future <- base::requireNamespace("future", 
[18:06:06.796]                           quietly = TRUE)
[18:06:06.796]                         if (has_future) {
[18:06:06.796]                           ns <- base::getNamespace("future")
[18:06:06.796]                           version <- ns[[".package"]][["version"]]
[18:06:06.796]                           if (is.null(version)) 
[18:06:06.796]                             version <- utils::packageVersion("future")
[18:06:06.796]                         }
[18:06:06.796]                         else {
[18:06:06.796]                           version <- NULL
[18:06:06.796]                         }
[18:06:06.796]                         if (!has_future || version < "1.8.0") {
[18:06:06.796]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:06.796]                             "", base::R.version$version.string), 
[18:06:06.796]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:06.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:06.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:06.796]                               "release", "version")], collapse = " "), 
[18:06:06.796]                             hostname = base::Sys.info()[["nodename"]])
[18:06:06.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:06.796]                             info)
[18:06:06.796]                           info <- base::paste(info, collapse = "; ")
[18:06:06.796]                           if (!has_future) {
[18:06:06.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:06.796]                               info)
[18:06:06.796]                           }
[18:06:06.796]                           else {
[18:06:06.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:06.796]                               info, version)
[18:06:06.796]                           }
[18:06:06.796]                           base::stop(msg)
[18:06:06.796]                         }
[18:06:06.796]                       })
[18:06:06.796]                     }
[18:06:06.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:06.796]                     base::options(mc.cores = 1L)
[18:06:06.796]                   }
[18:06:06.796]                   ...future.strategy.old <- future::plan("list")
[18:06:06.796]                   options(future.plan = NULL)
[18:06:06.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:06.796]                 }
[18:06:06.796]                 ...future.workdir <- getwd()
[18:06:06.796]             }
[18:06:06.796]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:06.796]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:06.796]         }
[18:06:06.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:06.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:06.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:06.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:06.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:06.796]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:06.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:06.796]             base::names(...future.oldOptions))
[18:06:06.796]     }
[18:06:06.796]     if (FALSE) {
[18:06:06.796]     }
[18:06:06.796]     else {
[18:06:06.796]         if (TRUE) {
[18:06:06.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:06.796]                 open = "w")
[18:06:06.796]         }
[18:06:06.796]         else {
[18:06:06.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:06.796]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:06.796]         }
[18:06:06.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:06.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:06.796]             base::sink(type = "output", split = FALSE)
[18:06:06.796]             base::close(...future.stdout)
[18:06:06.796]         }, add = TRUE)
[18:06:06.796]     }
[18:06:06.796]     ...future.frame <- base::sys.nframe()
[18:06:06.796]     ...future.conditions <- base::list()
[18:06:06.796]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:06.796]     if (FALSE) {
[18:06:06.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:06.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:06.796]     }
[18:06:06.796]     ...future.result <- base::tryCatch({
[18:06:06.796]         base::withCallingHandlers({
[18:06:06.796]             ...future.value <- base::withVisible(base::local({
[18:06:06.796]                 withCallingHandlers({
[18:06:06.796]                   {
[18:06:06.796]                     Sys.sleep(0.5)
[18:06:06.796]                     2
[18:06:06.796]                   }
[18:06:06.796]                 }, immediateCondition = function(cond) {
[18:06:06.796]                   save_rds <- function (object, pathname, ...) 
[18:06:06.796]                   {
[18:06:06.796]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:06.796]                     if (file_test("-f", pathname_tmp)) {
[18:06:06.796]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.796]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:06.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.796]                         fi_tmp[["mtime"]])
[18:06:06.796]                     }
[18:06:06.796]                     tryCatch({
[18:06:06.796]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:06.796]                     }, error = function(ex) {
[18:06:06.796]                       msg <- conditionMessage(ex)
[18:06:06.796]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.796]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:06.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.796]                         fi_tmp[["mtime"]], msg)
[18:06:06.796]                       ex$message <- msg
[18:06:06.796]                       stop(ex)
[18:06:06.796]                     })
[18:06:06.796]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:06.796]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:06.796]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:06.796]                       fi_tmp <- file.info(pathname_tmp)
[18:06:06.796]                       fi <- file.info(pathname)
[18:06:06.796]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:06.796]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:06.796]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:06.796]                         fi[["size"]], fi[["mtime"]])
[18:06:06.796]                       stop(msg)
[18:06:06.796]                     }
[18:06:06.796]                     invisible(pathname)
[18:06:06.796]                   }
[18:06:06.796]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:06.796]                     rootPath = tempdir()) 
[18:06:06.796]                   {
[18:06:06.796]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:06.796]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:06.796]                       tmpdir = path, fileext = ".rds")
[18:06:06.796]                     save_rds(obj, file)
[18:06:06.796]                   }
[18:06:06.796]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:06.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.796]                   {
[18:06:06.796]                     inherits <- base::inherits
[18:06:06.796]                     invokeRestart <- base::invokeRestart
[18:06:06.796]                     is.null <- base::is.null
[18:06:06.796]                     muffled <- FALSE
[18:06:06.796]                     if (inherits(cond, "message")) {
[18:06:06.796]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:06.796]                       if (muffled) 
[18:06:06.796]                         invokeRestart("muffleMessage")
[18:06:06.796]                     }
[18:06:06.796]                     else if (inherits(cond, "warning")) {
[18:06:06.796]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:06.796]                       if (muffled) 
[18:06:06.796]                         invokeRestart("muffleWarning")
[18:06:06.796]                     }
[18:06:06.796]                     else if (inherits(cond, "condition")) {
[18:06:06.796]                       if (!is.null(pattern)) {
[18:06:06.796]                         computeRestarts <- base::computeRestarts
[18:06:06.796]                         grepl <- base::grepl
[18:06:06.796]                         restarts <- computeRestarts(cond)
[18:06:06.796]                         for (restart in restarts) {
[18:06:06.796]                           name <- restart$name
[18:06:06.796]                           if (is.null(name)) 
[18:06:06.796]                             next
[18:06:06.796]                           if (!grepl(pattern, name)) 
[18:06:06.796]                             next
[18:06:06.796]                           invokeRestart(restart)
[18:06:06.796]                           muffled <- TRUE
[18:06:06.796]                           break
[18:06:06.796]                         }
[18:06:06.796]                       }
[18:06:06.796]                     }
[18:06:06.796]                     invisible(muffled)
[18:06:06.796]                   }
[18:06:06.796]                   muffleCondition(cond)
[18:06:06.796]                 })
[18:06:06.796]             }))
[18:06:06.796]             future::FutureResult(value = ...future.value$value, 
[18:06:06.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.796]                   ...future.rng), globalenv = if (FALSE) 
[18:06:06.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:06.796]                     ...future.globalenv.names))
[18:06:06.796]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:06.796]         }, condition = base::local({
[18:06:06.796]             c <- base::c
[18:06:06.796]             inherits <- base::inherits
[18:06:06.796]             invokeRestart <- base::invokeRestart
[18:06:06.796]             length <- base::length
[18:06:06.796]             list <- base::list
[18:06:06.796]             seq.int <- base::seq.int
[18:06:06.796]             signalCondition <- base::signalCondition
[18:06:06.796]             sys.calls <- base::sys.calls
[18:06:06.796]             `[[` <- base::`[[`
[18:06:06.796]             `+` <- base::`+`
[18:06:06.796]             `<<-` <- base::`<<-`
[18:06:06.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:06.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:06.796]                   3L)]
[18:06:06.796]             }
[18:06:06.796]             function(cond) {
[18:06:06.796]                 is_error <- inherits(cond, "error")
[18:06:06.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:06.796]                   NULL)
[18:06:06.796]                 if (is_error) {
[18:06:06.796]                   sessionInformation <- function() {
[18:06:06.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:06.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:06.796]                       search = base::search(), system = base::Sys.info())
[18:06:06.796]                   }
[18:06:06.796]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:06.796]                     cond$call), session = sessionInformation(), 
[18:06:06.796]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:06.796]                   signalCondition(cond)
[18:06:06.796]                 }
[18:06:06.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:06.796]                 "immediateCondition"))) {
[18:06:06.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:06.796]                   ...future.conditions[[length(...future.conditions) + 
[18:06:06.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:06.796]                   if (TRUE && !signal) {
[18:06:06.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.796]                     {
[18:06:06.796]                       inherits <- base::inherits
[18:06:06.796]                       invokeRestart <- base::invokeRestart
[18:06:06.796]                       is.null <- base::is.null
[18:06:06.796]                       muffled <- FALSE
[18:06:06.796]                       if (inherits(cond, "message")) {
[18:06:06.796]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.796]                         if (muffled) 
[18:06:06.796]                           invokeRestart("muffleMessage")
[18:06:06.796]                       }
[18:06:06.796]                       else if (inherits(cond, "warning")) {
[18:06:06.796]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.796]                         if (muffled) 
[18:06:06.796]                           invokeRestart("muffleWarning")
[18:06:06.796]                       }
[18:06:06.796]                       else if (inherits(cond, "condition")) {
[18:06:06.796]                         if (!is.null(pattern)) {
[18:06:06.796]                           computeRestarts <- base::computeRestarts
[18:06:06.796]                           grepl <- base::grepl
[18:06:06.796]                           restarts <- computeRestarts(cond)
[18:06:06.796]                           for (restart in restarts) {
[18:06:06.796]                             name <- restart$name
[18:06:06.796]                             if (is.null(name)) 
[18:06:06.796]                               next
[18:06:06.796]                             if (!grepl(pattern, name)) 
[18:06:06.796]                               next
[18:06:06.796]                             invokeRestart(restart)
[18:06:06.796]                             muffled <- TRUE
[18:06:06.796]                             break
[18:06:06.796]                           }
[18:06:06.796]                         }
[18:06:06.796]                       }
[18:06:06.796]                       invisible(muffled)
[18:06:06.796]                     }
[18:06:06.796]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.796]                   }
[18:06:06.796]                 }
[18:06:06.796]                 else {
[18:06:06.796]                   if (TRUE) {
[18:06:06.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:06.796]                     {
[18:06:06.796]                       inherits <- base::inherits
[18:06:06.796]                       invokeRestart <- base::invokeRestart
[18:06:06.796]                       is.null <- base::is.null
[18:06:06.796]                       muffled <- FALSE
[18:06:06.796]                       if (inherits(cond, "message")) {
[18:06:06.796]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:06.796]                         if (muffled) 
[18:06:06.796]                           invokeRestart("muffleMessage")
[18:06:06.796]                       }
[18:06:06.796]                       else if (inherits(cond, "warning")) {
[18:06:06.796]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:06.796]                         if (muffled) 
[18:06:06.796]                           invokeRestart("muffleWarning")
[18:06:06.796]                       }
[18:06:06.796]                       else if (inherits(cond, "condition")) {
[18:06:06.796]                         if (!is.null(pattern)) {
[18:06:06.796]                           computeRestarts <- base::computeRestarts
[18:06:06.796]                           grepl <- base::grepl
[18:06:06.796]                           restarts <- computeRestarts(cond)
[18:06:06.796]                           for (restart in restarts) {
[18:06:06.796]                             name <- restart$name
[18:06:06.796]                             if (is.null(name)) 
[18:06:06.796]                               next
[18:06:06.796]                             if (!grepl(pattern, name)) 
[18:06:06.796]                               next
[18:06:06.796]                             invokeRestart(restart)
[18:06:06.796]                             muffled <- TRUE
[18:06:06.796]                             break
[18:06:06.796]                           }
[18:06:06.796]                         }
[18:06:06.796]                       }
[18:06:06.796]                       invisible(muffled)
[18:06:06.796]                     }
[18:06:06.796]                     muffleCondition(cond, pattern = "^muffle")
[18:06:06.796]                   }
[18:06:06.796]                 }
[18:06:06.796]             }
[18:06:06.796]         }))
[18:06:06.796]     }, error = function(ex) {
[18:06:06.796]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:06.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:06.796]                 ...future.rng), started = ...future.startTime, 
[18:06:06.796]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:06.796]             version = "1.8"), class = "FutureResult")
[18:06:06.796]     }, finally = {
[18:06:06.796]         if (!identical(...future.workdir, getwd())) 
[18:06:06.796]             setwd(...future.workdir)
[18:06:06.796]         {
[18:06:06.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:06.796]                 ...future.oldOptions$nwarnings <- NULL
[18:06:06.796]             }
[18:06:06.796]             base::options(...future.oldOptions)
[18:06:06.796]             if (.Platform$OS.type == "windows") {
[18:06:06.796]                 old_names <- names(...future.oldEnvVars)
[18:06:06.796]                 envs <- base::Sys.getenv()
[18:06:06.796]                 names <- names(envs)
[18:06:06.796]                 common <- intersect(names, old_names)
[18:06:06.796]                 added <- setdiff(names, old_names)
[18:06:06.796]                 removed <- setdiff(old_names, names)
[18:06:06.796]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:06.796]                   envs[common]]
[18:06:06.796]                 NAMES <- toupper(changed)
[18:06:06.796]                 args <- list()
[18:06:06.796]                 for (kk in seq_along(NAMES)) {
[18:06:06.796]                   name <- changed[[kk]]
[18:06:06.796]                   NAME <- NAMES[[kk]]
[18:06:06.796]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.796]                     next
[18:06:06.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.796]                 }
[18:06:06.796]                 NAMES <- toupper(added)
[18:06:06.796]                 for (kk in seq_along(NAMES)) {
[18:06:06.796]                   name <- added[[kk]]
[18:06:06.796]                   NAME <- NAMES[[kk]]
[18:06:06.796]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.796]                     next
[18:06:06.796]                   args[[name]] <- ""
[18:06:06.796]                 }
[18:06:06.796]                 NAMES <- toupper(removed)
[18:06:06.796]                 for (kk in seq_along(NAMES)) {
[18:06:06.796]                   name <- removed[[kk]]
[18:06:06.796]                   NAME <- NAMES[[kk]]
[18:06:06.796]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:06.796]                     next
[18:06:06.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:06.796]                 }
[18:06:06.796]                 if (length(args) > 0) 
[18:06:06.796]                   base::do.call(base::Sys.setenv, args = args)
[18:06:06.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:06.796]             }
[18:06:06.796]             else {
[18:06:06.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:06.796]             }
[18:06:06.796]             {
[18:06:06.796]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:06.796]                   0L) {
[18:06:06.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:06.796]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:06.796]                   base::options(opts)
[18:06:06.796]                 }
[18:06:06.796]                 {
[18:06:06.796]                   {
[18:06:06.796]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:06.796]                     NULL
[18:06:06.796]                   }
[18:06:06.796]                   options(future.plan = NULL)
[18:06:06.796]                   if (is.na(NA_character_)) 
[18:06:06.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:06.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:06.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:06.796]                     .init = FALSE)
[18:06:06.796]                 }
[18:06:06.796]             }
[18:06:06.796]         }
[18:06:06.796]     })
[18:06:06.796]     if (TRUE) {
[18:06:06.796]         base::sink(type = "output", split = FALSE)
[18:06:06.796]         if (TRUE) {
[18:06:06.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:06.796]         }
[18:06:06.796]         else {
[18:06:06.796]             ...future.result["stdout"] <- base::list(NULL)
[18:06:06.796]         }
[18:06:06.796]         base::close(...future.stdout)
[18:06:06.796]         ...future.stdout <- NULL
[18:06:06.796]     }
[18:06:06.796]     ...future.result$conditions <- ...future.conditions
[18:06:06.796]     ...future.result$finished <- base::Sys.time()
[18:06:06.796]     ...future.result
[18:06:06.796] }
[18:06:06.802] requestCore(): workers = 2
[18:06:06.803] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:06.816] result() for MulticoreFuture ...
[18:06:06.819] result() for MulticoreFuture ...
[18:06:06.819] result() for MulticoreFuture ... done
[18:06:06.819] result() for MulticoreFuture ... done
[18:06:06.825] result() for MulticoreFuture ...
[18:06:06.826] result() for MulticoreFuture ... done
[18:06:06.831] MulticoreFuture started
[18:06:06.832] - Launch lazy future ... done
[18:06:06.832] run() for ‘MulticoreFuture’ ... done
[18:06:06.834] resolve() on list ...
[18:06:06.834]  recursive: 0
[18:06:06.834]  length: 1
[18:06:06.835] 
[18:06:06.836] plan(): Setting new future strategy stack:
[18:06:06.836] Future #1
[18:06:06.837]  length: 0 (resolved future 1)
[18:06:06.837] resolve() on list ... DONE
[18:06:06.838] resolve() on list ...
[18:06:06.836] List of future strategies:
[18:06:06.836] 1. sequential:
[18:06:06.836]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:06.836]    - tweaked: FALSE
[18:06:06.836]    - call: NULL
[18:06:06.840] plan(): nbrOfWorkers() = 1
[18:06:06.839]  recursive: 0
[18:06:06.840]  length: 1
[18:06:06.840] 
[18:06:07.347] plan(): Setting new future strategy stack:
[18:06:07.347] List of future strategies:
[18:06:07.347] 1. multicore:
[18:06:07.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:07.347]    - tweaked: FALSE
[18:06:07.347]    - call: plan(strategy)
[18:06:07.360] plan(): nbrOfWorkers() = 2
[18:06:07.361] Future #1
[18:06:07.362]  length: 0 (resolved future 1)
[18:06:07.362] resolve() on list ... DONE
[18:06:07.363] resolve() on list ...
[18:06:07.363]  recursive: 0
[18:06:07.364]  length: 1
[18:06:07.364] 
[18:06:07.365]  length: 0 (resolved future 1)
[18:06:07.365] resolve() on list ... DONE
[18:06:07.366] resolve() on list ...
[18:06:07.366]  recursive: 0
[18:06:07.366]  length: 4
[18:06:07.366] 
[18:06:07.367] Future #1
[18:06:07.368]  length: 3 (resolved future 1)
[18:06:07.368] Future #2
[18:06:07.369]  length: 2 (resolved future 2)
[18:06:07.369]  length: 1 (resolved future 3)
[18:06:07.369]  length: 0 (resolved future 4)
[18:06:07.370] resolve() on list ... DONE
[18:06:07.370] resolve() on list ...
[18:06:07.371]  recursive: 0
[18:06:07.371]  length: 4
[18:06:07.371] 
[18:06:07.372] Future #1
[18:06:07.372]  length: 3 (resolved future 1)
[18:06:07.373] Future #2
[18:06:07.373]  length: 2 (resolved future 2)
[18:06:07.374]  length: 1 (resolved future 3)
[18:06:07.375]  length: 0 (resolved future 4)
[18:06:07.375] resolve() on list ... DONE
[18:06:07.376] resolve() on list ...
[18:06:07.376]  recursive: 0
[18:06:07.377]  length: 1
[18:06:07.377] 
[18:06:07.377]  length: 0 (resolved future 1)
[18:06:07.378] resolve() on list ... DONE
[18:06:07.378] getGlobalsAndPackages() ...
[18:06:07.378] Searching for globals...
[18:06:07.383] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:07.383] Searching for globals ... DONE
[18:06:07.384] Resolving globals: FALSE
[18:06:07.385] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:07.386] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:07.387] - globals: [1] ‘kk’
[18:06:07.387] 
[18:06:07.387] getGlobalsAndPackages() ... DONE
[18:06:07.388] run() for ‘Future’ ...
[18:06:07.388] - state: ‘created’
[18:06:07.389] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:07.397] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:07.398] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:07.398]   - Field: ‘label’
[18:06:07.399]   - Field: ‘local’
[18:06:07.399]   - Field: ‘owner’
[18:06:07.399]   - Field: ‘envir’
[18:06:07.400]   - Field: ‘workers’
[18:06:07.400]   - Field: ‘packages’
[18:06:07.401]   - Field: ‘gc’
[18:06:07.401]   - Field: ‘job’
[18:06:07.401]   - Field: ‘conditions’
[18:06:07.402]   - Field: ‘expr’
[18:06:07.402]   - Field: ‘uuid’
[18:06:07.402]   - Field: ‘seed’
[18:06:07.408]   - Field: ‘version’
[18:06:07.408]   - Field: ‘result’
[18:06:07.409]   - Field: ‘asynchronous’
[18:06:07.409]   - Field: ‘calls’
[18:06:07.410]   - Field: ‘globals’
[18:06:07.411]   - Field: ‘stdout’
[18:06:07.411]   - Field: ‘earlySignal’
[18:06:07.411]   - Field: ‘lazy’
[18:06:07.412]   - Field: ‘state’
[18:06:07.412] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:07.413] - Launch lazy future ...
[18:06:07.414] Packages needed by the future expression (n = 0): <none>
[18:06:07.414] Packages needed by future strategies (n = 0): <none>
[18:06:07.416] {
[18:06:07.416]     {
[18:06:07.416]         {
[18:06:07.416]             ...future.startTime <- base::Sys.time()
[18:06:07.416]             {
[18:06:07.416]                 {
[18:06:07.416]                   {
[18:06:07.416]                     {
[18:06:07.416]                       base::local({
[18:06:07.416]                         has_future <- base::requireNamespace("future", 
[18:06:07.416]                           quietly = TRUE)
[18:06:07.416]                         if (has_future) {
[18:06:07.416]                           ns <- base::getNamespace("future")
[18:06:07.416]                           version <- ns[[".package"]][["version"]]
[18:06:07.416]                           if (is.null(version)) 
[18:06:07.416]                             version <- utils::packageVersion("future")
[18:06:07.416]                         }
[18:06:07.416]                         else {
[18:06:07.416]                           version <- NULL
[18:06:07.416]                         }
[18:06:07.416]                         if (!has_future || version < "1.8.0") {
[18:06:07.416]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:07.416]                             "", base::R.version$version.string), 
[18:06:07.416]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:07.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:07.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:07.416]                               "release", "version")], collapse = " "), 
[18:06:07.416]                             hostname = base::Sys.info()[["nodename"]])
[18:06:07.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:07.416]                             info)
[18:06:07.416]                           info <- base::paste(info, collapse = "; ")
[18:06:07.416]                           if (!has_future) {
[18:06:07.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:07.416]                               info)
[18:06:07.416]                           }
[18:06:07.416]                           else {
[18:06:07.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:07.416]                               info, version)
[18:06:07.416]                           }
[18:06:07.416]                           base::stop(msg)
[18:06:07.416]                         }
[18:06:07.416]                       })
[18:06:07.416]                     }
[18:06:07.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:07.416]                     base::options(mc.cores = 1L)
[18:06:07.416]                   }
[18:06:07.416]                   ...future.strategy.old <- future::plan("list")
[18:06:07.416]                   options(future.plan = NULL)
[18:06:07.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:07.416]                 }
[18:06:07.416]                 ...future.workdir <- getwd()
[18:06:07.416]             }
[18:06:07.416]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:07.416]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:07.416]         }
[18:06:07.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:07.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:07.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:07.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:07.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:07.416]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:07.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:07.416]             base::names(...future.oldOptions))
[18:06:07.416]     }
[18:06:07.416]     if (FALSE) {
[18:06:07.416]     }
[18:06:07.416]     else {
[18:06:07.416]         if (TRUE) {
[18:06:07.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:07.416]                 open = "w")
[18:06:07.416]         }
[18:06:07.416]         else {
[18:06:07.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:07.416]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:07.416]         }
[18:06:07.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:07.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:07.416]             base::sink(type = "output", split = FALSE)
[18:06:07.416]             base::close(...future.stdout)
[18:06:07.416]         }, add = TRUE)
[18:06:07.416]     }
[18:06:07.416]     ...future.frame <- base::sys.nframe()
[18:06:07.416]     ...future.conditions <- base::list()
[18:06:07.416]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:07.416]     if (FALSE) {
[18:06:07.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:07.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:07.416]     }
[18:06:07.416]     ...future.result <- base::tryCatch({
[18:06:07.416]         base::withCallingHandlers({
[18:06:07.416]             ...future.value <- base::withVisible(base::local({
[18:06:07.416]                 withCallingHandlers({
[18:06:07.416]                   {
[18:06:07.416]                     Sys.sleep(0.1)
[18:06:07.416]                     kk
[18:06:07.416]                   }
[18:06:07.416]                 }, immediateCondition = function(cond) {
[18:06:07.416]                   save_rds <- function (object, pathname, ...) 
[18:06:07.416]                   {
[18:06:07.416]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:07.416]                     if (file_test("-f", pathname_tmp)) {
[18:06:07.416]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.416]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:07.416]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.416]                         fi_tmp[["mtime"]])
[18:06:07.416]                     }
[18:06:07.416]                     tryCatch({
[18:06:07.416]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:07.416]                     }, error = function(ex) {
[18:06:07.416]                       msg <- conditionMessage(ex)
[18:06:07.416]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.416]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:07.416]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.416]                         fi_tmp[["mtime"]], msg)
[18:06:07.416]                       ex$message <- msg
[18:06:07.416]                       stop(ex)
[18:06:07.416]                     })
[18:06:07.416]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:07.416]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:07.416]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:07.416]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.416]                       fi <- file.info(pathname)
[18:06:07.416]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:07.416]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.416]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:07.416]                         fi[["size"]], fi[["mtime"]])
[18:06:07.416]                       stop(msg)
[18:06:07.416]                     }
[18:06:07.416]                     invisible(pathname)
[18:06:07.416]                   }
[18:06:07.416]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:07.416]                     rootPath = tempdir()) 
[18:06:07.416]                   {
[18:06:07.416]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:07.416]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:07.416]                       tmpdir = path, fileext = ".rds")
[18:06:07.416]                     save_rds(obj, file)
[18:06:07.416]                   }
[18:06:07.416]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:07.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.416]                   {
[18:06:07.416]                     inherits <- base::inherits
[18:06:07.416]                     invokeRestart <- base::invokeRestart
[18:06:07.416]                     is.null <- base::is.null
[18:06:07.416]                     muffled <- FALSE
[18:06:07.416]                     if (inherits(cond, "message")) {
[18:06:07.416]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:07.416]                       if (muffled) 
[18:06:07.416]                         invokeRestart("muffleMessage")
[18:06:07.416]                     }
[18:06:07.416]                     else if (inherits(cond, "warning")) {
[18:06:07.416]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:07.416]                       if (muffled) 
[18:06:07.416]                         invokeRestart("muffleWarning")
[18:06:07.416]                     }
[18:06:07.416]                     else if (inherits(cond, "condition")) {
[18:06:07.416]                       if (!is.null(pattern)) {
[18:06:07.416]                         computeRestarts <- base::computeRestarts
[18:06:07.416]                         grepl <- base::grepl
[18:06:07.416]                         restarts <- computeRestarts(cond)
[18:06:07.416]                         for (restart in restarts) {
[18:06:07.416]                           name <- restart$name
[18:06:07.416]                           if (is.null(name)) 
[18:06:07.416]                             next
[18:06:07.416]                           if (!grepl(pattern, name)) 
[18:06:07.416]                             next
[18:06:07.416]                           invokeRestart(restart)
[18:06:07.416]                           muffled <- TRUE
[18:06:07.416]                           break
[18:06:07.416]                         }
[18:06:07.416]                       }
[18:06:07.416]                     }
[18:06:07.416]                     invisible(muffled)
[18:06:07.416]                   }
[18:06:07.416]                   muffleCondition(cond)
[18:06:07.416]                 })
[18:06:07.416]             }))
[18:06:07.416]             future::FutureResult(value = ...future.value$value, 
[18:06:07.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.416]                   ...future.rng), globalenv = if (FALSE) 
[18:06:07.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:07.416]                     ...future.globalenv.names))
[18:06:07.416]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:07.416]         }, condition = base::local({
[18:06:07.416]             c <- base::c
[18:06:07.416]             inherits <- base::inherits
[18:06:07.416]             invokeRestart <- base::invokeRestart
[18:06:07.416]             length <- base::length
[18:06:07.416]             list <- base::list
[18:06:07.416]             seq.int <- base::seq.int
[18:06:07.416]             signalCondition <- base::signalCondition
[18:06:07.416]             sys.calls <- base::sys.calls
[18:06:07.416]             `[[` <- base::`[[`
[18:06:07.416]             `+` <- base::`+`
[18:06:07.416]             `<<-` <- base::`<<-`
[18:06:07.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:07.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:07.416]                   3L)]
[18:06:07.416]             }
[18:06:07.416]             function(cond) {
[18:06:07.416]                 is_error <- inherits(cond, "error")
[18:06:07.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:07.416]                   NULL)
[18:06:07.416]                 if (is_error) {
[18:06:07.416]                   sessionInformation <- function() {
[18:06:07.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:07.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:07.416]                       search = base::search(), system = base::Sys.info())
[18:06:07.416]                   }
[18:06:07.416]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:07.416]                     cond$call), session = sessionInformation(), 
[18:06:07.416]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:07.416]                   signalCondition(cond)
[18:06:07.416]                 }
[18:06:07.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:07.416]                 "immediateCondition"))) {
[18:06:07.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:07.416]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:07.416]                   if (TRUE && !signal) {
[18:06:07.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.416]                     {
[18:06:07.416]                       inherits <- base::inherits
[18:06:07.416]                       invokeRestart <- base::invokeRestart
[18:06:07.416]                       is.null <- base::is.null
[18:06:07.416]                       muffled <- FALSE
[18:06:07.416]                       if (inherits(cond, "message")) {
[18:06:07.416]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.416]                         if (muffled) 
[18:06:07.416]                           invokeRestart("muffleMessage")
[18:06:07.416]                       }
[18:06:07.416]                       else if (inherits(cond, "warning")) {
[18:06:07.416]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.416]                         if (muffled) 
[18:06:07.416]                           invokeRestart("muffleWarning")
[18:06:07.416]                       }
[18:06:07.416]                       else if (inherits(cond, "condition")) {
[18:06:07.416]                         if (!is.null(pattern)) {
[18:06:07.416]                           computeRestarts <- base::computeRestarts
[18:06:07.416]                           grepl <- base::grepl
[18:06:07.416]                           restarts <- computeRestarts(cond)
[18:06:07.416]                           for (restart in restarts) {
[18:06:07.416]                             name <- restart$name
[18:06:07.416]                             if (is.null(name)) 
[18:06:07.416]                               next
[18:06:07.416]                             if (!grepl(pattern, name)) 
[18:06:07.416]                               next
[18:06:07.416]                             invokeRestart(restart)
[18:06:07.416]                             muffled <- TRUE
[18:06:07.416]                             break
[18:06:07.416]                           }
[18:06:07.416]                         }
[18:06:07.416]                       }
[18:06:07.416]                       invisible(muffled)
[18:06:07.416]                     }
[18:06:07.416]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.416]                   }
[18:06:07.416]                 }
[18:06:07.416]                 else {
[18:06:07.416]                   if (TRUE) {
[18:06:07.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.416]                     {
[18:06:07.416]                       inherits <- base::inherits
[18:06:07.416]                       invokeRestart <- base::invokeRestart
[18:06:07.416]                       is.null <- base::is.null
[18:06:07.416]                       muffled <- FALSE
[18:06:07.416]                       if (inherits(cond, "message")) {
[18:06:07.416]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.416]                         if (muffled) 
[18:06:07.416]                           invokeRestart("muffleMessage")
[18:06:07.416]                       }
[18:06:07.416]                       else if (inherits(cond, "warning")) {
[18:06:07.416]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.416]                         if (muffled) 
[18:06:07.416]                           invokeRestart("muffleWarning")
[18:06:07.416]                       }
[18:06:07.416]                       else if (inherits(cond, "condition")) {
[18:06:07.416]                         if (!is.null(pattern)) {
[18:06:07.416]                           computeRestarts <- base::computeRestarts
[18:06:07.416]                           grepl <- base::grepl
[18:06:07.416]                           restarts <- computeRestarts(cond)
[18:06:07.416]                           for (restart in restarts) {
[18:06:07.416]                             name <- restart$name
[18:06:07.416]                             if (is.null(name)) 
[18:06:07.416]                               next
[18:06:07.416]                             if (!grepl(pattern, name)) 
[18:06:07.416]                               next
[18:06:07.416]                             invokeRestart(restart)
[18:06:07.416]                             muffled <- TRUE
[18:06:07.416]                             break
[18:06:07.416]                           }
[18:06:07.416]                         }
[18:06:07.416]                       }
[18:06:07.416]                       invisible(muffled)
[18:06:07.416]                     }
[18:06:07.416]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.416]                   }
[18:06:07.416]                 }
[18:06:07.416]             }
[18:06:07.416]         }))
[18:06:07.416]     }, error = function(ex) {
[18:06:07.416]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:07.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.416]                 ...future.rng), started = ...future.startTime, 
[18:06:07.416]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:07.416]             version = "1.8"), class = "FutureResult")
[18:06:07.416]     }, finally = {
[18:06:07.416]         if (!identical(...future.workdir, getwd())) 
[18:06:07.416]             setwd(...future.workdir)
[18:06:07.416]         {
[18:06:07.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:07.416]                 ...future.oldOptions$nwarnings <- NULL
[18:06:07.416]             }
[18:06:07.416]             base::options(...future.oldOptions)
[18:06:07.416]             if (.Platform$OS.type == "windows") {
[18:06:07.416]                 old_names <- names(...future.oldEnvVars)
[18:06:07.416]                 envs <- base::Sys.getenv()
[18:06:07.416]                 names <- names(envs)
[18:06:07.416]                 common <- intersect(names, old_names)
[18:06:07.416]                 added <- setdiff(names, old_names)
[18:06:07.416]                 removed <- setdiff(old_names, names)
[18:06:07.416]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:07.416]                   envs[common]]
[18:06:07.416]                 NAMES <- toupper(changed)
[18:06:07.416]                 args <- list()
[18:06:07.416]                 for (kk in seq_along(NAMES)) {
[18:06:07.416]                   name <- changed[[kk]]
[18:06:07.416]                   NAME <- NAMES[[kk]]
[18:06:07.416]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.416]                     next
[18:06:07.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.416]                 }
[18:06:07.416]                 NAMES <- toupper(added)
[18:06:07.416]                 for (kk in seq_along(NAMES)) {
[18:06:07.416]                   name <- added[[kk]]
[18:06:07.416]                   NAME <- NAMES[[kk]]
[18:06:07.416]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.416]                     next
[18:06:07.416]                   args[[name]] <- ""
[18:06:07.416]                 }
[18:06:07.416]                 NAMES <- toupper(removed)
[18:06:07.416]                 for (kk in seq_along(NAMES)) {
[18:06:07.416]                   name <- removed[[kk]]
[18:06:07.416]                   NAME <- NAMES[[kk]]
[18:06:07.416]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.416]                     next
[18:06:07.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.416]                 }
[18:06:07.416]                 if (length(args) > 0) 
[18:06:07.416]                   base::do.call(base::Sys.setenv, args = args)
[18:06:07.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:07.416]             }
[18:06:07.416]             else {
[18:06:07.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:07.416]             }
[18:06:07.416]             {
[18:06:07.416]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:07.416]                   0L) {
[18:06:07.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:07.416]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:07.416]                   base::options(opts)
[18:06:07.416]                 }
[18:06:07.416]                 {
[18:06:07.416]                   {
[18:06:07.416]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:07.416]                     NULL
[18:06:07.416]                   }
[18:06:07.416]                   options(future.plan = NULL)
[18:06:07.416]                   if (is.na(NA_character_)) 
[18:06:07.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:07.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:07.416]                     .init = FALSE)
[18:06:07.416]                 }
[18:06:07.416]             }
[18:06:07.416]         }
[18:06:07.416]     })
[18:06:07.416]     if (TRUE) {
[18:06:07.416]         base::sink(type = "output", split = FALSE)
[18:06:07.416]         if (TRUE) {
[18:06:07.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:07.416]         }
[18:06:07.416]         else {
[18:06:07.416]             ...future.result["stdout"] <- base::list(NULL)
[18:06:07.416]         }
[18:06:07.416]         base::close(...future.stdout)
[18:06:07.416]         ...future.stdout <- NULL
[18:06:07.416]     }
[18:06:07.416]     ...future.result$conditions <- ...future.conditions
[18:06:07.416]     ...future.result$finished <- base::Sys.time()
[18:06:07.416]     ...future.result
[18:06:07.416] }
[18:06:07.421] assign_globals() ...
[18:06:07.421] List of 1
[18:06:07.421]  $ kk: int 1
[18:06:07.421]  - attr(*, "where")=List of 1
[18:06:07.421]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:07.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:07.421]  - attr(*, "resolved")= logi FALSE
[18:06:07.421]  - attr(*, "total_size")= num 56
[18:06:07.421]  - attr(*, "already-done")= logi TRUE
[18:06:07.430] - copied ‘kk’ to environment
[18:06:07.430] assign_globals() ... done
[18:06:07.431] requestCore(): workers = 2
[18:06:07.431] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:07.442] result() for MulticoreFuture ...
[18:06:07.444] result() for MulticoreFuture ...
[18:06:07.444] result() for MulticoreFuture ... done
[18:06:07.445] result() for MulticoreFuture ... done
[18:06:07.445] result() for MulticoreFuture ...
[18:06:07.445] result() for MulticoreFuture ... done
[18:06:07.449] MulticoreFuture started
[18:06:07.450] - Launch lazy future ... done
[18:06:07.451] run() for ‘MulticoreFuture’ ... done
[18:06:07.452] plan(): Setting new future strategy stack:
[18:06:07.452] getGlobalsAndPackages() ...
[18:06:07.452] Searching for globals...
[18:06:07.452] List of future strategies:
[18:06:07.452] 1. sequential:
[18:06:07.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:07.452]    - tweaked: FALSE
[18:06:07.452]    - call: NULL
[18:06:07.455] plan(): nbrOfWorkers() = 1
[18:06:07.457] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:07.458] Searching for globals ... DONE
[18:06:07.458] Resolving globals: FALSE
[18:06:07.460] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:07.462] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:07.462] - globals: [1] ‘kk’
[18:06:07.463] 
[18:06:07.463] getGlobalsAndPackages() ... DONE
[18:06:07.464] run() for ‘Future’ ...
[18:06:07.464] - state: ‘created’
[18:06:07.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:07.474] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:07.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:07.474]   - Field: ‘label’
[18:06:07.475]   - Field: ‘local’
[18:06:07.475]   - Field: ‘owner’
[18:06:07.476]   - Field: ‘envir’
[18:06:07.476]   - Field: ‘workers’
[18:06:07.476]   - Field: ‘packages’
[18:06:07.476]   - Field: ‘gc’
[18:06:07.477]   - Field: ‘job’
[18:06:07.477]   - Field: ‘conditions’
[18:06:07.477]   - Field: ‘expr’
[18:06:07.478]   - Field: ‘uuid’
[18:06:07.478]   - Field: ‘seed’
[18:06:07.478]   - Field: ‘version’
[18:06:07.479]   - Field: ‘result’
[18:06:07.479]   - Field: ‘asynchronous’
[18:06:07.479]   - Field: ‘calls’
[18:06:07.480]   - Field: ‘globals’
[18:06:07.480]   - Field: ‘stdout’
[18:06:07.480]   - Field: ‘earlySignal’
[18:06:07.480]   - Field: ‘lazy’
[18:06:07.481]   - Field: ‘state’
[18:06:07.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:07.481] - Launch lazy future ...
[18:06:07.482] Packages needed by the future expression (n = 0): <none>
[18:06:07.483] Packages needed by future strategies (n = 0): <none>
[18:06:07.484] {
[18:06:07.484]     {
[18:06:07.484]         {
[18:06:07.484]             ...future.startTime <- base::Sys.time()
[18:06:07.484]             {
[18:06:07.484]                 {
[18:06:07.484]                   {
[18:06:07.484]                     {
[18:06:07.484]                       base::local({
[18:06:07.484]                         has_future <- base::requireNamespace("future", 
[18:06:07.484]                           quietly = TRUE)
[18:06:07.484]                         if (has_future) {
[18:06:07.484]                           ns <- base::getNamespace("future")
[18:06:07.484]                           version <- ns[[".package"]][["version"]]
[18:06:07.484]                           if (is.null(version)) 
[18:06:07.484]                             version <- utils::packageVersion("future")
[18:06:07.484]                         }
[18:06:07.484]                         else {
[18:06:07.484]                           version <- NULL
[18:06:07.484]                         }
[18:06:07.484]                         if (!has_future || version < "1.8.0") {
[18:06:07.484]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:07.484]                             "", base::R.version$version.string), 
[18:06:07.484]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:07.484]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:07.484]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:07.484]                               "release", "version")], collapse = " "), 
[18:06:07.484]                             hostname = base::Sys.info()[["nodename"]])
[18:06:07.484]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:07.484]                             info)
[18:06:07.484]                           info <- base::paste(info, collapse = "; ")
[18:06:07.484]                           if (!has_future) {
[18:06:07.484]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:07.484]                               info)
[18:06:07.484]                           }
[18:06:07.484]                           else {
[18:06:07.484]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:07.484]                               info, version)
[18:06:07.484]                           }
[18:06:07.484]                           base::stop(msg)
[18:06:07.484]                         }
[18:06:07.484]                       })
[18:06:07.484]                     }
[18:06:07.484]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:07.484]                     base::options(mc.cores = 1L)
[18:06:07.484]                   }
[18:06:07.484]                   ...future.strategy.old <- future::plan("list")
[18:06:07.484]                   options(future.plan = NULL)
[18:06:07.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:07.484]                 }
[18:06:07.484]                 ...future.workdir <- getwd()
[18:06:07.484]             }
[18:06:07.484]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:07.484]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:07.484]         }
[18:06:07.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:07.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:07.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:07.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:07.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:07.484]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:07.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:07.484]             base::names(...future.oldOptions))
[18:06:07.484]     }
[18:06:07.484]     if (FALSE) {
[18:06:07.484]     }
[18:06:07.484]     else {
[18:06:07.484]         if (TRUE) {
[18:06:07.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:07.484]                 open = "w")
[18:06:07.484]         }
[18:06:07.484]         else {
[18:06:07.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:07.484]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:07.484]         }
[18:06:07.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:07.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:07.484]             base::sink(type = "output", split = FALSE)
[18:06:07.484]             base::close(...future.stdout)
[18:06:07.484]         }, add = TRUE)
[18:06:07.484]     }
[18:06:07.484]     ...future.frame <- base::sys.nframe()
[18:06:07.484]     ...future.conditions <- base::list()
[18:06:07.484]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:07.484]     if (FALSE) {
[18:06:07.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:07.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:07.484]     }
[18:06:07.484]     ...future.result <- base::tryCatch({
[18:06:07.484]         base::withCallingHandlers({
[18:06:07.484]             ...future.value <- base::withVisible(base::local({
[18:06:07.484]                 withCallingHandlers({
[18:06:07.484]                   {
[18:06:07.484]                     Sys.sleep(0.1)
[18:06:07.484]                     kk
[18:06:07.484]                   }
[18:06:07.484]                 }, immediateCondition = function(cond) {
[18:06:07.484]                   save_rds <- function (object, pathname, ...) 
[18:06:07.484]                   {
[18:06:07.484]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:07.484]                     if (file_test("-f", pathname_tmp)) {
[18:06:07.484]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.484]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:07.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.484]                         fi_tmp[["mtime"]])
[18:06:07.484]                     }
[18:06:07.484]                     tryCatch({
[18:06:07.484]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:07.484]                     }, error = function(ex) {
[18:06:07.484]                       msg <- conditionMessage(ex)
[18:06:07.484]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.484]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:07.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.484]                         fi_tmp[["mtime"]], msg)
[18:06:07.484]                       ex$message <- msg
[18:06:07.484]                       stop(ex)
[18:06:07.484]                     })
[18:06:07.484]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:07.484]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:07.484]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:07.484]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.484]                       fi <- file.info(pathname)
[18:06:07.484]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:07.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.484]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:07.484]                         fi[["size"]], fi[["mtime"]])
[18:06:07.484]                       stop(msg)
[18:06:07.484]                     }
[18:06:07.484]                     invisible(pathname)
[18:06:07.484]                   }
[18:06:07.484]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:07.484]                     rootPath = tempdir()) 
[18:06:07.484]                   {
[18:06:07.484]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:07.484]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:07.484]                       tmpdir = path, fileext = ".rds")
[18:06:07.484]                     save_rds(obj, file)
[18:06:07.484]                   }
[18:06:07.484]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:07.484]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.484]                   {
[18:06:07.484]                     inherits <- base::inherits
[18:06:07.484]                     invokeRestart <- base::invokeRestart
[18:06:07.484]                     is.null <- base::is.null
[18:06:07.484]                     muffled <- FALSE
[18:06:07.484]                     if (inherits(cond, "message")) {
[18:06:07.484]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:07.484]                       if (muffled) 
[18:06:07.484]                         invokeRestart("muffleMessage")
[18:06:07.484]                     }
[18:06:07.484]                     else if (inherits(cond, "warning")) {
[18:06:07.484]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:07.484]                       if (muffled) 
[18:06:07.484]                         invokeRestart("muffleWarning")
[18:06:07.484]                     }
[18:06:07.484]                     else if (inherits(cond, "condition")) {
[18:06:07.484]                       if (!is.null(pattern)) {
[18:06:07.484]                         computeRestarts <- base::computeRestarts
[18:06:07.484]                         grepl <- base::grepl
[18:06:07.484]                         restarts <- computeRestarts(cond)
[18:06:07.484]                         for (restart in restarts) {
[18:06:07.484]                           name <- restart$name
[18:06:07.484]                           if (is.null(name)) 
[18:06:07.484]                             next
[18:06:07.484]                           if (!grepl(pattern, name)) 
[18:06:07.484]                             next
[18:06:07.484]                           invokeRestart(restart)
[18:06:07.484]                           muffled <- TRUE
[18:06:07.484]                           break
[18:06:07.484]                         }
[18:06:07.484]                       }
[18:06:07.484]                     }
[18:06:07.484]                     invisible(muffled)
[18:06:07.484]                   }
[18:06:07.484]                   muffleCondition(cond)
[18:06:07.484]                 })
[18:06:07.484]             }))
[18:06:07.484]             future::FutureResult(value = ...future.value$value, 
[18:06:07.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.484]                   ...future.rng), globalenv = if (FALSE) 
[18:06:07.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:07.484]                     ...future.globalenv.names))
[18:06:07.484]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:07.484]         }, condition = base::local({
[18:06:07.484]             c <- base::c
[18:06:07.484]             inherits <- base::inherits
[18:06:07.484]             invokeRestart <- base::invokeRestart
[18:06:07.484]             length <- base::length
[18:06:07.484]             list <- base::list
[18:06:07.484]             seq.int <- base::seq.int
[18:06:07.484]             signalCondition <- base::signalCondition
[18:06:07.484]             sys.calls <- base::sys.calls
[18:06:07.484]             `[[` <- base::`[[`
[18:06:07.484]             `+` <- base::`+`
[18:06:07.484]             `<<-` <- base::`<<-`
[18:06:07.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:07.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:07.484]                   3L)]
[18:06:07.484]             }
[18:06:07.484]             function(cond) {
[18:06:07.484]                 is_error <- inherits(cond, "error")
[18:06:07.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:07.484]                   NULL)
[18:06:07.484]                 if (is_error) {
[18:06:07.484]                   sessionInformation <- function() {
[18:06:07.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:07.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:07.484]                       search = base::search(), system = base::Sys.info())
[18:06:07.484]                   }
[18:06:07.484]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:07.484]                     cond$call), session = sessionInformation(), 
[18:06:07.484]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:07.484]                   signalCondition(cond)
[18:06:07.484]                 }
[18:06:07.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:07.484]                 "immediateCondition"))) {
[18:06:07.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:07.484]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:07.484]                   if (TRUE && !signal) {
[18:06:07.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.484]                     {
[18:06:07.484]                       inherits <- base::inherits
[18:06:07.484]                       invokeRestart <- base::invokeRestart
[18:06:07.484]                       is.null <- base::is.null
[18:06:07.484]                       muffled <- FALSE
[18:06:07.484]                       if (inherits(cond, "message")) {
[18:06:07.484]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.484]                         if (muffled) 
[18:06:07.484]                           invokeRestart("muffleMessage")
[18:06:07.484]                       }
[18:06:07.484]                       else if (inherits(cond, "warning")) {
[18:06:07.484]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.484]                         if (muffled) 
[18:06:07.484]                           invokeRestart("muffleWarning")
[18:06:07.484]                       }
[18:06:07.484]                       else if (inherits(cond, "condition")) {
[18:06:07.484]                         if (!is.null(pattern)) {
[18:06:07.484]                           computeRestarts <- base::computeRestarts
[18:06:07.484]                           grepl <- base::grepl
[18:06:07.484]                           restarts <- computeRestarts(cond)
[18:06:07.484]                           for (restart in restarts) {
[18:06:07.484]                             name <- restart$name
[18:06:07.484]                             if (is.null(name)) 
[18:06:07.484]                               next
[18:06:07.484]                             if (!grepl(pattern, name)) 
[18:06:07.484]                               next
[18:06:07.484]                             invokeRestart(restart)
[18:06:07.484]                             muffled <- TRUE
[18:06:07.484]                             break
[18:06:07.484]                           }
[18:06:07.484]                         }
[18:06:07.484]                       }
[18:06:07.484]                       invisible(muffled)
[18:06:07.484]                     }
[18:06:07.484]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.484]                   }
[18:06:07.484]                 }
[18:06:07.484]                 else {
[18:06:07.484]                   if (TRUE) {
[18:06:07.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.484]                     {
[18:06:07.484]                       inherits <- base::inherits
[18:06:07.484]                       invokeRestart <- base::invokeRestart
[18:06:07.484]                       is.null <- base::is.null
[18:06:07.484]                       muffled <- FALSE
[18:06:07.484]                       if (inherits(cond, "message")) {
[18:06:07.484]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.484]                         if (muffled) 
[18:06:07.484]                           invokeRestart("muffleMessage")
[18:06:07.484]                       }
[18:06:07.484]                       else if (inherits(cond, "warning")) {
[18:06:07.484]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.484]                         if (muffled) 
[18:06:07.484]                           invokeRestart("muffleWarning")
[18:06:07.484]                       }
[18:06:07.484]                       else if (inherits(cond, "condition")) {
[18:06:07.484]                         if (!is.null(pattern)) {
[18:06:07.484]                           computeRestarts <- base::computeRestarts
[18:06:07.484]                           grepl <- base::grepl
[18:06:07.484]                           restarts <- computeRestarts(cond)
[18:06:07.484]                           for (restart in restarts) {
[18:06:07.484]                             name <- restart$name
[18:06:07.484]                             if (is.null(name)) 
[18:06:07.484]                               next
[18:06:07.484]                             if (!grepl(pattern, name)) 
[18:06:07.484]                               next
[18:06:07.484]                             invokeRestart(restart)
[18:06:07.484]                             muffled <- TRUE
[18:06:07.484]                             break
[18:06:07.484]                           }
[18:06:07.484]                         }
[18:06:07.484]                       }
[18:06:07.484]                       invisible(muffled)
[18:06:07.484]                     }
[18:06:07.484]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.484]                   }
[18:06:07.484]                 }
[18:06:07.484]             }
[18:06:07.484]         }))
[18:06:07.484]     }, error = function(ex) {
[18:06:07.484]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:07.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.484]                 ...future.rng), started = ...future.startTime, 
[18:06:07.484]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:07.484]             version = "1.8"), class = "FutureResult")
[18:06:07.484]     }, finally = {
[18:06:07.484]         if (!identical(...future.workdir, getwd())) 
[18:06:07.484]             setwd(...future.workdir)
[18:06:07.484]         {
[18:06:07.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:07.484]                 ...future.oldOptions$nwarnings <- NULL
[18:06:07.484]             }
[18:06:07.484]             base::options(...future.oldOptions)
[18:06:07.484]             if (.Platform$OS.type == "windows") {
[18:06:07.484]                 old_names <- names(...future.oldEnvVars)
[18:06:07.484]                 envs <- base::Sys.getenv()
[18:06:07.484]                 names <- names(envs)
[18:06:07.484]                 common <- intersect(names, old_names)
[18:06:07.484]                 added <- setdiff(names, old_names)
[18:06:07.484]                 removed <- setdiff(old_names, names)
[18:06:07.484]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:07.484]                   envs[common]]
[18:06:07.484]                 NAMES <- toupper(changed)
[18:06:07.484]                 args <- list()
[18:06:07.484]                 for (kk in seq_along(NAMES)) {
[18:06:07.484]                   name <- changed[[kk]]
[18:06:07.484]                   NAME <- NAMES[[kk]]
[18:06:07.484]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.484]                     next
[18:06:07.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.484]                 }
[18:06:07.484]                 NAMES <- toupper(added)
[18:06:07.484]                 for (kk in seq_along(NAMES)) {
[18:06:07.484]                   name <- added[[kk]]
[18:06:07.484]                   NAME <- NAMES[[kk]]
[18:06:07.484]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.484]                     next
[18:06:07.484]                   args[[name]] <- ""
[18:06:07.484]                 }
[18:06:07.484]                 NAMES <- toupper(removed)
[18:06:07.484]                 for (kk in seq_along(NAMES)) {
[18:06:07.484]                   name <- removed[[kk]]
[18:06:07.484]                   NAME <- NAMES[[kk]]
[18:06:07.484]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.484]                     next
[18:06:07.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.484]                 }
[18:06:07.484]                 if (length(args) > 0) 
[18:06:07.484]                   base::do.call(base::Sys.setenv, args = args)
[18:06:07.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:07.484]             }
[18:06:07.484]             else {
[18:06:07.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:07.484]             }
[18:06:07.484]             {
[18:06:07.484]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:07.484]                   0L) {
[18:06:07.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:07.484]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:07.484]                   base::options(opts)
[18:06:07.484]                 }
[18:06:07.484]                 {
[18:06:07.484]                   {
[18:06:07.484]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:07.484]                     NULL
[18:06:07.484]                   }
[18:06:07.484]                   options(future.plan = NULL)
[18:06:07.484]                   if (is.na(NA_character_)) 
[18:06:07.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:07.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:07.484]                     .init = FALSE)
[18:06:07.484]                 }
[18:06:07.484]             }
[18:06:07.484]         }
[18:06:07.484]     })
[18:06:07.484]     if (TRUE) {
[18:06:07.484]         base::sink(type = "output", split = FALSE)
[18:06:07.484]         if (TRUE) {
[18:06:07.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:07.484]         }
[18:06:07.484]         else {
[18:06:07.484]             ...future.result["stdout"] <- base::list(NULL)
[18:06:07.484]         }
[18:06:07.484]         base::close(...future.stdout)
[18:06:07.484]         ...future.stdout <- NULL
[18:06:07.484]     }
[18:06:07.484]     ...future.result$conditions <- ...future.conditions
[18:06:07.484]     ...future.result$finished <- base::Sys.time()
[18:06:07.484]     ...future.result
[18:06:07.484] }
[18:06:07.491] assign_globals() ...
[18:06:07.491] List of 1
[18:06:07.491]  $ kk: int 2
[18:06:07.491]  - attr(*, "where")=List of 1
[18:06:07.491]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:07.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:07.491]  - attr(*, "resolved")= logi FALSE
[18:06:07.491]  - attr(*, "total_size")= num 56
[18:06:07.491]  - attr(*, "already-done")= logi TRUE
[18:06:07.499] - copied ‘kk’ to environment
[18:06:07.500] assign_globals() ... done
[18:06:07.500] requestCore(): workers = 2
[18:06:07.501] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:07.512] result() for MulticoreFuture ...
[18:06:07.516] result() for MulticoreFuture ...
[18:06:07.516] result() for MulticoreFuture ... done
[18:06:07.517] result() for MulticoreFuture ... done
[18:06:07.517] result() for MulticoreFuture ...
[18:06:07.517] result() for MulticoreFuture ... done
[18:06:07.523] MulticoreFuture started
[18:06:07.524] - Launch lazy future ... done
[18:06:07.525] run() for ‘MulticoreFuture’ ... done
[18:06:07.525] getGlobalsAndPackages() ...
[18:06:07.526] Searching for globals...
[18:06:07.528] plan(): Setting new future strategy stack:
[18:06:07.531] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:07.531] Searching for globals ... DONE
[18:06:07.532] Resolving globals: FALSE
[18:06:07.529] List of future strategies:
[18:06:07.529] 1. sequential:
[18:06:07.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:07.529]    - tweaked: FALSE
[18:06:07.529]    - call: NULL
[18:06:07.533] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:07.535] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:07.535] - globals: [1] ‘kk’
[18:06:07.534] plan(): nbrOfWorkers() = 1
[18:06:07.536] 
[18:06:07.536] getGlobalsAndPackages() ... DONE
[18:06:07.537] run() for ‘Future’ ...
[18:06:07.537] - state: ‘created’
[18:06:07.538] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:07.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:07.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:07.549]   - Field: ‘label’
[18:06:07.549]   - Field: ‘local’
[18:06:07.549]   - Field: ‘owner’
[18:06:07.550]   - Field: ‘envir’
[18:06:07.550]   - Field: ‘workers’
[18:06:07.551]   - Field: ‘packages’
[18:06:07.551]   - Field: ‘gc’
[18:06:07.551]   - Field: ‘job’
[18:06:07.552]   - Field: ‘conditions’
[18:06:07.553]   - Field: ‘expr’
[18:06:07.553]   - Field: ‘uuid’
[18:06:07.553]   - Field: ‘seed’
[18:06:07.561] plan(): Setting new future strategy stack:
[18:06:07.562] List of future strategies:
[18:06:07.562] 1. multicore:
[18:06:07.562]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:07.562]    - tweaked: FALSE
[18:06:07.562]    - call: plan(strategy)
[18:06:07.561]   - Field: ‘version’
[18:06:07.564]   - Field: ‘result’
[18:06:07.565]   - Field: ‘asynchronous’
[18:06:07.567]   - Field: ‘calls’
[18:06:07.568]   - Field: ‘globals’
[18:06:07.568]   - Field: ‘stdout’
[18:06:07.569]   - Field: ‘earlySignal’
[18:06:07.569]   - Field: ‘lazy’
[18:06:07.572]   - Field: ‘state’
[18:06:07.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:07.576] plan(): nbrOfWorkers() = 2
[18:06:07.574] - Launch lazy future ...
[18:06:07.578] Packages needed by the future expression (n = 0): <none>
[18:06:07.579] Packages needed by future strategies (n = 0): <none>
[18:06:07.581] {
[18:06:07.581]     {
[18:06:07.581]         {
[18:06:07.581]             ...future.startTime <- base::Sys.time()
[18:06:07.581]             {
[18:06:07.581]                 {
[18:06:07.581]                   {
[18:06:07.581]                     {
[18:06:07.581]                       base::local({
[18:06:07.581]                         has_future <- base::requireNamespace("future", 
[18:06:07.581]                           quietly = TRUE)
[18:06:07.581]                         if (has_future) {
[18:06:07.581]                           ns <- base::getNamespace("future")
[18:06:07.581]                           version <- ns[[".package"]][["version"]]
[18:06:07.581]                           if (is.null(version)) 
[18:06:07.581]                             version <- utils::packageVersion("future")
[18:06:07.581]                         }
[18:06:07.581]                         else {
[18:06:07.581]                           version <- NULL
[18:06:07.581]                         }
[18:06:07.581]                         if (!has_future || version < "1.8.0") {
[18:06:07.581]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:07.581]                             "", base::R.version$version.string), 
[18:06:07.581]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:07.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:07.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:07.581]                               "release", "version")], collapse = " "), 
[18:06:07.581]                             hostname = base::Sys.info()[["nodename"]])
[18:06:07.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:07.581]                             info)
[18:06:07.581]                           info <- base::paste(info, collapse = "; ")
[18:06:07.581]                           if (!has_future) {
[18:06:07.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:07.581]                               info)
[18:06:07.581]                           }
[18:06:07.581]                           else {
[18:06:07.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:07.581]                               info, version)
[18:06:07.581]                           }
[18:06:07.581]                           base::stop(msg)
[18:06:07.581]                         }
[18:06:07.581]                       })
[18:06:07.581]                     }
[18:06:07.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:07.581]                     base::options(mc.cores = 1L)
[18:06:07.581]                   }
[18:06:07.581]                   ...future.strategy.old <- future::plan("list")
[18:06:07.581]                   options(future.plan = NULL)
[18:06:07.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:07.581]                 }
[18:06:07.581]                 ...future.workdir <- getwd()
[18:06:07.581]             }
[18:06:07.581]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:07.581]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:07.581]         }
[18:06:07.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:07.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:07.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:07.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:07.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:07.581]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:07.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:07.581]             base::names(...future.oldOptions))
[18:06:07.581]     }
[18:06:07.581]     if (FALSE) {
[18:06:07.581]     }
[18:06:07.581]     else {
[18:06:07.581]         if (TRUE) {
[18:06:07.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:07.581]                 open = "w")
[18:06:07.581]         }
[18:06:07.581]         else {
[18:06:07.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:07.581]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:07.581]         }
[18:06:07.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:07.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:07.581]             base::sink(type = "output", split = FALSE)
[18:06:07.581]             base::close(...future.stdout)
[18:06:07.581]         }, add = TRUE)
[18:06:07.581]     }
[18:06:07.581]     ...future.frame <- base::sys.nframe()
[18:06:07.581]     ...future.conditions <- base::list()
[18:06:07.581]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:07.581]     if (FALSE) {
[18:06:07.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:07.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:07.581]     }
[18:06:07.581]     ...future.result <- base::tryCatch({
[18:06:07.581]         base::withCallingHandlers({
[18:06:07.581]             ...future.value <- base::withVisible(base::local({
[18:06:07.581]                 withCallingHandlers({
[18:06:07.581]                   {
[18:06:07.581]                     Sys.sleep(0.1)
[18:06:07.581]                     kk
[18:06:07.581]                   }
[18:06:07.581]                 }, immediateCondition = function(cond) {
[18:06:07.581]                   save_rds <- function (object, pathname, ...) 
[18:06:07.581]                   {
[18:06:07.581]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:07.581]                     if (file_test("-f", pathname_tmp)) {
[18:06:07.581]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.581]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:07.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.581]                         fi_tmp[["mtime"]])
[18:06:07.581]                     }
[18:06:07.581]                     tryCatch({
[18:06:07.581]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:07.581]                     }, error = function(ex) {
[18:06:07.581]                       msg <- conditionMessage(ex)
[18:06:07.581]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.581]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:07.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.581]                         fi_tmp[["mtime"]], msg)
[18:06:07.581]                       ex$message <- msg
[18:06:07.581]                       stop(ex)
[18:06:07.581]                     })
[18:06:07.581]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:07.581]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:07.581]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:07.581]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.581]                       fi <- file.info(pathname)
[18:06:07.581]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:07.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.581]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:07.581]                         fi[["size"]], fi[["mtime"]])
[18:06:07.581]                       stop(msg)
[18:06:07.581]                     }
[18:06:07.581]                     invisible(pathname)
[18:06:07.581]                   }
[18:06:07.581]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:07.581]                     rootPath = tempdir()) 
[18:06:07.581]                   {
[18:06:07.581]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:07.581]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:07.581]                       tmpdir = path, fileext = ".rds")
[18:06:07.581]                     save_rds(obj, file)
[18:06:07.581]                   }
[18:06:07.581]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:07.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.581]                   {
[18:06:07.581]                     inherits <- base::inherits
[18:06:07.581]                     invokeRestart <- base::invokeRestart
[18:06:07.581]                     is.null <- base::is.null
[18:06:07.581]                     muffled <- FALSE
[18:06:07.581]                     if (inherits(cond, "message")) {
[18:06:07.581]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:07.581]                       if (muffled) 
[18:06:07.581]                         invokeRestart("muffleMessage")
[18:06:07.581]                     }
[18:06:07.581]                     else if (inherits(cond, "warning")) {
[18:06:07.581]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:07.581]                       if (muffled) 
[18:06:07.581]                         invokeRestart("muffleWarning")
[18:06:07.581]                     }
[18:06:07.581]                     else if (inherits(cond, "condition")) {
[18:06:07.581]                       if (!is.null(pattern)) {
[18:06:07.581]                         computeRestarts <- base::computeRestarts
[18:06:07.581]                         grepl <- base::grepl
[18:06:07.581]                         restarts <- computeRestarts(cond)
[18:06:07.581]                         for (restart in restarts) {
[18:06:07.581]                           name <- restart$name
[18:06:07.581]                           if (is.null(name)) 
[18:06:07.581]                             next
[18:06:07.581]                           if (!grepl(pattern, name)) 
[18:06:07.581]                             next
[18:06:07.581]                           invokeRestart(restart)
[18:06:07.581]                           muffled <- TRUE
[18:06:07.581]                           break
[18:06:07.581]                         }
[18:06:07.581]                       }
[18:06:07.581]                     }
[18:06:07.581]                     invisible(muffled)
[18:06:07.581]                   }
[18:06:07.581]                   muffleCondition(cond)
[18:06:07.581]                 })
[18:06:07.581]             }))
[18:06:07.581]             future::FutureResult(value = ...future.value$value, 
[18:06:07.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.581]                   ...future.rng), globalenv = if (FALSE) 
[18:06:07.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:07.581]                     ...future.globalenv.names))
[18:06:07.581]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:07.581]         }, condition = base::local({
[18:06:07.581]             c <- base::c
[18:06:07.581]             inherits <- base::inherits
[18:06:07.581]             invokeRestart <- base::invokeRestart
[18:06:07.581]             length <- base::length
[18:06:07.581]             list <- base::list
[18:06:07.581]             seq.int <- base::seq.int
[18:06:07.581]             signalCondition <- base::signalCondition
[18:06:07.581]             sys.calls <- base::sys.calls
[18:06:07.581]             `[[` <- base::`[[`
[18:06:07.581]             `+` <- base::`+`
[18:06:07.581]             `<<-` <- base::`<<-`
[18:06:07.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:07.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:07.581]                   3L)]
[18:06:07.581]             }
[18:06:07.581]             function(cond) {
[18:06:07.581]                 is_error <- inherits(cond, "error")
[18:06:07.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:07.581]                   NULL)
[18:06:07.581]                 if (is_error) {
[18:06:07.581]                   sessionInformation <- function() {
[18:06:07.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:07.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:07.581]                       search = base::search(), system = base::Sys.info())
[18:06:07.581]                   }
[18:06:07.581]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:07.581]                     cond$call), session = sessionInformation(), 
[18:06:07.581]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:07.581]                   signalCondition(cond)
[18:06:07.581]                 }
[18:06:07.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:07.581]                 "immediateCondition"))) {
[18:06:07.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:07.581]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:07.581]                   if (TRUE && !signal) {
[18:06:07.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.581]                     {
[18:06:07.581]                       inherits <- base::inherits
[18:06:07.581]                       invokeRestart <- base::invokeRestart
[18:06:07.581]                       is.null <- base::is.null
[18:06:07.581]                       muffled <- FALSE
[18:06:07.581]                       if (inherits(cond, "message")) {
[18:06:07.581]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.581]                         if (muffled) 
[18:06:07.581]                           invokeRestart("muffleMessage")
[18:06:07.581]                       }
[18:06:07.581]                       else if (inherits(cond, "warning")) {
[18:06:07.581]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.581]                         if (muffled) 
[18:06:07.581]                           invokeRestart("muffleWarning")
[18:06:07.581]                       }
[18:06:07.581]                       else if (inherits(cond, "condition")) {
[18:06:07.581]                         if (!is.null(pattern)) {
[18:06:07.581]                           computeRestarts <- base::computeRestarts
[18:06:07.581]                           grepl <- base::grepl
[18:06:07.581]                           restarts <- computeRestarts(cond)
[18:06:07.581]                           for (restart in restarts) {
[18:06:07.581]                             name <- restart$name
[18:06:07.581]                             if (is.null(name)) 
[18:06:07.581]                               next
[18:06:07.581]                             if (!grepl(pattern, name)) 
[18:06:07.581]                               next
[18:06:07.581]                             invokeRestart(restart)
[18:06:07.581]                             muffled <- TRUE
[18:06:07.581]                             break
[18:06:07.581]                           }
[18:06:07.581]                         }
[18:06:07.581]                       }
[18:06:07.581]                       invisible(muffled)
[18:06:07.581]                     }
[18:06:07.581]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.581]                   }
[18:06:07.581]                 }
[18:06:07.581]                 else {
[18:06:07.581]                   if (TRUE) {
[18:06:07.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.581]                     {
[18:06:07.581]                       inherits <- base::inherits
[18:06:07.581]                       invokeRestart <- base::invokeRestart
[18:06:07.581]                       is.null <- base::is.null
[18:06:07.581]                       muffled <- FALSE
[18:06:07.581]                       if (inherits(cond, "message")) {
[18:06:07.581]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.581]                         if (muffled) 
[18:06:07.581]                           invokeRestart("muffleMessage")
[18:06:07.581]                       }
[18:06:07.581]                       else if (inherits(cond, "warning")) {
[18:06:07.581]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.581]                         if (muffled) 
[18:06:07.581]                           invokeRestart("muffleWarning")
[18:06:07.581]                       }
[18:06:07.581]                       else if (inherits(cond, "condition")) {
[18:06:07.581]                         if (!is.null(pattern)) {
[18:06:07.581]                           computeRestarts <- base::computeRestarts
[18:06:07.581]                           grepl <- base::grepl
[18:06:07.581]                           restarts <- computeRestarts(cond)
[18:06:07.581]                           for (restart in restarts) {
[18:06:07.581]                             name <- restart$name
[18:06:07.581]                             if (is.null(name)) 
[18:06:07.581]                               next
[18:06:07.581]                             if (!grepl(pattern, name)) 
[18:06:07.581]                               next
[18:06:07.581]                             invokeRestart(restart)
[18:06:07.581]                             muffled <- TRUE
[18:06:07.581]                             break
[18:06:07.581]                           }
[18:06:07.581]                         }
[18:06:07.581]                       }
[18:06:07.581]                       invisible(muffled)
[18:06:07.581]                     }
[18:06:07.581]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.581]                   }
[18:06:07.581]                 }
[18:06:07.581]             }
[18:06:07.581]         }))
[18:06:07.581]     }, error = function(ex) {
[18:06:07.581]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:07.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.581]                 ...future.rng), started = ...future.startTime, 
[18:06:07.581]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:07.581]             version = "1.8"), class = "FutureResult")
[18:06:07.581]     }, finally = {
[18:06:07.581]         if (!identical(...future.workdir, getwd())) 
[18:06:07.581]             setwd(...future.workdir)
[18:06:07.581]         {
[18:06:07.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:07.581]                 ...future.oldOptions$nwarnings <- NULL
[18:06:07.581]             }
[18:06:07.581]             base::options(...future.oldOptions)
[18:06:07.581]             if (.Platform$OS.type == "windows") {
[18:06:07.581]                 old_names <- names(...future.oldEnvVars)
[18:06:07.581]                 envs <- base::Sys.getenv()
[18:06:07.581]                 names <- names(envs)
[18:06:07.581]                 common <- intersect(names, old_names)
[18:06:07.581]                 added <- setdiff(names, old_names)
[18:06:07.581]                 removed <- setdiff(old_names, names)
[18:06:07.581]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:07.581]                   envs[common]]
[18:06:07.581]                 NAMES <- toupper(changed)
[18:06:07.581]                 args <- list()
[18:06:07.581]                 for (kk in seq_along(NAMES)) {
[18:06:07.581]                   name <- changed[[kk]]
[18:06:07.581]                   NAME <- NAMES[[kk]]
[18:06:07.581]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.581]                     next
[18:06:07.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.581]                 }
[18:06:07.581]                 NAMES <- toupper(added)
[18:06:07.581]                 for (kk in seq_along(NAMES)) {
[18:06:07.581]                   name <- added[[kk]]
[18:06:07.581]                   NAME <- NAMES[[kk]]
[18:06:07.581]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.581]                     next
[18:06:07.581]                   args[[name]] <- ""
[18:06:07.581]                 }
[18:06:07.581]                 NAMES <- toupper(removed)
[18:06:07.581]                 for (kk in seq_along(NAMES)) {
[18:06:07.581]                   name <- removed[[kk]]
[18:06:07.581]                   NAME <- NAMES[[kk]]
[18:06:07.581]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.581]                     next
[18:06:07.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.581]                 }
[18:06:07.581]                 if (length(args) > 0) 
[18:06:07.581]                   base::do.call(base::Sys.setenv, args = args)
[18:06:07.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:07.581]             }
[18:06:07.581]             else {
[18:06:07.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:07.581]             }
[18:06:07.581]             {
[18:06:07.581]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:07.581]                   0L) {
[18:06:07.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:07.581]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:07.581]                   base::options(opts)
[18:06:07.581]                 }
[18:06:07.581]                 {
[18:06:07.581]                   {
[18:06:07.581]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:07.581]                     NULL
[18:06:07.581]                   }
[18:06:07.581]                   options(future.plan = NULL)
[18:06:07.581]                   if (is.na(NA_character_)) 
[18:06:07.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:07.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:07.581]                     .init = FALSE)
[18:06:07.581]                 }
[18:06:07.581]             }
[18:06:07.581]         }
[18:06:07.581]     })
[18:06:07.581]     if (TRUE) {
[18:06:07.581]         base::sink(type = "output", split = FALSE)
[18:06:07.581]         if (TRUE) {
[18:06:07.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:07.581]         }
[18:06:07.581]         else {
[18:06:07.581]             ...future.result["stdout"] <- base::list(NULL)
[18:06:07.581]         }
[18:06:07.581]         base::close(...future.stdout)
[18:06:07.581]         ...future.stdout <- NULL
[18:06:07.581]     }
[18:06:07.581]     ...future.result$conditions <- ...future.conditions
[18:06:07.581]     ...future.result$finished <- base::Sys.time()
[18:06:07.581]     ...future.result
[18:06:07.581] }
[18:06:07.586] assign_globals() ...
[18:06:07.587] List of 1
[18:06:07.587]  $ kk: int 3
[18:06:07.587]  - attr(*, "where")=List of 1
[18:06:07.587]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:07.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:07.587]  - attr(*, "resolved")= logi FALSE
[18:06:07.587]  - attr(*, "total_size")= num 56
[18:06:07.587]  - attr(*, "already-done")= logi TRUE
[18:06:07.596] - copied ‘kk’ to environment
[18:06:07.596] assign_globals() ... done
[18:06:07.596] requestCore(): workers = 2
[18:06:07.597] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:07.609] result() for MulticoreFuture ...
[18:06:07.610] result() for MulticoreFuture ...
[18:06:07.611] result() for MulticoreFuture ... done
[18:06:07.611] result() for MulticoreFuture ... done
[18:06:07.611] result() for MulticoreFuture ...
[18:06:07.611] result() for MulticoreFuture ... done
[18:06:07.615] MulticoreFuture started
[18:06:07.616] - Launch lazy future ... done
[18:06:07.617] run() for ‘MulticoreFuture’ ... done
[18:06:07.618] resolve() on list ...
[18:06:07.618]  recursive: 0
[18:06:07.619]  length: 3
[18:06:07.619] 
[18:06:07.620] Future #1
[18:06:07.620]  length: 2 (resolved future 1)
[18:06:07.622] plan(): Setting new future strategy stack:
[18:06:07.622] List of future strategies:
[18:06:07.622] 1. sequential:
[18:06:07.622]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:07.622]    - tweaked: FALSE
[18:06:07.622]    - call: NULL
[18:06:07.625] plan(): nbrOfWorkers() = 1
[18:06:07.642] plan(): Setting new future strategy stack:
[18:06:07.642] List of future strategies:
[18:06:07.642] 1. multicore:
[18:06:07.642]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:07.642]    - tweaked: FALSE
[18:06:07.642]    - call: plan(strategy)
[18:06:07.649] plan(): nbrOfWorkers() = 2
[18:06:07.653] Future #2
[18:06:07.653]  length: 1 (resolved future 2)
[18:06:07.731] plan(): Setting new future strategy stack:
[18:06:07.731] List of future strategies:
[18:06:07.731] 1. multicore:
[18:06:07.731]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:07.731]    - tweaked: FALSE
[18:06:07.731]    - call: plan(strategy)
[18:06:07.744] plan(): nbrOfWorkers() = 2
[18:06:07.745] Future #3
[18:06:07.745]  length: 0 (resolved future 3)
[18:06:07.746] resolve() on list ... DONE
[18:06:07.746] getGlobalsAndPackages() ...
[18:06:07.746] Searching for globals...
[18:06:07.751] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:07.751] Searching for globals ... DONE
[18:06:07.752] Resolving globals: FALSE
[18:06:07.753] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:07.754] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:07.754] - globals: [1] ‘kk’
[18:06:07.755] 
[18:06:07.755] getGlobalsAndPackages() ... DONE
[18:06:07.756] getGlobalsAndPackages() ...
[18:06:07.756] Searching for globals...
[18:06:07.760] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:07.760] Searching for globals ... DONE
[18:06:07.760] Resolving globals: FALSE
[18:06:07.761] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:07.762] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:07.763] - globals: [1] ‘kk’
[18:06:07.763] 
[18:06:07.763] getGlobalsAndPackages() ... DONE
[18:06:07.764] getGlobalsAndPackages() ...
[18:06:07.764] Searching for globals...
[18:06:07.767] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:07.768] Searching for globals ... DONE
[18:06:07.768] Resolving globals: FALSE
[18:06:07.769] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:07.770] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:07.770] - globals: [1] ‘kk’
[18:06:07.771] 
[18:06:07.771] getGlobalsAndPackages() ... DONE
[18:06:07.771] resolve() on list ...
[18:06:07.772]  recursive: 0
[18:06:07.772]  length: 3
[18:06:07.772] 
[18:06:07.773] run() for ‘Future’ ...
[18:06:07.773] - state: ‘created’
[18:06:07.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:07.781] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:07.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:07.782]   - Field: ‘label’
[18:06:07.782]   - Field: ‘local’
[18:06:07.783]   - Field: ‘owner’
[18:06:07.783]   - Field: ‘envir’
[18:06:07.783]   - Field: ‘workers’
[18:06:07.784]   - Field: ‘packages’
[18:06:07.784]   - Field: ‘gc’
[18:06:07.784]   - Field: ‘job’
[18:06:07.785]   - Field: ‘conditions’
[18:06:07.785]   - Field: ‘expr’
[18:06:07.785]   - Field: ‘uuid’
[18:06:07.785]   - Field: ‘seed’
[18:06:07.786]   - Field: ‘version’
[18:06:07.786]   - Field: ‘result’
[18:06:07.786]   - Field: ‘asynchronous’
[18:06:07.787]   - Field: ‘calls’
[18:06:07.787]   - Field: ‘globals’
[18:06:07.787]   - Field: ‘stdout’
[18:06:07.787]   - Field: ‘earlySignal’
[18:06:07.788]   - Field: ‘lazy’
[18:06:07.788]   - Field: ‘state’
[18:06:07.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:07.789] - Launch lazy future ...
[18:06:07.789] Packages needed by the future expression (n = 0): <none>
[18:06:07.790] Packages needed by future strategies (n = 0): <none>
[18:06:07.791] {
[18:06:07.791]     {
[18:06:07.791]         {
[18:06:07.791]             ...future.startTime <- base::Sys.time()
[18:06:07.791]             {
[18:06:07.791]                 {
[18:06:07.791]                   {
[18:06:07.791]                     {
[18:06:07.791]                       base::local({
[18:06:07.791]                         has_future <- base::requireNamespace("future", 
[18:06:07.791]                           quietly = TRUE)
[18:06:07.791]                         if (has_future) {
[18:06:07.791]                           ns <- base::getNamespace("future")
[18:06:07.791]                           version <- ns[[".package"]][["version"]]
[18:06:07.791]                           if (is.null(version)) 
[18:06:07.791]                             version <- utils::packageVersion("future")
[18:06:07.791]                         }
[18:06:07.791]                         else {
[18:06:07.791]                           version <- NULL
[18:06:07.791]                         }
[18:06:07.791]                         if (!has_future || version < "1.8.0") {
[18:06:07.791]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:07.791]                             "", base::R.version$version.string), 
[18:06:07.791]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:07.791]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:07.791]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:07.791]                               "release", "version")], collapse = " "), 
[18:06:07.791]                             hostname = base::Sys.info()[["nodename"]])
[18:06:07.791]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:07.791]                             info)
[18:06:07.791]                           info <- base::paste(info, collapse = "; ")
[18:06:07.791]                           if (!has_future) {
[18:06:07.791]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:07.791]                               info)
[18:06:07.791]                           }
[18:06:07.791]                           else {
[18:06:07.791]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:07.791]                               info, version)
[18:06:07.791]                           }
[18:06:07.791]                           base::stop(msg)
[18:06:07.791]                         }
[18:06:07.791]                       })
[18:06:07.791]                     }
[18:06:07.791]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:07.791]                     base::options(mc.cores = 1L)
[18:06:07.791]                   }
[18:06:07.791]                   ...future.strategy.old <- future::plan("list")
[18:06:07.791]                   options(future.plan = NULL)
[18:06:07.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:07.791]                 }
[18:06:07.791]                 ...future.workdir <- getwd()
[18:06:07.791]             }
[18:06:07.791]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:07.791]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:07.791]         }
[18:06:07.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:07.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:07.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:07.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:07.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:07.791]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:07.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:07.791]             base::names(...future.oldOptions))
[18:06:07.791]     }
[18:06:07.791]     if (FALSE) {
[18:06:07.791]     }
[18:06:07.791]     else {
[18:06:07.791]         if (TRUE) {
[18:06:07.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:07.791]                 open = "w")
[18:06:07.791]         }
[18:06:07.791]         else {
[18:06:07.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:07.791]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:07.791]         }
[18:06:07.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:07.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:07.791]             base::sink(type = "output", split = FALSE)
[18:06:07.791]             base::close(...future.stdout)
[18:06:07.791]         }, add = TRUE)
[18:06:07.791]     }
[18:06:07.791]     ...future.frame <- base::sys.nframe()
[18:06:07.791]     ...future.conditions <- base::list()
[18:06:07.791]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:07.791]     if (FALSE) {
[18:06:07.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:07.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:07.791]     }
[18:06:07.791]     ...future.result <- base::tryCatch({
[18:06:07.791]         base::withCallingHandlers({
[18:06:07.791]             ...future.value <- base::withVisible(base::local({
[18:06:07.791]                 withCallingHandlers({
[18:06:07.791]                   {
[18:06:07.791]                     Sys.sleep(0.1)
[18:06:07.791]                     kk
[18:06:07.791]                   }
[18:06:07.791]                 }, immediateCondition = function(cond) {
[18:06:07.791]                   save_rds <- function (object, pathname, ...) 
[18:06:07.791]                   {
[18:06:07.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:07.791]                     if (file_test("-f", pathname_tmp)) {
[18:06:07.791]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:07.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.791]                         fi_tmp[["mtime"]])
[18:06:07.791]                     }
[18:06:07.791]                     tryCatch({
[18:06:07.791]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:07.791]                     }, error = function(ex) {
[18:06:07.791]                       msg <- conditionMessage(ex)
[18:06:07.791]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:07.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.791]                         fi_tmp[["mtime"]], msg)
[18:06:07.791]                       ex$message <- msg
[18:06:07.791]                       stop(ex)
[18:06:07.791]                     })
[18:06:07.791]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:07.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:07.791]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:07.791]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.791]                       fi <- file.info(pathname)
[18:06:07.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:07.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:07.791]                         fi[["size"]], fi[["mtime"]])
[18:06:07.791]                       stop(msg)
[18:06:07.791]                     }
[18:06:07.791]                     invisible(pathname)
[18:06:07.791]                   }
[18:06:07.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:07.791]                     rootPath = tempdir()) 
[18:06:07.791]                   {
[18:06:07.791]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:07.791]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:07.791]                       tmpdir = path, fileext = ".rds")
[18:06:07.791]                     save_rds(obj, file)
[18:06:07.791]                   }
[18:06:07.791]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:07.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.791]                   {
[18:06:07.791]                     inherits <- base::inherits
[18:06:07.791]                     invokeRestart <- base::invokeRestart
[18:06:07.791]                     is.null <- base::is.null
[18:06:07.791]                     muffled <- FALSE
[18:06:07.791]                     if (inherits(cond, "message")) {
[18:06:07.791]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:07.791]                       if (muffled) 
[18:06:07.791]                         invokeRestart("muffleMessage")
[18:06:07.791]                     }
[18:06:07.791]                     else if (inherits(cond, "warning")) {
[18:06:07.791]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:07.791]                       if (muffled) 
[18:06:07.791]                         invokeRestart("muffleWarning")
[18:06:07.791]                     }
[18:06:07.791]                     else if (inherits(cond, "condition")) {
[18:06:07.791]                       if (!is.null(pattern)) {
[18:06:07.791]                         computeRestarts <- base::computeRestarts
[18:06:07.791]                         grepl <- base::grepl
[18:06:07.791]                         restarts <- computeRestarts(cond)
[18:06:07.791]                         for (restart in restarts) {
[18:06:07.791]                           name <- restart$name
[18:06:07.791]                           if (is.null(name)) 
[18:06:07.791]                             next
[18:06:07.791]                           if (!grepl(pattern, name)) 
[18:06:07.791]                             next
[18:06:07.791]                           invokeRestart(restart)
[18:06:07.791]                           muffled <- TRUE
[18:06:07.791]                           break
[18:06:07.791]                         }
[18:06:07.791]                       }
[18:06:07.791]                     }
[18:06:07.791]                     invisible(muffled)
[18:06:07.791]                   }
[18:06:07.791]                   muffleCondition(cond)
[18:06:07.791]                 })
[18:06:07.791]             }))
[18:06:07.791]             future::FutureResult(value = ...future.value$value, 
[18:06:07.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.791]                   ...future.rng), globalenv = if (FALSE) 
[18:06:07.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:07.791]                     ...future.globalenv.names))
[18:06:07.791]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:07.791]         }, condition = base::local({
[18:06:07.791]             c <- base::c
[18:06:07.791]             inherits <- base::inherits
[18:06:07.791]             invokeRestart <- base::invokeRestart
[18:06:07.791]             length <- base::length
[18:06:07.791]             list <- base::list
[18:06:07.791]             seq.int <- base::seq.int
[18:06:07.791]             signalCondition <- base::signalCondition
[18:06:07.791]             sys.calls <- base::sys.calls
[18:06:07.791]             `[[` <- base::`[[`
[18:06:07.791]             `+` <- base::`+`
[18:06:07.791]             `<<-` <- base::`<<-`
[18:06:07.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:07.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:07.791]                   3L)]
[18:06:07.791]             }
[18:06:07.791]             function(cond) {
[18:06:07.791]                 is_error <- inherits(cond, "error")
[18:06:07.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:07.791]                   NULL)
[18:06:07.791]                 if (is_error) {
[18:06:07.791]                   sessionInformation <- function() {
[18:06:07.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:07.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:07.791]                       search = base::search(), system = base::Sys.info())
[18:06:07.791]                   }
[18:06:07.791]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:07.791]                     cond$call), session = sessionInformation(), 
[18:06:07.791]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:07.791]                   signalCondition(cond)
[18:06:07.791]                 }
[18:06:07.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:07.791]                 "immediateCondition"))) {
[18:06:07.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:07.791]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:07.791]                   if (TRUE && !signal) {
[18:06:07.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.791]                     {
[18:06:07.791]                       inherits <- base::inherits
[18:06:07.791]                       invokeRestart <- base::invokeRestart
[18:06:07.791]                       is.null <- base::is.null
[18:06:07.791]                       muffled <- FALSE
[18:06:07.791]                       if (inherits(cond, "message")) {
[18:06:07.791]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.791]                         if (muffled) 
[18:06:07.791]                           invokeRestart("muffleMessage")
[18:06:07.791]                       }
[18:06:07.791]                       else if (inherits(cond, "warning")) {
[18:06:07.791]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.791]                         if (muffled) 
[18:06:07.791]                           invokeRestart("muffleWarning")
[18:06:07.791]                       }
[18:06:07.791]                       else if (inherits(cond, "condition")) {
[18:06:07.791]                         if (!is.null(pattern)) {
[18:06:07.791]                           computeRestarts <- base::computeRestarts
[18:06:07.791]                           grepl <- base::grepl
[18:06:07.791]                           restarts <- computeRestarts(cond)
[18:06:07.791]                           for (restart in restarts) {
[18:06:07.791]                             name <- restart$name
[18:06:07.791]                             if (is.null(name)) 
[18:06:07.791]                               next
[18:06:07.791]                             if (!grepl(pattern, name)) 
[18:06:07.791]                               next
[18:06:07.791]                             invokeRestart(restart)
[18:06:07.791]                             muffled <- TRUE
[18:06:07.791]                             break
[18:06:07.791]                           }
[18:06:07.791]                         }
[18:06:07.791]                       }
[18:06:07.791]                       invisible(muffled)
[18:06:07.791]                     }
[18:06:07.791]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.791]                   }
[18:06:07.791]                 }
[18:06:07.791]                 else {
[18:06:07.791]                   if (TRUE) {
[18:06:07.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.791]                     {
[18:06:07.791]                       inherits <- base::inherits
[18:06:07.791]                       invokeRestart <- base::invokeRestart
[18:06:07.791]                       is.null <- base::is.null
[18:06:07.791]                       muffled <- FALSE
[18:06:07.791]                       if (inherits(cond, "message")) {
[18:06:07.791]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.791]                         if (muffled) 
[18:06:07.791]                           invokeRestart("muffleMessage")
[18:06:07.791]                       }
[18:06:07.791]                       else if (inherits(cond, "warning")) {
[18:06:07.791]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.791]                         if (muffled) 
[18:06:07.791]                           invokeRestart("muffleWarning")
[18:06:07.791]                       }
[18:06:07.791]                       else if (inherits(cond, "condition")) {
[18:06:07.791]                         if (!is.null(pattern)) {
[18:06:07.791]                           computeRestarts <- base::computeRestarts
[18:06:07.791]                           grepl <- base::grepl
[18:06:07.791]                           restarts <- computeRestarts(cond)
[18:06:07.791]                           for (restart in restarts) {
[18:06:07.791]                             name <- restart$name
[18:06:07.791]                             if (is.null(name)) 
[18:06:07.791]                               next
[18:06:07.791]                             if (!grepl(pattern, name)) 
[18:06:07.791]                               next
[18:06:07.791]                             invokeRestart(restart)
[18:06:07.791]                             muffled <- TRUE
[18:06:07.791]                             break
[18:06:07.791]                           }
[18:06:07.791]                         }
[18:06:07.791]                       }
[18:06:07.791]                       invisible(muffled)
[18:06:07.791]                     }
[18:06:07.791]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.791]                   }
[18:06:07.791]                 }
[18:06:07.791]             }
[18:06:07.791]         }))
[18:06:07.791]     }, error = function(ex) {
[18:06:07.791]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:07.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.791]                 ...future.rng), started = ...future.startTime, 
[18:06:07.791]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:07.791]             version = "1.8"), class = "FutureResult")
[18:06:07.791]     }, finally = {
[18:06:07.791]         if (!identical(...future.workdir, getwd())) 
[18:06:07.791]             setwd(...future.workdir)
[18:06:07.791]         {
[18:06:07.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:07.791]                 ...future.oldOptions$nwarnings <- NULL
[18:06:07.791]             }
[18:06:07.791]             base::options(...future.oldOptions)
[18:06:07.791]             if (.Platform$OS.type == "windows") {
[18:06:07.791]                 old_names <- names(...future.oldEnvVars)
[18:06:07.791]                 envs <- base::Sys.getenv()
[18:06:07.791]                 names <- names(envs)
[18:06:07.791]                 common <- intersect(names, old_names)
[18:06:07.791]                 added <- setdiff(names, old_names)
[18:06:07.791]                 removed <- setdiff(old_names, names)
[18:06:07.791]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:07.791]                   envs[common]]
[18:06:07.791]                 NAMES <- toupper(changed)
[18:06:07.791]                 args <- list()
[18:06:07.791]                 for (kk in seq_along(NAMES)) {
[18:06:07.791]                   name <- changed[[kk]]
[18:06:07.791]                   NAME <- NAMES[[kk]]
[18:06:07.791]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.791]                     next
[18:06:07.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.791]                 }
[18:06:07.791]                 NAMES <- toupper(added)
[18:06:07.791]                 for (kk in seq_along(NAMES)) {
[18:06:07.791]                   name <- added[[kk]]
[18:06:07.791]                   NAME <- NAMES[[kk]]
[18:06:07.791]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.791]                     next
[18:06:07.791]                   args[[name]] <- ""
[18:06:07.791]                 }
[18:06:07.791]                 NAMES <- toupper(removed)
[18:06:07.791]                 for (kk in seq_along(NAMES)) {
[18:06:07.791]                   name <- removed[[kk]]
[18:06:07.791]                   NAME <- NAMES[[kk]]
[18:06:07.791]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.791]                     next
[18:06:07.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.791]                 }
[18:06:07.791]                 if (length(args) > 0) 
[18:06:07.791]                   base::do.call(base::Sys.setenv, args = args)
[18:06:07.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:07.791]             }
[18:06:07.791]             else {
[18:06:07.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:07.791]             }
[18:06:07.791]             {
[18:06:07.791]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:07.791]                   0L) {
[18:06:07.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:07.791]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:07.791]                   base::options(opts)
[18:06:07.791]                 }
[18:06:07.791]                 {
[18:06:07.791]                   {
[18:06:07.791]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:07.791]                     NULL
[18:06:07.791]                   }
[18:06:07.791]                   options(future.plan = NULL)
[18:06:07.791]                   if (is.na(NA_character_)) 
[18:06:07.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:07.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:07.791]                     .init = FALSE)
[18:06:07.791]                 }
[18:06:07.791]             }
[18:06:07.791]         }
[18:06:07.791]     })
[18:06:07.791]     if (TRUE) {
[18:06:07.791]         base::sink(type = "output", split = FALSE)
[18:06:07.791]         if (TRUE) {
[18:06:07.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:07.791]         }
[18:06:07.791]         else {
[18:06:07.791]             ...future.result["stdout"] <- base::list(NULL)
[18:06:07.791]         }
[18:06:07.791]         base::close(...future.stdout)
[18:06:07.791]         ...future.stdout <- NULL
[18:06:07.791]     }
[18:06:07.791]     ...future.result$conditions <- ...future.conditions
[18:06:07.791]     ...future.result$finished <- base::Sys.time()
[18:06:07.791]     ...future.result
[18:06:07.791] }
[18:06:07.797] assign_globals() ...
[18:06:07.798] List of 1
[18:06:07.798]  $ kk: int 1
[18:06:07.798]  - attr(*, "where")=List of 1
[18:06:07.798]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:07.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:07.798]  - attr(*, "resolved")= logi FALSE
[18:06:07.798]  - attr(*, "total_size")= num 56
[18:06:07.798]  - attr(*, "already-done")= logi TRUE
[18:06:07.805] - copied ‘kk’ to environment
[18:06:07.806] assign_globals() ... done
[18:06:07.806] requestCore(): workers = 2
[18:06:07.810] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:07.822] result() for MulticoreFuture ...
[18:06:07.824] result() for MulticoreFuture ...
[18:06:07.824] result() for MulticoreFuture ... done
[18:06:07.825] result() for MulticoreFuture ... done
[18:06:07.825] result() for MulticoreFuture ...
[18:06:07.826] result() for MulticoreFuture ... done
[18:06:07.830] MulticoreFuture started
[18:06:07.832] - Launch lazy future ... done
[18:06:07.832] run() for ‘MulticoreFuture’ ... done
[18:06:07.833] plan(): Setting new future strategy stack:
[18:06:07.833] List of future strategies:
[18:06:07.833] 1. sequential:
[18:06:07.833]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:07.833]    - tweaked: FALSE
[18:06:07.833]    - call: NULL
[18:06:07.837] plan(): nbrOfWorkers() = 1
[18:06:07.844] run() for ‘Future’ ...
[18:06:07.845] - state: ‘created’
[18:06:07.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:07.856] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:07.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:07.857]   - Field: ‘label’
[18:06:07.858]   - Field: ‘local’
[18:06:07.858]   - Field: ‘owner’
[18:06:07.859]   - Field: ‘envir’
[18:06:07.859]   - Field: ‘workers’
[18:06:07.860]   - Field: ‘packages’
[18:06:07.860]   - Field: ‘gc’
[18:06:07.860]   - Field: ‘job’
[18:06:07.861]   - Field: ‘conditions’
[18:06:07.861]   - Field: ‘expr’
[18:06:07.861]   - Field: ‘uuid’
[18:06:07.862]   - Field: ‘seed’
[18:06:07.862]   - Field: ‘version’
[18:06:07.863]   - Field: ‘result’
[18:06:07.863]   - Field: ‘asynchronous’
[18:06:07.863]   - Field: ‘calls’
[18:06:07.864]   - Field: ‘globals’
[18:06:07.864]   - Field: ‘stdout’
[18:06:07.864]   - Field: ‘earlySignal’
[18:06:07.865]   - Field: ‘lazy’
[18:06:07.865]   - Field: ‘state’
[18:06:07.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:07.866] - Launch lazy future ...
[18:06:07.867] Packages needed by the future expression (n = 0): <none>
[18:06:07.867] Packages needed by future strategies (n = 0): <none>
[18:06:07.869] {
[18:06:07.869]     {
[18:06:07.869]         {
[18:06:07.869]             ...future.startTime <- base::Sys.time()
[18:06:07.869]             {
[18:06:07.869]                 {
[18:06:07.869]                   {
[18:06:07.869]                     {
[18:06:07.869]                       base::local({
[18:06:07.869]                         has_future <- base::requireNamespace("future", 
[18:06:07.869]                           quietly = TRUE)
[18:06:07.869]                         if (has_future) {
[18:06:07.869]                           ns <- base::getNamespace("future")
[18:06:07.869]                           version <- ns[[".package"]][["version"]]
[18:06:07.869]                           if (is.null(version)) 
[18:06:07.869]                             version <- utils::packageVersion("future")
[18:06:07.869]                         }
[18:06:07.869]                         else {
[18:06:07.869]                           version <- NULL
[18:06:07.869]                         }
[18:06:07.869]                         if (!has_future || version < "1.8.0") {
[18:06:07.869]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:07.869]                             "", base::R.version$version.string), 
[18:06:07.869]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:07.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:07.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:07.869]                               "release", "version")], collapse = " "), 
[18:06:07.869]                             hostname = base::Sys.info()[["nodename"]])
[18:06:07.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:07.869]                             info)
[18:06:07.869]                           info <- base::paste(info, collapse = "; ")
[18:06:07.869]                           if (!has_future) {
[18:06:07.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:07.869]                               info)
[18:06:07.869]                           }
[18:06:07.869]                           else {
[18:06:07.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:07.869]                               info, version)
[18:06:07.869]                           }
[18:06:07.869]                           base::stop(msg)
[18:06:07.869]                         }
[18:06:07.869]                       })
[18:06:07.869]                     }
[18:06:07.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:07.869]                     base::options(mc.cores = 1L)
[18:06:07.869]                   }
[18:06:07.869]                   ...future.strategy.old <- future::plan("list")
[18:06:07.869]                   options(future.plan = NULL)
[18:06:07.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:07.869]                 }
[18:06:07.869]                 ...future.workdir <- getwd()
[18:06:07.869]             }
[18:06:07.869]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:07.869]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:07.869]         }
[18:06:07.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:07.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:07.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:07.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:07.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:07.869]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:07.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:07.869]             base::names(...future.oldOptions))
[18:06:07.869]     }
[18:06:07.869]     if (FALSE) {
[18:06:07.869]     }
[18:06:07.869]     else {
[18:06:07.869]         if (TRUE) {
[18:06:07.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:07.869]                 open = "w")
[18:06:07.869]         }
[18:06:07.869]         else {
[18:06:07.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:07.869]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:07.869]         }
[18:06:07.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:07.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:07.869]             base::sink(type = "output", split = FALSE)
[18:06:07.869]             base::close(...future.stdout)
[18:06:07.869]         }, add = TRUE)
[18:06:07.869]     }
[18:06:07.869]     ...future.frame <- base::sys.nframe()
[18:06:07.869]     ...future.conditions <- base::list()
[18:06:07.869]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:07.869]     if (FALSE) {
[18:06:07.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:07.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:07.869]     }
[18:06:07.869]     ...future.result <- base::tryCatch({
[18:06:07.869]         base::withCallingHandlers({
[18:06:07.869]             ...future.value <- base::withVisible(base::local({
[18:06:07.869]                 withCallingHandlers({
[18:06:07.869]                   {
[18:06:07.869]                     Sys.sleep(0.1)
[18:06:07.869]                     kk
[18:06:07.869]                   }
[18:06:07.869]                 }, immediateCondition = function(cond) {
[18:06:07.869]                   save_rds <- function (object, pathname, ...) 
[18:06:07.869]                   {
[18:06:07.869]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:07.869]                     if (file_test("-f", pathname_tmp)) {
[18:06:07.869]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.869]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:07.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.869]                         fi_tmp[["mtime"]])
[18:06:07.869]                     }
[18:06:07.869]                     tryCatch({
[18:06:07.869]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:07.869]                     }, error = function(ex) {
[18:06:07.869]                       msg <- conditionMessage(ex)
[18:06:07.869]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.869]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:07.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.869]                         fi_tmp[["mtime"]], msg)
[18:06:07.869]                       ex$message <- msg
[18:06:07.869]                       stop(ex)
[18:06:07.869]                     })
[18:06:07.869]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:07.869]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:07.869]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:07.869]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.869]                       fi <- file.info(pathname)
[18:06:07.869]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:07.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.869]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:07.869]                         fi[["size"]], fi[["mtime"]])
[18:06:07.869]                       stop(msg)
[18:06:07.869]                     }
[18:06:07.869]                     invisible(pathname)
[18:06:07.869]                   }
[18:06:07.869]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:07.869]                     rootPath = tempdir()) 
[18:06:07.869]                   {
[18:06:07.869]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:07.869]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:07.869]                       tmpdir = path, fileext = ".rds")
[18:06:07.869]                     save_rds(obj, file)
[18:06:07.869]                   }
[18:06:07.869]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:07.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.869]                   {
[18:06:07.869]                     inherits <- base::inherits
[18:06:07.869]                     invokeRestart <- base::invokeRestart
[18:06:07.869]                     is.null <- base::is.null
[18:06:07.869]                     muffled <- FALSE
[18:06:07.869]                     if (inherits(cond, "message")) {
[18:06:07.869]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:07.869]                       if (muffled) 
[18:06:07.869]                         invokeRestart("muffleMessage")
[18:06:07.869]                     }
[18:06:07.869]                     else if (inherits(cond, "warning")) {
[18:06:07.869]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:07.869]                       if (muffled) 
[18:06:07.869]                         invokeRestart("muffleWarning")
[18:06:07.869]                     }
[18:06:07.869]                     else if (inherits(cond, "condition")) {
[18:06:07.869]                       if (!is.null(pattern)) {
[18:06:07.869]                         computeRestarts <- base::computeRestarts
[18:06:07.869]                         grepl <- base::grepl
[18:06:07.869]                         restarts <- computeRestarts(cond)
[18:06:07.869]                         for (restart in restarts) {
[18:06:07.869]                           name <- restart$name
[18:06:07.869]                           if (is.null(name)) 
[18:06:07.869]                             next
[18:06:07.869]                           if (!grepl(pattern, name)) 
[18:06:07.869]                             next
[18:06:07.869]                           invokeRestart(restart)
[18:06:07.869]                           muffled <- TRUE
[18:06:07.869]                           break
[18:06:07.869]                         }
[18:06:07.869]                       }
[18:06:07.869]                     }
[18:06:07.869]                     invisible(muffled)
[18:06:07.869]                   }
[18:06:07.869]                   muffleCondition(cond)
[18:06:07.869]                 })
[18:06:07.869]             }))
[18:06:07.869]             future::FutureResult(value = ...future.value$value, 
[18:06:07.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.869]                   ...future.rng), globalenv = if (FALSE) 
[18:06:07.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:07.869]                     ...future.globalenv.names))
[18:06:07.869]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:07.869]         }, condition = base::local({
[18:06:07.869]             c <- base::c
[18:06:07.869]             inherits <- base::inherits
[18:06:07.869]             invokeRestart <- base::invokeRestart
[18:06:07.869]             length <- base::length
[18:06:07.869]             list <- base::list
[18:06:07.869]             seq.int <- base::seq.int
[18:06:07.869]             signalCondition <- base::signalCondition
[18:06:07.869]             sys.calls <- base::sys.calls
[18:06:07.869]             `[[` <- base::`[[`
[18:06:07.869]             `+` <- base::`+`
[18:06:07.869]             `<<-` <- base::`<<-`
[18:06:07.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:07.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:07.869]                   3L)]
[18:06:07.869]             }
[18:06:07.869]             function(cond) {
[18:06:07.869]                 is_error <- inherits(cond, "error")
[18:06:07.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:07.869]                   NULL)
[18:06:07.869]                 if (is_error) {
[18:06:07.869]                   sessionInformation <- function() {
[18:06:07.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:07.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:07.869]                       search = base::search(), system = base::Sys.info())
[18:06:07.869]                   }
[18:06:07.869]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:07.869]                     cond$call), session = sessionInformation(), 
[18:06:07.869]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:07.869]                   signalCondition(cond)
[18:06:07.869]                 }
[18:06:07.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:07.869]                 "immediateCondition"))) {
[18:06:07.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:07.869]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:07.869]                   if (TRUE && !signal) {
[18:06:07.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.869]                     {
[18:06:07.869]                       inherits <- base::inherits
[18:06:07.869]                       invokeRestart <- base::invokeRestart
[18:06:07.869]                       is.null <- base::is.null
[18:06:07.869]                       muffled <- FALSE
[18:06:07.869]                       if (inherits(cond, "message")) {
[18:06:07.869]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.869]                         if (muffled) 
[18:06:07.869]                           invokeRestart("muffleMessage")
[18:06:07.869]                       }
[18:06:07.869]                       else if (inherits(cond, "warning")) {
[18:06:07.869]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.869]                         if (muffled) 
[18:06:07.869]                           invokeRestart("muffleWarning")
[18:06:07.869]                       }
[18:06:07.869]                       else if (inherits(cond, "condition")) {
[18:06:07.869]                         if (!is.null(pattern)) {
[18:06:07.869]                           computeRestarts <- base::computeRestarts
[18:06:07.869]                           grepl <- base::grepl
[18:06:07.869]                           restarts <- computeRestarts(cond)
[18:06:07.869]                           for (restart in restarts) {
[18:06:07.869]                             name <- restart$name
[18:06:07.869]                             if (is.null(name)) 
[18:06:07.869]                               next
[18:06:07.869]                             if (!grepl(pattern, name)) 
[18:06:07.869]                               next
[18:06:07.869]                             invokeRestart(restart)
[18:06:07.869]                             muffled <- TRUE
[18:06:07.869]                             break
[18:06:07.869]                           }
[18:06:07.869]                         }
[18:06:07.869]                       }
[18:06:07.869]                       invisible(muffled)
[18:06:07.869]                     }
[18:06:07.869]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.869]                   }
[18:06:07.869]                 }
[18:06:07.869]                 else {
[18:06:07.869]                   if (TRUE) {
[18:06:07.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.869]                     {
[18:06:07.869]                       inherits <- base::inherits
[18:06:07.869]                       invokeRestart <- base::invokeRestart
[18:06:07.869]                       is.null <- base::is.null
[18:06:07.869]                       muffled <- FALSE
[18:06:07.869]                       if (inherits(cond, "message")) {
[18:06:07.869]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.869]                         if (muffled) 
[18:06:07.869]                           invokeRestart("muffleMessage")
[18:06:07.869]                       }
[18:06:07.869]                       else if (inherits(cond, "warning")) {
[18:06:07.869]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.869]                         if (muffled) 
[18:06:07.869]                           invokeRestart("muffleWarning")
[18:06:07.869]                       }
[18:06:07.869]                       else if (inherits(cond, "condition")) {
[18:06:07.869]                         if (!is.null(pattern)) {
[18:06:07.869]                           computeRestarts <- base::computeRestarts
[18:06:07.869]                           grepl <- base::grepl
[18:06:07.869]                           restarts <- computeRestarts(cond)
[18:06:07.869]                           for (restart in restarts) {
[18:06:07.869]                             name <- restart$name
[18:06:07.869]                             if (is.null(name)) 
[18:06:07.869]                               next
[18:06:07.869]                             if (!grepl(pattern, name)) 
[18:06:07.869]                               next
[18:06:07.869]                             invokeRestart(restart)
[18:06:07.869]                             muffled <- TRUE
[18:06:07.869]                             break
[18:06:07.869]                           }
[18:06:07.869]                         }
[18:06:07.869]                       }
[18:06:07.869]                       invisible(muffled)
[18:06:07.869]                     }
[18:06:07.869]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.869]                   }
[18:06:07.869]                 }
[18:06:07.869]             }
[18:06:07.869]         }))
[18:06:07.869]     }, error = function(ex) {
[18:06:07.869]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:07.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.869]                 ...future.rng), started = ...future.startTime, 
[18:06:07.869]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:07.869]             version = "1.8"), class = "FutureResult")
[18:06:07.869]     }, finally = {
[18:06:07.869]         if (!identical(...future.workdir, getwd())) 
[18:06:07.869]             setwd(...future.workdir)
[18:06:07.869]         {
[18:06:07.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:07.869]                 ...future.oldOptions$nwarnings <- NULL
[18:06:07.869]             }
[18:06:07.869]             base::options(...future.oldOptions)
[18:06:07.869]             if (.Platform$OS.type == "windows") {
[18:06:07.869]                 old_names <- names(...future.oldEnvVars)
[18:06:07.869]                 envs <- base::Sys.getenv()
[18:06:07.869]                 names <- names(envs)
[18:06:07.869]                 common <- intersect(names, old_names)
[18:06:07.869]                 added <- setdiff(names, old_names)
[18:06:07.869]                 removed <- setdiff(old_names, names)
[18:06:07.869]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:07.869]                   envs[common]]
[18:06:07.869]                 NAMES <- toupper(changed)
[18:06:07.869]                 args <- list()
[18:06:07.869]                 for (kk in seq_along(NAMES)) {
[18:06:07.869]                   name <- changed[[kk]]
[18:06:07.869]                   NAME <- NAMES[[kk]]
[18:06:07.869]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.869]                     next
[18:06:07.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.869]                 }
[18:06:07.869]                 NAMES <- toupper(added)
[18:06:07.869]                 for (kk in seq_along(NAMES)) {
[18:06:07.869]                   name <- added[[kk]]
[18:06:07.869]                   NAME <- NAMES[[kk]]
[18:06:07.869]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.869]                     next
[18:06:07.869]                   args[[name]] <- ""
[18:06:07.869]                 }
[18:06:07.869]                 NAMES <- toupper(removed)
[18:06:07.869]                 for (kk in seq_along(NAMES)) {
[18:06:07.869]                   name <- removed[[kk]]
[18:06:07.869]                   NAME <- NAMES[[kk]]
[18:06:07.869]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.869]                     next
[18:06:07.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.869]                 }
[18:06:07.869]                 if (length(args) > 0) 
[18:06:07.869]                   base::do.call(base::Sys.setenv, args = args)
[18:06:07.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:07.869]             }
[18:06:07.869]             else {
[18:06:07.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:07.869]             }
[18:06:07.869]             {
[18:06:07.869]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:07.869]                   0L) {
[18:06:07.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:07.869]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:07.869]                   base::options(opts)
[18:06:07.869]                 }
[18:06:07.869]                 {
[18:06:07.869]                   {
[18:06:07.869]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:07.869]                     NULL
[18:06:07.869]                   }
[18:06:07.869]                   options(future.plan = NULL)
[18:06:07.869]                   if (is.na(NA_character_)) 
[18:06:07.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:07.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:07.869]                     .init = FALSE)
[18:06:07.869]                 }
[18:06:07.869]             }
[18:06:07.869]         }
[18:06:07.869]     })
[18:06:07.869]     if (TRUE) {
[18:06:07.869]         base::sink(type = "output", split = FALSE)
[18:06:07.869]         if (TRUE) {
[18:06:07.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:07.869]         }
[18:06:07.869]         else {
[18:06:07.869]             ...future.result["stdout"] <- base::list(NULL)
[18:06:07.869]         }
[18:06:07.869]         base::close(...future.stdout)
[18:06:07.869]         ...future.stdout <- NULL
[18:06:07.869]     }
[18:06:07.869]     ...future.result$conditions <- ...future.conditions
[18:06:07.869]     ...future.result$finished <- base::Sys.time()
[18:06:07.869]     ...future.result
[18:06:07.869] }
[18:06:07.876] assign_globals() ...
[18:06:07.876] List of 1
[18:06:07.876]  $ kk: int 2
[18:06:07.876]  - attr(*, "where")=List of 1
[18:06:07.876]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:07.876]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:07.876]  - attr(*, "resolved")= logi FALSE
[18:06:07.876]  - attr(*, "total_size")= num 56
[18:06:07.876]  - attr(*, "already-done")= logi TRUE
[18:06:07.886] - copied ‘kk’ to environment
[18:06:07.886] assign_globals() ... done
[18:06:07.886] requestCore(): workers = 2
[18:06:07.887] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:07.899] result() for MulticoreFuture ...
[18:06:07.900] result() for MulticoreFuture ...
[18:06:07.901] result() for MulticoreFuture ... done
[18:06:07.901] result() for MulticoreFuture ... done
[18:06:07.902] result() for MulticoreFuture ...
[18:06:07.904] result() for MulticoreFuture ... done
[18:06:07.912] MulticoreFuture started
[18:06:07.913] - Launch lazy future ... done
[18:06:07.913] run() for ‘MulticoreFuture’ ... done
[18:06:07.915] plan(): Setting new future strategy stack:
[18:06:07.916] List of future strategies:
[18:06:07.916] 1. sequential:
[18:06:07.916]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:07.916]    - tweaked: FALSE
[18:06:07.916]    - call: NULL
[18:06:07.918] plan(): nbrOfWorkers() = 1
[18:06:07.925] run() for ‘Future’ ...
[18:06:07.925] - state: ‘created’
[18:06:07.926] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:07.936] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:07.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:07.937]   - Field: ‘label’
[18:06:07.937]   - Field: ‘local’
[18:06:07.937]   - Field: ‘owner’
[18:06:07.938]   - Field: ‘envir’
[18:06:07.938]   - Field: ‘workers’
[18:06:07.938]   - Field: ‘packages’
[18:06:07.939]   - Field: ‘gc’
[18:06:07.939]   - Field: ‘job’
[18:06:07.939]   - Field: ‘conditions’
[18:06:07.940]   - Field: ‘expr’
[18:06:07.940]   - Field: ‘uuid’
[18:06:07.940]   - Field: ‘seed’
[18:06:07.941]   - Field: ‘version’
[18:06:07.941]   - Field: ‘result’
[18:06:07.941]   - Field: ‘asynchronous’
[18:06:07.942]   - Field: ‘calls’
[18:06:07.942] plan(): Setting new future strategy stack:
[18:06:07.942]   - Field: ‘globals’
[18:06:07.942]   - Field: ‘stdout’
[18:06:07.942] List of future strategies:
[18:06:07.942] 1. multicore:
[18:06:07.942]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:07.942]    - tweaked: FALSE
[18:06:07.942]    - call: plan(strategy)
[18:06:07.945]   - Field: ‘earlySignal’
[18:06:07.945]   - Field: ‘lazy’
[18:06:07.946]   - Field: ‘state’
[18:06:07.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:07.946] - Launch lazy future ...
[18:06:07.949] Packages needed by the future expression (n = 0): <none>
[18:06:07.950] plan(): nbrOfWorkers() = 2
[18:06:07.950] Packages needed by future strategies (n = 0): <none>
[18:06:07.951] {
[18:06:07.951]     {
[18:06:07.951]         {
[18:06:07.951]             ...future.startTime <- base::Sys.time()
[18:06:07.951]             {
[18:06:07.951]                 {
[18:06:07.951]                   {
[18:06:07.951]                     {
[18:06:07.951]                       base::local({
[18:06:07.951]                         has_future <- base::requireNamespace("future", 
[18:06:07.951]                           quietly = TRUE)
[18:06:07.951]                         if (has_future) {
[18:06:07.951]                           ns <- base::getNamespace("future")
[18:06:07.951]                           version <- ns[[".package"]][["version"]]
[18:06:07.951]                           if (is.null(version)) 
[18:06:07.951]                             version <- utils::packageVersion("future")
[18:06:07.951]                         }
[18:06:07.951]                         else {
[18:06:07.951]                           version <- NULL
[18:06:07.951]                         }
[18:06:07.951]                         if (!has_future || version < "1.8.0") {
[18:06:07.951]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:07.951]                             "", base::R.version$version.string), 
[18:06:07.951]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:07.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:07.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:07.951]                               "release", "version")], collapse = " "), 
[18:06:07.951]                             hostname = base::Sys.info()[["nodename"]])
[18:06:07.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:07.951]                             info)
[18:06:07.951]                           info <- base::paste(info, collapse = "; ")
[18:06:07.951]                           if (!has_future) {
[18:06:07.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:07.951]                               info)
[18:06:07.951]                           }
[18:06:07.951]                           else {
[18:06:07.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:07.951]                               info, version)
[18:06:07.951]                           }
[18:06:07.951]                           base::stop(msg)
[18:06:07.951]                         }
[18:06:07.951]                       })
[18:06:07.951]                     }
[18:06:07.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:07.951]                     base::options(mc.cores = 1L)
[18:06:07.951]                   }
[18:06:07.951]                   ...future.strategy.old <- future::plan("list")
[18:06:07.951]                   options(future.plan = NULL)
[18:06:07.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:07.951]                 }
[18:06:07.951]                 ...future.workdir <- getwd()
[18:06:07.951]             }
[18:06:07.951]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:07.951]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:07.951]         }
[18:06:07.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:07.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:07.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:07.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:07.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:07.951]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:07.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:07.951]             base::names(...future.oldOptions))
[18:06:07.951]     }
[18:06:07.951]     if (FALSE) {
[18:06:07.951]     }
[18:06:07.951]     else {
[18:06:07.951]         if (TRUE) {
[18:06:07.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:07.951]                 open = "w")
[18:06:07.951]         }
[18:06:07.951]         else {
[18:06:07.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:07.951]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:07.951]         }
[18:06:07.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:07.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:07.951]             base::sink(type = "output", split = FALSE)
[18:06:07.951]             base::close(...future.stdout)
[18:06:07.951]         }, add = TRUE)
[18:06:07.951]     }
[18:06:07.951]     ...future.frame <- base::sys.nframe()
[18:06:07.951]     ...future.conditions <- base::list()
[18:06:07.951]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:07.951]     if (FALSE) {
[18:06:07.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:07.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:07.951]     }
[18:06:07.951]     ...future.result <- base::tryCatch({
[18:06:07.951]         base::withCallingHandlers({
[18:06:07.951]             ...future.value <- base::withVisible(base::local({
[18:06:07.951]                 withCallingHandlers({
[18:06:07.951]                   {
[18:06:07.951]                     Sys.sleep(0.1)
[18:06:07.951]                     kk
[18:06:07.951]                   }
[18:06:07.951]                 }, immediateCondition = function(cond) {
[18:06:07.951]                   save_rds <- function (object, pathname, ...) 
[18:06:07.951]                   {
[18:06:07.951]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:07.951]                     if (file_test("-f", pathname_tmp)) {
[18:06:07.951]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.951]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:07.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.951]                         fi_tmp[["mtime"]])
[18:06:07.951]                     }
[18:06:07.951]                     tryCatch({
[18:06:07.951]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:07.951]                     }, error = function(ex) {
[18:06:07.951]                       msg <- conditionMessage(ex)
[18:06:07.951]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.951]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:07.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.951]                         fi_tmp[["mtime"]], msg)
[18:06:07.951]                       ex$message <- msg
[18:06:07.951]                       stop(ex)
[18:06:07.951]                     })
[18:06:07.951]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:07.951]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:07.951]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:07.951]                       fi_tmp <- file.info(pathname_tmp)
[18:06:07.951]                       fi <- file.info(pathname)
[18:06:07.951]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:07.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:07.951]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:07.951]                         fi[["size"]], fi[["mtime"]])
[18:06:07.951]                       stop(msg)
[18:06:07.951]                     }
[18:06:07.951]                     invisible(pathname)
[18:06:07.951]                   }
[18:06:07.951]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:07.951]                     rootPath = tempdir()) 
[18:06:07.951]                   {
[18:06:07.951]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:07.951]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:07.951]                       tmpdir = path, fileext = ".rds")
[18:06:07.951]                     save_rds(obj, file)
[18:06:07.951]                   }
[18:06:07.951]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:07.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.951]                   {
[18:06:07.951]                     inherits <- base::inherits
[18:06:07.951]                     invokeRestart <- base::invokeRestart
[18:06:07.951]                     is.null <- base::is.null
[18:06:07.951]                     muffled <- FALSE
[18:06:07.951]                     if (inherits(cond, "message")) {
[18:06:07.951]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:07.951]                       if (muffled) 
[18:06:07.951]                         invokeRestart("muffleMessage")
[18:06:07.951]                     }
[18:06:07.951]                     else if (inherits(cond, "warning")) {
[18:06:07.951]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:07.951]                       if (muffled) 
[18:06:07.951]                         invokeRestart("muffleWarning")
[18:06:07.951]                     }
[18:06:07.951]                     else if (inherits(cond, "condition")) {
[18:06:07.951]                       if (!is.null(pattern)) {
[18:06:07.951]                         computeRestarts <- base::computeRestarts
[18:06:07.951]                         grepl <- base::grepl
[18:06:07.951]                         restarts <- computeRestarts(cond)
[18:06:07.951]                         for (restart in restarts) {
[18:06:07.951]                           name <- restart$name
[18:06:07.951]                           if (is.null(name)) 
[18:06:07.951]                             next
[18:06:07.951]                           if (!grepl(pattern, name)) 
[18:06:07.951]                             next
[18:06:07.951]                           invokeRestart(restart)
[18:06:07.951]                           muffled <- TRUE
[18:06:07.951]                           break
[18:06:07.951]                         }
[18:06:07.951]                       }
[18:06:07.951]                     }
[18:06:07.951]                     invisible(muffled)
[18:06:07.951]                   }
[18:06:07.951]                   muffleCondition(cond)
[18:06:07.951]                 })
[18:06:07.951]             }))
[18:06:07.951]             future::FutureResult(value = ...future.value$value, 
[18:06:07.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.951]                   ...future.rng), globalenv = if (FALSE) 
[18:06:07.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:07.951]                     ...future.globalenv.names))
[18:06:07.951]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:07.951]         }, condition = base::local({
[18:06:07.951]             c <- base::c
[18:06:07.951]             inherits <- base::inherits
[18:06:07.951]             invokeRestart <- base::invokeRestart
[18:06:07.951]             length <- base::length
[18:06:07.951]             list <- base::list
[18:06:07.951]             seq.int <- base::seq.int
[18:06:07.951]             signalCondition <- base::signalCondition
[18:06:07.951]             sys.calls <- base::sys.calls
[18:06:07.951]             `[[` <- base::`[[`
[18:06:07.951]             `+` <- base::`+`
[18:06:07.951]             `<<-` <- base::`<<-`
[18:06:07.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:07.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:07.951]                   3L)]
[18:06:07.951]             }
[18:06:07.951]             function(cond) {
[18:06:07.951]                 is_error <- inherits(cond, "error")
[18:06:07.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:07.951]                   NULL)
[18:06:07.951]                 if (is_error) {
[18:06:07.951]                   sessionInformation <- function() {
[18:06:07.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:07.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:07.951]                       search = base::search(), system = base::Sys.info())
[18:06:07.951]                   }
[18:06:07.951]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:07.951]                     cond$call), session = sessionInformation(), 
[18:06:07.951]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:07.951]                   signalCondition(cond)
[18:06:07.951]                 }
[18:06:07.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:07.951]                 "immediateCondition"))) {
[18:06:07.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:07.951]                   ...future.conditions[[length(...future.conditions) + 
[18:06:07.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:07.951]                   if (TRUE && !signal) {
[18:06:07.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.951]                     {
[18:06:07.951]                       inherits <- base::inherits
[18:06:07.951]                       invokeRestart <- base::invokeRestart
[18:06:07.951]                       is.null <- base::is.null
[18:06:07.951]                       muffled <- FALSE
[18:06:07.951]                       if (inherits(cond, "message")) {
[18:06:07.951]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.951]                         if (muffled) 
[18:06:07.951]                           invokeRestart("muffleMessage")
[18:06:07.951]                       }
[18:06:07.951]                       else if (inherits(cond, "warning")) {
[18:06:07.951]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.951]                         if (muffled) 
[18:06:07.951]                           invokeRestart("muffleWarning")
[18:06:07.951]                       }
[18:06:07.951]                       else if (inherits(cond, "condition")) {
[18:06:07.951]                         if (!is.null(pattern)) {
[18:06:07.951]                           computeRestarts <- base::computeRestarts
[18:06:07.951]                           grepl <- base::grepl
[18:06:07.951]                           restarts <- computeRestarts(cond)
[18:06:07.951]                           for (restart in restarts) {
[18:06:07.951]                             name <- restart$name
[18:06:07.951]                             if (is.null(name)) 
[18:06:07.951]                               next
[18:06:07.951]                             if (!grepl(pattern, name)) 
[18:06:07.951]                               next
[18:06:07.951]                             invokeRestart(restart)
[18:06:07.951]                             muffled <- TRUE
[18:06:07.951]                             break
[18:06:07.951]                           }
[18:06:07.951]                         }
[18:06:07.951]                       }
[18:06:07.951]                       invisible(muffled)
[18:06:07.951]                     }
[18:06:07.951]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.951]                   }
[18:06:07.951]                 }
[18:06:07.951]                 else {
[18:06:07.951]                   if (TRUE) {
[18:06:07.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:07.951]                     {
[18:06:07.951]                       inherits <- base::inherits
[18:06:07.951]                       invokeRestart <- base::invokeRestart
[18:06:07.951]                       is.null <- base::is.null
[18:06:07.951]                       muffled <- FALSE
[18:06:07.951]                       if (inherits(cond, "message")) {
[18:06:07.951]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:07.951]                         if (muffled) 
[18:06:07.951]                           invokeRestart("muffleMessage")
[18:06:07.951]                       }
[18:06:07.951]                       else if (inherits(cond, "warning")) {
[18:06:07.951]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:07.951]                         if (muffled) 
[18:06:07.951]                           invokeRestart("muffleWarning")
[18:06:07.951]                       }
[18:06:07.951]                       else if (inherits(cond, "condition")) {
[18:06:07.951]                         if (!is.null(pattern)) {
[18:06:07.951]                           computeRestarts <- base::computeRestarts
[18:06:07.951]                           grepl <- base::grepl
[18:06:07.951]                           restarts <- computeRestarts(cond)
[18:06:07.951]                           for (restart in restarts) {
[18:06:07.951]                             name <- restart$name
[18:06:07.951]                             if (is.null(name)) 
[18:06:07.951]                               next
[18:06:07.951]                             if (!grepl(pattern, name)) 
[18:06:07.951]                               next
[18:06:07.951]                             invokeRestart(restart)
[18:06:07.951]                             muffled <- TRUE
[18:06:07.951]                             break
[18:06:07.951]                           }
[18:06:07.951]                         }
[18:06:07.951]                       }
[18:06:07.951]                       invisible(muffled)
[18:06:07.951]                     }
[18:06:07.951]                     muffleCondition(cond, pattern = "^muffle")
[18:06:07.951]                   }
[18:06:07.951]                 }
[18:06:07.951]             }
[18:06:07.951]         }))
[18:06:07.951]     }, error = function(ex) {
[18:06:07.951]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:07.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:07.951]                 ...future.rng), started = ...future.startTime, 
[18:06:07.951]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:07.951]             version = "1.8"), class = "FutureResult")
[18:06:07.951]     }, finally = {
[18:06:07.951]         if (!identical(...future.workdir, getwd())) 
[18:06:07.951]             setwd(...future.workdir)
[18:06:07.951]         {
[18:06:07.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:07.951]                 ...future.oldOptions$nwarnings <- NULL
[18:06:07.951]             }
[18:06:07.951]             base::options(...future.oldOptions)
[18:06:07.951]             if (.Platform$OS.type == "windows") {
[18:06:07.951]                 old_names <- names(...future.oldEnvVars)
[18:06:07.951]                 envs <- base::Sys.getenv()
[18:06:07.951]                 names <- names(envs)
[18:06:07.951]                 common <- intersect(names, old_names)
[18:06:07.951]                 added <- setdiff(names, old_names)
[18:06:07.951]                 removed <- setdiff(old_names, names)
[18:06:07.951]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:07.951]                   envs[common]]
[18:06:07.951]                 NAMES <- toupper(changed)
[18:06:07.951]                 args <- list()
[18:06:07.951]                 for (kk in seq_along(NAMES)) {
[18:06:07.951]                   name <- changed[[kk]]
[18:06:07.951]                   NAME <- NAMES[[kk]]
[18:06:07.951]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.951]                     next
[18:06:07.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.951]                 }
[18:06:07.951]                 NAMES <- toupper(added)
[18:06:07.951]                 for (kk in seq_along(NAMES)) {
[18:06:07.951]                   name <- added[[kk]]
[18:06:07.951]                   NAME <- NAMES[[kk]]
[18:06:07.951]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.951]                     next
[18:06:07.951]                   args[[name]] <- ""
[18:06:07.951]                 }
[18:06:07.951]                 NAMES <- toupper(removed)
[18:06:07.951]                 for (kk in seq_along(NAMES)) {
[18:06:07.951]                   name <- removed[[kk]]
[18:06:07.951]                   NAME <- NAMES[[kk]]
[18:06:07.951]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:07.951]                     next
[18:06:07.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:07.951]                 }
[18:06:07.951]                 if (length(args) > 0) 
[18:06:07.951]                   base::do.call(base::Sys.setenv, args = args)
[18:06:07.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:07.951]             }
[18:06:07.951]             else {
[18:06:07.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:07.951]             }
[18:06:07.951]             {
[18:06:07.951]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:07.951]                   0L) {
[18:06:07.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:07.951]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:07.951]                   base::options(opts)
[18:06:07.951]                 }
[18:06:07.951]                 {
[18:06:07.951]                   {
[18:06:07.951]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:07.951]                     NULL
[18:06:07.951]                   }
[18:06:07.951]                   options(future.plan = NULL)
[18:06:07.951]                   if (is.na(NA_character_)) 
[18:06:07.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:07.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:07.951]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:07.951]                     .init = FALSE)
[18:06:07.951]                 }
[18:06:07.951]             }
[18:06:07.951]         }
[18:06:07.951]     })
[18:06:07.951]     if (TRUE) {
[18:06:07.951]         base::sink(type = "output", split = FALSE)
[18:06:07.951]         if (TRUE) {
[18:06:07.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:07.951]         }
[18:06:07.951]         else {
[18:06:07.951]             ...future.result["stdout"] <- base::list(NULL)
[18:06:07.951]         }
[18:06:07.951]         base::close(...future.stdout)
[18:06:07.951]         ...future.stdout <- NULL
[18:06:07.951]     }
[18:06:07.951]     ...future.result$conditions <- ...future.conditions
[18:06:07.951]     ...future.result$finished <- base::Sys.time()
[18:06:07.951]     ...future.result
[18:06:07.951] }
[18:06:07.959] assign_globals() ...
[18:06:07.959] List of 1
[18:06:07.959]  $ kk: int 3
[18:06:07.959]  - attr(*, "where")=List of 1
[18:06:07.959]   ..$ kk:<environment: R_EmptyEnv> 
[18:06:07.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:06:07.959]  - attr(*, "resolved")= logi FALSE
[18:06:07.959]  - attr(*, "total_size")= num 56
[18:06:07.959]  - attr(*, "already-done")= logi TRUE
[18:06:07.968] - copied ‘kk’ to environment
[18:06:07.969] assign_globals() ... done
[18:06:07.969] requestCore(): workers = 2
[18:06:07.970] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:07.981] result() for MulticoreFuture ...
[18:06:07.985] result() for MulticoreFuture ...
[18:06:07.986] result() for MulticoreFuture ... done
[18:06:07.986] result() for MulticoreFuture ... done
[18:06:07.986] result() for MulticoreFuture ...
[18:06:07.987] result() for MulticoreFuture ... done
[18:06:07.991] MulticoreFuture started
[18:06:07.991] - Launch lazy future ... done
[18:06:07.992] run() for ‘MulticoreFuture’ ... done
[18:06:07.993] plan(): Setting new future strategy stack:
[18:06:07.993] List of future strategies:
[18:06:07.993] 1. sequential:
[18:06:07.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:07.993]    - tweaked: FALSE
[18:06:07.993]    - call: NULL
[18:06:07.996] plan(): nbrOfWorkers() = 1
[18:06:08.014] Future #1
[18:06:08.014]  length: 2 (resolved future 1)
[18:06:08.023] plan(): Setting new future strategy stack:
[18:06:08.023] List of future strategies:
[18:06:08.023] 1. multicore:
[18:06:08.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.023]    - tweaked: FALSE
[18:06:08.023]    - call: plan(strategy)
[18:06:08.031] plan(): nbrOfWorkers() = 2
[18:06:08.046] Future #2
[18:06:08.047]  length: 1 (resolved future 2)
[18:06:08.101] plan(): Setting new future strategy stack:
[18:06:08.101] List of future strategies:
[18:06:08.101] 1. multicore:
[18:06:08.101]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.101]    - tweaked: FALSE
[18:06:08.101]    - call: plan(strategy)
[18:06:08.115] plan(): nbrOfWorkers() = 2
[18:06:08.117] Future #3
[18:06:08.117]  length: 0 (resolved future 3)
[18:06:08.118] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[18:06:08.120] resolve() on environment ...
[18:06:08.120]  recursive: 0
[18:06:08.122]  elements: [2] ‘a’, ‘b’
[18:06:08.123]  length: 1 (resolved future 1)
[18:06:08.123]  length: 0 (resolved future 2)
[18:06:08.123] resolve() on environment ... DONE
[18:06:08.125] getGlobalsAndPackages() ...
[18:06:08.131] Searching for globals...
[18:06:08.133] 
[18:06:08.134] Searching for globals ... DONE
[18:06:08.135] - globals: [0] <none>
[18:06:08.135] getGlobalsAndPackages() ... DONE
[18:06:08.137] run() for ‘Future’ ...
[18:06:08.137] - state: ‘created’
[18:06:08.138] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.148] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.148]   - Field: ‘label’
[18:06:08.149]   - Field: ‘local’
[18:06:08.149]   - Field: ‘owner’
[18:06:08.150]   - Field: ‘envir’
[18:06:08.150]   - Field: ‘workers’
[18:06:08.150]   - Field: ‘packages’
[18:06:08.151]   - Field: ‘gc’
[18:06:08.151]   - Field: ‘job’
[18:06:08.151]   - Field: ‘conditions’
[18:06:08.152]   - Field: ‘expr’
[18:06:08.152]   - Field: ‘uuid’
[18:06:08.152]   - Field: ‘seed’
[18:06:08.153]   - Field: ‘version’
[18:06:08.153]   - Field: ‘result’
[18:06:08.153]   - Field: ‘asynchronous’
[18:06:08.153]   - Field: ‘calls’
[18:06:08.154]   - Field: ‘globals’
[18:06:08.154]   - Field: ‘stdout’
[18:06:08.154]   - Field: ‘earlySignal’
[18:06:08.155]   - Field: ‘lazy’
[18:06:08.155]   - Field: ‘state’
[18:06:08.155] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.156] - Launch lazy future ...
[18:06:08.156] Packages needed by the future expression (n = 0): <none>
[18:06:08.157] Packages needed by future strategies (n = 0): <none>
[18:06:08.158] {
[18:06:08.158]     {
[18:06:08.158]         {
[18:06:08.158]             ...future.startTime <- base::Sys.time()
[18:06:08.158]             {
[18:06:08.158]                 {
[18:06:08.158]                   {
[18:06:08.158]                     {
[18:06:08.158]                       base::local({
[18:06:08.158]                         has_future <- base::requireNamespace("future", 
[18:06:08.158]                           quietly = TRUE)
[18:06:08.158]                         if (has_future) {
[18:06:08.158]                           ns <- base::getNamespace("future")
[18:06:08.158]                           version <- ns[[".package"]][["version"]]
[18:06:08.158]                           if (is.null(version)) 
[18:06:08.158]                             version <- utils::packageVersion("future")
[18:06:08.158]                         }
[18:06:08.158]                         else {
[18:06:08.158]                           version <- NULL
[18:06:08.158]                         }
[18:06:08.158]                         if (!has_future || version < "1.8.0") {
[18:06:08.158]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.158]                             "", base::R.version$version.string), 
[18:06:08.158]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.158]                               "release", "version")], collapse = " "), 
[18:06:08.158]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.158]                             info)
[18:06:08.158]                           info <- base::paste(info, collapse = "; ")
[18:06:08.158]                           if (!has_future) {
[18:06:08.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.158]                               info)
[18:06:08.158]                           }
[18:06:08.158]                           else {
[18:06:08.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.158]                               info, version)
[18:06:08.158]                           }
[18:06:08.158]                           base::stop(msg)
[18:06:08.158]                         }
[18:06:08.158]                       })
[18:06:08.158]                     }
[18:06:08.158]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.158]                     base::options(mc.cores = 1L)
[18:06:08.158]                   }
[18:06:08.158]                   ...future.strategy.old <- future::plan("list")
[18:06:08.158]                   options(future.plan = NULL)
[18:06:08.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.158]                 }
[18:06:08.158]                 ...future.workdir <- getwd()
[18:06:08.158]             }
[18:06:08.158]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.158]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.158]         }
[18:06:08.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.158]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.158]             base::names(...future.oldOptions))
[18:06:08.158]     }
[18:06:08.158]     if (FALSE) {
[18:06:08.158]     }
[18:06:08.158]     else {
[18:06:08.158]         if (TRUE) {
[18:06:08.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.158]                 open = "w")
[18:06:08.158]         }
[18:06:08.158]         else {
[18:06:08.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.158]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.158]         }
[18:06:08.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.158]             base::sink(type = "output", split = FALSE)
[18:06:08.158]             base::close(...future.stdout)
[18:06:08.158]         }, add = TRUE)
[18:06:08.158]     }
[18:06:08.158]     ...future.frame <- base::sys.nframe()
[18:06:08.158]     ...future.conditions <- base::list()
[18:06:08.158]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.158]     if (FALSE) {
[18:06:08.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.158]     }
[18:06:08.158]     ...future.result <- base::tryCatch({
[18:06:08.158]         base::withCallingHandlers({
[18:06:08.158]             ...future.value <- base::withVisible(base::local({
[18:06:08.158]                 withCallingHandlers({
[18:06:08.158]                   1
[18:06:08.158]                 }, immediateCondition = function(cond) {
[18:06:08.158]                   save_rds <- function (object, pathname, ...) 
[18:06:08.158]                   {
[18:06:08.158]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.158]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.158]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.158]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.158]                         fi_tmp[["mtime"]])
[18:06:08.158]                     }
[18:06:08.158]                     tryCatch({
[18:06:08.158]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.158]                     }, error = function(ex) {
[18:06:08.158]                       msg <- conditionMessage(ex)
[18:06:08.158]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.158]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.158]                         fi_tmp[["mtime"]], msg)
[18:06:08.158]                       ex$message <- msg
[18:06:08.158]                       stop(ex)
[18:06:08.158]                     })
[18:06:08.158]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.158]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.158]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.158]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.158]                       fi <- file.info(pathname)
[18:06:08.158]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.158]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.158]                         fi[["size"]], fi[["mtime"]])
[18:06:08.158]                       stop(msg)
[18:06:08.158]                     }
[18:06:08.158]                     invisible(pathname)
[18:06:08.158]                   }
[18:06:08.158]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.158]                     rootPath = tempdir()) 
[18:06:08.158]                   {
[18:06:08.158]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.158]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.158]                       tmpdir = path, fileext = ".rds")
[18:06:08.158]                     save_rds(obj, file)
[18:06:08.158]                   }
[18:06:08.158]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.158]                   {
[18:06:08.158]                     inherits <- base::inherits
[18:06:08.158]                     invokeRestart <- base::invokeRestart
[18:06:08.158]                     is.null <- base::is.null
[18:06:08.158]                     muffled <- FALSE
[18:06:08.158]                     if (inherits(cond, "message")) {
[18:06:08.158]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.158]                       if (muffled) 
[18:06:08.158]                         invokeRestart("muffleMessage")
[18:06:08.158]                     }
[18:06:08.158]                     else if (inherits(cond, "warning")) {
[18:06:08.158]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.158]                       if (muffled) 
[18:06:08.158]                         invokeRestart("muffleWarning")
[18:06:08.158]                     }
[18:06:08.158]                     else if (inherits(cond, "condition")) {
[18:06:08.158]                       if (!is.null(pattern)) {
[18:06:08.158]                         computeRestarts <- base::computeRestarts
[18:06:08.158]                         grepl <- base::grepl
[18:06:08.158]                         restarts <- computeRestarts(cond)
[18:06:08.158]                         for (restart in restarts) {
[18:06:08.158]                           name <- restart$name
[18:06:08.158]                           if (is.null(name)) 
[18:06:08.158]                             next
[18:06:08.158]                           if (!grepl(pattern, name)) 
[18:06:08.158]                             next
[18:06:08.158]                           invokeRestart(restart)
[18:06:08.158]                           muffled <- TRUE
[18:06:08.158]                           break
[18:06:08.158]                         }
[18:06:08.158]                       }
[18:06:08.158]                     }
[18:06:08.158]                     invisible(muffled)
[18:06:08.158]                   }
[18:06:08.158]                   muffleCondition(cond)
[18:06:08.158]                 })
[18:06:08.158]             }))
[18:06:08.158]             future::FutureResult(value = ...future.value$value, 
[18:06:08.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.158]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.158]                     ...future.globalenv.names))
[18:06:08.158]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.158]         }, condition = base::local({
[18:06:08.158]             c <- base::c
[18:06:08.158]             inherits <- base::inherits
[18:06:08.158]             invokeRestart <- base::invokeRestart
[18:06:08.158]             length <- base::length
[18:06:08.158]             list <- base::list
[18:06:08.158]             seq.int <- base::seq.int
[18:06:08.158]             signalCondition <- base::signalCondition
[18:06:08.158]             sys.calls <- base::sys.calls
[18:06:08.158]             `[[` <- base::`[[`
[18:06:08.158]             `+` <- base::`+`
[18:06:08.158]             `<<-` <- base::`<<-`
[18:06:08.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.158]                   3L)]
[18:06:08.158]             }
[18:06:08.158]             function(cond) {
[18:06:08.158]                 is_error <- inherits(cond, "error")
[18:06:08.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.158]                   NULL)
[18:06:08.158]                 if (is_error) {
[18:06:08.158]                   sessionInformation <- function() {
[18:06:08.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.158]                       search = base::search(), system = base::Sys.info())
[18:06:08.158]                   }
[18:06:08.158]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.158]                     cond$call), session = sessionInformation(), 
[18:06:08.158]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.158]                   signalCondition(cond)
[18:06:08.158]                 }
[18:06:08.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.158]                 "immediateCondition"))) {
[18:06:08.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.158]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.158]                   if (TRUE && !signal) {
[18:06:08.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.158]                     {
[18:06:08.158]                       inherits <- base::inherits
[18:06:08.158]                       invokeRestart <- base::invokeRestart
[18:06:08.158]                       is.null <- base::is.null
[18:06:08.158]                       muffled <- FALSE
[18:06:08.158]                       if (inherits(cond, "message")) {
[18:06:08.158]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.158]                         if (muffled) 
[18:06:08.158]                           invokeRestart("muffleMessage")
[18:06:08.158]                       }
[18:06:08.158]                       else if (inherits(cond, "warning")) {
[18:06:08.158]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.158]                         if (muffled) 
[18:06:08.158]                           invokeRestart("muffleWarning")
[18:06:08.158]                       }
[18:06:08.158]                       else if (inherits(cond, "condition")) {
[18:06:08.158]                         if (!is.null(pattern)) {
[18:06:08.158]                           computeRestarts <- base::computeRestarts
[18:06:08.158]                           grepl <- base::grepl
[18:06:08.158]                           restarts <- computeRestarts(cond)
[18:06:08.158]                           for (restart in restarts) {
[18:06:08.158]                             name <- restart$name
[18:06:08.158]                             if (is.null(name)) 
[18:06:08.158]                               next
[18:06:08.158]                             if (!grepl(pattern, name)) 
[18:06:08.158]                               next
[18:06:08.158]                             invokeRestart(restart)
[18:06:08.158]                             muffled <- TRUE
[18:06:08.158]                             break
[18:06:08.158]                           }
[18:06:08.158]                         }
[18:06:08.158]                       }
[18:06:08.158]                       invisible(muffled)
[18:06:08.158]                     }
[18:06:08.158]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.158]                   }
[18:06:08.158]                 }
[18:06:08.158]                 else {
[18:06:08.158]                   if (TRUE) {
[18:06:08.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.158]                     {
[18:06:08.158]                       inherits <- base::inherits
[18:06:08.158]                       invokeRestart <- base::invokeRestart
[18:06:08.158]                       is.null <- base::is.null
[18:06:08.158]                       muffled <- FALSE
[18:06:08.158]                       if (inherits(cond, "message")) {
[18:06:08.158]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.158]                         if (muffled) 
[18:06:08.158]                           invokeRestart("muffleMessage")
[18:06:08.158]                       }
[18:06:08.158]                       else if (inherits(cond, "warning")) {
[18:06:08.158]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.158]                         if (muffled) 
[18:06:08.158]                           invokeRestart("muffleWarning")
[18:06:08.158]                       }
[18:06:08.158]                       else if (inherits(cond, "condition")) {
[18:06:08.158]                         if (!is.null(pattern)) {
[18:06:08.158]                           computeRestarts <- base::computeRestarts
[18:06:08.158]                           grepl <- base::grepl
[18:06:08.158]                           restarts <- computeRestarts(cond)
[18:06:08.158]                           for (restart in restarts) {
[18:06:08.158]                             name <- restart$name
[18:06:08.158]                             if (is.null(name)) 
[18:06:08.158]                               next
[18:06:08.158]                             if (!grepl(pattern, name)) 
[18:06:08.158]                               next
[18:06:08.158]                             invokeRestart(restart)
[18:06:08.158]                             muffled <- TRUE
[18:06:08.158]                             break
[18:06:08.158]                           }
[18:06:08.158]                         }
[18:06:08.158]                       }
[18:06:08.158]                       invisible(muffled)
[18:06:08.158]                     }
[18:06:08.158]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.158]                   }
[18:06:08.158]                 }
[18:06:08.158]             }
[18:06:08.158]         }))
[18:06:08.158]     }, error = function(ex) {
[18:06:08.158]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.158]                 ...future.rng), started = ...future.startTime, 
[18:06:08.158]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.158]             version = "1.8"), class = "FutureResult")
[18:06:08.158]     }, finally = {
[18:06:08.158]         if (!identical(...future.workdir, getwd())) 
[18:06:08.158]             setwd(...future.workdir)
[18:06:08.158]         {
[18:06:08.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.158]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.158]             }
[18:06:08.158]             base::options(...future.oldOptions)
[18:06:08.158]             if (.Platform$OS.type == "windows") {
[18:06:08.158]                 old_names <- names(...future.oldEnvVars)
[18:06:08.158]                 envs <- base::Sys.getenv()
[18:06:08.158]                 names <- names(envs)
[18:06:08.158]                 common <- intersect(names, old_names)
[18:06:08.158]                 added <- setdiff(names, old_names)
[18:06:08.158]                 removed <- setdiff(old_names, names)
[18:06:08.158]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.158]                   envs[common]]
[18:06:08.158]                 NAMES <- toupper(changed)
[18:06:08.158]                 args <- list()
[18:06:08.158]                 for (kk in seq_along(NAMES)) {
[18:06:08.158]                   name <- changed[[kk]]
[18:06:08.158]                   NAME <- NAMES[[kk]]
[18:06:08.158]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.158]                     next
[18:06:08.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.158]                 }
[18:06:08.158]                 NAMES <- toupper(added)
[18:06:08.158]                 for (kk in seq_along(NAMES)) {
[18:06:08.158]                   name <- added[[kk]]
[18:06:08.158]                   NAME <- NAMES[[kk]]
[18:06:08.158]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.158]                     next
[18:06:08.158]                   args[[name]] <- ""
[18:06:08.158]                 }
[18:06:08.158]                 NAMES <- toupper(removed)
[18:06:08.158]                 for (kk in seq_along(NAMES)) {
[18:06:08.158]                   name <- removed[[kk]]
[18:06:08.158]                   NAME <- NAMES[[kk]]
[18:06:08.158]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.158]                     next
[18:06:08.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.158]                 }
[18:06:08.158]                 if (length(args) > 0) 
[18:06:08.158]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.158]             }
[18:06:08.158]             else {
[18:06:08.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.158]             }
[18:06:08.158]             {
[18:06:08.158]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.158]                   0L) {
[18:06:08.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.158]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.158]                   base::options(opts)
[18:06:08.158]                 }
[18:06:08.158]                 {
[18:06:08.158]                   {
[18:06:08.158]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.158]                     NULL
[18:06:08.158]                   }
[18:06:08.158]                   options(future.plan = NULL)
[18:06:08.158]                   if (is.na(NA_character_)) 
[18:06:08.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.158]                     .init = FALSE)
[18:06:08.158]                 }
[18:06:08.158]             }
[18:06:08.158]         }
[18:06:08.158]     })
[18:06:08.158]     if (TRUE) {
[18:06:08.158]         base::sink(type = "output", split = FALSE)
[18:06:08.158]         if (TRUE) {
[18:06:08.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.158]         }
[18:06:08.158]         else {
[18:06:08.158]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.158]         }
[18:06:08.158]         base::close(...future.stdout)
[18:06:08.158]         ...future.stdout <- NULL
[18:06:08.158]     }
[18:06:08.158]     ...future.result$conditions <- ...future.conditions
[18:06:08.158]     ...future.result$finished <- base::Sys.time()
[18:06:08.158]     ...future.result
[18:06:08.158] }
[18:06:08.163] requestCore(): workers = 2
[18:06:08.164] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.175] result() for MulticoreFuture ...
[18:06:08.177] result() for MulticoreFuture ...
[18:06:08.177] result() for MulticoreFuture ... done
[18:06:08.177] result() for MulticoreFuture ... done
[18:06:08.178] result() for MulticoreFuture ...
[18:06:08.178] result() for MulticoreFuture ... done
[18:06:08.183] MulticoreFuture started
[18:06:08.184] - Launch lazy future ... done
[18:06:08.184] run() for ‘MulticoreFuture’ ... done
[18:06:08.185] getGlobalsAndPackages() ...
[18:06:08.186] Searching for globals...
[18:06:08.185] plan(): Setting new future strategy stack:
[18:06:08.188] 
[18:06:08.188] Searching for globals ... DONE
[18:06:08.188] - globals: [0] <none>
[18:06:08.189] getGlobalsAndPackages() ... DONE
[18:06:08.186] List of future strategies:
[18:06:08.186] 1. sequential:
[18:06:08.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.186]    - tweaked: FALSE
[18:06:08.186]    - call: NULL
[18:06:08.190] run() for ‘Future’ ...
[18:06:08.191] - state: ‘created’
[18:06:08.191] plan(): nbrOfWorkers() = 1
[18:06:08.191] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.200] plan(): Setting new future strategy stack:
[18:06:08.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.202]   - Field: ‘label’
[18:06:08.202]   - Field: ‘local’
[18:06:08.203]   - Field: ‘owner’
[18:06:08.203]   - Field: ‘envir’
[18:06:08.203]   - Field: ‘workers’
[18:06:08.204]   - Field: ‘packages’
[18:06:08.204]   - Field: ‘gc’
[18:06:08.201] List of future strategies:
[18:06:08.201] 1. multicore:
[18:06:08.201]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.201]    - tweaked: FALSE
[18:06:08.201]    - call: plan(strategy)
[18:06:08.205]   - Field: ‘job’
[18:06:08.205]   - Field: ‘conditions’
[18:06:08.205]   - Field: ‘expr’
[18:06:08.206]   - Field: ‘uuid’
[18:06:08.206]   - Field: ‘seed’
[18:06:08.206]   - Field: ‘version’
[18:06:08.207]   - Field: ‘result’
[18:06:08.207]   - Field: ‘asynchronous’
[18:06:08.207]   - Field: ‘calls’
[18:06:08.208]   - Field: ‘globals’
[18:06:08.208]   - Field: ‘stdout’
[18:06:08.208]   - Field: ‘earlySignal’
[18:06:08.209]   - Field: ‘lazy’
[18:06:08.209]   - Field: ‘state’
[18:06:08.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.210] - Launch lazy future ...
[18:06:08.212] Packages needed by the future expression (n = 0): <none>
[18:06:08.212] Packages needed by future strategies (n = 0): <none>
[18:06:08.214] {
[18:06:08.214]     {
[18:06:08.214]         {
[18:06:08.214]             ...future.startTime <- base::Sys.time()
[18:06:08.214]             {
[18:06:08.214]                 {
[18:06:08.214]                   {
[18:06:08.214]                     {
[18:06:08.214]                       base::local({
[18:06:08.214]                         has_future <- base::requireNamespace("future", 
[18:06:08.214]                           quietly = TRUE)
[18:06:08.214]                         if (has_future) {
[18:06:08.214]                           ns <- base::getNamespace("future")
[18:06:08.214]                           version <- ns[[".package"]][["version"]]
[18:06:08.214]                           if (is.null(version)) 
[18:06:08.214]                             version <- utils::packageVersion("future")
[18:06:08.214]                         }
[18:06:08.214]                         else {
[18:06:08.214]                           version <- NULL
[18:06:08.214]                         }
[18:06:08.214]                         if (!has_future || version < "1.8.0") {
[18:06:08.214]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.214]                             "", base::R.version$version.string), 
[18:06:08.214]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.214]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.214]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.214]                               "release", "version")], collapse = " "), 
[18:06:08.214]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.214]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.214]                             info)
[18:06:08.214]                           info <- base::paste(info, collapse = "; ")
[18:06:08.214]                           if (!has_future) {
[18:06:08.214]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.214]                               info)
[18:06:08.214]                           }
[18:06:08.214]                           else {
[18:06:08.214]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.214]                               info, version)
[18:06:08.214]                           }
[18:06:08.214]                           base::stop(msg)
[18:06:08.214]                         }
[18:06:08.214]                       })
[18:06:08.214]                     }
[18:06:08.214]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.214]                     base::options(mc.cores = 1L)
[18:06:08.214]                   }
[18:06:08.214]                   ...future.strategy.old <- future::plan("list")
[18:06:08.214]                   options(future.plan = NULL)
[18:06:08.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.214]                 }
[18:06:08.214]                 ...future.workdir <- getwd()
[18:06:08.214]             }
[18:06:08.214]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.214]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.214]         }
[18:06:08.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.214]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.214]             base::names(...future.oldOptions))
[18:06:08.214]     }
[18:06:08.214]     if (FALSE) {
[18:06:08.214]     }
[18:06:08.214]     else {
[18:06:08.214]         if (TRUE) {
[18:06:08.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.214]                 open = "w")
[18:06:08.214]         }
[18:06:08.214]         else {
[18:06:08.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.214]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.214]         }
[18:06:08.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.214]             base::sink(type = "output", split = FALSE)
[18:06:08.214]             base::close(...future.stdout)
[18:06:08.214]         }, add = TRUE)
[18:06:08.214]     }
[18:06:08.214]     ...future.frame <- base::sys.nframe()
[18:06:08.214]     ...future.conditions <- base::list()
[18:06:08.214]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.214]     if (FALSE) {
[18:06:08.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.214]     }
[18:06:08.214]     ...future.result <- base::tryCatch({
[18:06:08.214]         base::withCallingHandlers({
[18:06:08.214]             ...future.value <- base::withVisible(base::local({
[18:06:08.214]                 withCallingHandlers({
[18:06:08.214]                   2
[18:06:08.214]                 }, immediateCondition = function(cond) {
[18:06:08.214]                   save_rds <- function (object, pathname, ...) 
[18:06:08.214]                   {
[18:06:08.214]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.214]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.214]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.214]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.214]                         fi_tmp[["mtime"]])
[18:06:08.214]                     }
[18:06:08.214]                     tryCatch({
[18:06:08.214]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.214]                     }, error = function(ex) {
[18:06:08.214]                       msg <- conditionMessage(ex)
[18:06:08.214]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.214]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.214]                         fi_tmp[["mtime"]], msg)
[18:06:08.214]                       ex$message <- msg
[18:06:08.214]                       stop(ex)
[18:06:08.214]                     })
[18:06:08.214]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.214]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.214]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.214]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.214]                       fi <- file.info(pathname)
[18:06:08.214]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.214]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.214]                         fi[["size"]], fi[["mtime"]])
[18:06:08.214]                       stop(msg)
[18:06:08.214]                     }
[18:06:08.214]                     invisible(pathname)
[18:06:08.214]                   }
[18:06:08.214]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.214]                     rootPath = tempdir()) 
[18:06:08.214]                   {
[18:06:08.214]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.214]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.214]                       tmpdir = path, fileext = ".rds")
[18:06:08.214]                     save_rds(obj, file)
[18:06:08.214]                   }
[18:06:08.214]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.214]                   {
[18:06:08.214]                     inherits <- base::inherits
[18:06:08.214]                     invokeRestart <- base::invokeRestart
[18:06:08.214]                     is.null <- base::is.null
[18:06:08.214]                     muffled <- FALSE
[18:06:08.214]                     if (inherits(cond, "message")) {
[18:06:08.214]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.214]                       if (muffled) 
[18:06:08.214]                         invokeRestart("muffleMessage")
[18:06:08.214]                     }
[18:06:08.214]                     else if (inherits(cond, "warning")) {
[18:06:08.214]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.214]                       if (muffled) 
[18:06:08.214]                         invokeRestart("muffleWarning")
[18:06:08.214]                     }
[18:06:08.214]                     else if (inherits(cond, "condition")) {
[18:06:08.214]                       if (!is.null(pattern)) {
[18:06:08.214]                         computeRestarts <- base::computeRestarts
[18:06:08.214]                         grepl <- base::grepl
[18:06:08.214]                         restarts <- computeRestarts(cond)
[18:06:08.214]                         for (restart in restarts) {
[18:06:08.214]                           name <- restart$name
[18:06:08.214]                           if (is.null(name)) 
[18:06:08.214]                             next
[18:06:08.214]                           if (!grepl(pattern, name)) 
[18:06:08.214]                             next
[18:06:08.214]                           invokeRestart(restart)
[18:06:08.214]                           muffled <- TRUE
[18:06:08.214]                           break
[18:06:08.214]                         }
[18:06:08.214]                       }
[18:06:08.214]                     }
[18:06:08.214]                     invisible(muffled)
[18:06:08.214]                   }
[18:06:08.214]                   muffleCondition(cond)
[18:06:08.214]                 })
[18:06:08.214]             }))
[18:06:08.214]             future::FutureResult(value = ...future.value$value, 
[18:06:08.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.214]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.214]                     ...future.globalenv.names))
[18:06:08.214]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.214]         }, condition = base::local({
[18:06:08.214]             c <- base::c
[18:06:08.214]             inherits <- base::inherits
[18:06:08.214]             invokeRestart <- base::invokeRestart
[18:06:08.214]             length <- base::length
[18:06:08.214]             list <- base::list
[18:06:08.214]             seq.int <- base::seq.int
[18:06:08.214]             signalCondition <- base::signalCondition
[18:06:08.214]             sys.calls <- base::sys.calls
[18:06:08.214]             `[[` <- base::`[[`
[18:06:08.214]             `+` <- base::`+`
[18:06:08.214]             `<<-` <- base::`<<-`
[18:06:08.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.214]                   3L)]
[18:06:08.214]             }
[18:06:08.214]             function(cond) {
[18:06:08.214]                 is_error <- inherits(cond, "error")
[18:06:08.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.214]                   NULL)
[18:06:08.214]                 if (is_error) {
[18:06:08.214]                   sessionInformation <- function() {
[18:06:08.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.214]                       search = base::search(), system = base::Sys.info())
[18:06:08.214]                   }
[18:06:08.214]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.214]                     cond$call), session = sessionInformation(), 
[18:06:08.214]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.214]                   signalCondition(cond)
[18:06:08.214]                 }
[18:06:08.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.214]                 "immediateCondition"))) {
[18:06:08.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.214]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.214]                   if (TRUE && !signal) {
[18:06:08.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.214]                     {
[18:06:08.214]                       inherits <- base::inherits
[18:06:08.214]                       invokeRestart <- base::invokeRestart
[18:06:08.214]                       is.null <- base::is.null
[18:06:08.214]                       muffled <- FALSE
[18:06:08.214]                       if (inherits(cond, "message")) {
[18:06:08.214]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.214]                         if (muffled) 
[18:06:08.214]                           invokeRestart("muffleMessage")
[18:06:08.214]                       }
[18:06:08.214]                       else if (inherits(cond, "warning")) {
[18:06:08.214]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.214]                         if (muffled) 
[18:06:08.214]                           invokeRestart("muffleWarning")
[18:06:08.214]                       }
[18:06:08.214]                       else if (inherits(cond, "condition")) {
[18:06:08.214]                         if (!is.null(pattern)) {
[18:06:08.214]                           computeRestarts <- base::computeRestarts
[18:06:08.214]                           grepl <- base::grepl
[18:06:08.214]                           restarts <- computeRestarts(cond)
[18:06:08.214]                           for (restart in restarts) {
[18:06:08.214]                             name <- restart$name
[18:06:08.214]                             if (is.null(name)) 
[18:06:08.214]                               next
[18:06:08.214]                             if (!grepl(pattern, name)) 
[18:06:08.214]                               next
[18:06:08.214]                             invokeRestart(restart)
[18:06:08.214]                             muffled <- TRUE
[18:06:08.214]                             break
[18:06:08.214]                           }
[18:06:08.214]                         }
[18:06:08.214]                       }
[18:06:08.214]                       invisible(muffled)
[18:06:08.214]                     }
[18:06:08.214]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.214]                   }
[18:06:08.214]                 }
[18:06:08.214]                 else {
[18:06:08.214]                   if (TRUE) {
[18:06:08.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.214]                     {
[18:06:08.214]                       inherits <- base::inherits
[18:06:08.214]                       invokeRestart <- base::invokeRestart
[18:06:08.214]                       is.null <- base::is.null
[18:06:08.214]                       muffled <- FALSE
[18:06:08.214]                       if (inherits(cond, "message")) {
[18:06:08.214]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.214]                         if (muffled) 
[18:06:08.214]                           invokeRestart("muffleMessage")
[18:06:08.214]                       }
[18:06:08.214]                       else if (inherits(cond, "warning")) {
[18:06:08.214]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.214]                         if (muffled) 
[18:06:08.214]                           invokeRestart("muffleWarning")
[18:06:08.214]                       }
[18:06:08.214]                       else if (inherits(cond, "condition")) {
[18:06:08.214]                         if (!is.null(pattern)) {
[18:06:08.214]                           computeRestarts <- base::computeRestarts
[18:06:08.214]                           grepl <- base::grepl
[18:06:08.214]                           restarts <- computeRestarts(cond)
[18:06:08.214]                           for (restart in restarts) {
[18:06:08.214]                             name <- restart$name
[18:06:08.214]                             if (is.null(name)) 
[18:06:08.214]                               next
[18:06:08.214]                             if (!grepl(pattern, name)) 
[18:06:08.214]                               next
[18:06:08.214]                             invokeRestart(restart)
[18:06:08.214]                             muffled <- TRUE
[18:06:08.214]                             break
[18:06:08.214]                           }
[18:06:08.214]                         }
[18:06:08.214]                       }
[18:06:08.214]                       invisible(muffled)
[18:06:08.214]                     }
[18:06:08.214]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.214]                   }
[18:06:08.214]                 }
[18:06:08.214]             }
[18:06:08.214]         }))
[18:06:08.214]     }, error = function(ex) {
[18:06:08.214]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.214]                 ...future.rng), started = ...future.startTime, 
[18:06:08.214]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.214]             version = "1.8"), class = "FutureResult")
[18:06:08.214]     }, finally = {
[18:06:08.214]         if (!identical(...future.workdir, getwd())) 
[18:06:08.214]             setwd(...future.workdir)
[18:06:08.214]         {
[18:06:08.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.214]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.214]             }
[18:06:08.214]             base::options(...future.oldOptions)
[18:06:08.214]             if (.Platform$OS.type == "windows") {
[18:06:08.214]                 old_names <- names(...future.oldEnvVars)
[18:06:08.214]                 envs <- base::Sys.getenv()
[18:06:08.214]                 names <- names(envs)
[18:06:08.214]                 common <- intersect(names, old_names)
[18:06:08.214]                 added <- setdiff(names, old_names)
[18:06:08.214]                 removed <- setdiff(old_names, names)
[18:06:08.214]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.214]                   envs[common]]
[18:06:08.214]                 NAMES <- toupper(changed)
[18:06:08.214]                 args <- list()
[18:06:08.214]                 for (kk in seq_along(NAMES)) {
[18:06:08.214]                   name <- changed[[kk]]
[18:06:08.214]                   NAME <- NAMES[[kk]]
[18:06:08.214]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.214]                     next
[18:06:08.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.214]                 }
[18:06:08.214]                 NAMES <- toupper(added)
[18:06:08.214]                 for (kk in seq_along(NAMES)) {
[18:06:08.214]                   name <- added[[kk]]
[18:06:08.214]                   NAME <- NAMES[[kk]]
[18:06:08.214]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.214]                     next
[18:06:08.214]                   args[[name]] <- ""
[18:06:08.214]                 }
[18:06:08.214]                 NAMES <- toupper(removed)
[18:06:08.214]                 for (kk in seq_along(NAMES)) {
[18:06:08.214]                   name <- removed[[kk]]
[18:06:08.214]                   NAME <- NAMES[[kk]]
[18:06:08.214]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.214]                     next
[18:06:08.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.214]                 }
[18:06:08.214]                 if (length(args) > 0) 
[18:06:08.214]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.214]             }
[18:06:08.214]             else {
[18:06:08.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.214]             }
[18:06:08.214]             {
[18:06:08.214]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.214]                   0L) {
[18:06:08.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.214]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.214]                   base::options(opts)
[18:06:08.214]                 }
[18:06:08.214]                 {
[18:06:08.214]                   {
[18:06:08.214]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.214]                     NULL
[18:06:08.214]                   }
[18:06:08.214]                   options(future.plan = NULL)
[18:06:08.214]                   if (is.na(NA_character_)) 
[18:06:08.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.214]                     .init = FALSE)
[18:06:08.214]                 }
[18:06:08.214]             }
[18:06:08.214]         }
[18:06:08.214]     })
[18:06:08.214]     if (TRUE) {
[18:06:08.214]         base::sink(type = "output", split = FALSE)
[18:06:08.214]         if (TRUE) {
[18:06:08.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.214]         }
[18:06:08.214]         else {
[18:06:08.214]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.214]         }
[18:06:08.214]         base::close(...future.stdout)
[18:06:08.214]         ...future.stdout <- NULL
[18:06:08.214]     }
[18:06:08.214]     ...future.result$conditions <- ...future.conditions
[18:06:08.214]     ...future.result$finished <- base::Sys.time()
[18:06:08.214]     ...future.result
[18:06:08.214] }
[18:06:08.221] requestCore(): workers = 2
[18:06:08.222] plan(): nbrOfWorkers() = 2
[18:06:08.222] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.234] result() for MulticoreFuture ...
[18:06:08.236] result() for MulticoreFuture ...
[18:06:08.236] result() for MulticoreFuture ... done
[18:06:08.236] result() for MulticoreFuture ... done
[18:06:08.239] result() for MulticoreFuture ...
[18:06:08.239] result() for MulticoreFuture ... done
[18:06:08.249] MulticoreFuture started
[18:06:08.250] - Launch lazy future ... done
[18:06:08.252] plan(): Setting new future strategy stack:
[18:06:08.250] run() for ‘MulticoreFuture’ ... done
[18:06:08.252] List of future strategies:
[18:06:08.252] 1. sequential:
[18:06:08.252]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.252]    - tweaked: FALSE
[18:06:08.252]    - call: NULL
[18:06:08.257] resolve() on environment ...
[18:06:08.258]  recursive: 0
[18:06:08.259] plan(): nbrOfWorkers() = 1
[18:06:08.262]  elements: [3] ‘a’, ‘b’, ‘c’
[18:06:08.265] Future #1
[18:06:08.266]  length: 2 (resolved future 1)
[18:06:08.267] plan(): Setting new future strategy stack:
[18:06:08.267] List of future strategies:
[18:06:08.267] 1. multicore:
[18:06:08.267]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.267]    - tweaked: FALSE
[18:06:08.267]    - call: plan(strategy)
[18:06:08.277] plan(): nbrOfWorkers() = 2
[18:06:08.277]  length: 1 (resolved future 3)
[18:06:08.289] Future #2
[18:06:08.289]  length: 0 (resolved future 2)
[18:06:08.289] resolve() on environment ... DONE
[18:06:08.292] getGlobalsAndPackages() ...
[18:06:08.293] Searching for globals...
[18:06:08.295] - globals found: [1] ‘{’
[18:06:08.295] Searching for globals ... DONE
[18:06:08.296] Resolving globals: FALSE
[18:06:08.297] 
[18:06:08.297] 
[18:06:08.297] getGlobalsAndPackages() ... DONE
[18:06:08.298] run() for ‘Future’ ...
[18:06:08.299] - state: ‘created’
[18:06:08.299] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.307] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.308]   - Field: ‘label’
[18:06:08.308]   - Field: ‘local’
[18:06:08.308]   - Field: ‘owner’
[18:06:08.309]   - Field: ‘envir’
[18:06:08.309]   - Field: ‘workers’
[18:06:08.309]   - Field: ‘packages’
[18:06:08.310]   - Field: ‘gc’
[18:06:08.310]   - Field: ‘job’
[18:06:08.310]   - Field: ‘conditions’
[18:06:08.311]   - Field: ‘expr’
[18:06:08.311]   - Field: ‘uuid’
[18:06:08.311]   - Field: ‘seed’
[18:06:08.312]   - Field: ‘version’
[18:06:08.312]   - Field: ‘result’
[18:06:08.312]   - Field: ‘asynchronous’
[18:06:08.312]   - Field: ‘calls’
[18:06:08.313]   - Field: ‘globals’
[18:06:08.313]   - Field: ‘stdout’
[18:06:08.313]   - Field: ‘earlySignal’
[18:06:08.314]   - Field: ‘lazy’
[18:06:08.314]   - Field: ‘state’
[18:06:08.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.315] - Launch lazy future ...
[18:06:08.315] Packages needed by the future expression (n = 0): <none>
[18:06:08.316] Packages needed by future strategies (n = 0): <none>
[18:06:08.323] {
[18:06:08.323]     {
[18:06:08.323]         {
[18:06:08.323]             ...future.startTime <- base::Sys.time()
[18:06:08.323]             {
[18:06:08.323]                 {
[18:06:08.323]                   {
[18:06:08.323]                     {
[18:06:08.323]                       base::local({
[18:06:08.323]                         has_future <- base::requireNamespace("future", 
[18:06:08.323]                           quietly = TRUE)
[18:06:08.323]                         if (has_future) {
[18:06:08.323]                           ns <- base::getNamespace("future")
[18:06:08.323]                           version <- ns[[".package"]][["version"]]
[18:06:08.323]                           if (is.null(version)) 
[18:06:08.323]                             version <- utils::packageVersion("future")
[18:06:08.323]                         }
[18:06:08.323]                         else {
[18:06:08.323]                           version <- NULL
[18:06:08.323]                         }
[18:06:08.323]                         if (!has_future || version < "1.8.0") {
[18:06:08.323]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.323]                             "", base::R.version$version.string), 
[18:06:08.323]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.323]                               "release", "version")], collapse = " "), 
[18:06:08.323]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.323]                             info)
[18:06:08.323]                           info <- base::paste(info, collapse = "; ")
[18:06:08.323]                           if (!has_future) {
[18:06:08.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.323]                               info)
[18:06:08.323]                           }
[18:06:08.323]                           else {
[18:06:08.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.323]                               info, version)
[18:06:08.323]                           }
[18:06:08.323]                           base::stop(msg)
[18:06:08.323]                         }
[18:06:08.323]                       })
[18:06:08.323]                     }
[18:06:08.323]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.323]                     base::options(mc.cores = 1L)
[18:06:08.323]                   }
[18:06:08.323]                   ...future.strategy.old <- future::plan("list")
[18:06:08.323]                   options(future.plan = NULL)
[18:06:08.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.323]                 }
[18:06:08.323]                 ...future.workdir <- getwd()
[18:06:08.323]             }
[18:06:08.323]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.323]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.323]         }
[18:06:08.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.323]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.323]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.323]             base::names(...future.oldOptions))
[18:06:08.323]     }
[18:06:08.323]     if (FALSE) {
[18:06:08.323]     }
[18:06:08.323]     else {
[18:06:08.323]         if (TRUE) {
[18:06:08.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.323]                 open = "w")
[18:06:08.323]         }
[18:06:08.323]         else {
[18:06:08.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.323]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.323]         }
[18:06:08.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.323]             base::sink(type = "output", split = FALSE)
[18:06:08.323]             base::close(...future.stdout)
[18:06:08.323]         }, add = TRUE)
[18:06:08.323]     }
[18:06:08.323]     ...future.frame <- base::sys.nframe()
[18:06:08.323]     ...future.conditions <- base::list()
[18:06:08.323]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.323]     if (FALSE) {
[18:06:08.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.323]     }
[18:06:08.323]     ...future.result <- base::tryCatch({
[18:06:08.323]         base::withCallingHandlers({
[18:06:08.323]             ...future.value <- base::withVisible(base::local({
[18:06:08.323]                 withCallingHandlers({
[18:06:08.323]                   {
[18:06:08.323]                     1
[18:06:08.323]                   }
[18:06:08.323]                 }, immediateCondition = function(cond) {
[18:06:08.323]                   save_rds <- function (object, pathname, ...) 
[18:06:08.323]                   {
[18:06:08.323]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.323]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.323]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.323]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.323]                         fi_tmp[["mtime"]])
[18:06:08.323]                     }
[18:06:08.323]                     tryCatch({
[18:06:08.323]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.323]                     }, error = function(ex) {
[18:06:08.323]                       msg <- conditionMessage(ex)
[18:06:08.323]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.323]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.323]                         fi_tmp[["mtime"]], msg)
[18:06:08.323]                       ex$message <- msg
[18:06:08.323]                       stop(ex)
[18:06:08.323]                     })
[18:06:08.323]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.323]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.323]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.323]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.323]                       fi <- file.info(pathname)
[18:06:08.323]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.323]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.323]                         fi[["size"]], fi[["mtime"]])
[18:06:08.323]                       stop(msg)
[18:06:08.323]                     }
[18:06:08.323]                     invisible(pathname)
[18:06:08.323]                   }
[18:06:08.323]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.323]                     rootPath = tempdir()) 
[18:06:08.323]                   {
[18:06:08.323]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.323]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.323]                       tmpdir = path, fileext = ".rds")
[18:06:08.323]                     save_rds(obj, file)
[18:06:08.323]                   }
[18:06:08.323]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.323]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.323]                   {
[18:06:08.323]                     inherits <- base::inherits
[18:06:08.323]                     invokeRestart <- base::invokeRestart
[18:06:08.323]                     is.null <- base::is.null
[18:06:08.323]                     muffled <- FALSE
[18:06:08.323]                     if (inherits(cond, "message")) {
[18:06:08.323]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.323]                       if (muffled) 
[18:06:08.323]                         invokeRestart("muffleMessage")
[18:06:08.323]                     }
[18:06:08.323]                     else if (inherits(cond, "warning")) {
[18:06:08.323]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.323]                       if (muffled) 
[18:06:08.323]                         invokeRestart("muffleWarning")
[18:06:08.323]                     }
[18:06:08.323]                     else if (inherits(cond, "condition")) {
[18:06:08.323]                       if (!is.null(pattern)) {
[18:06:08.323]                         computeRestarts <- base::computeRestarts
[18:06:08.323]                         grepl <- base::grepl
[18:06:08.323]                         restarts <- computeRestarts(cond)
[18:06:08.323]                         for (restart in restarts) {
[18:06:08.323]                           name <- restart$name
[18:06:08.323]                           if (is.null(name)) 
[18:06:08.323]                             next
[18:06:08.323]                           if (!grepl(pattern, name)) 
[18:06:08.323]                             next
[18:06:08.323]                           invokeRestart(restart)
[18:06:08.323]                           muffled <- TRUE
[18:06:08.323]                           break
[18:06:08.323]                         }
[18:06:08.323]                       }
[18:06:08.323]                     }
[18:06:08.323]                     invisible(muffled)
[18:06:08.323]                   }
[18:06:08.323]                   muffleCondition(cond)
[18:06:08.323]                 })
[18:06:08.323]             }))
[18:06:08.323]             future::FutureResult(value = ...future.value$value, 
[18:06:08.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.323]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.323]                     ...future.globalenv.names))
[18:06:08.323]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.323]         }, condition = base::local({
[18:06:08.323]             c <- base::c
[18:06:08.323]             inherits <- base::inherits
[18:06:08.323]             invokeRestart <- base::invokeRestart
[18:06:08.323]             length <- base::length
[18:06:08.323]             list <- base::list
[18:06:08.323]             seq.int <- base::seq.int
[18:06:08.323]             signalCondition <- base::signalCondition
[18:06:08.323]             sys.calls <- base::sys.calls
[18:06:08.323]             `[[` <- base::`[[`
[18:06:08.323]             `+` <- base::`+`
[18:06:08.323]             `<<-` <- base::`<<-`
[18:06:08.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.323]                   3L)]
[18:06:08.323]             }
[18:06:08.323]             function(cond) {
[18:06:08.323]                 is_error <- inherits(cond, "error")
[18:06:08.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.323]                   NULL)
[18:06:08.323]                 if (is_error) {
[18:06:08.323]                   sessionInformation <- function() {
[18:06:08.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.323]                       search = base::search(), system = base::Sys.info())
[18:06:08.323]                   }
[18:06:08.323]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.323]                     cond$call), session = sessionInformation(), 
[18:06:08.323]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.323]                   signalCondition(cond)
[18:06:08.323]                 }
[18:06:08.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.323]                 "immediateCondition"))) {
[18:06:08.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.323]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.323]                   if (TRUE && !signal) {
[18:06:08.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.323]                     {
[18:06:08.323]                       inherits <- base::inherits
[18:06:08.323]                       invokeRestart <- base::invokeRestart
[18:06:08.323]                       is.null <- base::is.null
[18:06:08.323]                       muffled <- FALSE
[18:06:08.323]                       if (inherits(cond, "message")) {
[18:06:08.323]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.323]                         if (muffled) 
[18:06:08.323]                           invokeRestart("muffleMessage")
[18:06:08.323]                       }
[18:06:08.323]                       else if (inherits(cond, "warning")) {
[18:06:08.323]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.323]                         if (muffled) 
[18:06:08.323]                           invokeRestart("muffleWarning")
[18:06:08.323]                       }
[18:06:08.323]                       else if (inherits(cond, "condition")) {
[18:06:08.323]                         if (!is.null(pattern)) {
[18:06:08.323]                           computeRestarts <- base::computeRestarts
[18:06:08.323]                           grepl <- base::grepl
[18:06:08.323]                           restarts <- computeRestarts(cond)
[18:06:08.323]                           for (restart in restarts) {
[18:06:08.323]                             name <- restart$name
[18:06:08.323]                             if (is.null(name)) 
[18:06:08.323]                               next
[18:06:08.323]                             if (!grepl(pattern, name)) 
[18:06:08.323]                               next
[18:06:08.323]                             invokeRestart(restart)
[18:06:08.323]                             muffled <- TRUE
[18:06:08.323]                             break
[18:06:08.323]                           }
[18:06:08.323]                         }
[18:06:08.323]                       }
[18:06:08.323]                       invisible(muffled)
[18:06:08.323]                     }
[18:06:08.323]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.323]                   }
[18:06:08.323]                 }
[18:06:08.323]                 else {
[18:06:08.323]                   if (TRUE) {
[18:06:08.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.323]                     {
[18:06:08.323]                       inherits <- base::inherits
[18:06:08.323]                       invokeRestart <- base::invokeRestart
[18:06:08.323]                       is.null <- base::is.null
[18:06:08.323]                       muffled <- FALSE
[18:06:08.323]                       if (inherits(cond, "message")) {
[18:06:08.323]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.323]                         if (muffled) 
[18:06:08.323]                           invokeRestart("muffleMessage")
[18:06:08.323]                       }
[18:06:08.323]                       else if (inherits(cond, "warning")) {
[18:06:08.323]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.323]                         if (muffled) 
[18:06:08.323]                           invokeRestart("muffleWarning")
[18:06:08.323]                       }
[18:06:08.323]                       else if (inherits(cond, "condition")) {
[18:06:08.323]                         if (!is.null(pattern)) {
[18:06:08.323]                           computeRestarts <- base::computeRestarts
[18:06:08.323]                           grepl <- base::grepl
[18:06:08.323]                           restarts <- computeRestarts(cond)
[18:06:08.323]                           for (restart in restarts) {
[18:06:08.323]                             name <- restart$name
[18:06:08.323]                             if (is.null(name)) 
[18:06:08.323]                               next
[18:06:08.323]                             if (!grepl(pattern, name)) 
[18:06:08.323]                               next
[18:06:08.323]                             invokeRestart(restart)
[18:06:08.323]                             muffled <- TRUE
[18:06:08.323]                             break
[18:06:08.323]                           }
[18:06:08.323]                         }
[18:06:08.323]                       }
[18:06:08.323]                       invisible(muffled)
[18:06:08.323]                     }
[18:06:08.323]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.323]                   }
[18:06:08.323]                 }
[18:06:08.323]             }
[18:06:08.323]         }))
[18:06:08.323]     }, error = function(ex) {
[18:06:08.323]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.323]                 ...future.rng), started = ...future.startTime, 
[18:06:08.323]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.323]             version = "1.8"), class = "FutureResult")
[18:06:08.323]     }, finally = {
[18:06:08.323]         if (!identical(...future.workdir, getwd())) 
[18:06:08.323]             setwd(...future.workdir)
[18:06:08.323]         {
[18:06:08.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.323]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.323]             }
[18:06:08.323]             base::options(...future.oldOptions)
[18:06:08.323]             if (.Platform$OS.type == "windows") {
[18:06:08.323]                 old_names <- names(...future.oldEnvVars)
[18:06:08.323]                 envs <- base::Sys.getenv()
[18:06:08.323]                 names <- names(envs)
[18:06:08.323]                 common <- intersect(names, old_names)
[18:06:08.323]                 added <- setdiff(names, old_names)
[18:06:08.323]                 removed <- setdiff(old_names, names)
[18:06:08.323]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.323]                   envs[common]]
[18:06:08.323]                 NAMES <- toupper(changed)
[18:06:08.323]                 args <- list()
[18:06:08.323]                 for (kk in seq_along(NAMES)) {
[18:06:08.323]                   name <- changed[[kk]]
[18:06:08.323]                   NAME <- NAMES[[kk]]
[18:06:08.323]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.323]                     next
[18:06:08.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.323]                 }
[18:06:08.323]                 NAMES <- toupper(added)
[18:06:08.323]                 for (kk in seq_along(NAMES)) {
[18:06:08.323]                   name <- added[[kk]]
[18:06:08.323]                   NAME <- NAMES[[kk]]
[18:06:08.323]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.323]                     next
[18:06:08.323]                   args[[name]] <- ""
[18:06:08.323]                 }
[18:06:08.323]                 NAMES <- toupper(removed)
[18:06:08.323]                 for (kk in seq_along(NAMES)) {
[18:06:08.323]                   name <- removed[[kk]]
[18:06:08.323]                   NAME <- NAMES[[kk]]
[18:06:08.323]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.323]                     next
[18:06:08.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.323]                 }
[18:06:08.323]                 if (length(args) > 0) 
[18:06:08.323]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.323]             }
[18:06:08.323]             else {
[18:06:08.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.323]             }
[18:06:08.323]             {
[18:06:08.323]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.323]                   0L) {
[18:06:08.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.323]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.323]                   base::options(opts)
[18:06:08.323]                 }
[18:06:08.323]                 {
[18:06:08.323]                   {
[18:06:08.323]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.323]                     NULL
[18:06:08.323]                   }
[18:06:08.323]                   options(future.plan = NULL)
[18:06:08.323]                   if (is.na(NA_character_)) 
[18:06:08.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.323]                     .init = FALSE)
[18:06:08.323]                 }
[18:06:08.323]             }
[18:06:08.323]         }
[18:06:08.323]     })
[18:06:08.323]     if (TRUE) {
[18:06:08.323]         base::sink(type = "output", split = FALSE)
[18:06:08.323]         if (TRUE) {
[18:06:08.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.323]         }
[18:06:08.323]         else {
[18:06:08.323]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.323]         }
[18:06:08.323]         base::close(...future.stdout)
[18:06:08.323]         ...future.stdout <- NULL
[18:06:08.323]     }
[18:06:08.323]     ...future.result$conditions <- ...future.conditions
[18:06:08.323]     ...future.result$finished <- base::Sys.time()
[18:06:08.323]     ...future.result
[18:06:08.323] }
[18:06:08.329] requestCore(): workers = 2
[18:06:08.330] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.343] result() for MulticoreFuture ...
[18:06:08.347] result() for MulticoreFuture ...
[18:06:08.347] result() for MulticoreFuture ... done
[18:06:08.350] result() for MulticoreFuture ... done
[18:06:08.350] result() for MulticoreFuture ...
[18:06:08.351] result() for MulticoreFuture ... done
[18:06:08.357] MulticoreFuture started
[18:06:08.358] - Launch lazy future ... done
[18:06:08.359] run() for ‘MulticoreFuture’ ... done
[18:06:08.361] getGlobalsAndPackages() ...
[18:06:08.362] plan(): Setting new future strategy stack:
[18:06:08.362] Searching for globals...
[18:06:08.366] - globals found: [1] ‘{’
[18:06:08.367] Searching for globals ... DONE
[18:06:08.367] Resolving globals: FALSE
[18:06:08.362] List of future strategies:
[18:06:08.362] 1. sequential:
[18:06:08.362]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.362]    - tweaked: FALSE
[18:06:08.362]    - call: NULL
[18:06:08.368] 
[18:06:08.369] 
[18:06:08.369] getGlobalsAndPackages() ... DONE
[18:06:08.369] plan(): nbrOfWorkers() = 1
[18:06:08.370] run() for ‘Future’ ...
[18:06:08.371] - state: ‘created’
[18:06:08.371] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.379] plan(): Setting new future strategy stack:
[18:06:08.380] List of future strategies:
[18:06:08.380] 1. multicore:
[18:06:08.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.380]    - tweaked: FALSE
[18:06:08.380]    - call: plan(strategy)
[18:06:08.388] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.388] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.389]   - Field: ‘label’
[18:06:08.389]   - Field: ‘local’
[18:06:08.389]   - Field: ‘owner’
[18:06:08.390]   - Field: ‘envir’
[18:06:08.391]   - Field: ‘workers’
[18:06:08.392]   - Field: ‘packages’
[18:06:08.392]   - Field: ‘gc’
[18:06:08.392]   - Field: ‘job’
[18:06:08.393]   - Field: ‘conditions’
[18:06:08.393]   - Field: ‘expr’
[18:06:08.393]   - Field: ‘uuid’
[18:06:08.394]   - Field: ‘seed’
[18:06:08.394]   - Field: ‘version’
[18:06:08.394]   - Field: ‘result’
[18:06:08.395]   - Field: ‘asynchronous’
[18:06:08.395]   - Field: ‘calls’
[18:06:08.395]   - Field: ‘globals’
[18:06:08.396]   - Field: ‘stdout’
[18:06:08.396]   - Field: ‘earlySignal’
[18:06:08.396]   - Field: ‘lazy’
[18:06:08.396] plan(): nbrOfWorkers() = 2
[18:06:08.397]   - Field: ‘state’
[18:06:08.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.397] - Launch lazy future ...
[18:06:08.398] Packages needed by the future expression (n = 0): <none>
[18:06:08.399] Packages needed by future strategies (n = 0): <none>
[18:06:08.400] {
[18:06:08.400]     {
[18:06:08.400]         {
[18:06:08.400]             ...future.startTime <- base::Sys.time()
[18:06:08.400]             {
[18:06:08.400]                 {
[18:06:08.400]                   {
[18:06:08.400]                     {
[18:06:08.400]                       base::local({
[18:06:08.400]                         has_future <- base::requireNamespace("future", 
[18:06:08.400]                           quietly = TRUE)
[18:06:08.400]                         if (has_future) {
[18:06:08.400]                           ns <- base::getNamespace("future")
[18:06:08.400]                           version <- ns[[".package"]][["version"]]
[18:06:08.400]                           if (is.null(version)) 
[18:06:08.400]                             version <- utils::packageVersion("future")
[18:06:08.400]                         }
[18:06:08.400]                         else {
[18:06:08.400]                           version <- NULL
[18:06:08.400]                         }
[18:06:08.400]                         if (!has_future || version < "1.8.0") {
[18:06:08.400]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.400]                             "", base::R.version$version.string), 
[18:06:08.400]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.400]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.400]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.400]                               "release", "version")], collapse = " "), 
[18:06:08.400]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.400]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.400]                             info)
[18:06:08.400]                           info <- base::paste(info, collapse = "; ")
[18:06:08.400]                           if (!has_future) {
[18:06:08.400]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.400]                               info)
[18:06:08.400]                           }
[18:06:08.400]                           else {
[18:06:08.400]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.400]                               info, version)
[18:06:08.400]                           }
[18:06:08.400]                           base::stop(msg)
[18:06:08.400]                         }
[18:06:08.400]                       })
[18:06:08.400]                     }
[18:06:08.400]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.400]                     base::options(mc.cores = 1L)
[18:06:08.400]                   }
[18:06:08.400]                   ...future.strategy.old <- future::plan("list")
[18:06:08.400]                   options(future.plan = NULL)
[18:06:08.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.400]                 }
[18:06:08.400]                 ...future.workdir <- getwd()
[18:06:08.400]             }
[18:06:08.400]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.400]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.400]         }
[18:06:08.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.400]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.400]             base::names(...future.oldOptions))
[18:06:08.400]     }
[18:06:08.400]     if (FALSE) {
[18:06:08.400]     }
[18:06:08.400]     else {
[18:06:08.400]         if (TRUE) {
[18:06:08.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.400]                 open = "w")
[18:06:08.400]         }
[18:06:08.400]         else {
[18:06:08.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.400]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.400]         }
[18:06:08.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.400]             base::sink(type = "output", split = FALSE)
[18:06:08.400]             base::close(...future.stdout)
[18:06:08.400]         }, add = TRUE)
[18:06:08.400]     }
[18:06:08.400]     ...future.frame <- base::sys.nframe()
[18:06:08.400]     ...future.conditions <- base::list()
[18:06:08.400]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.400]     if (FALSE) {
[18:06:08.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.400]     }
[18:06:08.400]     ...future.result <- base::tryCatch({
[18:06:08.400]         base::withCallingHandlers({
[18:06:08.400]             ...future.value <- base::withVisible(base::local({
[18:06:08.400]                 withCallingHandlers({
[18:06:08.400]                   {
[18:06:08.400]                     2
[18:06:08.400]                   }
[18:06:08.400]                 }, immediateCondition = function(cond) {
[18:06:08.400]                   save_rds <- function (object, pathname, ...) 
[18:06:08.400]                   {
[18:06:08.400]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.400]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.400]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.400]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.400]                         fi_tmp[["mtime"]])
[18:06:08.400]                     }
[18:06:08.400]                     tryCatch({
[18:06:08.400]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.400]                     }, error = function(ex) {
[18:06:08.400]                       msg <- conditionMessage(ex)
[18:06:08.400]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.400]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.400]                         fi_tmp[["mtime"]], msg)
[18:06:08.400]                       ex$message <- msg
[18:06:08.400]                       stop(ex)
[18:06:08.400]                     })
[18:06:08.400]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.400]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.400]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.400]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.400]                       fi <- file.info(pathname)
[18:06:08.400]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.400]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.400]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.400]                         fi[["size"]], fi[["mtime"]])
[18:06:08.400]                       stop(msg)
[18:06:08.400]                     }
[18:06:08.400]                     invisible(pathname)
[18:06:08.400]                   }
[18:06:08.400]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.400]                     rootPath = tempdir()) 
[18:06:08.400]                   {
[18:06:08.400]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.400]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.400]                       tmpdir = path, fileext = ".rds")
[18:06:08.400]                     save_rds(obj, file)
[18:06:08.400]                   }
[18:06:08.400]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.400]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.400]                   {
[18:06:08.400]                     inherits <- base::inherits
[18:06:08.400]                     invokeRestart <- base::invokeRestart
[18:06:08.400]                     is.null <- base::is.null
[18:06:08.400]                     muffled <- FALSE
[18:06:08.400]                     if (inherits(cond, "message")) {
[18:06:08.400]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.400]                       if (muffled) 
[18:06:08.400]                         invokeRestart("muffleMessage")
[18:06:08.400]                     }
[18:06:08.400]                     else if (inherits(cond, "warning")) {
[18:06:08.400]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.400]                       if (muffled) 
[18:06:08.400]                         invokeRestart("muffleWarning")
[18:06:08.400]                     }
[18:06:08.400]                     else if (inherits(cond, "condition")) {
[18:06:08.400]                       if (!is.null(pattern)) {
[18:06:08.400]                         computeRestarts <- base::computeRestarts
[18:06:08.400]                         grepl <- base::grepl
[18:06:08.400]                         restarts <- computeRestarts(cond)
[18:06:08.400]                         for (restart in restarts) {
[18:06:08.400]                           name <- restart$name
[18:06:08.400]                           if (is.null(name)) 
[18:06:08.400]                             next
[18:06:08.400]                           if (!grepl(pattern, name)) 
[18:06:08.400]                             next
[18:06:08.400]                           invokeRestart(restart)
[18:06:08.400]                           muffled <- TRUE
[18:06:08.400]                           break
[18:06:08.400]                         }
[18:06:08.400]                       }
[18:06:08.400]                     }
[18:06:08.400]                     invisible(muffled)
[18:06:08.400]                   }
[18:06:08.400]                   muffleCondition(cond)
[18:06:08.400]                 })
[18:06:08.400]             }))
[18:06:08.400]             future::FutureResult(value = ...future.value$value, 
[18:06:08.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.400]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.400]                     ...future.globalenv.names))
[18:06:08.400]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.400]         }, condition = base::local({
[18:06:08.400]             c <- base::c
[18:06:08.400]             inherits <- base::inherits
[18:06:08.400]             invokeRestart <- base::invokeRestart
[18:06:08.400]             length <- base::length
[18:06:08.400]             list <- base::list
[18:06:08.400]             seq.int <- base::seq.int
[18:06:08.400]             signalCondition <- base::signalCondition
[18:06:08.400]             sys.calls <- base::sys.calls
[18:06:08.400]             `[[` <- base::`[[`
[18:06:08.400]             `+` <- base::`+`
[18:06:08.400]             `<<-` <- base::`<<-`
[18:06:08.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.400]                   3L)]
[18:06:08.400]             }
[18:06:08.400]             function(cond) {
[18:06:08.400]                 is_error <- inherits(cond, "error")
[18:06:08.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.400]                   NULL)
[18:06:08.400]                 if (is_error) {
[18:06:08.400]                   sessionInformation <- function() {
[18:06:08.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.400]                       search = base::search(), system = base::Sys.info())
[18:06:08.400]                   }
[18:06:08.400]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.400]                     cond$call), session = sessionInformation(), 
[18:06:08.400]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.400]                   signalCondition(cond)
[18:06:08.400]                 }
[18:06:08.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.400]                 "immediateCondition"))) {
[18:06:08.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.400]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.400]                   if (TRUE && !signal) {
[18:06:08.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.400]                     {
[18:06:08.400]                       inherits <- base::inherits
[18:06:08.400]                       invokeRestart <- base::invokeRestart
[18:06:08.400]                       is.null <- base::is.null
[18:06:08.400]                       muffled <- FALSE
[18:06:08.400]                       if (inherits(cond, "message")) {
[18:06:08.400]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.400]                         if (muffled) 
[18:06:08.400]                           invokeRestart("muffleMessage")
[18:06:08.400]                       }
[18:06:08.400]                       else if (inherits(cond, "warning")) {
[18:06:08.400]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.400]                         if (muffled) 
[18:06:08.400]                           invokeRestart("muffleWarning")
[18:06:08.400]                       }
[18:06:08.400]                       else if (inherits(cond, "condition")) {
[18:06:08.400]                         if (!is.null(pattern)) {
[18:06:08.400]                           computeRestarts <- base::computeRestarts
[18:06:08.400]                           grepl <- base::grepl
[18:06:08.400]                           restarts <- computeRestarts(cond)
[18:06:08.400]                           for (restart in restarts) {
[18:06:08.400]                             name <- restart$name
[18:06:08.400]                             if (is.null(name)) 
[18:06:08.400]                               next
[18:06:08.400]                             if (!grepl(pattern, name)) 
[18:06:08.400]                               next
[18:06:08.400]                             invokeRestart(restart)
[18:06:08.400]                             muffled <- TRUE
[18:06:08.400]                             break
[18:06:08.400]                           }
[18:06:08.400]                         }
[18:06:08.400]                       }
[18:06:08.400]                       invisible(muffled)
[18:06:08.400]                     }
[18:06:08.400]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.400]                   }
[18:06:08.400]                 }
[18:06:08.400]                 else {
[18:06:08.400]                   if (TRUE) {
[18:06:08.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.400]                     {
[18:06:08.400]                       inherits <- base::inherits
[18:06:08.400]                       invokeRestart <- base::invokeRestart
[18:06:08.400]                       is.null <- base::is.null
[18:06:08.400]                       muffled <- FALSE
[18:06:08.400]                       if (inherits(cond, "message")) {
[18:06:08.400]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.400]                         if (muffled) 
[18:06:08.400]                           invokeRestart("muffleMessage")
[18:06:08.400]                       }
[18:06:08.400]                       else if (inherits(cond, "warning")) {
[18:06:08.400]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.400]                         if (muffled) 
[18:06:08.400]                           invokeRestart("muffleWarning")
[18:06:08.400]                       }
[18:06:08.400]                       else if (inherits(cond, "condition")) {
[18:06:08.400]                         if (!is.null(pattern)) {
[18:06:08.400]                           computeRestarts <- base::computeRestarts
[18:06:08.400]                           grepl <- base::grepl
[18:06:08.400]                           restarts <- computeRestarts(cond)
[18:06:08.400]                           for (restart in restarts) {
[18:06:08.400]                             name <- restart$name
[18:06:08.400]                             if (is.null(name)) 
[18:06:08.400]                               next
[18:06:08.400]                             if (!grepl(pattern, name)) 
[18:06:08.400]                               next
[18:06:08.400]                             invokeRestart(restart)
[18:06:08.400]                             muffled <- TRUE
[18:06:08.400]                             break
[18:06:08.400]                           }
[18:06:08.400]                         }
[18:06:08.400]                       }
[18:06:08.400]                       invisible(muffled)
[18:06:08.400]                     }
[18:06:08.400]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.400]                   }
[18:06:08.400]                 }
[18:06:08.400]             }
[18:06:08.400]         }))
[18:06:08.400]     }, error = function(ex) {
[18:06:08.400]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.400]                 ...future.rng), started = ...future.startTime, 
[18:06:08.400]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.400]             version = "1.8"), class = "FutureResult")
[18:06:08.400]     }, finally = {
[18:06:08.400]         if (!identical(...future.workdir, getwd())) 
[18:06:08.400]             setwd(...future.workdir)
[18:06:08.400]         {
[18:06:08.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.400]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.400]             }
[18:06:08.400]             base::options(...future.oldOptions)
[18:06:08.400]             if (.Platform$OS.type == "windows") {
[18:06:08.400]                 old_names <- names(...future.oldEnvVars)
[18:06:08.400]                 envs <- base::Sys.getenv()
[18:06:08.400]                 names <- names(envs)
[18:06:08.400]                 common <- intersect(names, old_names)
[18:06:08.400]                 added <- setdiff(names, old_names)
[18:06:08.400]                 removed <- setdiff(old_names, names)
[18:06:08.400]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.400]                   envs[common]]
[18:06:08.400]                 NAMES <- toupper(changed)
[18:06:08.400]                 args <- list()
[18:06:08.400]                 for (kk in seq_along(NAMES)) {
[18:06:08.400]                   name <- changed[[kk]]
[18:06:08.400]                   NAME <- NAMES[[kk]]
[18:06:08.400]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.400]                     next
[18:06:08.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.400]                 }
[18:06:08.400]                 NAMES <- toupper(added)
[18:06:08.400]                 for (kk in seq_along(NAMES)) {
[18:06:08.400]                   name <- added[[kk]]
[18:06:08.400]                   NAME <- NAMES[[kk]]
[18:06:08.400]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.400]                     next
[18:06:08.400]                   args[[name]] <- ""
[18:06:08.400]                 }
[18:06:08.400]                 NAMES <- toupper(removed)
[18:06:08.400]                 for (kk in seq_along(NAMES)) {
[18:06:08.400]                   name <- removed[[kk]]
[18:06:08.400]                   NAME <- NAMES[[kk]]
[18:06:08.400]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.400]                     next
[18:06:08.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.400]                 }
[18:06:08.400]                 if (length(args) > 0) 
[18:06:08.400]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.400]             }
[18:06:08.400]             else {
[18:06:08.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.400]             }
[18:06:08.400]             {
[18:06:08.400]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.400]                   0L) {
[18:06:08.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.400]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.400]                   base::options(opts)
[18:06:08.400]                 }
[18:06:08.400]                 {
[18:06:08.400]                   {
[18:06:08.400]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.400]                     NULL
[18:06:08.400]                   }
[18:06:08.400]                   options(future.plan = NULL)
[18:06:08.400]                   if (is.na(NA_character_)) 
[18:06:08.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.400]                     .init = FALSE)
[18:06:08.400]                 }
[18:06:08.400]             }
[18:06:08.400]         }
[18:06:08.400]     })
[18:06:08.400]     if (TRUE) {
[18:06:08.400]         base::sink(type = "output", split = FALSE)
[18:06:08.400]         if (TRUE) {
[18:06:08.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.400]         }
[18:06:08.400]         else {
[18:06:08.400]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.400]         }
[18:06:08.400]         base::close(...future.stdout)
[18:06:08.400]         ...future.stdout <- NULL
[18:06:08.400]     }
[18:06:08.400]     ...future.result$conditions <- ...future.conditions
[18:06:08.400]     ...future.result$finished <- base::Sys.time()
[18:06:08.400]     ...future.result
[18:06:08.400] }
[18:06:08.407] requestCore(): workers = 2
[18:06:08.408] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.419] result() for MulticoreFuture ...
[18:06:08.421] result() for MulticoreFuture ...
[18:06:08.421] result() for MulticoreFuture ... done
[18:06:08.421] result() for MulticoreFuture ... done
[18:06:08.422] result() for MulticoreFuture ...
[18:06:08.422] result() for MulticoreFuture ... done
[18:06:08.426] MulticoreFuture started
[18:06:08.427] - Launch lazy future ... done
[18:06:08.427] run() for ‘MulticoreFuture’ ... done
[18:06:08.428] plan(): Setting new future strategy stack:
[18:06:08.430] resolve() on environment ...
[18:06:08.429] List of future strategies:
[18:06:08.429] 1. sequential:
[18:06:08.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.429]    - tweaked: FALSE
[18:06:08.429]    - call: NULL
[18:06:08.431]  recursive: 0
[18:06:08.431] plan(): nbrOfWorkers() = 1
[18:06:08.433]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[18:06:08.434] Future #1
[18:06:08.435]  length: 2 (resolved future 1)
[18:06:08.435] plan(): Setting new future strategy stack:
[18:06:08.436] List of future strategies:
[18:06:08.436] 1. multicore:
[18:06:08.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.436]    - tweaked: FALSE
[18:06:08.436]    - call: plan(strategy)
[18:06:08.445] plan(): nbrOfWorkers() = 2
[18:06:08.445]  length: 1 (resolved future 3)
[18:06:08.456] Future #2
[18:06:08.457]  length: 0 (resolved future 2)
[18:06:08.457] resolve() on environment ... DONE
[18:06:08.459] getGlobalsAndPackages() ...
[18:06:08.459] Searching for globals...
[18:06:08.461] - globals found: [1] ‘{’
[18:06:08.462] Searching for globals ... DONE
[18:06:08.462] Resolving globals: FALSE
[18:06:08.463] 
[18:06:08.464] 
[18:06:08.464] getGlobalsAndPackages() ... DONE
[18:06:08.465] run() for ‘Future’ ...
[18:06:08.465] - state: ‘created’
[18:06:08.466] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.474] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.474]   - Field: ‘label’
[18:06:08.475]   - Field: ‘local’
[18:06:08.475]   - Field: ‘owner’
[18:06:08.475]   - Field: ‘envir’
[18:06:08.476]   - Field: ‘workers’
[18:06:08.476]   - Field: ‘packages’
[18:06:08.476]   - Field: ‘gc’
[18:06:08.477]   - Field: ‘job’
[18:06:08.477]   - Field: ‘conditions’
[18:06:08.477]   - Field: ‘expr’
[18:06:08.478]   - Field: ‘uuid’
[18:06:08.478]   - Field: ‘seed’
[18:06:08.478]   - Field: ‘version’
[18:06:08.479]   - Field: ‘result’
[18:06:08.479]   - Field: ‘asynchronous’
[18:06:08.479]   - Field: ‘calls’
[18:06:08.480]   - Field: ‘globals’
[18:06:08.480]   - Field: ‘stdout’
[18:06:08.480]   - Field: ‘earlySignal’
[18:06:08.480]   - Field: ‘lazy’
[18:06:08.481]   - Field: ‘state’
[18:06:08.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.481] - Launch lazy future ...
[18:06:08.482] Packages needed by the future expression (n = 0): <none>
[18:06:08.483] Packages needed by future strategies (n = 0): <none>
[18:06:08.484] {
[18:06:08.484]     {
[18:06:08.484]         {
[18:06:08.484]             ...future.startTime <- base::Sys.time()
[18:06:08.484]             {
[18:06:08.484]                 {
[18:06:08.484]                   {
[18:06:08.484]                     {
[18:06:08.484]                       base::local({
[18:06:08.484]                         has_future <- base::requireNamespace("future", 
[18:06:08.484]                           quietly = TRUE)
[18:06:08.484]                         if (has_future) {
[18:06:08.484]                           ns <- base::getNamespace("future")
[18:06:08.484]                           version <- ns[[".package"]][["version"]]
[18:06:08.484]                           if (is.null(version)) 
[18:06:08.484]                             version <- utils::packageVersion("future")
[18:06:08.484]                         }
[18:06:08.484]                         else {
[18:06:08.484]                           version <- NULL
[18:06:08.484]                         }
[18:06:08.484]                         if (!has_future || version < "1.8.0") {
[18:06:08.484]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.484]                             "", base::R.version$version.string), 
[18:06:08.484]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.484]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.484]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.484]                               "release", "version")], collapse = " "), 
[18:06:08.484]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.484]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.484]                             info)
[18:06:08.484]                           info <- base::paste(info, collapse = "; ")
[18:06:08.484]                           if (!has_future) {
[18:06:08.484]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.484]                               info)
[18:06:08.484]                           }
[18:06:08.484]                           else {
[18:06:08.484]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.484]                               info, version)
[18:06:08.484]                           }
[18:06:08.484]                           base::stop(msg)
[18:06:08.484]                         }
[18:06:08.484]                       })
[18:06:08.484]                     }
[18:06:08.484]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.484]                     base::options(mc.cores = 1L)
[18:06:08.484]                   }
[18:06:08.484]                   ...future.strategy.old <- future::plan("list")
[18:06:08.484]                   options(future.plan = NULL)
[18:06:08.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.484]                 }
[18:06:08.484]                 ...future.workdir <- getwd()
[18:06:08.484]             }
[18:06:08.484]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.484]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.484]         }
[18:06:08.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.484]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.484]             base::names(...future.oldOptions))
[18:06:08.484]     }
[18:06:08.484]     if (FALSE) {
[18:06:08.484]     }
[18:06:08.484]     else {
[18:06:08.484]         if (TRUE) {
[18:06:08.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.484]                 open = "w")
[18:06:08.484]         }
[18:06:08.484]         else {
[18:06:08.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.484]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.484]         }
[18:06:08.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.484]             base::sink(type = "output", split = FALSE)
[18:06:08.484]             base::close(...future.stdout)
[18:06:08.484]         }, add = TRUE)
[18:06:08.484]     }
[18:06:08.484]     ...future.frame <- base::sys.nframe()
[18:06:08.484]     ...future.conditions <- base::list()
[18:06:08.484]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.484]     if (FALSE) {
[18:06:08.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.484]     }
[18:06:08.484]     ...future.result <- base::tryCatch({
[18:06:08.484]         base::withCallingHandlers({
[18:06:08.484]             ...future.value <- base::withVisible(base::local({
[18:06:08.484]                 withCallingHandlers({
[18:06:08.484]                   {
[18:06:08.484]                     1
[18:06:08.484]                   }
[18:06:08.484]                 }, immediateCondition = function(cond) {
[18:06:08.484]                   save_rds <- function (object, pathname, ...) 
[18:06:08.484]                   {
[18:06:08.484]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.484]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.484]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.484]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.484]                         fi_tmp[["mtime"]])
[18:06:08.484]                     }
[18:06:08.484]                     tryCatch({
[18:06:08.484]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.484]                     }, error = function(ex) {
[18:06:08.484]                       msg <- conditionMessage(ex)
[18:06:08.484]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.484]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.484]                         fi_tmp[["mtime"]], msg)
[18:06:08.484]                       ex$message <- msg
[18:06:08.484]                       stop(ex)
[18:06:08.484]                     })
[18:06:08.484]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.484]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.484]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.484]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.484]                       fi <- file.info(pathname)
[18:06:08.484]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.484]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.484]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.484]                         fi[["size"]], fi[["mtime"]])
[18:06:08.484]                       stop(msg)
[18:06:08.484]                     }
[18:06:08.484]                     invisible(pathname)
[18:06:08.484]                   }
[18:06:08.484]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.484]                     rootPath = tempdir()) 
[18:06:08.484]                   {
[18:06:08.484]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.484]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.484]                       tmpdir = path, fileext = ".rds")
[18:06:08.484]                     save_rds(obj, file)
[18:06:08.484]                   }
[18:06:08.484]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.484]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.484]                   {
[18:06:08.484]                     inherits <- base::inherits
[18:06:08.484]                     invokeRestart <- base::invokeRestart
[18:06:08.484]                     is.null <- base::is.null
[18:06:08.484]                     muffled <- FALSE
[18:06:08.484]                     if (inherits(cond, "message")) {
[18:06:08.484]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.484]                       if (muffled) 
[18:06:08.484]                         invokeRestart("muffleMessage")
[18:06:08.484]                     }
[18:06:08.484]                     else if (inherits(cond, "warning")) {
[18:06:08.484]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.484]                       if (muffled) 
[18:06:08.484]                         invokeRestart("muffleWarning")
[18:06:08.484]                     }
[18:06:08.484]                     else if (inherits(cond, "condition")) {
[18:06:08.484]                       if (!is.null(pattern)) {
[18:06:08.484]                         computeRestarts <- base::computeRestarts
[18:06:08.484]                         grepl <- base::grepl
[18:06:08.484]                         restarts <- computeRestarts(cond)
[18:06:08.484]                         for (restart in restarts) {
[18:06:08.484]                           name <- restart$name
[18:06:08.484]                           if (is.null(name)) 
[18:06:08.484]                             next
[18:06:08.484]                           if (!grepl(pattern, name)) 
[18:06:08.484]                             next
[18:06:08.484]                           invokeRestart(restart)
[18:06:08.484]                           muffled <- TRUE
[18:06:08.484]                           break
[18:06:08.484]                         }
[18:06:08.484]                       }
[18:06:08.484]                     }
[18:06:08.484]                     invisible(muffled)
[18:06:08.484]                   }
[18:06:08.484]                   muffleCondition(cond)
[18:06:08.484]                 })
[18:06:08.484]             }))
[18:06:08.484]             future::FutureResult(value = ...future.value$value, 
[18:06:08.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.484]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.484]                     ...future.globalenv.names))
[18:06:08.484]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.484]         }, condition = base::local({
[18:06:08.484]             c <- base::c
[18:06:08.484]             inherits <- base::inherits
[18:06:08.484]             invokeRestart <- base::invokeRestart
[18:06:08.484]             length <- base::length
[18:06:08.484]             list <- base::list
[18:06:08.484]             seq.int <- base::seq.int
[18:06:08.484]             signalCondition <- base::signalCondition
[18:06:08.484]             sys.calls <- base::sys.calls
[18:06:08.484]             `[[` <- base::`[[`
[18:06:08.484]             `+` <- base::`+`
[18:06:08.484]             `<<-` <- base::`<<-`
[18:06:08.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.484]                   3L)]
[18:06:08.484]             }
[18:06:08.484]             function(cond) {
[18:06:08.484]                 is_error <- inherits(cond, "error")
[18:06:08.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.484]                   NULL)
[18:06:08.484]                 if (is_error) {
[18:06:08.484]                   sessionInformation <- function() {
[18:06:08.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.484]                       search = base::search(), system = base::Sys.info())
[18:06:08.484]                   }
[18:06:08.484]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.484]                     cond$call), session = sessionInformation(), 
[18:06:08.484]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.484]                   signalCondition(cond)
[18:06:08.484]                 }
[18:06:08.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.484]                 "immediateCondition"))) {
[18:06:08.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.484]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.484]                   if (TRUE && !signal) {
[18:06:08.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.484]                     {
[18:06:08.484]                       inherits <- base::inherits
[18:06:08.484]                       invokeRestart <- base::invokeRestart
[18:06:08.484]                       is.null <- base::is.null
[18:06:08.484]                       muffled <- FALSE
[18:06:08.484]                       if (inherits(cond, "message")) {
[18:06:08.484]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.484]                         if (muffled) 
[18:06:08.484]                           invokeRestart("muffleMessage")
[18:06:08.484]                       }
[18:06:08.484]                       else if (inherits(cond, "warning")) {
[18:06:08.484]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.484]                         if (muffled) 
[18:06:08.484]                           invokeRestart("muffleWarning")
[18:06:08.484]                       }
[18:06:08.484]                       else if (inherits(cond, "condition")) {
[18:06:08.484]                         if (!is.null(pattern)) {
[18:06:08.484]                           computeRestarts <- base::computeRestarts
[18:06:08.484]                           grepl <- base::grepl
[18:06:08.484]                           restarts <- computeRestarts(cond)
[18:06:08.484]                           for (restart in restarts) {
[18:06:08.484]                             name <- restart$name
[18:06:08.484]                             if (is.null(name)) 
[18:06:08.484]                               next
[18:06:08.484]                             if (!grepl(pattern, name)) 
[18:06:08.484]                               next
[18:06:08.484]                             invokeRestart(restart)
[18:06:08.484]                             muffled <- TRUE
[18:06:08.484]                             break
[18:06:08.484]                           }
[18:06:08.484]                         }
[18:06:08.484]                       }
[18:06:08.484]                       invisible(muffled)
[18:06:08.484]                     }
[18:06:08.484]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.484]                   }
[18:06:08.484]                 }
[18:06:08.484]                 else {
[18:06:08.484]                   if (TRUE) {
[18:06:08.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.484]                     {
[18:06:08.484]                       inherits <- base::inherits
[18:06:08.484]                       invokeRestart <- base::invokeRestart
[18:06:08.484]                       is.null <- base::is.null
[18:06:08.484]                       muffled <- FALSE
[18:06:08.484]                       if (inherits(cond, "message")) {
[18:06:08.484]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.484]                         if (muffled) 
[18:06:08.484]                           invokeRestart("muffleMessage")
[18:06:08.484]                       }
[18:06:08.484]                       else if (inherits(cond, "warning")) {
[18:06:08.484]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.484]                         if (muffled) 
[18:06:08.484]                           invokeRestart("muffleWarning")
[18:06:08.484]                       }
[18:06:08.484]                       else if (inherits(cond, "condition")) {
[18:06:08.484]                         if (!is.null(pattern)) {
[18:06:08.484]                           computeRestarts <- base::computeRestarts
[18:06:08.484]                           grepl <- base::grepl
[18:06:08.484]                           restarts <- computeRestarts(cond)
[18:06:08.484]                           for (restart in restarts) {
[18:06:08.484]                             name <- restart$name
[18:06:08.484]                             if (is.null(name)) 
[18:06:08.484]                               next
[18:06:08.484]                             if (!grepl(pattern, name)) 
[18:06:08.484]                               next
[18:06:08.484]                             invokeRestart(restart)
[18:06:08.484]                             muffled <- TRUE
[18:06:08.484]                             break
[18:06:08.484]                           }
[18:06:08.484]                         }
[18:06:08.484]                       }
[18:06:08.484]                       invisible(muffled)
[18:06:08.484]                     }
[18:06:08.484]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.484]                   }
[18:06:08.484]                 }
[18:06:08.484]             }
[18:06:08.484]         }))
[18:06:08.484]     }, error = function(ex) {
[18:06:08.484]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.484]                 ...future.rng), started = ...future.startTime, 
[18:06:08.484]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.484]             version = "1.8"), class = "FutureResult")
[18:06:08.484]     }, finally = {
[18:06:08.484]         if (!identical(...future.workdir, getwd())) 
[18:06:08.484]             setwd(...future.workdir)
[18:06:08.484]         {
[18:06:08.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.484]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.484]             }
[18:06:08.484]             base::options(...future.oldOptions)
[18:06:08.484]             if (.Platform$OS.type == "windows") {
[18:06:08.484]                 old_names <- names(...future.oldEnvVars)
[18:06:08.484]                 envs <- base::Sys.getenv()
[18:06:08.484]                 names <- names(envs)
[18:06:08.484]                 common <- intersect(names, old_names)
[18:06:08.484]                 added <- setdiff(names, old_names)
[18:06:08.484]                 removed <- setdiff(old_names, names)
[18:06:08.484]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.484]                   envs[common]]
[18:06:08.484]                 NAMES <- toupper(changed)
[18:06:08.484]                 args <- list()
[18:06:08.484]                 for (kk in seq_along(NAMES)) {
[18:06:08.484]                   name <- changed[[kk]]
[18:06:08.484]                   NAME <- NAMES[[kk]]
[18:06:08.484]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.484]                     next
[18:06:08.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.484]                 }
[18:06:08.484]                 NAMES <- toupper(added)
[18:06:08.484]                 for (kk in seq_along(NAMES)) {
[18:06:08.484]                   name <- added[[kk]]
[18:06:08.484]                   NAME <- NAMES[[kk]]
[18:06:08.484]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.484]                     next
[18:06:08.484]                   args[[name]] <- ""
[18:06:08.484]                 }
[18:06:08.484]                 NAMES <- toupper(removed)
[18:06:08.484]                 for (kk in seq_along(NAMES)) {
[18:06:08.484]                   name <- removed[[kk]]
[18:06:08.484]                   NAME <- NAMES[[kk]]
[18:06:08.484]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.484]                     next
[18:06:08.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.484]                 }
[18:06:08.484]                 if (length(args) > 0) 
[18:06:08.484]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.484]             }
[18:06:08.484]             else {
[18:06:08.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.484]             }
[18:06:08.484]             {
[18:06:08.484]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.484]                   0L) {
[18:06:08.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.484]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.484]                   base::options(opts)
[18:06:08.484]                 }
[18:06:08.484]                 {
[18:06:08.484]                   {
[18:06:08.484]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.484]                     NULL
[18:06:08.484]                   }
[18:06:08.484]                   options(future.plan = NULL)
[18:06:08.484]                   if (is.na(NA_character_)) 
[18:06:08.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.484]                     .init = FALSE)
[18:06:08.484]                 }
[18:06:08.484]             }
[18:06:08.484]         }
[18:06:08.484]     })
[18:06:08.484]     if (TRUE) {
[18:06:08.484]         base::sink(type = "output", split = FALSE)
[18:06:08.484]         if (TRUE) {
[18:06:08.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.484]         }
[18:06:08.484]         else {
[18:06:08.484]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.484]         }
[18:06:08.484]         base::close(...future.stdout)
[18:06:08.484]         ...future.stdout <- NULL
[18:06:08.484]     }
[18:06:08.484]     ...future.result$conditions <- ...future.conditions
[18:06:08.484]     ...future.result$finished <- base::Sys.time()
[18:06:08.484]     ...future.result
[18:06:08.484] }
[18:06:08.490] requestCore(): workers = 2
[18:06:08.491] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.502] result() for MulticoreFuture ...
[18:06:08.504] result() for MulticoreFuture ...
[18:06:08.504] result() for MulticoreFuture ... done
[18:06:08.505] result() for MulticoreFuture ... done
[18:06:08.505] result() for MulticoreFuture ...
[18:06:08.505] result() for MulticoreFuture ... done
[18:06:08.509] MulticoreFuture started
[18:06:08.510] - Launch lazy future ... done
[18:06:08.511] run() for ‘MulticoreFuture’ ... done
[18:06:08.511] plan(): Setting new future strategy stack:
[18:06:08.512] getGlobalsAndPackages() ...
[18:06:08.513] Searching for globals...
[18:06:08.512] List of future strategies:
[18:06:08.512] 1. sequential:
[18:06:08.512]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.512]    - tweaked: FALSE
[18:06:08.512]    - call: NULL
[18:06:08.514] plan(): nbrOfWorkers() = 1
[18:06:08.516] - globals found: [1] ‘{’
[18:06:08.516] Searching for globals ... DONE
[18:06:08.517] Resolving globals: FALSE
[18:06:08.518] 
[18:06:08.518] 
[18:06:08.519] getGlobalsAndPackages() ... DONE
[18:06:08.519] plan(): Setting new future strategy stack:
[18:06:08.520] run() for ‘Future’ ...
[18:06:08.519] List of future strategies:
[18:06:08.519] 1. multicore:
[18:06:08.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.519]    - tweaked: FALSE
[18:06:08.519]    - call: plan(strategy)
[18:06:08.520] - state: ‘created’
[18:06:08.520] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.536] plan(): nbrOfWorkers() = 2
[18:06:08.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.542] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.543]   - Field: ‘label’
[18:06:08.543]   - Field: ‘local’
[18:06:08.544]   - Field: ‘owner’
[18:06:08.544]   - Field: ‘envir’
[18:06:08.544]   - Field: ‘workers’
[18:06:08.545]   - Field: ‘packages’
[18:06:08.545]   - Field: ‘gc’
[18:06:08.545]   - Field: ‘job’
[18:06:08.546]   - Field: ‘conditions’
[18:06:08.546]   - Field: ‘expr’
[18:06:08.547]   - Field: ‘uuid’
[18:06:08.547]   - Field: ‘seed’
[18:06:08.548]   - Field: ‘version’
[18:06:08.548]   - Field: ‘result’
[18:06:08.548]   - Field: ‘asynchronous’
[18:06:08.549]   - Field: ‘calls’
[18:06:08.549]   - Field: ‘globals’
[18:06:08.549]   - Field: ‘stdout’
[18:06:08.550]   - Field: ‘earlySignal’
[18:06:08.551]   - Field: ‘lazy’
[18:06:08.552]   - Field: ‘state’
[18:06:08.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.552] - Launch lazy future ...
[18:06:08.553] Packages needed by the future expression (n = 0): <none>
[18:06:08.554] Packages needed by future strategies (n = 0): <none>
[18:06:08.555] {
[18:06:08.555]     {
[18:06:08.555]         {
[18:06:08.555]             ...future.startTime <- base::Sys.time()
[18:06:08.555]             {
[18:06:08.555]                 {
[18:06:08.555]                   {
[18:06:08.555]                     {
[18:06:08.555]                       base::local({
[18:06:08.555]                         has_future <- base::requireNamespace("future", 
[18:06:08.555]                           quietly = TRUE)
[18:06:08.555]                         if (has_future) {
[18:06:08.555]                           ns <- base::getNamespace("future")
[18:06:08.555]                           version <- ns[[".package"]][["version"]]
[18:06:08.555]                           if (is.null(version)) 
[18:06:08.555]                             version <- utils::packageVersion("future")
[18:06:08.555]                         }
[18:06:08.555]                         else {
[18:06:08.555]                           version <- NULL
[18:06:08.555]                         }
[18:06:08.555]                         if (!has_future || version < "1.8.0") {
[18:06:08.555]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.555]                             "", base::R.version$version.string), 
[18:06:08.555]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.555]                               "release", "version")], collapse = " "), 
[18:06:08.555]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.555]                             info)
[18:06:08.555]                           info <- base::paste(info, collapse = "; ")
[18:06:08.555]                           if (!has_future) {
[18:06:08.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.555]                               info)
[18:06:08.555]                           }
[18:06:08.555]                           else {
[18:06:08.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.555]                               info, version)
[18:06:08.555]                           }
[18:06:08.555]                           base::stop(msg)
[18:06:08.555]                         }
[18:06:08.555]                       })
[18:06:08.555]                     }
[18:06:08.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.555]                     base::options(mc.cores = 1L)
[18:06:08.555]                   }
[18:06:08.555]                   ...future.strategy.old <- future::plan("list")
[18:06:08.555]                   options(future.plan = NULL)
[18:06:08.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.555]                 }
[18:06:08.555]                 ...future.workdir <- getwd()
[18:06:08.555]             }
[18:06:08.555]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.555]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.555]         }
[18:06:08.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.555]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.555]             base::names(...future.oldOptions))
[18:06:08.555]     }
[18:06:08.555]     if (FALSE) {
[18:06:08.555]     }
[18:06:08.555]     else {
[18:06:08.555]         if (TRUE) {
[18:06:08.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.555]                 open = "w")
[18:06:08.555]         }
[18:06:08.555]         else {
[18:06:08.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.555]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.555]         }
[18:06:08.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.555]             base::sink(type = "output", split = FALSE)
[18:06:08.555]             base::close(...future.stdout)
[18:06:08.555]         }, add = TRUE)
[18:06:08.555]     }
[18:06:08.555]     ...future.frame <- base::sys.nframe()
[18:06:08.555]     ...future.conditions <- base::list()
[18:06:08.555]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.555]     if (FALSE) {
[18:06:08.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.555]     }
[18:06:08.555]     ...future.result <- base::tryCatch({
[18:06:08.555]         base::withCallingHandlers({
[18:06:08.555]             ...future.value <- base::withVisible(base::local({
[18:06:08.555]                 withCallingHandlers({
[18:06:08.555]                   {
[18:06:08.555]                     2
[18:06:08.555]                   }
[18:06:08.555]                 }, immediateCondition = function(cond) {
[18:06:08.555]                   save_rds <- function (object, pathname, ...) 
[18:06:08.555]                   {
[18:06:08.555]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.555]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.555]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.555]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.555]                         fi_tmp[["mtime"]])
[18:06:08.555]                     }
[18:06:08.555]                     tryCatch({
[18:06:08.555]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.555]                     }, error = function(ex) {
[18:06:08.555]                       msg <- conditionMessage(ex)
[18:06:08.555]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.555]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.555]                         fi_tmp[["mtime"]], msg)
[18:06:08.555]                       ex$message <- msg
[18:06:08.555]                       stop(ex)
[18:06:08.555]                     })
[18:06:08.555]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.555]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.555]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.555]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.555]                       fi <- file.info(pathname)
[18:06:08.555]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.555]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.555]                         fi[["size"]], fi[["mtime"]])
[18:06:08.555]                       stop(msg)
[18:06:08.555]                     }
[18:06:08.555]                     invisible(pathname)
[18:06:08.555]                   }
[18:06:08.555]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.555]                     rootPath = tempdir()) 
[18:06:08.555]                   {
[18:06:08.555]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.555]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.555]                       tmpdir = path, fileext = ".rds")
[18:06:08.555]                     save_rds(obj, file)
[18:06:08.555]                   }
[18:06:08.555]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.555]                   {
[18:06:08.555]                     inherits <- base::inherits
[18:06:08.555]                     invokeRestart <- base::invokeRestart
[18:06:08.555]                     is.null <- base::is.null
[18:06:08.555]                     muffled <- FALSE
[18:06:08.555]                     if (inherits(cond, "message")) {
[18:06:08.555]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.555]                       if (muffled) 
[18:06:08.555]                         invokeRestart("muffleMessage")
[18:06:08.555]                     }
[18:06:08.555]                     else if (inherits(cond, "warning")) {
[18:06:08.555]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.555]                       if (muffled) 
[18:06:08.555]                         invokeRestart("muffleWarning")
[18:06:08.555]                     }
[18:06:08.555]                     else if (inherits(cond, "condition")) {
[18:06:08.555]                       if (!is.null(pattern)) {
[18:06:08.555]                         computeRestarts <- base::computeRestarts
[18:06:08.555]                         grepl <- base::grepl
[18:06:08.555]                         restarts <- computeRestarts(cond)
[18:06:08.555]                         for (restart in restarts) {
[18:06:08.555]                           name <- restart$name
[18:06:08.555]                           if (is.null(name)) 
[18:06:08.555]                             next
[18:06:08.555]                           if (!grepl(pattern, name)) 
[18:06:08.555]                             next
[18:06:08.555]                           invokeRestart(restart)
[18:06:08.555]                           muffled <- TRUE
[18:06:08.555]                           break
[18:06:08.555]                         }
[18:06:08.555]                       }
[18:06:08.555]                     }
[18:06:08.555]                     invisible(muffled)
[18:06:08.555]                   }
[18:06:08.555]                   muffleCondition(cond)
[18:06:08.555]                 })
[18:06:08.555]             }))
[18:06:08.555]             future::FutureResult(value = ...future.value$value, 
[18:06:08.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.555]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.555]                     ...future.globalenv.names))
[18:06:08.555]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.555]         }, condition = base::local({
[18:06:08.555]             c <- base::c
[18:06:08.555]             inherits <- base::inherits
[18:06:08.555]             invokeRestart <- base::invokeRestart
[18:06:08.555]             length <- base::length
[18:06:08.555]             list <- base::list
[18:06:08.555]             seq.int <- base::seq.int
[18:06:08.555]             signalCondition <- base::signalCondition
[18:06:08.555]             sys.calls <- base::sys.calls
[18:06:08.555]             `[[` <- base::`[[`
[18:06:08.555]             `+` <- base::`+`
[18:06:08.555]             `<<-` <- base::`<<-`
[18:06:08.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.555]                   3L)]
[18:06:08.555]             }
[18:06:08.555]             function(cond) {
[18:06:08.555]                 is_error <- inherits(cond, "error")
[18:06:08.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.555]                   NULL)
[18:06:08.555]                 if (is_error) {
[18:06:08.555]                   sessionInformation <- function() {
[18:06:08.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.555]                       search = base::search(), system = base::Sys.info())
[18:06:08.555]                   }
[18:06:08.555]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.555]                     cond$call), session = sessionInformation(), 
[18:06:08.555]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.555]                   signalCondition(cond)
[18:06:08.555]                 }
[18:06:08.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.555]                 "immediateCondition"))) {
[18:06:08.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.555]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.555]                   if (TRUE && !signal) {
[18:06:08.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.555]                     {
[18:06:08.555]                       inherits <- base::inherits
[18:06:08.555]                       invokeRestart <- base::invokeRestart
[18:06:08.555]                       is.null <- base::is.null
[18:06:08.555]                       muffled <- FALSE
[18:06:08.555]                       if (inherits(cond, "message")) {
[18:06:08.555]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.555]                         if (muffled) 
[18:06:08.555]                           invokeRestart("muffleMessage")
[18:06:08.555]                       }
[18:06:08.555]                       else if (inherits(cond, "warning")) {
[18:06:08.555]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.555]                         if (muffled) 
[18:06:08.555]                           invokeRestart("muffleWarning")
[18:06:08.555]                       }
[18:06:08.555]                       else if (inherits(cond, "condition")) {
[18:06:08.555]                         if (!is.null(pattern)) {
[18:06:08.555]                           computeRestarts <- base::computeRestarts
[18:06:08.555]                           grepl <- base::grepl
[18:06:08.555]                           restarts <- computeRestarts(cond)
[18:06:08.555]                           for (restart in restarts) {
[18:06:08.555]                             name <- restart$name
[18:06:08.555]                             if (is.null(name)) 
[18:06:08.555]                               next
[18:06:08.555]                             if (!grepl(pattern, name)) 
[18:06:08.555]                               next
[18:06:08.555]                             invokeRestart(restart)
[18:06:08.555]                             muffled <- TRUE
[18:06:08.555]                             break
[18:06:08.555]                           }
[18:06:08.555]                         }
[18:06:08.555]                       }
[18:06:08.555]                       invisible(muffled)
[18:06:08.555]                     }
[18:06:08.555]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.555]                   }
[18:06:08.555]                 }
[18:06:08.555]                 else {
[18:06:08.555]                   if (TRUE) {
[18:06:08.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.555]                     {
[18:06:08.555]                       inherits <- base::inherits
[18:06:08.555]                       invokeRestart <- base::invokeRestart
[18:06:08.555]                       is.null <- base::is.null
[18:06:08.555]                       muffled <- FALSE
[18:06:08.555]                       if (inherits(cond, "message")) {
[18:06:08.555]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.555]                         if (muffled) 
[18:06:08.555]                           invokeRestart("muffleMessage")
[18:06:08.555]                       }
[18:06:08.555]                       else if (inherits(cond, "warning")) {
[18:06:08.555]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.555]                         if (muffled) 
[18:06:08.555]                           invokeRestart("muffleWarning")
[18:06:08.555]                       }
[18:06:08.555]                       else if (inherits(cond, "condition")) {
[18:06:08.555]                         if (!is.null(pattern)) {
[18:06:08.555]                           computeRestarts <- base::computeRestarts
[18:06:08.555]                           grepl <- base::grepl
[18:06:08.555]                           restarts <- computeRestarts(cond)
[18:06:08.555]                           for (restart in restarts) {
[18:06:08.555]                             name <- restart$name
[18:06:08.555]                             if (is.null(name)) 
[18:06:08.555]                               next
[18:06:08.555]                             if (!grepl(pattern, name)) 
[18:06:08.555]                               next
[18:06:08.555]                             invokeRestart(restart)
[18:06:08.555]                             muffled <- TRUE
[18:06:08.555]                             break
[18:06:08.555]                           }
[18:06:08.555]                         }
[18:06:08.555]                       }
[18:06:08.555]                       invisible(muffled)
[18:06:08.555]                     }
[18:06:08.555]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.555]                   }
[18:06:08.555]                 }
[18:06:08.555]             }
[18:06:08.555]         }))
[18:06:08.555]     }, error = function(ex) {
[18:06:08.555]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.555]                 ...future.rng), started = ...future.startTime, 
[18:06:08.555]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.555]             version = "1.8"), class = "FutureResult")
[18:06:08.555]     }, finally = {
[18:06:08.555]         if (!identical(...future.workdir, getwd())) 
[18:06:08.555]             setwd(...future.workdir)
[18:06:08.555]         {
[18:06:08.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.555]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.555]             }
[18:06:08.555]             base::options(...future.oldOptions)
[18:06:08.555]             if (.Platform$OS.type == "windows") {
[18:06:08.555]                 old_names <- names(...future.oldEnvVars)
[18:06:08.555]                 envs <- base::Sys.getenv()
[18:06:08.555]                 names <- names(envs)
[18:06:08.555]                 common <- intersect(names, old_names)
[18:06:08.555]                 added <- setdiff(names, old_names)
[18:06:08.555]                 removed <- setdiff(old_names, names)
[18:06:08.555]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.555]                   envs[common]]
[18:06:08.555]                 NAMES <- toupper(changed)
[18:06:08.555]                 args <- list()
[18:06:08.555]                 for (kk in seq_along(NAMES)) {
[18:06:08.555]                   name <- changed[[kk]]
[18:06:08.555]                   NAME <- NAMES[[kk]]
[18:06:08.555]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.555]                     next
[18:06:08.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.555]                 }
[18:06:08.555]                 NAMES <- toupper(added)
[18:06:08.555]                 for (kk in seq_along(NAMES)) {
[18:06:08.555]                   name <- added[[kk]]
[18:06:08.555]                   NAME <- NAMES[[kk]]
[18:06:08.555]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.555]                     next
[18:06:08.555]                   args[[name]] <- ""
[18:06:08.555]                 }
[18:06:08.555]                 NAMES <- toupper(removed)
[18:06:08.555]                 for (kk in seq_along(NAMES)) {
[18:06:08.555]                   name <- removed[[kk]]
[18:06:08.555]                   NAME <- NAMES[[kk]]
[18:06:08.555]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.555]                     next
[18:06:08.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.555]                 }
[18:06:08.555]                 if (length(args) > 0) 
[18:06:08.555]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.555]             }
[18:06:08.555]             else {
[18:06:08.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.555]             }
[18:06:08.555]             {
[18:06:08.555]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.555]                   0L) {
[18:06:08.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.555]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.555]                   base::options(opts)
[18:06:08.555]                 }
[18:06:08.555]                 {
[18:06:08.555]                   {
[18:06:08.555]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.555]                     NULL
[18:06:08.555]                   }
[18:06:08.555]                   options(future.plan = NULL)
[18:06:08.555]                   if (is.na(NA_character_)) 
[18:06:08.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.555]                     .init = FALSE)
[18:06:08.555]                 }
[18:06:08.555]             }
[18:06:08.555]         }
[18:06:08.555]     })
[18:06:08.555]     if (TRUE) {
[18:06:08.555]         base::sink(type = "output", split = FALSE)
[18:06:08.555]         if (TRUE) {
[18:06:08.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.555]         }
[18:06:08.555]         else {
[18:06:08.555]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.555]         }
[18:06:08.555]         base::close(...future.stdout)
[18:06:08.555]         ...future.stdout <- NULL
[18:06:08.555]     }
[18:06:08.555]     ...future.result$conditions <- ...future.conditions
[18:06:08.555]     ...future.result$finished <- base::Sys.time()
[18:06:08.555]     ...future.result
[18:06:08.555] }
[18:06:08.561] requestCore(): workers = 2
[18:06:08.562] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.573] result() for MulticoreFuture ...
[18:06:08.575] result() for MulticoreFuture ...
[18:06:08.575] result() for MulticoreFuture ... done
[18:06:08.575] result() for MulticoreFuture ... done
[18:06:08.576] result() for MulticoreFuture ...
[18:06:08.578] result() for MulticoreFuture ... done
[18:06:08.584] MulticoreFuture started
[18:06:08.585] - Launch lazy future ... done
[18:06:08.585] run() for ‘MulticoreFuture’ ... done
[18:06:08.589] resolve() on environment ...
[18:06:08.589]  recursive: 0
[18:06:08.589] plan(): Setting new future strategy stack:
[18:06:08.592]  elements: [3] ‘a’
[18:06:08.593] Future #1
[18:06:08.590] List of future strategies:
[18:06:08.590] 1. sequential:
[18:06:08.590]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.590]    - tweaked: FALSE
[18:06:08.590]    - call: NULL
[18:06:08.594]  length: 2 (resolved future 1)
[18:06:08.595] plan(): nbrOfWorkers() = 1
[18:06:08.600] plan(): Setting new future strategy stack:
[18:06:08.600] List of future strategies:
[18:06:08.600] 1. multicore:
[18:06:08.600]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.600]    - tweaked: FALSE
[18:06:08.600]    - call: plan(strategy)
[18:06:08.606]  length: 1 (resolved future 3)
[18:06:08.611] plan(): nbrOfWorkers() = 2
[18:06:08.617] Future #2
[18:06:08.617]  length: 0 (resolved future 2)
[18:06:08.618] resolve() on environment ... DONE
[18:06:08.620] resolve() on environment ...
[18:06:08.620]  recursive: 0
[18:06:08.622]  elements: [3] ‘b’
[18:06:08.623] Future #1
[18:06:08.623]  length: 2 (resolved future 1)
[18:06:08.624] Future #2
[18:06:08.624]  length: 1 (resolved future 2)
[18:06:08.625]  length: 0 (resolved future 3)
[18:06:08.625] resolve() on environment ... DONE
[18:06:08.627] resolve() on environment ...
[18:06:08.628]  recursive: 0
[18:06:08.629]  elements: [3] ‘c’
[18:06:08.630] Future #1
[18:06:08.631]  length: 2 (resolved future 1)
[18:06:08.631] Future #2
[18:06:08.632]  length: 1 (resolved future 2)
[18:06:08.632]  length: 0 (resolved future 3)
[18:06:08.632] resolve() on environment ... DONE
[18:06:08.634] resolve() on environment ...
[18:06:08.635]  recursive: 0
[18:06:08.636]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[18:06:08.637] Future #1
[18:06:08.638] result() for MulticoreFuture ...
[18:06:08.639] result() for MulticoreFuture ...
[18:06:08.640] result() for MulticoreFuture ... done
[18:06:08.640] result() for MulticoreFuture ... done
[18:06:08.640] result() for MulticoreFuture ...
[18:06:08.643] result() for MulticoreFuture ... done
[18:06:08.644]  length: 2 (resolved future 1)
[18:06:08.644] Future #2
[18:06:08.645] result() for MulticoreFuture ...
[18:06:08.648] result() for MulticoreFuture ...
[18:06:08.648] result() for MulticoreFuture ... done
[18:06:08.649] result() for MulticoreFuture ... done
[18:06:08.651] result() for MulticoreFuture ...
[18:06:08.652] result() for MulticoreFuture ... done
[18:06:08.654]  length: 1 (resolved future 2)
[18:06:08.654]  length: 0 (resolved future 3)
[18:06:08.654] resolve() on environment ... DONE
[18:06:08.656] resolve() on environment ...
[18:06:08.656]  recursive: 99
[18:06:08.657]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[18:06:08.658] Future #1
[18:06:08.658] result() for MulticoreFuture ...
[18:06:08.658] result() for MulticoreFuture ... done
[18:06:08.659] result() for MulticoreFuture ...
[18:06:08.659] result() for MulticoreFuture ... done
[18:06:08.659] A MulticoreFuture was resolved
[18:06:08.660]  length: 2 (resolved future 1)
[18:06:08.660] Future #2
[18:06:08.660] result() for MulticoreFuture ...
[18:06:08.661] result() for MulticoreFuture ... done
[18:06:08.661] result() for MulticoreFuture ...
[18:06:08.661] result() for MulticoreFuture ... done
[18:06:08.661] A MulticoreFuture was resolved
[18:06:08.662]  length: 1 (resolved future 2)
[18:06:08.662]  length: 0 (resolved future 3)
[18:06:08.662] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[18:06:08.664] resolve() on list environment ...
[18:06:08.664]  recursive: 0
[18:06:08.666]  length: 2
[18:06:08.666]  elements: ‘a’, ‘b’
[18:06:08.666]  length: 1 (resolved future 1)
[18:06:08.666]  length: 0 (resolved future 2)
[18:06:08.667] resolve() on list environment ... DONE
[18:06:08.667] getGlobalsAndPackages() ...
[18:06:08.667] Searching for globals...
[18:06:08.668] 
[18:06:08.669] Searching for globals ... DONE
[18:06:08.669] - globals: [0] <none>
[18:06:08.669] getGlobalsAndPackages() ... DONE
[18:06:08.670] run() for ‘Future’ ...
[18:06:08.670] - state: ‘created’
[18:06:08.670] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.678] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.678]   - Field: ‘label’
[18:06:08.679]   - Field: ‘local’
[18:06:08.679]   - Field: ‘owner’
[18:06:08.679]   - Field: ‘envir’
[18:06:08.679]   - Field: ‘workers’
[18:06:08.680]   - Field: ‘packages’
[18:06:08.680]   - Field: ‘gc’
[18:06:08.683]   - Field: ‘job’
[18:06:08.684]   - Field: ‘conditions’
[18:06:08.684]   - Field: ‘expr’
[18:06:08.684]   - Field: ‘uuid’
[18:06:08.685]   - Field: ‘seed’
[18:06:08.685]   - Field: ‘version’
[18:06:08.685]   - Field: ‘result’
[18:06:08.686]   - Field: ‘asynchronous’
[18:06:08.686]   - Field: ‘calls’
[18:06:08.686]   - Field: ‘globals’
[18:06:08.687]   - Field: ‘stdout’
[18:06:08.687]   - Field: ‘earlySignal’
[18:06:08.687]   - Field: ‘lazy’
[18:06:08.687]   - Field: ‘state’
[18:06:08.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.688] - Launch lazy future ...
[18:06:08.689] Packages needed by the future expression (n = 0): <none>
[18:06:08.689] Packages needed by future strategies (n = 0): <none>
[18:06:08.690] {
[18:06:08.690]     {
[18:06:08.690]         {
[18:06:08.690]             ...future.startTime <- base::Sys.time()
[18:06:08.690]             {
[18:06:08.690]                 {
[18:06:08.690]                   {
[18:06:08.690]                     {
[18:06:08.690]                       base::local({
[18:06:08.690]                         has_future <- base::requireNamespace("future", 
[18:06:08.690]                           quietly = TRUE)
[18:06:08.690]                         if (has_future) {
[18:06:08.690]                           ns <- base::getNamespace("future")
[18:06:08.690]                           version <- ns[[".package"]][["version"]]
[18:06:08.690]                           if (is.null(version)) 
[18:06:08.690]                             version <- utils::packageVersion("future")
[18:06:08.690]                         }
[18:06:08.690]                         else {
[18:06:08.690]                           version <- NULL
[18:06:08.690]                         }
[18:06:08.690]                         if (!has_future || version < "1.8.0") {
[18:06:08.690]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.690]                             "", base::R.version$version.string), 
[18:06:08.690]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.690]                               "release", "version")], collapse = " "), 
[18:06:08.690]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.690]                             info)
[18:06:08.690]                           info <- base::paste(info, collapse = "; ")
[18:06:08.690]                           if (!has_future) {
[18:06:08.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.690]                               info)
[18:06:08.690]                           }
[18:06:08.690]                           else {
[18:06:08.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.690]                               info, version)
[18:06:08.690]                           }
[18:06:08.690]                           base::stop(msg)
[18:06:08.690]                         }
[18:06:08.690]                       })
[18:06:08.690]                     }
[18:06:08.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.690]                     base::options(mc.cores = 1L)
[18:06:08.690]                   }
[18:06:08.690]                   ...future.strategy.old <- future::plan("list")
[18:06:08.690]                   options(future.plan = NULL)
[18:06:08.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.690]                 }
[18:06:08.690]                 ...future.workdir <- getwd()
[18:06:08.690]             }
[18:06:08.690]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.690]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.690]         }
[18:06:08.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.690]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.690]             base::names(...future.oldOptions))
[18:06:08.690]     }
[18:06:08.690]     if (FALSE) {
[18:06:08.690]     }
[18:06:08.690]     else {
[18:06:08.690]         if (TRUE) {
[18:06:08.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.690]                 open = "w")
[18:06:08.690]         }
[18:06:08.690]         else {
[18:06:08.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.690]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.690]         }
[18:06:08.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.690]             base::sink(type = "output", split = FALSE)
[18:06:08.690]             base::close(...future.stdout)
[18:06:08.690]         }, add = TRUE)
[18:06:08.690]     }
[18:06:08.690]     ...future.frame <- base::sys.nframe()
[18:06:08.690]     ...future.conditions <- base::list()
[18:06:08.690]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.690]     if (FALSE) {
[18:06:08.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.690]     }
[18:06:08.690]     ...future.result <- base::tryCatch({
[18:06:08.690]         base::withCallingHandlers({
[18:06:08.690]             ...future.value <- base::withVisible(base::local({
[18:06:08.690]                 withCallingHandlers({
[18:06:08.690]                   1
[18:06:08.690]                 }, immediateCondition = function(cond) {
[18:06:08.690]                   save_rds <- function (object, pathname, ...) 
[18:06:08.690]                   {
[18:06:08.690]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.690]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.690]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.690]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.690]                         fi_tmp[["mtime"]])
[18:06:08.690]                     }
[18:06:08.690]                     tryCatch({
[18:06:08.690]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.690]                     }, error = function(ex) {
[18:06:08.690]                       msg <- conditionMessage(ex)
[18:06:08.690]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.690]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.690]                         fi_tmp[["mtime"]], msg)
[18:06:08.690]                       ex$message <- msg
[18:06:08.690]                       stop(ex)
[18:06:08.690]                     })
[18:06:08.690]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.690]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.690]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.690]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.690]                       fi <- file.info(pathname)
[18:06:08.690]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.690]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.690]                         fi[["size"]], fi[["mtime"]])
[18:06:08.690]                       stop(msg)
[18:06:08.690]                     }
[18:06:08.690]                     invisible(pathname)
[18:06:08.690]                   }
[18:06:08.690]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.690]                     rootPath = tempdir()) 
[18:06:08.690]                   {
[18:06:08.690]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.690]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.690]                       tmpdir = path, fileext = ".rds")
[18:06:08.690]                     save_rds(obj, file)
[18:06:08.690]                   }
[18:06:08.690]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.690]                   {
[18:06:08.690]                     inherits <- base::inherits
[18:06:08.690]                     invokeRestart <- base::invokeRestart
[18:06:08.690]                     is.null <- base::is.null
[18:06:08.690]                     muffled <- FALSE
[18:06:08.690]                     if (inherits(cond, "message")) {
[18:06:08.690]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.690]                       if (muffled) 
[18:06:08.690]                         invokeRestart("muffleMessage")
[18:06:08.690]                     }
[18:06:08.690]                     else if (inherits(cond, "warning")) {
[18:06:08.690]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.690]                       if (muffled) 
[18:06:08.690]                         invokeRestart("muffleWarning")
[18:06:08.690]                     }
[18:06:08.690]                     else if (inherits(cond, "condition")) {
[18:06:08.690]                       if (!is.null(pattern)) {
[18:06:08.690]                         computeRestarts <- base::computeRestarts
[18:06:08.690]                         grepl <- base::grepl
[18:06:08.690]                         restarts <- computeRestarts(cond)
[18:06:08.690]                         for (restart in restarts) {
[18:06:08.690]                           name <- restart$name
[18:06:08.690]                           if (is.null(name)) 
[18:06:08.690]                             next
[18:06:08.690]                           if (!grepl(pattern, name)) 
[18:06:08.690]                             next
[18:06:08.690]                           invokeRestart(restart)
[18:06:08.690]                           muffled <- TRUE
[18:06:08.690]                           break
[18:06:08.690]                         }
[18:06:08.690]                       }
[18:06:08.690]                     }
[18:06:08.690]                     invisible(muffled)
[18:06:08.690]                   }
[18:06:08.690]                   muffleCondition(cond)
[18:06:08.690]                 })
[18:06:08.690]             }))
[18:06:08.690]             future::FutureResult(value = ...future.value$value, 
[18:06:08.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.690]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.690]                     ...future.globalenv.names))
[18:06:08.690]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.690]         }, condition = base::local({
[18:06:08.690]             c <- base::c
[18:06:08.690]             inherits <- base::inherits
[18:06:08.690]             invokeRestart <- base::invokeRestart
[18:06:08.690]             length <- base::length
[18:06:08.690]             list <- base::list
[18:06:08.690]             seq.int <- base::seq.int
[18:06:08.690]             signalCondition <- base::signalCondition
[18:06:08.690]             sys.calls <- base::sys.calls
[18:06:08.690]             `[[` <- base::`[[`
[18:06:08.690]             `+` <- base::`+`
[18:06:08.690]             `<<-` <- base::`<<-`
[18:06:08.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.690]                   3L)]
[18:06:08.690]             }
[18:06:08.690]             function(cond) {
[18:06:08.690]                 is_error <- inherits(cond, "error")
[18:06:08.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.690]                   NULL)
[18:06:08.690]                 if (is_error) {
[18:06:08.690]                   sessionInformation <- function() {
[18:06:08.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.690]                       search = base::search(), system = base::Sys.info())
[18:06:08.690]                   }
[18:06:08.690]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.690]                     cond$call), session = sessionInformation(), 
[18:06:08.690]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.690]                   signalCondition(cond)
[18:06:08.690]                 }
[18:06:08.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.690]                 "immediateCondition"))) {
[18:06:08.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.690]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.690]                   if (TRUE && !signal) {
[18:06:08.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.690]                     {
[18:06:08.690]                       inherits <- base::inherits
[18:06:08.690]                       invokeRestart <- base::invokeRestart
[18:06:08.690]                       is.null <- base::is.null
[18:06:08.690]                       muffled <- FALSE
[18:06:08.690]                       if (inherits(cond, "message")) {
[18:06:08.690]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.690]                         if (muffled) 
[18:06:08.690]                           invokeRestart("muffleMessage")
[18:06:08.690]                       }
[18:06:08.690]                       else if (inherits(cond, "warning")) {
[18:06:08.690]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.690]                         if (muffled) 
[18:06:08.690]                           invokeRestart("muffleWarning")
[18:06:08.690]                       }
[18:06:08.690]                       else if (inherits(cond, "condition")) {
[18:06:08.690]                         if (!is.null(pattern)) {
[18:06:08.690]                           computeRestarts <- base::computeRestarts
[18:06:08.690]                           grepl <- base::grepl
[18:06:08.690]                           restarts <- computeRestarts(cond)
[18:06:08.690]                           for (restart in restarts) {
[18:06:08.690]                             name <- restart$name
[18:06:08.690]                             if (is.null(name)) 
[18:06:08.690]                               next
[18:06:08.690]                             if (!grepl(pattern, name)) 
[18:06:08.690]                               next
[18:06:08.690]                             invokeRestart(restart)
[18:06:08.690]                             muffled <- TRUE
[18:06:08.690]                             break
[18:06:08.690]                           }
[18:06:08.690]                         }
[18:06:08.690]                       }
[18:06:08.690]                       invisible(muffled)
[18:06:08.690]                     }
[18:06:08.690]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.690]                   }
[18:06:08.690]                 }
[18:06:08.690]                 else {
[18:06:08.690]                   if (TRUE) {
[18:06:08.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.690]                     {
[18:06:08.690]                       inherits <- base::inherits
[18:06:08.690]                       invokeRestart <- base::invokeRestart
[18:06:08.690]                       is.null <- base::is.null
[18:06:08.690]                       muffled <- FALSE
[18:06:08.690]                       if (inherits(cond, "message")) {
[18:06:08.690]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.690]                         if (muffled) 
[18:06:08.690]                           invokeRestart("muffleMessage")
[18:06:08.690]                       }
[18:06:08.690]                       else if (inherits(cond, "warning")) {
[18:06:08.690]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.690]                         if (muffled) 
[18:06:08.690]                           invokeRestart("muffleWarning")
[18:06:08.690]                       }
[18:06:08.690]                       else if (inherits(cond, "condition")) {
[18:06:08.690]                         if (!is.null(pattern)) {
[18:06:08.690]                           computeRestarts <- base::computeRestarts
[18:06:08.690]                           grepl <- base::grepl
[18:06:08.690]                           restarts <- computeRestarts(cond)
[18:06:08.690]                           for (restart in restarts) {
[18:06:08.690]                             name <- restart$name
[18:06:08.690]                             if (is.null(name)) 
[18:06:08.690]                               next
[18:06:08.690]                             if (!grepl(pattern, name)) 
[18:06:08.690]                               next
[18:06:08.690]                             invokeRestart(restart)
[18:06:08.690]                             muffled <- TRUE
[18:06:08.690]                             break
[18:06:08.690]                           }
[18:06:08.690]                         }
[18:06:08.690]                       }
[18:06:08.690]                       invisible(muffled)
[18:06:08.690]                     }
[18:06:08.690]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.690]                   }
[18:06:08.690]                 }
[18:06:08.690]             }
[18:06:08.690]         }))
[18:06:08.690]     }, error = function(ex) {
[18:06:08.690]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.690]                 ...future.rng), started = ...future.startTime, 
[18:06:08.690]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.690]             version = "1.8"), class = "FutureResult")
[18:06:08.690]     }, finally = {
[18:06:08.690]         if (!identical(...future.workdir, getwd())) 
[18:06:08.690]             setwd(...future.workdir)
[18:06:08.690]         {
[18:06:08.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.690]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.690]             }
[18:06:08.690]             base::options(...future.oldOptions)
[18:06:08.690]             if (.Platform$OS.type == "windows") {
[18:06:08.690]                 old_names <- names(...future.oldEnvVars)
[18:06:08.690]                 envs <- base::Sys.getenv()
[18:06:08.690]                 names <- names(envs)
[18:06:08.690]                 common <- intersect(names, old_names)
[18:06:08.690]                 added <- setdiff(names, old_names)
[18:06:08.690]                 removed <- setdiff(old_names, names)
[18:06:08.690]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.690]                   envs[common]]
[18:06:08.690]                 NAMES <- toupper(changed)
[18:06:08.690]                 args <- list()
[18:06:08.690]                 for (kk in seq_along(NAMES)) {
[18:06:08.690]                   name <- changed[[kk]]
[18:06:08.690]                   NAME <- NAMES[[kk]]
[18:06:08.690]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.690]                     next
[18:06:08.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.690]                 }
[18:06:08.690]                 NAMES <- toupper(added)
[18:06:08.690]                 for (kk in seq_along(NAMES)) {
[18:06:08.690]                   name <- added[[kk]]
[18:06:08.690]                   NAME <- NAMES[[kk]]
[18:06:08.690]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.690]                     next
[18:06:08.690]                   args[[name]] <- ""
[18:06:08.690]                 }
[18:06:08.690]                 NAMES <- toupper(removed)
[18:06:08.690]                 for (kk in seq_along(NAMES)) {
[18:06:08.690]                   name <- removed[[kk]]
[18:06:08.690]                   NAME <- NAMES[[kk]]
[18:06:08.690]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.690]                     next
[18:06:08.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.690]                 }
[18:06:08.690]                 if (length(args) > 0) 
[18:06:08.690]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.690]             }
[18:06:08.690]             else {
[18:06:08.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.690]             }
[18:06:08.690]             {
[18:06:08.690]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.690]                   0L) {
[18:06:08.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.690]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.690]                   base::options(opts)
[18:06:08.690]                 }
[18:06:08.690]                 {
[18:06:08.690]                   {
[18:06:08.690]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.690]                     NULL
[18:06:08.690]                   }
[18:06:08.690]                   options(future.plan = NULL)
[18:06:08.690]                   if (is.na(NA_character_)) 
[18:06:08.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.690]                     .init = FALSE)
[18:06:08.690]                 }
[18:06:08.690]             }
[18:06:08.690]         }
[18:06:08.690]     })
[18:06:08.690]     if (TRUE) {
[18:06:08.690]         base::sink(type = "output", split = FALSE)
[18:06:08.690]         if (TRUE) {
[18:06:08.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.690]         }
[18:06:08.690]         else {
[18:06:08.690]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.690]         }
[18:06:08.690]         base::close(...future.stdout)
[18:06:08.690]         ...future.stdout <- NULL
[18:06:08.690]     }
[18:06:08.690]     ...future.result$conditions <- ...future.conditions
[18:06:08.690]     ...future.result$finished <- base::Sys.time()
[18:06:08.690]     ...future.result
[18:06:08.690] }
[18:06:08.695] requestCore(): workers = 2
[18:06:08.701] MulticoreFuture started
[18:06:08.702] - Launch lazy future ... done
[18:06:08.704] plan(): Setting new future strategy stack:
[18:06:08.703] run() for ‘MulticoreFuture’ ... done
[18:06:08.706] getGlobalsAndPackages() ...
[18:06:08.706] Searching for globals...
[18:06:08.707] List of future strategies:
[18:06:08.707] 1. sequential:
[18:06:08.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.707]    - tweaked: FALSE
[18:06:08.707]    - call: NULL
[18:06:08.711] plan(): nbrOfWorkers() = 1
[18:06:08.712] 
[18:06:08.713] Searching for globals ... DONE
[18:06:08.713] - globals: [0] <none>
[18:06:08.713] getGlobalsAndPackages() ... DONE
[18:06:08.714] run() for ‘Future’ ...
[18:06:08.717] - state: ‘created’
[18:06:08.719] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.719] plan(): Setting new future strategy stack:
[18:06:08.721] List of future strategies:
[18:06:08.721] 1. multicore:
[18:06:08.721]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.721]    - tweaked: FALSE
[18:06:08.721]    - call: plan(strategy)
[18:06:08.735] plan(): nbrOfWorkers() = 2
[18:06:08.736] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.737] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.737]   - Field: ‘label’
[18:06:08.738]   - Field: ‘local’
[18:06:08.738]   - Field: ‘owner’
[18:06:08.739]   - Field: ‘envir’
[18:06:08.739]   - Field: ‘workers’
[18:06:08.739]   - Field: ‘packages’
[18:06:08.740]   - Field: ‘gc’
[18:06:08.740]   - Field: ‘job’
[18:06:08.740]   - Field: ‘conditions’
[18:06:08.741]   - Field: ‘expr’
[18:06:08.741]   - Field: ‘uuid’
[18:06:08.742]   - Field: ‘seed’
[18:06:08.742]   - Field: ‘version’
[18:06:08.743]   - Field: ‘result’
[18:06:08.743]   - Field: ‘asynchronous’
[18:06:08.743]   - Field: ‘calls’
[18:06:08.744]   - Field: ‘globals’
[18:06:08.744]   - Field: ‘stdout’
[18:06:08.744]   - Field: ‘earlySignal’
[18:06:08.745]   - Field: ‘lazy’
[18:06:08.745]   - Field: ‘state’
[18:06:08.745] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.746] - Launch lazy future ...
[18:06:08.746] Packages needed by the future expression (n = 0): <none>
[18:06:08.747] Packages needed by future strategies (n = 0): <none>
[18:06:08.749] {
[18:06:08.749]     {
[18:06:08.749]         {
[18:06:08.749]             ...future.startTime <- base::Sys.time()
[18:06:08.749]             {
[18:06:08.749]                 {
[18:06:08.749]                   {
[18:06:08.749]                     {
[18:06:08.749]                       base::local({
[18:06:08.749]                         has_future <- base::requireNamespace("future", 
[18:06:08.749]                           quietly = TRUE)
[18:06:08.749]                         if (has_future) {
[18:06:08.749]                           ns <- base::getNamespace("future")
[18:06:08.749]                           version <- ns[[".package"]][["version"]]
[18:06:08.749]                           if (is.null(version)) 
[18:06:08.749]                             version <- utils::packageVersion("future")
[18:06:08.749]                         }
[18:06:08.749]                         else {
[18:06:08.749]                           version <- NULL
[18:06:08.749]                         }
[18:06:08.749]                         if (!has_future || version < "1.8.0") {
[18:06:08.749]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.749]                             "", base::R.version$version.string), 
[18:06:08.749]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.749]                               "release", "version")], collapse = " "), 
[18:06:08.749]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.749]                             info)
[18:06:08.749]                           info <- base::paste(info, collapse = "; ")
[18:06:08.749]                           if (!has_future) {
[18:06:08.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.749]                               info)
[18:06:08.749]                           }
[18:06:08.749]                           else {
[18:06:08.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.749]                               info, version)
[18:06:08.749]                           }
[18:06:08.749]                           base::stop(msg)
[18:06:08.749]                         }
[18:06:08.749]                       })
[18:06:08.749]                     }
[18:06:08.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.749]                     base::options(mc.cores = 1L)
[18:06:08.749]                   }
[18:06:08.749]                   ...future.strategy.old <- future::plan("list")
[18:06:08.749]                   options(future.plan = NULL)
[18:06:08.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.749]                 }
[18:06:08.749]                 ...future.workdir <- getwd()
[18:06:08.749]             }
[18:06:08.749]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.749]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.749]         }
[18:06:08.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.749]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.749]             base::names(...future.oldOptions))
[18:06:08.749]     }
[18:06:08.749]     if (FALSE) {
[18:06:08.749]     }
[18:06:08.749]     else {
[18:06:08.749]         if (TRUE) {
[18:06:08.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.749]                 open = "w")
[18:06:08.749]         }
[18:06:08.749]         else {
[18:06:08.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.749]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.749]         }
[18:06:08.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.749]             base::sink(type = "output", split = FALSE)
[18:06:08.749]             base::close(...future.stdout)
[18:06:08.749]         }, add = TRUE)
[18:06:08.749]     }
[18:06:08.749]     ...future.frame <- base::sys.nframe()
[18:06:08.749]     ...future.conditions <- base::list()
[18:06:08.749]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.749]     if (FALSE) {
[18:06:08.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.749]     }
[18:06:08.749]     ...future.result <- base::tryCatch({
[18:06:08.749]         base::withCallingHandlers({
[18:06:08.749]             ...future.value <- base::withVisible(base::local({
[18:06:08.749]                 withCallingHandlers({
[18:06:08.749]                   2
[18:06:08.749]                 }, immediateCondition = function(cond) {
[18:06:08.749]                   save_rds <- function (object, pathname, ...) 
[18:06:08.749]                   {
[18:06:08.749]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.749]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.749]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.749]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.749]                         fi_tmp[["mtime"]])
[18:06:08.749]                     }
[18:06:08.749]                     tryCatch({
[18:06:08.749]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.749]                     }, error = function(ex) {
[18:06:08.749]                       msg <- conditionMessage(ex)
[18:06:08.749]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.749]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.749]                         fi_tmp[["mtime"]], msg)
[18:06:08.749]                       ex$message <- msg
[18:06:08.749]                       stop(ex)
[18:06:08.749]                     })
[18:06:08.749]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.749]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.749]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.749]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.749]                       fi <- file.info(pathname)
[18:06:08.749]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.749]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.749]                         fi[["size"]], fi[["mtime"]])
[18:06:08.749]                       stop(msg)
[18:06:08.749]                     }
[18:06:08.749]                     invisible(pathname)
[18:06:08.749]                   }
[18:06:08.749]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.749]                     rootPath = tempdir()) 
[18:06:08.749]                   {
[18:06:08.749]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.749]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.749]                       tmpdir = path, fileext = ".rds")
[18:06:08.749]                     save_rds(obj, file)
[18:06:08.749]                   }
[18:06:08.749]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.749]                   {
[18:06:08.749]                     inherits <- base::inherits
[18:06:08.749]                     invokeRestart <- base::invokeRestart
[18:06:08.749]                     is.null <- base::is.null
[18:06:08.749]                     muffled <- FALSE
[18:06:08.749]                     if (inherits(cond, "message")) {
[18:06:08.749]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.749]                       if (muffled) 
[18:06:08.749]                         invokeRestart("muffleMessage")
[18:06:08.749]                     }
[18:06:08.749]                     else if (inherits(cond, "warning")) {
[18:06:08.749]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.749]                       if (muffled) 
[18:06:08.749]                         invokeRestart("muffleWarning")
[18:06:08.749]                     }
[18:06:08.749]                     else if (inherits(cond, "condition")) {
[18:06:08.749]                       if (!is.null(pattern)) {
[18:06:08.749]                         computeRestarts <- base::computeRestarts
[18:06:08.749]                         grepl <- base::grepl
[18:06:08.749]                         restarts <- computeRestarts(cond)
[18:06:08.749]                         for (restart in restarts) {
[18:06:08.749]                           name <- restart$name
[18:06:08.749]                           if (is.null(name)) 
[18:06:08.749]                             next
[18:06:08.749]                           if (!grepl(pattern, name)) 
[18:06:08.749]                             next
[18:06:08.749]                           invokeRestart(restart)
[18:06:08.749]                           muffled <- TRUE
[18:06:08.749]                           break
[18:06:08.749]                         }
[18:06:08.749]                       }
[18:06:08.749]                     }
[18:06:08.749]                     invisible(muffled)
[18:06:08.749]                   }
[18:06:08.749]                   muffleCondition(cond)
[18:06:08.749]                 })
[18:06:08.749]             }))
[18:06:08.749]             future::FutureResult(value = ...future.value$value, 
[18:06:08.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.749]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.749]                     ...future.globalenv.names))
[18:06:08.749]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.749]         }, condition = base::local({
[18:06:08.749]             c <- base::c
[18:06:08.749]             inherits <- base::inherits
[18:06:08.749]             invokeRestart <- base::invokeRestart
[18:06:08.749]             length <- base::length
[18:06:08.749]             list <- base::list
[18:06:08.749]             seq.int <- base::seq.int
[18:06:08.749]             signalCondition <- base::signalCondition
[18:06:08.749]             sys.calls <- base::sys.calls
[18:06:08.749]             `[[` <- base::`[[`
[18:06:08.749]             `+` <- base::`+`
[18:06:08.749]             `<<-` <- base::`<<-`
[18:06:08.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.749]                   3L)]
[18:06:08.749]             }
[18:06:08.749]             function(cond) {
[18:06:08.749]                 is_error <- inherits(cond, "error")
[18:06:08.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.749]                   NULL)
[18:06:08.749]                 if (is_error) {
[18:06:08.749]                   sessionInformation <- function() {
[18:06:08.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.749]                       search = base::search(), system = base::Sys.info())
[18:06:08.749]                   }
[18:06:08.749]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.749]                     cond$call), session = sessionInformation(), 
[18:06:08.749]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.749]                   signalCondition(cond)
[18:06:08.749]                 }
[18:06:08.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.749]                 "immediateCondition"))) {
[18:06:08.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.749]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.749]                   if (TRUE && !signal) {
[18:06:08.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.749]                     {
[18:06:08.749]                       inherits <- base::inherits
[18:06:08.749]                       invokeRestart <- base::invokeRestart
[18:06:08.749]                       is.null <- base::is.null
[18:06:08.749]                       muffled <- FALSE
[18:06:08.749]                       if (inherits(cond, "message")) {
[18:06:08.749]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.749]                         if (muffled) 
[18:06:08.749]                           invokeRestart("muffleMessage")
[18:06:08.749]                       }
[18:06:08.749]                       else if (inherits(cond, "warning")) {
[18:06:08.749]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.749]                         if (muffled) 
[18:06:08.749]                           invokeRestart("muffleWarning")
[18:06:08.749]                       }
[18:06:08.749]                       else if (inherits(cond, "condition")) {
[18:06:08.749]                         if (!is.null(pattern)) {
[18:06:08.749]                           computeRestarts <- base::computeRestarts
[18:06:08.749]                           grepl <- base::grepl
[18:06:08.749]                           restarts <- computeRestarts(cond)
[18:06:08.749]                           for (restart in restarts) {
[18:06:08.749]                             name <- restart$name
[18:06:08.749]                             if (is.null(name)) 
[18:06:08.749]                               next
[18:06:08.749]                             if (!grepl(pattern, name)) 
[18:06:08.749]                               next
[18:06:08.749]                             invokeRestart(restart)
[18:06:08.749]                             muffled <- TRUE
[18:06:08.749]                             break
[18:06:08.749]                           }
[18:06:08.749]                         }
[18:06:08.749]                       }
[18:06:08.749]                       invisible(muffled)
[18:06:08.749]                     }
[18:06:08.749]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.749]                   }
[18:06:08.749]                 }
[18:06:08.749]                 else {
[18:06:08.749]                   if (TRUE) {
[18:06:08.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.749]                     {
[18:06:08.749]                       inherits <- base::inherits
[18:06:08.749]                       invokeRestart <- base::invokeRestart
[18:06:08.749]                       is.null <- base::is.null
[18:06:08.749]                       muffled <- FALSE
[18:06:08.749]                       if (inherits(cond, "message")) {
[18:06:08.749]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.749]                         if (muffled) 
[18:06:08.749]                           invokeRestart("muffleMessage")
[18:06:08.749]                       }
[18:06:08.749]                       else if (inherits(cond, "warning")) {
[18:06:08.749]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.749]                         if (muffled) 
[18:06:08.749]                           invokeRestart("muffleWarning")
[18:06:08.749]                       }
[18:06:08.749]                       else if (inherits(cond, "condition")) {
[18:06:08.749]                         if (!is.null(pattern)) {
[18:06:08.749]                           computeRestarts <- base::computeRestarts
[18:06:08.749]                           grepl <- base::grepl
[18:06:08.749]                           restarts <- computeRestarts(cond)
[18:06:08.749]                           for (restart in restarts) {
[18:06:08.749]                             name <- restart$name
[18:06:08.749]                             if (is.null(name)) 
[18:06:08.749]                               next
[18:06:08.749]                             if (!grepl(pattern, name)) 
[18:06:08.749]                               next
[18:06:08.749]                             invokeRestart(restart)
[18:06:08.749]                             muffled <- TRUE
[18:06:08.749]                             break
[18:06:08.749]                           }
[18:06:08.749]                         }
[18:06:08.749]                       }
[18:06:08.749]                       invisible(muffled)
[18:06:08.749]                     }
[18:06:08.749]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.749]                   }
[18:06:08.749]                 }
[18:06:08.749]             }
[18:06:08.749]         }))
[18:06:08.749]     }, error = function(ex) {
[18:06:08.749]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.749]                 ...future.rng), started = ...future.startTime, 
[18:06:08.749]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.749]             version = "1.8"), class = "FutureResult")
[18:06:08.749]     }, finally = {
[18:06:08.749]         if (!identical(...future.workdir, getwd())) 
[18:06:08.749]             setwd(...future.workdir)
[18:06:08.749]         {
[18:06:08.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.749]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.749]             }
[18:06:08.749]             base::options(...future.oldOptions)
[18:06:08.749]             if (.Platform$OS.type == "windows") {
[18:06:08.749]                 old_names <- names(...future.oldEnvVars)
[18:06:08.749]                 envs <- base::Sys.getenv()
[18:06:08.749]                 names <- names(envs)
[18:06:08.749]                 common <- intersect(names, old_names)
[18:06:08.749]                 added <- setdiff(names, old_names)
[18:06:08.749]                 removed <- setdiff(old_names, names)
[18:06:08.749]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.749]                   envs[common]]
[18:06:08.749]                 NAMES <- toupper(changed)
[18:06:08.749]                 args <- list()
[18:06:08.749]                 for (kk in seq_along(NAMES)) {
[18:06:08.749]                   name <- changed[[kk]]
[18:06:08.749]                   NAME <- NAMES[[kk]]
[18:06:08.749]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.749]                     next
[18:06:08.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.749]                 }
[18:06:08.749]                 NAMES <- toupper(added)
[18:06:08.749]                 for (kk in seq_along(NAMES)) {
[18:06:08.749]                   name <- added[[kk]]
[18:06:08.749]                   NAME <- NAMES[[kk]]
[18:06:08.749]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.749]                     next
[18:06:08.749]                   args[[name]] <- ""
[18:06:08.749]                 }
[18:06:08.749]                 NAMES <- toupper(removed)
[18:06:08.749]                 for (kk in seq_along(NAMES)) {
[18:06:08.749]                   name <- removed[[kk]]
[18:06:08.749]                   NAME <- NAMES[[kk]]
[18:06:08.749]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.749]                     next
[18:06:08.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.749]                 }
[18:06:08.749]                 if (length(args) > 0) 
[18:06:08.749]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.749]             }
[18:06:08.749]             else {
[18:06:08.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.749]             }
[18:06:08.749]             {
[18:06:08.749]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.749]                   0L) {
[18:06:08.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.749]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.749]                   base::options(opts)
[18:06:08.749]                 }
[18:06:08.749]                 {
[18:06:08.749]                   {
[18:06:08.749]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.749]                     NULL
[18:06:08.749]                   }
[18:06:08.749]                   options(future.plan = NULL)
[18:06:08.749]                   if (is.na(NA_character_)) 
[18:06:08.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.749]                     .init = FALSE)
[18:06:08.749]                 }
[18:06:08.749]             }
[18:06:08.749]         }
[18:06:08.749]     })
[18:06:08.749]     if (TRUE) {
[18:06:08.749]         base::sink(type = "output", split = FALSE)
[18:06:08.749]         if (TRUE) {
[18:06:08.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.749]         }
[18:06:08.749]         else {
[18:06:08.749]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.749]         }
[18:06:08.749]         base::close(...future.stdout)
[18:06:08.749]         ...future.stdout <- NULL
[18:06:08.749]     }
[18:06:08.749]     ...future.result$conditions <- ...future.conditions
[18:06:08.749]     ...future.result$finished <- base::Sys.time()
[18:06:08.749]     ...future.result
[18:06:08.749] }
[18:06:08.756] requestCore(): workers = 2
[18:06:08.760] MulticoreFuture started
[18:06:08.761] - Launch lazy future ... done
[18:06:08.761] run() for ‘MulticoreFuture’ ... done
[18:06:08.764] resolve() on list environment ...
[18:06:08.764]  recursive: 0
[18:06:08.764] plan(): Setting new future strategy stack:
[18:06:08.767]  length: 3
[18:06:08.767]  elements: ‘a’, ‘b’, ‘c’
[18:06:08.768] Future #1
[18:06:08.765] List of future strategies:
[18:06:08.765] 1. sequential:
[18:06:08.765]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.765]    - tweaked: FALSE
[18:06:08.765]    - call: NULL
[18:06:08.769]  length: 2 (resolved future 1)
[18:06:08.769] plan(): nbrOfWorkers() = 1
[18:06:08.774] plan(): Setting new future strategy stack:
[18:06:08.774] List of future strategies:
[18:06:08.774] 1. multicore:
[18:06:08.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.774]    - tweaked: FALSE
[18:06:08.774]    - call: plan(strategy)
[18:06:08.780]  length: 1 (resolved future 3)
[18:06:08.784] plan(): nbrOfWorkers() = 2
[18:06:08.791] Future #2
[18:06:08.792]  length: 0 (resolved future 2)
[18:06:08.792] resolve() on list environment ... DONE
[18:06:08.795] getGlobalsAndPackages() ...
[18:06:08.795] Searching for globals...
[18:06:08.798] - globals found: [1] ‘{’
[18:06:08.798] Searching for globals ... DONE
[18:06:08.799] Resolving globals: FALSE
[18:06:08.800] 
[18:06:08.800] 
[18:06:08.801] getGlobalsAndPackages() ... DONE
[18:06:08.802] run() for ‘Future’ ...
[18:06:08.802] - state: ‘created’
[18:06:08.802] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.811] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.812] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.812]   - Field: ‘label’
[18:06:08.812]   - Field: ‘local’
[18:06:08.813]   - Field: ‘owner’
[18:06:08.813]   - Field: ‘envir’
[18:06:08.813]   - Field: ‘workers’
[18:06:08.814]   - Field: ‘packages’
[18:06:08.814]   - Field: ‘gc’
[18:06:08.814]   - Field: ‘job’
[18:06:08.815]   - Field: ‘conditions’
[18:06:08.815]   - Field: ‘expr’
[18:06:08.815]   - Field: ‘uuid’
[18:06:08.816]   - Field: ‘seed’
[18:06:08.816]   - Field: ‘version’
[18:06:08.816]   - Field: ‘result’
[18:06:08.817]   - Field: ‘asynchronous’
[18:06:08.817]   - Field: ‘calls’
[18:06:08.817]   - Field: ‘globals’
[18:06:08.818]   - Field: ‘stdout’
[18:06:08.818]   - Field: ‘earlySignal’
[18:06:08.818]   - Field: ‘lazy’
[18:06:08.819]   - Field: ‘state’
[18:06:08.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.819] - Launch lazy future ...
[18:06:08.820] Packages needed by the future expression (n = 0): <none>
[18:06:08.821] Packages needed by future strategies (n = 0): <none>
[18:06:08.822] {
[18:06:08.822]     {
[18:06:08.822]         {
[18:06:08.822]             ...future.startTime <- base::Sys.time()
[18:06:08.822]             {
[18:06:08.822]                 {
[18:06:08.822]                   {
[18:06:08.822]                     {
[18:06:08.822]                       base::local({
[18:06:08.822]                         has_future <- base::requireNamespace("future", 
[18:06:08.822]                           quietly = TRUE)
[18:06:08.822]                         if (has_future) {
[18:06:08.822]                           ns <- base::getNamespace("future")
[18:06:08.822]                           version <- ns[[".package"]][["version"]]
[18:06:08.822]                           if (is.null(version)) 
[18:06:08.822]                             version <- utils::packageVersion("future")
[18:06:08.822]                         }
[18:06:08.822]                         else {
[18:06:08.822]                           version <- NULL
[18:06:08.822]                         }
[18:06:08.822]                         if (!has_future || version < "1.8.0") {
[18:06:08.822]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.822]                             "", base::R.version$version.string), 
[18:06:08.822]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.822]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.822]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.822]                               "release", "version")], collapse = " "), 
[18:06:08.822]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.822]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.822]                             info)
[18:06:08.822]                           info <- base::paste(info, collapse = "; ")
[18:06:08.822]                           if (!has_future) {
[18:06:08.822]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.822]                               info)
[18:06:08.822]                           }
[18:06:08.822]                           else {
[18:06:08.822]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.822]                               info, version)
[18:06:08.822]                           }
[18:06:08.822]                           base::stop(msg)
[18:06:08.822]                         }
[18:06:08.822]                       })
[18:06:08.822]                     }
[18:06:08.822]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.822]                     base::options(mc.cores = 1L)
[18:06:08.822]                   }
[18:06:08.822]                   ...future.strategy.old <- future::plan("list")
[18:06:08.822]                   options(future.plan = NULL)
[18:06:08.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.822]                 }
[18:06:08.822]                 ...future.workdir <- getwd()
[18:06:08.822]             }
[18:06:08.822]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.822]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.822]         }
[18:06:08.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.822]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.822]             base::names(...future.oldOptions))
[18:06:08.822]     }
[18:06:08.822]     if (FALSE) {
[18:06:08.822]     }
[18:06:08.822]     else {
[18:06:08.822]         if (TRUE) {
[18:06:08.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.822]                 open = "w")
[18:06:08.822]         }
[18:06:08.822]         else {
[18:06:08.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.822]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.822]         }
[18:06:08.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.822]             base::sink(type = "output", split = FALSE)
[18:06:08.822]             base::close(...future.stdout)
[18:06:08.822]         }, add = TRUE)
[18:06:08.822]     }
[18:06:08.822]     ...future.frame <- base::sys.nframe()
[18:06:08.822]     ...future.conditions <- base::list()
[18:06:08.822]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.822]     if (FALSE) {
[18:06:08.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.822]     }
[18:06:08.822]     ...future.result <- base::tryCatch({
[18:06:08.822]         base::withCallingHandlers({
[18:06:08.822]             ...future.value <- base::withVisible(base::local({
[18:06:08.822]                 withCallingHandlers({
[18:06:08.822]                   {
[18:06:08.822]                     1
[18:06:08.822]                   }
[18:06:08.822]                 }, immediateCondition = function(cond) {
[18:06:08.822]                   save_rds <- function (object, pathname, ...) 
[18:06:08.822]                   {
[18:06:08.822]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.822]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.822]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.822]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.822]                         fi_tmp[["mtime"]])
[18:06:08.822]                     }
[18:06:08.822]                     tryCatch({
[18:06:08.822]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.822]                     }, error = function(ex) {
[18:06:08.822]                       msg <- conditionMessage(ex)
[18:06:08.822]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.822]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.822]                         fi_tmp[["mtime"]], msg)
[18:06:08.822]                       ex$message <- msg
[18:06:08.822]                       stop(ex)
[18:06:08.822]                     })
[18:06:08.822]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.822]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.822]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.822]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.822]                       fi <- file.info(pathname)
[18:06:08.822]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.822]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.822]                         fi[["size"]], fi[["mtime"]])
[18:06:08.822]                       stop(msg)
[18:06:08.822]                     }
[18:06:08.822]                     invisible(pathname)
[18:06:08.822]                   }
[18:06:08.822]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.822]                     rootPath = tempdir()) 
[18:06:08.822]                   {
[18:06:08.822]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.822]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.822]                       tmpdir = path, fileext = ".rds")
[18:06:08.822]                     save_rds(obj, file)
[18:06:08.822]                   }
[18:06:08.822]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.822]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.822]                   {
[18:06:08.822]                     inherits <- base::inherits
[18:06:08.822]                     invokeRestart <- base::invokeRestart
[18:06:08.822]                     is.null <- base::is.null
[18:06:08.822]                     muffled <- FALSE
[18:06:08.822]                     if (inherits(cond, "message")) {
[18:06:08.822]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.822]                       if (muffled) 
[18:06:08.822]                         invokeRestart("muffleMessage")
[18:06:08.822]                     }
[18:06:08.822]                     else if (inherits(cond, "warning")) {
[18:06:08.822]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.822]                       if (muffled) 
[18:06:08.822]                         invokeRestart("muffleWarning")
[18:06:08.822]                     }
[18:06:08.822]                     else if (inherits(cond, "condition")) {
[18:06:08.822]                       if (!is.null(pattern)) {
[18:06:08.822]                         computeRestarts <- base::computeRestarts
[18:06:08.822]                         grepl <- base::grepl
[18:06:08.822]                         restarts <- computeRestarts(cond)
[18:06:08.822]                         for (restart in restarts) {
[18:06:08.822]                           name <- restart$name
[18:06:08.822]                           if (is.null(name)) 
[18:06:08.822]                             next
[18:06:08.822]                           if (!grepl(pattern, name)) 
[18:06:08.822]                             next
[18:06:08.822]                           invokeRestart(restart)
[18:06:08.822]                           muffled <- TRUE
[18:06:08.822]                           break
[18:06:08.822]                         }
[18:06:08.822]                       }
[18:06:08.822]                     }
[18:06:08.822]                     invisible(muffled)
[18:06:08.822]                   }
[18:06:08.822]                   muffleCondition(cond)
[18:06:08.822]                 })
[18:06:08.822]             }))
[18:06:08.822]             future::FutureResult(value = ...future.value$value, 
[18:06:08.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.822]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.822]                     ...future.globalenv.names))
[18:06:08.822]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.822]         }, condition = base::local({
[18:06:08.822]             c <- base::c
[18:06:08.822]             inherits <- base::inherits
[18:06:08.822]             invokeRestart <- base::invokeRestart
[18:06:08.822]             length <- base::length
[18:06:08.822]             list <- base::list
[18:06:08.822]             seq.int <- base::seq.int
[18:06:08.822]             signalCondition <- base::signalCondition
[18:06:08.822]             sys.calls <- base::sys.calls
[18:06:08.822]             `[[` <- base::`[[`
[18:06:08.822]             `+` <- base::`+`
[18:06:08.822]             `<<-` <- base::`<<-`
[18:06:08.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.822]                   3L)]
[18:06:08.822]             }
[18:06:08.822]             function(cond) {
[18:06:08.822]                 is_error <- inherits(cond, "error")
[18:06:08.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.822]                   NULL)
[18:06:08.822]                 if (is_error) {
[18:06:08.822]                   sessionInformation <- function() {
[18:06:08.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.822]                       search = base::search(), system = base::Sys.info())
[18:06:08.822]                   }
[18:06:08.822]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.822]                     cond$call), session = sessionInformation(), 
[18:06:08.822]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.822]                   signalCondition(cond)
[18:06:08.822]                 }
[18:06:08.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.822]                 "immediateCondition"))) {
[18:06:08.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.822]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.822]                   if (TRUE && !signal) {
[18:06:08.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.822]                     {
[18:06:08.822]                       inherits <- base::inherits
[18:06:08.822]                       invokeRestart <- base::invokeRestart
[18:06:08.822]                       is.null <- base::is.null
[18:06:08.822]                       muffled <- FALSE
[18:06:08.822]                       if (inherits(cond, "message")) {
[18:06:08.822]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.822]                         if (muffled) 
[18:06:08.822]                           invokeRestart("muffleMessage")
[18:06:08.822]                       }
[18:06:08.822]                       else if (inherits(cond, "warning")) {
[18:06:08.822]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.822]                         if (muffled) 
[18:06:08.822]                           invokeRestart("muffleWarning")
[18:06:08.822]                       }
[18:06:08.822]                       else if (inherits(cond, "condition")) {
[18:06:08.822]                         if (!is.null(pattern)) {
[18:06:08.822]                           computeRestarts <- base::computeRestarts
[18:06:08.822]                           grepl <- base::grepl
[18:06:08.822]                           restarts <- computeRestarts(cond)
[18:06:08.822]                           for (restart in restarts) {
[18:06:08.822]                             name <- restart$name
[18:06:08.822]                             if (is.null(name)) 
[18:06:08.822]                               next
[18:06:08.822]                             if (!grepl(pattern, name)) 
[18:06:08.822]                               next
[18:06:08.822]                             invokeRestart(restart)
[18:06:08.822]                             muffled <- TRUE
[18:06:08.822]                             break
[18:06:08.822]                           }
[18:06:08.822]                         }
[18:06:08.822]                       }
[18:06:08.822]                       invisible(muffled)
[18:06:08.822]                     }
[18:06:08.822]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.822]                   }
[18:06:08.822]                 }
[18:06:08.822]                 else {
[18:06:08.822]                   if (TRUE) {
[18:06:08.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.822]                     {
[18:06:08.822]                       inherits <- base::inherits
[18:06:08.822]                       invokeRestart <- base::invokeRestart
[18:06:08.822]                       is.null <- base::is.null
[18:06:08.822]                       muffled <- FALSE
[18:06:08.822]                       if (inherits(cond, "message")) {
[18:06:08.822]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.822]                         if (muffled) 
[18:06:08.822]                           invokeRestart("muffleMessage")
[18:06:08.822]                       }
[18:06:08.822]                       else if (inherits(cond, "warning")) {
[18:06:08.822]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.822]                         if (muffled) 
[18:06:08.822]                           invokeRestart("muffleWarning")
[18:06:08.822]                       }
[18:06:08.822]                       else if (inherits(cond, "condition")) {
[18:06:08.822]                         if (!is.null(pattern)) {
[18:06:08.822]                           computeRestarts <- base::computeRestarts
[18:06:08.822]                           grepl <- base::grepl
[18:06:08.822]                           restarts <- computeRestarts(cond)
[18:06:08.822]                           for (restart in restarts) {
[18:06:08.822]                             name <- restart$name
[18:06:08.822]                             if (is.null(name)) 
[18:06:08.822]                               next
[18:06:08.822]                             if (!grepl(pattern, name)) 
[18:06:08.822]                               next
[18:06:08.822]                             invokeRestart(restart)
[18:06:08.822]                             muffled <- TRUE
[18:06:08.822]                             break
[18:06:08.822]                           }
[18:06:08.822]                         }
[18:06:08.822]                       }
[18:06:08.822]                       invisible(muffled)
[18:06:08.822]                     }
[18:06:08.822]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.822]                   }
[18:06:08.822]                 }
[18:06:08.822]             }
[18:06:08.822]         }))
[18:06:08.822]     }, error = function(ex) {
[18:06:08.822]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.822]                 ...future.rng), started = ...future.startTime, 
[18:06:08.822]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.822]             version = "1.8"), class = "FutureResult")
[18:06:08.822]     }, finally = {
[18:06:08.822]         if (!identical(...future.workdir, getwd())) 
[18:06:08.822]             setwd(...future.workdir)
[18:06:08.822]         {
[18:06:08.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.822]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.822]             }
[18:06:08.822]             base::options(...future.oldOptions)
[18:06:08.822]             if (.Platform$OS.type == "windows") {
[18:06:08.822]                 old_names <- names(...future.oldEnvVars)
[18:06:08.822]                 envs <- base::Sys.getenv()
[18:06:08.822]                 names <- names(envs)
[18:06:08.822]                 common <- intersect(names, old_names)
[18:06:08.822]                 added <- setdiff(names, old_names)
[18:06:08.822]                 removed <- setdiff(old_names, names)
[18:06:08.822]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.822]                   envs[common]]
[18:06:08.822]                 NAMES <- toupper(changed)
[18:06:08.822]                 args <- list()
[18:06:08.822]                 for (kk in seq_along(NAMES)) {
[18:06:08.822]                   name <- changed[[kk]]
[18:06:08.822]                   NAME <- NAMES[[kk]]
[18:06:08.822]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.822]                     next
[18:06:08.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.822]                 }
[18:06:08.822]                 NAMES <- toupper(added)
[18:06:08.822]                 for (kk in seq_along(NAMES)) {
[18:06:08.822]                   name <- added[[kk]]
[18:06:08.822]                   NAME <- NAMES[[kk]]
[18:06:08.822]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.822]                     next
[18:06:08.822]                   args[[name]] <- ""
[18:06:08.822]                 }
[18:06:08.822]                 NAMES <- toupper(removed)
[18:06:08.822]                 for (kk in seq_along(NAMES)) {
[18:06:08.822]                   name <- removed[[kk]]
[18:06:08.822]                   NAME <- NAMES[[kk]]
[18:06:08.822]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.822]                     next
[18:06:08.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.822]                 }
[18:06:08.822]                 if (length(args) > 0) 
[18:06:08.822]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.822]             }
[18:06:08.822]             else {
[18:06:08.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.822]             }
[18:06:08.822]             {
[18:06:08.822]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.822]                   0L) {
[18:06:08.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.822]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.822]                   base::options(opts)
[18:06:08.822]                 }
[18:06:08.822]                 {
[18:06:08.822]                   {
[18:06:08.822]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.822]                     NULL
[18:06:08.822]                   }
[18:06:08.822]                   options(future.plan = NULL)
[18:06:08.822]                   if (is.na(NA_character_)) 
[18:06:08.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.822]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.822]                     .init = FALSE)
[18:06:08.822]                 }
[18:06:08.822]             }
[18:06:08.822]         }
[18:06:08.822]     })
[18:06:08.822]     if (TRUE) {
[18:06:08.822]         base::sink(type = "output", split = FALSE)
[18:06:08.822]         if (TRUE) {
[18:06:08.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.822]         }
[18:06:08.822]         else {
[18:06:08.822]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.822]         }
[18:06:08.822]         base::close(...future.stdout)
[18:06:08.822]         ...future.stdout <- NULL
[18:06:08.822]     }
[18:06:08.822]     ...future.result$conditions <- ...future.conditions
[18:06:08.822]     ...future.result$finished <- base::Sys.time()
[18:06:08.822]     ...future.result
[18:06:08.822] }
[18:06:08.829] requestCore(): workers = 2
[18:06:08.830] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.841] result() for MulticoreFuture ...
[18:06:08.843] result() for MulticoreFuture ...
[18:06:08.843] result() for MulticoreFuture ... done
[18:06:08.844] result() for MulticoreFuture ... done
[18:06:08.844] result() for MulticoreFuture ...
[18:06:08.844] result() for MulticoreFuture ... done
[18:06:08.849] MulticoreFuture started
[18:06:08.852] - Launch lazy future ... done
[18:06:08.852] run() for ‘MulticoreFuture’ ... done
[18:06:08.854] plan(): Setting new future strategy stack:
[18:06:08.856] getGlobalsAndPackages() ...
[18:06:08.854] List of future strategies:
[18:06:08.854] 1. sequential:
[18:06:08.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.854]    - tweaked: FALSE
[18:06:08.854]    - call: NULL
[18:06:08.856] Searching for globals...
[18:06:08.861] plan(): nbrOfWorkers() = 1
[18:06:08.864] - globals found: [1] ‘{’
[18:06:08.864] Searching for globals ... DONE
[18:06:08.865] Resolving globals: FALSE
[18:06:08.868] 
[18:06:08.868] 
[18:06:08.869] plan(): Setting new future strategy stack:
[18:06:08.870] List of future strategies:
[18:06:08.870] 1. multicore:
[18:06:08.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.870]    - tweaked: FALSE
[18:06:08.870]    - call: plan(strategy)
[18:06:08.869] getGlobalsAndPackages() ... DONE
[18:06:08.872] run() for ‘Future’ ...
[18:06:08.872] - state: ‘created’
[18:06:08.873] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.888] plan(): nbrOfWorkers() = 2
[18:06:08.906] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.907] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.907]   - Field: ‘label’
[18:06:08.908]   - Field: ‘local’
[18:06:08.909]   - Field: ‘owner’
[18:06:08.909]   - Field: ‘envir’
[18:06:08.910]   - Field: ‘workers’
[18:06:08.910]   - Field: ‘packages’
[18:06:08.910]   - Field: ‘gc’
[18:06:08.911]   - Field: ‘job’
[18:06:08.911]   - Field: ‘conditions’
[18:06:08.912]   - Field: ‘expr’
[18:06:08.912]   - Field: ‘uuid’
[18:06:08.912]   - Field: ‘seed’
[18:06:08.913]   - Field: ‘version’
[18:06:08.913]   - Field: ‘result’
[18:06:08.914]   - Field: ‘asynchronous’
[18:06:08.914]   - Field: ‘calls’
[18:06:08.914]   - Field: ‘globals’
[18:06:08.915]   - Field: ‘stdout’
[18:06:08.915]   - Field: ‘earlySignal’
[18:06:08.915]   - Field: ‘lazy’
[18:06:08.916]   - Field: ‘state’
[18:06:08.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.917] - Launch lazy future ...
[18:06:08.917] Packages needed by the future expression (n = 0): <none>
[18:06:08.918] Packages needed by future strategies (n = 0): <none>
[18:06:08.919] {
[18:06:08.919]     {
[18:06:08.919]         {
[18:06:08.919]             ...future.startTime <- base::Sys.time()
[18:06:08.919]             {
[18:06:08.919]                 {
[18:06:08.919]                   {
[18:06:08.919]                     {
[18:06:08.919]                       base::local({
[18:06:08.919]                         has_future <- base::requireNamespace("future", 
[18:06:08.919]                           quietly = TRUE)
[18:06:08.919]                         if (has_future) {
[18:06:08.919]                           ns <- base::getNamespace("future")
[18:06:08.919]                           version <- ns[[".package"]][["version"]]
[18:06:08.919]                           if (is.null(version)) 
[18:06:08.919]                             version <- utils::packageVersion("future")
[18:06:08.919]                         }
[18:06:08.919]                         else {
[18:06:08.919]                           version <- NULL
[18:06:08.919]                         }
[18:06:08.919]                         if (!has_future || version < "1.8.0") {
[18:06:08.919]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.919]                             "", base::R.version$version.string), 
[18:06:08.919]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.919]                               "release", "version")], collapse = " "), 
[18:06:08.919]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.919]                             info)
[18:06:08.919]                           info <- base::paste(info, collapse = "; ")
[18:06:08.919]                           if (!has_future) {
[18:06:08.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.919]                               info)
[18:06:08.919]                           }
[18:06:08.919]                           else {
[18:06:08.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.919]                               info, version)
[18:06:08.919]                           }
[18:06:08.919]                           base::stop(msg)
[18:06:08.919]                         }
[18:06:08.919]                       })
[18:06:08.919]                     }
[18:06:08.919]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.919]                     base::options(mc.cores = 1L)
[18:06:08.919]                   }
[18:06:08.919]                   ...future.strategy.old <- future::plan("list")
[18:06:08.919]                   options(future.plan = NULL)
[18:06:08.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.919]                 }
[18:06:08.919]                 ...future.workdir <- getwd()
[18:06:08.919]             }
[18:06:08.919]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.919]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.919]         }
[18:06:08.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.919]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.919]             base::names(...future.oldOptions))
[18:06:08.919]     }
[18:06:08.919]     if (FALSE) {
[18:06:08.919]     }
[18:06:08.919]     else {
[18:06:08.919]         if (TRUE) {
[18:06:08.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.919]                 open = "w")
[18:06:08.919]         }
[18:06:08.919]         else {
[18:06:08.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.919]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.919]         }
[18:06:08.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.919]             base::sink(type = "output", split = FALSE)
[18:06:08.919]             base::close(...future.stdout)
[18:06:08.919]         }, add = TRUE)
[18:06:08.919]     }
[18:06:08.919]     ...future.frame <- base::sys.nframe()
[18:06:08.919]     ...future.conditions <- base::list()
[18:06:08.919]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.919]     if (FALSE) {
[18:06:08.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.919]     }
[18:06:08.919]     ...future.result <- base::tryCatch({
[18:06:08.919]         base::withCallingHandlers({
[18:06:08.919]             ...future.value <- base::withVisible(base::local({
[18:06:08.919]                 withCallingHandlers({
[18:06:08.919]                   {
[18:06:08.919]                     2
[18:06:08.919]                   }
[18:06:08.919]                 }, immediateCondition = function(cond) {
[18:06:08.919]                   save_rds <- function (object, pathname, ...) 
[18:06:08.919]                   {
[18:06:08.919]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.919]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.919]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.919]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.919]                         fi_tmp[["mtime"]])
[18:06:08.919]                     }
[18:06:08.919]                     tryCatch({
[18:06:08.919]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.919]                     }, error = function(ex) {
[18:06:08.919]                       msg <- conditionMessage(ex)
[18:06:08.919]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.919]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.919]                         fi_tmp[["mtime"]], msg)
[18:06:08.919]                       ex$message <- msg
[18:06:08.919]                       stop(ex)
[18:06:08.919]                     })
[18:06:08.919]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.919]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.919]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.919]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.919]                       fi <- file.info(pathname)
[18:06:08.919]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.919]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.919]                         fi[["size"]], fi[["mtime"]])
[18:06:08.919]                       stop(msg)
[18:06:08.919]                     }
[18:06:08.919]                     invisible(pathname)
[18:06:08.919]                   }
[18:06:08.919]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.919]                     rootPath = tempdir()) 
[18:06:08.919]                   {
[18:06:08.919]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.919]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.919]                       tmpdir = path, fileext = ".rds")
[18:06:08.919]                     save_rds(obj, file)
[18:06:08.919]                   }
[18:06:08.919]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.919]                   {
[18:06:08.919]                     inherits <- base::inherits
[18:06:08.919]                     invokeRestart <- base::invokeRestart
[18:06:08.919]                     is.null <- base::is.null
[18:06:08.919]                     muffled <- FALSE
[18:06:08.919]                     if (inherits(cond, "message")) {
[18:06:08.919]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.919]                       if (muffled) 
[18:06:08.919]                         invokeRestart("muffleMessage")
[18:06:08.919]                     }
[18:06:08.919]                     else if (inherits(cond, "warning")) {
[18:06:08.919]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.919]                       if (muffled) 
[18:06:08.919]                         invokeRestart("muffleWarning")
[18:06:08.919]                     }
[18:06:08.919]                     else if (inherits(cond, "condition")) {
[18:06:08.919]                       if (!is.null(pattern)) {
[18:06:08.919]                         computeRestarts <- base::computeRestarts
[18:06:08.919]                         grepl <- base::grepl
[18:06:08.919]                         restarts <- computeRestarts(cond)
[18:06:08.919]                         for (restart in restarts) {
[18:06:08.919]                           name <- restart$name
[18:06:08.919]                           if (is.null(name)) 
[18:06:08.919]                             next
[18:06:08.919]                           if (!grepl(pattern, name)) 
[18:06:08.919]                             next
[18:06:08.919]                           invokeRestart(restart)
[18:06:08.919]                           muffled <- TRUE
[18:06:08.919]                           break
[18:06:08.919]                         }
[18:06:08.919]                       }
[18:06:08.919]                     }
[18:06:08.919]                     invisible(muffled)
[18:06:08.919]                   }
[18:06:08.919]                   muffleCondition(cond)
[18:06:08.919]                 })
[18:06:08.919]             }))
[18:06:08.919]             future::FutureResult(value = ...future.value$value, 
[18:06:08.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.919]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.919]                     ...future.globalenv.names))
[18:06:08.919]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.919]         }, condition = base::local({
[18:06:08.919]             c <- base::c
[18:06:08.919]             inherits <- base::inherits
[18:06:08.919]             invokeRestart <- base::invokeRestart
[18:06:08.919]             length <- base::length
[18:06:08.919]             list <- base::list
[18:06:08.919]             seq.int <- base::seq.int
[18:06:08.919]             signalCondition <- base::signalCondition
[18:06:08.919]             sys.calls <- base::sys.calls
[18:06:08.919]             `[[` <- base::`[[`
[18:06:08.919]             `+` <- base::`+`
[18:06:08.919]             `<<-` <- base::`<<-`
[18:06:08.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.919]                   3L)]
[18:06:08.919]             }
[18:06:08.919]             function(cond) {
[18:06:08.919]                 is_error <- inherits(cond, "error")
[18:06:08.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.919]                   NULL)
[18:06:08.919]                 if (is_error) {
[18:06:08.919]                   sessionInformation <- function() {
[18:06:08.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.919]                       search = base::search(), system = base::Sys.info())
[18:06:08.919]                   }
[18:06:08.919]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.919]                     cond$call), session = sessionInformation(), 
[18:06:08.919]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.919]                   signalCondition(cond)
[18:06:08.919]                 }
[18:06:08.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.919]                 "immediateCondition"))) {
[18:06:08.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.919]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.919]                   if (TRUE && !signal) {
[18:06:08.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.919]                     {
[18:06:08.919]                       inherits <- base::inherits
[18:06:08.919]                       invokeRestart <- base::invokeRestart
[18:06:08.919]                       is.null <- base::is.null
[18:06:08.919]                       muffled <- FALSE
[18:06:08.919]                       if (inherits(cond, "message")) {
[18:06:08.919]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.919]                         if (muffled) 
[18:06:08.919]                           invokeRestart("muffleMessage")
[18:06:08.919]                       }
[18:06:08.919]                       else if (inherits(cond, "warning")) {
[18:06:08.919]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.919]                         if (muffled) 
[18:06:08.919]                           invokeRestart("muffleWarning")
[18:06:08.919]                       }
[18:06:08.919]                       else if (inherits(cond, "condition")) {
[18:06:08.919]                         if (!is.null(pattern)) {
[18:06:08.919]                           computeRestarts <- base::computeRestarts
[18:06:08.919]                           grepl <- base::grepl
[18:06:08.919]                           restarts <- computeRestarts(cond)
[18:06:08.919]                           for (restart in restarts) {
[18:06:08.919]                             name <- restart$name
[18:06:08.919]                             if (is.null(name)) 
[18:06:08.919]                               next
[18:06:08.919]                             if (!grepl(pattern, name)) 
[18:06:08.919]                               next
[18:06:08.919]                             invokeRestart(restart)
[18:06:08.919]                             muffled <- TRUE
[18:06:08.919]                             break
[18:06:08.919]                           }
[18:06:08.919]                         }
[18:06:08.919]                       }
[18:06:08.919]                       invisible(muffled)
[18:06:08.919]                     }
[18:06:08.919]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.919]                   }
[18:06:08.919]                 }
[18:06:08.919]                 else {
[18:06:08.919]                   if (TRUE) {
[18:06:08.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.919]                     {
[18:06:08.919]                       inherits <- base::inherits
[18:06:08.919]                       invokeRestart <- base::invokeRestart
[18:06:08.919]                       is.null <- base::is.null
[18:06:08.919]                       muffled <- FALSE
[18:06:08.919]                       if (inherits(cond, "message")) {
[18:06:08.919]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.919]                         if (muffled) 
[18:06:08.919]                           invokeRestart("muffleMessage")
[18:06:08.919]                       }
[18:06:08.919]                       else if (inherits(cond, "warning")) {
[18:06:08.919]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.919]                         if (muffled) 
[18:06:08.919]                           invokeRestart("muffleWarning")
[18:06:08.919]                       }
[18:06:08.919]                       else if (inherits(cond, "condition")) {
[18:06:08.919]                         if (!is.null(pattern)) {
[18:06:08.919]                           computeRestarts <- base::computeRestarts
[18:06:08.919]                           grepl <- base::grepl
[18:06:08.919]                           restarts <- computeRestarts(cond)
[18:06:08.919]                           for (restart in restarts) {
[18:06:08.919]                             name <- restart$name
[18:06:08.919]                             if (is.null(name)) 
[18:06:08.919]                               next
[18:06:08.919]                             if (!grepl(pattern, name)) 
[18:06:08.919]                               next
[18:06:08.919]                             invokeRestart(restart)
[18:06:08.919]                             muffled <- TRUE
[18:06:08.919]                             break
[18:06:08.919]                           }
[18:06:08.919]                         }
[18:06:08.919]                       }
[18:06:08.919]                       invisible(muffled)
[18:06:08.919]                     }
[18:06:08.919]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.919]                   }
[18:06:08.919]                 }
[18:06:08.919]             }
[18:06:08.919]         }))
[18:06:08.919]     }, error = function(ex) {
[18:06:08.919]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.919]                 ...future.rng), started = ...future.startTime, 
[18:06:08.919]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.919]             version = "1.8"), class = "FutureResult")
[18:06:08.919]     }, finally = {
[18:06:08.919]         if (!identical(...future.workdir, getwd())) 
[18:06:08.919]             setwd(...future.workdir)
[18:06:08.919]         {
[18:06:08.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.919]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.919]             }
[18:06:08.919]             base::options(...future.oldOptions)
[18:06:08.919]             if (.Platform$OS.type == "windows") {
[18:06:08.919]                 old_names <- names(...future.oldEnvVars)
[18:06:08.919]                 envs <- base::Sys.getenv()
[18:06:08.919]                 names <- names(envs)
[18:06:08.919]                 common <- intersect(names, old_names)
[18:06:08.919]                 added <- setdiff(names, old_names)
[18:06:08.919]                 removed <- setdiff(old_names, names)
[18:06:08.919]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.919]                   envs[common]]
[18:06:08.919]                 NAMES <- toupper(changed)
[18:06:08.919]                 args <- list()
[18:06:08.919]                 for (kk in seq_along(NAMES)) {
[18:06:08.919]                   name <- changed[[kk]]
[18:06:08.919]                   NAME <- NAMES[[kk]]
[18:06:08.919]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.919]                     next
[18:06:08.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.919]                 }
[18:06:08.919]                 NAMES <- toupper(added)
[18:06:08.919]                 for (kk in seq_along(NAMES)) {
[18:06:08.919]                   name <- added[[kk]]
[18:06:08.919]                   NAME <- NAMES[[kk]]
[18:06:08.919]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.919]                     next
[18:06:08.919]                   args[[name]] <- ""
[18:06:08.919]                 }
[18:06:08.919]                 NAMES <- toupper(removed)
[18:06:08.919]                 for (kk in seq_along(NAMES)) {
[18:06:08.919]                   name <- removed[[kk]]
[18:06:08.919]                   NAME <- NAMES[[kk]]
[18:06:08.919]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.919]                     next
[18:06:08.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.919]                 }
[18:06:08.919]                 if (length(args) > 0) 
[18:06:08.919]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.919]             }
[18:06:08.919]             else {
[18:06:08.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.919]             }
[18:06:08.919]             {
[18:06:08.919]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.919]                   0L) {
[18:06:08.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.919]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.919]                   base::options(opts)
[18:06:08.919]                 }
[18:06:08.919]                 {
[18:06:08.919]                   {
[18:06:08.919]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.919]                     NULL
[18:06:08.919]                   }
[18:06:08.919]                   options(future.plan = NULL)
[18:06:08.919]                   if (is.na(NA_character_)) 
[18:06:08.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.919]                     .init = FALSE)
[18:06:08.919]                 }
[18:06:08.919]             }
[18:06:08.919]         }
[18:06:08.919]     })
[18:06:08.919]     if (TRUE) {
[18:06:08.919]         base::sink(type = "output", split = FALSE)
[18:06:08.919]         if (TRUE) {
[18:06:08.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.919]         }
[18:06:08.919]         else {
[18:06:08.919]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.919]         }
[18:06:08.919]         base::close(...future.stdout)
[18:06:08.919]         ...future.stdout <- NULL
[18:06:08.919]     }
[18:06:08.919]     ...future.result$conditions <- ...future.conditions
[18:06:08.919]     ...future.result$finished <- base::Sys.time()
[18:06:08.919]     ...future.result
[18:06:08.919] }
[18:06:08.925] requestCore(): workers = 2
[18:06:08.926] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:08.937] result() for MulticoreFuture ...
[18:06:08.938] result() for MulticoreFuture ...
[18:06:08.939] result() for MulticoreFuture ... done
[18:06:08.939] result() for MulticoreFuture ... done
[18:06:08.939] result() for MulticoreFuture ...
[18:06:08.940] result() for MulticoreFuture ... done
[18:06:08.950] MulticoreFuture started
[18:06:08.951] - Launch lazy future ... done
[18:06:08.951] run() for ‘MulticoreFuture’ ... done
[18:06:08.953] plan(): Setting new future strategy stack:
[18:06:08.953] List of future strategies:
[18:06:08.953] 1. sequential:
[18:06:08.953]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:08.953]    - tweaked: FALSE
[18:06:08.953]    - call: NULL
[18:06:08.956] resolve() on list environment ...
[18:06:08.956] plan(): nbrOfWorkers() = 1
[18:06:08.956]  recursive: 0
[18:06:08.958]  length: 3
[18:06:08.958]  elements: ‘a’, ‘b’, ‘c’
[18:06:08.960] Future #1
[18:06:08.960] plan(): Setting new future strategy stack:
[18:06:08.960]  length: 2 (resolved future 1)
[18:06:08.960] List of future strategies:
[18:06:08.960] 1. multicore:
[18:06:08.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:08.960]    - tweaked: FALSE
[18:06:08.960]    - call: plan(strategy)
[18:06:08.969] plan(): nbrOfWorkers() = 2
[18:06:08.970] Future #2
[18:06:08.971]  length: 1 (resolved future 2)
[18:06:08.971]  length: 0 (resolved future 3)
[18:06:08.971] resolve() on list environment ... DONE
[18:06:08.973] getGlobalsAndPackages() ...
[18:06:08.973] Searching for globals...
[18:06:08.976] - globals found: [1] ‘{’
[18:06:08.976] Searching for globals ... DONE
[18:06:08.977] Resolving globals: FALSE
[18:06:08.978] 
[18:06:08.978] 
[18:06:08.979] getGlobalsAndPackages() ... DONE
[18:06:08.979] run() for ‘Future’ ...
[18:06:08.980] - state: ‘created’
[18:06:08.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:08.988] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:08.988] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:08.989]   - Field: ‘label’
[18:06:08.989]   - Field: ‘local’
[18:06:08.990]   - Field: ‘owner’
[18:06:08.990]   - Field: ‘envir’
[18:06:08.990]   - Field: ‘workers’
[18:06:08.991]   - Field: ‘packages’
[18:06:08.991]   - Field: ‘gc’
[18:06:08.991]   - Field: ‘job’
[18:06:08.991]   - Field: ‘conditions’
[18:06:08.992]   - Field: ‘expr’
[18:06:08.992]   - Field: ‘uuid’
[18:06:08.992]   - Field: ‘seed’
[18:06:08.993]   - Field: ‘version’
[18:06:08.993]   - Field: ‘result’
[18:06:08.993]   - Field: ‘asynchronous’
[18:06:08.994]   - Field: ‘calls’
[18:06:08.994]   - Field: ‘globals’
[18:06:08.994]   - Field: ‘stdout’
[18:06:08.995]   - Field: ‘earlySignal’
[18:06:08.995]   - Field: ‘lazy’
[18:06:08.995]   - Field: ‘state’
[18:06:08.996] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:08.996] - Launch lazy future ...
[18:06:08.997] Packages needed by the future expression (n = 0): <none>
[18:06:08.997] Packages needed by future strategies (n = 0): <none>
[18:06:08.999] {
[18:06:08.999]     {
[18:06:08.999]         {
[18:06:08.999]             ...future.startTime <- base::Sys.time()
[18:06:08.999]             {
[18:06:08.999]                 {
[18:06:08.999]                   {
[18:06:08.999]                     {
[18:06:08.999]                       base::local({
[18:06:08.999]                         has_future <- base::requireNamespace("future", 
[18:06:08.999]                           quietly = TRUE)
[18:06:08.999]                         if (has_future) {
[18:06:08.999]                           ns <- base::getNamespace("future")
[18:06:08.999]                           version <- ns[[".package"]][["version"]]
[18:06:08.999]                           if (is.null(version)) 
[18:06:08.999]                             version <- utils::packageVersion("future")
[18:06:08.999]                         }
[18:06:08.999]                         else {
[18:06:08.999]                           version <- NULL
[18:06:08.999]                         }
[18:06:08.999]                         if (!has_future || version < "1.8.0") {
[18:06:08.999]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:08.999]                             "", base::R.version$version.string), 
[18:06:08.999]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:08.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:08.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:08.999]                               "release", "version")], collapse = " "), 
[18:06:08.999]                             hostname = base::Sys.info()[["nodename"]])
[18:06:08.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:08.999]                             info)
[18:06:08.999]                           info <- base::paste(info, collapse = "; ")
[18:06:08.999]                           if (!has_future) {
[18:06:08.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:08.999]                               info)
[18:06:08.999]                           }
[18:06:08.999]                           else {
[18:06:08.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:08.999]                               info, version)
[18:06:08.999]                           }
[18:06:08.999]                           base::stop(msg)
[18:06:08.999]                         }
[18:06:08.999]                       })
[18:06:08.999]                     }
[18:06:08.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:08.999]                     base::options(mc.cores = 1L)
[18:06:08.999]                   }
[18:06:08.999]                   ...future.strategy.old <- future::plan("list")
[18:06:08.999]                   options(future.plan = NULL)
[18:06:08.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:08.999]                 }
[18:06:08.999]                 ...future.workdir <- getwd()
[18:06:08.999]             }
[18:06:08.999]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:08.999]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:08.999]         }
[18:06:08.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:08.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:08.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:08.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:08.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:08.999]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:08.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:08.999]             base::names(...future.oldOptions))
[18:06:08.999]     }
[18:06:08.999]     if (FALSE) {
[18:06:08.999]     }
[18:06:08.999]     else {
[18:06:08.999]         if (TRUE) {
[18:06:08.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:08.999]                 open = "w")
[18:06:08.999]         }
[18:06:08.999]         else {
[18:06:08.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:08.999]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:08.999]         }
[18:06:08.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:08.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:08.999]             base::sink(type = "output", split = FALSE)
[18:06:08.999]             base::close(...future.stdout)
[18:06:08.999]         }, add = TRUE)
[18:06:08.999]     }
[18:06:08.999]     ...future.frame <- base::sys.nframe()
[18:06:08.999]     ...future.conditions <- base::list()
[18:06:08.999]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:08.999]     if (FALSE) {
[18:06:08.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:08.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:08.999]     }
[18:06:08.999]     ...future.result <- base::tryCatch({
[18:06:08.999]         base::withCallingHandlers({
[18:06:08.999]             ...future.value <- base::withVisible(base::local({
[18:06:08.999]                 withCallingHandlers({
[18:06:08.999]                   {
[18:06:08.999]                     1
[18:06:08.999]                   }
[18:06:08.999]                 }, immediateCondition = function(cond) {
[18:06:08.999]                   save_rds <- function (object, pathname, ...) 
[18:06:08.999]                   {
[18:06:08.999]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:08.999]                     if (file_test("-f", pathname_tmp)) {
[18:06:08.999]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.999]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:08.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.999]                         fi_tmp[["mtime"]])
[18:06:08.999]                     }
[18:06:08.999]                     tryCatch({
[18:06:08.999]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:08.999]                     }, error = function(ex) {
[18:06:08.999]                       msg <- conditionMessage(ex)
[18:06:08.999]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.999]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:08.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.999]                         fi_tmp[["mtime"]], msg)
[18:06:08.999]                       ex$message <- msg
[18:06:08.999]                       stop(ex)
[18:06:08.999]                     })
[18:06:08.999]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:08.999]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:08.999]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:08.999]                       fi_tmp <- file.info(pathname_tmp)
[18:06:08.999]                       fi <- file.info(pathname)
[18:06:08.999]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:08.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:08.999]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:08.999]                         fi[["size"]], fi[["mtime"]])
[18:06:08.999]                       stop(msg)
[18:06:08.999]                     }
[18:06:08.999]                     invisible(pathname)
[18:06:08.999]                   }
[18:06:08.999]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:08.999]                     rootPath = tempdir()) 
[18:06:08.999]                   {
[18:06:08.999]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:08.999]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:08.999]                       tmpdir = path, fileext = ".rds")
[18:06:08.999]                     save_rds(obj, file)
[18:06:08.999]                   }
[18:06:08.999]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:08.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.999]                   {
[18:06:08.999]                     inherits <- base::inherits
[18:06:08.999]                     invokeRestart <- base::invokeRestart
[18:06:08.999]                     is.null <- base::is.null
[18:06:08.999]                     muffled <- FALSE
[18:06:08.999]                     if (inherits(cond, "message")) {
[18:06:08.999]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:08.999]                       if (muffled) 
[18:06:08.999]                         invokeRestart("muffleMessage")
[18:06:08.999]                     }
[18:06:08.999]                     else if (inherits(cond, "warning")) {
[18:06:08.999]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:08.999]                       if (muffled) 
[18:06:08.999]                         invokeRestart("muffleWarning")
[18:06:08.999]                     }
[18:06:08.999]                     else if (inherits(cond, "condition")) {
[18:06:08.999]                       if (!is.null(pattern)) {
[18:06:08.999]                         computeRestarts <- base::computeRestarts
[18:06:08.999]                         grepl <- base::grepl
[18:06:08.999]                         restarts <- computeRestarts(cond)
[18:06:08.999]                         for (restart in restarts) {
[18:06:08.999]                           name <- restart$name
[18:06:08.999]                           if (is.null(name)) 
[18:06:08.999]                             next
[18:06:08.999]                           if (!grepl(pattern, name)) 
[18:06:08.999]                             next
[18:06:08.999]                           invokeRestart(restart)
[18:06:08.999]                           muffled <- TRUE
[18:06:08.999]                           break
[18:06:08.999]                         }
[18:06:08.999]                       }
[18:06:08.999]                     }
[18:06:08.999]                     invisible(muffled)
[18:06:08.999]                   }
[18:06:08.999]                   muffleCondition(cond)
[18:06:08.999]                 })
[18:06:08.999]             }))
[18:06:08.999]             future::FutureResult(value = ...future.value$value, 
[18:06:08.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.999]                   ...future.rng), globalenv = if (FALSE) 
[18:06:08.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:08.999]                     ...future.globalenv.names))
[18:06:08.999]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:08.999]         }, condition = base::local({
[18:06:08.999]             c <- base::c
[18:06:08.999]             inherits <- base::inherits
[18:06:08.999]             invokeRestart <- base::invokeRestart
[18:06:08.999]             length <- base::length
[18:06:08.999]             list <- base::list
[18:06:08.999]             seq.int <- base::seq.int
[18:06:08.999]             signalCondition <- base::signalCondition
[18:06:08.999]             sys.calls <- base::sys.calls
[18:06:08.999]             `[[` <- base::`[[`
[18:06:08.999]             `+` <- base::`+`
[18:06:08.999]             `<<-` <- base::`<<-`
[18:06:08.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:08.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:08.999]                   3L)]
[18:06:08.999]             }
[18:06:08.999]             function(cond) {
[18:06:08.999]                 is_error <- inherits(cond, "error")
[18:06:08.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:08.999]                   NULL)
[18:06:08.999]                 if (is_error) {
[18:06:08.999]                   sessionInformation <- function() {
[18:06:08.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:08.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:08.999]                       search = base::search(), system = base::Sys.info())
[18:06:08.999]                   }
[18:06:08.999]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:08.999]                     cond$call), session = sessionInformation(), 
[18:06:08.999]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:08.999]                   signalCondition(cond)
[18:06:08.999]                 }
[18:06:08.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:08.999]                 "immediateCondition"))) {
[18:06:08.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:08.999]                   ...future.conditions[[length(...future.conditions) + 
[18:06:08.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:08.999]                   if (TRUE && !signal) {
[18:06:08.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.999]                     {
[18:06:08.999]                       inherits <- base::inherits
[18:06:08.999]                       invokeRestart <- base::invokeRestart
[18:06:08.999]                       is.null <- base::is.null
[18:06:08.999]                       muffled <- FALSE
[18:06:08.999]                       if (inherits(cond, "message")) {
[18:06:08.999]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.999]                         if (muffled) 
[18:06:08.999]                           invokeRestart("muffleMessage")
[18:06:08.999]                       }
[18:06:08.999]                       else if (inherits(cond, "warning")) {
[18:06:08.999]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.999]                         if (muffled) 
[18:06:08.999]                           invokeRestart("muffleWarning")
[18:06:08.999]                       }
[18:06:08.999]                       else if (inherits(cond, "condition")) {
[18:06:08.999]                         if (!is.null(pattern)) {
[18:06:08.999]                           computeRestarts <- base::computeRestarts
[18:06:08.999]                           grepl <- base::grepl
[18:06:08.999]                           restarts <- computeRestarts(cond)
[18:06:08.999]                           for (restart in restarts) {
[18:06:08.999]                             name <- restart$name
[18:06:08.999]                             if (is.null(name)) 
[18:06:08.999]                               next
[18:06:08.999]                             if (!grepl(pattern, name)) 
[18:06:08.999]                               next
[18:06:08.999]                             invokeRestart(restart)
[18:06:08.999]                             muffled <- TRUE
[18:06:08.999]                             break
[18:06:08.999]                           }
[18:06:08.999]                         }
[18:06:08.999]                       }
[18:06:08.999]                       invisible(muffled)
[18:06:08.999]                     }
[18:06:08.999]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.999]                   }
[18:06:08.999]                 }
[18:06:08.999]                 else {
[18:06:08.999]                   if (TRUE) {
[18:06:08.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:08.999]                     {
[18:06:08.999]                       inherits <- base::inherits
[18:06:08.999]                       invokeRestart <- base::invokeRestart
[18:06:08.999]                       is.null <- base::is.null
[18:06:08.999]                       muffled <- FALSE
[18:06:08.999]                       if (inherits(cond, "message")) {
[18:06:08.999]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:08.999]                         if (muffled) 
[18:06:08.999]                           invokeRestart("muffleMessage")
[18:06:08.999]                       }
[18:06:08.999]                       else if (inherits(cond, "warning")) {
[18:06:08.999]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:08.999]                         if (muffled) 
[18:06:08.999]                           invokeRestart("muffleWarning")
[18:06:08.999]                       }
[18:06:08.999]                       else if (inherits(cond, "condition")) {
[18:06:08.999]                         if (!is.null(pattern)) {
[18:06:08.999]                           computeRestarts <- base::computeRestarts
[18:06:08.999]                           grepl <- base::grepl
[18:06:08.999]                           restarts <- computeRestarts(cond)
[18:06:08.999]                           for (restart in restarts) {
[18:06:08.999]                             name <- restart$name
[18:06:08.999]                             if (is.null(name)) 
[18:06:08.999]                               next
[18:06:08.999]                             if (!grepl(pattern, name)) 
[18:06:08.999]                               next
[18:06:08.999]                             invokeRestart(restart)
[18:06:08.999]                             muffled <- TRUE
[18:06:08.999]                             break
[18:06:08.999]                           }
[18:06:08.999]                         }
[18:06:08.999]                       }
[18:06:08.999]                       invisible(muffled)
[18:06:08.999]                     }
[18:06:08.999]                     muffleCondition(cond, pattern = "^muffle")
[18:06:08.999]                   }
[18:06:08.999]                 }
[18:06:08.999]             }
[18:06:08.999]         }))
[18:06:08.999]     }, error = function(ex) {
[18:06:08.999]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:08.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:08.999]                 ...future.rng), started = ...future.startTime, 
[18:06:08.999]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:08.999]             version = "1.8"), class = "FutureResult")
[18:06:08.999]     }, finally = {
[18:06:08.999]         if (!identical(...future.workdir, getwd())) 
[18:06:08.999]             setwd(...future.workdir)
[18:06:08.999]         {
[18:06:08.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:08.999]                 ...future.oldOptions$nwarnings <- NULL
[18:06:08.999]             }
[18:06:08.999]             base::options(...future.oldOptions)
[18:06:08.999]             if (.Platform$OS.type == "windows") {
[18:06:08.999]                 old_names <- names(...future.oldEnvVars)
[18:06:08.999]                 envs <- base::Sys.getenv()
[18:06:08.999]                 names <- names(envs)
[18:06:08.999]                 common <- intersect(names, old_names)
[18:06:08.999]                 added <- setdiff(names, old_names)
[18:06:08.999]                 removed <- setdiff(old_names, names)
[18:06:08.999]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:08.999]                   envs[common]]
[18:06:08.999]                 NAMES <- toupper(changed)
[18:06:08.999]                 args <- list()
[18:06:08.999]                 for (kk in seq_along(NAMES)) {
[18:06:08.999]                   name <- changed[[kk]]
[18:06:08.999]                   NAME <- NAMES[[kk]]
[18:06:08.999]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.999]                     next
[18:06:08.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.999]                 }
[18:06:08.999]                 NAMES <- toupper(added)
[18:06:08.999]                 for (kk in seq_along(NAMES)) {
[18:06:08.999]                   name <- added[[kk]]
[18:06:08.999]                   NAME <- NAMES[[kk]]
[18:06:08.999]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.999]                     next
[18:06:08.999]                   args[[name]] <- ""
[18:06:08.999]                 }
[18:06:08.999]                 NAMES <- toupper(removed)
[18:06:08.999]                 for (kk in seq_along(NAMES)) {
[18:06:08.999]                   name <- removed[[kk]]
[18:06:08.999]                   NAME <- NAMES[[kk]]
[18:06:08.999]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:08.999]                     next
[18:06:08.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:08.999]                 }
[18:06:08.999]                 if (length(args) > 0) 
[18:06:08.999]                   base::do.call(base::Sys.setenv, args = args)
[18:06:08.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:08.999]             }
[18:06:08.999]             else {
[18:06:08.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:08.999]             }
[18:06:08.999]             {
[18:06:08.999]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:08.999]                   0L) {
[18:06:08.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:08.999]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:08.999]                   base::options(opts)
[18:06:08.999]                 }
[18:06:08.999]                 {
[18:06:08.999]                   {
[18:06:08.999]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:08.999]                     NULL
[18:06:08.999]                   }
[18:06:08.999]                   options(future.plan = NULL)
[18:06:08.999]                   if (is.na(NA_character_)) 
[18:06:08.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:08.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:08.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:08.999]                     .init = FALSE)
[18:06:08.999]                 }
[18:06:08.999]             }
[18:06:08.999]         }
[18:06:08.999]     })
[18:06:08.999]     if (TRUE) {
[18:06:08.999]         base::sink(type = "output", split = FALSE)
[18:06:08.999]         if (TRUE) {
[18:06:08.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:08.999]         }
[18:06:08.999]         else {
[18:06:08.999]             ...future.result["stdout"] <- base::list(NULL)
[18:06:08.999]         }
[18:06:08.999]         base::close(...future.stdout)
[18:06:08.999]         ...future.stdout <- NULL
[18:06:08.999]     }
[18:06:08.999]     ...future.result$conditions <- ...future.conditions
[18:06:08.999]     ...future.result$finished <- base::Sys.time()
[18:06:08.999]     ...future.result
[18:06:08.999] }
[18:06:09.005] requestCore(): workers = 2
[18:06:09.006] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:09.017] result() for MulticoreFuture ...
[18:06:09.019] result() for MulticoreFuture ...
[18:06:09.019] result() for MulticoreFuture ... done
[18:06:09.019] result() for MulticoreFuture ... done
[18:06:09.020] result() for MulticoreFuture ...
[18:06:09.020] result() for MulticoreFuture ... done
[18:06:09.024] MulticoreFuture started
[18:06:09.025] - Launch lazy future ... done
[18:06:09.025] run() for ‘MulticoreFuture’ ... done
[18:06:09.026] plan(): Setting new future strategy stack:
[18:06:09.027] getGlobalsAndPackages() ...
[18:06:09.028] Searching for globals...
[18:06:09.027] List of future strategies:
[18:06:09.027] 1. sequential:
[18:06:09.027]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:09.027]    - tweaked: FALSE
[18:06:09.027]    - call: NULL
[18:06:09.029] plan(): nbrOfWorkers() = 1
[18:06:09.032] - globals found: [2] ‘{’, ‘Sys.sleep’
[18:06:09.032] Searching for globals ... DONE
[18:06:09.033] Resolving globals: FALSE
[18:06:09.033] plan(): Setting new future strategy stack:
[18:06:09.034] 
[18:06:09.033] List of future strategies:
[18:06:09.033] 1. multicore:
[18:06:09.033]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:09.033]    - tweaked: FALSE
[18:06:09.033]    - call: plan(strategy)
[18:06:09.034] 
[18:06:09.035] getGlobalsAndPackages() ... DONE
[18:06:09.036] run() for ‘Future’ ...
[18:06:09.036] - state: ‘created’
[18:06:09.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:09.042] plan(): nbrOfWorkers() = 2
[18:06:09.045] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:09.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:09.045]   - Field: ‘label’
[18:06:09.046]   - Field: ‘local’
[18:06:09.046]   - Field: ‘owner’
[18:06:09.046]   - Field: ‘envir’
[18:06:09.047]   - Field: ‘workers’
[18:06:09.047]   - Field: ‘packages’
[18:06:09.047]   - Field: ‘gc’
[18:06:09.048]   - Field: ‘job’
[18:06:09.048]   - Field: ‘conditions’
[18:06:09.048]   - Field: ‘expr’
[18:06:09.049]   - Field: ‘uuid’
[18:06:09.049]   - Field: ‘seed’
[18:06:09.049]   - Field: ‘version’
[18:06:09.049]   - Field: ‘result’
[18:06:09.050]   - Field: ‘asynchronous’
[18:06:09.050]   - Field: ‘calls’
[18:06:09.050]   - Field: ‘globals’
[18:06:09.051]   - Field: ‘stdout’
[18:06:09.051]   - Field: ‘earlySignal’
[18:06:09.057]   - Field: ‘lazy’
[18:06:09.058]   - Field: ‘state’
[18:06:09.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:09.059] - Launch lazy future ...
[18:06:09.061] Packages needed by the future expression (n = 0): <none>
[18:06:09.062] Packages needed by future strategies (n = 0): <none>
[18:06:09.064] {
[18:06:09.064]     {
[18:06:09.064]         {
[18:06:09.064]             ...future.startTime <- base::Sys.time()
[18:06:09.064]             {
[18:06:09.064]                 {
[18:06:09.064]                   {
[18:06:09.064]                     {
[18:06:09.064]                       base::local({
[18:06:09.064]                         has_future <- base::requireNamespace("future", 
[18:06:09.064]                           quietly = TRUE)
[18:06:09.064]                         if (has_future) {
[18:06:09.064]                           ns <- base::getNamespace("future")
[18:06:09.064]                           version <- ns[[".package"]][["version"]]
[18:06:09.064]                           if (is.null(version)) 
[18:06:09.064]                             version <- utils::packageVersion("future")
[18:06:09.064]                         }
[18:06:09.064]                         else {
[18:06:09.064]                           version <- NULL
[18:06:09.064]                         }
[18:06:09.064]                         if (!has_future || version < "1.8.0") {
[18:06:09.064]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:09.064]                             "", base::R.version$version.string), 
[18:06:09.064]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:09.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:09.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:09.064]                               "release", "version")], collapse = " "), 
[18:06:09.064]                             hostname = base::Sys.info()[["nodename"]])
[18:06:09.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:09.064]                             info)
[18:06:09.064]                           info <- base::paste(info, collapse = "; ")
[18:06:09.064]                           if (!has_future) {
[18:06:09.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:09.064]                               info)
[18:06:09.064]                           }
[18:06:09.064]                           else {
[18:06:09.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:09.064]                               info, version)
[18:06:09.064]                           }
[18:06:09.064]                           base::stop(msg)
[18:06:09.064]                         }
[18:06:09.064]                       })
[18:06:09.064]                     }
[18:06:09.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:09.064]                     base::options(mc.cores = 1L)
[18:06:09.064]                   }
[18:06:09.064]                   ...future.strategy.old <- future::plan("list")
[18:06:09.064]                   options(future.plan = NULL)
[18:06:09.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:09.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:09.064]                 }
[18:06:09.064]                 ...future.workdir <- getwd()
[18:06:09.064]             }
[18:06:09.064]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:09.064]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:09.064]         }
[18:06:09.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:09.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:09.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:09.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:09.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:09.064]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:09.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:09.064]             base::names(...future.oldOptions))
[18:06:09.064]     }
[18:06:09.064]     if (FALSE) {
[18:06:09.064]     }
[18:06:09.064]     else {
[18:06:09.064]         if (TRUE) {
[18:06:09.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:09.064]                 open = "w")
[18:06:09.064]         }
[18:06:09.064]         else {
[18:06:09.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:09.064]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:09.064]         }
[18:06:09.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:09.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:09.064]             base::sink(type = "output", split = FALSE)
[18:06:09.064]             base::close(...future.stdout)
[18:06:09.064]         }, add = TRUE)
[18:06:09.064]     }
[18:06:09.064]     ...future.frame <- base::sys.nframe()
[18:06:09.064]     ...future.conditions <- base::list()
[18:06:09.064]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:09.064]     if (FALSE) {
[18:06:09.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:09.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:09.064]     }
[18:06:09.064]     ...future.result <- base::tryCatch({
[18:06:09.064]         base::withCallingHandlers({
[18:06:09.064]             ...future.value <- base::withVisible(base::local({
[18:06:09.064]                 withCallingHandlers({
[18:06:09.064]                   {
[18:06:09.064]                     Sys.sleep(0.5)
[18:06:09.064]                     2
[18:06:09.064]                   }
[18:06:09.064]                 }, immediateCondition = function(cond) {
[18:06:09.064]                   save_rds <- function (object, pathname, ...) 
[18:06:09.064]                   {
[18:06:09.064]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:09.064]                     if (file_test("-f", pathname_tmp)) {
[18:06:09.064]                       fi_tmp <- file.info(pathname_tmp)
[18:06:09.064]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:09.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:09.064]                         fi_tmp[["mtime"]])
[18:06:09.064]                     }
[18:06:09.064]                     tryCatch({
[18:06:09.064]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:09.064]                     }, error = function(ex) {
[18:06:09.064]                       msg <- conditionMessage(ex)
[18:06:09.064]                       fi_tmp <- file.info(pathname_tmp)
[18:06:09.064]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:09.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:09.064]                         fi_tmp[["mtime"]], msg)
[18:06:09.064]                       ex$message <- msg
[18:06:09.064]                       stop(ex)
[18:06:09.064]                     })
[18:06:09.064]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:09.064]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:09.064]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:09.064]                       fi_tmp <- file.info(pathname_tmp)
[18:06:09.064]                       fi <- file.info(pathname)
[18:06:09.064]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:09.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:09.064]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:09.064]                         fi[["size"]], fi[["mtime"]])
[18:06:09.064]                       stop(msg)
[18:06:09.064]                     }
[18:06:09.064]                     invisible(pathname)
[18:06:09.064]                   }
[18:06:09.064]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:09.064]                     rootPath = tempdir()) 
[18:06:09.064]                   {
[18:06:09.064]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:09.064]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:09.064]                       tmpdir = path, fileext = ".rds")
[18:06:09.064]                     save_rds(obj, file)
[18:06:09.064]                   }
[18:06:09.064]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:09.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:09.064]                   {
[18:06:09.064]                     inherits <- base::inherits
[18:06:09.064]                     invokeRestart <- base::invokeRestart
[18:06:09.064]                     is.null <- base::is.null
[18:06:09.064]                     muffled <- FALSE
[18:06:09.064]                     if (inherits(cond, "message")) {
[18:06:09.064]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:09.064]                       if (muffled) 
[18:06:09.064]                         invokeRestart("muffleMessage")
[18:06:09.064]                     }
[18:06:09.064]                     else if (inherits(cond, "warning")) {
[18:06:09.064]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:09.064]                       if (muffled) 
[18:06:09.064]                         invokeRestart("muffleWarning")
[18:06:09.064]                     }
[18:06:09.064]                     else if (inherits(cond, "condition")) {
[18:06:09.064]                       if (!is.null(pattern)) {
[18:06:09.064]                         computeRestarts <- base::computeRestarts
[18:06:09.064]                         grepl <- base::grepl
[18:06:09.064]                         restarts <- computeRestarts(cond)
[18:06:09.064]                         for (restart in restarts) {
[18:06:09.064]                           name <- restart$name
[18:06:09.064]                           if (is.null(name)) 
[18:06:09.064]                             next
[18:06:09.064]                           if (!grepl(pattern, name)) 
[18:06:09.064]                             next
[18:06:09.064]                           invokeRestart(restart)
[18:06:09.064]                           muffled <- TRUE
[18:06:09.064]                           break
[18:06:09.064]                         }
[18:06:09.064]                       }
[18:06:09.064]                     }
[18:06:09.064]                     invisible(muffled)
[18:06:09.064]                   }
[18:06:09.064]                   muffleCondition(cond)
[18:06:09.064]                 })
[18:06:09.064]             }))
[18:06:09.064]             future::FutureResult(value = ...future.value$value, 
[18:06:09.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:09.064]                   ...future.rng), globalenv = if (FALSE) 
[18:06:09.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:09.064]                     ...future.globalenv.names))
[18:06:09.064]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:09.064]         }, condition = base::local({
[18:06:09.064]             c <- base::c
[18:06:09.064]             inherits <- base::inherits
[18:06:09.064]             invokeRestart <- base::invokeRestart
[18:06:09.064]             length <- base::length
[18:06:09.064]             list <- base::list
[18:06:09.064]             seq.int <- base::seq.int
[18:06:09.064]             signalCondition <- base::signalCondition
[18:06:09.064]             sys.calls <- base::sys.calls
[18:06:09.064]             `[[` <- base::`[[`
[18:06:09.064]             `+` <- base::`+`
[18:06:09.064]             `<<-` <- base::`<<-`
[18:06:09.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:09.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:09.064]                   3L)]
[18:06:09.064]             }
[18:06:09.064]             function(cond) {
[18:06:09.064]                 is_error <- inherits(cond, "error")
[18:06:09.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:09.064]                   NULL)
[18:06:09.064]                 if (is_error) {
[18:06:09.064]                   sessionInformation <- function() {
[18:06:09.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:09.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:09.064]                       search = base::search(), system = base::Sys.info())
[18:06:09.064]                   }
[18:06:09.064]                   ...future.conditions[[length(...future.conditions) + 
[18:06:09.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:09.064]                     cond$call), session = sessionInformation(), 
[18:06:09.064]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:09.064]                   signalCondition(cond)
[18:06:09.064]                 }
[18:06:09.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:09.064]                 "immediateCondition"))) {
[18:06:09.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:09.064]                   ...future.conditions[[length(...future.conditions) + 
[18:06:09.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:09.064]                   if (TRUE && !signal) {
[18:06:09.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:09.064]                     {
[18:06:09.064]                       inherits <- base::inherits
[18:06:09.064]                       invokeRestart <- base::invokeRestart
[18:06:09.064]                       is.null <- base::is.null
[18:06:09.064]                       muffled <- FALSE
[18:06:09.064]                       if (inherits(cond, "message")) {
[18:06:09.064]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:09.064]                         if (muffled) 
[18:06:09.064]                           invokeRestart("muffleMessage")
[18:06:09.064]                       }
[18:06:09.064]                       else if (inherits(cond, "warning")) {
[18:06:09.064]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:09.064]                         if (muffled) 
[18:06:09.064]                           invokeRestart("muffleWarning")
[18:06:09.064]                       }
[18:06:09.064]                       else if (inherits(cond, "condition")) {
[18:06:09.064]                         if (!is.null(pattern)) {
[18:06:09.064]                           computeRestarts <- base::computeRestarts
[18:06:09.064]                           grepl <- base::grepl
[18:06:09.064]                           restarts <- computeRestarts(cond)
[18:06:09.064]                           for (restart in restarts) {
[18:06:09.064]                             name <- restart$name
[18:06:09.064]                             if (is.null(name)) 
[18:06:09.064]                               next
[18:06:09.064]                             if (!grepl(pattern, name)) 
[18:06:09.064]                               next
[18:06:09.064]                             invokeRestart(restart)
[18:06:09.064]                             muffled <- TRUE
[18:06:09.064]                             break
[18:06:09.064]                           }
[18:06:09.064]                         }
[18:06:09.064]                       }
[18:06:09.064]                       invisible(muffled)
[18:06:09.064]                     }
[18:06:09.064]                     muffleCondition(cond, pattern = "^muffle")
[18:06:09.064]                   }
[18:06:09.064]                 }
[18:06:09.064]                 else {
[18:06:09.064]                   if (TRUE) {
[18:06:09.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:09.064]                     {
[18:06:09.064]                       inherits <- base::inherits
[18:06:09.064]                       invokeRestart <- base::invokeRestart
[18:06:09.064]                       is.null <- base::is.null
[18:06:09.064]                       muffled <- FALSE
[18:06:09.064]                       if (inherits(cond, "message")) {
[18:06:09.064]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:09.064]                         if (muffled) 
[18:06:09.064]                           invokeRestart("muffleMessage")
[18:06:09.064]                       }
[18:06:09.064]                       else if (inherits(cond, "warning")) {
[18:06:09.064]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:09.064]                         if (muffled) 
[18:06:09.064]                           invokeRestart("muffleWarning")
[18:06:09.064]                       }
[18:06:09.064]                       else if (inherits(cond, "condition")) {
[18:06:09.064]                         if (!is.null(pattern)) {
[18:06:09.064]                           computeRestarts <- base::computeRestarts
[18:06:09.064]                           grepl <- base::grepl
[18:06:09.064]                           restarts <- computeRestarts(cond)
[18:06:09.064]                           for (restart in restarts) {
[18:06:09.064]                             name <- restart$name
[18:06:09.064]                             if (is.null(name)) 
[18:06:09.064]                               next
[18:06:09.064]                             if (!grepl(pattern, name)) 
[18:06:09.064]                               next
[18:06:09.064]                             invokeRestart(restart)
[18:06:09.064]                             muffled <- TRUE
[18:06:09.064]                             break
[18:06:09.064]                           }
[18:06:09.064]                         }
[18:06:09.064]                       }
[18:06:09.064]                       invisible(muffled)
[18:06:09.064]                     }
[18:06:09.064]                     muffleCondition(cond, pattern = "^muffle")
[18:06:09.064]                   }
[18:06:09.064]                 }
[18:06:09.064]             }
[18:06:09.064]         }))
[18:06:09.064]     }, error = function(ex) {
[18:06:09.064]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:09.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:09.064]                 ...future.rng), started = ...future.startTime, 
[18:06:09.064]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:09.064]             version = "1.8"), class = "FutureResult")
[18:06:09.064]     }, finally = {
[18:06:09.064]         if (!identical(...future.workdir, getwd())) 
[18:06:09.064]             setwd(...future.workdir)
[18:06:09.064]         {
[18:06:09.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:09.064]                 ...future.oldOptions$nwarnings <- NULL
[18:06:09.064]             }
[18:06:09.064]             base::options(...future.oldOptions)
[18:06:09.064]             if (.Platform$OS.type == "windows") {
[18:06:09.064]                 old_names <- names(...future.oldEnvVars)
[18:06:09.064]                 envs <- base::Sys.getenv()
[18:06:09.064]                 names <- names(envs)
[18:06:09.064]                 common <- intersect(names, old_names)
[18:06:09.064]                 added <- setdiff(names, old_names)
[18:06:09.064]                 removed <- setdiff(old_names, names)
[18:06:09.064]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:09.064]                   envs[common]]
[18:06:09.064]                 NAMES <- toupper(changed)
[18:06:09.064]                 args <- list()
[18:06:09.064]                 for (kk in seq_along(NAMES)) {
[18:06:09.064]                   name <- changed[[kk]]
[18:06:09.064]                   NAME <- NAMES[[kk]]
[18:06:09.064]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:09.064]                     next
[18:06:09.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:09.064]                 }
[18:06:09.064]                 NAMES <- toupper(added)
[18:06:09.064]                 for (kk in seq_along(NAMES)) {
[18:06:09.064]                   name <- added[[kk]]
[18:06:09.064]                   NAME <- NAMES[[kk]]
[18:06:09.064]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:09.064]                     next
[18:06:09.064]                   args[[name]] <- ""
[18:06:09.064]                 }
[18:06:09.064]                 NAMES <- toupper(removed)
[18:06:09.064]                 for (kk in seq_along(NAMES)) {
[18:06:09.064]                   name <- removed[[kk]]
[18:06:09.064]                   NAME <- NAMES[[kk]]
[18:06:09.064]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:09.064]                     next
[18:06:09.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:09.064]                 }
[18:06:09.064]                 if (length(args) > 0) 
[18:06:09.064]                   base::do.call(base::Sys.setenv, args = args)
[18:06:09.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:09.064]             }
[18:06:09.064]             else {
[18:06:09.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:09.064]             }
[18:06:09.064]             {
[18:06:09.064]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:09.064]                   0L) {
[18:06:09.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:09.064]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:09.064]                   base::options(opts)
[18:06:09.064]                 }
[18:06:09.064]                 {
[18:06:09.064]                   {
[18:06:09.064]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:09.064]                     NULL
[18:06:09.064]                   }
[18:06:09.064]                   options(future.plan = NULL)
[18:06:09.064]                   if (is.na(NA_character_)) 
[18:06:09.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:09.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:09.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:09.064]                     .init = FALSE)
[18:06:09.064]                 }
[18:06:09.064]             }
[18:06:09.064]         }
[18:06:09.064]     })
[18:06:09.064]     if (TRUE) {
[18:06:09.064]         base::sink(type = "output", split = FALSE)
[18:06:09.064]         if (TRUE) {
[18:06:09.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:09.064]         }
[18:06:09.064]         else {
[18:06:09.064]             ...future.result["stdout"] <- base::list(NULL)
[18:06:09.064]         }
[18:06:09.064]         base::close(...future.stdout)
[18:06:09.064]         ...future.stdout <- NULL
[18:06:09.064]     }
[18:06:09.064]     ...future.result$conditions <- ...future.conditions
[18:06:09.064]     ...future.result$finished <- base::Sys.time()
[18:06:09.064]     ...future.result
[18:06:09.064] }
[18:06:09.070] requestCore(): workers = 2
[18:06:09.071] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:09.082] result() for MulticoreFuture ...
[18:06:09.084] result() for MulticoreFuture ...
[18:06:09.084] result() for MulticoreFuture ... done
[18:06:09.085] result() for MulticoreFuture ... done
[18:06:09.085] result() for MulticoreFuture ...
[18:06:09.086] result() for MulticoreFuture ... done
[18:06:09.090] MulticoreFuture started
[18:06:09.091] - Launch lazy future ... done
[18:06:09.092] run() for ‘MulticoreFuture’ ... done
[18:06:09.092] plan(): Setting new future strategy stack:
[18:06:09.094] getGlobalsAndPackages() ...
[18:06:09.093] List of future strategies:
[18:06:09.093] 1. sequential:
[18:06:09.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:09.093]    - tweaked: FALSE
[18:06:09.093]    - call: NULL
[18:06:09.095] Searching for globals...
[18:06:09.095] plan(): nbrOfWorkers() = 1
[18:06:09.098] - globals found: [1] ‘{’
[18:06:09.098] Searching for globals ... DONE
[18:06:09.099] Resolving globals: FALSE
[18:06:09.100] 
[18:06:09.100] 
[18:06:09.101] getGlobalsAndPackages() ... DONE
[18:06:09.102] run() for ‘Future’ ...
[18:06:09.102] - state: ‘created’
[18:06:09.103] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:06:09.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:09.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:06:09.113]   - Field: ‘label’
[18:06:09.113]   - Field: ‘local’
[18:06:09.113]   - Field: ‘owner’
[18:06:09.114]   - Field: ‘envir’
[18:06:09.114]   - Field: ‘workers’
[18:06:09.114]   - Field: ‘packages’
[18:06:09.115]   - Field: ‘gc’
[18:06:09.115]   - Field: ‘job’
[18:06:09.115]   - Field: ‘conditions’
[18:06:09.116]   - Field: ‘expr’
[18:06:09.116]   - Field: ‘uuid’
[18:06:09.116]   - Field: ‘seed’
[18:06:09.117]   - Field: ‘version’
[18:06:09.117]   - Field: ‘result’
[18:06:09.117]   - Field: ‘asynchronous’
[18:06:09.117]   - Field: ‘calls’
[18:06:09.118]   - Field: ‘globals’
[18:06:09.118]   - Field: ‘stdout’
[18:06:09.118]   - Field: ‘earlySignal’
[18:06:09.119]   - Field: ‘lazy’
[18:06:09.119]   - Field: ‘state’
[18:06:09.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:06:09.120] - Launch lazy future ...
[18:06:09.121] Packages needed by the future expression (n = 0): <none>
[18:06:09.121] Packages needed by future strategies (n = 0): <none>
[18:06:09.123] {
[18:06:09.123]     {
[18:06:09.123]         {
[18:06:09.123]             ...future.startTime <- base::Sys.time()
[18:06:09.123]             {
[18:06:09.123]                 {
[18:06:09.123]                   {
[18:06:09.123]                     {
[18:06:09.123]                       base::local({
[18:06:09.123]                         has_future <- base::requireNamespace("future", 
[18:06:09.123]                           quietly = TRUE)
[18:06:09.123]                         if (has_future) {
[18:06:09.123]                           ns <- base::getNamespace("future")
[18:06:09.123]                           version <- ns[[".package"]][["version"]]
[18:06:09.123]                           if (is.null(version)) 
[18:06:09.123]                             version <- utils::packageVersion("future")
[18:06:09.123]                         }
[18:06:09.123]                         else {
[18:06:09.123]                           version <- NULL
[18:06:09.123]                         }
[18:06:09.123]                         if (!has_future || version < "1.8.0") {
[18:06:09.123]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:09.123]                             "", base::R.version$version.string), 
[18:06:09.123]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:09.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:09.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:09.123]                               "release", "version")], collapse = " "), 
[18:06:09.123]                             hostname = base::Sys.info()[["nodename"]])
[18:06:09.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:09.123]                             info)
[18:06:09.123]                           info <- base::paste(info, collapse = "; ")
[18:06:09.123]                           if (!has_future) {
[18:06:09.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:09.123]                               info)
[18:06:09.123]                           }
[18:06:09.123]                           else {
[18:06:09.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:09.123]                               info, version)
[18:06:09.123]                           }
[18:06:09.123]                           base::stop(msg)
[18:06:09.123]                         }
[18:06:09.123]                       })
[18:06:09.123]                     }
[18:06:09.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:09.123]                     base::options(mc.cores = 1L)
[18:06:09.123]                   }
[18:06:09.123]                   ...future.strategy.old <- future::plan("list")
[18:06:09.123]                   options(future.plan = NULL)
[18:06:09.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:09.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:09.123]                 }
[18:06:09.123]                 ...future.workdir <- getwd()
[18:06:09.123]             }
[18:06:09.123]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:09.123]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:09.123]         }
[18:06:09.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:09.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:09.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:09.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:09.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:09.123]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:09.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:09.123]             base::names(...future.oldOptions))
[18:06:09.123]     }
[18:06:09.123]     if (FALSE) {
[18:06:09.123]     }
[18:06:09.123]     else {
[18:06:09.123]         if (TRUE) {
[18:06:09.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:09.123]                 open = "w")
[18:06:09.123]         }
[18:06:09.123]         else {
[18:06:09.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:09.123]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:09.123]         }
[18:06:09.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:09.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:09.123]             base::sink(type = "output", split = FALSE)
[18:06:09.123]             base::close(...future.stdout)
[18:06:09.123]         }, add = TRUE)
[18:06:09.123]     }
[18:06:09.123]     ...future.frame <- base::sys.nframe()
[18:06:09.123]     ...future.conditions <- base::list()
[18:06:09.123]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:09.123]     if (FALSE) {
[18:06:09.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:09.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:09.123]     }
[18:06:09.123]     ...future.result <- base::tryCatch({
[18:06:09.123]         base::withCallingHandlers({
[18:06:09.123]             ...future.value <- base::withVisible(base::local({
[18:06:09.123]                 withCallingHandlers({
[18:06:09.123]                   {
[18:06:09.123]                     3
[18:06:09.123]                   }
[18:06:09.123]                 }, immediateCondition = function(cond) {
[18:06:09.123]                   save_rds <- function (object, pathname, ...) 
[18:06:09.123]                   {
[18:06:09.123]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:06:09.123]                     if (file_test("-f", pathname_tmp)) {
[18:06:09.123]                       fi_tmp <- file.info(pathname_tmp)
[18:06:09.123]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:06:09.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:09.123]                         fi_tmp[["mtime"]])
[18:06:09.123]                     }
[18:06:09.123]                     tryCatch({
[18:06:09.123]                       saveRDS(object, file = pathname_tmp, ...)
[18:06:09.123]                     }, error = function(ex) {
[18:06:09.123]                       msg <- conditionMessage(ex)
[18:06:09.123]                       fi_tmp <- file.info(pathname_tmp)
[18:06:09.123]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:06:09.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:09.123]                         fi_tmp[["mtime"]], msg)
[18:06:09.123]                       ex$message <- msg
[18:06:09.123]                       stop(ex)
[18:06:09.123]                     })
[18:06:09.123]                     stopifnot(file_test("-f", pathname_tmp))
[18:06:09.123]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:06:09.123]                     if (!res || file_test("-f", pathname_tmp)) {
[18:06:09.123]                       fi_tmp <- file.info(pathname_tmp)
[18:06:09.123]                       fi <- file.info(pathname)
[18:06:09.123]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:06:09.123]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:06:09.123]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:06:09.123]                         fi[["size"]], fi[["mtime"]])
[18:06:09.123]                       stop(msg)
[18:06:09.123]                     }
[18:06:09.123]                     invisible(pathname)
[18:06:09.123]                   }
[18:06:09.123]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:06:09.123]                     rootPath = tempdir()) 
[18:06:09.123]                   {
[18:06:09.123]                     obj <- list(time = Sys.time(), condition = cond)
[18:06:09.123]                     file <- tempfile(pattern = class(cond)[1], 
[18:06:09.123]                       tmpdir = path, fileext = ".rds")
[18:06:09.123]                     save_rds(obj, file)
[18:06:09.123]                   }
[18:06:09.123]                   saveImmediateCondition(cond, path = "/tmp/RtmpxIgMSR/.future/immediateConditions")
[18:06:09.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:09.123]                   {
[18:06:09.123]                     inherits <- base::inherits
[18:06:09.123]                     invokeRestart <- base::invokeRestart
[18:06:09.123]                     is.null <- base::is.null
[18:06:09.123]                     muffled <- FALSE
[18:06:09.123]                     if (inherits(cond, "message")) {
[18:06:09.123]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:09.123]                       if (muffled) 
[18:06:09.123]                         invokeRestart("muffleMessage")
[18:06:09.123]                     }
[18:06:09.123]                     else if (inherits(cond, "warning")) {
[18:06:09.123]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:09.123]                       if (muffled) 
[18:06:09.123]                         invokeRestart("muffleWarning")
[18:06:09.123]                     }
[18:06:09.123]                     else if (inherits(cond, "condition")) {
[18:06:09.123]                       if (!is.null(pattern)) {
[18:06:09.123]                         computeRestarts <- base::computeRestarts
[18:06:09.123]                         grepl <- base::grepl
[18:06:09.123]                         restarts <- computeRestarts(cond)
[18:06:09.123]                         for (restart in restarts) {
[18:06:09.123]                           name <- restart$name
[18:06:09.123]                           if (is.null(name)) 
[18:06:09.123]                             next
[18:06:09.123]                           if (!grepl(pattern, name)) 
[18:06:09.123]                             next
[18:06:09.123]                           invokeRestart(restart)
[18:06:09.123]                           muffled <- TRUE
[18:06:09.123]                           break
[18:06:09.123]                         }
[18:06:09.123]                       }
[18:06:09.123]                     }
[18:06:09.123]                     invisible(muffled)
[18:06:09.123]                   }
[18:06:09.123]                   muffleCondition(cond)
[18:06:09.123]                 })
[18:06:09.123]             }))
[18:06:09.123]             future::FutureResult(value = ...future.value$value, 
[18:06:09.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:09.123]                   ...future.rng), globalenv = if (FALSE) 
[18:06:09.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:09.123]                     ...future.globalenv.names))
[18:06:09.123]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:09.123]         }, condition = base::local({
[18:06:09.123]             c <- base::c
[18:06:09.123]             inherits <- base::inherits
[18:06:09.123]             invokeRestart <- base::invokeRestart
[18:06:09.123]             length <- base::length
[18:06:09.123]             list <- base::list
[18:06:09.123]             seq.int <- base::seq.int
[18:06:09.123]             signalCondition <- base::signalCondition
[18:06:09.123]             sys.calls <- base::sys.calls
[18:06:09.123]             `[[` <- base::`[[`
[18:06:09.123]             `+` <- base::`+`
[18:06:09.123]             `<<-` <- base::`<<-`
[18:06:09.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:09.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:09.123]                   3L)]
[18:06:09.123]             }
[18:06:09.123]             function(cond) {
[18:06:09.123]                 is_error <- inherits(cond, "error")
[18:06:09.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:09.123]                   NULL)
[18:06:09.123]                 if (is_error) {
[18:06:09.123]                   sessionInformation <- function() {
[18:06:09.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:09.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:09.123]                       search = base::search(), system = base::Sys.info())
[18:06:09.123]                   }
[18:06:09.123]                   ...future.conditions[[length(...future.conditions) + 
[18:06:09.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:09.123]                     cond$call), session = sessionInformation(), 
[18:06:09.123]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:09.123]                   signalCondition(cond)
[18:06:09.123]                 }
[18:06:09.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:09.123]                 "immediateCondition"))) {
[18:06:09.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:09.123]                   ...future.conditions[[length(...future.conditions) + 
[18:06:09.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:09.123]                   if (TRUE && !signal) {
[18:06:09.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:09.123]                     {
[18:06:09.123]                       inherits <- base::inherits
[18:06:09.123]                       invokeRestart <- base::invokeRestart
[18:06:09.123]                       is.null <- base::is.null
[18:06:09.123]                       muffled <- FALSE
[18:06:09.123]                       if (inherits(cond, "message")) {
[18:06:09.123]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:09.123]                         if (muffled) 
[18:06:09.123]                           invokeRestart("muffleMessage")
[18:06:09.123]                       }
[18:06:09.123]                       else if (inherits(cond, "warning")) {
[18:06:09.123]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:09.123]                         if (muffled) 
[18:06:09.123]                           invokeRestart("muffleWarning")
[18:06:09.123]                       }
[18:06:09.123]                       else if (inherits(cond, "condition")) {
[18:06:09.123]                         if (!is.null(pattern)) {
[18:06:09.123]                           computeRestarts <- base::computeRestarts
[18:06:09.123]                           grepl <- base::grepl
[18:06:09.123]                           restarts <- computeRestarts(cond)
[18:06:09.123]                           for (restart in restarts) {
[18:06:09.123]                             name <- restart$name
[18:06:09.123]                             if (is.null(name)) 
[18:06:09.123]                               next
[18:06:09.123]                             if (!grepl(pattern, name)) 
[18:06:09.123]                               next
[18:06:09.123]                             invokeRestart(restart)
[18:06:09.123]                             muffled <- TRUE
[18:06:09.123]                             break
[18:06:09.123]                           }
[18:06:09.123]                         }
[18:06:09.123]                       }
[18:06:09.123]                       invisible(muffled)
[18:06:09.123]                     }
[18:06:09.123]                     muffleCondition(cond, pattern = "^muffle")
[18:06:09.123]                   }
[18:06:09.123]                 }
[18:06:09.123]                 else {
[18:06:09.123]                   if (TRUE) {
[18:06:09.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:09.123]                     {
[18:06:09.123]                       inherits <- base::inherits
[18:06:09.123]                       invokeRestart <- base::invokeRestart
[18:06:09.123]                       is.null <- base::is.null
[18:06:09.123]                       muffled <- FALSE
[18:06:09.123]                       if (inherits(cond, "message")) {
[18:06:09.123]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:09.123]                         if (muffled) 
[18:06:09.123]                           invokeRestart("muffleMessage")
[18:06:09.123]                       }
[18:06:09.123]                       else if (inherits(cond, "warning")) {
[18:06:09.123]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:09.123]                         if (muffled) 
[18:06:09.123]                           invokeRestart("muffleWarning")
[18:06:09.123]                       }
[18:06:09.123]                       else if (inherits(cond, "condition")) {
[18:06:09.123]                         if (!is.null(pattern)) {
[18:06:09.123]                           computeRestarts <- base::computeRestarts
[18:06:09.123]                           grepl <- base::grepl
[18:06:09.123]                           restarts <- computeRestarts(cond)
[18:06:09.123]                           for (restart in restarts) {
[18:06:09.123]                             name <- restart$name
[18:06:09.123]                             if (is.null(name)) 
[18:06:09.123]                               next
[18:06:09.123]                             if (!grepl(pattern, name)) 
[18:06:09.123]                               next
[18:06:09.123]                             invokeRestart(restart)
[18:06:09.123]                             muffled <- TRUE
[18:06:09.123]                             break
[18:06:09.123]                           }
[18:06:09.123]                         }
[18:06:09.123]                       }
[18:06:09.123]                       invisible(muffled)
[18:06:09.123]                     }
[18:06:09.123]                     muffleCondition(cond, pattern = "^muffle")
[18:06:09.123]                   }
[18:06:09.123]                 }
[18:06:09.123]             }
[18:06:09.123]         }))
[18:06:09.123]     }, error = function(ex) {
[18:06:09.123]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:09.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:09.123]                 ...future.rng), started = ...future.startTime, 
[18:06:09.123]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:09.123]             version = "1.8"), class = "FutureResult")
[18:06:09.123]     }, finally = {
[18:06:09.123]         if (!identical(...future.workdir, getwd())) 
[18:06:09.123]             setwd(...future.workdir)
[18:06:09.123]         {
[18:06:09.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:09.123]                 ...future.oldOptions$nwarnings <- NULL
[18:06:09.123]             }
[18:06:09.123]             base::options(...future.oldOptions)
[18:06:09.123]             if (.Platform$OS.type == "windows") {
[18:06:09.123]                 old_names <- names(...future.oldEnvVars)
[18:06:09.123]                 envs <- base::Sys.getenv()
[18:06:09.123]                 names <- names(envs)
[18:06:09.123]                 common <- intersect(names, old_names)
[18:06:09.123]                 added <- setdiff(names, old_names)
[18:06:09.123]                 removed <- setdiff(old_names, names)
[18:06:09.123]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:09.123]                   envs[common]]
[18:06:09.123]                 NAMES <- toupper(changed)
[18:06:09.123]                 args <- list()
[18:06:09.123]                 for (kk in seq_along(NAMES)) {
[18:06:09.123]                   name <- changed[[kk]]
[18:06:09.123]                   NAME <- NAMES[[kk]]
[18:06:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:09.123]                     next
[18:06:09.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:09.123]                 }
[18:06:09.123]                 NAMES <- toupper(added)
[18:06:09.123]                 for (kk in seq_along(NAMES)) {
[18:06:09.123]                   name <- added[[kk]]
[18:06:09.123]                   NAME <- NAMES[[kk]]
[18:06:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:09.123]                     next
[18:06:09.123]                   args[[name]] <- ""
[18:06:09.123]                 }
[18:06:09.123]                 NAMES <- toupper(removed)
[18:06:09.123]                 for (kk in seq_along(NAMES)) {
[18:06:09.123]                   name <- removed[[kk]]
[18:06:09.123]                   NAME <- NAMES[[kk]]
[18:06:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:09.123]                     next
[18:06:09.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:09.123]                 }
[18:06:09.123]                 if (length(args) > 0) 
[18:06:09.123]                   base::do.call(base::Sys.setenv, args = args)
[18:06:09.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:09.123]             }
[18:06:09.123]             else {
[18:06:09.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:09.123]             }
[18:06:09.123]             {
[18:06:09.123]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:09.123]                   0L) {
[18:06:09.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:09.123]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:09.123]                   base::options(opts)
[18:06:09.123]                 }
[18:06:09.123]                 {
[18:06:09.123]                   {
[18:06:09.123]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:09.123]                     NULL
[18:06:09.123]                   }
[18:06:09.123]                   options(future.plan = NULL)
[18:06:09.123]                   if (is.na(NA_character_)) 
[18:06:09.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:09.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:09.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:09.123]                     .init = FALSE)
[18:06:09.123]                 }
[18:06:09.123]             }
[18:06:09.123]         }
[18:06:09.123]     })
[18:06:09.123]     if (TRUE) {
[18:06:09.123]         base::sink(type = "output", split = FALSE)
[18:06:09.123]         if (TRUE) {
[18:06:09.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:09.123]         }
[18:06:09.123]         else {
[18:06:09.123]             ...future.result["stdout"] <- base::list(NULL)
[18:06:09.123]         }
[18:06:09.123]         base::close(...future.stdout)
[18:06:09.123]         ...future.stdout <- NULL
[18:06:09.123]     }
[18:06:09.123]     ...future.result$conditions <- ...future.conditions
[18:06:09.123]     ...future.result$finished <- base::Sys.time()
[18:06:09.123]     ...future.result
[18:06:09.123] }
[18:06:09.129] requestCore(): workers = 2
[18:06:09.130] Poll #1 (0): usedCores() = 2, workers = 2
[18:06:09.142] result() for MulticoreFuture ...
[18:06:09.143] result() for MulticoreFuture ...
[18:06:09.144] result() for MulticoreFuture ... done
[18:06:09.144] result() for MulticoreFuture ... done
[18:06:09.144] result() for MulticoreFuture ...
[18:06:09.144] result() for MulticoreFuture ... done
[18:06:09.151] MulticoreFuture started
[18:06:09.152] - Launch lazy future ... done
[18:06:09.152] run() for ‘MulticoreFuture’ ... done
[18:06:09.156] resolve() on list environment ...
[18:06:09.155] plan(): Setting new future strategy stack:
[18:06:09.156]  recursive: 0
[18:06:09.158]  length: 4
[18:06:09.159]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:09.159] Future #1
[18:06:09.156] List of future strategies:
[18:06:09.156] 1. sequential:
[18:06:09.156]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:09.156]    - tweaked: FALSE
[18:06:09.156]    - call: NULL
[18:06:09.160]  length: 3 (resolved future 1)
[18:06:09.160] plan(): nbrOfWorkers() = 1
[18:06:09.165] plan(): Setting new future strategy stack:
[18:06:09.165] List of future strategies:
[18:06:09.165] 1. multicore:
[18:06:09.165]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:09.165]    - tweaked: FALSE
[18:06:09.165]    - call: plan(strategy)
[18:06:09.175] plan(): nbrOfWorkers() = 2
[18:06:09.176] Future #3
[18:06:09.177]  length: 2 (resolved future 3)
[18:06:09.177]  length: 1 (resolved future 4)
[18:06:09.600] plan(): Setting new future strategy stack:
[18:06:09.601] List of future strategies:
[18:06:09.601] 1. multicore:
[18:06:09.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:06:09.601]    - tweaked: FALSE
[18:06:09.601]    - call: plan(strategy)
[18:06:09.612] plan(): nbrOfWorkers() = 2
[18:06:09.613] Future #2
[18:06:09.614]  length: 0 (resolved future 2)
[18:06:09.614] resolve() on list environment ... DONE
[18:06:09.616] resolve() on list environment ...
[18:06:09.616]  recursive: 0
[18:06:09.619]  length: 4
[18:06:09.620]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:09.620] Future #1
[18:06:09.621]  length: 3 (resolved future 1)
[18:06:09.622] Future #2
[18:06:09.622]  length: 2 (resolved future 2)
[18:06:09.623] Future #3
[18:06:09.623]  length: 1 (resolved future 3)
[18:06:09.624]  length: 0 (resolved future 4)
[18:06:09.624] resolve() on list environment ... DONE
[18:06:09.626] resolve() on list environment ...
[18:06:09.627]  recursive: 0
[18:06:09.630]  length: 4
[18:06:09.630]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:09.631] Future #1
[18:06:09.632]  length: 3 (resolved future 1)
[18:06:09.633] Future #2
[18:06:09.633]  length: 2 (resolved future 2)
[18:06:09.634] Future #3
[18:06:09.635]  length: 1 (resolved future 3)
[18:06:09.635]  length: 0 (resolved future 4)
[18:06:09.636] resolve() on list environment ... DONE
[18:06:09.638] resolve() on list environment ...
[18:06:09.638]  recursive: 0
[18:06:09.641]  length: 4
[18:06:09.641]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:09.642] Future #1
[18:06:09.642]  length: 3 (resolved future 1)
[18:06:09.650] Future #2
[18:06:09.651]  length: 2 (resolved future 2)
[18:06:09.653] Future #3
[18:06:09.654]  length: 1 (resolved future 3)
[18:06:09.655]  length: 0 (resolved future 4)
[18:06:09.655] resolve() on list environment ... DONE
[18:06:09.659] resolve() on list environment ...
[18:06:09.659]  recursive: 0
[18:06:09.662]  length: 4
[18:06:09.663]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:09.664] Future #1
[18:06:09.664] result() for MulticoreFuture ...
[18:06:09.665] result() for MulticoreFuture ... done
[18:06:09.665] result() for MulticoreFuture ...
[18:06:09.666] result() for MulticoreFuture ... done
[18:06:09.666]  length: 3 (resolved future 1)
[18:06:09.667] Future #2
[18:06:09.668] result() for MulticoreFuture ...
[18:06:09.670] result() for MulticoreFuture ...
[18:06:09.670] result() for MulticoreFuture ... done
[18:06:09.671] result() for MulticoreFuture ... done
[18:06:09.671] result() for MulticoreFuture ...
[18:06:09.671] result() for MulticoreFuture ... done
[18:06:09.672]  length: 2 (resolved future 2)
[18:06:09.673] Future #3
[18:06:09.673] result() for MulticoreFuture ...
[18:06:09.675] result() for MulticoreFuture ...
[18:06:09.675] result() for MulticoreFuture ... done
[18:06:09.676] result() for MulticoreFuture ... done
[18:06:09.676] result() for MulticoreFuture ...
[18:06:09.676] result() for MulticoreFuture ... done
[18:06:09.677]  length: 1 (resolved future 3)
[18:06:09.677]  length: 0 (resolved future 4)
[18:06:09.678] resolve() on list environment ... DONE
[18:06:09.679] resolve() on list environment ...
[18:06:09.679]  recursive: 99
[18:06:09.681]  length: 4
[18:06:09.682]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:09.682] Future #1
[18:06:09.682] result() for MulticoreFuture ...
[18:06:09.682] result() for MulticoreFuture ... done
[18:06:09.683] result() for MulticoreFuture ...
[18:06:09.683] result() for MulticoreFuture ... done
[18:06:09.683] A MulticoreFuture was resolved
[18:06:09.684]  length: 3 (resolved future 1)
[18:06:09.684] Future #2
[18:06:09.684] result() for MulticoreFuture ...
[18:06:09.684] result() for MulticoreFuture ... done
[18:06:09.685] result() for MulticoreFuture ...
[18:06:09.685] result() for MulticoreFuture ... done
[18:06:09.685] A MulticoreFuture was resolved
[18:06:09.686]  length: 2 (resolved future 2)
[18:06:09.686] Future #3
[18:06:09.686] result() for MulticoreFuture ...
[18:06:09.686] result() for MulticoreFuture ... done
[18:06:09.687] result() for MulticoreFuture ...
[18:06:09.687] result() for MulticoreFuture ... done
[18:06:09.687] A MulticoreFuture was resolved
[18:06:09.688]  length: 1 (resolved future 3)
[18:06:09.688]  length: 0 (resolved future 4)
[18:06:09.688] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[18:06:09.690] plan(): Setting new future strategy stack:
[18:06:09.690] List of future strategies:
[18:06:09.690] 1. multisession:
[18:06:09.690]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:06:09.690]    - tweaked: FALSE
[18:06:09.690]    - call: plan(strategy)
[18:06:09.691] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:06:09.691] multisession:
[18:06:09.691] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:06:09.691] - tweaked: FALSE
[18:06:09.691] - call: plan(strategy)
[18:06:09.701] getGlobalsAndPackages() ...
[18:06:09.702] Not searching for globals
[18:06:09.702] - globals: [0] <none>
[18:06:09.703] getGlobalsAndPackages() ... DONE
[18:06:09.704] [local output] makeClusterPSOCK() ...
[18:06:09.769] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:06:09.771] [local output] Base port: 11170
[18:06:09.772] [local output] Getting setup options for 2 cluster nodes ...
[18:06:09.772] [local output]  - Node 1 of 2 ...
[18:06:09.773] [local output] localMachine=TRUE => revtunnel=FALSE

[18:06:09.774] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpxIgMSR/worker.rank=1.parallelly.parent=329327.5066f7b519816.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpxIgMSR/worker.rank=1.parallelly.parent=329327.5066f7b519816.pid")'’
[18:06:10.030] - Possible to infer worker's PID: TRUE
[18:06:10.030] [local output] Rscript port: 11170

[18:06:10.031] [local output]  - Node 2 of 2 ...
[18:06:10.032] [local output] localMachine=TRUE => revtunnel=FALSE

[18:06:10.033] [local output] Rscript port: 11170

[18:06:10.033] [local output] Getting setup options for 2 cluster nodes ... done
[18:06:10.033] [local output]  - Parallel setup requested for some PSOCK nodes
[18:06:10.034] [local output] Setting up PSOCK nodes in parallel
[18:06:10.035] List of 36
[18:06:10.035]  $ worker          : chr "localhost"
[18:06:10.035]   ..- attr(*, "localhost")= logi TRUE
[18:06:10.035]  $ master          : chr "localhost"
[18:06:10.035]  $ port            : int 11170
[18:06:10.035]  $ connectTimeout  : num 120
[18:06:10.035]  $ timeout         : num 2592000
[18:06:10.035]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:06:10.035]  $ homogeneous     : logi TRUE
[18:06:10.035]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:06:10.035]  $ rscript_envs    : NULL
[18:06:10.035]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:06:10.035]  $ rscript_startup : NULL
[18:06:10.035]  $ rscript_sh      : chr "sh"
[18:06:10.035]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:06:10.035]  $ methods         : logi TRUE
[18:06:10.035]  $ socketOptions   : chr "no-delay"
[18:06:10.035]  $ useXDR          : logi FALSE
[18:06:10.035]  $ outfile         : chr "/dev/null"
[18:06:10.035]  $ renice          : int NA
[18:06:10.035]  $ rshcmd          : NULL
[18:06:10.035]  $ user            : chr(0) 
[18:06:10.035]  $ revtunnel       : logi FALSE
[18:06:10.035]  $ rshlogfile      : NULL
[18:06:10.035]  $ rshopts         : chr(0) 
[18:06:10.035]  $ rank            : int 1
[18:06:10.035]  $ manual          : logi FALSE
[18:06:10.035]  $ dryrun          : logi FALSE
[18:06:10.035]  $ quiet           : logi FALSE
[18:06:10.035]  $ setup_strategy  : chr "parallel"
[18:06:10.035]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:06:10.035]  $ pidfile         : chr "/tmp/RtmpxIgMSR/worker.rank=1.parallelly.parent=329327.5066f7b519816.pid"
[18:06:10.035]  $ rshcmd_label    : NULL
[18:06:10.035]  $ rsh_call        : NULL
[18:06:10.035]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:06:10.035]  $ localMachine    : logi TRUE
[18:06:10.035]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:06:10.035]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:06:10.035]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:06:10.035]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:06:10.035]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:06:10.035]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:06:10.035]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:06:10.035]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:06:10.035]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:06:10.035]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:06:10.035]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:06:10.035]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:06:10.035]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:06:10.035]  $ arguments       :List of 28
[18:06:10.035]   ..$ worker          : chr "localhost"
[18:06:10.035]   ..$ master          : NULL
[18:06:10.035]   ..$ port            : int 11170
[18:06:10.035]   ..$ connectTimeout  : num 120
[18:06:10.035]   ..$ timeout         : num 2592000
[18:06:10.035]   ..$ rscript         : NULL
[18:06:10.035]   ..$ homogeneous     : NULL
[18:06:10.035]   ..$ rscript_args    : NULL
[18:06:10.035]   ..$ rscript_envs    : NULL
[18:06:10.035]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:06:10.035]   ..$ rscript_startup : NULL
[18:06:10.035]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:06:10.035]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:06:10.035]   ..$ methods         : logi TRUE
[18:06:10.035]   ..$ socketOptions   : chr "no-delay"
[18:06:10.035]   ..$ useXDR          : logi FALSE
[18:06:10.035]   ..$ outfile         : chr "/dev/null"
[18:06:10.035]   ..$ renice          : int NA
[18:06:10.035]   ..$ rshcmd          : NULL
[18:06:10.035]   ..$ user            : NULL
[18:06:10.035]   ..$ revtunnel       : logi NA
[18:06:10.035]   ..$ rshlogfile      : NULL
[18:06:10.035]   ..$ rshopts         : NULL
[18:06:10.035]   ..$ rank            : int 1
[18:06:10.035]   ..$ manual          : logi FALSE
[18:06:10.035]   ..$ dryrun          : logi FALSE
[18:06:10.035]   ..$ quiet           : logi FALSE
[18:06:10.035]   ..$ setup_strategy  : chr "parallel"
[18:06:10.035]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:06:10.069] [local output] System call to launch all workers:
[18:06:10.069] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpxIgMSR/worker.rank=1.parallelly.parent=329327.5066f7b519816.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11170 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:06:10.069] [local output] Starting PSOCK main server
[18:06:10.079] [local output] Workers launched
[18:06:10.079] [local output] Waiting for workers to connect back
[18:06:10.080]  - [local output] 0 workers out of 2 ready
[18:06:10.447]  - [local output] 0 workers out of 2 ready
[18:06:10.449]  - [local output] 1 workers out of 2 ready
[18:06:10.458]  - [local output] 1 workers out of 2 ready
[18:06:10.459]  - [local output] 2 workers out of 2 ready
[18:06:10.459] [local output] Launching of workers completed
[18:06:10.459] [local output] Collecting session information from workers
[18:06:10.461] [local output]  - Worker #1 of 2
[18:06:10.462] [local output]  - Worker #2 of 2
[18:06:10.462] [local output] makeClusterPSOCK() ... done
[18:06:10.482] Packages needed by the future expression (n = 0): <none>
[18:06:10.482] Packages needed by future strategies (n = 0): <none>
[18:06:10.483] {
[18:06:10.483]     {
[18:06:10.483]         {
[18:06:10.483]             ...future.startTime <- base::Sys.time()
[18:06:10.483]             {
[18:06:10.483]                 {
[18:06:10.483]                   {
[18:06:10.483]                     {
[18:06:10.483]                       base::local({
[18:06:10.483]                         has_future <- base::requireNamespace("future", 
[18:06:10.483]                           quietly = TRUE)
[18:06:10.483]                         if (has_future) {
[18:06:10.483]                           ns <- base::getNamespace("future")
[18:06:10.483]                           version <- ns[[".package"]][["version"]]
[18:06:10.483]                           if (is.null(version)) 
[18:06:10.483]                             version <- utils::packageVersion("future")
[18:06:10.483]                         }
[18:06:10.483]                         else {
[18:06:10.483]                           version <- NULL
[18:06:10.483]                         }
[18:06:10.483]                         if (!has_future || version < "1.8.0") {
[18:06:10.483]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:10.483]                             "", base::R.version$version.string), 
[18:06:10.483]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:10.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:10.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:10.483]                               "release", "version")], collapse = " "), 
[18:06:10.483]                             hostname = base::Sys.info()[["nodename"]])
[18:06:10.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:10.483]                             info)
[18:06:10.483]                           info <- base::paste(info, collapse = "; ")
[18:06:10.483]                           if (!has_future) {
[18:06:10.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:10.483]                               info)
[18:06:10.483]                           }
[18:06:10.483]                           else {
[18:06:10.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:10.483]                               info, version)
[18:06:10.483]                           }
[18:06:10.483]                           base::stop(msg)
[18:06:10.483]                         }
[18:06:10.483]                       })
[18:06:10.483]                     }
[18:06:10.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:10.483]                     base::options(mc.cores = 1L)
[18:06:10.483]                   }
[18:06:10.483]                   ...future.strategy.old <- future::plan("list")
[18:06:10.483]                   options(future.plan = NULL)
[18:06:10.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:10.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:10.483]                 }
[18:06:10.483]                 ...future.workdir <- getwd()
[18:06:10.483]             }
[18:06:10.483]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:10.483]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:10.483]         }
[18:06:10.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:10.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:10.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:10.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:10.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:10.483]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:10.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:10.483]             base::names(...future.oldOptions))
[18:06:10.483]     }
[18:06:10.483]     if (FALSE) {
[18:06:10.483]     }
[18:06:10.483]     else {
[18:06:10.483]         if (TRUE) {
[18:06:10.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:10.483]                 open = "w")
[18:06:10.483]         }
[18:06:10.483]         else {
[18:06:10.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:10.483]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:10.483]         }
[18:06:10.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:10.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:10.483]             base::sink(type = "output", split = FALSE)
[18:06:10.483]             base::close(...future.stdout)
[18:06:10.483]         }, add = TRUE)
[18:06:10.483]     }
[18:06:10.483]     ...future.frame <- base::sys.nframe()
[18:06:10.483]     ...future.conditions <- base::list()
[18:06:10.483]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:10.483]     if (FALSE) {
[18:06:10.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:10.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:10.483]     }
[18:06:10.483]     ...future.result <- base::tryCatch({
[18:06:10.483]         base::withCallingHandlers({
[18:06:10.483]             ...future.value <- base::withVisible(base::local({
[18:06:10.483]                 ...future.makeSendCondition <- base::local({
[18:06:10.483]                   sendCondition <- NULL
[18:06:10.483]                   function(frame = 1L) {
[18:06:10.483]                     if (is.function(sendCondition)) 
[18:06:10.483]                       return(sendCondition)
[18:06:10.483]                     ns <- getNamespace("parallel")
[18:06:10.483]                     if (exists("sendData", mode = "function", 
[18:06:10.483]                       envir = ns)) {
[18:06:10.483]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:10.483]                         envir = ns)
[18:06:10.483]                       envir <- sys.frame(frame)
[18:06:10.483]                       master <- NULL
[18:06:10.483]                       while (!identical(envir, .GlobalEnv) && 
[18:06:10.483]                         !identical(envir, emptyenv())) {
[18:06:10.483]                         if (exists("master", mode = "list", envir = envir, 
[18:06:10.483]                           inherits = FALSE)) {
[18:06:10.483]                           master <- get("master", mode = "list", 
[18:06:10.483]                             envir = envir, inherits = FALSE)
[18:06:10.483]                           if (inherits(master, c("SOCKnode", 
[18:06:10.483]                             "SOCK0node"))) {
[18:06:10.483]                             sendCondition <<- function(cond) {
[18:06:10.483]                               data <- list(type = "VALUE", value = cond, 
[18:06:10.483]                                 success = TRUE)
[18:06:10.483]                               parallel_sendData(master, data)
[18:06:10.483]                             }
[18:06:10.483]                             return(sendCondition)
[18:06:10.483]                           }
[18:06:10.483]                         }
[18:06:10.483]                         frame <- frame + 1L
[18:06:10.483]                         envir <- sys.frame(frame)
[18:06:10.483]                       }
[18:06:10.483]                     }
[18:06:10.483]                     sendCondition <<- function(cond) NULL
[18:06:10.483]                   }
[18:06:10.483]                 })
[18:06:10.483]                 withCallingHandlers({
[18:06:10.483]                   NA
[18:06:10.483]                 }, immediateCondition = function(cond) {
[18:06:10.483]                   sendCondition <- ...future.makeSendCondition()
[18:06:10.483]                   sendCondition(cond)
[18:06:10.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:10.483]                   {
[18:06:10.483]                     inherits <- base::inherits
[18:06:10.483]                     invokeRestart <- base::invokeRestart
[18:06:10.483]                     is.null <- base::is.null
[18:06:10.483]                     muffled <- FALSE
[18:06:10.483]                     if (inherits(cond, "message")) {
[18:06:10.483]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:10.483]                       if (muffled) 
[18:06:10.483]                         invokeRestart("muffleMessage")
[18:06:10.483]                     }
[18:06:10.483]                     else if (inherits(cond, "warning")) {
[18:06:10.483]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:10.483]                       if (muffled) 
[18:06:10.483]                         invokeRestart("muffleWarning")
[18:06:10.483]                     }
[18:06:10.483]                     else if (inherits(cond, "condition")) {
[18:06:10.483]                       if (!is.null(pattern)) {
[18:06:10.483]                         computeRestarts <- base::computeRestarts
[18:06:10.483]                         grepl <- base::grepl
[18:06:10.483]                         restarts <- computeRestarts(cond)
[18:06:10.483]                         for (restart in restarts) {
[18:06:10.483]                           name <- restart$name
[18:06:10.483]                           if (is.null(name)) 
[18:06:10.483]                             next
[18:06:10.483]                           if (!grepl(pattern, name)) 
[18:06:10.483]                             next
[18:06:10.483]                           invokeRestart(restart)
[18:06:10.483]                           muffled <- TRUE
[18:06:10.483]                           break
[18:06:10.483]                         }
[18:06:10.483]                       }
[18:06:10.483]                     }
[18:06:10.483]                     invisible(muffled)
[18:06:10.483]                   }
[18:06:10.483]                   muffleCondition(cond)
[18:06:10.483]                 })
[18:06:10.483]             }))
[18:06:10.483]             future::FutureResult(value = ...future.value$value, 
[18:06:10.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:10.483]                   ...future.rng), globalenv = if (FALSE) 
[18:06:10.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:10.483]                     ...future.globalenv.names))
[18:06:10.483]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:10.483]         }, condition = base::local({
[18:06:10.483]             c <- base::c
[18:06:10.483]             inherits <- base::inherits
[18:06:10.483]             invokeRestart <- base::invokeRestart
[18:06:10.483]             length <- base::length
[18:06:10.483]             list <- base::list
[18:06:10.483]             seq.int <- base::seq.int
[18:06:10.483]             signalCondition <- base::signalCondition
[18:06:10.483]             sys.calls <- base::sys.calls
[18:06:10.483]             `[[` <- base::`[[`
[18:06:10.483]             `+` <- base::`+`
[18:06:10.483]             `<<-` <- base::`<<-`
[18:06:10.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:10.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:10.483]                   3L)]
[18:06:10.483]             }
[18:06:10.483]             function(cond) {
[18:06:10.483]                 is_error <- inherits(cond, "error")
[18:06:10.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:10.483]                   NULL)
[18:06:10.483]                 if (is_error) {
[18:06:10.483]                   sessionInformation <- function() {
[18:06:10.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:10.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:10.483]                       search = base::search(), system = base::Sys.info())
[18:06:10.483]                   }
[18:06:10.483]                   ...future.conditions[[length(...future.conditions) + 
[18:06:10.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:10.483]                     cond$call), session = sessionInformation(), 
[18:06:10.483]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:10.483]                   signalCondition(cond)
[18:06:10.483]                 }
[18:06:10.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:10.483]                 "immediateCondition"))) {
[18:06:10.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:10.483]                   ...future.conditions[[length(...future.conditions) + 
[18:06:10.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:10.483]                   if (TRUE && !signal) {
[18:06:10.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:10.483]                     {
[18:06:10.483]                       inherits <- base::inherits
[18:06:10.483]                       invokeRestart <- base::invokeRestart
[18:06:10.483]                       is.null <- base::is.null
[18:06:10.483]                       muffled <- FALSE
[18:06:10.483]                       if (inherits(cond, "message")) {
[18:06:10.483]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:10.483]                         if (muffled) 
[18:06:10.483]                           invokeRestart("muffleMessage")
[18:06:10.483]                       }
[18:06:10.483]                       else if (inherits(cond, "warning")) {
[18:06:10.483]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:10.483]                         if (muffled) 
[18:06:10.483]                           invokeRestart("muffleWarning")
[18:06:10.483]                       }
[18:06:10.483]                       else if (inherits(cond, "condition")) {
[18:06:10.483]                         if (!is.null(pattern)) {
[18:06:10.483]                           computeRestarts <- base::computeRestarts
[18:06:10.483]                           grepl <- base::grepl
[18:06:10.483]                           restarts <- computeRestarts(cond)
[18:06:10.483]                           for (restart in restarts) {
[18:06:10.483]                             name <- restart$name
[18:06:10.483]                             if (is.null(name)) 
[18:06:10.483]                               next
[18:06:10.483]                             if (!grepl(pattern, name)) 
[18:06:10.483]                               next
[18:06:10.483]                             invokeRestart(restart)
[18:06:10.483]                             muffled <- TRUE
[18:06:10.483]                             break
[18:06:10.483]                           }
[18:06:10.483]                         }
[18:06:10.483]                       }
[18:06:10.483]                       invisible(muffled)
[18:06:10.483]                     }
[18:06:10.483]                     muffleCondition(cond, pattern = "^muffle")
[18:06:10.483]                   }
[18:06:10.483]                 }
[18:06:10.483]                 else {
[18:06:10.483]                   if (TRUE) {
[18:06:10.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:10.483]                     {
[18:06:10.483]                       inherits <- base::inherits
[18:06:10.483]                       invokeRestart <- base::invokeRestart
[18:06:10.483]                       is.null <- base::is.null
[18:06:10.483]                       muffled <- FALSE
[18:06:10.483]                       if (inherits(cond, "message")) {
[18:06:10.483]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:10.483]                         if (muffled) 
[18:06:10.483]                           invokeRestart("muffleMessage")
[18:06:10.483]                       }
[18:06:10.483]                       else if (inherits(cond, "warning")) {
[18:06:10.483]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:10.483]                         if (muffled) 
[18:06:10.483]                           invokeRestart("muffleWarning")
[18:06:10.483]                       }
[18:06:10.483]                       else if (inherits(cond, "condition")) {
[18:06:10.483]                         if (!is.null(pattern)) {
[18:06:10.483]                           computeRestarts <- base::computeRestarts
[18:06:10.483]                           grepl <- base::grepl
[18:06:10.483]                           restarts <- computeRestarts(cond)
[18:06:10.483]                           for (restart in restarts) {
[18:06:10.483]                             name <- restart$name
[18:06:10.483]                             if (is.null(name)) 
[18:06:10.483]                               next
[18:06:10.483]                             if (!grepl(pattern, name)) 
[18:06:10.483]                               next
[18:06:10.483]                             invokeRestart(restart)
[18:06:10.483]                             muffled <- TRUE
[18:06:10.483]                             break
[18:06:10.483]                           }
[18:06:10.483]                         }
[18:06:10.483]                       }
[18:06:10.483]                       invisible(muffled)
[18:06:10.483]                     }
[18:06:10.483]                     muffleCondition(cond, pattern = "^muffle")
[18:06:10.483]                   }
[18:06:10.483]                 }
[18:06:10.483]             }
[18:06:10.483]         }))
[18:06:10.483]     }, error = function(ex) {
[18:06:10.483]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:10.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:10.483]                 ...future.rng), started = ...future.startTime, 
[18:06:10.483]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:10.483]             version = "1.8"), class = "FutureResult")
[18:06:10.483]     }, finally = {
[18:06:10.483]         if (!identical(...future.workdir, getwd())) 
[18:06:10.483]             setwd(...future.workdir)
[18:06:10.483]         {
[18:06:10.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:10.483]                 ...future.oldOptions$nwarnings <- NULL
[18:06:10.483]             }
[18:06:10.483]             base::options(...future.oldOptions)
[18:06:10.483]             if (.Platform$OS.type == "windows") {
[18:06:10.483]                 old_names <- names(...future.oldEnvVars)
[18:06:10.483]                 envs <- base::Sys.getenv()
[18:06:10.483]                 names <- names(envs)
[18:06:10.483]                 common <- intersect(names, old_names)
[18:06:10.483]                 added <- setdiff(names, old_names)
[18:06:10.483]                 removed <- setdiff(old_names, names)
[18:06:10.483]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:10.483]                   envs[common]]
[18:06:10.483]                 NAMES <- toupper(changed)
[18:06:10.483]                 args <- list()
[18:06:10.483]                 for (kk in seq_along(NAMES)) {
[18:06:10.483]                   name <- changed[[kk]]
[18:06:10.483]                   NAME <- NAMES[[kk]]
[18:06:10.483]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:10.483]                     next
[18:06:10.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:10.483]                 }
[18:06:10.483]                 NAMES <- toupper(added)
[18:06:10.483]                 for (kk in seq_along(NAMES)) {
[18:06:10.483]                   name <- added[[kk]]
[18:06:10.483]                   NAME <- NAMES[[kk]]
[18:06:10.483]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:10.483]                     next
[18:06:10.483]                   args[[name]] <- ""
[18:06:10.483]                 }
[18:06:10.483]                 NAMES <- toupper(removed)
[18:06:10.483]                 for (kk in seq_along(NAMES)) {
[18:06:10.483]                   name <- removed[[kk]]
[18:06:10.483]                   NAME <- NAMES[[kk]]
[18:06:10.483]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:10.483]                     next
[18:06:10.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:10.483]                 }
[18:06:10.483]                 if (length(args) > 0) 
[18:06:10.483]                   base::do.call(base::Sys.setenv, args = args)
[18:06:10.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:10.483]             }
[18:06:10.483]             else {
[18:06:10.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:10.483]             }
[18:06:10.483]             {
[18:06:10.483]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:10.483]                   0L) {
[18:06:10.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:10.483]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:10.483]                   base::options(opts)
[18:06:10.483]                 }
[18:06:10.483]                 {
[18:06:10.483]                   {
[18:06:10.483]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:10.483]                     NULL
[18:06:10.483]                   }
[18:06:10.483]                   options(future.plan = NULL)
[18:06:10.483]                   if (is.na(NA_character_)) 
[18:06:10.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:10.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:10.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:10.483]                     .init = FALSE)
[18:06:10.483]                 }
[18:06:10.483]             }
[18:06:10.483]         }
[18:06:10.483]     })
[18:06:10.483]     if (TRUE) {
[18:06:10.483]         base::sink(type = "output", split = FALSE)
[18:06:10.483]         if (TRUE) {
[18:06:10.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:10.483]         }
[18:06:10.483]         else {
[18:06:10.483]             ...future.result["stdout"] <- base::list(NULL)
[18:06:10.483]         }
[18:06:10.483]         base::close(...future.stdout)
[18:06:10.483]         ...future.stdout <- NULL
[18:06:10.483]     }
[18:06:10.483]     ...future.result$conditions <- ...future.conditions
[18:06:10.483]     ...future.result$finished <- base::Sys.time()
[18:06:10.483]     ...future.result
[18:06:10.483] }
[18:06:10.586] MultisessionFuture started
[18:06:10.587] result() for ClusterFuture ...
[18:06:10.589] receiveMessageFromWorker() for ClusterFuture ...
[18:06:10.589] - Validating connection of MultisessionFuture
[18:06:10.652] - received message: FutureResult
[18:06:10.652] - Received FutureResult
[18:06:10.653] - Erased future from FutureRegistry
[18:06:10.653] result() for ClusterFuture ...
[18:06:10.653] - result already collected: FutureResult
[18:06:10.654] result() for ClusterFuture ... done
[18:06:10.654] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:10.654] result() for ClusterFuture ... done
[18:06:10.655] result() for ClusterFuture ...
[18:06:10.655] - result already collected: FutureResult
[18:06:10.655] result() for ClusterFuture ... done
[18:06:10.656] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:06:10.663] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[18:06:10.670] getGlobalsAndPackages() ...
[18:06:10.670] Searching for globals...
[18:06:10.673] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:10.673] Searching for globals ... DONE
[18:06:10.673] Resolving globals: FALSE
[18:06:10.674] 
[18:06:10.674] 
[18:06:10.674] getGlobalsAndPackages() ... DONE
[18:06:10.675] run() for ‘Future’ ...
[18:06:10.675] - state: ‘created’
[18:06:10.675] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:10.701] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:10.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:10.701]   - Field: ‘node’
[18:06:10.702]   - Field: ‘label’
[18:06:10.702]   - Field: ‘local’
[18:06:10.702]   - Field: ‘owner’
[18:06:10.702]   - Field: ‘envir’
[18:06:10.703]   - Field: ‘workers’
[18:06:10.703]   - Field: ‘packages’
[18:06:10.703]   - Field: ‘gc’
[18:06:10.703]   - Field: ‘conditions’
[18:06:10.703]   - Field: ‘persistent’
[18:06:10.704]   - Field: ‘expr’
[18:06:10.704]   - Field: ‘uuid’
[18:06:10.704]   - Field: ‘seed’
[18:06:10.704]   - Field: ‘version’
[18:06:10.705]   - Field: ‘result’
[18:06:10.705]   - Field: ‘asynchronous’
[18:06:10.705]   - Field: ‘calls’
[18:06:10.705]   - Field: ‘globals’
[18:06:10.706]   - Field: ‘stdout’
[18:06:10.706]   - Field: ‘earlySignal’
[18:06:10.706]   - Field: ‘lazy’
[18:06:10.706]   - Field: ‘state’
[18:06:10.706] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:10.707] - Launch lazy future ...
[18:06:10.707] Packages needed by the future expression (n = 0): <none>
[18:06:10.708] Packages needed by future strategies (n = 0): <none>
[18:06:10.709] {
[18:06:10.709]     {
[18:06:10.709]         {
[18:06:10.709]             ...future.startTime <- base::Sys.time()
[18:06:10.709]             {
[18:06:10.709]                 {
[18:06:10.709]                   {
[18:06:10.709]                     {
[18:06:10.709]                       base::local({
[18:06:10.709]                         has_future <- base::requireNamespace("future", 
[18:06:10.709]                           quietly = TRUE)
[18:06:10.709]                         if (has_future) {
[18:06:10.709]                           ns <- base::getNamespace("future")
[18:06:10.709]                           version <- ns[[".package"]][["version"]]
[18:06:10.709]                           if (is.null(version)) 
[18:06:10.709]                             version <- utils::packageVersion("future")
[18:06:10.709]                         }
[18:06:10.709]                         else {
[18:06:10.709]                           version <- NULL
[18:06:10.709]                         }
[18:06:10.709]                         if (!has_future || version < "1.8.0") {
[18:06:10.709]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:10.709]                             "", base::R.version$version.string), 
[18:06:10.709]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:10.709]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:10.709]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:10.709]                               "release", "version")], collapse = " "), 
[18:06:10.709]                             hostname = base::Sys.info()[["nodename"]])
[18:06:10.709]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:10.709]                             info)
[18:06:10.709]                           info <- base::paste(info, collapse = "; ")
[18:06:10.709]                           if (!has_future) {
[18:06:10.709]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:10.709]                               info)
[18:06:10.709]                           }
[18:06:10.709]                           else {
[18:06:10.709]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:10.709]                               info, version)
[18:06:10.709]                           }
[18:06:10.709]                           base::stop(msg)
[18:06:10.709]                         }
[18:06:10.709]                       })
[18:06:10.709]                     }
[18:06:10.709]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:10.709]                     base::options(mc.cores = 1L)
[18:06:10.709]                   }
[18:06:10.709]                   ...future.strategy.old <- future::plan("list")
[18:06:10.709]                   options(future.plan = NULL)
[18:06:10.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:10.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:10.709]                 }
[18:06:10.709]                 ...future.workdir <- getwd()
[18:06:10.709]             }
[18:06:10.709]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:10.709]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:10.709]         }
[18:06:10.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:10.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:10.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:10.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:10.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:10.709]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:10.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:10.709]             base::names(...future.oldOptions))
[18:06:10.709]     }
[18:06:10.709]     if (FALSE) {
[18:06:10.709]     }
[18:06:10.709]     else {
[18:06:10.709]         if (TRUE) {
[18:06:10.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:10.709]                 open = "w")
[18:06:10.709]         }
[18:06:10.709]         else {
[18:06:10.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:10.709]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:10.709]         }
[18:06:10.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:10.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:10.709]             base::sink(type = "output", split = FALSE)
[18:06:10.709]             base::close(...future.stdout)
[18:06:10.709]         }, add = TRUE)
[18:06:10.709]     }
[18:06:10.709]     ...future.frame <- base::sys.nframe()
[18:06:10.709]     ...future.conditions <- base::list()
[18:06:10.709]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:10.709]     if (FALSE) {
[18:06:10.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:10.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:10.709]     }
[18:06:10.709]     ...future.result <- base::tryCatch({
[18:06:10.709]         base::withCallingHandlers({
[18:06:10.709]             ...future.value <- base::withVisible(base::local({
[18:06:10.709]                 ...future.makeSendCondition <- base::local({
[18:06:10.709]                   sendCondition <- NULL
[18:06:10.709]                   function(frame = 1L) {
[18:06:10.709]                     if (is.function(sendCondition)) 
[18:06:10.709]                       return(sendCondition)
[18:06:10.709]                     ns <- getNamespace("parallel")
[18:06:10.709]                     if (exists("sendData", mode = "function", 
[18:06:10.709]                       envir = ns)) {
[18:06:10.709]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:10.709]                         envir = ns)
[18:06:10.709]                       envir <- sys.frame(frame)
[18:06:10.709]                       master <- NULL
[18:06:10.709]                       while (!identical(envir, .GlobalEnv) && 
[18:06:10.709]                         !identical(envir, emptyenv())) {
[18:06:10.709]                         if (exists("master", mode = "list", envir = envir, 
[18:06:10.709]                           inherits = FALSE)) {
[18:06:10.709]                           master <- get("master", mode = "list", 
[18:06:10.709]                             envir = envir, inherits = FALSE)
[18:06:10.709]                           if (inherits(master, c("SOCKnode", 
[18:06:10.709]                             "SOCK0node"))) {
[18:06:10.709]                             sendCondition <<- function(cond) {
[18:06:10.709]                               data <- list(type = "VALUE", value = cond, 
[18:06:10.709]                                 success = TRUE)
[18:06:10.709]                               parallel_sendData(master, data)
[18:06:10.709]                             }
[18:06:10.709]                             return(sendCondition)
[18:06:10.709]                           }
[18:06:10.709]                         }
[18:06:10.709]                         frame <- frame + 1L
[18:06:10.709]                         envir <- sys.frame(frame)
[18:06:10.709]                       }
[18:06:10.709]                     }
[18:06:10.709]                     sendCondition <<- function(cond) NULL
[18:06:10.709]                   }
[18:06:10.709]                 })
[18:06:10.709]                 withCallingHandlers({
[18:06:10.709]                   {
[18:06:10.709]                     Sys.sleep(0.5)
[18:06:10.709]                     list(a = 1, b = 42L)
[18:06:10.709]                   }
[18:06:10.709]                 }, immediateCondition = function(cond) {
[18:06:10.709]                   sendCondition <- ...future.makeSendCondition()
[18:06:10.709]                   sendCondition(cond)
[18:06:10.709]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:10.709]                   {
[18:06:10.709]                     inherits <- base::inherits
[18:06:10.709]                     invokeRestart <- base::invokeRestart
[18:06:10.709]                     is.null <- base::is.null
[18:06:10.709]                     muffled <- FALSE
[18:06:10.709]                     if (inherits(cond, "message")) {
[18:06:10.709]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:10.709]                       if (muffled) 
[18:06:10.709]                         invokeRestart("muffleMessage")
[18:06:10.709]                     }
[18:06:10.709]                     else if (inherits(cond, "warning")) {
[18:06:10.709]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:10.709]                       if (muffled) 
[18:06:10.709]                         invokeRestart("muffleWarning")
[18:06:10.709]                     }
[18:06:10.709]                     else if (inherits(cond, "condition")) {
[18:06:10.709]                       if (!is.null(pattern)) {
[18:06:10.709]                         computeRestarts <- base::computeRestarts
[18:06:10.709]                         grepl <- base::grepl
[18:06:10.709]                         restarts <- computeRestarts(cond)
[18:06:10.709]                         for (restart in restarts) {
[18:06:10.709]                           name <- restart$name
[18:06:10.709]                           if (is.null(name)) 
[18:06:10.709]                             next
[18:06:10.709]                           if (!grepl(pattern, name)) 
[18:06:10.709]                             next
[18:06:10.709]                           invokeRestart(restart)
[18:06:10.709]                           muffled <- TRUE
[18:06:10.709]                           break
[18:06:10.709]                         }
[18:06:10.709]                       }
[18:06:10.709]                     }
[18:06:10.709]                     invisible(muffled)
[18:06:10.709]                   }
[18:06:10.709]                   muffleCondition(cond)
[18:06:10.709]                 })
[18:06:10.709]             }))
[18:06:10.709]             future::FutureResult(value = ...future.value$value, 
[18:06:10.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:10.709]                   ...future.rng), globalenv = if (FALSE) 
[18:06:10.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:10.709]                     ...future.globalenv.names))
[18:06:10.709]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:10.709]         }, condition = base::local({
[18:06:10.709]             c <- base::c
[18:06:10.709]             inherits <- base::inherits
[18:06:10.709]             invokeRestart <- base::invokeRestart
[18:06:10.709]             length <- base::length
[18:06:10.709]             list <- base::list
[18:06:10.709]             seq.int <- base::seq.int
[18:06:10.709]             signalCondition <- base::signalCondition
[18:06:10.709]             sys.calls <- base::sys.calls
[18:06:10.709]             `[[` <- base::`[[`
[18:06:10.709]             `+` <- base::`+`
[18:06:10.709]             `<<-` <- base::`<<-`
[18:06:10.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:10.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:10.709]                   3L)]
[18:06:10.709]             }
[18:06:10.709]             function(cond) {
[18:06:10.709]                 is_error <- inherits(cond, "error")
[18:06:10.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:10.709]                   NULL)
[18:06:10.709]                 if (is_error) {
[18:06:10.709]                   sessionInformation <- function() {
[18:06:10.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:10.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:10.709]                       search = base::search(), system = base::Sys.info())
[18:06:10.709]                   }
[18:06:10.709]                   ...future.conditions[[length(...future.conditions) + 
[18:06:10.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:10.709]                     cond$call), session = sessionInformation(), 
[18:06:10.709]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:10.709]                   signalCondition(cond)
[18:06:10.709]                 }
[18:06:10.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:10.709]                 "immediateCondition"))) {
[18:06:10.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:10.709]                   ...future.conditions[[length(...future.conditions) + 
[18:06:10.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:10.709]                   if (TRUE && !signal) {
[18:06:10.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:10.709]                     {
[18:06:10.709]                       inherits <- base::inherits
[18:06:10.709]                       invokeRestart <- base::invokeRestart
[18:06:10.709]                       is.null <- base::is.null
[18:06:10.709]                       muffled <- FALSE
[18:06:10.709]                       if (inherits(cond, "message")) {
[18:06:10.709]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:10.709]                         if (muffled) 
[18:06:10.709]                           invokeRestart("muffleMessage")
[18:06:10.709]                       }
[18:06:10.709]                       else if (inherits(cond, "warning")) {
[18:06:10.709]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:10.709]                         if (muffled) 
[18:06:10.709]                           invokeRestart("muffleWarning")
[18:06:10.709]                       }
[18:06:10.709]                       else if (inherits(cond, "condition")) {
[18:06:10.709]                         if (!is.null(pattern)) {
[18:06:10.709]                           computeRestarts <- base::computeRestarts
[18:06:10.709]                           grepl <- base::grepl
[18:06:10.709]                           restarts <- computeRestarts(cond)
[18:06:10.709]                           for (restart in restarts) {
[18:06:10.709]                             name <- restart$name
[18:06:10.709]                             if (is.null(name)) 
[18:06:10.709]                               next
[18:06:10.709]                             if (!grepl(pattern, name)) 
[18:06:10.709]                               next
[18:06:10.709]                             invokeRestart(restart)
[18:06:10.709]                             muffled <- TRUE
[18:06:10.709]                             break
[18:06:10.709]                           }
[18:06:10.709]                         }
[18:06:10.709]                       }
[18:06:10.709]                       invisible(muffled)
[18:06:10.709]                     }
[18:06:10.709]                     muffleCondition(cond, pattern = "^muffle")
[18:06:10.709]                   }
[18:06:10.709]                 }
[18:06:10.709]                 else {
[18:06:10.709]                   if (TRUE) {
[18:06:10.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:10.709]                     {
[18:06:10.709]                       inherits <- base::inherits
[18:06:10.709]                       invokeRestart <- base::invokeRestart
[18:06:10.709]                       is.null <- base::is.null
[18:06:10.709]                       muffled <- FALSE
[18:06:10.709]                       if (inherits(cond, "message")) {
[18:06:10.709]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:10.709]                         if (muffled) 
[18:06:10.709]                           invokeRestart("muffleMessage")
[18:06:10.709]                       }
[18:06:10.709]                       else if (inherits(cond, "warning")) {
[18:06:10.709]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:10.709]                         if (muffled) 
[18:06:10.709]                           invokeRestart("muffleWarning")
[18:06:10.709]                       }
[18:06:10.709]                       else if (inherits(cond, "condition")) {
[18:06:10.709]                         if (!is.null(pattern)) {
[18:06:10.709]                           computeRestarts <- base::computeRestarts
[18:06:10.709]                           grepl <- base::grepl
[18:06:10.709]                           restarts <- computeRestarts(cond)
[18:06:10.709]                           for (restart in restarts) {
[18:06:10.709]                             name <- restart$name
[18:06:10.709]                             if (is.null(name)) 
[18:06:10.709]                               next
[18:06:10.709]                             if (!grepl(pattern, name)) 
[18:06:10.709]                               next
[18:06:10.709]                             invokeRestart(restart)
[18:06:10.709]                             muffled <- TRUE
[18:06:10.709]                             break
[18:06:10.709]                           }
[18:06:10.709]                         }
[18:06:10.709]                       }
[18:06:10.709]                       invisible(muffled)
[18:06:10.709]                     }
[18:06:10.709]                     muffleCondition(cond, pattern = "^muffle")
[18:06:10.709]                   }
[18:06:10.709]                 }
[18:06:10.709]             }
[18:06:10.709]         }))
[18:06:10.709]     }, error = function(ex) {
[18:06:10.709]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:10.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:10.709]                 ...future.rng), started = ...future.startTime, 
[18:06:10.709]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:10.709]             version = "1.8"), class = "FutureResult")
[18:06:10.709]     }, finally = {
[18:06:10.709]         if (!identical(...future.workdir, getwd())) 
[18:06:10.709]             setwd(...future.workdir)
[18:06:10.709]         {
[18:06:10.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:10.709]                 ...future.oldOptions$nwarnings <- NULL
[18:06:10.709]             }
[18:06:10.709]             base::options(...future.oldOptions)
[18:06:10.709]             if (.Platform$OS.type == "windows") {
[18:06:10.709]                 old_names <- names(...future.oldEnvVars)
[18:06:10.709]                 envs <- base::Sys.getenv()
[18:06:10.709]                 names <- names(envs)
[18:06:10.709]                 common <- intersect(names, old_names)
[18:06:10.709]                 added <- setdiff(names, old_names)
[18:06:10.709]                 removed <- setdiff(old_names, names)
[18:06:10.709]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:10.709]                   envs[common]]
[18:06:10.709]                 NAMES <- toupper(changed)
[18:06:10.709]                 args <- list()
[18:06:10.709]                 for (kk in seq_along(NAMES)) {
[18:06:10.709]                   name <- changed[[kk]]
[18:06:10.709]                   NAME <- NAMES[[kk]]
[18:06:10.709]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:10.709]                     next
[18:06:10.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:10.709]                 }
[18:06:10.709]                 NAMES <- toupper(added)
[18:06:10.709]                 for (kk in seq_along(NAMES)) {
[18:06:10.709]                   name <- added[[kk]]
[18:06:10.709]                   NAME <- NAMES[[kk]]
[18:06:10.709]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:10.709]                     next
[18:06:10.709]                   args[[name]] <- ""
[18:06:10.709]                 }
[18:06:10.709]                 NAMES <- toupper(removed)
[18:06:10.709]                 for (kk in seq_along(NAMES)) {
[18:06:10.709]                   name <- removed[[kk]]
[18:06:10.709]                   NAME <- NAMES[[kk]]
[18:06:10.709]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:10.709]                     next
[18:06:10.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:10.709]                 }
[18:06:10.709]                 if (length(args) > 0) 
[18:06:10.709]                   base::do.call(base::Sys.setenv, args = args)
[18:06:10.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:10.709]             }
[18:06:10.709]             else {
[18:06:10.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:10.709]             }
[18:06:10.709]             {
[18:06:10.709]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:10.709]                   0L) {
[18:06:10.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:10.709]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:10.709]                   base::options(opts)
[18:06:10.709]                 }
[18:06:10.709]                 {
[18:06:10.709]                   {
[18:06:10.709]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:10.709]                     NULL
[18:06:10.709]                   }
[18:06:10.709]                   options(future.plan = NULL)
[18:06:10.709]                   if (is.na(NA_character_)) 
[18:06:10.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:10.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:10.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:10.709]                     .init = FALSE)
[18:06:10.709]                 }
[18:06:10.709]             }
[18:06:10.709]         }
[18:06:10.709]     })
[18:06:10.709]     if (TRUE) {
[18:06:10.709]         base::sink(type = "output", split = FALSE)
[18:06:10.709]         if (TRUE) {
[18:06:10.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:10.709]         }
[18:06:10.709]         else {
[18:06:10.709]             ...future.result["stdout"] <- base::list(NULL)
[18:06:10.709]         }
[18:06:10.709]         base::close(...future.stdout)
[18:06:10.709]         ...future.stdout <- NULL
[18:06:10.709]     }
[18:06:10.709]     ...future.result$conditions <- ...future.conditions
[18:06:10.709]     ...future.result$finished <- base::Sys.time()
[18:06:10.709]     ...future.result
[18:06:10.709] }
[18:06:10.715] MultisessionFuture started
[18:06:10.715] - Launch lazy future ... done
[18:06:10.715] run() for ‘MultisessionFuture’ ... done
[18:06:11.259] receiveMessageFromWorker() for ClusterFuture ...
[18:06:11.259] - Validating connection of MultisessionFuture
[18:06:11.260] - received message: FutureResult
[18:06:11.260] - Received FutureResult
[18:06:11.261] - Erased future from FutureRegistry
[18:06:11.262] result() for ClusterFuture ...
[18:06:11.262] - result already collected: FutureResult
[18:06:11.262] result() for ClusterFuture ... done
[18:06:11.263] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:11.263] A MultisessionFuture was resolved (result was not collected)
[18:06:11.264] getGlobalsAndPackages() ...
[18:06:11.264] Searching for globals...
[18:06:11.269] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:11.269] Searching for globals ... DONE
[18:06:11.270] Resolving globals: FALSE
[18:06:11.271] 
[18:06:11.272] 
[18:06:11.272] getGlobalsAndPackages() ... DONE
[18:06:11.273] run() for ‘Future’ ...
[18:06:11.273] - state: ‘created’
[18:06:11.274] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:11.301] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:11.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:11.302]   - Field: ‘node’
[18:06:11.302]   - Field: ‘label’
[18:06:11.302]   - Field: ‘local’
[18:06:11.303]   - Field: ‘owner’
[18:06:11.303]   - Field: ‘envir’
[18:06:11.303]   - Field: ‘workers’
[18:06:11.303]   - Field: ‘packages’
[18:06:11.303]   - Field: ‘gc’
[18:06:11.304]   - Field: ‘conditions’
[18:06:11.304]   - Field: ‘persistent’
[18:06:11.304]   - Field: ‘expr’
[18:06:11.304]   - Field: ‘uuid’
[18:06:11.305]   - Field: ‘seed’
[18:06:11.305]   - Field: ‘version’
[18:06:11.305]   - Field: ‘result’
[18:06:11.305]   - Field: ‘asynchronous’
[18:06:11.306]   - Field: ‘calls’
[18:06:11.306]   - Field: ‘globals’
[18:06:11.306]   - Field: ‘stdout’
[18:06:11.306]   - Field: ‘earlySignal’
[18:06:11.307]   - Field: ‘lazy’
[18:06:11.307]   - Field: ‘state’
[18:06:11.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:11.307] - Launch lazy future ...
[18:06:11.308] Packages needed by the future expression (n = 0): <none>
[18:06:11.308] Packages needed by future strategies (n = 0): <none>
[18:06:11.309] {
[18:06:11.309]     {
[18:06:11.309]         {
[18:06:11.309]             ...future.startTime <- base::Sys.time()
[18:06:11.309]             {
[18:06:11.309]                 {
[18:06:11.309]                   {
[18:06:11.309]                     {
[18:06:11.309]                       base::local({
[18:06:11.309]                         has_future <- base::requireNamespace("future", 
[18:06:11.309]                           quietly = TRUE)
[18:06:11.309]                         if (has_future) {
[18:06:11.309]                           ns <- base::getNamespace("future")
[18:06:11.309]                           version <- ns[[".package"]][["version"]]
[18:06:11.309]                           if (is.null(version)) 
[18:06:11.309]                             version <- utils::packageVersion("future")
[18:06:11.309]                         }
[18:06:11.309]                         else {
[18:06:11.309]                           version <- NULL
[18:06:11.309]                         }
[18:06:11.309]                         if (!has_future || version < "1.8.0") {
[18:06:11.309]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:11.309]                             "", base::R.version$version.string), 
[18:06:11.309]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:11.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:11.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:11.309]                               "release", "version")], collapse = " "), 
[18:06:11.309]                             hostname = base::Sys.info()[["nodename"]])
[18:06:11.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:11.309]                             info)
[18:06:11.309]                           info <- base::paste(info, collapse = "; ")
[18:06:11.309]                           if (!has_future) {
[18:06:11.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:11.309]                               info)
[18:06:11.309]                           }
[18:06:11.309]                           else {
[18:06:11.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:11.309]                               info, version)
[18:06:11.309]                           }
[18:06:11.309]                           base::stop(msg)
[18:06:11.309]                         }
[18:06:11.309]                       })
[18:06:11.309]                     }
[18:06:11.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:11.309]                     base::options(mc.cores = 1L)
[18:06:11.309]                   }
[18:06:11.309]                   ...future.strategy.old <- future::plan("list")
[18:06:11.309]                   options(future.plan = NULL)
[18:06:11.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:11.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:11.309]                 }
[18:06:11.309]                 ...future.workdir <- getwd()
[18:06:11.309]             }
[18:06:11.309]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:11.309]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:11.309]         }
[18:06:11.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:11.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:11.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:11.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:11.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:11.309]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:11.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:11.309]             base::names(...future.oldOptions))
[18:06:11.309]     }
[18:06:11.309]     if (FALSE) {
[18:06:11.309]     }
[18:06:11.309]     else {
[18:06:11.309]         if (TRUE) {
[18:06:11.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:11.309]                 open = "w")
[18:06:11.309]         }
[18:06:11.309]         else {
[18:06:11.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:11.309]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:11.309]         }
[18:06:11.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:11.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:11.309]             base::sink(type = "output", split = FALSE)
[18:06:11.309]             base::close(...future.stdout)
[18:06:11.309]         }, add = TRUE)
[18:06:11.309]     }
[18:06:11.309]     ...future.frame <- base::sys.nframe()
[18:06:11.309]     ...future.conditions <- base::list()
[18:06:11.309]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:11.309]     if (FALSE) {
[18:06:11.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:11.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:11.309]     }
[18:06:11.309]     ...future.result <- base::tryCatch({
[18:06:11.309]         base::withCallingHandlers({
[18:06:11.309]             ...future.value <- base::withVisible(base::local({
[18:06:11.309]                 ...future.makeSendCondition <- base::local({
[18:06:11.309]                   sendCondition <- NULL
[18:06:11.309]                   function(frame = 1L) {
[18:06:11.309]                     if (is.function(sendCondition)) 
[18:06:11.309]                       return(sendCondition)
[18:06:11.309]                     ns <- getNamespace("parallel")
[18:06:11.309]                     if (exists("sendData", mode = "function", 
[18:06:11.309]                       envir = ns)) {
[18:06:11.309]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:11.309]                         envir = ns)
[18:06:11.309]                       envir <- sys.frame(frame)
[18:06:11.309]                       master <- NULL
[18:06:11.309]                       while (!identical(envir, .GlobalEnv) && 
[18:06:11.309]                         !identical(envir, emptyenv())) {
[18:06:11.309]                         if (exists("master", mode = "list", envir = envir, 
[18:06:11.309]                           inherits = FALSE)) {
[18:06:11.309]                           master <- get("master", mode = "list", 
[18:06:11.309]                             envir = envir, inherits = FALSE)
[18:06:11.309]                           if (inherits(master, c("SOCKnode", 
[18:06:11.309]                             "SOCK0node"))) {
[18:06:11.309]                             sendCondition <<- function(cond) {
[18:06:11.309]                               data <- list(type = "VALUE", value = cond, 
[18:06:11.309]                                 success = TRUE)
[18:06:11.309]                               parallel_sendData(master, data)
[18:06:11.309]                             }
[18:06:11.309]                             return(sendCondition)
[18:06:11.309]                           }
[18:06:11.309]                         }
[18:06:11.309]                         frame <- frame + 1L
[18:06:11.309]                         envir <- sys.frame(frame)
[18:06:11.309]                       }
[18:06:11.309]                     }
[18:06:11.309]                     sendCondition <<- function(cond) NULL
[18:06:11.309]                   }
[18:06:11.309]                 })
[18:06:11.309]                 withCallingHandlers({
[18:06:11.309]                   {
[18:06:11.309]                     Sys.sleep(0.5)
[18:06:11.309]                     list(a = 1, b = 42L)
[18:06:11.309]                   }
[18:06:11.309]                 }, immediateCondition = function(cond) {
[18:06:11.309]                   sendCondition <- ...future.makeSendCondition()
[18:06:11.309]                   sendCondition(cond)
[18:06:11.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:11.309]                   {
[18:06:11.309]                     inherits <- base::inherits
[18:06:11.309]                     invokeRestart <- base::invokeRestart
[18:06:11.309]                     is.null <- base::is.null
[18:06:11.309]                     muffled <- FALSE
[18:06:11.309]                     if (inherits(cond, "message")) {
[18:06:11.309]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:11.309]                       if (muffled) 
[18:06:11.309]                         invokeRestart("muffleMessage")
[18:06:11.309]                     }
[18:06:11.309]                     else if (inherits(cond, "warning")) {
[18:06:11.309]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:11.309]                       if (muffled) 
[18:06:11.309]                         invokeRestart("muffleWarning")
[18:06:11.309]                     }
[18:06:11.309]                     else if (inherits(cond, "condition")) {
[18:06:11.309]                       if (!is.null(pattern)) {
[18:06:11.309]                         computeRestarts <- base::computeRestarts
[18:06:11.309]                         grepl <- base::grepl
[18:06:11.309]                         restarts <- computeRestarts(cond)
[18:06:11.309]                         for (restart in restarts) {
[18:06:11.309]                           name <- restart$name
[18:06:11.309]                           if (is.null(name)) 
[18:06:11.309]                             next
[18:06:11.309]                           if (!grepl(pattern, name)) 
[18:06:11.309]                             next
[18:06:11.309]                           invokeRestart(restart)
[18:06:11.309]                           muffled <- TRUE
[18:06:11.309]                           break
[18:06:11.309]                         }
[18:06:11.309]                       }
[18:06:11.309]                     }
[18:06:11.309]                     invisible(muffled)
[18:06:11.309]                   }
[18:06:11.309]                   muffleCondition(cond)
[18:06:11.309]                 })
[18:06:11.309]             }))
[18:06:11.309]             future::FutureResult(value = ...future.value$value, 
[18:06:11.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:11.309]                   ...future.rng), globalenv = if (FALSE) 
[18:06:11.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:11.309]                     ...future.globalenv.names))
[18:06:11.309]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:11.309]         }, condition = base::local({
[18:06:11.309]             c <- base::c
[18:06:11.309]             inherits <- base::inherits
[18:06:11.309]             invokeRestart <- base::invokeRestart
[18:06:11.309]             length <- base::length
[18:06:11.309]             list <- base::list
[18:06:11.309]             seq.int <- base::seq.int
[18:06:11.309]             signalCondition <- base::signalCondition
[18:06:11.309]             sys.calls <- base::sys.calls
[18:06:11.309]             `[[` <- base::`[[`
[18:06:11.309]             `+` <- base::`+`
[18:06:11.309]             `<<-` <- base::`<<-`
[18:06:11.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:11.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:11.309]                   3L)]
[18:06:11.309]             }
[18:06:11.309]             function(cond) {
[18:06:11.309]                 is_error <- inherits(cond, "error")
[18:06:11.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:11.309]                   NULL)
[18:06:11.309]                 if (is_error) {
[18:06:11.309]                   sessionInformation <- function() {
[18:06:11.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:11.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:11.309]                       search = base::search(), system = base::Sys.info())
[18:06:11.309]                   }
[18:06:11.309]                   ...future.conditions[[length(...future.conditions) + 
[18:06:11.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:11.309]                     cond$call), session = sessionInformation(), 
[18:06:11.309]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:11.309]                   signalCondition(cond)
[18:06:11.309]                 }
[18:06:11.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:11.309]                 "immediateCondition"))) {
[18:06:11.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:11.309]                   ...future.conditions[[length(...future.conditions) + 
[18:06:11.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:11.309]                   if (TRUE && !signal) {
[18:06:11.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:11.309]                     {
[18:06:11.309]                       inherits <- base::inherits
[18:06:11.309]                       invokeRestart <- base::invokeRestart
[18:06:11.309]                       is.null <- base::is.null
[18:06:11.309]                       muffled <- FALSE
[18:06:11.309]                       if (inherits(cond, "message")) {
[18:06:11.309]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:11.309]                         if (muffled) 
[18:06:11.309]                           invokeRestart("muffleMessage")
[18:06:11.309]                       }
[18:06:11.309]                       else if (inherits(cond, "warning")) {
[18:06:11.309]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:11.309]                         if (muffled) 
[18:06:11.309]                           invokeRestart("muffleWarning")
[18:06:11.309]                       }
[18:06:11.309]                       else if (inherits(cond, "condition")) {
[18:06:11.309]                         if (!is.null(pattern)) {
[18:06:11.309]                           computeRestarts <- base::computeRestarts
[18:06:11.309]                           grepl <- base::grepl
[18:06:11.309]                           restarts <- computeRestarts(cond)
[18:06:11.309]                           for (restart in restarts) {
[18:06:11.309]                             name <- restart$name
[18:06:11.309]                             if (is.null(name)) 
[18:06:11.309]                               next
[18:06:11.309]                             if (!grepl(pattern, name)) 
[18:06:11.309]                               next
[18:06:11.309]                             invokeRestart(restart)
[18:06:11.309]                             muffled <- TRUE
[18:06:11.309]                             break
[18:06:11.309]                           }
[18:06:11.309]                         }
[18:06:11.309]                       }
[18:06:11.309]                       invisible(muffled)
[18:06:11.309]                     }
[18:06:11.309]                     muffleCondition(cond, pattern = "^muffle")
[18:06:11.309]                   }
[18:06:11.309]                 }
[18:06:11.309]                 else {
[18:06:11.309]                   if (TRUE) {
[18:06:11.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:11.309]                     {
[18:06:11.309]                       inherits <- base::inherits
[18:06:11.309]                       invokeRestart <- base::invokeRestart
[18:06:11.309]                       is.null <- base::is.null
[18:06:11.309]                       muffled <- FALSE
[18:06:11.309]                       if (inherits(cond, "message")) {
[18:06:11.309]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:11.309]                         if (muffled) 
[18:06:11.309]                           invokeRestart("muffleMessage")
[18:06:11.309]                       }
[18:06:11.309]                       else if (inherits(cond, "warning")) {
[18:06:11.309]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:11.309]                         if (muffled) 
[18:06:11.309]                           invokeRestart("muffleWarning")
[18:06:11.309]                       }
[18:06:11.309]                       else if (inherits(cond, "condition")) {
[18:06:11.309]                         if (!is.null(pattern)) {
[18:06:11.309]                           computeRestarts <- base::computeRestarts
[18:06:11.309]                           grepl <- base::grepl
[18:06:11.309]                           restarts <- computeRestarts(cond)
[18:06:11.309]                           for (restart in restarts) {
[18:06:11.309]                             name <- restart$name
[18:06:11.309]                             if (is.null(name)) 
[18:06:11.309]                               next
[18:06:11.309]                             if (!grepl(pattern, name)) 
[18:06:11.309]                               next
[18:06:11.309]                             invokeRestart(restart)
[18:06:11.309]                             muffled <- TRUE
[18:06:11.309]                             break
[18:06:11.309]                           }
[18:06:11.309]                         }
[18:06:11.309]                       }
[18:06:11.309]                       invisible(muffled)
[18:06:11.309]                     }
[18:06:11.309]                     muffleCondition(cond, pattern = "^muffle")
[18:06:11.309]                   }
[18:06:11.309]                 }
[18:06:11.309]             }
[18:06:11.309]         }))
[18:06:11.309]     }, error = function(ex) {
[18:06:11.309]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:11.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:11.309]                 ...future.rng), started = ...future.startTime, 
[18:06:11.309]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:11.309]             version = "1.8"), class = "FutureResult")
[18:06:11.309]     }, finally = {
[18:06:11.309]         if (!identical(...future.workdir, getwd())) 
[18:06:11.309]             setwd(...future.workdir)
[18:06:11.309]         {
[18:06:11.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:11.309]                 ...future.oldOptions$nwarnings <- NULL
[18:06:11.309]             }
[18:06:11.309]             base::options(...future.oldOptions)
[18:06:11.309]             if (.Platform$OS.type == "windows") {
[18:06:11.309]                 old_names <- names(...future.oldEnvVars)
[18:06:11.309]                 envs <- base::Sys.getenv()
[18:06:11.309]                 names <- names(envs)
[18:06:11.309]                 common <- intersect(names, old_names)
[18:06:11.309]                 added <- setdiff(names, old_names)
[18:06:11.309]                 removed <- setdiff(old_names, names)
[18:06:11.309]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:11.309]                   envs[common]]
[18:06:11.309]                 NAMES <- toupper(changed)
[18:06:11.309]                 args <- list()
[18:06:11.309]                 for (kk in seq_along(NAMES)) {
[18:06:11.309]                   name <- changed[[kk]]
[18:06:11.309]                   NAME <- NAMES[[kk]]
[18:06:11.309]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:11.309]                     next
[18:06:11.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:11.309]                 }
[18:06:11.309]                 NAMES <- toupper(added)
[18:06:11.309]                 for (kk in seq_along(NAMES)) {
[18:06:11.309]                   name <- added[[kk]]
[18:06:11.309]                   NAME <- NAMES[[kk]]
[18:06:11.309]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:11.309]                     next
[18:06:11.309]                   args[[name]] <- ""
[18:06:11.309]                 }
[18:06:11.309]                 NAMES <- toupper(removed)
[18:06:11.309]                 for (kk in seq_along(NAMES)) {
[18:06:11.309]                   name <- removed[[kk]]
[18:06:11.309]                   NAME <- NAMES[[kk]]
[18:06:11.309]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:11.309]                     next
[18:06:11.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:11.309]                 }
[18:06:11.309]                 if (length(args) > 0) 
[18:06:11.309]                   base::do.call(base::Sys.setenv, args = args)
[18:06:11.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:11.309]             }
[18:06:11.309]             else {
[18:06:11.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:11.309]             }
[18:06:11.309]             {
[18:06:11.309]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:11.309]                   0L) {
[18:06:11.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:11.309]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:11.309]                   base::options(opts)
[18:06:11.309]                 }
[18:06:11.309]                 {
[18:06:11.309]                   {
[18:06:11.309]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:11.309]                     NULL
[18:06:11.309]                   }
[18:06:11.309]                   options(future.plan = NULL)
[18:06:11.309]                   if (is.na(NA_character_)) 
[18:06:11.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:11.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:11.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:11.309]                     .init = FALSE)
[18:06:11.309]                 }
[18:06:11.309]             }
[18:06:11.309]         }
[18:06:11.309]     })
[18:06:11.309]     if (TRUE) {
[18:06:11.309]         base::sink(type = "output", split = FALSE)
[18:06:11.309]         if (TRUE) {
[18:06:11.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:11.309]         }
[18:06:11.309]         else {
[18:06:11.309]             ...future.result["stdout"] <- base::list(NULL)
[18:06:11.309]         }
[18:06:11.309]         base::close(...future.stdout)
[18:06:11.309]         ...future.stdout <- NULL
[18:06:11.309]     }
[18:06:11.309]     ...future.result$conditions <- ...future.conditions
[18:06:11.309]     ...future.result$finished <- base::Sys.time()
[18:06:11.309]     ...future.result
[18:06:11.309] }
[18:06:11.316] MultisessionFuture started
[18:06:11.316] - Launch lazy future ... done
[18:06:11.317] run() for ‘MultisessionFuture’ ... done
[18:06:11.867] receiveMessageFromWorker() for ClusterFuture ...
[18:06:11.867] - Validating connection of MultisessionFuture
[18:06:11.868] - received message: FutureResult
[18:06:11.869] - Received FutureResult
[18:06:11.869] - Erased future from FutureRegistry
[18:06:11.869] result() for ClusterFuture ...
[18:06:11.870] - result already collected: FutureResult
[18:06:11.870] result() for ClusterFuture ... done
[18:06:11.871] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:11.871] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[18:06:11.872] getGlobalsAndPackages() ...
[18:06:11.872] Searching for globals...
[18:06:11.875] - globals found: [2] ‘list’, ‘stop’
[18:06:11.875] Searching for globals ... DONE
[18:06:11.876] Resolving globals: FALSE
[18:06:11.877] 
[18:06:11.877] 
[18:06:11.878] getGlobalsAndPackages() ... DONE
[18:06:11.879] run() for ‘Future’ ...
[18:06:11.879] - state: ‘created’
[18:06:11.880] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:11.922] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:11.923] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:11.923]   - Field: ‘node’
[18:06:11.923]   - Field: ‘label’
[18:06:11.924]   - Field: ‘local’
[18:06:11.924]   - Field: ‘owner’
[18:06:11.924]   - Field: ‘envir’
[18:06:11.925]   - Field: ‘workers’
[18:06:11.925]   - Field: ‘packages’
[18:06:11.925]   - Field: ‘gc’
[18:06:11.925]   - Field: ‘conditions’
[18:06:11.926]   - Field: ‘persistent’
[18:06:11.926]   - Field: ‘expr’
[18:06:11.927]   - Field: ‘uuid’
[18:06:11.927]   - Field: ‘seed’
[18:06:11.927]   - Field: ‘version’
[18:06:11.927]   - Field: ‘result’
[18:06:11.928]   - Field: ‘asynchronous’
[18:06:11.928]   - Field: ‘calls’
[18:06:11.928]   - Field: ‘globals’
[18:06:11.929]   - Field: ‘stdout’
[18:06:11.929]   - Field: ‘earlySignal’
[18:06:11.929]   - Field: ‘lazy’
[18:06:11.930]   - Field: ‘state’
[18:06:11.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:11.930] - Launch lazy future ...
[18:06:11.931] Packages needed by the future expression (n = 0): <none>
[18:06:11.932] Packages needed by future strategies (n = 0): <none>
[18:06:11.933] {
[18:06:11.933]     {
[18:06:11.933]         {
[18:06:11.933]             ...future.startTime <- base::Sys.time()
[18:06:11.933]             {
[18:06:11.933]                 {
[18:06:11.933]                   {
[18:06:11.933]                     {
[18:06:11.933]                       base::local({
[18:06:11.933]                         has_future <- base::requireNamespace("future", 
[18:06:11.933]                           quietly = TRUE)
[18:06:11.933]                         if (has_future) {
[18:06:11.933]                           ns <- base::getNamespace("future")
[18:06:11.933]                           version <- ns[[".package"]][["version"]]
[18:06:11.933]                           if (is.null(version)) 
[18:06:11.933]                             version <- utils::packageVersion("future")
[18:06:11.933]                         }
[18:06:11.933]                         else {
[18:06:11.933]                           version <- NULL
[18:06:11.933]                         }
[18:06:11.933]                         if (!has_future || version < "1.8.0") {
[18:06:11.933]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:11.933]                             "", base::R.version$version.string), 
[18:06:11.933]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:11.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:11.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:11.933]                               "release", "version")], collapse = " "), 
[18:06:11.933]                             hostname = base::Sys.info()[["nodename"]])
[18:06:11.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:11.933]                             info)
[18:06:11.933]                           info <- base::paste(info, collapse = "; ")
[18:06:11.933]                           if (!has_future) {
[18:06:11.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:11.933]                               info)
[18:06:11.933]                           }
[18:06:11.933]                           else {
[18:06:11.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:11.933]                               info, version)
[18:06:11.933]                           }
[18:06:11.933]                           base::stop(msg)
[18:06:11.933]                         }
[18:06:11.933]                       })
[18:06:11.933]                     }
[18:06:11.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:11.933]                     base::options(mc.cores = 1L)
[18:06:11.933]                   }
[18:06:11.933]                   ...future.strategy.old <- future::plan("list")
[18:06:11.933]                   options(future.plan = NULL)
[18:06:11.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:11.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:11.933]                 }
[18:06:11.933]                 ...future.workdir <- getwd()
[18:06:11.933]             }
[18:06:11.933]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:11.933]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:11.933]         }
[18:06:11.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:11.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:11.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:11.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:11.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:11.933]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:11.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:11.933]             base::names(...future.oldOptions))
[18:06:11.933]     }
[18:06:11.933]     if (FALSE) {
[18:06:11.933]     }
[18:06:11.933]     else {
[18:06:11.933]         if (TRUE) {
[18:06:11.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:11.933]                 open = "w")
[18:06:11.933]         }
[18:06:11.933]         else {
[18:06:11.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:11.933]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:11.933]         }
[18:06:11.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:11.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:11.933]             base::sink(type = "output", split = FALSE)
[18:06:11.933]             base::close(...future.stdout)
[18:06:11.933]         }, add = TRUE)
[18:06:11.933]     }
[18:06:11.933]     ...future.frame <- base::sys.nframe()
[18:06:11.933]     ...future.conditions <- base::list()
[18:06:11.933]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:11.933]     if (FALSE) {
[18:06:11.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:11.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:11.933]     }
[18:06:11.933]     ...future.result <- base::tryCatch({
[18:06:11.933]         base::withCallingHandlers({
[18:06:11.933]             ...future.value <- base::withVisible(base::local({
[18:06:11.933]                 ...future.makeSendCondition <- base::local({
[18:06:11.933]                   sendCondition <- NULL
[18:06:11.933]                   function(frame = 1L) {
[18:06:11.933]                     if (is.function(sendCondition)) 
[18:06:11.933]                       return(sendCondition)
[18:06:11.933]                     ns <- getNamespace("parallel")
[18:06:11.933]                     if (exists("sendData", mode = "function", 
[18:06:11.933]                       envir = ns)) {
[18:06:11.933]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:11.933]                         envir = ns)
[18:06:11.933]                       envir <- sys.frame(frame)
[18:06:11.933]                       master <- NULL
[18:06:11.933]                       while (!identical(envir, .GlobalEnv) && 
[18:06:11.933]                         !identical(envir, emptyenv())) {
[18:06:11.933]                         if (exists("master", mode = "list", envir = envir, 
[18:06:11.933]                           inherits = FALSE)) {
[18:06:11.933]                           master <- get("master", mode = "list", 
[18:06:11.933]                             envir = envir, inherits = FALSE)
[18:06:11.933]                           if (inherits(master, c("SOCKnode", 
[18:06:11.933]                             "SOCK0node"))) {
[18:06:11.933]                             sendCondition <<- function(cond) {
[18:06:11.933]                               data <- list(type = "VALUE", value = cond, 
[18:06:11.933]                                 success = TRUE)
[18:06:11.933]                               parallel_sendData(master, data)
[18:06:11.933]                             }
[18:06:11.933]                             return(sendCondition)
[18:06:11.933]                           }
[18:06:11.933]                         }
[18:06:11.933]                         frame <- frame + 1L
[18:06:11.933]                         envir <- sys.frame(frame)
[18:06:11.933]                       }
[18:06:11.933]                     }
[18:06:11.933]                     sendCondition <<- function(cond) NULL
[18:06:11.933]                   }
[18:06:11.933]                 })
[18:06:11.933]                 withCallingHandlers({
[18:06:11.933]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:11.933]                 }, immediateCondition = function(cond) {
[18:06:11.933]                   sendCondition <- ...future.makeSendCondition()
[18:06:11.933]                   sendCondition(cond)
[18:06:11.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:11.933]                   {
[18:06:11.933]                     inherits <- base::inherits
[18:06:11.933]                     invokeRestart <- base::invokeRestart
[18:06:11.933]                     is.null <- base::is.null
[18:06:11.933]                     muffled <- FALSE
[18:06:11.933]                     if (inherits(cond, "message")) {
[18:06:11.933]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:11.933]                       if (muffled) 
[18:06:11.933]                         invokeRestart("muffleMessage")
[18:06:11.933]                     }
[18:06:11.933]                     else if (inherits(cond, "warning")) {
[18:06:11.933]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:11.933]                       if (muffled) 
[18:06:11.933]                         invokeRestart("muffleWarning")
[18:06:11.933]                     }
[18:06:11.933]                     else if (inherits(cond, "condition")) {
[18:06:11.933]                       if (!is.null(pattern)) {
[18:06:11.933]                         computeRestarts <- base::computeRestarts
[18:06:11.933]                         grepl <- base::grepl
[18:06:11.933]                         restarts <- computeRestarts(cond)
[18:06:11.933]                         for (restart in restarts) {
[18:06:11.933]                           name <- restart$name
[18:06:11.933]                           if (is.null(name)) 
[18:06:11.933]                             next
[18:06:11.933]                           if (!grepl(pattern, name)) 
[18:06:11.933]                             next
[18:06:11.933]                           invokeRestart(restart)
[18:06:11.933]                           muffled <- TRUE
[18:06:11.933]                           break
[18:06:11.933]                         }
[18:06:11.933]                       }
[18:06:11.933]                     }
[18:06:11.933]                     invisible(muffled)
[18:06:11.933]                   }
[18:06:11.933]                   muffleCondition(cond)
[18:06:11.933]                 })
[18:06:11.933]             }))
[18:06:11.933]             future::FutureResult(value = ...future.value$value, 
[18:06:11.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:11.933]                   ...future.rng), globalenv = if (FALSE) 
[18:06:11.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:11.933]                     ...future.globalenv.names))
[18:06:11.933]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:11.933]         }, condition = base::local({
[18:06:11.933]             c <- base::c
[18:06:11.933]             inherits <- base::inherits
[18:06:11.933]             invokeRestart <- base::invokeRestart
[18:06:11.933]             length <- base::length
[18:06:11.933]             list <- base::list
[18:06:11.933]             seq.int <- base::seq.int
[18:06:11.933]             signalCondition <- base::signalCondition
[18:06:11.933]             sys.calls <- base::sys.calls
[18:06:11.933]             `[[` <- base::`[[`
[18:06:11.933]             `+` <- base::`+`
[18:06:11.933]             `<<-` <- base::`<<-`
[18:06:11.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:11.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:11.933]                   3L)]
[18:06:11.933]             }
[18:06:11.933]             function(cond) {
[18:06:11.933]                 is_error <- inherits(cond, "error")
[18:06:11.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:11.933]                   NULL)
[18:06:11.933]                 if (is_error) {
[18:06:11.933]                   sessionInformation <- function() {
[18:06:11.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:11.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:11.933]                       search = base::search(), system = base::Sys.info())
[18:06:11.933]                   }
[18:06:11.933]                   ...future.conditions[[length(...future.conditions) + 
[18:06:11.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:11.933]                     cond$call), session = sessionInformation(), 
[18:06:11.933]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:11.933]                   signalCondition(cond)
[18:06:11.933]                 }
[18:06:11.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:11.933]                 "immediateCondition"))) {
[18:06:11.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:11.933]                   ...future.conditions[[length(...future.conditions) + 
[18:06:11.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:11.933]                   if (TRUE && !signal) {
[18:06:11.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:11.933]                     {
[18:06:11.933]                       inherits <- base::inherits
[18:06:11.933]                       invokeRestart <- base::invokeRestart
[18:06:11.933]                       is.null <- base::is.null
[18:06:11.933]                       muffled <- FALSE
[18:06:11.933]                       if (inherits(cond, "message")) {
[18:06:11.933]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:11.933]                         if (muffled) 
[18:06:11.933]                           invokeRestart("muffleMessage")
[18:06:11.933]                       }
[18:06:11.933]                       else if (inherits(cond, "warning")) {
[18:06:11.933]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:11.933]                         if (muffled) 
[18:06:11.933]                           invokeRestart("muffleWarning")
[18:06:11.933]                       }
[18:06:11.933]                       else if (inherits(cond, "condition")) {
[18:06:11.933]                         if (!is.null(pattern)) {
[18:06:11.933]                           computeRestarts <- base::computeRestarts
[18:06:11.933]                           grepl <- base::grepl
[18:06:11.933]                           restarts <- computeRestarts(cond)
[18:06:11.933]                           for (restart in restarts) {
[18:06:11.933]                             name <- restart$name
[18:06:11.933]                             if (is.null(name)) 
[18:06:11.933]                               next
[18:06:11.933]                             if (!grepl(pattern, name)) 
[18:06:11.933]                               next
[18:06:11.933]                             invokeRestart(restart)
[18:06:11.933]                             muffled <- TRUE
[18:06:11.933]                             break
[18:06:11.933]                           }
[18:06:11.933]                         }
[18:06:11.933]                       }
[18:06:11.933]                       invisible(muffled)
[18:06:11.933]                     }
[18:06:11.933]                     muffleCondition(cond, pattern = "^muffle")
[18:06:11.933]                   }
[18:06:11.933]                 }
[18:06:11.933]                 else {
[18:06:11.933]                   if (TRUE) {
[18:06:11.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:11.933]                     {
[18:06:11.933]                       inherits <- base::inherits
[18:06:11.933]                       invokeRestart <- base::invokeRestart
[18:06:11.933]                       is.null <- base::is.null
[18:06:11.933]                       muffled <- FALSE
[18:06:11.933]                       if (inherits(cond, "message")) {
[18:06:11.933]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:11.933]                         if (muffled) 
[18:06:11.933]                           invokeRestart("muffleMessage")
[18:06:11.933]                       }
[18:06:11.933]                       else if (inherits(cond, "warning")) {
[18:06:11.933]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:11.933]                         if (muffled) 
[18:06:11.933]                           invokeRestart("muffleWarning")
[18:06:11.933]                       }
[18:06:11.933]                       else if (inherits(cond, "condition")) {
[18:06:11.933]                         if (!is.null(pattern)) {
[18:06:11.933]                           computeRestarts <- base::computeRestarts
[18:06:11.933]                           grepl <- base::grepl
[18:06:11.933]                           restarts <- computeRestarts(cond)
[18:06:11.933]                           for (restart in restarts) {
[18:06:11.933]                             name <- restart$name
[18:06:11.933]                             if (is.null(name)) 
[18:06:11.933]                               next
[18:06:11.933]                             if (!grepl(pattern, name)) 
[18:06:11.933]                               next
[18:06:11.933]                             invokeRestart(restart)
[18:06:11.933]                             muffled <- TRUE
[18:06:11.933]                             break
[18:06:11.933]                           }
[18:06:11.933]                         }
[18:06:11.933]                       }
[18:06:11.933]                       invisible(muffled)
[18:06:11.933]                     }
[18:06:11.933]                     muffleCondition(cond, pattern = "^muffle")
[18:06:11.933]                   }
[18:06:11.933]                 }
[18:06:11.933]             }
[18:06:11.933]         }))
[18:06:11.933]     }, error = function(ex) {
[18:06:11.933]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:11.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:11.933]                 ...future.rng), started = ...future.startTime, 
[18:06:11.933]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:11.933]             version = "1.8"), class = "FutureResult")
[18:06:11.933]     }, finally = {
[18:06:11.933]         if (!identical(...future.workdir, getwd())) 
[18:06:11.933]             setwd(...future.workdir)
[18:06:11.933]         {
[18:06:11.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:11.933]                 ...future.oldOptions$nwarnings <- NULL
[18:06:11.933]             }
[18:06:11.933]             base::options(...future.oldOptions)
[18:06:11.933]             if (.Platform$OS.type == "windows") {
[18:06:11.933]                 old_names <- names(...future.oldEnvVars)
[18:06:11.933]                 envs <- base::Sys.getenv()
[18:06:11.933]                 names <- names(envs)
[18:06:11.933]                 common <- intersect(names, old_names)
[18:06:11.933]                 added <- setdiff(names, old_names)
[18:06:11.933]                 removed <- setdiff(old_names, names)
[18:06:11.933]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:11.933]                   envs[common]]
[18:06:11.933]                 NAMES <- toupper(changed)
[18:06:11.933]                 args <- list()
[18:06:11.933]                 for (kk in seq_along(NAMES)) {
[18:06:11.933]                   name <- changed[[kk]]
[18:06:11.933]                   NAME <- NAMES[[kk]]
[18:06:11.933]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:11.933]                     next
[18:06:11.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:11.933]                 }
[18:06:11.933]                 NAMES <- toupper(added)
[18:06:11.933]                 for (kk in seq_along(NAMES)) {
[18:06:11.933]                   name <- added[[kk]]
[18:06:11.933]                   NAME <- NAMES[[kk]]
[18:06:11.933]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:11.933]                     next
[18:06:11.933]                   args[[name]] <- ""
[18:06:11.933]                 }
[18:06:11.933]                 NAMES <- toupper(removed)
[18:06:11.933]                 for (kk in seq_along(NAMES)) {
[18:06:11.933]                   name <- removed[[kk]]
[18:06:11.933]                   NAME <- NAMES[[kk]]
[18:06:11.933]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:11.933]                     next
[18:06:11.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:11.933]                 }
[18:06:11.933]                 if (length(args) > 0) 
[18:06:11.933]                   base::do.call(base::Sys.setenv, args = args)
[18:06:11.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:11.933]             }
[18:06:11.933]             else {
[18:06:11.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:11.933]             }
[18:06:11.933]             {
[18:06:11.933]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:11.933]                   0L) {
[18:06:11.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:11.933]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:11.933]                   base::options(opts)
[18:06:11.933]                 }
[18:06:11.933]                 {
[18:06:11.933]                   {
[18:06:11.933]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:11.933]                     NULL
[18:06:11.933]                   }
[18:06:11.933]                   options(future.plan = NULL)
[18:06:11.933]                   if (is.na(NA_character_)) 
[18:06:11.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:11.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:11.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:11.933]                     .init = FALSE)
[18:06:11.933]                 }
[18:06:11.933]             }
[18:06:11.933]         }
[18:06:11.933]     })
[18:06:11.933]     if (TRUE) {
[18:06:11.933]         base::sink(type = "output", split = FALSE)
[18:06:11.933]         if (TRUE) {
[18:06:11.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:11.933]         }
[18:06:11.933]         else {
[18:06:11.933]             ...future.result["stdout"] <- base::list(NULL)
[18:06:11.933]         }
[18:06:11.933]         base::close(...future.stdout)
[18:06:11.933]         ...future.stdout <- NULL
[18:06:11.933]     }
[18:06:11.933]     ...future.result$conditions <- ...future.conditions
[18:06:11.933]     ...future.result$finished <- base::Sys.time()
[18:06:11.933]     ...future.result
[18:06:11.933] }
[18:06:11.940] MultisessionFuture started
[18:06:11.940] - Launch lazy future ... done
[18:06:11.940] run() for ‘MultisessionFuture’ ... done
[18:06:11.985] receiveMessageFromWorker() for ClusterFuture ...
[18:06:11.986] - Validating connection of MultisessionFuture
[18:06:11.987] - received message: FutureResult
[18:06:11.988] - Received FutureResult
[18:06:11.988] - Erased future from FutureRegistry
[18:06:11.988] result() for ClusterFuture ...
[18:06:11.989] - result already collected: FutureResult
[18:06:11.989] result() for ClusterFuture ... done
[18:06:11.989] signalConditions() ...
[18:06:11.989]  - include = ‘immediateCondition’
[18:06:11.990]  - exclude = 
[18:06:11.990]  - resignal = FALSE
[18:06:11.990]  - Number of conditions: 1
[18:06:11.991] signalConditions() ... done
[18:06:11.991] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:11.991] A MultisessionFuture was resolved (result was not collected)
[18:06:11.992] getGlobalsAndPackages() ...
[18:06:11.992] Searching for globals...
[18:06:11.994] - globals found: [2] ‘list’, ‘stop’
[18:06:11.994] Searching for globals ... DONE
[18:06:11.995] Resolving globals: FALSE
[18:06:11.996] 
[18:06:11.996] 
[18:06:11.996] getGlobalsAndPackages() ... DONE
[18:06:11.997] run() for ‘Future’ ...
[18:06:11.997] - state: ‘created’
[18:06:11.998] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:12.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:12.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:12.033]   - Field: ‘node’
[18:06:12.033]   - Field: ‘label’
[18:06:12.033]   - Field: ‘local’
[18:06:12.034]   - Field: ‘owner’
[18:06:12.034]   - Field: ‘envir’
[18:06:12.034]   - Field: ‘workers’
[18:06:12.034]   - Field: ‘packages’
[18:06:12.035]   - Field: ‘gc’
[18:06:12.035]   - Field: ‘conditions’
[18:06:12.035]   - Field: ‘persistent’
[18:06:12.035]   - Field: ‘expr’
[18:06:12.036]   - Field: ‘uuid’
[18:06:12.036]   - Field: ‘seed’
[18:06:12.036]   - Field: ‘version’
[18:06:12.036]   - Field: ‘result’
[18:06:12.037]   - Field: ‘asynchronous’
[18:06:12.037]   - Field: ‘calls’
[18:06:12.037]   - Field: ‘globals’
[18:06:12.037]   - Field: ‘stdout’
[18:06:12.038]   - Field: ‘earlySignal’
[18:06:12.038]   - Field: ‘lazy’
[18:06:12.038]   - Field: ‘state’
[18:06:12.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:12.039] - Launch lazy future ...
[18:06:12.039] Packages needed by the future expression (n = 0): <none>
[18:06:12.040] Packages needed by future strategies (n = 0): <none>
[18:06:12.041] {
[18:06:12.041]     {
[18:06:12.041]         {
[18:06:12.041]             ...future.startTime <- base::Sys.time()
[18:06:12.041]             {
[18:06:12.041]                 {
[18:06:12.041]                   {
[18:06:12.041]                     {
[18:06:12.041]                       base::local({
[18:06:12.041]                         has_future <- base::requireNamespace("future", 
[18:06:12.041]                           quietly = TRUE)
[18:06:12.041]                         if (has_future) {
[18:06:12.041]                           ns <- base::getNamespace("future")
[18:06:12.041]                           version <- ns[[".package"]][["version"]]
[18:06:12.041]                           if (is.null(version)) 
[18:06:12.041]                             version <- utils::packageVersion("future")
[18:06:12.041]                         }
[18:06:12.041]                         else {
[18:06:12.041]                           version <- NULL
[18:06:12.041]                         }
[18:06:12.041]                         if (!has_future || version < "1.8.0") {
[18:06:12.041]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:12.041]                             "", base::R.version$version.string), 
[18:06:12.041]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:12.041]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:12.041]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:12.041]                               "release", "version")], collapse = " "), 
[18:06:12.041]                             hostname = base::Sys.info()[["nodename"]])
[18:06:12.041]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:12.041]                             info)
[18:06:12.041]                           info <- base::paste(info, collapse = "; ")
[18:06:12.041]                           if (!has_future) {
[18:06:12.041]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:12.041]                               info)
[18:06:12.041]                           }
[18:06:12.041]                           else {
[18:06:12.041]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:12.041]                               info, version)
[18:06:12.041]                           }
[18:06:12.041]                           base::stop(msg)
[18:06:12.041]                         }
[18:06:12.041]                       })
[18:06:12.041]                     }
[18:06:12.041]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:12.041]                     base::options(mc.cores = 1L)
[18:06:12.041]                   }
[18:06:12.041]                   ...future.strategy.old <- future::plan("list")
[18:06:12.041]                   options(future.plan = NULL)
[18:06:12.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:12.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:12.041]                 }
[18:06:12.041]                 ...future.workdir <- getwd()
[18:06:12.041]             }
[18:06:12.041]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:12.041]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:12.041]         }
[18:06:12.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:12.041]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:12.041]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:12.041]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:12.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:12.041]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:12.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:12.041]             base::names(...future.oldOptions))
[18:06:12.041]     }
[18:06:12.041]     if (FALSE) {
[18:06:12.041]     }
[18:06:12.041]     else {
[18:06:12.041]         if (TRUE) {
[18:06:12.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:12.041]                 open = "w")
[18:06:12.041]         }
[18:06:12.041]         else {
[18:06:12.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:12.041]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:12.041]         }
[18:06:12.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:12.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:12.041]             base::sink(type = "output", split = FALSE)
[18:06:12.041]             base::close(...future.stdout)
[18:06:12.041]         }, add = TRUE)
[18:06:12.041]     }
[18:06:12.041]     ...future.frame <- base::sys.nframe()
[18:06:12.041]     ...future.conditions <- base::list()
[18:06:12.041]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:12.041]     if (FALSE) {
[18:06:12.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:12.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:12.041]     }
[18:06:12.041]     ...future.result <- base::tryCatch({
[18:06:12.041]         base::withCallingHandlers({
[18:06:12.041]             ...future.value <- base::withVisible(base::local({
[18:06:12.041]                 ...future.makeSendCondition <- base::local({
[18:06:12.041]                   sendCondition <- NULL
[18:06:12.041]                   function(frame = 1L) {
[18:06:12.041]                     if (is.function(sendCondition)) 
[18:06:12.041]                       return(sendCondition)
[18:06:12.041]                     ns <- getNamespace("parallel")
[18:06:12.041]                     if (exists("sendData", mode = "function", 
[18:06:12.041]                       envir = ns)) {
[18:06:12.041]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:12.041]                         envir = ns)
[18:06:12.041]                       envir <- sys.frame(frame)
[18:06:12.041]                       master <- NULL
[18:06:12.041]                       while (!identical(envir, .GlobalEnv) && 
[18:06:12.041]                         !identical(envir, emptyenv())) {
[18:06:12.041]                         if (exists("master", mode = "list", envir = envir, 
[18:06:12.041]                           inherits = FALSE)) {
[18:06:12.041]                           master <- get("master", mode = "list", 
[18:06:12.041]                             envir = envir, inherits = FALSE)
[18:06:12.041]                           if (inherits(master, c("SOCKnode", 
[18:06:12.041]                             "SOCK0node"))) {
[18:06:12.041]                             sendCondition <<- function(cond) {
[18:06:12.041]                               data <- list(type = "VALUE", value = cond, 
[18:06:12.041]                                 success = TRUE)
[18:06:12.041]                               parallel_sendData(master, data)
[18:06:12.041]                             }
[18:06:12.041]                             return(sendCondition)
[18:06:12.041]                           }
[18:06:12.041]                         }
[18:06:12.041]                         frame <- frame + 1L
[18:06:12.041]                         envir <- sys.frame(frame)
[18:06:12.041]                       }
[18:06:12.041]                     }
[18:06:12.041]                     sendCondition <<- function(cond) NULL
[18:06:12.041]                   }
[18:06:12.041]                 })
[18:06:12.041]                 withCallingHandlers({
[18:06:12.041]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:12.041]                 }, immediateCondition = function(cond) {
[18:06:12.041]                   sendCondition <- ...future.makeSendCondition()
[18:06:12.041]                   sendCondition(cond)
[18:06:12.041]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.041]                   {
[18:06:12.041]                     inherits <- base::inherits
[18:06:12.041]                     invokeRestart <- base::invokeRestart
[18:06:12.041]                     is.null <- base::is.null
[18:06:12.041]                     muffled <- FALSE
[18:06:12.041]                     if (inherits(cond, "message")) {
[18:06:12.041]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:12.041]                       if (muffled) 
[18:06:12.041]                         invokeRestart("muffleMessage")
[18:06:12.041]                     }
[18:06:12.041]                     else if (inherits(cond, "warning")) {
[18:06:12.041]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:12.041]                       if (muffled) 
[18:06:12.041]                         invokeRestart("muffleWarning")
[18:06:12.041]                     }
[18:06:12.041]                     else if (inherits(cond, "condition")) {
[18:06:12.041]                       if (!is.null(pattern)) {
[18:06:12.041]                         computeRestarts <- base::computeRestarts
[18:06:12.041]                         grepl <- base::grepl
[18:06:12.041]                         restarts <- computeRestarts(cond)
[18:06:12.041]                         for (restart in restarts) {
[18:06:12.041]                           name <- restart$name
[18:06:12.041]                           if (is.null(name)) 
[18:06:12.041]                             next
[18:06:12.041]                           if (!grepl(pattern, name)) 
[18:06:12.041]                             next
[18:06:12.041]                           invokeRestart(restart)
[18:06:12.041]                           muffled <- TRUE
[18:06:12.041]                           break
[18:06:12.041]                         }
[18:06:12.041]                       }
[18:06:12.041]                     }
[18:06:12.041]                     invisible(muffled)
[18:06:12.041]                   }
[18:06:12.041]                   muffleCondition(cond)
[18:06:12.041]                 })
[18:06:12.041]             }))
[18:06:12.041]             future::FutureResult(value = ...future.value$value, 
[18:06:12.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:12.041]                   ...future.rng), globalenv = if (FALSE) 
[18:06:12.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:12.041]                     ...future.globalenv.names))
[18:06:12.041]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:12.041]         }, condition = base::local({
[18:06:12.041]             c <- base::c
[18:06:12.041]             inherits <- base::inherits
[18:06:12.041]             invokeRestart <- base::invokeRestart
[18:06:12.041]             length <- base::length
[18:06:12.041]             list <- base::list
[18:06:12.041]             seq.int <- base::seq.int
[18:06:12.041]             signalCondition <- base::signalCondition
[18:06:12.041]             sys.calls <- base::sys.calls
[18:06:12.041]             `[[` <- base::`[[`
[18:06:12.041]             `+` <- base::`+`
[18:06:12.041]             `<<-` <- base::`<<-`
[18:06:12.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:12.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:12.041]                   3L)]
[18:06:12.041]             }
[18:06:12.041]             function(cond) {
[18:06:12.041]                 is_error <- inherits(cond, "error")
[18:06:12.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:12.041]                   NULL)
[18:06:12.041]                 if (is_error) {
[18:06:12.041]                   sessionInformation <- function() {
[18:06:12.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:12.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:12.041]                       search = base::search(), system = base::Sys.info())
[18:06:12.041]                   }
[18:06:12.041]                   ...future.conditions[[length(...future.conditions) + 
[18:06:12.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:12.041]                     cond$call), session = sessionInformation(), 
[18:06:12.041]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:12.041]                   signalCondition(cond)
[18:06:12.041]                 }
[18:06:12.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:12.041]                 "immediateCondition"))) {
[18:06:12.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:12.041]                   ...future.conditions[[length(...future.conditions) + 
[18:06:12.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:12.041]                   if (TRUE && !signal) {
[18:06:12.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.041]                     {
[18:06:12.041]                       inherits <- base::inherits
[18:06:12.041]                       invokeRestart <- base::invokeRestart
[18:06:12.041]                       is.null <- base::is.null
[18:06:12.041]                       muffled <- FALSE
[18:06:12.041]                       if (inherits(cond, "message")) {
[18:06:12.041]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:12.041]                         if (muffled) 
[18:06:12.041]                           invokeRestart("muffleMessage")
[18:06:12.041]                       }
[18:06:12.041]                       else if (inherits(cond, "warning")) {
[18:06:12.041]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:12.041]                         if (muffled) 
[18:06:12.041]                           invokeRestart("muffleWarning")
[18:06:12.041]                       }
[18:06:12.041]                       else if (inherits(cond, "condition")) {
[18:06:12.041]                         if (!is.null(pattern)) {
[18:06:12.041]                           computeRestarts <- base::computeRestarts
[18:06:12.041]                           grepl <- base::grepl
[18:06:12.041]                           restarts <- computeRestarts(cond)
[18:06:12.041]                           for (restart in restarts) {
[18:06:12.041]                             name <- restart$name
[18:06:12.041]                             if (is.null(name)) 
[18:06:12.041]                               next
[18:06:12.041]                             if (!grepl(pattern, name)) 
[18:06:12.041]                               next
[18:06:12.041]                             invokeRestart(restart)
[18:06:12.041]                             muffled <- TRUE
[18:06:12.041]                             break
[18:06:12.041]                           }
[18:06:12.041]                         }
[18:06:12.041]                       }
[18:06:12.041]                       invisible(muffled)
[18:06:12.041]                     }
[18:06:12.041]                     muffleCondition(cond, pattern = "^muffle")
[18:06:12.041]                   }
[18:06:12.041]                 }
[18:06:12.041]                 else {
[18:06:12.041]                   if (TRUE) {
[18:06:12.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.041]                     {
[18:06:12.041]                       inherits <- base::inherits
[18:06:12.041]                       invokeRestart <- base::invokeRestart
[18:06:12.041]                       is.null <- base::is.null
[18:06:12.041]                       muffled <- FALSE
[18:06:12.041]                       if (inherits(cond, "message")) {
[18:06:12.041]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:12.041]                         if (muffled) 
[18:06:12.041]                           invokeRestart("muffleMessage")
[18:06:12.041]                       }
[18:06:12.041]                       else if (inherits(cond, "warning")) {
[18:06:12.041]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:12.041]                         if (muffled) 
[18:06:12.041]                           invokeRestart("muffleWarning")
[18:06:12.041]                       }
[18:06:12.041]                       else if (inherits(cond, "condition")) {
[18:06:12.041]                         if (!is.null(pattern)) {
[18:06:12.041]                           computeRestarts <- base::computeRestarts
[18:06:12.041]                           grepl <- base::grepl
[18:06:12.041]                           restarts <- computeRestarts(cond)
[18:06:12.041]                           for (restart in restarts) {
[18:06:12.041]                             name <- restart$name
[18:06:12.041]                             if (is.null(name)) 
[18:06:12.041]                               next
[18:06:12.041]                             if (!grepl(pattern, name)) 
[18:06:12.041]                               next
[18:06:12.041]                             invokeRestart(restart)
[18:06:12.041]                             muffled <- TRUE
[18:06:12.041]                             break
[18:06:12.041]                           }
[18:06:12.041]                         }
[18:06:12.041]                       }
[18:06:12.041]                       invisible(muffled)
[18:06:12.041]                     }
[18:06:12.041]                     muffleCondition(cond, pattern = "^muffle")
[18:06:12.041]                   }
[18:06:12.041]                 }
[18:06:12.041]             }
[18:06:12.041]         }))
[18:06:12.041]     }, error = function(ex) {
[18:06:12.041]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:12.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:12.041]                 ...future.rng), started = ...future.startTime, 
[18:06:12.041]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:12.041]             version = "1.8"), class = "FutureResult")
[18:06:12.041]     }, finally = {
[18:06:12.041]         if (!identical(...future.workdir, getwd())) 
[18:06:12.041]             setwd(...future.workdir)
[18:06:12.041]         {
[18:06:12.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:12.041]                 ...future.oldOptions$nwarnings <- NULL
[18:06:12.041]             }
[18:06:12.041]             base::options(...future.oldOptions)
[18:06:12.041]             if (.Platform$OS.type == "windows") {
[18:06:12.041]                 old_names <- names(...future.oldEnvVars)
[18:06:12.041]                 envs <- base::Sys.getenv()
[18:06:12.041]                 names <- names(envs)
[18:06:12.041]                 common <- intersect(names, old_names)
[18:06:12.041]                 added <- setdiff(names, old_names)
[18:06:12.041]                 removed <- setdiff(old_names, names)
[18:06:12.041]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:12.041]                   envs[common]]
[18:06:12.041]                 NAMES <- toupper(changed)
[18:06:12.041]                 args <- list()
[18:06:12.041]                 for (kk in seq_along(NAMES)) {
[18:06:12.041]                   name <- changed[[kk]]
[18:06:12.041]                   NAME <- NAMES[[kk]]
[18:06:12.041]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.041]                     next
[18:06:12.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:12.041]                 }
[18:06:12.041]                 NAMES <- toupper(added)
[18:06:12.041]                 for (kk in seq_along(NAMES)) {
[18:06:12.041]                   name <- added[[kk]]
[18:06:12.041]                   NAME <- NAMES[[kk]]
[18:06:12.041]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.041]                     next
[18:06:12.041]                   args[[name]] <- ""
[18:06:12.041]                 }
[18:06:12.041]                 NAMES <- toupper(removed)
[18:06:12.041]                 for (kk in seq_along(NAMES)) {
[18:06:12.041]                   name <- removed[[kk]]
[18:06:12.041]                   NAME <- NAMES[[kk]]
[18:06:12.041]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.041]                     next
[18:06:12.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:12.041]                 }
[18:06:12.041]                 if (length(args) > 0) 
[18:06:12.041]                   base::do.call(base::Sys.setenv, args = args)
[18:06:12.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:12.041]             }
[18:06:12.041]             else {
[18:06:12.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:12.041]             }
[18:06:12.041]             {
[18:06:12.041]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:12.041]                   0L) {
[18:06:12.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:12.041]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:12.041]                   base::options(opts)
[18:06:12.041]                 }
[18:06:12.041]                 {
[18:06:12.041]                   {
[18:06:12.041]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:12.041]                     NULL
[18:06:12.041]                   }
[18:06:12.041]                   options(future.plan = NULL)
[18:06:12.041]                   if (is.na(NA_character_)) 
[18:06:12.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:12.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:12.041]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:12.041]                     .init = FALSE)
[18:06:12.041]                 }
[18:06:12.041]             }
[18:06:12.041]         }
[18:06:12.041]     })
[18:06:12.041]     if (TRUE) {
[18:06:12.041]         base::sink(type = "output", split = FALSE)
[18:06:12.041]         if (TRUE) {
[18:06:12.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:12.041]         }
[18:06:12.041]         else {
[18:06:12.041]             ...future.result["stdout"] <- base::list(NULL)
[18:06:12.041]         }
[18:06:12.041]         base::close(...future.stdout)
[18:06:12.041]         ...future.stdout <- NULL
[18:06:12.041]     }
[18:06:12.041]     ...future.result$conditions <- ...future.conditions
[18:06:12.041]     ...future.result$finished <- base::Sys.time()
[18:06:12.041]     ...future.result
[18:06:12.041] }
[18:06:12.047] MultisessionFuture started
[18:06:12.048] - Launch lazy future ... done
[18:06:12.048] run() for ‘MultisessionFuture’ ... done
[18:06:12.094] receiveMessageFromWorker() for ClusterFuture ...
[18:06:12.094] - Validating connection of MultisessionFuture
[18:06:12.095] - received message: FutureResult
[18:06:12.097] - Received FutureResult
[18:06:12.097] - Erased future from FutureRegistry
[18:06:12.098] result() for ClusterFuture ...
[18:06:12.098] - result already collected: FutureResult
[18:06:12.098] result() for ClusterFuture ... done
[18:06:12.098] signalConditions() ...
[18:06:12.098]  - include = ‘immediateCondition’
[18:06:12.099]  - exclude = 
[18:06:12.099]  - resignal = FALSE
[18:06:12.099]  - Number of conditions: 1
[18:06:12.099] signalConditions() ... done
[18:06:12.099] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:12.100] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[18:06:12.100] getGlobalsAndPackages() ...
[18:06:12.100] Searching for globals...
[18:06:12.103] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:12.103] Searching for globals ... DONE
[18:06:12.103] Resolving globals: FALSE
[18:06:12.104] 
[18:06:12.104] 
[18:06:12.105] getGlobalsAndPackages() ... DONE
[18:06:12.105] run() for ‘Future’ ...
[18:06:12.106] - state: ‘created’
[18:06:12.106] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:12.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:12.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:12.134]   - Field: ‘node’
[18:06:12.134]   - Field: ‘label’
[18:06:12.134]   - Field: ‘local’
[18:06:12.134]   - Field: ‘owner’
[18:06:12.134]   - Field: ‘envir’
[18:06:12.135]   - Field: ‘workers’
[18:06:12.135]   - Field: ‘packages’
[18:06:12.135]   - Field: ‘gc’
[18:06:12.135]   - Field: ‘conditions’
[18:06:12.135]   - Field: ‘persistent’
[18:06:12.136]   - Field: ‘expr’
[18:06:12.136]   - Field: ‘uuid’
[18:06:12.136]   - Field: ‘seed’
[18:06:12.136]   - Field: ‘version’
[18:06:12.136]   - Field: ‘result’
[18:06:12.137]   - Field: ‘asynchronous’
[18:06:12.137]   - Field: ‘calls’
[18:06:12.137]   - Field: ‘globals’
[18:06:12.137]   - Field: ‘stdout’
[18:06:12.137]   - Field: ‘earlySignal’
[18:06:12.138]   - Field: ‘lazy’
[18:06:12.138]   - Field: ‘state’
[18:06:12.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:12.138] - Launch lazy future ...
[18:06:12.139] Packages needed by the future expression (n = 0): <none>
[18:06:12.139] Packages needed by future strategies (n = 0): <none>
[18:06:12.140] {
[18:06:12.140]     {
[18:06:12.140]         {
[18:06:12.140]             ...future.startTime <- base::Sys.time()
[18:06:12.140]             {
[18:06:12.140]                 {
[18:06:12.140]                   {
[18:06:12.140]                     {
[18:06:12.140]                       base::local({
[18:06:12.140]                         has_future <- base::requireNamespace("future", 
[18:06:12.140]                           quietly = TRUE)
[18:06:12.140]                         if (has_future) {
[18:06:12.140]                           ns <- base::getNamespace("future")
[18:06:12.140]                           version <- ns[[".package"]][["version"]]
[18:06:12.140]                           if (is.null(version)) 
[18:06:12.140]                             version <- utils::packageVersion("future")
[18:06:12.140]                         }
[18:06:12.140]                         else {
[18:06:12.140]                           version <- NULL
[18:06:12.140]                         }
[18:06:12.140]                         if (!has_future || version < "1.8.0") {
[18:06:12.140]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:12.140]                             "", base::R.version$version.string), 
[18:06:12.140]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:12.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:12.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:12.140]                               "release", "version")], collapse = " "), 
[18:06:12.140]                             hostname = base::Sys.info()[["nodename"]])
[18:06:12.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:12.140]                             info)
[18:06:12.140]                           info <- base::paste(info, collapse = "; ")
[18:06:12.140]                           if (!has_future) {
[18:06:12.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:12.140]                               info)
[18:06:12.140]                           }
[18:06:12.140]                           else {
[18:06:12.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:12.140]                               info, version)
[18:06:12.140]                           }
[18:06:12.140]                           base::stop(msg)
[18:06:12.140]                         }
[18:06:12.140]                       })
[18:06:12.140]                     }
[18:06:12.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:12.140]                     base::options(mc.cores = 1L)
[18:06:12.140]                   }
[18:06:12.140]                   ...future.strategy.old <- future::plan("list")
[18:06:12.140]                   options(future.plan = NULL)
[18:06:12.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:12.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:12.140]                 }
[18:06:12.140]                 ...future.workdir <- getwd()
[18:06:12.140]             }
[18:06:12.140]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:12.140]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:12.140]         }
[18:06:12.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:12.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:12.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:12.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:12.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:12.140]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:12.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:12.140]             base::names(...future.oldOptions))
[18:06:12.140]     }
[18:06:12.140]     if (FALSE) {
[18:06:12.140]     }
[18:06:12.140]     else {
[18:06:12.140]         if (TRUE) {
[18:06:12.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:12.140]                 open = "w")
[18:06:12.140]         }
[18:06:12.140]         else {
[18:06:12.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:12.140]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:12.140]         }
[18:06:12.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:12.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:12.140]             base::sink(type = "output", split = FALSE)
[18:06:12.140]             base::close(...future.stdout)
[18:06:12.140]         }, add = TRUE)
[18:06:12.140]     }
[18:06:12.140]     ...future.frame <- base::sys.nframe()
[18:06:12.140]     ...future.conditions <- base::list()
[18:06:12.140]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:12.140]     if (FALSE) {
[18:06:12.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:12.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:12.140]     }
[18:06:12.140]     ...future.result <- base::tryCatch({
[18:06:12.140]         base::withCallingHandlers({
[18:06:12.140]             ...future.value <- base::withVisible(base::local({
[18:06:12.140]                 ...future.makeSendCondition <- base::local({
[18:06:12.140]                   sendCondition <- NULL
[18:06:12.140]                   function(frame = 1L) {
[18:06:12.140]                     if (is.function(sendCondition)) 
[18:06:12.140]                       return(sendCondition)
[18:06:12.140]                     ns <- getNamespace("parallel")
[18:06:12.140]                     if (exists("sendData", mode = "function", 
[18:06:12.140]                       envir = ns)) {
[18:06:12.140]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:12.140]                         envir = ns)
[18:06:12.140]                       envir <- sys.frame(frame)
[18:06:12.140]                       master <- NULL
[18:06:12.140]                       while (!identical(envir, .GlobalEnv) && 
[18:06:12.140]                         !identical(envir, emptyenv())) {
[18:06:12.140]                         if (exists("master", mode = "list", envir = envir, 
[18:06:12.140]                           inherits = FALSE)) {
[18:06:12.140]                           master <- get("master", mode = "list", 
[18:06:12.140]                             envir = envir, inherits = FALSE)
[18:06:12.140]                           if (inherits(master, c("SOCKnode", 
[18:06:12.140]                             "SOCK0node"))) {
[18:06:12.140]                             sendCondition <<- function(cond) {
[18:06:12.140]                               data <- list(type = "VALUE", value = cond, 
[18:06:12.140]                                 success = TRUE)
[18:06:12.140]                               parallel_sendData(master, data)
[18:06:12.140]                             }
[18:06:12.140]                             return(sendCondition)
[18:06:12.140]                           }
[18:06:12.140]                         }
[18:06:12.140]                         frame <- frame + 1L
[18:06:12.140]                         envir <- sys.frame(frame)
[18:06:12.140]                       }
[18:06:12.140]                     }
[18:06:12.140]                     sendCondition <<- function(cond) NULL
[18:06:12.140]                   }
[18:06:12.140]                 })
[18:06:12.140]                 withCallingHandlers({
[18:06:12.140]                   {
[18:06:12.140]                     Sys.sleep(0.5)
[18:06:12.140]                     list(a = 1, b = 42L)
[18:06:12.140]                   }
[18:06:12.140]                 }, immediateCondition = function(cond) {
[18:06:12.140]                   sendCondition <- ...future.makeSendCondition()
[18:06:12.140]                   sendCondition(cond)
[18:06:12.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.140]                   {
[18:06:12.140]                     inherits <- base::inherits
[18:06:12.140]                     invokeRestart <- base::invokeRestart
[18:06:12.140]                     is.null <- base::is.null
[18:06:12.140]                     muffled <- FALSE
[18:06:12.140]                     if (inherits(cond, "message")) {
[18:06:12.140]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:12.140]                       if (muffled) 
[18:06:12.140]                         invokeRestart("muffleMessage")
[18:06:12.140]                     }
[18:06:12.140]                     else if (inherits(cond, "warning")) {
[18:06:12.140]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:12.140]                       if (muffled) 
[18:06:12.140]                         invokeRestart("muffleWarning")
[18:06:12.140]                     }
[18:06:12.140]                     else if (inherits(cond, "condition")) {
[18:06:12.140]                       if (!is.null(pattern)) {
[18:06:12.140]                         computeRestarts <- base::computeRestarts
[18:06:12.140]                         grepl <- base::grepl
[18:06:12.140]                         restarts <- computeRestarts(cond)
[18:06:12.140]                         for (restart in restarts) {
[18:06:12.140]                           name <- restart$name
[18:06:12.140]                           if (is.null(name)) 
[18:06:12.140]                             next
[18:06:12.140]                           if (!grepl(pattern, name)) 
[18:06:12.140]                             next
[18:06:12.140]                           invokeRestart(restart)
[18:06:12.140]                           muffled <- TRUE
[18:06:12.140]                           break
[18:06:12.140]                         }
[18:06:12.140]                       }
[18:06:12.140]                     }
[18:06:12.140]                     invisible(muffled)
[18:06:12.140]                   }
[18:06:12.140]                   muffleCondition(cond)
[18:06:12.140]                 })
[18:06:12.140]             }))
[18:06:12.140]             future::FutureResult(value = ...future.value$value, 
[18:06:12.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:12.140]                   ...future.rng), globalenv = if (FALSE) 
[18:06:12.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:12.140]                     ...future.globalenv.names))
[18:06:12.140]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:12.140]         }, condition = base::local({
[18:06:12.140]             c <- base::c
[18:06:12.140]             inherits <- base::inherits
[18:06:12.140]             invokeRestart <- base::invokeRestart
[18:06:12.140]             length <- base::length
[18:06:12.140]             list <- base::list
[18:06:12.140]             seq.int <- base::seq.int
[18:06:12.140]             signalCondition <- base::signalCondition
[18:06:12.140]             sys.calls <- base::sys.calls
[18:06:12.140]             `[[` <- base::`[[`
[18:06:12.140]             `+` <- base::`+`
[18:06:12.140]             `<<-` <- base::`<<-`
[18:06:12.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:12.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:12.140]                   3L)]
[18:06:12.140]             }
[18:06:12.140]             function(cond) {
[18:06:12.140]                 is_error <- inherits(cond, "error")
[18:06:12.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:12.140]                   NULL)
[18:06:12.140]                 if (is_error) {
[18:06:12.140]                   sessionInformation <- function() {
[18:06:12.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:12.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:12.140]                       search = base::search(), system = base::Sys.info())
[18:06:12.140]                   }
[18:06:12.140]                   ...future.conditions[[length(...future.conditions) + 
[18:06:12.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:12.140]                     cond$call), session = sessionInformation(), 
[18:06:12.140]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:12.140]                   signalCondition(cond)
[18:06:12.140]                 }
[18:06:12.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:12.140]                 "immediateCondition"))) {
[18:06:12.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:12.140]                   ...future.conditions[[length(...future.conditions) + 
[18:06:12.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:12.140]                   if (TRUE && !signal) {
[18:06:12.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.140]                     {
[18:06:12.140]                       inherits <- base::inherits
[18:06:12.140]                       invokeRestart <- base::invokeRestart
[18:06:12.140]                       is.null <- base::is.null
[18:06:12.140]                       muffled <- FALSE
[18:06:12.140]                       if (inherits(cond, "message")) {
[18:06:12.140]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:12.140]                         if (muffled) 
[18:06:12.140]                           invokeRestart("muffleMessage")
[18:06:12.140]                       }
[18:06:12.140]                       else if (inherits(cond, "warning")) {
[18:06:12.140]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:12.140]                         if (muffled) 
[18:06:12.140]                           invokeRestart("muffleWarning")
[18:06:12.140]                       }
[18:06:12.140]                       else if (inherits(cond, "condition")) {
[18:06:12.140]                         if (!is.null(pattern)) {
[18:06:12.140]                           computeRestarts <- base::computeRestarts
[18:06:12.140]                           grepl <- base::grepl
[18:06:12.140]                           restarts <- computeRestarts(cond)
[18:06:12.140]                           for (restart in restarts) {
[18:06:12.140]                             name <- restart$name
[18:06:12.140]                             if (is.null(name)) 
[18:06:12.140]                               next
[18:06:12.140]                             if (!grepl(pattern, name)) 
[18:06:12.140]                               next
[18:06:12.140]                             invokeRestart(restart)
[18:06:12.140]                             muffled <- TRUE
[18:06:12.140]                             break
[18:06:12.140]                           }
[18:06:12.140]                         }
[18:06:12.140]                       }
[18:06:12.140]                       invisible(muffled)
[18:06:12.140]                     }
[18:06:12.140]                     muffleCondition(cond, pattern = "^muffle")
[18:06:12.140]                   }
[18:06:12.140]                 }
[18:06:12.140]                 else {
[18:06:12.140]                   if (TRUE) {
[18:06:12.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.140]                     {
[18:06:12.140]                       inherits <- base::inherits
[18:06:12.140]                       invokeRestart <- base::invokeRestart
[18:06:12.140]                       is.null <- base::is.null
[18:06:12.140]                       muffled <- FALSE
[18:06:12.140]                       if (inherits(cond, "message")) {
[18:06:12.140]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:12.140]                         if (muffled) 
[18:06:12.140]                           invokeRestart("muffleMessage")
[18:06:12.140]                       }
[18:06:12.140]                       else if (inherits(cond, "warning")) {
[18:06:12.140]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:12.140]                         if (muffled) 
[18:06:12.140]                           invokeRestart("muffleWarning")
[18:06:12.140]                       }
[18:06:12.140]                       else if (inherits(cond, "condition")) {
[18:06:12.140]                         if (!is.null(pattern)) {
[18:06:12.140]                           computeRestarts <- base::computeRestarts
[18:06:12.140]                           grepl <- base::grepl
[18:06:12.140]                           restarts <- computeRestarts(cond)
[18:06:12.140]                           for (restart in restarts) {
[18:06:12.140]                             name <- restart$name
[18:06:12.140]                             if (is.null(name)) 
[18:06:12.140]                               next
[18:06:12.140]                             if (!grepl(pattern, name)) 
[18:06:12.140]                               next
[18:06:12.140]                             invokeRestart(restart)
[18:06:12.140]                             muffled <- TRUE
[18:06:12.140]                             break
[18:06:12.140]                           }
[18:06:12.140]                         }
[18:06:12.140]                       }
[18:06:12.140]                       invisible(muffled)
[18:06:12.140]                     }
[18:06:12.140]                     muffleCondition(cond, pattern = "^muffle")
[18:06:12.140]                   }
[18:06:12.140]                 }
[18:06:12.140]             }
[18:06:12.140]         }))
[18:06:12.140]     }, error = function(ex) {
[18:06:12.140]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:12.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:12.140]                 ...future.rng), started = ...future.startTime, 
[18:06:12.140]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:12.140]             version = "1.8"), class = "FutureResult")
[18:06:12.140]     }, finally = {
[18:06:12.140]         if (!identical(...future.workdir, getwd())) 
[18:06:12.140]             setwd(...future.workdir)
[18:06:12.140]         {
[18:06:12.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:12.140]                 ...future.oldOptions$nwarnings <- NULL
[18:06:12.140]             }
[18:06:12.140]             base::options(...future.oldOptions)
[18:06:12.140]             if (.Platform$OS.type == "windows") {
[18:06:12.140]                 old_names <- names(...future.oldEnvVars)
[18:06:12.140]                 envs <- base::Sys.getenv()
[18:06:12.140]                 names <- names(envs)
[18:06:12.140]                 common <- intersect(names, old_names)
[18:06:12.140]                 added <- setdiff(names, old_names)
[18:06:12.140]                 removed <- setdiff(old_names, names)
[18:06:12.140]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:12.140]                   envs[common]]
[18:06:12.140]                 NAMES <- toupper(changed)
[18:06:12.140]                 args <- list()
[18:06:12.140]                 for (kk in seq_along(NAMES)) {
[18:06:12.140]                   name <- changed[[kk]]
[18:06:12.140]                   NAME <- NAMES[[kk]]
[18:06:12.140]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.140]                     next
[18:06:12.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:12.140]                 }
[18:06:12.140]                 NAMES <- toupper(added)
[18:06:12.140]                 for (kk in seq_along(NAMES)) {
[18:06:12.140]                   name <- added[[kk]]
[18:06:12.140]                   NAME <- NAMES[[kk]]
[18:06:12.140]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.140]                     next
[18:06:12.140]                   args[[name]] <- ""
[18:06:12.140]                 }
[18:06:12.140]                 NAMES <- toupper(removed)
[18:06:12.140]                 for (kk in seq_along(NAMES)) {
[18:06:12.140]                   name <- removed[[kk]]
[18:06:12.140]                   NAME <- NAMES[[kk]]
[18:06:12.140]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.140]                     next
[18:06:12.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:12.140]                 }
[18:06:12.140]                 if (length(args) > 0) 
[18:06:12.140]                   base::do.call(base::Sys.setenv, args = args)
[18:06:12.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:12.140]             }
[18:06:12.140]             else {
[18:06:12.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:12.140]             }
[18:06:12.140]             {
[18:06:12.140]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:12.140]                   0L) {
[18:06:12.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:12.140]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:12.140]                   base::options(opts)
[18:06:12.140]                 }
[18:06:12.140]                 {
[18:06:12.140]                   {
[18:06:12.140]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:12.140]                     NULL
[18:06:12.140]                   }
[18:06:12.140]                   options(future.plan = NULL)
[18:06:12.140]                   if (is.na(NA_character_)) 
[18:06:12.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:12.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:12.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:12.140]                     .init = FALSE)
[18:06:12.140]                 }
[18:06:12.140]             }
[18:06:12.140]         }
[18:06:12.140]     })
[18:06:12.140]     if (TRUE) {
[18:06:12.140]         base::sink(type = "output", split = FALSE)
[18:06:12.140]         if (TRUE) {
[18:06:12.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:12.140]         }
[18:06:12.140]         else {
[18:06:12.140]             ...future.result["stdout"] <- base::list(NULL)
[18:06:12.140]         }
[18:06:12.140]         base::close(...future.stdout)
[18:06:12.140]         ...future.stdout <- NULL
[18:06:12.140]     }
[18:06:12.140]     ...future.result$conditions <- ...future.conditions
[18:06:12.140]     ...future.result$finished <- base::Sys.time()
[18:06:12.140]     ...future.result
[18:06:12.140] }
[18:06:12.145] MultisessionFuture started
[18:06:12.146] - Launch lazy future ... done
[18:06:12.146] run() for ‘MultisessionFuture’ ... done
[18:06:12.690] receiveMessageFromWorker() for ClusterFuture ...
[18:06:12.691] - Validating connection of MultisessionFuture
[18:06:12.691] - received message: FutureResult
[18:06:12.692] - Received FutureResult
[18:06:12.692] - Erased future from FutureRegistry
[18:06:12.692] result() for ClusterFuture ...
[18:06:12.693] - result already collected: FutureResult
[18:06:12.693] result() for ClusterFuture ... done
[18:06:12.693] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:12.694] A MultisessionFuture was resolved (result was not collected)
[18:06:12.694] getGlobalsAndPackages() ...
[18:06:12.694] Searching for globals...
[18:06:12.698] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:12.698] Searching for globals ... DONE
[18:06:12.699] Resolving globals: FALSE
[18:06:12.699] 
[18:06:12.700] 
[18:06:12.700] getGlobalsAndPackages() ... DONE
[18:06:12.701] run() for ‘Future’ ...
[18:06:12.701] - state: ‘created’
[18:06:12.702] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:12.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:12.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:12.728]   - Field: ‘node’
[18:06:12.728]   - Field: ‘label’
[18:06:12.728]   - Field: ‘local’
[18:06:12.728]   - Field: ‘owner’
[18:06:12.729]   - Field: ‘envir’
[18:06:12.729]   - Field: ‘workers’
[18:06:12.729]   - Field: ‘packages’
[18:06:12.729]   - Field: ‘gc’
[18:06:12.729]   - Field: ‘conditions’
[18:06:12.730]   - Field: ‘persistent’
[18:06:12.730]   - Field: ‘expr’
[18:06:12.730]   - Field: ‘uuid’
[18:06:12.730]   - Field: ‘seed’
[18:06:12.730]   - Field: ‘version’
[18:06:12.731]   - Field: ‘result’
[18:06:12.731]   - Field: ‘asynchronous’
[18:06:12.731]   - Field: ‘calls’
[18:06:12.731]   - Field: ‘globals’
[18:06:12.732]   - Field: ‘stdout’
[18:06:12.732]   - Field: ‘earlySignal’
[18:06:12.732]   - Field: ‘lazy’
[18:06:12.732]   - Field: ‘state’
[18:06:12.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:12.733] - Launch lazy future ...
[18:06:12.733] Packages needed by the future expression (n = 0): <none>
[18:06:12.733] Packages needed by future strategies (n = 0): <none>
[18:06:12.734] {
[18:06:12.734]     {
[18:06:12.734]         {
[18:06:12.734]             ...future.startTime <- base::Sys.time()
[18:06:12.734]             {
[18:06:12.734]                 {
[18:06:12.734]                   {
[18:06:12.734]                     {
[18:06:12.734]                       base::local({
[18:06:12.734]                         has_future <- base::requireNamespace("future", 
[18:06:12.734]                           quietly = TRUE)
[18:06:12.734]                         if (has_future) {
[18:06:12.734]                           ns <- base::getNamespace("future")
[18:06:12.734]                           version <- ns[[".package"]][["version"]]
[18:06:12.734]                           if (is.null(version)) 
[18:06:12.734]                             version <- utils::packageVersion("future")
[18:06:12.734]                         }
[18:06:12.734]                         else {
[18:06:12.734]                           version <- NULL
[18:06:12.734]                         }
[18:06:12.734]                         if (!has_future || version < "1.8.0") {
[18:06:12.734]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:12.734]                             "", base::R.version$version.string), 
[18:06:12.734]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:12.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:12.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:12.734]                               "release", "version")], collapse = " "), 
[18:06:12.734]                             hostname = base::Sys.info()[["nodename"]])
[18:06:12.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:12.734]                             info)
[18:06:12.734]                           info <- base::paste(info, collapse = "; ")
[18:06:12.734]                           if (!has_future) {
[18:06:12.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:12.734]                               info)
[18:06:12.734]                           }
[18:06:12.734]                           else {
[18:06:12.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:12.734]                               info, version)
[18:06:12.734]                           }
[18:06:12.734]                           base::stop(msg)
[18:06:12.734]                         }
[18:06:12.734]                       })
[18:06:12.734]                     }
[18:06:12.734]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:12.734]                     base::options(mc.cores = 1L)
[18:06:12.734]                   }
[18:06:12.734]                   ...future.strategy.old <- future::plan("list")
[18:06:12.734]                   options(future.plan = NULL)
[18:06:12.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:12.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:12.734]                 }
[18:06:12.734]                 ...future.workdir <- getwd()
[18:06:12.734]             }
[18:06:12.734]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:12.734]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:12.734]         }
[18:06:12.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:12.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:12.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:12.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:12.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:12.734]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:12.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:12.734]             base::names(...future.oldOptions))
[18:06:12.734]     }
[18:06:12.734]     if (FALSE) {
[18:06:12.734]     }
[18:06:12.734]     else {
[18:06:12.734]         if (TRUE) {
[18:06:12.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:12.734]                 open = "w")
[18:06:12.734]         }
[18:06:12.734]         else {
[18:06:12.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:12.734]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:12.734]         }
[18:06:12.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:12.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:12.734]             base::sink(type = "output", split = FALSE)
[18:06:12.734]             base::close(...future.stdout)
[18:06:12.734]         }, add = TRUE)
[18:06:12.734]     }
[18:06:12.734]     ...future.frame <- base::sys.nframe()
[18:06:12.734]     ...future.conditions <- base::list()
[18:06:12.734]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:12.734]     if (FALSE) {
[18:06:12.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:12.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:12.734]     }
[18:06:12.734]     ...future.result <- base::tryCatch({
[18:06:12.734]         base::withCallingHandlers({
[18:06:12.734]             ...future.value <- base::withVisible(base::local({
[18:06:12.734]                 ...future.makeSendCondition <- base::local({
[18:06:12.734]                   sendCondition <- NULL
[18:06:12.734]                   function(frame = 1L) {
[18:06:12.734]                     if (is.function(sendCondition)) 
[18:06:12.734]                       return(sendCondition)
[18:06:12.734]                     ns <- getNamespace("parallel")
[18:06:12.734]                     if (exists("sendData", mode = "function", 
[18:06:12.734]                       envir = ns)) {
[18:06:12.734]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:12.734]                         envir = ns)
[18:06:12.734]                       envir <- sys.frame(frame)
[18:06:12.734]                       master <- NULL
[18:06:12.734]                       while (!identical(envir, .GlobalEnv) && 
[18:06:12.734]                         !identical(envir, emptyenv())) {
[18:06:12.734]                         if (exists("master", mode = "list", envir = envir, 
[18:06:12.734]                           inherits = FALSE)) {
[18:06:12.734]                           master <- get("master", mode = "list", 
[18:06:12.734]                             envir = envir, inherits = FALSE)
[18:06:12.734]                           if (inherits(master, c("SOCKnode", 
[18:06:12.734]                             "SOCK0node"))) {
[18:06:12.734]                             sendCondition <<- function(cond) {
[18:06:12.734]                               data <- list(type = "VALUE", value = cond, 
[18:06:12.734]                                 success = TRUE)
[18:06:12.734]                               parallel_sendData(master, data)
[18:06:12.734]                             }
[18:06:12.734]                             return(sendCondition)
[18:06:12.734]                           }
[18:06:12.734]                         }
[18:06:12.734]                         frame <- frame + 1L
[18:06:12.734]                         envir <- sys.frame(frame)
[18:06:12.734]                       }
[18:06:12.734]                     }
[18:06:12.734]                     sendCondition <<- function(cond) NULL
[18:06:12.734]                   }
[18:06:12.734]                 })
[18:06:12.734]                 withCallingHandlers({
[18:06:12.734]                   {
[18:06:12.734]                     Sys.sleep(0.5)
[18:06:12.734]                     list(a = 1, b = 42L)
[18:06:12.734]                   }
[18:06:12.734]                 }, immediateCondition = function(cond) {
[18:06:12.734]                   sendCondition <- ...future.makeSendCondition()
[18:06:12.734]                   sendCondition(cond)
[18:06:12.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.734]                   {
[18:06:12.734]                     inherits <- base::inherits
[18:06:12.734]                     invokeRestart <- base::invokeRestart
[18:06:12.734]                     is.null <- base::is.null
[18:06:12.734]                     muffled <- FALSE
[18:06:12.734]                     if (inherits(cond, "message")) {
[18:06:12.734]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:12.734]                       if (muffled) 
[18:06:12.734]                         invokeRestart("muffleMessage")
[18:06:12.734]                     }
[18:06:12.734]                     else if (inherits(cond, "warning")) {
[18:06:12.734]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:12.734]                       if (muffled) 
[18:06:12.734]                         invokeRestart("muffleWarning")
[18:06:12.734]                     }
[18:06:12.734]                     else if (inherits(cond, "condition")) {
[18:06:12.734]                       if (!is.null(pattern)) {
[18:06:12.734]                         computeRestarts <- base::computeRestarts
[18:06:12.734]                         grepl <- base::grepl
[18:06:12.734]                         restarts <- computeRestarts(cond)
[18:06:12.734]                         for (restart in restarts) {
[18:06:12.734]                           name <- restart$name
[18:06:12.734]                           if (is.null(name)) 
[18:06:12.734]                             next
[18:06:12.734]                           if (!grepl(pattern, name)) 
[18:06:12.734]                             next
[18:06:12.734]                           invokeRestart(restart)
[18:06:12.734]                           muffled <- TRUE
[18:06:12.734]                           break
[18:06:12.734]                         }
[18:06:12.734]                       }
[18:06:12.734]                     }
[18:06:12.734]                     invisible(muffled)
[18:06:12.734]                   }
[18:06:12.734]                   muffleCondition(cond)
[18:06:12.734]                 })
[18:06:12.734]             }))
[18:06:12.734]             future::FutureResult(value = ...future.value$value, 
[18:06:12.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:12.734]                   ...future.rng), globalenv = if (FALSE) 
[18:06:12.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:12.734]                     ...future.globalenv.names))
[18:06:12.734]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:12.734]         }, condition = base::local({
[18:06:12.734]             c <- base::c
[18:06:12.734]             inherits <- base::inherits
[18:06:12.734]             invokeRestart <- base::invokeRestart
[18:06:12.734]             length <- base::length
[18:06:12.734]             list <- base::list
[18:06:12.734]             seq.int <- base::seq.int
[18:06:12.734]             signalCondition <- base::signalCondition
[18:06:12.734]             sys.calls <- base::sys.calls
[18:06:12.734]             `[[` <- base::`[[`
[18:06:12.734]             `+` <- base::`+`
[18:06:12.734]             `<<-` <- base::`<<-`
[18:06:12.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:12.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:12.734]                   3L)]
[18:06:12.734]             }
[18:06:12.734]             function(cond) {
[18:06:12.734]                 is_error <- inherits(cond, "error")
[18:06:12.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:12.734]                   NULL)
[18:06:12.734]                 if (is_error) {
[18:06:12.734]                   sessionInformation <- function() {
[18:06:12.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:12.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:12.734]                       search = base::search(), system = base::Sys.info())
[18:06:12.734]                   }
[18:06:12.734]                   ...future.conditions[[length(...future.conditions) + 
[18:06:12.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:12.734]                     cond$call), session = sessionInformation(), 
[18:06:12.734]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:12.734]                   signalCondition(cond)
[18:06:12.734]                 }
[18:06:12.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:12.734]                 "immediateCondition"))) {
[18:06:12.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:12.734]                   ...future.conditions[[length(...future.conditions) + 
[18:06:12.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:12.734]                   if (TRUE && !signal) {
[18:06:12.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.734]                     {
[18:06:12.734]                       inherits <- base::inherits
[18:06:12.734]                       invokeRestart <- base::invokeRestart
[18:06:12.734]                       is.null <- base::is.null
[18:06:12.734]                       muffled <- FALSE
[18:06:12.734]                       if (inherits(cond, "message")) {
[18:06:12.734]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:12.734]                         if (muffled) 
[18:06:12.734]                           invokeRestart("muffleMessage")
[18:06:12.734]                       }
[18:06:12.734]                       else if (inherits(cond, "warning")) {
[18:06:12.734]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:12.734]                         if (muffled) 
[18:06:12.734]                           invokeRestart("muffleWarning")
[18:06:12.734]                       }
[18:06:12.734]                       else if (inherits(cond, "condition")) {
[18:06:12.734]                         if (!is.null(pattern)) {
[18:06:12.734]                           computeRestarts <- base::computeRestarts
[18:06:12.734]                           grepl <- base::grepl
[18:06:12.734]                           restarts <- computeRestarts(cond)
[18:06:12.734]                           for (restart in restarts) {
[18:06:12.734]                             name <- restart$name
[18:06:12.734]                             if (is.null(name)) 
[18:06:12.734]                               next
[18:06:12.734]                             if (!grepl(pattern, name)) 
[18:06:12.734]                               next
[18:06:12.734]                             invokeRestart(restart)
[18:06:12.734]                             muffled <- TRUE
[18:06:12.734]                             break
[18:06:12.734]                           }
[18:06:12.734]                         }
[18:06:12.734]                       }
[18:06:12.734]                       invisible(muffled)
[18:06:12.734]                     }
[18:06:12.734]                     muffleCondition(cond, pattern = "^muffle")
[18:06:12.734]                   }
[18:06:12.734]                 }
[18:06:12.734]                 else {
[18:06:12.734]                   if (TRUE) {
[18:06:12.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:12.734]                     {
[18:06:12.734]                       inherits <- base::inherits
[18:06:12.734]                       invokeRestart <- base::invokeRestart
[18:06:12.734]                       is.null <- base::is.null
[18:06:12.734]                       muffled <- FALSE
[18:06:12.734]                       if (inherits(cond, "message")) {
[18:06:12.734]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:12.734]                         if (muffled) 
[18:06:12.734]                           invokeRestart("muffleMessage")
[18:06:12.734]                       }
[18:06:12.734]                       else if (inherits(cond, "warning")) {
[18:06:12.734]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:12.734]                         if (muffled) 
[18:06:12.734]                           invokeRestart("muffleWarning")
[18:06:12.734]                       }
[18:06:12.734]                       else if (inherits(cond, "condition")) {
[18:06:12.734]                         if (!is.null(pattern)) {
[18:06:12.734]                           computeRestarts <- base::computeRestarts
[18:06:12.734]                           grepl <- base::grepl
[18:06:12.734]                           restarts <- computeRestarts(cond)
[18:06:12.734]                           for (restart in restarts) {
[18:06:12.734]                             name <- restart$name
[18:06:12.734]                             if (is.null(name)) 
[18:06:12.734]                               next
[18:06:12.734]                             if (!grepl(pattern, name)) 
[18:06:12.734]                               next
[18:06:12.734]                             invokeRestart(restart)
[18:06:12.734]                             muffled <- TRUE
[18:06:12.734]                             break
[18:06:12.734]                           }
[18:06:12.734]                         }
[18:06:12.734]                       }
[18:06:12.734]                       invisible(muffled)
[18:06:12.734]                     }
[18:06:12.734]                     muffleCondition(cond, pattern = "^muffle")
[18:06:12.734]                   }
[18:06:12.734]                 }
[18:06:12.734]             }
[18:06:12.734]         }))
[18:06:12.734]     }, error = function(ex) {
[18:06:12.734]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:12.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:12.734]                 ...future.rng), started = ...future.startTime, 
[18:06:12.734]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:12.734]             version = "1.8"), class = "FutureResult")
[18:06:12.734]     }, finally = {
[18:06:12.734]         if (!identical(...future.workdir, getwd())) 
[18:06:12.734]             setwd(...future.workdir)
[18:06:12.734]         {
[18:06:12.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:12.734]                 ...future.oldOptions$nwarnings <- NULL
[18:06:12.734]             }
[18:06:12.734]             base::options(...future.oldOptions)
[18:06:12.734]             if (.Platform$OS.type == "windows") {
[18:06:12.734]                 old_names <- names(...future.oldEnvVars)
[18:06:12.734]                 envs <- base::Sys.getenv()
[18:06:12.734]                 names <- names(envs)
[18:06:12.734]                 common <- intersect(names, old_names)
[18:06:12.734]                 added <- setdiff(names, old_names)
[18:06:12.734]                 removed <- setdiff(old_names, names)
[18:06:12.734]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:12.734]                   envs[common]]
[18:06:12.734]                 NAMES <- toupper(changed)
[18:06:12.734]                 args <- list()
[18:06:12.734]                 for (kk in seq_along(NAMES)) {
[18:06:12.734]                   name <- changed[[kk]]
[18:06:12.734]                   NAME <- NAMES[[kk]]
[18:06:12.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.734]                     next
[18:06:12.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:12.734]                 }
[18:06:12.734]                 NAMES <- toupper(added)
[18:06:12.734]                 for (kk in seq_along(NAMES)) {
[18:06:12.734]                   name <- added[[kk]]
[18:06:12.734]                   NAME <- NAMES[[kk]]
[18:06:12.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.734]                     next
[18:06:12.734]                   args[[name]] <- ""
[18:06:12.734]                 }
[18:06:12.734]                 NAMES <- toupper(removed)
[18:06:12.734]                 for (kk in seq_along(NAMES)) {
[18:06:12.734]                   name <- removed[[kk]]
[18:06:12.734]                   NAME <- NAMES[[kk]]
[18:06:12.734]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:12.734]                     next
[18:06:12.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:12.734]                 }
[18:06:12.734]                 if (length(args) > 0) 
[18:06:12.734]                   base::do.call(base::Sys.setenv, args = args)
[18:06:12.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:12.734]             }
[18:06:12.734]             else {
[18:06:12.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:12.734]             }
[18:06:12.734]             {
[18:06:12.734]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:12.734]                   0L) {
[18:06:12.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:12.734]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:12.734]                   base::options(opts)
[18:06:12.734]                 }
[18:06:12.734]                 {
[18:06:12.734]                   {
[18:06:12.734]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:12.734]                     NULL
[18:06:12.734]                   }
[18:06:12.734]                   options(future.plan = NULL)
[18:06:12.734]                   if (is.na(NA_character_)) 
[18:06:12.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:12.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:12.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:12.734]                     .init = FALSE)
[18:06:12.734]                 }
[18:06:12.734]             }
[18:06:12.734]         }
[18:06:12.734]     })
[18:06:12.734]     if (TRUE) {
[18:06:12.734]         base::sink(type = "output", split = FALSE)
[18:06:12.734]         if (TRUE) {
[18:06:12.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:12.734]         }
[18:06:12.734]         else {
[18:06:12.734]             ...future.result["stdout"] <- base::list(NULL)
[18:06:12.734]         }
[18:06:12.734]         base::close(...future.stdout)
[18:06:12.734]         ...future.stdout <- NULL
[18:06:12.734]     }
[18:06:12.734]     ...future.result$conditions <- ...future.conditions
[18:06:12.734]     ...future.result$finished <- base::Sys.time()
[18:06:12.734]     ...future.result
[18:06:12.734] }
[18:06:12.740] MultisessionFuture started
[18:06:12.741] - Launch lazy future ... done
[18:06:12.741] run() for ‘MultisessionFuture’ ... done
[18:06:13.285] receiveMessageFromWorker() for ClusterFuture ...
[18:06:13.286] - Validating connection of MultisessionFuture
[18:06:13.286] - received message: FutureResult
[18:06:13.287] - Received FutureResult
[18:06:13.287] - Erased future from FutureRegistry
[18:06:13.287] result() for ClusterFuture ...
[18:06:13.288] - result already collected: FutureResult
[18:06:13.288] result() for ClusterFuture ... done
[18:06:13.288] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:13.289] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[18:06:13.289] getGlobalsAndPackages() ...
[18:06:13.289] Searching for globals...
[18:06:13.291] - globals found: [2] ‘list’, ‘stop’
[18:06:13.292] Searching for globals ... DONE
[18:06:13.292] Resolving globals: FALSE
[18:06:13.293] 
[18:06:13.293] 
[18:06:13.294] getGlobalsAndPackages() ... DONE
[18:06:13.294] run() for ‘Future’ ...
[18:06:13.295] - state: ‘created’
[18:06:13.295] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:13.327] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:13.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:13.328]   - Field: ‘node’
[18:06:13.328]   - Field: ‘label’
[18:06:13.328]   - Field: ‘local’
[18:06:13.328]   - Field: ‘owner’
[18:06:13.329]   - Field: ‘envir’
[18:06:13.329]   - Field: ‘workers’
[18:06:13.329]   - Field: ‘packages’
[18:06:13.330]   - Field: ‘gc’
[18:06:13.330]   - Field: ‘conditions’
[18:06:13.330]   - Field: ‘persistent’
[18:06:13.330]   - Field: ‘expr’
[18:06:13.331]   - Field: ‘uuid’
[18:06:13.331]   - Field: ‘seed’
[18:06:13.331]   - Field: ‘version’
[18:06:13.331]   - Field: ‘result’
[18:06:13.332]   - Field: ‘asynchronous’
[18:06:13.332]   - Field: ‘calls’
[18:06:13.332]   - Field: ‘globals’
[18:06:13.332]   - Field: ‘stdout’
[18:06:13.333]   - Field: ‘earlySignal’
[18:06:13.333]   - Field: ‘lazy’
[18:06:13.333]   - Field: ‘state’
[18:06:13.333] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:13.334] - Launch lazy future ...
[18:06:13.334] Packages needed by the future expression (n = 0): <none>
[18:06:13.335] Packages needed by future strategies (n = 0): <none>
[18:06:13.336] {
[18:06:13.336]     {
[18:06:13.336]         {
[18:06:13.336]             ...future.startTime <- base::Sys.time()
[18:06:13.336]             {
[18:06:13.336]                 {
[18:06:13.336]                   {
[18:06:13.336]                     {
[18:06:13.336]                       base::local({
[18:06:13.336]                         has_future <- base::requireNamespace("future", 
[18:06:13.336]                           quietly = TRUE)
[18:06:13.336]                         if (has_future) {
[18:06:13.336]                           ns <- base::getNamespace("future")
[18:06:13.336]                           version <- ns[[".package"]][["version"]]
[18:06:13.336]                           if (is.null(version)) 
[18:06:13.336]                             version <- utils::packageVersion("future")
[18:06:13.336]                         }
[18:06:13.336]                         else {
[18:06:13.336]                           version <- NULL
[18:06:13.336]                         }
[18:06:13.336]                         if (!has_future || version < "1.8.0") {
[18:06:13.336]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:13.336]                             "", base::R.version$version.string), 
[18:06:13.336]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:13.336]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:13.336]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:13.336]                               "release", "version")], collapse = " "), 
[18:06:13.336]                             hostname = base::Sys.info()[["nodename"]])
[18:06:13.336]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:13.336]                             info)
[18:06:13.336]                           info <- base::paste(info, collapse = "; ")
[18:06:13.336]                           if (!has_future) {
[18:06:13.336]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:13.336]                               info)
[18:06:13.336]                           }
[18:06:13.336]                           else {
[18:06:13.336]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:13.336]                               info, version)
[18:06:13.336]                           }
[18:06:13.336]                           base::stop(msg)
[18:06:13.336]                         }
[18:06:13.336]                       })
[18:06:13.336]                     }
[18:06:13.336]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:13.336]                     base::options(mc.cores = 1L)
[18:06:13.336]                   }
[18:06:13.336]                   ...future.strategy.old <- future::plan("list")
[18:06:13.336]                   options(future.plan = NULL)
[18:06:13.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:13.336]                 }
[18:06:13.336]                 ...future.workdir <- getwd()
[18:06:13.336]             }
[18:06:13.336]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:13.336]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:13.336]         }
[18:06:13.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:13.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:13.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:13.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:13.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:13.336]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:13.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:13.336]             base::names(...future.oldOptions))
[18:06:13.336]     }
[18:06:13.336]     if (FALSE) {
[18:06:13.336]     }
[18:06:13.336]     else {
[18:06:13.336]         if (TRUE) {
[18:06:13.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:13.336]                 open = "w")
[18:06:13.336]         }
[18:06:13.336]         else {
[18:06:13.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:13.336]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:13.336]         }
[18:06:13.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:13.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:13.336]             base::sink(type = "output", split = FALSE)
[18:06:13.336]             base::close(...future.stdout)
[18:06:13.336]         }, add = TRUE)
[18:06:13.336]     }
[18:06:13.336]     ...future.frame <- base::sys.nframe()
[18:06:13.336]     ...future.conditions <- base::list()
[18:06:13.336]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:13.336]     if (FALSE) {
[18:06:13.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:13.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:13.336]     }
[18:06:13.336]     ...future.result <- base::tryCatch({
[18:06:13.336]         base::withCallingHandlers({
[18:06:13.336]             ...future.value <- base::withVisible(base::local({
[18:06:13.336]                 ...future.makeSendCondition <- base::local({
[18:06:13.336]                   sendCondition <- NULL
[18:06:13.336]                   function(frame = 1L) {
[18:06:13.336]                     if (is.function(sendCondition)) 
[18:06:13.336]                       return(sendCondition)
[18:06:13.336]                     ns <- getNamespace("parallel")
[18:06:13.336]                     if (exists("sendData", mode = "function", 
[18:06:13.336]                       envir = ns)) {
[18:06:13.336]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:13.336]                         envir = ns)
[18:06:13.336]                       envir <- sys.frame(frame)
[18:06:13.336]                       master <- NULL
[18:06:13.336]                       while (!identical(envir, .GlobalEnv) && 
[18:06:13.336]                         !identical(envir, emptyenv())) {
[18:06:13.336]                         if (exists("master", mode = "list", envir = envir, 
[18:06:13.336]                           inherits = FALSE)) {
[18:06:13.336]                           master <- get("master", mode = "list", 
[18:06:13.336]                             envir = envir, inherits = FALSE)
[18:06:13.336]                           if (inherits(master, c("SOCKnode", 
[18:06:13.336]                             "SOCK0node"))) {
[18:06:13.336]                             sendCondition <<- function(cond) {
[18:06:13.336]                               data <- list(type = "VALUE", value = cond, 
[18:06:13.336]                                 success = TRUE)
[18:06:13.336]                               parallel_sendData(master, data)
[18:06:13.336]                             }
[18:06:13.336]                             return(sendCondition)
[18:06:13.336]                           }
[18:06:13.336]                         }
[18:06:13.336]                         frame <- frame + 1L
[18:06:13.336]                         envir <- sys.frame(frame)
[18:06:13.336]                       }
[18:06:13.336]                     }
[18:06:13.336]                     sendCondition <<- function(cond) NULL
[18:06:13.336]                   }
[18:06:13.336]                 })
[18:06:13.336]                 withCallingHandlers({
[18:06:13.336]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:13.336]                 }, immediateCondition = function(cond) {
[18:06:13.336]                   sendCondition <- ...future.makeSendCondition()
[18:06:13.336]                   sendCondition(cond)
[18:06:13.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.336]                   {
[18:06:13.336]                     inherits <- base::inherits
[18:06:13.336]                     invokeRestart <- base::invokeRestart
[18:06:13.336]                     is.null <- base::is.null
[18:06:13.336]                     muffled <- FALSE
[18:06:13.336]                     if (inherits(cond, "message")) {
[18:06:13.336]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:13.336]                       if (muffled) 
[18:06:13.336]                         invokeRestart("muffleMessage")
[18:06:13.336]                     }
[18:06:13.336]                     else if (inherits(cond, "warning")) {
[18:06:13.336]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:13.336]                       if (muffled) 
[18:06:13.336]                         invokeRestart("muffleWarning")
[18:06:13.336]                     }
[18:06:13.336]                     else if (inherits(cond, "condition")) {
[18:06:13.336]                       if (!is.null(pattern)) {
[18:06:13.336]                         computeRestarts <- base::computeRestarts
[18:06:13.336]                         grepl <- base::grepl
[18:06:13.336]                         restarts <- computeRestarts(cond)
[18:06:13.336]                         for (restart in restarts) {
[18:06:13.336]                           name <- restart$name
[18:06:13.336]                           if (is.null(name)) 
[18:06:13.336]                             next
[18:06:13.336]                           if (!grepl(pattern, name)) 
[18:06:13.336]                             next
[18:06:13.336]                           invokeRestart(restart)
[18:06:13.336]                           muffled <- TRUE
[18:06:13.336]                           break
[18:06:13.336]                         }
[18:06:13.336]                       }
[18:06:13.336]                     }
[18:06:13.336]                     invisible(muffled)
[18:06:13.336]                   }
[18:06:13.336]                   muffleCondition(cond)
[18:06:13.336]                 })
[18:06:13.336]             }))
[18:06:13.336]             future::FutureResult(value = ...future.value$value, 
[18:06:13.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.336]                   ...future.rng), globalenv = if (FALSE) 
[18:06:13.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:13.336]                     ...future.globalenv.names))
[18:06:13.336]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:13.336]         }, condition = base::local({
[18:06:13.336]             c <- base::c
[18:06:13.336]             inherits <- base::inherits
[18:06:13.336]             invokeRestart <- base::invokeRestart
[18:06:13.336]             length <- base::length
[18:06:13.336]             list <- base::list
[18:06:13.336]             seq.int <- base::seq.int
[18:06:13.336]             signalCondition <- base::signalCondition
[18:06:13.336]             sys.calls <- base::sys.calls
[18:06:13.336]             `[[` <- base::`[[`
[18:06:13.336]             `+` <- base::`+`
[18:06:13.336]             `<<-` <- base::`<<-`
[18:06:13.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:13.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:13.336]                   3L)]
[18:06:13.336]             }
[18:06:13.336]             function(cond) {
[18:06:13.336]                 is_error <- inherits(cond, "error")
[18:06:13.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:13.336]                   NULL)
[18:06:13.336]                 if (is_error) {
[18:06:13.336]                   sessionInformation <- function() {
[18:06:13.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:13.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:13.336]                       search = base::search(), system = base::Sys.info())
[18:06:13.336]                   }
[18:06:13.336]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:13.336]                     cond$call), session = sessionInformation(), 
[18:06:13.336]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:13.336]                   signalCondition(cond)
[18:06:13.336]                 }
[18:06:13.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:13.336]                 "immediateCondition"))) {
[18:06:13.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:13.336]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:13.336]                   if (TRUE && !signal) {
[18:06:13.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.336]                     {
[18:06:13.336]                       inherits <- base::inherits
[18:06:13.336]                       invokeRestart <- base::invokeRestart
[18:06:13.336]                       is.null <- base::is.null
[18:06:13.336]                       muffled <- FALSE
[18:06:13.336]                       if (inherits(cond, "message")) {
[18:06:13.336]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.336]                         if (muffled) 
[18:06:13.336]                           invokeRestart("muffleMessage")
[18:06:13.336]                       }
[18:06:13.336]                       else if (inherits(cond, "warning")) {
[18:06:13.336]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.336]                         if (muffled) 
[18:06:13.336]                           invokeRestart("muffleWarning")
[18:06:13.336]                       }
[18:06:13.336]                       else if (inherits(cond, "condition")) {
[18:06:13.336]                         if (!is.null(pattern)) {
[18:06:13.336]                           computeRestarts <- base::computeRestarts
[18:06:13.336]                           grepl <- base::grepl
[18:06:13.336]                           restarts <- computeRestarts(cond)
[18:06:13.336]                           for (restart in restarts) {
[18:06:13.336]                             name <- restart$name
[18:06:13.336]                             if (is.null(name)) 
[18:06:13.336]                               next
[18:06:13.336]                             if (!grepl(pattern, name)) 
[18:06:13.336]                               next
[18:06:13.336]                             invokeRestart(restart)
[18:06:13.336]                             muffled <- TRUE
[18:06:13.336]                             break
[18:06:13.336]                           }
[18:06:13.336]                         }
[18:06:13.336]                       }
[18:06:13.336]                       invisible(muffled)
[18:06:13.336]                     }
[18:06:13.336]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.336]                   }
[18:06:13.336]                 }
[18:06:13.336]                 else {
[18:06:13.336]                   if (TRUE) {
[18:06:13.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.336]                     {
[18:06:13.336]                       inherits <- base::inherits
[18:06:13.336]                       invokeRestart <- base::invokeRestart
[18:06:13.336]                       is.null <- base::is.null
[18:06:13.336]                       muffled <- FALSE
[18:06:13.336]                       if (inherits(cond, "message")) {
[18:06:13.336]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.336]                         if (muffled) 
[18:06:13.336]                           invokeRestart("muffleMessage")
[18:06:13.336]                       }
[18:06:13.336]                       else if (inherits(cond, "warning")) {
[18:06:13.336]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.336]                         if (muffled) 
[18:06:13.336]                           invokeRestart("muffleWarning")
[18:06:13.336]                       }
[18:06:13.336]                       else if (inherits(cond, "condition")) {
[18:06:13.336]                         if (!is.null(pattern)) {
[18:06:13.336]                           computeRestarts <- base::computeRestarts
[18:06:13.336]                           grepl <- base::grepl
[18:06:13.336]                           restarts <- computeRestarts(cond)
[18:06:13.336]                           for (restart in restarts) {
[18:06:13.336]                             name <- restart$name
[18:06:13.336]                             if (is.null(name)) 
[18:06:13.336]                               next
[18:06:13.336]                             if (!grepl(pattern, name)) 
[18:06:13.336]                               next
[18:06:13.336]                             invokeRestart(restart)
[18:06:13.336]                             muffled <- TRUE
[18:06:13.336]                             break
[18:06:13.336]                           }
[18:06:13.336]                         }
[18:06:13.336]                       }
[18:06:13.336]                       invisible(muffled)
[18:06:13.336]                     }
[18:06:13.336]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.336]                   }
[18:06:13.336]                 }
[18:06:13.336]             }
[18:06:13.336]         }))
[18:06:13.336]     }, error = function(ex) {
[18:06:13.336]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:13.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.336]                 ...future.rng), started = ...future.startTime, 
[18:06:13.336]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:13.336]             version = "1.8"), class = "FutureResult")
[18:06:13.336]     }, finally = {
[18:06:13.336]         if (!identical(...future.workdir, getwd())) 
[18:06:13.336]             setwd(...future.workdir)
[18:06:13.336]         {
[18:06:13.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:13.336]                 ...future.oldOptions$nwarnings <- NULL
[18:06:13.336]             }
[18:06:13.336]             base::options(...future.oldOptions)
[18:06:13.336]             if (.Platform$OS.type == "windows") {
[18:06:13.336]                 old_names <- names(...future.oldEnvVars)
[18:06:13.336]                 envs <- base::Sys.getenv()
[18:06:13.336]                 names <- names(envs)
[18:06:13.336]                 common <- intersect(names, old_names)
[18:06:13.336]                 added <- setdiff(names, old_names)
[18:06:13.336]                 removed <- setdiff(old_names, names)
[18:06:13.336]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:13.336]                   envs[common]]
[18:06:13.336]                 NAMES <- toupper(changed)
[18:06:13.336]                 args <- list()
[18:06:13.336]                 for (kk in seq_along(NAMES)) {
[18:06:13.336]                   name <- changed[[kk]]
[18:06:13.336]                   NAME <- NAMES[[kk]]
[18:06:13.336]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.336]                     next
[18:06:13.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.336]                 }
[18:06:13.336]                 NAMES <- toupper(added)
[18:06:13.336]                 for (kk in seq_along(NAMES)) {
[18:06:13.336]                   name <- added[[kk]]
[18:06:13.336]                   NAME <- NAMES[[kk]]
[18:06:13.336]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.336]                     next
[18:06:13.336]                   args[[name]] <- ""
[18:06:13.336]                 }
[18:06:13.336]                 NAMES <- toupper(removed)
[18:06:13.336]                 for (kk in seq_along(NAMES)) {
[18:06:13.336]                   name <- removed[[kk]]
[18:06:13.336]                   NAME <- NAMES[[kk]]
[18:06:13.336]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.336]                     next
[18:06:13.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.336]                 }
[18:06:13.336]                 if (length(args) > 0) 
[18:06:13.336]                   base::do.call(base::Sys.setenv, args = args)
[18:06:13.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:13.336]             }
[18:06:13.336]             else {
[18:06:13.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:13.336]             }
[18:06:13.336]             {
[18:06:13.336]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:13.336]                   0L) {
[18:06:13.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:13.336]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:13.336]                   base::options(opts)
[18:06:13.336]                 }
[18:06:13.336]                 {
[18:06:13.336]                   {
[18:06:13.336]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:13.336]                     NULL
[18:06:13.336]                   }
[18:06:13.336]                   options(future.plan = NULL)
[18:06:13.336]                   if (is.na(NA_character_)) 
[18:06:13.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:13.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:13.336]                     .init = FALSE)
[18:06:13.336]                 }
[18:06:13.336]             }
[18:06:13.336]         }
[18:06:13.336]     })
[18:06:13.336]     if (TRUE) {
[18:06:13.336]         base::sink(type = "output", split = FALSE)
[18:06:13.336]         if (TRUE) {
[18:06:13.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:13.336]         }
[18:06:13.336]         else {
[18:06:13.336]             ...future.result["stdout"] <- base::list(NULL)
[18:06:13.336]         }
[18:06:13.336]         base::close(...future.stdout)
[18:06:13.336]         ...future.stdout <- NULL
[18:06:13.336]     }
[18:06:13.336]     ...future.result$conditions <- ...future.conditions
[18:06:13.336]     ...future.result$finished <- base::Sys.time()
[18:06:13.336]     ...future.result
[18:06:13.336] }
[18:06:13.345] MultisessionFuture started
[18:06:13.346] - Launch lazy future ... done
[18:06:13.348] run() for ‘MultisessionFuture’ ... done
[18:06:13.392] receiveMessageFromWorker() for ClusterFuture ...
[18:06:13.392] - Validating connection of MultisessionFuture
[18:06:13.393] - received message: FutureResult
[18:06:13.394] - Received FutureResult
[18:06:13.394] - Erased future from FutureRegistry
[18:06:13.394] result() for ClusterFuture ...
[18:06:13.395] - result already collected: FutureResult
[18:06:13.395] result() for ClusterFuture ... done
[18:06:13.395] signalConditions() ...
[18:06:13.395]  - include = ‘immediateCondition’
[18:06:13.396]  - exclude = 
[18:06:13.396]  - resignal = FALSE
[18:06:13.396]  - Number of conditions: 1
[18:06:13.396] signalConditions() ... done
[18:06:13.397] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:13.397] A MultisessionFuture was resolved (result was not collected)
[18:06:13.397] getGlobalsAndPackages() ...
[18:06:13.398] Searching for globals...
[18:06:13.399] - globals found: [2] ‘list’, ‘stop’
[18:06:13.400] Searching for globals ... DONE
[18:06:13.400] Resolving globals: FALSE
[18:06:13.401] 
[18:06:13.401] 
[18:06:13.401] getGlobalsAndPackages() ... DONE
[18:06:13.402] run() for ‘Future’ ...
[18:06:13.402] - state: ‘created’
[18:06:13.403] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:13.429] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:13.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:13.430]   - Field: ‘node’
[18:06:13.430]   - Field: ‘label’
[18:06:13.430]   - Field: ‘local’
[18:06:13.430]   - Field: ‘owner’
[18:06:13.430]   - Field: ‘envir’
[18:06:13.431]   - Field: ‘workers’
[18:06:13.431]   - Field: ‘packages’
[18:06:13.431]   - Field: ‘gc’
[18:06:13.431]   - Field: ‘conditions’
[18:06:13.432]   - Field: ‘persistent’
[18:06:13.432]   - Field: ‘expr’
[18:06:13.432]   - Field: ‘uuid’
[18:06:13.432]   - Field: ‘seed’
[18:06:13.432]   - Field: ‘version’
[18:06:13.432]   - Field: ‘result’
[18:06:13.433]   - Field: ‘asynchronous’
[18:06:13.433]   - Field: ‘calls’
[18:06:13.433]   - Field: ‘globals’
[18:06:13.433]   - Field: ‘stdout’
[18:06:13.433]   - Field: ‘earlySignal’
[18:06:13.434]   - Field: ‘lazy’
[18:06:13.434]   - Field: ‘state’
[18:06:13.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:13.437] - Launch lazy future ...
[18:06:13.438] Packages needed by the future expression (n = 0): <none>
[18:06:13.438] Packages needed by future strategies (n = 0): <none>
[18:06:13.439] {
[18:06:13.439]     {
[18:06:13.439]         {
[18:06:13.439]             ...future.startTime <- base::Sys.time()
[18:06:13.439]             {
[18:06:13.439]                 {
[18:06:13.439]                   {
[18:06:13.439]                     {
[18:06:13.439]                       base::local({
[18:06:13.439]                         has_future <- base::requireNamespace("future", 
[18:06:13.439]                           quietly = TRUE)
[18:06:13.439]                         if (has_future) {
[18:06:13.439]                           ns <- base::getNamespace("future")
[18:06:13.439]                           version <- ns[[".package"]][["version"]]
[18:06:13.439]                           if (is.null(version)) 
[18:06:13.439]                             version <- utils::packageVersion("future")
[18:06:13.439]                         }
[18:06:13.439]                         else {
[18:06:13.439]                           version <- NULL
[18:06:13.439]                         }
[18:06:13.439]                         if (!has_future || version < "1.8.0") {
[18:06:13.439]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:13.439]                             "", base::R.version$version.string), 
[18:06:13.439]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:13.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:13.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:13.439]                               "release", "version")], collapse = " "), 
[18:06:13.439]                             hostname = base::Sys.info()[["nodename"]])
[18:06:13.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:13.439]                             info)
[18:06:13.439]                           info <- base::paste(info, collapse = "; ")
[18:06:13.439]                           if (!has_future) {
[18:06:13.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:13.439]                               info)
[18:06:13.439]                           }
[18:06:13.439]                           else {
[18:06:13.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:13.439]                               info, version)
[18:06:13.439]                           }
[18:06:13.439]                           base::stop(msg)
[18:06:13.439]                         }
[18:06:13.439]                       })
[18:06:13.439]                     }
[18:06:13.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:13.439]                     base::options(mc.cores = 1L)
[18:06:13.439]                   }
[18:06:13.439]                   ...future.strategy.old <- future::plan("list")
[18:06:13.439]                   options(future.plan = NULL)
[18:06:13.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:13.439]                 }
[18:06:13.439]                 ...future.workdir <- getwd()
[18:06:13.439]             }
[18:06:13.439]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:13.439]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:13.439]         }
[18:06:13.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:13.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:13.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:13.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:13.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:13.439]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:13.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:13.439]             base::names(...future.oldOptions))
[18:06:13.439]     }
[18:06:13.439]     if (FALSE) {
[18:06:13.439]     }
[18:06:13.439]     else {
[18:06:13.439]         if (TRUE) {
[18:06:13.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:13.439]                 open = "w")
[18:06:13.439]         }
[18:06:13.439]         else {
[18:06:13.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:13.439]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:13.439]         }
[18:06:13.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:13.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:13.439]             base::sink(type = "output", split = FALSE)
[18:06:13.439]             base::close(...future.stdout)
[18:06:13.439]         }, add = TRUE)
[18:06:13.439]     }
[18:06:13.439]     ...future.frame <- base::sys.nframe()
[18:06:13.439]     ...future.conditions <- base::list()
[18:06:13.439]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:13.439]     if (FALSE) {
[18:06:13.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:13.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:13.439]     }
[18:06:13.439]     ...future.result <- base::tryCatch({
[18:06:13.439]         base::withCallingHandlers({
[18:06:13.439]             ...future.value <- base::withVisible(base::local({
[18:06:13.439]                 ...future.makeSendCondition <- base::local({
[18:06:13.439]                   sendCondition <- NULL
[18:06:13.439]                   function(frame = 1L) {
[18:06:13.439]                     if (is.function(sendCondition)) 
[18:06:13.439]                       return(sendCondition)
[18:06:13.439]                     ns <- getNamespace("parallel")
[18:06:13.439]                     if (exists("sendData", mode = "function", 
[18:06:13.439]                       envir = ns)) {
[18:06:13.439]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:13.439]                         envir = ns)
[18:06:13.439]                       envir <- sys.frame(frame)
[18:06:13.439]                       master <- NULL
[18:06:13.439]                       while (!identical(envir, .GlobalEnv) && 
[18:06:13.439]                         !identical(envir, emptyenv())) {
[18:06:13.439]                         if (exists("master", mode = "list", envir = envir, 
[18:06:13.439]                           inherits = FALSE)) {
[18:06:13.439]                           master <- get("master", mode = "list", 
[18:06:13.439]                             envir = envir, inherits = FALSE)
[18:06:13.439]                           if (inherits(master, c("SOCKnode", 
[18:06:13.439]                             "SOCK0node"))) {
[18:06:13.439]                             sendCondition <<- function(cond) {
[18:06:13.439]                               data <- list(type = "VALUE", value = cond, 
[18:06:13.439]                                 success = TRUE)
[18:06:13.439]                               parallel_sendData(master, data)
[18:06:13.439]                             }
[18:06:13.439]                             return(sendCondition)
[18:06:13.439]                           }
[18:06:13.439]                         }
[18:06:13.439]                         frame <- frame + 1L
[18:06:13.439]                         envir <- sys.frame(frame)
[18:06:13.439]                       }
[18:06:13.439]                     }
[18:06:13.439]                     sendCondition <<- function(cond) NULL
[18:06:13.439]                   }
[18:06:13.439]                 })
[18:06:13.439]                 withCallingHandlers({
[18:06:13.439]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:13.439]                 }, immediateCondition = function(cond) {
[18:06:13.439]                   sendCondition <- ...future.makeSendCondition()
[18:06:13.439]                   sendCondition(cond)
[18:06:13.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.439]                   {
[18:06:13.439]                     inherits <- base::inherits
[18:06:13.439]                     invokeRestart <- base::invokeRestart
[18:06:13.439]                     is.null <- base::is.null
[18:06:13.439]                     muffled <- FALSE
[18:06:13.439]                     if (inherits(cond, "message")) {
[18:06:13.439]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:13.439]                       if (muffled) 
[18:06:13.439]                         invokeRestart("muffleMessage")
[18:06:13.439]                     }
[18:06:13.439]                     else if (inherits(cond, "warning")) {
[18:06:13.439]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:13.439]                       if (muffled) 
[18:06:13.439]                         invokeRestart("muffleWarning")
[18:06:13.439]                     }
[18:06:13.439]                     else if (inherits(cond, "condition")) {
[18:06:13.439]                       if (!is.null(pattern)) {
[18:06:13.439]                         computeRestarts <- base::computeRestarts
[18:06:13.439]                         grepl <- base::grepl
[18:06:13.439]                         restarts <- computeRestarts(cond)
[18:06:13.439]                         for (restart in restarts) {
[18:06:13.439]                           name <- restart$name
[18:06:13.439]                           if (is.null(name)) 
[18:06:13.439]                             next
[18:06:13.439]                           if (!grepl(pattern, name)) 
[18:06:13.439]                             next
[18:06:13.439]                           invokeRestart(restart)
[18:06:13.439]                           muffled <- TRUE
[18:06:13.439]                           break
[18:06:13.439]                         }
[18:06:13.439]                       }
[18:06:13.439]                     }
[18:06:13.439]                     invisible(muffled)
[18:06:13.439]                   }
[18:06:13.439]                   muffleCondition(cond)
[18:06:13.439]                 })
[18:06:13.439]             }))
[18:06:13.439]             future::FutureResult(value = ...future.value$value, 
[18:06:13.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.439]                   ...future.rng), globalenv = if (FALSE) 
[18:06:13.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:13.439]                     ...future.globalenv.names))
[18:06:13.439]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:13.439]         }, condition = base::local({
[18:06:13.439]             c <- base::c
[18:06:13.439]             inherits <- base::inherits
[18:06:13.439]             invokeRestart <- base::invokeRestart
[18:06:13.439]             length <- base::length
[18:06:13.439]             list <- base::list
[18:06:13.439]             seq.int <- base::seq.int
[18:06:13.439]             signalCondition <- base::signalCondition
[18:06:13.439]             sys.calls <- base::sys.calls
[18:06:13.439]             `[[` <- base::`[[`
[18:06:13.439]             `+` <- base::`+`
[18:06:13.439]             `<<-` <- base::`<<-`
[18:06:13.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:13.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:13.439]                   3L)]
[18:06:13.439]             }
[18:06:13.439]             function(cond) {
[18:06:13.439]                 is_error <- inherits(cond, "error")
[18:06:13.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:13.439]                   NULL)
[18:06:13.439]                 if (is_error) {
[18:06:13.439]                   sessionInformation <- function() {
[18:06:13.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:13.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:13.439]                       search = base::search(), system = base::Sys.info())
[18:06:13.439]                   }
[18:06:13.439]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:13.439]                     cond$call), session = sessionInformation(), 
[18:06:13.439]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:13.439]                   signalCondition(cond)
[18:06:13.439]                 }
[18:06:13.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:13.439]                 "immediateCondition"))) {
[18:06:13.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:13.439]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:13.439]                   if (TRUE && !signal) {
[18:06:13.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.439]                     {
[18:06:13.439]                       inherits <- base::inherits
[18:06:13.439]                       invokeRestart <- base::invokeRestart
[18:06:13.439]                       is.null <- base::is.null
[18:06:13.439]                       muffled <- FALSE
[18:06:13.439]                       if (inherits(cond, "message")) {
[18:06:13.439]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.439]                         if (muffled) 
[18:06:13.439]                           invokeRestart("muffleMessage")
[18:06:13.439]                       }
[18:06:13.439]                       else if (inherits(cond, "warning")) {
[18:06:13.439]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.439]                         if (muffled) 
[18:06:13.439]                           invokeRestart("muffleWarning")
[18:06:13.439]                       }
[18:06:13.439]                       else if (inherits(cond, "condition")) {
[18:06:13.439]                         if (!is.null(pattern)) {
[18:06:13.439]                           computeRestarts <- base::computeRestarts
[18:06:13.439]                           grepl <- base::grepl
[18:06:13.439]                           restarts <- computeRestarts(cond)
[18:06:13.439]                           for (restart in restarts) {
[18:06:13.439]                             name <- restart$name
[18:06:13.439]                             if (is.null(name)) 
[18:06:13.439]                               next
[18:06:13.439]                             if (!grepl(pattern, name)) 
[18:06:13.439]                               next
[18:06:13.439]                             invokeRestart(restart)
[18:06:13.439]                             muffled <- TRUE
[18:06:13.439]                             break
[18:06:13.439]                           }
[18:06:13.439]                         }
[18:06:13.439]                       }
[18:06:13.439]                       invisible(muffled)
[18:06:13.439]                     }
[18:06:13.439]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.439]                   }
[18:06:13.439]                 }
[18:06:13.439]                 else {
[18:06:13.439]                   if (TRUE) {
[18:06:13.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.439]                     {
[18:06:13.439]                       inherits <- base::inherits
[18:06:13.439]                       invokeRestart <- base::invokeRestart
[18:06:13.439]                       is.null <- base::is.null
[18:06:13.439]                       muffled <- FALSE
[18:06:13.439]                       if (inherits(cond, "message")) {
[18:06:13.439]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.439]                         if (muffled) 
[18:06:13.439]                           invokeRestart("muffleMessage")
[18:06:13.439]                       }
[18:06:13.439]                       else if (inherits(cond, "warning")) {
[18:06:13.439]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.439]                         if (muffled) 
[18:06:13.439]                           invokeRestart("muffleWarning")
[18:06:13.439]                       }
[18:06:13.439]                       else if (inherits(cond, "condition")) {
[18:06:13.439]                         if (!is.null(pattern)) {
[18:06:13.439]                           computeRestarts <- base::computeRestarts
[18:06:13.439]                           grepl <- base::grepl
[18:06:13.439]                           restarts <- computeRestarts(cond)
[18:06:13.439]                           for (restart in restarts) {
[18:06:13.439]                             name <- restart$name
[18:06:13.439]                             if (is.null(name)) 
[18:06:13.439]                               next
[18:06:13.439]                             if (!grepl(pattern, name)) 
[18:06:13.439]                               next
[18:06:13.439]                             invokeRestart(restart)
[18:06:13.439]                             muffled <- TRUE
[18:06:13.439]                             break
[18:06:13.439]                           }
[18:06:13.439]                         }
[18:06:13.439]                       }
[18:06:13.439]                       invisible(muffled)
[18:06:13.439]                     }
[18:06:13.439]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.439]                   }
[18:06:13.439]                 }
[18:06:13.439]             }
[18:06:13.439]         }))
[18:06:13.439]     }, error = function(ex) {
[18:06:13.439]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:13.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.439]                 ...future.rng), started = ...future.startTime, 
[18:06:13.439]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:13.439]             version = "1.8"), class = "FutureResult")
[18:06:13.439]     }, finally = {
[18:06:13.439]         if (!identical(...future.workdir, getwd())) 
[18:06:13.439]             setwd(...future.workdir)
[18:06:13.439]         {
[18:06:13.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:13.439]                 ...future.oldOptions$nwarnings <- NULL
[18:06:13.439]             }
[18:06:13.439]             base::options(...future.oldOptions)
[18:06:13.439]             if (.Platform$OS.type == "windows") {
[18:06:13.439]                 old_names <- names(...future.oldEnvVars)
[18:06:13.439]                 envs <- base::Sys.getenv()
[18:06:13.439]                 names <- names(envs)
[18:06:13.439]                 common <- intersect(names, old_names)
[18:06:13.439]                 added <- setdiff(names, old_names)
[18:06:13.439]                 removed <- setdiff(old_names, names)
[18:06:13.439]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:13.439]                   envs[common]]
[18:06:13.439]                 NAMES <- toupper(changed)
[18:06:13.439]                 args <- list()
[18:06:13.439]                 for (kk in seq_along(NAMES)) {
[18:06:13.439]                   name <- changed[[kk]]
[18:06:13.439]                   NAME <- NAMES[[kk]]
[18:06:13.439]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.439]                     next
[18:06:13.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.439]                 }
[18:06:13.439]                 NAMES <- toupper(added)
[18:06:13.439]                 for (kk in seq_along(NAMES)) {
[18:06:13.439]                   name <- added[[kk]]
[18:06:13.439]                   NAME <- NAMES[[kk]]
[18:06:13.439]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.439]                     next
[18:06:13.439]                   args[[name]] <- ""
[18:06:13.439]                 }
[18:06:13.439]                 NAMES <- toupper(removed)
[18:06:13.439]                 for (kk in seq_along(NAMES)) {
[18:06:13.439]                   name <- removed[[kk]]
[18:06:13.439]                   NAME <- NAMES[[kk]]
[18:06:13.439]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.439]                     next
[18:06:13.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.439]                 }
[18:06:13.439]                 if (length(args) > 0) 
[18:06:13.439]                   base::do.call(base::Sys.setenv, args = args)
[18:06:13.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:13.439]             }
[18:06:13.439]             else {
[18:06:13.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:13.439]             }
[18:06:13.439]             {
[18:06:13.439]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:13.439]                   0L) {
[18:06:13.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:13.439]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:13.439]                   base::options(opts)
[18:06:13.439]                 }
[18:06:13.439]                 {
[18:06:13.439]                   {
[18:06:13.439]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:13.439]                     NULL
[18:06:13.439]                   }
[18:06:13.439]                   options(future.plan = NULL)
[18:06:13.439]                   if (is.na(NA_character_)) 
[18:06:13.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:13.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:13.439]                     .init = FALSE)
[18:06:13.439]                 }
[18:06:13.439]             }
[18:06:13.439]         }
[18:06:13.439]     })
[18:06:13.439]     if (TRUE) {
[18:06:13.439]         base::sink(type = "output", split = FALSE)
[18:06:13.439]         if (TRUE) {
[18:06:13.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:13.439]         }
[18:06:13.439]         else {
[18:06:13.439]             ...future.result["stdout"] <- base::list(NULL)
[18:06:13.439]         }
[18:06:13.439]         base::close(...future.stdout)
[18:06:13.439]         ...future.stdout <- NULL
[18:06:13.439]     }
[18:06:13.439]     ...future.result$conditions <- ...future.conditions
[18:06:13.439]     ...future.result$finished <- base::Sys.time()
[18:06:13.439]     ...future.result
[18:06:13.439] }
[18:06:13.444] MultisessionFuture started
[18:06:13.445] - Launch lazy future ... done
[18:06:13.445] run() for ‘MultisessionFuture’ ... done
[18:06:13.488] receiveMessageFromWorker() for ClusterFuture ...
[18:06:13.489] - Validating connection of MultisessionFuture
[18:06:13.490] - received message: FutureResult
[18:06:13.490] - Received FutureResult
[18:06:13.490] - Erased future from FutureRegistry
[18:06:13.490] result() for ClusterFuture ...
[18:06:13.491] - result already collected: FutureResult
[18:06:13.491] result() for ClusterFuture ... done
[18:06:13.491] signalConditions() ...
[18:06:13.491]  - include = ‘immediateCondition’
[18:06:13.491]  - exclude = 
[18:06:13.492]  - resignal = FALSE
[18:06:13.492]  - Number of conditions: 1
[18:06:13.492] signalConditions() ... done
[18:06:13.492] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:13.492] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[18:06:13.493] getGlobalsAndPackages() ...
[18:06:13.493] Searching for globals...
[18:06:13.496] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:13.496] Searching for globals ... DONE
[18:06:13.496] Resolving globals: FALSE
[18:06:13.497] 
[18:06:13.497] 
[18:06:13.497] getGlobalsAndPackages() ... DONE
[18:06:13.498] run() for ‘Future’ ...
[18:06:13.498] - state: ‘created’
[18:06:13.498] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:13.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:13.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:13.524]   - Field: ‘node’
[18:06:13.524]   - Field: ‘label’
[18:06:13.524]   - Field: ‘local’
[18:06:13.524]   - Field: ‘owner’
[18:06:13.525]   - Field: ‘envir’
[18:06:13.525]   - Field: ‘workers’
[18:06:13.525]   - Field: ‘packages’
[18:06:13.525]   - Field: ‘gc’
[18:06:13.526]   - Field: ‘conditions’
[18:06:13.526]   - Field: ‘persistent’
[18:06:13.526]   - Field: ‘expr’
[18:06:13.526]   - Field: ‘uuid’
[18:06:13.526]   - Field: ‘seed’
[18:06:13.527]   - Field: ‘version’
[18:06:13.527]   - Field: ‘result’
[18:06:13.527]   - Field: ‘asynchronous’
[18:06:13.527]   - Field: ‘calls’
[18:06:13.528]   - Field: ‘globals’
[18:06:13.528]   - Field: ‘stdout’
[18:06:13.528]   - Field: ‘earlySignal’
[18:06:13.528]   - Field: ‘lazy’
[18:06:13.528]   - Field: ‘state’
[18:06:13.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:13.529] - Launch lazy future ...
[18:06:13.529] Packages needed by the future expression (n = 0): <none>
[18:06:13.530] Packages needed by future strategies (n = 0): <none>
[18:06:13.531] {
[18:06:13.531]     {
[18:06:13.531]         {
[18:06:13.531]             ...future.startTime <- base::Sys.time()
[18:06:13.531]             {
[18:06:13.531]                 {
[18:06:13.531]                   {
[18:06:13.531]                     {
[18:06:13.531]                       base::local({
[18:06:13.531]                         has_future <- base::requireNamespace("future", 
[18:06:13.531]                           quietly = TRUE)
[18:06:13.531]                         if (has_future) {
[18:06:13.531]                           ns <- base::getNamespace("future")
[18:06:13.531]                           version <- ns[[".package"]][["version"]]
[18:06:13.531]                           if (is.null(version)) 
[18:06:13.531]                             version <- utils::packageVersion("future")
[18:06:13.531]                         }
[18:06:13.531]                         else {
[18:06:13.531]                           version <- NULL
[18:06:13.531]                         }
[18:06:13.531]                         if (!has_future || version < "1.8.0") {
[18:06:13.531]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:13.531]                             "", base::R.version$version.string), 
[18:06:13.531]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:13.531]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:13.531]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:13.531]                               "release", "version")], collapse = " "), 
[18:06:13.531]                             hostname = base::Sys.info()[["nodename"]])
[18:06:13.531]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:13.531]                             info)
[18:06:13.531]                           info <- base::paste(info, collapse = "; ")
[18:06:13.531]                           if (!has_future) {
[18:06:13.531]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:13.531]                               info)
[18:06:13.531]                           }
[18:06:13.531]                           else {
[18:06:13.531]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:13.531]                               info, version)
[18:06:13.531]                           }
[18:06:13.531]                           base::stop(msg)
[18:06:13.531]                         }
[18:06:13.531]                       })
[18:06:13.531]                     }
[18:06:13.531]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:13.531]                     base::options(mc.cores = 1L)
[18:06:13.531]                   }
[18:06:13.531]                   ...future.strategy.old <- future::plan("list")
[18:06:13.531]                   options(future.plan = NULL)
[18:06:13.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:13.531]                 }
[18:06:13.531]                 ...future.workdir <- getwd()
[18:06:13.531]             }
[18:06:13.531]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:13.531]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:13.531]         }
[18:06:13.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:13.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:13.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:13.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:13.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:13.531]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:13.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:13.531]             base::names(...future.oldOptions))
[18:06:13.531]     }
[18:06:13.531]     if (FALSE) {
[18:06:13.531]     }
[18:06:13.531]     else {
[18:06:13.531]         if (TRUE) {
[18:06:13.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:13.531]                 open = "w")
[18:06:13.531]         }
[18:06:13.531]         else {
[18:06:13.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:13.531]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:13.531]         }
[18:06:13.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:13.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:13.531]             base::sink(type = "output", split = FALSE)
[18:06:13.531]             base::close(...future.stdout)
[18:06:13.531]         }, add = TRUE)
[18:06:13.531]     }
[18:06:13.531]     ...future.frame <- base::sys.nframe()
[18:06:13.531]     ...future.conditions <- base::list()
[18:06:13.531]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:13.531]     if (FALSE) {
[18:06:13.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:13.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:13.531]     }
[18:06:13.531]     ...future.result <- base::tryCatch({
[18:06:13.531]         base::withCallingHandlers({
[18:06:13.531]             ...future.value <- base::withVisible(base::local({
[18:06:13.531]                 ...future.makeSendCondition <- base::local({
[18:06:13.531]                   sendCondition <- NULL
[18:06:13.531]                   function(frame = 1L) {
[18:06:13.531]                     if (is.function(sendCondition)) 
[18:06:13.531]                       return(sendCondition)
[18:06:13.531]                     ns <- getNamespace("parallel")
[18:06:13.531]                     if (exists("sendData", mode = "function", 
[18:06:13.531]                       envir = ns)) {
[18:06:13.531]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:13.531]                         envir = ns)
[18:06:13.531]                       envir <- sys.frame(frame)
[18:06:13.531]                       master <- NULL
[18:06:13.531]                       while (!identical(envir, .GlobalEnv) && 
[18:06:13.531]                         !identical(envir, emptyenv())) {
[18:06:13.531]                         if (exists("master", mode = "list", envir = envir, 
[18:06:13.531]                           inherits = FALSE)) {
[18:06:13.531]                           master <- get("master", mode = "list", 
[18:06:13.531]                             envir = envir, inherits = FALSE)
[18:06:13.531]                           if (inherits(master, c("SOCKnode", 
[18:06:13.531]                             "SOCK0node"))) {
[18:06:13.531]                             sendCondition <<- function(cond) {
[18:06:13.531]                               data <- list(type = "VALUE", value = cond, 
[18:06:13.531]                                 success = TRUE)
[18:06:13.531]                               parallel_sendData(master, data)
[18:06:13.531]                             }
[18:06:13.531]                             return(sendCondition)
[18:06:13.531]                           }
[18:06:13.531]                         }
[18:06:13.531]                         frame <- frame + 1L
[18:06:13.531]                         envir <- sys.frame(frame)
[18:06:13.531]                       }
[18:06:13.531]                     }
[18:06:13.531]                     sendCondition <<- function(cond) NULL
[18:06:13.531]                   }
[18:06:13.531]                 })
[18:06:13.531]                 withCallingHandlers({
[18:06:13.531]                   {
[18:06:13.531]                     Sys.sleep(0.5)
[18:06:13.531]                     list(a = 1, b = 42L)
[18:06:13.531]                   }
[18:06:13.531]                 }, immediateCondition = function(cond) {
[18:06:13.531]                   sendCondition <- ...future.makeSendCondition()
[18:06:13.531]                   sendCondition(cond)
[18:06:13.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.531]                   {
[18:06:13.531]                     inherits <- base::inherits
[18:06:13.531]                     invokeRestart <- base::invokeRestart
[18:06:13.531]                     is.null <- base::is.null
[18:06:13.531]                     muffled <- FALSE
[18:06:13.531]                     if (inherits(cond, "message")) {
[18:06:13.531]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:13.531]                       if (muffled) 
[18:06:13.531]                         invokeRestart("muffleMessage")
[18:06:13.531]                     }
[18:06:13.531]                     else if (inherits(cond, "warning")) {
[18:06:13.531]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:13.531]                       if (muffled) 
[18:06:13.531]                         invokeRestart("muffleWarning")
[18:06:13.531]                     }
[18:06:13.531]                     else if (inherits(cond, "condition")) {
[18:06:13.531]                       if (!is.null(pattern)) {
[18:06:13.531]                         computeRestarts <- base::computeRestarts
[18:06:13.531]                         grepl <- base::grepl
[18:06:13.531]                         restarts <- computeRestarts(cond)
[18:06:13.531]                         for (restart in restarts) {
[18:06:13.531]                           name <- restart$name
[18:06:13.531]                           if (is.null(name)) 
[18:06:13.531]                             next
[18:06:13.531]                           if (!grepl(pattern, name)) 
[18:06:13.531]                             next
[18:06:13.531]                           invokeRestart(restart)
[18:06:13.531]                           muffled <- TRUE
[18:06:13.531]                           break
[18:06:13.531]                         }
[18:06:13.531]                       }
[18:06:13.531]                     }
[18:06:13.531]                     invisible(muffled)
[18:06:13.531]                   }
[18:06:13.531]                   muffleCondition(cond)
[18:06:13.531]                 })
[18:06:13.531]             }))
[18:06:13.531]             future::FutureResult(value = ...future.value$value, 
[18:06:13.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.531]                   ...future.rng), globalenv = if (FALSE) 
[18:06:13.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:13.531]                     ...future.globalenv.names))
[18:06:13.531]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:13.531]         }, condition = base::local({
[18:06:13.531]             c <- base::c
[18:06:13.531]             inherits <- base::inherits
[18:06:13.531]             invokeRestart <- base::invokeRestart
[18:06:13.531]             length <- base::length
[18:06:13.531]             list <- base::list
[18:06:13.531]             seq.int <- base::seq.int
[18:06:13.531]             signalCondition <- base::signalCondition
[18:06:13.531]             sys.calls <- base::sys.calls
[18:06:13.531]             `[[` <- base::`[[`
[18:06:13.531]             `+` <- base::`+`
[18:06:13.531]             `<<-` <- base::`<<-`
[18:06:13.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:13.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:13.531]                   3L)]
[18:06:13.531]             }
[18:06:13.531]             function(cond) {
[18:06:13.531]                 is_error <- inherits(cond, "error")
[18:06:13.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:13.531]                   NULL)
[18:06:13.531]                 if (is_error) {
[18:06:13.531]                   sessionInformation <- function() {
[18:06:13.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:13.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:13.531]                       search = base::search(), system = base::Sys.info())
[18:06:13.531]                   }
[18:06:13.531]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:13.531]                     cond$call), session = sessionInformation(), 
[18:06:13.531]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:13.531]                   signalCondition(cond)
[18:06:13.531]                 }
[18:06:13.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:13.531]                 "immediateCondition"))) {
[18:06:13.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:13.531]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:13.531]                   if (TRUE && !signal) {
[18:06:13.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.531]                     {
[18:06:13.531]                       inherits <- base::inherits
[18:06:13.531]                       invokeRestart <- base::invokeRestart
[18:06:13.531]                       is.null <- base::is.null
[18:06:13.531]                       muffled <- FALSE
[18:06:13.531]                       if (inherits(cond, "message")) {
[18:06:13.531]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.531]                         if (muffled) 
[18:06:13.531]                           invokeRestart("muffleMessage")
[18:06:13.531]                       }
[18:06:13.531]                       else if (inherits(cond, "warning")) {
[18:06:13.531]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.531]                         if (muffled) 
[18:06:13.531]                           invokeRestart("muffleWarning")
[18:06:13.531]                       }
[18:06:13.531]                       else if (inherits(cond, "condition")) {
[18:06:13.531]                         if (!is.null(pattern)) {
[18:06:13.531]                           computeRestarts <- base::computeRestarts
[18:06:13.531]                           grepl <- base::grepl
[18:06:13.531]                           restarts <- computeRestarts(cond)
[18:06:13.531]                           for (restart in restarts) {
[18:06:13.531]                             name <- restart$name
[18:06:13.531]                             if (is.null(name)) 
[18:06:13.531]                               next
[18:06:13.531]                             if (!grepl(pattern, name)) 
[18:06:13.531]                               next
[18:06:13.531]                             invokeRestart(restart)
[18:06:13.531]                             muffled <- TRUE
[18:06:13.531]                             break
[18:06:13.531]                           }
[18:06:13.531]                         }
[18:06:13.531]                       }
[18:06:13.531]                       invisible(muffled)
[18:06:13.531]                     }
[18:06:13.531]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.531]                   }
[18:06:13.531]                 }
[18:06:13.531]                 else {
[18:06:13.531]                   if (TRUE) {
[18:06:13.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.531]                     {
[18:06:13.531]                       inherits <- base::inherits
[18:06:13.531]                       invokeRestart <- base::invokeRestart
[18:06:13.531]                       is.null <- base::is.null
[18:06:13.531]                       muffled <- FALSE
[18:06:13.531]                       if (inherits(cond, "message")) {
[18:06:13.531]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.531]                         if (muffled) 
[18:06:13.531]                           invokeRestart("muffleMessage")
[18:06:13.531]                       }
[18:06:13.531]                       else if (inherits(cond, "warning")) {
[18:06:13.531]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.531]                         if (muffled) 
[18:06:13.531]                           invokeRestart("muffleWarning")
[18:06:13.531]                       }
[18:06:13.531]                       else if (inherits(cond, "condition")) {
[18:06:13.531]                         if (!is.null(pattern)) {
[18:06:13.531]                           computeRestarts <- base::computeRestarts
[18:06:13.531]                           grepl <- base::grepl
[18:06:13.531]                           restarts <- computeRestarts(cond)
[18:06:13.531]                           for (restart in restarts) {
[18:06:13.531]                             name <- restart$name
[18:06:13.531]                             if (is.null(name)) 
[18:06:13.531]                               next
[18:06:13.531]                             if (!grepl(pattern, name)) 
[18:06:13.531]                               next
[18:06:13.531]                             invokeRestart(restart)
[18:06:13.531]                             muffled <- TRUE
[18:06:13.531]                             break
[18:06:13.531]                           }
[18:06:13.531]                         }
[18:06:13.531]                       }
[18:06:13.531]                       invisible(muffled)
[18:06:13.531]                     }
[18:06:13.531]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.531]                   }
[18:06:13.531]                 }
[18:06:13.531]             }
[18:06:13.531]         }))
[18:06:13.531]     }, error = function(ex) {
[18:06:13.531]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:13.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.531]                 ...future.rng), started = ...future.startTime, 
[18:06:13.531]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:13.531]             version = "1.8"), class = "FutureResult")
[18:06:13.531]     }, finally = {
[18:06:13.531]         if (!identical(...future.workdir, getwd())) 
[18:06:13.531]             setwd(...future.workdir)
[18:06:13.531]         {
[18:06:13.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:13.531]                 ...future.oldOptions$nwarnings <- NULL
[18:06:13.531]             }
[18:06:13.531]             base::options(...future.oldOptions)
[18:06:13.531]             if (.Platform$OS.type == "windows") {
[18:06:13.531]                 old_names <- names(...future.oldEnvVars)
[18:06:13.531]                 envs <- base::Sys.getenv()
[18:06:13.531]                 names <- names(envs)
[18:06:13.531]                 common <- intersect(names, old_names)
[18:06:13.531]                 added <- setdiff(names, old_names)
[18:06:13.531]                 removed <- setdiff(old_names, names)
[18:06:13.531]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:13.531]                   envs[common]]
[18:06:13.531]                 NAMES <- toupper(changed)
[18:06:13.531]                 args <- list()
[18:06:13.531]                 for (kk in seq_along(NAMES)) {
[18:06:13.531]                   name <- changed[[kk]]
[18:06:13.531]                   NAME <- NAMES[[kk]]
[18:06:13.531]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.531]                     next
[18:06:13.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.531]                 }
[18:06:13.531]                 NAMES <- toupper(added)
[18:06:13.531]                 for (kk in seq_along(NAMES)) {
[18:06:13.531]                   name <- added[[kk]]
[18:06:13.531]                   NAME <- NAMES[[kk]]
[18:06:13.531]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.531]                     next
[18:06:13.531]                   args[[name]] <- ""
[18:06:13.531]                 }
[18:06:13.531]                 NAMES <- toupper(removed)
[18:06:13.531]                 for (kk in seq_along(NAMES)) {
[18:06:13.531]                   name <- removed[[kk]]
[18:06:13.531]                   NAME <- NAMES[[kk]]
[18:06:13.531]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.531]                     next
[18:06:13.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.531]                 }
[18:06:13.531]                 if (length(args) > 0) 
[18:06:13.531]                   base::do.call(base::Sys.setenv, args = args)
[18:06:13.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:13.531]             }
[18:06:13.531]             else {
[18:06:13.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:13.531]             }
[18:06:13.531]             {
[18:06:13.531]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:13.531]                   0L) {
[18:06:13.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:13.531]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:13.531]                   base::options(opts)
[18:06:13.531]                 }
[18:06:13.531]                 {
[18:06:13.531]                   {
[18:06:13.531]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:13.531]                     NULL
[18:06:13.531]                   }
[18:06:13.531]                   options(future.plan = NULL)
[18:06:13.531]                   if (is.na(NA_character_)) 
[18:06:13.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:13.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:13.531]                     .init = FALSE)
[18:06:13.531]                 }
[18:06:13.531]             }
[18:06:13.531]         }
[18:06:13.531]     })
[18:06:13.531]     if (TRUE) {
[18:06:13.531]         base::sink(type = "output", split = FALSE)
[18:06:13.531]         if (TRUE) {
[18:06:13.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:13.531]         }
[18:06:13.531]         else {
[18:06:13.531]             ...future.result["stdout"] <- base::list(NULL)
[18:06:13.531]         }
[18:06:13.531]         base::close(...future.stdout)
[18:06:13.531]         ...future.stdout <- NULL
[18:06:13.531]     }
[18:06:13.531]     ...future.result$conditions <- ...future.conditions
[18:06:13.531]     ...future.result$finished <- base::Sys.time()
[18:06:13.531]     ...future.result
[18:06:13.531] }
[18:06:13.537] MultisessionFuture started
[18:06:13.537] - Launch lazy future ... done
[18:06:13.537] run() for ‘MultisessionFuture’ ... done
[18:06:13.538] getGlobalsAndPackages() ...
[18:06:13.538] Searching for globals...
[18:06:13.540] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:13.541] Searching for globals ... DONE
[18:06:13.541] Resolving globals: FALSE
[18:06:13.542] 
[18:06:13.542] 
[18:06:13.542] getGlobalsAndPackages() ... DONE
- w/ exception ...
[18:06:13.543] getGlobalsAndPackages() ...
[18:06:13.543] Searching for globals...
[18:06:13.544] - globals found: [2] ‘list’, ‘stop’
[18:06:13.545] Searching for globals ... DONE
[18:06:13.545] Resolving globals: FALSE
[18:06:13.546] 
[18:06:13.546] 
[18:06:13.546] getGlobalsAndPackages() ... DONE
[18:06:13.547] run() for ‘Future’ ...
[18:06:13.547] - state: ‘created’
[18:06:13.547] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:13.569] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:13.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:13.570]   - Field: ‘node’
[18:06:13.570]   - Field: ‘label’
[18:06:13.570]   - Field: ‘local’
[18:06:13.571]   - Field: ‘owner’
[18:06:13.571]   - Field: ‘envir’
[18:06:13.571]   - Field: ‘workers’
[18:06:13.571]   - Field: ‘packages’
[18:06:13.571]   - Field: ‘gc’
[18:06:13.572]   - Field: ‘conditions’
[18:06:13.572]   - Field: ‘persistent’
[18:06:13.572]   - Field: ‘expr’
[18:06:13.572]   - Field: ‘uuid’
[18:06:13.572]   - Field: ‘seed’
[18:06:13.573]   - Field: ‘version’
[18:06:13.573]   - Field: ‘result’
[18:06:13.573]   - Field: ‘asynchronous’
[18:06:13.573]   - Field: ‘calls’
[18:06:13.573]   - Field: ‘globals’
[18:06:13.574]   - Field: ‘stdout’
[18:06:13.574]   - Field: ‘earlySignal’
[18:06:13.574]   - Field: ‘lazy’
[18:06:13.574]   - Field: ‘state’
[18:06:13.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:13.575] - Launch lazy future ...
[18:06:13.575] Packages needed by the future expression (n = 0): <none>
[18:06:13.575] Packages needed by future strategies (n = 0): <none>
[18:06:13.576] {
[18:06:13.576]     {
[18:06:13.576]         {
[18:06:13.576]             ...future.startTime <- base::Sys.time()
[18:06:13.576]             {
[18:06:13.576]                 {
[18:06:13.576]                   {
[18:06:13.576]                     {
[18:06:13.576]                       base::local({
[18:06:13.576]                         has_future <- base::requireNamespace("future", 
[18:06:13.576]                           quietly = TRUE)
[18:06:13.576]                         if (has_future) {
[18:06:13.576]                           ns <- base::getNamespace("future")
[18:06:13.576]                           version <- ns[[".package"]][["version"]]
[18:06:13.576]                           if (is.null(version)) 
[18:06:13.576]                             version <- utils::packageVersion("future")
[18:06:13.576]                         }
[18:06:13.576]                         else {
[18:06:13.576]                           version <- NULL
[18:06:13.576]                         }
[18:06:13.576]                         if (!has_future || version < "1.8.0") {
[18:06:13.576]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:13.576]                             "", base::R.version$version.string), 
[18:06:13.576]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:13.576]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:13.576]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:13.576]                               "release", "version")], collapse = " "), 
[18:06:13.576]                             hostname = base::Sys.info()[["nodename"]])
[18:06:13.576]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:13.576]                             info)
[18:06:13.576]                           info <- base::paste(info, collapse = "; ")
[18:06:13.576]                           if (!has_future) {
[18:06:13.576]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:13.576]                               info)
[18:06:13.576]                           }
[18:06:13.576]                           else {
[18:06:13.576]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:13.576]                               info, version)
[18:06:13.576]                           }
[18:06:13.576]                           base::stop(msg)
[18:06:13.576]                         }
[18:06:13.576]                       })
[18:06:13.576]                     }
[18:06:13.576]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:13.576]                     base::options(mc.cores = 1L)
[18:06:13.576]                   }
[18:06:13.576]                   ...future.strategy.old <- future::plan("list")
[18:06:13.576]                   options(future.plan = NULL)
[18:06:13.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:13.576]                 }
[18:06:13.576]                 ...future.workdir <- getwd()
[18:06:13.576]             }
[18:06:13.576]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:13.576]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:13.576]         }
[18:06:13.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:13.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:13.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:13.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:13.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:13.576]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:13.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:13.576]             base::names(...future.oldOptions))
[18:06:13.576]     }
[18:06:13.576]     if (FALSE) {
[18:06:13.576]     }
[18:06:13.576]     else {
[18:06:13.576]         if (TRUE) {
[18:06:13.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:13.576]                 open = "w")
[18:06:13.576]         }
[18:06:13.576]         else {
[18:06:13.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:13.576]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:13.576]         }
[18:06:13.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:13.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:13.576]             base::sink(type = "output", split = FALSE)
[18:06:13.576]             base::close(...future.stdout)
[18:06:13.576]         }, add = TRUE)
[18:06:13.576]     }
[18:06:13.576]     ...future.frame <- base::sys.nframe()
[18:06:13.576]     ...future.conditions <- base::list()
[18:06:13.576]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:13.576]     if (FALSE) {
[18:06:13.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:13.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:13.576]     }
[18:06:13.576]     ...future.result <- base::tryCatch({
[18:06:13.576]         base::withCallingHandlers({
[18:06:13.576]             ...future.value <- base::withVisible(base::local({
[18:06:13.576]                 ...future.makeSendCondition <- base::local({
[18:06:13.576]                   sendCondition <- NULL
[18:06:13.576]                   function(frame = 1L) {
[18:06:13.576]                     if (is.function(sendCondition)) 
[18:06:13.576]                       return(sendCondition)
[18:06:13.576]                     ns <- getNamespace("parallel")
[18:06:13.576]                     if (exists("sendData", mode = "function", 
[18:06:13.576]                       envir = ns)) {
[18:06:13.576]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:13.576]                         envir = ns)
[18:06:13.576]                       envir <- sys.frame(frame)
[18:06:13.576]                       master <- NULL
[18:06:13.576]                       while (!identical(envir, .GlobalEnv) && 
[18:06:13.576]                         !identical(envir, emptyenv())) {
[18:06:13.576]                         if (exists("master", mode = "list", envir = envir, 
[18:06:13.576]                           inherits = FALSE)) {
[18:06:13.576]                           master <- get("master", mode = "list", 
[18:06:13.576]                             envir = envir, inherits = FALSE)
[18:06:13.576]                           if (inherits(master, c("SOCKnode", 
[18:06:13.576]                             "SOCK0node"))) {
[18:06:13.576]                             sendCondition <<- function(cond) {
[18:06:13.576]                               data <- list(type = "VALUE", value = cond, 
[18:06:13.576]                                 success = TRUE)
[18:06:13.576]                               parallel_sendData(master, data)
[18:06:13.576]                             }
[18:06:13.576]                             return(sendCondition)
[18:06:13.576]                           }
[18:06:13.576]                         }
[18:06:13.576]                         frame <- frame + 1L
[18:06:13.576]                         envir <- sys.frame(frame)
[18:06:13.576]                       }
[18:06:13.576]                     }
[18:06:13.576]                     sendCondition <<- function(cond) NULL
[18:06:13.576]                   }
[18:06:13.576]                 })
[18:06:13.576]                 withCallingHandlers({
[18:06:13.576]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:13.576]                 }, immediateCondition = function(cond) {
[18:06:13.576]                   sendCondition <- ...future.makeSendCondition()
[18:06:13.576]                   sendCondition(cond)
[18:06:13.576]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.576]                   {
[18:06:13.576]                     inherits <- base::inherits
[18:06:13.576]                     invokeRestart <- base::invokeRestart
[18:06:13.576]                     is.null <- base::is.null
[18:06:13.576]                     muffled <- FALSE
[18:06:13.576]                     if (inherits(cond, "message")) {
[18:06:13.576]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:13.576]                       if (muffled) 
[18:06:13.576]                         invokeRestart("muffleMessage")
[18:06:13.576]                     }
[18:06:13.576]                     else if (inherits(cond, "warning")) {
[18:06:13.576]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:13.576]                       if (muffled) 
[18:06:13.576]                         invokeRestart("muffleWarning")
[18:06:13.576]                     }
[18:06:13.576]                     else if (inherits(cond, "condition")) {
[18:06:13.576]                       if (!is.null(pattern)) {
[18:06:13.576]                         computeRestarts <- base::computeRestarts
[18:06:13.576]                         grepl <- base::grepl
[18:06:13.576]                         restarts <- computeRestarts(cond)
[18:06:13.576]                         for (restart in restarts) {
[18:06:13.576]                           name <- restart$name
[18:06:13.576]                           if (is.null(name)) 
[18:06:13.576]                             next
[18:06:13.576]                           if (!grepl(pattern, name)) 
[18:06:13.576]                             next
[18:06:13.576]                           invokeRestart(restart)
[18:06:13.576]                           muffled <- TRUE
[18:06:13.576]                           break
[18:06:13.576]                         }
[18:06:13.576]                       }
[18:06:13.576]                     }
[18:06:13.576]                     invisible(muffled)
[18:06:13.576]                   }
[18:06:13.576]                   muffleCondition(cond)
[18:06:13.576]                 })
[18:06:13.576]             }))
[18:06:13.576]             future::FutureResult(value = ...future.value$value, 
[18:06:13.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.576]                   ...future.rng), globalenv = if (FALSE) 
[18:06:13.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:13.576]                     ...future.globalenv.names))
[18:06:13.576]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:13.576]         }, condition = base::local({
[18:06:13.576]             c <- base::c
[18:06:13.576]             inherits <- base::inherits
[18:06:13.576]             invokeRestart <- base::invokeRestart
[18:06:13.576]             length <- base::length
[18:06:13.576]             list <- base::list
[18:06:13.576]             seq.int <- base::seq.int
[18:06:13.576]             signalCondition <- base::signalCondition
[18:06:13.576]             sys.calls <- base::sys.calls
[18:06:13.576]             `[[` <- base::`[[`
[18:06:13.576]             `+` <- base::`+`
[18:06:13.576]             `<<-` <- base::`<<-`
[18:06:13.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:13.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:13.576]                   3L)]
[18:06:13.576]             }
[18:06:13.576]             function(cond) {
[18:06:13.576]                 is_error <- inherits(cond, "error")
[18:06:13.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:13.576]                   NULL)
[18:06:13.576]                 if (is_error) {
[18:06:13.576]                   sessionInformation <- function() {
[18:06:13.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:13.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:13.576]                       search = base::search(), system = base::Sys.info())
[18:06:13.576]                   }
[18:06:13.576]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:13.576]                     cond$call), session = sessionInformation(), 
[18:06:13.576]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:13.576]                   signalCondition(cond)
[18:06:13.576]                 }
[18:06:13.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:13.576]                 "immediateCondition"))) {
[18:06:13.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:13.576]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:13.576]                   if (TRUE && !signal) {
[18:06:13.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.576]                     {
[18:06:13.576]                       inherits <- base::inherits
[18:06:13.576]                       invokeRestart <- base::invokeRestart
[18:06:13.576]                       is.null <- base::is.null
[18:06:13.576]                       muffled <- FALSE
[18:06:13.576]                       if (inherits(cond, "message")) {
[18:06:13.576]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.576]                         if (muffled) 
[18:06:13.576]                           invokeRestart("muffleMessage")
[18:06:13.576]                       }
[18:06:13.576]                       else if (inherits(cond, "warning")) {
[18:06:13.576]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.576]                         if (muffled) 
[18:06:13.576]                           invokeRestart("muffleWarning")
[18:06:13.576]                       }
[18:06:13.576]                       else if (inherits(cond, "condition")) {
[18:06:13.576]                         if (!is.null(pattern)) {
[18:06:13.576]                           computeRestarts <- base::computeRestarts
[18:06:13.576]                           grepl <- base::grepl
[18:06:13.576]                           restarts <- computeRestarts(cond)
[18:06:13.576]                           for (restart in restarts) {
[18:06:13.576]                             name <- restart$name
[18:06:13.576]                             if (is.null(name)) 
[18:06:13.576]                               next
[18:06:13.576]                             if (!grepl(pattern, name)) 
[18:06:13.576]                               next
[18:06:13.576]                             invokeRestart(restart)
[18:06:13.576]                             muffled <- TRUE
[18:06:13.576]                             break
[18:06:13.576]                           }
[18:06:13.576]                         }
[18:06:13.576]                       }
[18:06:13.576]                       invisible(muffled)
[18:06:13.576]                     }
[18:06:13.576]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.576]                   }
[18:06:13.576]                 }
[18:06:13.576]                 else {
[18:06:13.576]                   if (TRUE) {
[18:06:13.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.576]                     {
[18:06:13.576]                       inherits <- base::inherits
[18:06:13.576]                       invokeRestart <- base::invokeRestart
[18:06:13.576]                       is.null <- base::is.null
[18:06:13.576]                       muffled <- FALSE
[18:06:13.576]                       if (inherits(cond, "message")) {
[18:06:13.576]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.576]                         if (muffled) 
[18:06:13.576]                           invokeRestart("muffleMessage")
[18:06:13.576]                       }
[18:06:13.576]                       else if (inherits(cond, "warning")) {
[18:06:13.576]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.576]                         if (muffled) 
[18:06:13.576]                           invokeRestart("muffleWarning")
[18:06:13.576]                       }
[18:06:13.576]                       else if (inherits(cond, "condition")) {
[18:06:13.576]                         if (!is.null(pattern)) {
[18:06:13.576]                           computeRestarts <- base::computeRestarts
[18:06:13.576]                           grepl <- base::grepl
[18:06:13.576]                           restarts <- computeRestarts(cond)
[18:06:13.576]                           for (restart in restarts) {
[18:06:13.576]                             name <- restart$name
[18:06:13.576]                             if (is.null(name)) 
[18:06:13.576]                               next
[18:06:13.576]                             if (!grepl(pattern, name)) 
[18:06:13.576]                               next
[18:06:13.576]                             invokeRestart(restart)
[18:06:13.576]                             muffled <- TRUE
[18:06:13.576]                             break
[18:06:13.576]                           }
[18:06:13.576]                         }
[18:06:13.576]                       }
[18:06:13.576]                       invisible(muffled)
[18:06:13.576]                     }
[18:06:13.576]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.576]                   }
[18:06:13.576]                 }
[18:06:13.576]             }
[18:06:13.576]         }))
[18:06:13.576]     }, error = function(ex) {
[18:06:13.576]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:13.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.576]                 ...future.rng), started = ...future.startTime, 
[18:06:13.576]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:13.576]             version = "1.8"), class = "FutureResult")
[18:06:13.576]     }, finally = {
[18:06:13.576]         if (!identical(...future.workdir, getwd())) 
[18:06:13.576]             setwd(...future.workdir)
[18:06:13.576]         {
[18:06:13.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:13.576]                 ...future.oldOptions$nwarnings <- NULL
[18:06:13.576]             }
[18:06:13.576]             base::options(...future.oldOptions)
[18:06:13.576]             if (.Platform$OS.type == "windows") {
[18:06:13.576]                 old_names <- names(...future.oldEnvVars)
[18:06:13.576]                 envs <- base::Sys.getenv()
[18:06:13.576]                 names <- names(envs)
[18:06:13.576]                 common <- intersect(names, old_names)
[18:06:13.576]                 added <- setdiff(names, old_names)
[18:06:13.576]                 removed <- setdiff(old_names, names)
[18:06:13.576]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:13.576]                   envs[common]]
[18:06:13.576]                 NAMES <- toupper(changed)
[18:06:13.576]                 args <- list()
[18:06:13.576]                 for (kk in seq_along(NAMES)) {
[18:06:13.576]                   name <- changed[[kk]]
[18:06:13.576]                   NAME <- NAMES[[kk]]
[18:06:13.576]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.576]                     next
[18:06:13.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.576]                 }
[18:06:13.576]                 NAMES <- toupper(added)
[18:06:13.576]                 for (kk in seq_along(NAMES)) {
[18:06:13.576]                   name <- added[[kk]]
[18:06:13.576]                   NAME <- NAMES[[kk]]
[18:06:13.576]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.576]                     next
[18:06:13.576]                   args[[name]] <- ""
[18:06:13.576]                 }
[18:06:13.576]                 NAMES <- toupper(removed)
[18:06:13.576]                 for (kk in seq_along(NAMES)) {
[18:06:13.576]                   name <- removed[[kk]]
[18:06:13.576]                   NAME <- NAMES[[kk]]
[18:06:13.576]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.576]                     next
[18:06:13.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.576]                 }
[18:06:13.576]                 if (length(args) > 0) 
[18:06:13.576]                   base::do.call(base::Sys.setenv, args = args)
[18:06:13.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:13.576]             }
[18:06:13.576]             else {
[18:06:13.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:13.576]             }
[18:06:13.576]             {
[18:06:13.576]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:13.576]                   0L) {
[18:06:13.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:13.576]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:13.576]                   base::options(opts)
[18:06:13.576]                 }
[18:06:13.576]                 {
[18:06:13.576]                   {
[18:06:13.576]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:13.576]                     NULL
[18:06:13.576]                   }
[18:06:13.576]                   options(future.plan = NULL)
[18:06:13.576]                   if (is.na(NA_character_)) 
[18:06:13.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:13.576]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:13.576]                     .init = FALSE)
[18:06:13.576]                 }
[18:06:13.576]             }
[18:06:13.576]         }
[18:06:13.576]     })
[18:06:13.576]     if (TRUE) {
[18:06:13.576]         base::sink(type = "output", split = FALSE)
[18:06:13.576]         if (TRUE) {
[18:06:13.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:13.576]         }
[18:06:13.576]         else {
[18:06:13.576]             ...future.result["stdout"] <- base::list(NULL)
[18:06:13.576]         }
[18:06:13.576]         base::close(...future.stdout)
[18:06:13.576]         ...future.stdout <- NULL
[18:06:13.576]     }
[18:06:13.576]     ...future.result$conditions <- ...future.conditions
[18:06:13.576]     ...future.result$finished <- base::Sys.time()
[18:06:13.576]     ...future.result
[18:06:13.576] }
[18:06:13.677] MultisessionFuture started
[18:06:13.677] - Launch lazy future ... done
[18:06:13.677] run() for ‘MultisessionFuture’ ... done
[18:06:13.678] getGlobalsAndPackages() ...
[18:06:13.678] Searching for globals...
[18:06:13.679] - globals found: [2] ‘list’, ‘stop’
[18:06:13.679] Searching for globals ... DONE
[18:06:13.680] Resolving globals: FALSE
[18:06:13.680] 
[18:06:13.681] 
[18:06:13.681] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[18:06:13.682] getGlobalsAndPackages() ...
[18:06:13.682] Searching for globals...
[18:06:13.684] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:13.684] Searching for globals ... DONE
[18:06:13.685] Resolving globals: FALSE
[18:06:13.685] 
[18:06:13.685] 
[18:06:13.686] getGlobalsAndPackages() ... DONE
[18:06:13.686] run() for ‘Future’ ...
[18:06:13.686] - state: ‘created’
[18:06:13.687] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:13.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:13.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:13.711]   - Field: ‘node’
[18:06:13.712]   - Field: ‘label’
[18:06:13.712]   - Field: ‘local’
[18:06:13.712]   - Field: ‘owner’
[18:06:13.712]   - Field: ‘envir’
[18:06:13.713]   - Field: ‘workers’
[18:06:13.713]   - Field: ‘packages’
[18:06:13.713]   - Field: ‘gc’
[18:06:13.713]   - Field: ‘conditions’
[18:06:13.713]   - Field: ‘persistent’
[18:06:13.714]   - Field: ‘expr’
[18:06:13.714]   - Field: ‘uuid’
[18:06:13.714]   - Field: ‘seed’
[18:06:13.715]   - Field: ‘version’
[18:06:13.715]   - Field: ‘result’
[18:06:13.715]   - Field: ‘asynchronous’
[18:06:13.715]   - Field: ‘calls’
[18:06:13.715]   - Field: ‘globals’
[18:06:13.716]   - Field: ‘stdout’
[18:06:13.716]   - Field: ‘earlySignal’
[18:06:13.716]   - Field: ‘lazy’
[18:06:13.716]   - Field: ‘state’
[18:06:13.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:13.717] - Launch lazy future ...
[18:06:13.717] Packages needed by the future expression (n = 0): <none>
[18:06:13.717] Packages needed by future strategies (n = 0): <none>
[18:06:13.718] {
[18:06:13.718]     {
[18:06:13.718]         {
[18:06:13.718]             ...future.startTime <- base::Sys.time()
[18:06:13.718]             {
[18:06:13.718]                 {
[18:06:13.718]                   {
[18:06:13.718]                     {
[18:06:13.718]                       base::local({
[18:06:13.718]                         has_future <- base::requireNamespace("future", 
[18:06:13.718]                           quietly = TRUE)
[18:06:13.718]                         if (has_future) {
[18:06:13.718]                           ns <- base::getNamespace("future")
[18:06:13.718]                           version <- ns[[".package"]][["version"]]
[18:06:13.718]                           if (is.null(version)) 
[18:06:13.718]                             version <- utils::packageVersion("future")
[18:06:13.718]                         }
[18:06:13.718]                         else {
[18:06:13.718]                           version <- NULL
[18:06:13.718]                         }
[18:06:13.718]                         if (!has_future || version < "1.8.0") {
[18:06:13.718]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:13.718]                             "", base::R.version$version.string), 
[18:06:13.718]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:13.718]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:13.718]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:13.718]                               "release", "version")], collapse = " "), 
[18:06:13.718]                             hostname = base::Sys.info()[["nodename"]])
[18:06:13.718]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:13.718]                             info)
[18:06:13.718]                           info <- base::paste(info, collapse = "; ")
[18:06:13.718]                           if (!has_future) {
[18:06:13.718]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:13.718]                               info)
[18:06:13.718]                           }
[18:06:13.718]                           else {
[18:06:13.718]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:13.718]                               info, version)
[18:06:13.718]                           }
[18:06:13.718]                           base::stop(msg)
[18:06:13.718]                         }
[18:06:13.718]                       })
[18:06:13.718]                     }
[18:06:13.718]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:13.718]                     base::options(mc.cores = 1L)
[18:06:13.718]                   }
[18:06:13.718]                   ...future.strategy.old <- future::plan("list")
[18:06:13.718]                   options(future.plan = NULL)
[18:06:13.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:13.718]                 }
[18:06:13.718]                 ...future.workdir <- getwd()
[18:06:13.718]             }
[18:06:13.718]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:13.718]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:13.718]         }
[18:06:13.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:13.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:13.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:13.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:13.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:13.718]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:13.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:13.718]             base::names(...future.oldOptions))
[18:06:13.718]     }
[18:06:13.718]     if (FALSE) {
[18:06:13.718]     }
[18:06:13.718]     else {
[18:06:13.718]         if (TRUE) {
[18:06:13.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:13.718]                 open = "w")
[18:06:13.718]         }
[18:06:13.718]         else {
[18:06:13.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:13.718]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:13.718]         }
[18:06:13.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:13.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:13.718]             base::sink(type = "output", split = FALSE)
[18:06:13.718]             base::close(...future.stdout)
[18:06:13.718]         }, add = TRUE)
[18:06:13.718]     }
[18:06:13.718]     ...future.frame <- base::sys.nframe()
[18:06:13.718]     ...future.conditions <- base::list()
[18:06:13.718]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:13.718]     if (FALSE) {
[18:06:13.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:13.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:13.718]     }
[18:06:13.718]     ...future.result <- base::tryCatch({
[18:06:13.718]         base::withCallingHandlers({
[18:06:13.718]             ...future.value <- base::withVisible(base::local({
[18:06:13.718]                 ...future.makeSendCondition <- base::local({
[18:06:13.718]                   sendCondition <- NULL
[18:06:13.718]                   function(frame = 1L) {
[18:06:13.718]                     if (is.function(sendCondition)) 
[18:06:13.718]                       return(sendCondition)
[18:06:13.718]                     ns <- getNamespace("parallel")
[18:06:13.718]                     if (exists("sendData", mode = "function", 
[18:06:13.718]                       envir = ns)) {
[18:06:13.718]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:13.718]                         envir = ns)
[18:06:13.718]                       envir <- sys.frame(frame)
[18:06:13.718]                       master <- NULL
[18:06:13.718]                       while (!identical(envir, .GlobalEnv) && 
[18:06:13.718]                         !identical(envir, emptyenv())) {
[18:06:13.718]                         if (exists("master", mode = "list", envir = envir, 
[18:06:13.718]                           inherits = FALSE)) {
[18:06:13.718]                           master <- get("master", mode = "list", 
[18:06:13.718]                             envir = envir, inherits = FALSE)
[18:06:13.718]                           if (inherits(master, c("SOCKnode", 
[18:06:13.718]                             "SOCK0node"))) {
[18:06:13.718]                             sendCondition <<- function(cond) {
[18:06:13.718]                               data <- list(type = "VALUE", value = cond, 
[18:06:13.718]                                 success = TRUE)
[18:06:13.718]                               parallel_sendData(master, data)
[18:06:13.718]                             }
[18:06:13.718]                             return(sendCondition)
[18:06:13.718]                           }
[18:06:13.718]                         }
[18:06:13.718]                         frame <- frame + 1L
[18:06:13.718]                         envir <- sys.frame(frame)
[18:06:13.718]                       }
[18:06:13.718]                     }
[18:06:13.718]                     sendCondition <<- function(cond) NULL
[18:06:13.718]                   }
[18:06:13.718]                 })
[18:06:13.718]                 withCallingHandlers({
[18:06:13.718]                   {
[18:06:13.718]                     Sys.sleep(0.5)
[18:06:13.718]                     list(a = 1, b = 42L)
[18:06:13.718]                   }
[18:06:13.718]                 }, immediateCondition = function(cond) {
[18:06:13.718]                   sendCondition <- ...future.makeSendCondition()
[18:06:13.718]                   sendCondition(cond)
[18:06:13.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.718]                   {
[18:06:13.718]                     inherits <- base::inherits
[18:06:13.718]                     invokeRestart <- base::invokeRestart
[18:06:13.718]                     is.null <- base::is.null
[18:06:13.718]                     muffled <- FALSE
[18:06:13.718]                     if (inherits(cond, "message")) {
[18:06:13.718]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:13.718]                       if (muffled) 
[18:06:13.718]                         invokeRestart("muffleMessage")
[18:06:13.718]                     }
[18:06:13.718]                     else if (inherits(cond, "warning")) {
[18:06:13.718]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:13.718]                       if (muffled) 
[18:06:13.718]                         invokeRestart("muffleWarning")
[18:06:13.718]                     }
[18:06:13.718]                     else if (inherits(cond, "condition")) {
[18:06:13.718]                       if (!is.null(pattern)) {
[18:06:13.718]                         computeRestarts <- base::computeRestarts
[18:06:13.718]                         grepl <- base::grepl
[18:06:13.718]                         restarts <- computeRestarts(cond)
[18:06:13.718]                         for (restart in restarts) {
[18:06:13.718]                           name <- restart$name
[18:06:13.718]                           if (is.null(name)) 
[18:06:13.718]                             next
[18:06:13.718]                           if (!grepl(pattern, name)) 
[18:06:13.718]                             next
[18:06:13.718]                           invokeRestart(restart)
[18:06:13.718]                           muffled <- TRUE
[18:06:13.718]                           break
[18:06:13.718]                         }
[18:06:13.718]                       }
[18:06:13.718]                     }
[18:06:13.718]                     invisible(muffled)
[18:06:13.718]                   }
[18:06:13.718]                   muffleCondition(cond)
[18:06:13.718]                 })
[18:06:13.718]             }))
[18:06:13.718]             future::FutureResult(value = ...future.value$value, 
[18:06:13.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.718]                   ...future.rng), globalenv = if (FALSE) 
[18:06:13.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:13.718]                     ...future.globalenv.names))
[18:06:13.718]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:13.718]         }, condition = base::local({
[18:06:13.718]             c <- base::c
[18:06:13.718]             inherits <- base::inherits
[18:06:13.718]             invokeRestart <- base::invokeRestart
[18:06:13.718]             length <- base::length
[18:06:13.718]             list <- base::list
[18:06:13.718]             seq.int <- base::seq.int
[18:06:13.718]             signalCondition <- base::signalCondition
[18:06:13.718]             sys.calls <- base::sys.calls
[18:06:13.718]             `[[` <- base::`[[`
[18:06:13.718]             `+` <- base::`+`
[18:06:13.718]             `<<-` <- base::`<<-`
[18:06:13.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:13.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:13.718]                   3L)]
[18:06:13.718]             }
[18:06:13.718]             function(cond) {
[18:06:13.718]                 is_error <- inherits(cond, "error")
[18:06:13.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:13.718]                   NULL)
[18:06:13.718]                 if (is_error) {
[18:06:13.718]                   sessionInformation <- function() {
[18:06:13.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:13.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:13.718]                       search = base::search(), system = base::Sys.info())
[18:06:13.718]                   }
[18:06:13.718]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:13.718]                     cond$call), session = sessionInformation(), 
[18:06:13.718]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:13.718]                   signalCondition(cond)
[18:06:13.718]                 }
[18:06:13.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:13.718]                 "immediateCondition"))) {
[18:06:13.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:13.718]                   ...future.conditions[[length(...future.conditions) + 
[18:06:13.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:13.718]                   if (TRUE && !signal) {
[18:06:13.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.718]                     {
[18:06:13.718]                       inherits <- base::inherits
[18:06:13.718]                       invokeRestart <- base::invokeRestart
[18:06:13.718]                       is.null <- base::is.null
[18:06:13.718]                       muffled <- FALSE
[18:06:13.718]                       if (inherits(cond, "message")) {
[18:06:13.718]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.718]                         if (muffled) 
[18:06:13.718]                           invokeRestart("muffleMessage")
[18:06:13.718]                       }
[18:06:13.718]                       else if (inherits(cond, "warning")) {
[18:06:13.718]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.718]                         if (muffled) 
[18:06:13.718]                           invokeRestart("muffleWarning")
[18:06:13.718]                       }
[18:06:13.718]                       else if (inherits(cond, "condition")) {
[18:06:13.718]                         if (!is.null(pattern)) {
[18:06:13.718]                           computeRestarts <- base::computeRestarts
[18:06:13.718]                           grepl <- base::grepl
[18:06:13.718]                           restarts <- computeRestarts(cond)
[18:06:13.718]                           for (restart in restarts) {
[18:06:13.718]                             name <- restart$name
[18:06:13.718]                             if (is.null(name)) 
[18:06:13.718]                               next
[18:06:13.718]                             if (!grepl(pattern, name)) 
[18:06:13.718]                               next
[18:06:13.718]                             invokeRestart(restart)
[18:06:13.718]                             muffled <- TRUE
[18:06:13.718]                             break
[18:06:13.718]                           }
[18:06:13.718]                         }
[18:06:13.718]                       }
[18:06:13.718]                       invisible(muffled)
[18:06:13.718]                     }
[18:06:13.718]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.718]                   }
[18:06:13.718]                 }
[18:06:13.718]                 else {
[18:06:13.718]                   if (TRUE) {
[18:06:13.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:13.718]                     {
[18:06:13.718]                       inherits <- base::inherits
[18:06:13.718]                       invokeRestart <- base::invokeRestart
[18:06:13.718]                       is.null <- base::is.null
[18:06:13.718]                       muffled <- FALSE
[18:06:13.718]                       if (inherits(cond, "message")) {
[18:06:13.718]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:13.718]                         if (muffled) 
[18:06:13.718]                           invokeRestart("muffleMessage")
[18:06:13.718]                       }
[18:06:13.718]                       else if (inherits(cond, "warning")) {
[18:06:13.718]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:13.718]                         if (muffled) 
[18:06:13.718]                           invokeRestart("muffleWarning")
[18:06:13.718]                       }
[18:06:13.718]                       else if (inherits(cond, "condition")) {
[18:06:13.718]                         if (!is.null(pattern)) {
[18:06:13.718]                           computeRestarts <- base::computeRestarts
[18:06:13.718]                           grepl <- base::grepl
[18:06:13.718]                           restarts <- computeRestarts(cond)
[18:06:13.718]                           for (restart in restarts) {
[18:06:13.718]                             name <- restart$name
[18:06:13.718]                             if (is.null(name)) 
[18:06:13.718]                               next
[18:06:13.718]                             if (!grepl(pattern, name)) 
[18:06:13.718]                               next
[18:06:13.718]                             invokeRestart(restart)
[18:06:13.718]                             muffled <- TRUE
[18:06:13.718]                             break
[18:06:13.718]                           }
[18:06:13.718]                         }
[18:06:13.718]                       }
[18:06:13.718]                       invisible(muffled)
[18:06:13.718]                     }
[18:06:13.718]                     muffleCondition(cond, pattern = "^muffle")
[18:06:13.718]                   }
[18:06:13.718]                 }
[18:06:13.718]             }
[18:06:13.718]         }))
[18:06:13.718]     }, error = function(ex) {
[18:06:13.718]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:13.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:13.718]                 ...future.rng), started = ...future.startTime, 
[18:06:13.718]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:13.718]             version = "1.8"), class = "FutureResult")
[18:06:13.718]     }, finally = {
[18:06:13.718]         if (!identical(...future.workdir, getwd())) 
[18:06:13.718]             setwd(...future.workdir)
[18:06:13.718]         {
[18:06:13.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:13.718]                 ...future.oldOptions$nwarnings <- NULL
[18:06:13.718]             }
[18:06:13.718]             base::options(...future.oldOptions)
[18:06:13.718]             if (.Platform$OS.type == "windows") {
[18:06:13.718]                 old_names <- names(...future.oldEnvVars)
[18:06:13.718]                 envs <- base::Sys.getenv()
[18:06:13.718]                 names <- names(envs)
[18:06:13.718]                 common <- intersect(names, old_names)
[18:06:13.718]                 added <- setdiff(names, old_names)
[18:06:13.718]                 removed <- setdiff(old_names, names)
[18:06:13.718]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:13.718]                   envs[common]]
[18:06:13.718]                 NAMES <- toupper(changed)
[18:06:13.718]                 args <- list()
[18:06:13.718]                 for (kk in seq_along(NAMES)) {
[18:06:13.718]                   name <- changed[[kk]]
[18:06:13.718]                   NAME <- NAMES[[kk]]
[18:06:13.718]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.718]                     next
[18:06:13.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.718]                 }
[18:06:13.718]                 NAMES <- toupper(added)
[18:06:13.718]                 for (kk in seq_along(NAMES)) {
[18:06:13.718]                   name <- added[[kk]]
[18:06:13.718]                   NAME <- NAMES[[kk]]
[18:06:13.718]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.718]                     next
[18:06:13.718]                   args[[name]] <- ""
[18:06:13.718]                 }
[18:06:13.718]                 NAMES <- toupper(removed)
[18:06:13.718]                 for (kk in seq_along(NAMES)) {
[18:06:13.718]                   name <- removed[[kk]]
[18:06:13.718]                   NAME <- NAMES[[kk]]
[18:06:13.718]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:13.718]                     next
[18:06:13.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:13.718]                 }
[18:06:13.718]                 if (length(args) > 0) 
[18:06:13.718]                   base::do.call(base::Sys.setenv, args = args)
[18:06:13.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:13.718]             }
[18:06:13.718]             else {
[18:06:13.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:13.718]             }
[18:06:13.718]             {
[18:06:13.718]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:13.718]                   0L) {
[18:06:13.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:13.718]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:13.718]                   base::options(opts)
[18:06:13.718]                 }
[18:06:13.718]                 {
[18:06:13.718]                   {
[18:06:13.718]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:13.718]                     NULL
[18:06:13.718]                   }
[18:06:13.718]                   options(future.plan = NULL)
[18:06:13.718]                   if (is.na(NA_character_)) 
[18:06:13.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:13.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:13.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:13.718]                     .init = FALSE)
[18:06:13.718]                 }
[18:06:13.718]             }
[18:06:13.718]         }
[18:06:13.718]     })
[18:06:13.718]     if (TRUE) {
[18:06:13.718]         base::sink(type = "output", split = FALSE)
[18:06:13.718]         if (TRUE) {
[18:06:13.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:13.718]         }
[18:06:13.718]         else {
[18:06:13.718]             ...future.result["stdout"] <- base::list(NULL)
[18:06:13.718]         }
[18:06:13.718]         base::close(...future.stdout)
[18:06:13.718]         ...future.stdout <- NULL
[18:06:13.718]     }
[18:06:13.718]     ...future.result$conditions <- ...future.conditions
[18:06:13.718]     ...future.result$finished <- base::Sys.time()
[18:06:13.718]     ...future.result
[18:06:13.718] }
[18:06:13.722] Poll #1 (0): usedNodes() = 2, workers = 2
[18:06:13.745] receiveMessageFromWorker() for ClusterFuture ...
[18:06:13.745] - Validating connection of MultisessionFuture
[18:06:13.746] - received message: FutureResult
[18:06:13.746] - Received FutureResult
[18:06:13.747] - Erased future from FutureRegistry
[18:06:13.747] result() for ClusterFuture ...
[18:06:13.747] - result already collected: FutureResult
[18:06:13.747] result() for ClusterFuture ... done
[18:06:13.747] signalConditions() ...
[18:06:13.748]  - include = ‘immediateCondition’
[18:06:13.748]  - exclude = 
[18:06:13.748]  - resignal = FALSE
[18:06:13.748]  - Number of conditions: 1
[18:06:13.749] signalConditions() ... done
[18:06:13.749] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:13.749] result() for ClusterFuture ...
[18:06:13.749] - result already collected: FutureResult
[18:06:13.749] result() for ClusterFuture ... done
[18:06:13.750] result() for ClusterFuture ...
[18:06:13.750] - result already collected: FutureResult
[18:06:13.750] result() for ClusterFuture ... done
[18:06:13.750] signalConditions() ...
[18:06:13.750]  - include = ‘immediateCondition’
[18:06:13.751]  - exclude = 
[18:06:13.751]  - resignal = FALSE
[18:06:13.751]  - Number of conditions: 1
[18:06:13.751] signalConditions() ... done
[18:06:13.753] MultisessionFuture started
[18:06:13.754] - Launch lazy future ... done
[18:06:13.754] run() for ‘MultisessionFuture’ ... done
[18:06:14.298] receiveMessageFromWorker() for ClusterFuture ...
[18:06:14.298] - Validating connection of MultisessionFuture
[18:06:14.299] - received message: FutureResult
[18:06:14.299] - Received FutureResult
[18:06:14.300] - Erased future from FutureRegistry
[18:06:14.300] result() for ClusterFuture ...
[18:06:14.300] - result already collected: FutureResult
[18:06:14.301] result() for ClusterFuture ... done
[18:06:14.301] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:14.301] A MultisessionFuture was resolved (result was not collected)
[18:06:14.301] getGlobalsAndPackages() ...
[18:06:14.302] Searching for globals...
[18:06:14.305] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:14.306] Searching for globals ... DONE
[18:06:14.306] Resolving globals: FALSE
[18:06:14.307] 
[18:06:14.307] 
[18:06:14.308] getGlobalsAndPackages() ... DONE
[18:06:14.309] run() for ‘Future’ ...
[18:06:14.309] - state: ‘created’
[18:06:14.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:14.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:14.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:14.349]   - Field: ‘node’
[18:06:14.349]   - Field: ‘label’
[18:06:14.350]   - Field: ‘local’
[18:06:14.350]   - Field: ‘owner’
[18:06:14.350]   - Field: ‘envir’
[18:06:14.351]   - Field: ‘workers’
[18:06:14.351]   - Field: ‘packages’
[18:06:14.351]   - Field: ‘gc’
[18:06:14.352]   - Field: ‘conditions’
[18:06:14.352]   - Field: ‘persistent’
[18:06:14.352]   - Field: ‘expr’
[18:06:14.353]   - Field: ‘uuid’
[18:06:14.353]   - Field: ‘seed’
[18:06:14.353]   - Field: ‘version’
[18:06:14.354]   - Field: ‘result’
[18:06:14.354]   - Field: ‘asynchronous’
[18:06:14.354]   - Field: ‘calls’
[18:06:14.355]   - Field: ‘globals’
[18:06:14.355]   - Field: ‘stdout’
[18:06:14.355]   - Field: ‘earlySignal’
[18:06:14.356]   - Field: ‘lazy’
[18:06:14.356]   - Field: ‘state’
[18:06:14.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:14.356] - Launch lazy future ...
[18:06:14.357] Packages needed by the future expression (n = 0): <none>
[18:06:14.358] Packages needed by future strategies (n = 0): <none>
[18:06:14.359] {
[18:06:14.359]     {
[18:06:14.359]         {
[18:06:14.359]             ...future.startTime <- base::Sys.time()
[18:06:14.359]             {
[18:06:14.359]                 {
[18:06:14.359]                   {
[18:06:14.359]                     {
[18:06:14.359]                       base::local({
[18:06:14.359]                         has_future <- base::requireNamespace("future", 
[18:06:14.359]                           quietly = TRUE)
[18:06:14.359]                         if (has_future) {
[18:06:14.359]                           ns <- base::getNamespace("future")
[18:06:14.359]                           version <- ns[[".package"]][["version"]]
[18:06:14.359]                           if (is.null(version)) 
[18:06:14.359]                             version <- utils::packageVersion("future")
[18:06:14.359]                         }
[18:06:14.359]                         else {
[18:06:14.359]                           version <- NULL
[18:06:14.359]                         }
[18:06:14.359]                         if (!has_future || version < "1.8.0") {
[18:06:14.359]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:14.359]                             "", base::R.version$version.string), 
[18:06:14.359]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:14.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:14.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:14.359]                               "release", "version")], collapse = " "), 
[18:06:14.359]                             hostname = base::Sys.info()[["nodename"]])
[18:06:14.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:14.359]                             info)
[18:06:14.359]                           info <- base::paste(info, collapse = "; ")
[18:06:14.359]                           if (!has_future) {
[18:06:14.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:14.359]                               info)
[18:06:14.359]                           }
[18:06:14.359]                           else {
[18:06:14.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:14.359]                               info, version)
[18:06:14.359]                           }
[18:06:14.359]                           base::stop(msg)
[18:06:14.359]                         }
[18:06:14.359]                       })
[18:06:14.359]                     }
[18:06:14.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:14.359]                     base::options(mc.cores = 1L)
[18:06:14.359]                   }
[18:06:14.359]                   ...future.strategy.old <- future::plan("list")
[18:06:14.359]                   options(future.plan = NULL)
[18:06:14.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:14.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:14.359]                 }
[18:06:14.359]                 ...future.workdir <- getwd()
[18:06:14.359]             }
[18:06:14.359]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:14.359]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:14.359]         }
[18:06:14.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:14.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:14.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:14.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:14.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:14.359]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:14.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:14.359]             base::names(...future.oldOptions))
[18:06:14.359]     }
[18:06:14.359]     if (FALSE) {
[18:06:14.359]     }
[18:06:14.359]     else {
[18:06:14.359]         if (TRUE) {
[18:06:14.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:14.359]                 open = "w")
[18:06:14.359]         }
[18:06:14.359]         else {
[18:06:14.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:14.359]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:14.359]         }
[18:06:14.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:14.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:14.359]             base::sink(type = "output", split = FALSE)
[18:06:14.359]             base::close(...future.stdout)
[18:06:14.359]         }, add = TRUE)
[18:06:14.359]     }
[18:06:14.359]     ...future.frame <- base::sys.nframe()
[18:06:14.359]     ...future.conditions <- base::list()
[18:06:14.359]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:14.359]     if (FALSE) {
[18:06:14.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:14.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:14.359]     }
[18:06:14.359]     ...future.result <- base::tryCatch({
[18:06:14.359]         base::withCallingHandlers({
[18:06:14.359]             ...future.value <- base::withVisible(base::local({
[18:06:14.359]                 ...future.makeSendCondition <- base::local({
[18:06:14.359]                   sendCondition <- NULL
[18:06:14.359]                   function(frame = 1L) {
[18:06:14.359]                     if (is.function(sendCondition)) 
[18:06:14.359]                       return(sendCondition)
[18:06:14.359]                     ns <- getNamespace("parallel")
[18:06:14.359]                     if (exists("sendData", mode = "function", 
[18:06:14.359]                       envir = ns)) {
[18:06:14.359]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:14.359]                         envir = ns)
[18:06:14.359]                       envir <- sys.frame(frame)
[18:06:14.359]                       master <- NULL
[18:06:14.359]                       while (!identical(envir, .GlobalEnv) && 
[18:06:14.359]                         !identical(envir, emptyenv())) {
[18:06:14.359]                         if (exists("master", mode = "list", envir = envir, 
[18:06:14.359]                           inherits = FALSE)) {
[18:06:14.359]                           master <- get("master", mode = "list", 
[18:06:14.359]                             envir = envir, inherits = FALSE)
[18:06:14.359]                           if (inherits(master, c("SOCKnode", 
[18:06:14.359]                             "SOCK0node"))) {
[18:06:14.359]                             sendCondition <<- function(cond) {
[18:06:14.359]                               data <- list(type = "VALUE", value = cond, 
[18:06:14.359]                                 success = TRUE)
[18:06:14.359]                               parallel_sendData(master, data)
[18:06:14.359]                             }
[18:06:14.359]                             return(sendCondition)
[18:06:14.359]                           }
[18:06:14.359]                         }
[18:06:14.359]                         frame <- frame + 1L
[18:06:14.359]                         envir <- sys.frame(frame)
[18:06:14.359]                       }
[18:06:14.359]                     }
[18:06:14.359]                     sendCondition <<- function(cond) NULL
[18:06:14.359]                   }
[18:06:14.359]                 })
[18:06:14.359]                 withCallingHandlers({
[18:06:14.359]                   {
[18:06:14.359]                     Sys.sleep(0.5)
[18:06:14.359]                     list(a = 1, b = 42L)
[18:06:14.359]                   }
[18:06:14.359]                 }, immediateCondition = function(cond) {
[18:06:14.359]                   sendCondition <- ...future.makeSendCondition()
[18:06:14.359]                   sendCondition(cond)
[18:06:14.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:14.359]                   {
[18:06:14.359]                     inherits <- base::inherits
[18:06:14.359]                     invokeRestart <- base::invokeRestart
[18:06:14.359]                     is.null <- base::is.null
[18:06:14.359]                     muffled <- FALSE
[18:06:14.359]                     if (inherits(cond, "message")) {
[18:06:14.359]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:14.359]                       if (muffled) 
[18:06:14.359]                         invokeRestart("muffleMessage")
[18:06:14.359]                     }
[18:06:14.359]                     else if (inherits(cond, "warning")) {
[18:06:14.359]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:14.359]                       if (muffled) 
[18:06:14.359]                         invokeRestart("muffleWarning")
[18:06:14.359]                     }
[18:06:14.359]                     else if (inherits(cond, "condition")) {
[18:06:14.359]                       if (!is.null(pattern)) {
[18:06:14.359]                         computeRestarts <- base::computeRestarts
[18:06:14.359]                         grepl <- base::grepl
[18:06:14.359]                         restarts <- computeRestarts(cond)
[18:06:14.359]                         for (restart in restarts) {
[18:06:14.359]                           name <- restart$name
[18:06:14.359]                           if (is.null(name)) 
[18:06:14.359]                             next
[18:06:14.359]                           if (!grepl(pattern, name)) 
[18:06:14.359]                             next
[18:06:14.359]                           invokeRestart(restart)
[18:06:14.359]                           muffled <- TRUE
[18:06:14.359]                           break
[18:06:14.359]                         }
[18:06:14.359]                       }
[18:06:14.359]                     }
[18:06:14.359]                     invisible(muffled)
[18:06:14.359]                   }
[18:06:14.359]                   muffleCondition(cond)
[18:06:14.359]                 })
[18:06:14.359]             }))
[18:06:14.359]             future::FutureResult(value = ...future.value$value, 
[18:06:14.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:14.359]                   ...future.rng), globalenv = if (FALSE) 
[18:06:14.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:14.359]                     ...future.globalenv.names))
[18:06:14.359]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:14.359]         }, condition = base::local({
[18:06:14.359]             c <- base::c
[18:06:14.359]             inherits <- base::inherits
[18:06:14.359]             invokeRestart <- base::invokeRestart
[18:06:14.359]             length <- base::length
[18:06:14.359]             list <- base::list
[18:06:14.359]             seq.int <- base::seq.int
[18:06:14.359]             signalCondition <- base::signalCondition
[18:06:14.359]             sys.calls <- base::sys.calls
[18:06:14.359]             `[[` <- base::`[[`
[18:06:14.359]             `+` <- base::`+`
[18:06:14.359]             `<<-` <- base::`<<-`
[18:06:14.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:14.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:14.359]                   3L)]
[18:06:14.359]             }
[18:06:14.359]             function(cond) {
[18:06:14.359]                 is_error <- inherits(cond, "error")
[18:06:14.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:14.359]                   NULL)
[18:06:14.359]                 if (is_error) {
[18:06:14.359]                   sessionInformation <- function() {
[18:06:14.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:14.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:14.359]                       search = base::search(), system = base::Sys.info())
[18:06:14.359]                   }
[18:06:14.359]                   ...future.conditions[[length(...future.conditions) + 
[18:06:14.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:14.359]                     cond$call), session = sessionInformation(), 
[18:06:14.359]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:14.359]                   signalCondition(cond)
[18:06:14.359]                 }
[18:06:14.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:14.359]                 "immediateCondition"))) {
[18:06:14.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:14.359]                   ...future.conditions[[length(...future.conditions) + 
[18:06:14.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:14.359]                   if (TRUE && !signal) {
[18:06:14.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:14.359]                     {
[18:06:14.359]                       inherits <- base::inherits
[18:06:14.359]                       invokeRestart <- base::invokeRestart
[18:06:14.359]                       is.null <- base::is.null
[18:06:14.359]                       muffled <- FALSE
[18:06:14.359]                       if (inherits(cond, "message")) {
[18:06:14.359]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:14.359]                         if (muffled) 
[18:06:14.359]                           invokeRestart("muffleMessage")
[18:06:14.359]                       }
[18:06:14.359]                       else if (inherits(cond, "warning")) {
[18:06:14.359]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:14.359]                         if (muffled) 
[18:06:14.359]                           invokeRestart("muffleWarning")
[18:06:14.359]                       }
[18:06:14.359]                       else if (inherits(cond, "condition")) {
[18:06:14.359]                         if (!is.null(pattern)) {
[18:06:14.359]                           computeRestarts <- base::computeRestarts
[18:06:14.359]                           grepl <- base::grepl
[18:06:14.359]                           restarts <- computeRestarts(cond)
[18:06:14.359]                           for (restart in restarts) {
[18:06:14.359]                             name <- restart$name
[18:06:14.359]                             if (is.null(name)) 
[18:06:14.359]                               next
[18:06:14.359]                             if (!grepl(pattern, name)) 
[18:06:14.359]                               next
[18:06:14.359]                             invokeRestart(restart)
[18:06:14.359]                             muffled <- TRUE
[18:06:14.359]                             break
[18:06:14.359]                           }
[18:06:14.359]                         }
[18:06:14.359]                       }
[18:06:14.359]                       invisible(muffled)
[18:06:14.359]                     }
[18:06:14.359]                     muffleCondition(cond, pattern = "^muffle")
[18:06:14.359]                   }
[18:06:14.359]                 }
[18:06:14.359]                 else {
[18:06:14.359]                   if (TRUE) {
[18:06:14.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:14.359]                     {
[18:06:14.359]                       inherits <- base::inherits
[18:06:14.359]                       invokeRestart <- base::invokeRestart
[18:06:14.359]                       is.null <- base::is.null
[18:06:14.359]                       muffled <- FALSE
[18:06:14.359]                       if (inherits(cond, "message")) {
[18:06:14.359]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:14.359]                         if (muffled) 
[18:06:14.359]                           invokeRestart("muffleMessage")
[18:06:14.359]                       }
[18:06:14.359]                       else if (inherits(cond, "warning")) {
[18:06:14.359]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:14.359]                         if (muffled) 
[18:06:14.359]                           invokeRestart("muffleWarning")
[18:06:14.359]                       }
[18:06:14.359]                       else if (inherits(cond, "condition")) {
[18:06:14.359]                         if (!is.null(pattern)) {
[18:06:14.359]                           computeRestarts <- base::computeRestarts
[18:06:14.359]                           grepl <- base::grepl
[18:06:14.359]                           restarts <- computeRestarts(cond)
[18:06:14.359]                           for (restart in restarts) {
[18:06:14.359]                             name <- restart$name
[18:06:14.359]                             if (is.null(name)) 
[18:06:14.359]                               next
[18:06:14.359]                             if (!grepl(pattern, name)) 
[18:06:14.359]                               next
[18:06:14.359]                             invokeRestart(restart)
[18:06:14.359]                             muffled <- TRUE
[18:06:14.359]                             break
[18:06:14.359]                           }
[18:06:14.359]                         }
[18:06:14.359]                       }
[18:06:14.359]                       invisible(muffled)
[18:06:14.359]                     }
[18:06:14.359]                     muffleCondition(cond, pattern = "^muffle")
[18:06:14.359]                   }
[18:06:14.359]                 }
[18:06:14.359]             }
[18:06:14.359]         }))
[18:06:14.359]     }, error = function(ex) {
[18:06:14.359]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:14.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:14.359]                 ...future.rng), started = ...future.startTime, 
[18:06:14.359]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:14.359]             version = "1.8"), class = "FutureResult")
[18:06:14.359]     }, finally = {
[18:06:14.359]         if (!identical(...future.workdir, getwd())) 
[18:06:14.359]             setwd(...future.workdir)
[18:06:14.359]         {
[18:06:14.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:14.359]                 ...future.oldOptions$nwarnings <- NULL
[18:06:14.359]             }
[18:06:14.359]             base::options(...future.oldOptions)
[18:06:14.359]             if (.Platform$OS.type == "windows") {
[18:06:14.359]                 old_names <- names(...future.oldEnvVars)
[18:06:14.359]                 envs <- base::Sys.getenv()
[18:06:14.359]                 names <- names(envs)
[18:06:14.359]                 common <- intersect(names, old_names)
[18:06:14.359]                 added <- setdiff(names, old_names)
[18:06:14.359]                 removed <- setdiff(old_names, names)
[18:06:14.359]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:14.359]                   envs[common]]
[18:06:14.359]                 NAMES <- toupper(changed)
[18:06:14.359]                 args <- list()
[18:06:14.359]                 for (kk in seq_along(NAMES)) {
[18:06:14.359]                   name <- changed[[kk]]
[18:06:14.359]                   NAME <- NAMES[[kk]]
[18:06:14.359]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:14.359]                     next
[18:06:14.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:14.359]                 }
[18:06:14.359]                 NAMES <- toupper(added)
[18:06:14.359]                 for (kk in seq_along(NAMES)) {
[18:06:14.359]                   name <- added[[kk]]
[18:06:14.359]                   NAME <- NAMES[[kk]]
[18:06:14.359]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:14.359]                     next
[18:06:14.359]                   args[[name]] <- ""
[18:06:14.359]                 }
[18:06:14.359]                 NAMES <- toupper(removed)
[18:06:14.359]                 for (kk in seq_along(NAMES)) {
[18:06:14.359]                   name <- removed[[kk]]
[18:06:14.359]                   NAME <- NAMES[[kk]]
[18:06:14.359]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:14.359]                     next
[18:06:14.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:14.359]                 }
[18:06:14.359]                 if (length(args) > 0) 
[18:06:14.359]                   base::do.call(base::Sys.setenv, args = args)
[18:06:14.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:14.359]             }
[18:06:14.359]             else {
[18:06:14.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:14.359]             }
[18:06:14.359]             {
[18:06:14.359]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:14.359]                   0L) {
[18:06:14.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:14.359]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:14.359]                   base::options(opts)
[18:06:14.359]                 }
[18:06:14.359]                 {
[18:06:14.359]                   {
[18:06:14.359]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:14.359]                     NULL
[18:06:14.359]                   }
[18:06:14.359]                   options(future.plan = NULL)
[18:06:14.359]                   if (is.na(NA_character_)) 
[18:06:14.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:14.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:14.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:14.359]                     .init = FALSE)
[18:06:14.359]                 }
[18:06:14.359]             }
[18:06:14.359]         }
[18:06:14.359]     })
[18:06:14.359]     if (TRUE) {
[18:06:14.359]         base::sink(type = "output", split = FALSE)
[18:06:14.359]         if (TRUE) {
[18:06:14.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:14.359]         }
[18:06:14.359]         else {
[18:06:14.359]             ...future.result["stdout"] <- base::list(NULL)
[18:06:14.359]         }
[18:06:14.359]         base::close(...future.stdout)
[18:06:14.359]         ...future.stdout <- NULL
[18:06:14.359]     }
[18:06:14.359]     ...future.result$conditions <- ...future.conditions
[18:06:14.359]     ...future.result$finished <- base::Sys.time()
[18:06:14.359]     ...future.result
[18:06:14.359] }
[18:06:14.366] MultisessionFuture started
[18:06:14.367] - Launch lazy future ... done
[18:06:14.367] run() for ‘MultisessionFuture’ ... done
[18:06:14.924] receiveMessageFromWorker() for ClusterFuture ...
[18:06:14.924] - Validating connection of MultisessionFuture
[18:06:14.925] - received message: FutureResult
[18:06:14.925] - Received FutureResult
[18:06:14.926] - Erased future from FutureRegistry
[18:06:14.926] result() for ClusterFuture ...
[18:06:14.926] - result already collected: FutureResult
[18:06:14.927] result() for ClusterFuture ... done
[18:06:14.927] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:14.927] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[18:06:14.928] getGlobalsAndPackages() ...
[18:06:14.928] Searching for globals...
[18:06:14.930] - globals found: [2] ‘list’, ‘stop’
[18:06:14.930] Searching for globals ... DONE
[18:06:14.931] Resolving globals: FALSE
[18:06:14.932] 
[18:06:14.932] 
[18:06:14.932] getGlobalsAndPackages() ... DONE
[18:06:14.933] run() for ‘Future’ ...
[18:06:14.933] - state: ‘created’
[18:06:14.934] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:14.967] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:14.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:14.967]   - Field: ‘node’
[18:06:14.968]   - Field: ‘label’
[18:06:14.968]   - Field: ‘local’
[18:06:14.968]   - Field: ‘owner’
[18:06:14.972]   - Field: ‘envir’
[18:06:14.972]   - Field: ‘workers’
[18:06:14.972]   - Field: ‘packages’
[18:06:14.973]   - Field: ‘gc’
[18:06:14.973]   - Field: ‘conditions’
[18:06:14.973]   - Field: ‘persistent’
[18:06:14.973]   - Field: ‘expr’
[18:06:14.974]   - Field: ‘uuid’
[18:06:14.974]   - Field: ‘seed’
[18:06:14.974]   - Field: ‘version’
[18:06:14.974]   - Field: ‘result’
[18:06:14.975]   - Field: ‘asynchronous’
[18:06:14.975]   - Field: ‘calls’
[18:06:14.975]   - Field: ‘globals’
[18:06:14.975]   - Field: ‘stdout’
[18:06:14.976]   - Field: ‘earlySignal’
[18:06:14.976]   - Field: ‘lazy’
[18:06:14.976]   - Field: ‘state’
[18:06:14.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:14.977] - Launch lazy future ...
[18:06:14.977] Packages needed by the future expression (n = 0): <none>
[18:06:14.978] Packages needed by future strategies (n = 0): <none>
[18:06:14.979] {
[18:06:14.979]     {
[18:06:14.979]         {
[18:06:14.979]             ...future.startTime <- base::Sys.time()
[18:06:14.979]             {
[18:06:14.979]                 {
[18:06:14.979]                   {
[18:06:14.979]                     {
[18:06:14.979]                       base::local({
[18:06:14.979]                         has_future <- base::requireNamespace("future", 
[18:06:14.979]                           quietly = TRUE)
[18:06:14.979]                         if (has_future) {
[18:06:14.979]                           ns <- base::getNamespace("future")
[18:06:14.979]                           version <- ns[[".package"]][["version"]]
[18:06:14.979]                           if (is.null(version)) 
[18:06:14.979]                             version <- utils::packageVersion("future")
[18:06:14.979]                         }
[18:06:14.979]                         else {
[18:06:14.979]                           version <- NULL
[18:06:14.979]                         }
[18:06:14.979]                         if (!has_future || version < "1.8.0") {
[18:06:14.979]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:14.979]                             "", base::R.version$version.string), 
[18:06:14.979]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:14.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:14.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:14.979]                               "release", "version")], collapse = " "), 
[18:06:14.979]                             hostname = base::Sys.info()[["nodename"]])
[18:06:14.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:14.979]                             info)
[18:06:14.979]                           info <- base::paste(info, collapse = "; ")
[18:06:14.979]                           if (!has_future) {
[18:06:14.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:14.979]                               info)
[18:06:14.979]                           }
[18:06:14.979]                           else {
[18:06:14.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:14.979]                               info, version)
[18:06:14.979]                           }
[18:06:14.979]                           base::stop(msg)
[18:06:14.979]                         }
[18:06:14.979]                       })
[18:06:14.979]                     }
[18:06:14.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:14.979]                     base::options(mc.cores = 1L)
[18:06:14.979]                   }
[18:06:14.979]                   ...future.strategy.old <- future::plan("list")
[18:06:14.979]                   options(future.plan = NULL)
[18:06:14.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:14.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:14.979]                 }
[18:06:14.979]                 ...future.workdir <- getwd()
[18:06:14.979]             }
[18:06:14.979]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:14.979]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:14.979]         }
[18:06:14.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:14.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:14.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:14.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:14.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:14.979]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:14.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:14.979]             base::names(...future.oldOptions))
[18:06:14.979]     }
[18:06:14.979]     if (FALSE) {
[18:06:14.979]     }
[18:06:14.979]     else {
[18:06:14.979]         if (TRUE) {
[18:06:14.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:14.979]                 open = "w")
[18:06:14.979]         }
[18:06:14.979]         else {
[18:06:14.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:14.979]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:14.979]         }
[18:06:14.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:14.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:14.979]             base::sink(type = "output", split = FALSE)
[18:06:14.979]             base::close(...future.stdout)
[18:06:14.979]         }, add = TRUE)
[18:06:14.979]     }
[18:06:14.979]     ...future.frame <- base::sys.nframe()
[18:06:14.979]     ...future.conditions <- base::list()
[18:06:14.979]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:14.979]     if (FALSE) {
[18:06:14.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:14.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:14.979]     }
[18:06:14.979]     ...future.result <- base::tryCatch({
[18:06:14.979]         base::withCallingHandlers({
[18:06:14.979]             ...future.value <- base::withVisible(base::local({
[18:06:14.979]                 ...future.makeSendCondition <- base::local({
[18:06:14.979]                   sendCondition <- NULL
[18:06:14.979]                   function(frame = 1L) {
[18:06:14.979]                     if (is.function(sendCondition)) 
[18:06:14.979]                       return(sendCondition)
[18:06:14.979]                     ns <- getNamespace("parallel")
[18:06:14.979]                     if (exists("sendData", mode = "function", 
[18:06:14.979]                       envir = ns)) {
[18:06:14.979]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:14.979]                         envir = ns)
[18:06:14.979]                       envir <- sys.frame(frame)
[18:06:14.979]                       master <- NULL
[18:06:14.979]                       while (!identical(envir, .GlobalEnv) && 
[18:06:14.979]                         !identical(envir, emptyenv())) {
[18:06:14.979]                         if (exists("master", mode = "list", envir = envir, 
[18:06:14.979]                           inherits = FALSE)) {
[18:06:14.979]                           master <- get("master", mode = "list", 
[18:06:14.979]                             envir = envir, inherits = FALSE)
[18:06:14.979]                           if (inherits(master, c("SOCKnode", 
[18:06:14.979]                             "SOCK0node"))) {
[18:06:14.979]                             sendCondition <<- function(cond) {
[18:06:14.979]                               data <- list(type = "VALUE", value = cond, 
[18:06:14.979]                                 success = TRUE)
[18:06:14.979]                               parallel_sendData(master, data)
[18:06:14.979]                             }
[18:06:14.979]                             return(sendCondition)
[18:06:14.979]                           }
[18:06:14.979]                         }
[18:06:14.979]                         frame <- frame + 1L
[18:06:14.979]                         envir <- sys.frame(frame)
[18:06:14.979]                       }
[18:06:14.979]                     }
[18:06:14.979]                     sendCondition <<- function(cond) NULL
[18:06:14.979]                   }
[18:06:14.979]                 })
[18:06:14.979]                 withCallingHandlers({
[18:06:14.979]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:14.979]                 }, immediateCondition = function(cond) {
[18:06:14.979]                   sendCondition <- ...future.makeSendCondition()
[18:06:14.979]                   sendCondition(cond)
[18:06:14.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:14.979]                   {
[18:06:14.979]                     inherits <- base::inherits
[18:06:14.979]                     invokeRestart <- base::invokeRestart
[18:06:14.979]                     is.null <- base::is.null
[18:06:14.979]                     muffled <- FALSE
[18:06:14.979]                     if (inherits(cond, "message")) {
[18:06:14.979]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:14.979]                       if (muffled) 
[18:06:14.979]                         invokeRestart("muffleMessage")
[18:06:14.979]                     }
[18:06:14.979]                     else if (inherits(cond, "warning")) {
[18:06:14.979]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:14.979]                       if (muffled) 
[18:06:14.979]                         invokeRestart("muffleWarning")
[18:06:14.979]                     }
[18:06:14.979]                     else if (inherits(cond, "condition")) {
[18:06:14.979]                       if (!is.null(pattern)) {
[18:06:14.979]                         computeRestarts <- base::computeRestarts
[18:06:14.979]                         grepl <- base::grepl
[18:06:14.979]                         restarts <- computeRestarts(cond)
[18:06:14.979]                         for (restart in restarts) {
[18:06:14.979]                           name <- restart$name
[18:06:14.979]                           if (is.null(name)) 
[18:06:14.979]                             next
[18:06:14.979]                           if (!grepl(pattern, name)) 
[18:06:14.979]                             next
[18:06:14.979]                           invokeRestart(restart)
[18:06:14.979]                           muffled <- TRUE
[18:06:14.979]                           break
[18:06:14.979]                         }
[18:06:14.979]                       }
[18:06:14.979]                     }
[18:06:14.979]                     invisible(muffled)
[18:06:14.979]                   }
[18:06:14.979]                   muffleCondition(cond)
[18:06:14.979]                 })
[18:06:14.979]             }))
[18:06:14.979]             future::FutureResult(value = ...future.value$value, 
[18:06:14.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:14.979]                   ...future.rng), globalenv = if (FALSE) 
[18:06:14.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:14.979]                     ...future.globalenv.names))
[18:06:14.979]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:14.979]         }, condition = base::local({
[18:06:14.979]             c <- base::c
[18:06:14.979]             inherits <- base::inherits
[18:06:14.979]             invokeRestart <- base::invokeRestart
[18:06:14.979]             length <- base::length
[18:06:14.979]             list <- base::list
[18:06:14.979]             seq.int <- base::seq.int
[18:06:14.979]             signalCondition <- base::signalCondition
[18:06:14.979]             sys.calls <- base::sys.calls
[18:06:14.979]             `[[` <- base::`[[`
[18:06:14.979]             `+` <- base::`+`
[18:06:14.979]             `<<-` <- base::`<<-`
[18:06:14.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:14.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:14.979]                   3L)]
[18:06:14.979]             }
[18:06:14.979]             function(cond) {
[18:06:14.979]                 is_error <- inherits(cond, "error")
[18:06:14.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:14.979]                   NULL)
[18:06:14.979]                 if (is_error) {
[18:06:14.979]                   sessionInformation <- function() {
[18:06:14.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:14.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:14.979]                       search = base::search(), system = base::Sys.info())
[18:06:14.979]                   }
[18:06:14.979]                   ...future.conditions[[length(...future.conditions) + 
[18:06:14.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:14.979]                     cond$call), session = sessionInformation(), 
[18:06:14.979]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:14.979]                   signalCondition(cond)
[18:06:14.979]                 }
[18:06:14.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:14.979]                 "immediateCondition"))) {
[18:06:14.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:14.979]                   ...future.conditions[[length(...future.conditions) + 
[18:06:14.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:14.979]                   if (TRUE && !signal) {
[18:06:14.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:14.979]                     {
[18:06:14.979]                       inherits <- base::inherits
[18:06:14.979]                       invokeRestart <- base::invokeRestart
[18:06:14.979]                       is.null <- base::is.null
[18:06:14.979]                       muffled <- FALSE
[18:06:14.979]                       if (inherits(cond, "message")) {
[18:06:14.979]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:14.979]                         if (muffled) 
[18:06:14.979]                           invokeRestart("muffleMessage")
[18:06:14.979]                       }
[18:06:14.979]                       else if (inherits(cond, "warning")) {
[18:06:14.979]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:14.979]                         if (muffled) 
[18:06:14.979]                           invokeRestart("muffleWarning")
[18:06:14.979]                       }
[18:06:14.979]                       else if (inherits(cond, "condition")) {
[18:06:14.979]                         if (!is.null(pattern)) {
[18:06:14.979]                           computeRestarts <- base::computeRestarts
[18:06:14.979]                           grepl <- base::grepl
[18:06:14.979]                           restarts <- computeRestarts(cond)
[18:06:14.979]                           for (restart in restarts) {
[18:06:14.979]                             name <- restart$name
[18:06:14.979]                             if (is.null(name)) 
[18:06:14.979]                               next
[18:06:14.979]                             if (!grepl(pattern, name)) 
[18:06:14.979]                               next
[18:06:14.979]                             invokeRestart(restart)
[18:06:14.979]                             muffled <- TRUE
[18:06:14.979]                             break
[18:06:14.979]                           }
[18:06:14.979]                         }
[18:06:14.979]                       }
[18:06:14.979]                       invisible(muffled)
[18:06:14.979]                     }
[18:06:14.979]                     muffleCondition(cond, pattern = "^muffle")
[18:06:14.979]                   }
[18:06:14.979]                 }
[18:06:14.979]                 else {
[18:06:14.979]                   if (TRUE) {
[18:06:14.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:14.979]                     {
[18:06:14.979]                       inherits <- base::inherits
[18:06:14.979]                       invokeRestart <- base::invokeRestart
[18:06:14.979]                       is.null <- base::is.null
[18:06:14.979]                       muffled <- FALSE
[18:06:14.979]                       if (inherits(cond, "message")) {
[18:06:14.979]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:14.979]                         if (muffled) 
[18:06:14.979]                           invokeRestart("muffleMessage")
[18:06:14.979]                       }
[18:06:14.979]                       else if (inherits(cond, "warning")) {
[18:06:14.979]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:14.979]                         if (muffled) 
[18:06:14.979]                           invokeRestart("muffleWarning")
[18:06:14.979]                       }
[18:06:14.979]                       else if (inherits(cond, "condition")) {
[18:06:14.979]                         if (!is.null(pattern)) {
[18:06:14.979]                           computeRestarts <- base::computeRestarts
[18:06:14.979]                           grepl <- base::grepl
[18:06:14.979]                           restarts <- computeRestarts(cond)
[18:06:14.979]                           for (restart in restarts) {
[18:06:14.979]                             name <- restart$name
[18:06:14.979]                             if (is.null(name)) 
[18:06:14.979]                               next
[18:06:14.979]                             if (!grepl(pattern, name)) 
[18:06:14.979]                               next
[18:06:14.979]                             invokeRestart(restart)
[18:06:14.979]                             muffled <- TRUE
[18:06:14.979]                             break
[18:06:14.979]                           }
[18:06:14.979]                         }
[18:06:14.979]                       }
[18:06:14.979]                       invisible(muffled)
[18:06:14.979]                     }
[18:06:14.979]                     muffleCondition(cond, pattern = "^muffle")
[18:06:14.979]                   }
[18:06:14.979]                 }
[18:06:14.979]             }
[18:06:14.979]         }))
[18:06:14.979]     }, error = function(ex) {
[18:06:14.979]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:14.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:14.979]                 ...future.rng), started = ...future.startTime, 
[18:06:14.979]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:14.979]             version = "1.8"), class = "FutureResult")
[18:06:14.979]     }, finally = {
[18:06:14.979]         if (!identical(...future.workdir, getwd())) 
[18:06:14.979]             setwd(...future.workdir)
[18:06:14.979]         {
[18:06:14.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:14.979]                 ...future.oldOptions$nwarnings <- NULL
[18:06:14.979]             }
[18:06:14.979]             base::options(...future.oldOptions)
[18:06:14.979]             if (.Platform$OS.type == "windows") {
[18:06:14.979]                 old_names <- names(...future.oldEnvVars)
[18:06:14.979]                 envs <- base::Sys.getenv()
[18:06:14.979]                 names <- names(envs)
[18:06:14.979]                 common <- intersect(names, old_names)
[18:06:14.979]                 added <- setdiff(names, old_names)
[18:06:14.979]                 removed <- setdiff(old_names, names)
[18:06:14.979]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:14.979]                   envs[common]]
[18:06:14.979]                 NAMES <- toupper(changed)
[18:06:14.979]                 args <- list()
[18:06:14.979]                 for (kk in seq_along(NAMES)) {
[18:06:14.979]                   name <- changed[[kk]]
[18:06:14.979]                   NAME <- NAMES[[kk]]
[18:06:14.979]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:14.979]                     next
[18:06:14.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:14.979]                 }
[18:06:14.979]                 NAMES <- toupper(added)
[18:06:14.979]                 for (kk in seq_along(NAMES)) {
[18:06:14.979]                   name <- added[[kk]]
[18:06:14.979]                   NAME <- NAMES[[kk]]
[18:06:14.979]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:14.979]                     next
[18:06:14.979]                   args[[name]] <- ""
[18:06:14.979]                 }
[18:06:14.979]                 NAMES <- toupper(removed)
[18:06:14.979]                 for (kk in seq_along(NAMES)) {
[18:06:14.979]                   name <- removed[[kk]]
[18:06:14.979]                   NAME <- NAMES[[kk]]
[18:06:14.979]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:14.979]                     next
[18:06:14.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:14.979]                 }
[18:06:14.979]                 if (length(args) > 0) 
[18:06:14.979]                   base::do.call(base::Sys.setenv, args = args)
[18:06:14.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:14.979]             }
[18:06:14.979]             else {
[18:06:14.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:14.979]             }
[18:06:14.979]             {
[18:06:14.979]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:14.979]                   0L) {
[18:06:14.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:14.979]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:14.979]                   base::options(opts)
[18:06:14.979]                 }
[18:06:14.979]                 {
[18:06:14.979]                   {
[18:06:14.979]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:14.979]                     NULL
[18:06:14.979]                   }
[18:06:14.979]                   options(future.plan = NULL)
[18:06:14.979]                   if (is.na(NA_character_)) 
[18:06:14.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:14.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:14.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:14.979]                     .init = FALSE)
[18:06:14.979]                 }
[18:06:14.979]             }
[18:06:14.979]         }
[18:06:14.979]     })
[18:06:14.979]     if (TRUE) {
[18:06:14.979]         base::sink(type = "output", split = FALSE)
[18:06:14.979]         if (TRUE) {
[18:06:14.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:14.979]         }
[18:06:14.979]         else {
[18:06:14.979]             ...future.result["stdout"] <- base::list(NULL)
[18:06:14.979]         }
[18:06:14.979]         base::close(...future.stdout)
[18:06:14.979]         ...future.stdout <- NULL
[18:06:14.979]     }
[18:06:14.979]     ...future.result$conditions <- ...future.conditions
[18:06:14.979]     ...future.result$finished <- base::Sys.time()
[18:06:14.979]     ...future.result
[18:06:14.979] }
[18:06:14.987] MultisessionFuture started
[18:06:14.987] - Launch lazy future ... done
[18:06:14.987] run() for ‘MultisessionFuture’ ... done
[18:06:15.031] receiveMessageFromWorker() for ClusterFuture ...
[18:06:15.032] - Validating connection of MultisessionFuture
[18:06:15.033] - received message: FutureResult
[18:06:15.033] - Received FutureResult
[18:06:15.034] - Erased future from FutureRegistry
[18:06:15.034] result() for ClusterFuture ...
[18:06:15.034] - result already collected: FutureResult
[18:06:15.035] result() for ClusterFuture ... done
[18:06:15.035] signalConditions() ...
[18:06:15.035]  - include = ‘immediateCondition’
[18:06:15.035]  - exclude = 
[18:06:15.036]  - resignal = FALSE
[18:06:15.036]  - Number of conditions: 1
[18:06:15.036] signalConditions() ... done
[18:06:15.037] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:15.037] A MultisessionFuture was resolved (result was not collected)
[18:06:15.037] getGlobalsAndPackages() ...
[18:06:15.038] Searching for globals...
[18:06:15.040] - globals found: [2] ‘list’, ‘stop’
[18:06:15.040] Searching for globals ... DONE
[18:06:15.040] Resolving globals: FALSE
[18:06:15.041] 
[18:06:15.042] 
[18:06:15.042] getGlobalsAndPackages() ... DONE
[18:06:15.043] run() for ‘Future’ ...
[18:06:15.043] - state: ‘created’
[18:06:15.043] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:15.075] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:15.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:15.075]   - Field: ‘node’
[18:06:15.076]   - Field: ‘label’
[18:06:15.076]   - Field: ‘local’
[18:06:15.076]   - Field: ‘owner’
[18:06:15.076]   - Field: ‘envir’
[18:06:15.077]   - Field: ‘workers’
[18:06:15.077]   - Field: ‘packages’
[18:06:15.077]   - Field: ‘gc’
[18:06:15.078]   - Field: ‘conditions’
[18:06:15.078]   - Field: ‘persistent’
[18:06:15.078]   - Field: ‘expr’
[18:06:15.078]   - Field: ‘uuid’
[18:06:15.079]   - Field: ‘seed’
[18:06:15.079]   - Field: ‘version’
[18:06:15.079]   - Field: ‘result’
[18:06:15.079]   - Field: ‘asynchronous’
[18:06:15.080]   - Field: ‘calls’
[18:06:15.080]   - Field: ‘globals’
[18:06:15.080]   - Field: ‘stdout’
[18:06:15.080]   - Field: ‘earlySignal’
[18:06:15.081]   - Field: ‘lazy’
[18:06:15.081]   - Field: ‘state’
[18:06:15.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:15.081] - Launch lazy future ...
[18:06:15.082] Packages needed by the future expression (n = 0): <none>
[18:06:15.082] Packages needed by future strategies (n = 0): <none>
[18:06:15.083] {
[18:06:15.083]     {
[18:06:15.083]         {
[18:06:15.083]             ...future.startTime <- base::Sys.time()
[18:06:15.083]             {
[18:06:15.083]                 {
[18:06:15.083]                   {
[18:06:15.083]                     {
[18:06:15.083]                       base::local({
[18:06:15.083]                         has_future <- base::requireNamespace("future", 
[18:06:15.083]                           quietly = TRUE)
[18:06:15.083]                         if (has_future) {
[18:06:15.083]                           ns <- base::getNamespace("future")
[18:06:15.083]                           version <- ns[[".package"]][["version"]]
[18:06:15.083]                           if (is.null(version)) 
[18:06:15.083]                             version <- utils::packageVersion("future")
[18:06:15.083]                         }
[18:06:15.083]                         else {
[18:06:15.083]                           version <- NULL
[18:06:15.083]                         }
[18:06:15.083]                         if (!has_future || version < "1.8.0") {
[18:06:15.083]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:15.083]                             "", base::R.version$version.string), 
[18:06:15.083]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:15.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:15.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:15.083]                               "release", "version")], collapse = " "), 
[18:06:15.083]                             hostname = base::Sys.info()[["nodename"]])
[18:06:15.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:15.083]                             info)
[18:06:15.083]                           info <- base::paste(info, collapse = "; ")
[18:06:15.083]                           if (!has_future) {
[18:06:15.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:15.083]                               info)
[18:06:15.083]                           }
[18:06:15.083]                           else {
[18:06:15.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:15.083]                               info, version)
[18:06:15.083]                           }
[18:06:15.083]                           base::stop(msg)
[18:06:15.083]                         }
[18:06:15.083]                       })
[18:06:15.083]                     }
[18:06:15.083]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:15.083]                     base::options(mc.cores = 1L)
[18:06:15.083]                   }
[18:06:15.083]                   ...future.strategy.old <- future::plan("list")
[18:06:15.083]                   options(future.plan = NULL)
[18:06:15.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:15.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:15.083]                 }
[18:06:15.083]                 ...future.workdir <- getwd()
[18:06:15.083]             }
[18:06:15.083]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:15.083]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:15.083]         }
[18:06:15.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:15.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:15.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:15.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:15.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:15.083]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:15.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:15.083]             base::names(...future.oldOptions))
[18:06:15.083]     }
[18:06:15.083]     if (FALSE) {
[18:06:15.083]     }
[18:06:15.083]     else {
[18:06:15.083]         if (TRUE) {
[18:06:15.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:15.083]                 open = "w")
[18:06:15.083]         }
[18:06:15.083]         else {
[18:06:15.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:15.083]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:15.083]         }
[18:06:15.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:15.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:15.083]             base::sink(type = "output", split = FALSE)
[18:06:15.083]             base::close(...future.stdout)
[18:06:15.083]         }, add = TRUE)
[18:06:15.083]     }
[18:06:15.083]     ...future.frame <- base::sys.nframe()
[18:06:15.083]     ...future.conditions <- base::list()
[18:06:15.083]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:15.083]     if (FALSE) {
[18:06:15.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:15.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:15.083]     }
[18:06:15.083]     ...future.result <- base::tryCatch({
[18:06:15.083]         base::withCallingHandlers({
[18:06:15.083]             ...future.value <- base::withVisible(base::local({
[18:06:15.083]                 ...future.makeSendCondition <- base::local({
[18:06:15.083]                   sendCondition <- NULL
[18:06:15.083]                   function(frame = 1L) {
[18:06:15.083]                     if (is.function(sendCondition)) 
[18:06:15.083]                       return(sendCondition)
[18:06:15.083]                     ns <- getNamespace("parallel")
[18:06:15.083]                     if (exists("sendData", mode = "function", 
[18:06:15.083]                       envir = ns)) {
[18:06:15.083]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:15.083]                         envir = ns)
[18:06:15.083]                       envir <- sys.frame(frame)
[18:06:15.083]                       master <- NULL
[18:06:15.083]                       while (!identical(envir, .GlobalEnv) && 
[18:06:15.083]                         !identical(envir, emptyenv())) {
[18:06:15.083]                         if (exists("master", mode = "list", envir = envir, 
[18:06:15.083]                           inherits = FALSE)) {
[18:06:15.083]                           master <- get("master", mode = "list", 
[18:06:15.083]                             envir = envir, inherits = FALSE)
[18:06:15.083]                           if (inherits(master, c("SOCKnode", 
[18:06:15.083]                             "SOCK0node"))) {
[18:06:15.083]                             sendCondition <<- function(cond) {
[18:06:15.083]                               data <- list(type = "VALUE", value = cond, 
[18:06:15.083]                                 success = TRUE)
[18:06:15.083]                               parallel_sendData(master, data)
[18:06:15.083]                             }
[18:06:15.083]                             return(sendCondition)
[18:06:15.083]                           }
[18:06:15.083]                         }
[18:06:15.083]                         frame <- frame + 1L
[18:06:15.083]                         envir <- sys.frame(frame)
[18:06:15.083]                       }
[18:06:15.083]                     }
[18:06:15.083]                     sendCondition <<- function(cond) NULL
[18:06:15.083]                   }
[18:06:15.083]                 })
[18:06:15.083]                 withCallingHandlers({
[18:06:15.083]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:15.083]                 }, immediateCondition = function(cond) {
[18:06:15.083]                   sendCondition <- ...future.makeSendCondition()
[18:06:15.083]                   sendCondition(cond)
[18:06:15.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.083]                   {
[18:06:15.083]                     inherits <- base::inherits
[18:06:15.083]                     invokeRestart <- base::invokeRestart
[18:06:15.083]                     is.null <- base::is.null
[18:06:15.083]                     muffled <- FALSE
[18:06:15.083]                     if (inherits(cond, "message")) {
[18:06:15.083]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:15.083]                       if (muffled) 
[18:06:15.083]                         invokeRestart("muffleMessage")
[18:06:15.083]                     }
[18:06:15.083]                     else if (inherits(cond, "warning")) {
[18:06:15.083]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:15.083]                       if (muffled) 
[18:06:15.083]                         invokeRestart("muffleWarning")
[18:06:15.083]                     }
[18:06:15.083]                     else if (inherits(cond, "condition")) {
[18:06:15.083]                       if (!is.null(pattern)) {
[18:06:15.083]                         computeRestarts <- base::computeRestarts
[18:06:15.083]                         grepl <- base::grepl
[18:06:15.083]                         restarts <- computeRestarts(cond)
[18:06:15.083]                         for (restart in restarts) {
[18:06:15.083]                           name <- restart$name
[18:06:15.083]                           if (is.null(name)) 
[18:06:15.083]                             next
[18:06:15.083]                           if (!grepl(pattern, name)) 
[18:06:15.083]                             next
[18:06:15.083]                           invokeRestart(restart)
[18:06:15.083]                           muffled <- TRUE
[18:06:15.083]                           break
[18:06:15.083]                         }
[18:06:15.083]                       }
[18:06:15.083]                     }
[18:06:15.083]                     invisible(muffled)
[18:06:15.083]                   }
[18:06:15.083]                   muffleCondition(cond)
[18:06:15.083]                 })
[18:06:15.083]             }))
[18:06:15.083]             future::FutureResult(value = ...future.value$value, 
[18:06:15.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:15.083]                   ...future.rng), globalenv = if (FALSE) 
[18:06:15.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:15.083]                     ...future.globalenv.names))
[18:06:15.083]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:15.083]         }, condition = base::local({
[18:06:15.083]             c <- base::c
[18:06:15.083]             inherits <- base::inherits
[18:06:15.083]             invokeRestart <- base::invokeRestart
[18:06:15.083]             length <- base::length
[18:06:15.083]             list <- base::list
[18:06:15.083]             seq.int <- base::seq.int
[18:06:15.083]             signalCondition <- base::signalCondition
[18:06:15.083]             sys.calls <- base::sys.calls
[18:06:15.083]             `[[` <- base::`[[`
[18:06:15.083]             `+` <- base::`+`
[18:06:15.083]             `<<-` <- base::`<<-`
[18:06:15.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:15.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:15.083]                   3L)]
[18:06:15.083]             }
[18:06:15.083]             function(cond) {
[18:06:15.083]                 is_error <- inherits(cond, "error")
[18:06:15.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:15.083]                   NULL)
[18:06:15.083]                 if (is_error) {
[18:06:15.083]                   sessionInformation <- function() {
[18:06:15.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:15.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:15.083]                       search = base::search(), system = base::Sys.info())
[18:06:15.083]                   }
[18:06:15.083]                   ...future.conditions[[length(...future.conditions) + 
[18:06:15.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:15.083]                     cond$call), session = sessionInformation(), 
[18:06:15.083]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:15.083]                   signalCondition(cond)
[18:06:15.083]                 }
[18:06:15.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:15.083]                 "immediateCondition"))) {
[18:06:15.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:15.083]                   ...future.conditions[[length(...future.conditions) + 
[18:06:15.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:15.083]                   if (TRUE && !signal) {
[18:06:15.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.083]                     {
[18:06:15.083]                       inherits <- base::inherits
[18:06:15.083]                       invokeRestart <- base::invokeRestart
[18:06:15.083]                       is.null <- base::is.null
[18:06:15.083]                       muffled <- FALSE
[18:06:15.083]                       if (inherits(cond, "message")) {
[18:06:15.083]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:15.083]                         if (muffled) 
[18:06:15.083]                           invokeRestart("muffleMessage")
[18:06:15.083]                       }
[18:06:15.083]                       else if (inherits(cond, "warning")) {
[18:06:15.083]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:15.083]                         if (muffled) 
[18:06:15.083]                           invokeRestart("muffleWarning")
[18:06:15.083]                       }
[18:06:15.083]                       else if (inherits(cond, "condition")) {
[18:06:15.083]                         if (!is.null(pattern)) {
[18:06:15.083]                           computeRestarts <- base::computeRestarts
[18:06:15.083]                           grepl <- base::grepl
[18:06:15.083]                           restarts <- computeRestarts(cond)
[18:06:15.083]                           for (restart in restarts) {
[18:06:15.083]                             name <- restart$name
[18:06:15.083]                             if (is.null(name)) 
[18:06:15.083]                               next
[18:06:15.083]                             if (!grepl(pattern, name)) 
[18:06:15.083]                               next
[18:06:15.083]                             invokeRestart(restart)
[18:06:15.083]                             muffled <- TRUE
[18:06:15.083]                             break
[18:06:15.083]                           }
[18:06:15.083]                         }
[18:06:15.083]                       }
[18:06:15.083]                       invisible(muffled)
[18:06:15.083]                     }
[18:06:15.083]                     muffleCondition(cond, pattern = "^muffle")
[18:06:15.083]                   }
[18:06:15.083]                 }
[18:06:15.083]                 else {
[18:06:15.083]                   if (TRUE) {
[18:06:15.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.083]                     {
[18:06:15.083]                       inherits <- base::inherits
[18:06:15.083]                       invokeRestart <- base::invokeRestart
[18:06:15.083]                       is.null <- base::is.null
[18:06:15.083]                       muffled <- FALSE
[18:06:15.083]                       if (inherits(cond, "message")) {
[18:06:15.083]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:15.083]                         if (muffled) 
[18:06:15.083]                           invokeRestart("muffleMessage")
[18:06:15.083]                       }
[18:06:15.083]                       else if (inherits(cond, "warning")) {
[18:06:15.083]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:15.083]                         if (muffled) 
[18:06:15.083]                           invokeRestart("muffleWarning")
[18:06:15.083]                       }
[18:06:15.083]                       else if (inherits(cond, "condition")) {
[18:06:15.083]                         if (!is.null(pattern)) {
[18:06:15.083]                           computeRestarts <- base::computeRestarts
[18:06:15.083]                           grepl <- base::grepl
[18:06:15.083]                           restarts <- computeRestarts(cond)
[18:06:15.083]                           for (restart in restarts) {
[18:06:15.083]                             name <- restart$name
[18:06:15.083]                             if (is.null(name)) 
[18:06:15.083]                               next
[18:06:15.083]                             if (!grepl(pattern, name)) 
[18:06:15.083]                               next
[18:06:15.083]                             invokeRestart(restart)
[18:06:15.083]                             muffled <- TRUE
[18:06:15.083]                             break
[18:06:15.083]                           }
[18:06:15.083]                         }
[18:06:15.083]                       }
[18:06:15.083]                       invisible(muffled)
[18:06:15.083]                     }
[18:06:15.083]                     muffleCondition(cond, pattern = "^muffle")
[18:06:15.083]                   }
[18:06:15.083]                 }
[18:06:15.083]             }
[18:06:15.083]         }))
[18:06:15.083]     }, error = function(ex) {
[18:06:15.083]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:15.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:15.083]                 ...future.rng), started = ...future.startTime, 
[18:06:15.083]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:15.083]             version = "1.8"), class = "FutureResult")
[18:06:15.083]     }, finally = {
[18:06:15.083]         if (!identical(...future.workdir, getwd())) 
[18:06:15.083]             setwd(...future.workdir)
[18:06:15.083]         {
[18:06:15.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:15.083]                 ...future.oldOptions$nwarnings <- NULL
[18:06:15.083]             }
[18:06:15.083]             base::options(...future.oldOptions)
[18:06:15.083]             if (.Platform$OS.type == "windows") {
[18:06:15.083]                 old_names <- names(...future.oldEnvVars)
[18:06:15.083]                 envs <- base::Sys.getenv()
[18:06:15.083]                 names <- names(envs)
[18:06:15.083]                 common <- intersect(names, old_names)
[18:06:15.083]                 added <- setdiff(names, old_names)
[18:06:15.083]                 removed <- setdiff(old_names, names)
[18:06:15.083]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:15.083]                   envs[common]]
[18:06:15.083]                 NAMES <- toupper(changed)
[18:06:15.083]                 args <- list()
[18:06:15.083]                 for (kk in seq_along(NAMES)) {
[18:06:15.083]                   name <- changed[[kk]]
[18:06:15.083]                   NAME <- NAMES[[kk]]
[18:06:15.083]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.083]                     next
[18:06:15.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:15.083]                 }
[18:06:15.083]                 NAMES <- toupper(added)
[18:06:15.083]                 for (kk in seq_along(NAMES)) {
[18:06:15.083]                   name <- added[[kk]]
[18:06:15.083]                   NAME <- NAMES[[kk]]
[18:06:15.083]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.083]                     next
[18:06:15.083]                   args[[name]] <- ""
[18:06:15.083]                 }
[18:06:15.083]                 NAMES <- toupper(removed)
[18:06:15.083]                 for (kk in seq_along(NAMES)) {
[18:06:15.083]                   name <- removed[[kk]]
[18:06:15.083]                   NAME <- NAMES[[kk]]
[18:06:15.083]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.083]                     next
[18:06:15.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:15.083]                 }
[18:06:15.083]                 if (length(args) > 0) 
[18:06:15.083]                   base::do.call(base::Sys.setenv, args = args)
[18:06:15.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:15.083]             }
[18:06:15.083]             else {
[18:06:15.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:15.083]             }
[18:06:15.083]             {
[18:06:15.083]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:15.083]                   0L) {
[18:06:15.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:15.083]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:15.083]                   base::options(opts)
[18:06:15.083]                 }
[18:06:15.083]                 {
[18:06:15.083]                   {
[18:06:15.083]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:15.083]                     NULL
[18:06:15.083]                   }
[18:06:15.083]                   options(future.plan = NULL)
[18:06:15.083]                   if (is.na(NA_character_)) 
[18:06:15.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:15.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:15.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:15.083]                     .init = FALSE)
[18:06:15.083]                 }
[18:06:15.083]             }
[18:06:15.083]         }
[18:06:15.083]     })
[18:06:15.083]     if (TRUE) {
[18:06:15.083]         base::sink(type = "output", split = FALSE)
[18:06:15.083]         if (TRUE) {
[18:06:15.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:15.083]         }
[18:06:15.083]         else {
[18:06:15.083]             ...future.result["stdout"] <- base::list(NULL)
[18:06:15.083]         }
[18:06:15.083]         base::close(...future.stdout)
[18:06:15.083]         ...future.stdout <- NULL
[18:06:15.083]     }
[18:06:15.083]     ...future.result$conditions <- ...future.conditions
[18:06:15.083]     ...future.result$finished <- base::Sys.time()
[18:06:15.083]     ...future.result
[18:06:15.083] }
[18:06:15.090] MultisessionFuture started
[18:06:15.090] - Launch lazy future ... done
[18:06:15.091] run() for ‘MultisessionFuture’ ... done
[18:06:15.135] receiveMessageFromWorker() for ClusterFuture ...
[18:06:15.135] - Validating connection of MultisessionFuture
[18:06:15.137] - received message: FutureResult
[18:06:15.137] - Received FutureResult
[18:06:15.137] - Erased future from FutureRegistry
[18:06:15.138] result() for ClusterFuture ...
[18:06:15.138] - result already collected: FutureResult
[18:06:15.138] result() for ClusterFuture ... done
[18:06:15.139] signalConditions() ...
[18:06:15.139]  - include = ‘immediateCondition’
[18:06:15.139]  - exclude = 
[18:06:15.139]  - resignal = FALSE
[18:06:15.140]  - Number of conditions: 1
[18:06:15.140] signalConditions() ... done
[18:06:15.140] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:15.141] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[18:06:15.142] getGlobalsAndPackages() ...
[18:06:15.142] Searching for globals...
[18:06:15.146] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:15.146] Searching for globals ... DONE
[18:06:15.147] Resolving globals: FALSE
[18:06:15.148] 
[18:06:15.148] 
[18:06:15.148] getGlobalsAndPackages() ... DONE
[18:06:15.149] run() for ‘Future’ ...
[18:06:15.149] - state: ‘created’
[18:06:15.150] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:15.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:15.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:15.177]   - Field: ‘node’
[18:06:15.177]   - Field: ‘label’
[18:06:15.177]   - Field: ‘local’
[18:06:15.178]   - Field: ‘owner’
[18:06:15.178]   - Field: ‘envir’
[18:06:15.178]   - Field: ‘workers’
[18:06:15.178]   - Field: ‘packages’
[18:06:15.178]   - Field: ‘gc’
[18:06:15.179]   - Field: ‘conditions’
[18:06:15.179]   - Field: ‘persistent’
[18:06:15.179]   - Field: ‘expr’
[18:06:15.179]   - Field: ‘uuid’
[18:06:15.179]   - Field: ‘seed’
[18:06:15.180]   - Field: ‘version’
[18:06:15.180]   - Field: ‘result’
[18:06:15.180]   - Field: ‘asynchronous’
[18:06:15.180]   - Field: ‘calls’
[18:06:15.180]   - Field: ‘globals’
[18:06:15.181]   - Field: ‘stdout’
[18:06:15.181]   - Field: ‘earlySignal’
[18:06:15.181]   - Field: ‘lazy’
[18:06:15.181]   - Field: ‘state’
[18:06:15.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:15.181] - Launch lazy future ...
[18:06:15.182] Packages needed by the future expression (n = 0): <none>
[18:06:15.182] Packages needed by future strategies (n = 0): <none>
[18:06:15.183] {
[18:06:15.183]     {
[18:06:15.183]         {
[18:06:15.183]             ...future.startTime <- base::Sys.time()
[18:06:15.183]             {
[18:06:15.183]                 {
[18:06:15.183]                   {
[18:06:15.183]                     {
[18:06:15.183]                       base::local({
[18:06:15.183]                         has_future <- base::requireNamespace("future", 
[18:06:15.183]                           quietly = TRUE)
[18:06:15.183]                         if (has_future) {
[18:06:15.183]                           ns <- base::getNamespace("future")
[18:06:15.183]                           version <- ns[[".package"]][["version"]]
[18:06:15.183]                           if (is.null(version)) 
[18:06:15.183]                             version <- utils::packageVersion("future")
[18:06:15.183]                         }
[18:06:15.183]                         else {
[18:06:15.183]                           version <- NULL
[18:06:15.183]                         }
[18:06:15.183]                         if (!has_future || version < "1.8.0") {
[18:06:15.183]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:15.183]                             "", base::R.version$version.string), 
[18:06:15.183]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:15.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:15.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:15.183]                               "release", "version")], collapse = " "), 
[18:06:15.183]                             hostname = base::Sys.info()[["nodename"]])
[18:06:15.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:15.183]                             info)
[18:06:15.183]                           info <- base::paste(info, collapse = "; ")
[18:06:15.183]                           if (!has_future) {
[18:06:15.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:15.183]                               info)
[18:06:15.183]                           }
[18:06:15.183]                           else {
[18:06:15.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:15.183]                               info, version)
[18:06:15.183]                           }
[18:06:15.183]                           base::stop(msg)
[18:06:15.183]                         }
[18:06:15.183]                       })
[18:06:15.183]                     }
[18:06:15.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:15.183]                     base::options(mc.cores = 1L)
[18:06:15.183]                   }
[18:06:15.183]                   ...future.strategy.old <- future::plan("list")
[18:06:15.183]                   options(future.plan = NULL)
[18:06:15.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:15.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:15.183]                 }
[18:06:15.183]                 ...future.workdir <- getwd()
[18:06:15.183]             }
[18:06:15.183]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:15.183]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:15.183]         }
[18:06:15.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:15.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:15.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:15.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:15.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:15.183]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:15.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:15.183]             base::names(...future.oldOptions))
[18:06:15.183]     }
[18:06:15.183]     if (FALSE) {
[18:06:15.183]     }
[18:06:15.183]     else {
[18:06:15.183]         if (TRUE) {
[18:06:15.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:15.183]                 open = "w")
[18:06:15.183]         }
[18:06:15.183]         else {
[18:06:15.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:15.183]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:15.183]         }
[18:06:15.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:15.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:15.183]             base::sink(type = "output", split = FALSE)
[18:06:15.183]             base::close(...future.stdout)
[18:06:15.183]         }, add = TRUE)
[18:06:15.183]     }
[18:06:15.183]     ...future.frame <- base::sys.nframe()
[18:06:15.183]     ...future.conditions <- base::list()
[18:06:15.183]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:15.183]     if (FALSE) {
[18:06:15.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:15.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:15.183]     }
[18:06:15.183]     ...future.result <- base::tryCatch({
[18:06:15.183]         base::withCallingHandlers({
[18:06:15.183]             ...future.value <- base::withVisible(base::local({
[18:06:15.183]                 ...future.makeSendCondition <- base::local({
[18:06:15.183]                   sendCondition <- NULL
[18:06:15.183]                   function(frame = 1L) {
[18:06:15.183]                     if (is.function(sendCondition)) 
[18:06:15.183]                       return(sendCondition)
[18:06:15.183]                     ns <- getNamespace("parallel")
[18:06:15.183]                     if (exists("sendData", mode = "function", 
[18:06:15.183]                       envir = ns)) {
[18:06:15.183]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:15.183]                         envir = ns)
[18:06:15.183]                       envir <- sys.frame(frame)
[18:06:15.183]                       master <- NULL
[18:06:15.183]                       while (!identical(envir, .GlobalEnv) && 
[18:06:15.183]                         !identical(envir, emptyenv())) {
[18:06:15.183]                         if (exists("master", mode = "list", envir = envir, 
[18:06:15.183]                           inherits = FALSE)) {
[18:06:15.183]                           master <- get("master", mode = "list", 
[18:06:15.183]                             envir = envir, inherits = FALSE)
[18:06:15.183]                           if (inherits(master, c("SOCKnode", 
[18:06:15.183]                             "SOCK0node"))) {
[18:06:15.183]                             sendCondition <<- function(cond) {
[18:06:15.183]                               data <- list(type = "VALUE", value = cond, 
[18:06:15.183]                                 success = TRUE)
[18:06:15.183]                               parallel_sendData(master, data)
[18:06:15.183]                             }
[18:06:15.183]                             return(sendCondition)
[18:06:15.183]                           }
[18:06:15.183]                         }
[18:06:15.183]                         frame <- frame + 1L
[18:06:15.183]                         envir <- sys.frame(frame)
[18:06:15.183]                       }
[18:06:15.183]                     }
[18:06:15.183]                     sendCondition <<- function(cond) NULL
[18:06:15.183]                   }
[18:06:15.183]                 })
[18:06:15.183]                 withCallingHandlers({
[18:06:15.183]                   {
[18:06:15.183]                     Sys.sleep(0.5)
[18:06:15.183]                     list(a = 1, b = 42L)
[18:06:15.183]                   }
[18:06:15.183]                 }, immediateCondition = function(cond) {
[18:06:15.183]                   sendCondition <- ...future.makeSendCondition()
[18:06:15.183]                   sendCondition(cond)
[18:06:15.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.183]                   {
[18:06:15.183]                     inherits <- base::inherits
[18:06:15.183]                     invokeRestart <- base::invokeRestart
[18:06:15.183]                     is.null <- base::is.null
[18:06:15.183]                     muffled <- FALSE
[18:06:15.183]                     if (inherits(cond, "message")) {
[18:06:15.183]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:15.183]                       if (muffled) 
[18:06:15.183]                         invokeRestart("muffleMessage")
[18:06:15.183]                     }
[18:06:15.183]                     else if (inherits(cond, "warning")) {
[18:06:15.183]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:15.183]                       if (muffled) 
[18:06:15.183]                         invokeRestart("muffleWarning")
[18:06:15.183]                     }
[18:06:15.183]                     else if (inherits(cond, "condition")) {
[18:06:15.183]                       if (!is.null(pattern)) {
[18:06:15.183]                         computeRestarts <- base::computeRestarts
[18:06:15.183]                         grepl <- base::grepl
[18:06:15.183]                         restarts <- computeRestarts(cond)
[18:06:15.183]                         for (restart in restarts) {
[18:06:15.183]                           name <- restart$name
[18:06:15.183]                           if (is.null(name)) 
[18:06:15.183]                             next
[18:06:15.183]                           if (!grepl(pattern, name)) 
[18:06:15.183]                             next
[18:06:15.183]                           invokeRestart(restart)
[18:06:15.183]                           muffled <- TRUE
[18:06:15.183]                           break
[18:06:15.183]                         }
[18:06:15.183]                       }
[18:06:15.183]                     }
[18:06:15.183]                     invisible(muffled)
[18:06:15.183]                   }
[18:06:15.183]                   muffleCondition(cond)
[18:06:15.183]                 })
[18:06:15.183]             }))
[18:06:15.183]             future::FutureResult(value = ...future.value$value, 
[18:06:15.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:15.183]                   ...future.rng), globalenv = if (FALSE) 
[18:06:15.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:15.183]                     ...future.globalenv.names))
[18:06:15.183]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:15.183]         }, condition = base::local({
[18:06:15.183]             c <- base::c
[18:06:15.183]             inherits <- base::inherits
[18:06:15.183]             invokeRestart <- base::invokeRestart
[18:06:15.183]             length <- base::length
[18:06:15.183]             list <- base::list
[18:06:15.183]             seq.int <- base::seq.int
[18:06:15.183]             signalCondition <- base::signalCondition
[18:06:15.183]             sys.calls <- base::sys.calls
[18:06:15.183]             `[[` <- base::`[[`
[18:06:15.183]             `+` <- base::`+`
[18:06:15.183]             `<<-` <- base::`<<-`
[18:06:15.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:15.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:15.183]                   3L)]
[18:06:15.183]             }
[18:06:15.183]             function(cond) {
[18:06:15.183]                 is_error <- inherits(cond, "error")
[18:06:15.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:15.183]                   NULL)
[18:06:15.183]                 if (is_error) {
[18:06:15.183]                   sessionInformation <- function() {
[18:06:15.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:15.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:15.183]                       search = base::search(), system = base::Sys.info())
[18:06:15.183]                   }
[18:06:15.183]                   ...future.conditions[[length(...future.conditions) + 
[18:06:15.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:15.183]                     cond$call), session = sessionInformation(), 
[18:06:15.183]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:15.183]                   signalCondition(cond)
[18:06:15.183]                 }
[18:06:15.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:15.183]                 "immediateCondition"))) {
[18:06:15.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:15.183]                   ...future.conditions[[length(...future.conditions) + 
[18:06:15.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:15.183]                   if (TRUE && !signal) {
[18:06:15.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.183]                     {
[18:06:15.183]                       inherits <- base::inherits
[18:06:15.183]                       invokeRestart <- base::invokeRestart
[18:06:15.183]                       is.null <- base::is.null
[18:06:15.183]                       muffled <- FALSE
[18:06:15.183]                       if (inherits(cond, "message")) {
[18:06:15.183]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:15.183]                         if (muffled) 
[18:06:15.183]                           invokeRestart("muffleMessage")
[18:06:15.183]                       }
[18:06:15.183]                       else if (inherits(cond, "warning")) {
[18:06:15.183]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:15.183]                         if (muffled) 
[18:06:15.183]                           invokeRestart("muffleWarning")
[18:06:15.183]                       }
[18:06:15.183]                       else if (inherits(cond, "condition")) {
[18:06:15.183]                         if (!is.null(pattern)) {
[18:06:15.183]                           computeRestarts <- base::computeRestarts
[18:06:15.183]                           grepl <- base::grepl
[18:06:15.183]                           restarts <- computeRestarts(cond)
[18:06:15.183]                           for (restart in restarts) {
[18:06:15.183]                             name <- restart$name
[18:06:15.183]                             if (is.null(name)) 
[18:06:15.183]                               next
[18:06:15.183]                             if (!grepl(pattern, name)) 
[18:06:15.183]                               next
[18:06:15.183]                             invokeRestart(restart)
[18:06:15.183]                             muffled <- TRUE
[18:06:15.183]                             break
[18:06:15.183]                           }
[18:06:15.183]                         }
[18:06:15.183]                       }
[18:06:15.183]                       invisible(muffled)
[18:06:15.183]                     }
[18:06:15.183]                     muffleCondition(cond, pattern = "^muffle")
[18:06:15.183]                   }
[18:06:15.183]                 }
[18:06:15.183]                 else {
[18:06:15.183]                   if (TRUE) {
[18:06:15.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.183]                     {
[18:06:15.183]                       inherits <- base::inherits
[18:06:15.183]                       invokeRestart <- base::invokeRestart
[18:06:15.183]                       is.null <- base::is.null
[18:06:15.183]                       muffled <- FALSE
[18:06:15.183]                       if (inherits(cond, "message")) {
[18:06:15.183]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:15.183]                         if (muffled) 
[18:06:15.183]                           invokeRestart("muffleMessage")
[18:06:15.183]                       }
[18:06:15.183]                       else if (inherits(cond, "warning")) {
[18:06:15.183]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:15.183]                         if (muffled) 
[18:06:15.183]                           invokeRestart("muffleWarning")
[18:06:15.183]                       }
[18:06:15.183]                       else if (inherits(cond, "condition")) {
[18:06:15.183]                         if (!is.null(pattern)) {
[18:06:15.183]                           computeRestarts <- base::computeRestarts
[18:06:15.183]                           grepl <- base::grepl
[18:06:15.183]                           restarts <- computeRestarts(cond)
[18:06:15.183]                           for (restart in restarts) {
[18:06:15.183]                             name <- restart$name
[18:06:15.183]                             if (is.null(name)) 
[18:06:15.183]                               next
[18:06:15.183]                             if (!grepl(pattern, name)) 
[18:06:15.183]                               next
[18:06:15.183]                             invokeRestart(restart)
[18:06:15.183]                             muffled <- TRUE
[18:06:15.183]                             break
[18:06:15.183]                           }
[18:06:15.183]                         }
[18:06:15.183]                       }
[18:06:15.183]                       invisible(muffled)
[18:06:15.183]                     }
[18:06:15.183]                     muffleCondition(cond, pattern = "^muffle")
[18:06:15.183]                   }
[18:06:15.183]                 }
[18:06:15.183]             }
[18:06:15.183]         }))
[18:06:15.183]     }, error = function(ex) {
[18:06:15.183]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:15.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:15.183]                 ...future.rng), started = ...future.startTime, 
[18:06:15.183]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:15.183]             version = "1.8"), class = "FutureResult")
[18:06:15.183]     }, finally = {
[18:06:15.183]         if (!identical(...future.workdir, getwd())) 
[18:06:15.183]             setwd(...future.workdir)
[18:06:15.183]         {
[18:06:15.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:15.183]                 ...future.oldOptions$nwarnings <- NULL
[18:06:15.183]             }
[18:06:15.183]             base::options(...future.oldOptions)
[18:06:15.183]             if (.Platform$OS.type == "windows") {
[18:06:15.183]                 old_names <- names(...future.oldEnvVars)
[18:06:15.183]                 envs <- base::Sys.getenv()
[18:06:15.183]                 names <- names(envs)
[18:06:15.183]                 common <- intersect(names, old_names)
[18:06:15.183]                 added <- setdiff(names, old_names)
[18:06:15.183]                 removed <- setdiff(old_names, names)
[18:06:15.183]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:15.183]                   envs[common]]
[18:06:15.183]                 NAMES <- toupper(changed)
[18:06:15.183]                 args <- list()
[18:06:15.183]                 for (kk in seq_along(NAMES)) {
[18:06:15.183]                   name <- changed[[kk]]
[18:06:15.183]                   NAME <- NAMES[[kk]]
[18:06:15.183]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.183]                     next
[18:06:15.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:15.183]                 }
[18:06:15.183]                 NAMES <- toupper(added)
[18:06:15.183]                 for (kk in seq_along(NAMES)) {
[18:06:15.183]                   name <- added[[kk]]
[18:06:15.183]                   NAME <- NAMES[[kk]]
[18:06:15.183]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.183]                     next
[18:06:15.183]                   args[[name]] <- ""
[18:06:15.183]                 }
[18:06:15.183]                 NAMES <- toupper(removed)
[18:06:15.183]                 for (kk in seq_along(NAMES)) {
[18:06:15.183]                   name <- removed[[kk]]
[18:06:15.183]                   NAME <- NAMES[[kk]]
[18:06:15.183]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.183]                     next
[18:06:15.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:15.183]                 }
[18:06:15.183]                 if (length(args) > 0) 
[18:06:15.183]                   base::do.call(base::Sys.setenv, args = args)
[18:06:15.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:15.183]             }
[18:06:15.183]             else {
[18:06:15.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:15.183]             }
[18:06:15.183]             {
[18:06:15.183]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:15.183]                   0L) {
[18:06:15.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:15.183]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:15.183]                   base::options(opts)
[18:06:15.183]                 }
[18:06:15.183]                 {
[18:06:15.183]                   {
[18:06:15.183]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:15.183]                     NULL
[18:06:15.183]                   }
[18:06:15.183]                   options(future.plan = NULL)
[18:06:15.183]                   if (is.na(NA_character_)) 
[18:06:15.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:15.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:15.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:15.183]                     .init = FALSE)
[18:06:15.183]                 }
[18:06:15.183]             }
[18:06:15.183]         }
[18:06:15.183]     })
[18:06:15.183]     if (TRUE) {
[18:06:15.183]         base::sink(type = "output", split = FALSE)
[18:06:15.183]         if (TRUE) {
[18:06:15.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:15.183]         }
[18:06:15.183]         else {
[18:06:15.183]             ...future.result["stdout"] <- base::list(NULL)
[18:06:15.183]         }
[18:06:15.183]         base::close(...future.stdout)
[18:06:15.183]         ...future.stdout <- NULL
[18:06:15.183]     }
[18:06:15.183]     ...future.result$conditions <- ...future.conditions
[18:06:15.183]     ...future.result$finished <- base::Sys.time()
[18:06:15.183]     ...future.result
[18:06:15.183] }
[18:06:15.189] MultisessionFuture started
[18:06:15.189] - Launch lazy future ... done
[18:06:15.189] run() for ‘MultisessionFuture’ ... done
[18:06:15.734] receiveMessageFromWorker() for ClusterFuture ...
[18:06:15.734] - Validating connection of MultisessionFuture
[18:06:15.735] - received message: FutureResult
[18:06:15.735] - Received FutureResult
[18:06:15.735] - Erased future from FutureRegistry
[18:06:15.736] result() for ClusterFuture ...
[18:06:15.736] - result already collected: FutureResult
[18:06:15.736] result() for ClusterFuture ... done
[18:06:15.737] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:15.737] A MultisessionFuture was resolved (result was not collected)
[18:06:15.737] getGlobalsAndPackages() ...
[18:06:15.738] Searching for globals...
[18:06:15.741] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:15.742] Searching for globals ... DONE
[18:06:15.742] Resolving globals: FALSE
[18:06:15.743] 
[18:06:15.744] 
[18:06:15.744] getGlobalsAndPackages() ... DONE
[18:06:15.745] run() for ‘Future’ ...
[18:06:15.745] - state: ‘created’
[18:06:15.746] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:15.784] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:15.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:15.785]   - Field: ‘node’
[18:06:15.785]   - Field: ‘label’
[18:06:15.785]   - Field: ‘local’
[18:06:15.786]   - Field: ‘owner’
[18:06:15.787]   - Field: ‘envir’
[18:06:15.787]   - Field: ‘workers’
[18:06:15.787]   - Field: ‘packages’
[18:06:15.788]   - Field: ‘gc’
[18:06:15.788]   - Field: ‘conditions’
[18:06:15.788]   - Field: ‘persistent’
[18:06:15.789]   - Field: ‘expr’
[18:06:15.789]   - Field: ‘uuid’
[18:06:15.789]   - Field: ‘seed’
[18:06:15.789]   - Field: ‘version’
[18:06:15.790]   - Field: ‘result’
[18:06:15.790]   - Field: ‘asynchronous’
[18:06:15.790]   - Field: ‘calls’
[18:06:15.791]   - Field: ‘globals’
[18:06:15.791]   - Field: ‘stdout’
[18:06:15.791]   - Field: ‘earlySignal’
[18:06:15.792]   - Field: ‘lazy’
[18:06:15.792]   - Field: ‘state’
[18:06:15.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:15.793] - Launch lazy future ...
[18:06:15.793] Packages needed by the future expression (n = 0): <none>
[18:06:15.794] Packages needed by future strategies (n = 0): <none>
[18:06:15.795] {
[18:06:15.795]     {
[18:06:15.795]         {
[18:06:15.795]             ...future.startTime <- base::Sys.time()
[18:06:15.795]             {
[18:06:15.795]                 {
[18:06:15.795]                   {
[18:06:15.795]                     {
[18:06:15.795]                       base::local({
[18:06:15.795]                         has_future <- base::requireNamespace("future", 
[18:06:15.795]                           quietly = TRUE)
[18:06:15.795]                         if (has_future) {
[18:06:15.795]                           ns <- base::getNamespace("future")
[18:06:15.795]                           version <- ns[[".package"]][["version"]]
[18:06:15.795]                           if (is.null(version)) 
[18:06:15.795]                             version <- utils::packageVersion("future")
[18:06:15.795]                         }
[18:06:15.795]                         else {
[18:06:15.795]                           version <- NULL
[18:06:15.795]                         }
[18:06:15.795]                         if (!has_future || version < "1.8.0") {
[18:06:15.795]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:15.795]                             "", base::R.version$version.string), 
[18:06:15.795]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:15.795]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:15.795]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:15.795]                               "release", "version")], collapse = " "), 
[18:06:15.795]                             hostname = base::Sys.info()[["nodename"]])
[18:06:15.795]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:15.795]                             info)
[18:06:15.795]                           info <- base::paste(info, collapse = "; ")
[18:06:15.795]                           if (!has_future) {
[18:06:15.795]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:15.795]                               info)
[18:06:15.795]                           }
[18:06:15.795]                           else {
[18:06:15.795]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:15.795]                               info, version)
[18:06:15.795]                           }
[18:06:15.795]                           base::stop(msg)
[18:06:15.795]                         }
[18:06:15.795]                       })
[18:06:15.795]                     }
[18:06:15.795]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:15.795]                     base::options(mc.cores = 1L)
[18:06:15.795]                   }
[18:06:15.795]                   ...future.strategy.old <- future::plan("list")
[18:06:15.795]                   options(future.plan = NULL)
[18:06:15.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:15.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:15.795]                 }
[18:06:15.795]                 ...future.workdir <- getwd()
[18:06:15.795]             }
[18:06:15.795]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:15.795]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:15.795]         }
[18:06:15.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:15.795]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:15.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:15.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:15.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:15.795]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:15.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:15.795]             base::names(...future.oldOptions))
[18:06:15.795]     }
[18:06:15.795]     if (FALSE) {
[18:06:15.795]     }
[18:06:15.795]     else {
[18:06:15.795]         if (TRUE) {
[18:06:15.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:15.795]                 open = "w")
[18:06:15.795]         }
[18:06:15.795]         else {
[18:06:15.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:15.795]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:15.795]         }
[18:06:15.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:15.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:15.795]             base::sink(type = "output", split = FALSE)
[18:06:15.795]             base::close(...future.stdout)
[18:06:15.795]         }, add = TRUE)
[18:06:15.795]     }
[18:06:15.795]     ...future.frame <- base::sys.nframe()
[18:06:15.795]     ...future.conditions <- base::list()
[18:06:15.795]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:15.795]     if (FALSE) {
[18:06:15.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:15.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:15.795]     }
[18:06:15.795]     ...future.result <- base::tryCatch({
[18:06:15.795]         base::withCallingHandlers({
[18:06:15.795]             ...future.value <- base::withVisible(base::local({
[18:06:15.795]                 ...future.makeSendCondition <- base::local({
[18:06:15.795]                   sendCondition <- NULL
[18:06:15.795]                   function(frame = 1L) {
[18:06:15.795]                     if (is.function(sendCondition)) 
[18:06:15.795]                       return(sendCondition)
[18:06:15.795]                     ns <- getNamespace("parallel")
[18:06:15.795]                     if (exists("sendData", mode = "function", 
[18:06:15.795]                       envir = ns)) {
[18:06:15.795]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:15.795]                         envir = ns)
[18:06:15.795]                       envir <- sys.frame(frame)
[18:06:15.795]                       master <- NULL
[18:06:15.795]                       while (!identical(envir, .GlobalEnv) && 
[18:06:15.795]                         !identical(envir, emptyenv())) {
[18:06:15.795]                         if (exists("master", mode = "list", envir = envir, 
[18:06:15.795]                           inherits = FALSE)) {
[18:06:15.795]                           master <- get("master", mode = "list", 
[18:06:15.795]                             envir = envir, inherits = FALSE)
[18:06:15.795]                           if (inherits(master, c("SOCKnode", 
[18:06:15.795]                             "SOCK0node"))) {
[18:06:15.795]                             sendCondition <<- function(cond) {
[18:06:15.795]                               data <- list(type = "VALUE", value = cond, 
[18:06:15.795]                                 success = TRUE)
[18:06:15.795]                               parallel_sendData(master, data)
[18:06:15.795]                             }
[18:06:15.795]                             return(sendCondition)
[18:06:15.795]                           }
[18:06:15.795]                         }
[18:06:15.795]                         frame <- frame + 1L
[18:06:15.795]                         envir <- sys.frame(frame)
[18:06:15.795]                       }
[18:06:15.795]                     }
[18:06:15.795]                     sendCondition <<- function(cond) NULL
[18:06:15.795]                   }
[18:06:15.795]                 })
[18:06:15.795]                 withCallingHandlers({
[18:06:15.795]                   {
[18:06:15.795]                     Sys.sleep(0.5)
[18:06:15.795]                     list(a = 1, b = 42L)
[18:06:15.795]                   }
[18:06:15.795]                 }, immediateCondition = function(cond) {
[18:06:15.795]                   sendCondition <- ...future.makeSendCondition()
[18:06:15.795]                   sendCondition(cond)
[18:06:15.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.795]                   {
[18:06:15.795]                     inherits <- base::inherits
[18:06:15.795]                     invokeRestart <- base::invokeRestart
[18:06:15.795]                     is.null <- base::is.null
[18:06:15.795]                     muffled <- FALSE
[18:06:15.795]                     if (inherits(cond, "message")) {
[18:06:15.795]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:15.795]                       if (muffled) 
[18:06:15.795]                         invokeRestart("muffleMessage")
[18:06:15.795]                     }
[18:06:15.795]                     else if (inherits(cond, "warning")) {
[18:06:15.795]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:15.795]                       if (muffled) 
[18:06:15.795]                         invokeRestart("muffleWarning")
[18:06:15.795]                     }
[18:06:15.795]                     else if (inherits(cond, "condition")) {
[18:06:15.795]                       if (!is.null(pattern)) {
[18:06:15.795]                         computeRestarts <- base::computeRestarts
[18:06:15.795]                         grepl <- base::grepl
[18:06:15.795]                         restarts <- computeRestarts(cond)
[18:06:15.795]                         for (restart in restarts) {
[18:06:15.795]                           name <- restart$name
[18:06:15.795]                           if (is.null(name)) 
[18:06:15.795]                             next
[18:06:15.795]                           if (!grepl(pattern, name)) 
[18:06:15.795]                             next
[18:06:15.795]                           invokeRestart(restart)
[18:06:15.795]                           muffled <- TRUE
[18:06:15.795]                           break
[18:06:15.795]                         }
[18:06:15.795]                       }
[18:06:15.795]                     }
[18:06:15.795]                     invisible(muffled)
[18:06:15.795]                   }
[18:06:15.795]                   muffleCondition(cond)
[18:06:15.795]                 })
[18:06:15.795]             }))
[18:06:15.795]             future::FutureResult(value = ...future.value$value, 
[18:06:15.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:15.795]                   ...future.rng), globalenv = if (FALSE) 
[18:06:15.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:15.795]                     ...future.globalenv.names))
[18:06:15.795]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:15.795]         }, condition = base::local({
[18:06:15.795]             c <- base::c
[18:06:15.795]             inherits <- base::inherits
[18:06:15.795]             invokeRestart <- base::invokeRestart
[18:06:15.795]             length <- base::length
[18:06:15.795]             list <- base::list
[18:06:15.795]             seq.int <- base::seq.int
[18:06:15.795]             signalCondition <- base::signalCondition
[18:06:15.795]             sys.calls <- base::sys.calls
[18:06:15.795]             `[[` <- base::`[[`
[18:06:15.795]             `+` <- base::`+`
[18:06:15.795]             `<<-` <- base::`<<-`
[18:06:15.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:15.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:15.795]                   3L)]
[18:06:15.795]             }
[18:06:15.795]             function(cond) {
[18:06:15.795]                 is_error <- inherits(cond, "error")
[18:06:15.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:15.795]                   NULL)
[18:06:15.795]                 if (is_error) {
[18:06:15.795]                   sessionInformation <- function() {
[18:06:15.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:15.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:15.795]                       search = base::search(), system = base::Sys.info())
[18:06:15.795]                   }
[18:06:15.795]                   ...future.conditions[[length(...future.conditions) + 
[18:06:15.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:15.795]                     cond$call), session = sessionInformation(), 
[18:06:15.795]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:15.795]                   signalCondition(cond)
[18:06:15.795]                 }
[18:06:15.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:15.795]                 "immediateCondition"))) {
[18:06:15.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:15.795]                   ...future.conditions[[length(...future.conditions) + 
[18:06:15.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:15.795]                   if (TRUE && !signal) {
[18:06:15.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.795]                     {
[18:06:15.795]                       inherits <- base::inherits
[18:06:15.795]                       invokeRestart <- base::invokeRestart
[18:06:15.795]                       is.null <- base::is.null
[18:06:15.795]                       muffled <- FALSE
[18:06:15.795]                       if (inherits(cond, "message")) {
[18:06:15.795]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:15.795]                         if (muffled) 
[18:06:15.795]                           invokeRestart("muffleMessage")
[18:06:15.795]                       }
[18:06:15.795]                       else if (inherits(cond, "warning")) {
[18:06:15.795]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:15.795]                         if (muffled) 
[18:06:15.795]                           invokeRestart("muffleWarning")
[18:06:15.795]                       }
[18:06:15.795]                       else if (inherits(cond, "condition")) {
[18:06:15.795]                         if (!is.null(pattern)) {
[18:06:15.795]                           computeRestarts <- base::computeRestarts
[18:06:15.795]                           grepl <- base::grepl
[18:06:15.795]                           restarts <- computeRestarts(cond)
[18:06:15.795]                           for (restart in restarts) {
[18:06:15.795]                             name <- restart$name
[18:06:15.795]                             if (is.null(name)) 
[18:06:15.795]                               next
[18:06:15.795]                             if (!grepl(pattern, name)) 
[18:06:15.795]                               next
[18:06:15.795]                             invokeRestart(restart)
[18:06:15.795]                             muffled <- TRUE
[18:06:15.795]                             break
[18:06:15.795]                           }
[18:06:15.795]                         }
[18:06:15.795]                       }
[18:06:15.795]                       invisible(muffled)
[18:06:15.795]                     }
[18:06:15.795]                     muffleCondition(cond, pattern = "^muffle")
[18:06:15.795]                   }
[18:06:15.795]                 }
[18:06:15.795]                 else {
[18:06:15.795]                   if (TRUE) {
[18:06:15.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:15.795]                     {
[18:06:15.795]                       inherits <- base::inherits
[18:06:15.795]                       invokeRestart <- base::invokeRestart
[18:06:15.795]                       is.null <- base::is.null
[18:06:15.795]                       muffled <- FALSE
[18:06:15.795]                       if (inherits(cond, "message")) {
[18:06:15.795]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:15.795]                         if (muffled) 
[18:06:15.795]                           invokeRestart("muffleMessage")
[18:06:15.795]                       }
[18:06:15.795]                       else if (inherits(cond, "warning")) {
[18:06:15.795]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:15.795]                         if (muffled) 
[18:06:15.795]                           invokeRestart("muffleWarning")
[18:06:15.795]                       }
[18:06:15.795]                       else if (inherits(cond, "condition")) {
[18:06:15.795]                         if (!is.null(pattern)) {
[18:06:15.795]                           computeRestarts <- base::computeRestarts
[18:06:15.795]                           grepl <- base::grepl
[18:06:15.795]                           restarts <- computeRestarts(cond)
[18:06:15.795]                           for (restart in restarts) {
[18:06:15.795]                             name <- restart$name
[18:06:15.795]                             if (is.null(name)) 
[18:06:15.795]                               next
[18:06:15.795]                             if (!grepl(pattern, name)) 
[18:06:15.795]                               next
[18:06:15.795]                             invokeRestart(restart)
[18:06:15.795]                             muffled <- TRUE
[18:06:15.795]                             break
[18:06:15.795]                           }
[18:06:15.795]                         }
[18:06:15.795]                       }
[18:06:15.795]                       invisible(muffled)
[18:06:15.795]                     }
[18:06:15.795]                     muffleCondition(cond, pattern = "^muffle")
[18:06:15.795]                   }
[18:06:15.795]                 }
[18:06:15.795]             }
[18:06:15.795]         }))
[18:06:15.795]     }, error = function(ex) {
[18:06:15.795]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:15.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:15.795]                 ...future.rng), started = ...future.startTime, 
[18:06:15.795]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:15.795]             version = "1.8"), class = "FutureResult")
[18:06:15.795]     }, finally = {
[18:06:15.795]         if (!identical(...future.workdir, getwd())) 
[18:06:15.795]             setwd(...future.workdir)
[18:06:15.795]         {
[18:06:15.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:15.795]                 ...future.oldOptions$nwarnings <- NULL
[18:06:15.795]             }
[18:06:15.795]             base::options(...future.oldOptions)
[18:06:15.795]             if (.Platform$OS.type == "windows") {
[18:06:15.795]                 old_names <- names(...future.oldEnvVars)
[18:06:15.795]                 envs <- base::Sys.getenv()
[18:06:15.795]                 names <- names(envs)
[18:06:15.795]                 common <- intersect(names, old_names)
[18:06:15.795]                 added <- setdiff(names, old_names)
[18:06:15.795]                 removed <- setdiff(old_names, names)
[18:06:15.795]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:15.795]                   envs[common]]
[18:06:15.795]                 NAMES <- toupper(changed)
[18:06:15.795]                 args <- list()
[18:06:15.795]                 for (kk in seq_along(NAMES)) {
[18:06:15.795]                   name <- changed[[kk]]
[18:06:15.795]                   NAME <- NAMES[[kk]]
[18:06:15.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.795]                     next
[18:06:15.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:15.795]                 }
[18:06:15.795]                 NAMES <- toupper(added)
[18:06:15.795]                 for (kk in seq_along(NAMES)) {
[18:06:15.795]                   name <- added[[kk]]
[18:06:15.795]                   NAME <- NAMES[[kk]]
[18:06:15.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.795]                     next
[18:06:15.795]                   args[[name]] <- ""
[18:06:15.795]                 }
[18:06:15.795]                 NAMES <- toupper(removed)
[18:06:15.795]                 for (kk in seq_along(NAMES)) {
[18:06:15.795]                   name <- removed[[kk]]
[18:06:15.795]                   NAME <- NAMES[[kk]]
[18:06:15.795]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:15.795]                     next
[18:06:15.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:15.795]                 }
[18:06:15.795]                 if (length(args) > 0) 
[18:06:15.795]                   base::do.call(base::Sys.setenv, args = args)
[18:06:15.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:15.795]             }
[18:06:15.795]             else {
[18:06:15.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:15.795]             }
[18:06:15.795]             {
[18:06:15.795]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:15.795]                   0L) {
[18:06:15.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:15.795]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:15.795]                   base::options(opts)
[18:06:15.795]                 }
[18:06:15.795]                 {
[18:06:15.795]                   {
[18:06:15.795]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:15.795]                     NULL
[18:06:15.795]                   }
[18:06:15.795]                   options(future.plan = NULL)
[18:06:15.795]                   if (is.na(NA_character_)) 
[18:06:15.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:15.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:15.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:15.795]                     .init = FALSE)
[18:06:15.795]                 }
[18:06:15.795]             }
[18:06:15.795]         }
[18:06:15.795]     })
[18:06:15.795]     if (TRUE) {
[18:06:15.795]         base::sink(type = "output", split = FALSE)
[18:06:15.795]         if (TRUE) {
[18:06:15.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:15.795]         }
[18:06:15.795]         else {
[18:06:15.795]             ...future.result["stdout"] <- base::list(NULL)
[18:06:15.795]         }
[18:06:15.795]         base::close(...future.stdout)
[18:06:15.795]         ...future.stdout <- NULL
[18:06:15.795]     }
[18:06:15.795]     ...future.result$conditions <- ...future.conditions
[18:06:15.795]     ...future.result$finished <- base::Sys.time()
[18:06:15.795]     ...future.result
[18:06:15.795] }
[18:06:15.802] MultisessionFuture started
[18:06:15.803] - Launch lazy future ... done
[18:06:15.803] run() for ‘MultisessionFuture’ ... done
[18:06:16.347] receiveMessageFromWorker() for ClusterFuture ...
[18:06:16.348] - Validating connection of MultisessionFuture
[18:06:16.348] - received message: FutureResult
[18:06:16.349] - Received FutureResult
[18:06:16.349] - Erased future from FutureRegistry
[18:06:16.349] result() for ClusterFuture ...
[18:06:16.350] - result already collected: FutureResult
[18:06:16.350] result() for ClusterFuture ... done
[18:06:16.350] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:16.351] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[18:06:16.351] getGlobalsAndPackages() ...
[18:06:16.351] Searching for globals...
[18:06:16.353] - globals found: [2] ‘list’, ‘stop’
[18:06:16.354] Searching for globals ... DONE
[18:06:16.354] Resolving globals: FALSE
[18:06:16.355] 
[18:06:16.355] 
[18:06:16.356] getGlobalsAndPackages() ... DONE
[18:06:16.356] run() for ‘Future’ ...
[18:06:16.357] - state: ‘created’
[18:06:16.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:16.388] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:16.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:16.388]   - Field: ‘node’
[18:06:16.388]   - Field: ‘label’
[18:06:16.389]   - Field: ‘local’
[18:06:16.389]   - Field: ‘owner’
[18:06:16.389]   - Field: ‘envir’
[18:06:16.389]   - Field: ‘workers’
[18:06:16.389]   - Field: ‘packages’
[18:06:16.390]   - Field: ‘gc’
[18:06:16.390]   - Field: ‘conditions’
[18:06:16.390]   - Field: ‘persistent’
[18:06:16.390]   - Field: ‘expr’
[18:06:16.390]   - Field: ‘uuid’
[18:06:16.391]   - Field: ‘seed’
[18:06:16.391]   - Field: ‘version’
[18:06:16.391]   - Field: ‘result’
[18:06:16.391]   - Field: ‘asynchronous’
[18:06:16.391]   - Field: ‘calls’
[18:06:16.392]   - Field: ‘globals’
[18:06:16.392]   - Field: ‘stdout’
[18:06:16.392]   - Field: ‘earlySignal’
[18:06:16.392]   - Field: ‘lazy’
[18:06:16.392]   - Field: ‘state’
[18:06:16.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:16.393] - Launch lazy future ...
[18:06:16.393] Packages needed by the future expression (n = 0): <none>
[18:06:16.394] Packages needed by future strategies (n = 0): <none>
[18:06:16.394] {
[18:06:16.394]     {
[18:06:16.394]         {
[18:06:16.394]             ...future.startTime <- base::Sys.time()
[18:06:16.394]             {
[18:06:16.394]                 {
[18:06:16.394]                   {
[18:06:16.394]                     {
[18:06:16.394]                       base::local({
[18:06:16.394]                         has_future <- base::requireNamespace("future", 
[18:06:16.394]                           quietly = TRUE)
[18:06:16.394]                         if (has_future) {
[18:06:16.394]                           ns <- base::getNamespace("future")
[18:06:16.394]                           version <- ns[[".package"]][["version"]]
[18:06:16.394]                           if (is.null(version)) 
[18:06:16.394]                             version <- utils::packageVersion("future")
[18:06:16.394]                         }
[18:06:16.394]                         else {
[18:06:16.394]                           version <- NULL
[18:06:16.394]                         }
[18:06:16.394]                         if (!has_future || version < "1.8.0") {
[18:06:16.394]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:16.394]                             "", base::R.version$version.string), 
[18:06:16.394]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:16.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:16.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:16.394]                               "release", "version")], collapse = " "), 
[18:06:16.394]                             hostname = base::Sys.info()[["nodename"]])
[18:06:16.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:16.394]                             info)
[18:06:16.394]                           info <- base::paste(info, collapse = "; ")
[18:06:16.394]                           if (!has_future) {
[18:06:16.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:16.394]                               info)
[18:06:16.394]                           }
[18:06:16.394]                           else {
[18:06:16.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:16.394]                               info, version)
[18:06:16.394]                           }
[18:06:16.394]                           base::stop(msg)
[18:06:16.394]                         }
[18:06:16.394]                       })
[18:06:16.394]                     }
[18:06:16.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:16.394]                     base::options(mc.cores = 1L)
[18:06:16.394]                   }
[18:06:16.394]                   ...future.strategy.old <- future::plan("list")
[18:06:16.394]                   options(future.plan = NULL)
[18:06:16.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:16.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:16.394]                 }
[18:06:16.394]                 ...future.workdir <- getwd()
[18:06:16.394]             }
[18:06:16.394]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:16.394]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:16.394]         }
[18:06:16.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:16.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:16.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:16.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:16.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:16.394]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:16.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:16.394]             base::names(...future.oldOptions))
[18:06:16.394]     }
[18:06:16.394]     if (FALSE) {
[18:06:16.394]     }
[18:06:16.394]     else {
[18:06:16.394]         if (TRUE) {
[18:06:16.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:16.394]                 open = "w")
[18:06:16.394]         }
[18:06:16.394]         else {
[18:06:16.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:16.394]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:16.394]         }
[18:06:16.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:16.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:16.394]             base::sink(type = "output", split = FALSE)
[18:06:16.394]             base::close(...future.stdout)
[18:06:16.394]         }, add = TRUE)
[18:06:16.394]     }
[18:06:16.394]     ...future.frame <- base::sys.nframe()
[18:06:16.394]     ...future.conditions <- base::list()
[18:06:16.394]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:16.394]     if (FALSE) {
[18:06:16.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:16.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:16.394]     }
[18:06:16.394]     ...future.result <- base::tryCatch({
[18:06:16.394]         base::withCallingHandlers({
[18:06:16.394]             ...future.value <- base::withVisible(base::local({
[18:06:16.394]                 ...future.makeSendCondition <- base::local({
[18:06:16.394]                   sendCondition <- NULL
[18:06:16.394]                   function(frame = 1L) {
[18:06:16.394]                     if (is.function(sendCondition)) 
[18:06:16.394]                       return(sendCondition)
[18:06:16.394]                     ns <- getNamespace("parallel")
[18:06:16.394]                     if (exists("sendData", mode = "function", 
[18:06:16.394]                       envir = ns)) {
[18:06:16.394]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:16.394]                         envir = ns)
[18:06:16.394]                       envir <- sys.frame(frame)
[18:06:16.394]                       master <- NULL
[18:06:16.394]                       while (!identical(envir, .GlobalEnv) && 
[18:06:16.394]                         !identical(envir, emptyenv())) {
[18:06:16.394]                         if (exists("master", mode = "list", envir = envir, 
[18:06:16.394]                           inherits = FALSE)) {
[18:06:16.394]                           master <- get("master", mode = "list", 
[18:06:16.394]                             envir = envir, inherits = FALSE)
[18:06:16.394]                           if (inherits(master, c("SOCKnode", 
[18:06:16.394]                             "SOCK0node"))) {
[18:06:16.394]                             sendCondition <<- function(cond) {
[18:06:16.394]                               data <- list(type = "VALUE", value = cond, 
[18:06:16.394]                                 success = TRUE)
[18:06:16.394]                               parallel_sendData(master, data)
[18:06:16.394]                             }
[18:06:16.394]                             return(sendCondition)
[18:06:16.394]                           }
[18:06:16.394]                         }
[18:06:16.394]                         frame <- frame + 1L
[18:06:16.394]                         envir <- sys.frame(frame)
[18:06:16.394]                       }
[18:06:16.394]                     }
[18:06:16.394]                     sendCondition <<- function(cond) NULL
[18:06:16.394]                   }
[18:06:16.394]                 })
[18:06:16.394]                 withCallingHandlers({
[18:06:16.394]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:16.394]                 }, immediateCondition = function(cond) {
[18:06:16.394]                   sendCondition <- ...future.makeSendCondition()
[18:06:16.394]                   sendCondition(cond)
[18:06:16.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.394]                   {
[18:06:16.394]                     inherits <- base::inherits
[18:06:16.394]                     invokeRestart <- base::invokeRestart
[18:06:16.394]                     is.null <- base::is.null
[18:06:16.394]                     muffled <- FALSE
[18:06:16.394]                     if (inherits(cond, "message")) {
[18:06:16.394]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:16.394]                       if (muffled) 
[18:06:16.394]                         invokeRestart("muffleMessage")
[18:06:16.394]                     }
[18:06:16.394]                     else if (inherits(cond, "warning")) {
[18:06:16.394]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:16.394]                       if (muffled) 
[18:06:16.394]                         invokeRestart("muffleWarning")
[18:06:16.394]                     }
[18:06:16.394]                     else if (inherits(cond, "condition")) {
[18:06:16.394]                       if (!is.null(pattern)) {
[18:06:16.394]                         computeRestarts <- base::computeRestarts
[18:06:16.394]                         grepl <- base::grepl
[18:06:16.394]                         restarts <- computeRestarts(cond)
[18:06:16.394]                         for (restart in restarts) {
[18:06:16.394]                           name <- restart$name
[18:06:16.394]                           if (is.null(name)) 
[18:06:16.394]                             next
[18:06:16.394]                           if (!grepl(pattern, name)) 
[18:06:16.394]                             next
[18:06:16.394]                           invokeRestart(restart)
[18:06:16.394]                           muffled <- TRUE
[18:06:16.394]                           break
[18:06:16.394]                         }
[18:06:16.394]                       }
[18:06:16.394]                     }
[18:06:16.394]                     invisible(muffled)
[18:06:16.394]                   }
[18:06:16.394]                   muffleCondition(cond)
[18:06:16.394]                 })
[18:06:16.394]             }))
[18:06:16.394]             future::FutureResult(value = ...future.value$value, 
[18:06:16.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:16.394]                   ...future.rng), globalenv = if (FALSE) 
[18:06:16.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:16.394]                     ...future.globalenv.names))
[18:06:16.394]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:16.394]         }, condition = base::local({
[18:06:16.394]             c <- base::c
[18:06:16.394]             inherits <- base::inherits
[18:06:16.394]             invokeRestart <- base::invokeRestart
[18:06:16.394]             length <- base::length
[18:06:16.394]             list <- base::list
[18:06:16.394]             seq.int <- base::seq.int
[18:06:16.394]             signalCondition <- base::signalCondition
[18:06:16.394]             sys.calls <- base::sys.calls
[18:06:16.394]             `[[` <- base::`[[`
[18:06:16.394]             `+` <- base::`+`
[18:06:16.394]             `<<-` <- base::`<<-`
[18:06:16.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:16.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:16.394]                   3L)]
[18:06:16.394]             }
[18:06:16.394]             function(cond) {
[18:06:16.394]                 is_error <- inherits(cond, "error")
[18:06:16.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:16.394]                   NULL)
[18:06:16.394]                 if (is_error) {
[18:06:16.394]                   sessionInformation <- function() {
[18:06:16.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:16.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:16.394]                       search = base::search(), system = base::Sys.info())
[18:06:16.394]                   }
[18:06:16.394]                   ...future.conditions[[length(...future.conditions) + 
[18:06:16.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:16.394]                     cond$call), session = sessionInformation(), 
[18:06:16.394]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:16.394]                   signalCondition(cond)
[18:06:16.394]                 }
[18:06:16.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:16.394]                 "immediateCondition"))) {
[18:06:16.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:16.394]                   ...future.conditions[[length(...future.conditions) + 
[18:06:16.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:16.394]                   if (TRUE && !signal) {
[18:06:16.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.394]                     {
[18:06:16.394]                       inherits <- base::inherits
[18:06:16.394]                       invokeRestart <- base::invokeRestart
[18:06:16.394]                       is.null <- base::is.null
[18:06:16.394]                       muffled <- FALSE
[18:06:16.394]                       if (inherits(cond, "message")) {
[18:06:16.394]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:16.394]                         if (muffled) 
[18:06:16.394]                           invokeRestart("muffleMessage")
[18:06:16.394]                       }
[18:06:16.394]                       else if (inherits(cond, "warning")) {
[18:06:16.394]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:16.394]                         if (muffled) 
[18:06:16.394]                           invokeRestart("muffleWarning")
[18:06:16.394]                       }
[18:06:16.394]                       else if (inherits(cond, "condition")) {
[18:06:16.394]                         if (!is.null(pattern)) {
[18:06:16.394]                           computeRestarts <- base::computeRestarts
[18:06:16.394]                           grepl <- base::grepl
[18:06:16.394]                           restarts <- computeRestarts(cond)
[18:06:16.394]                           for (restart in restarts) {
[18:06:16.394]                             name <- restart$name
[18:06:16.394]                             if (is.null(name)) 
[18:06:16.394]                               next
[18:06:16.394]                             if (!grepl(pattern, name)) 
[18:06:16.394]                               next
[18:06:16.394]                             invokeRestart(restart)
[18:06:16.394]                             muffled <- TRUE
[18:06:16.394]                             break
[18:06:16.394]                           }
[18:06:16.394]                         }
[18:06:16.394]                       }
[18:06:16.394]                       invisible(muffled)
[18:06:16.394]                     }
[18:06:16.394]                     muffleCondition(cond, pattern = "^muffle")
[18:06:16.394]                   }
[18:06:16.394]                 }
[18:06:16.394]                 else {
[18:06:16.394]                   if (TRUE) {
[18:06:16.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.394]                     {
[18:06:16.394]                       inherits <- base::inherits
[18:06:16.394]                       invokeRestart <- base::invokeRestart
[18:06:16.394]                       is.null <- base::is.null
[18:06:16.394]                       muffled <- FALSE
[18:06:16.394]                       if (inherits(cond, "message")) {
[18:06:16.394]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:16.394]                         if (muffled) 
[18:06:16.394]                           invokeRestart("muffleMessage")
[18:06:16.394]                       }
[18:06:16.394]                       else if (inherits(cond, "warning")) {
[18:06:16.394]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:16.394]                         if (muffled) 
[18:06:16.394]                           invokeRestart("muffleWarning")
[18:06:16.394]                       }
[18:06:16.394]                       else if (inherits(cond, "condition")) {
[18:06:16.394]                         if (!is.null(pattern)) {
[18:06:16.394]                           computeRestarts <- base::computeRestarts
[18:06:16.394]                           grepl <- base::grepl
[18:06:16.394]                           restarts <- computeRestarts(cond)
[18:06:16.394]                           for (restart in restarts) {
[18:06:16.394]                             name <- restart$name
[18:06:16.394]                             if (is.null(name)) 
[18:06:16.394]                               next
[18:06:16.394]                             if (!grepl(pattern, name)) 
[18:06:16.394]                               next
[18:06:16.394]                             invokeRestart(restart)
[18:06:16.394]                             muffled <- TRUE
[18:06:16.394]                             break
[18:06:16.394]                           }
[18:06:16.394]                         }
[18:06:16.394]                       }
[18:06:16.394]                       invisible(muffled)
[18:06:16.394]                     }
[18:06:16.394]                     muffleCondition(cond, pattern = "^muffle")
[18:06:16.394]                   }
[18:06:16.394]                 }
[18:06:16.394]             }
[18:06:16.394]         }))
[18:06:16.394]     }, error = function(ex) {
[18:06:16.394]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:16.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:16.394]                 ...future.rng), started = ...future.startTime, 
[18:06:16.394]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:16.394]             version = "1.8"), class = "FutureResult")
[18:06:16.394]     }, finally = {
[18:06:16.394]         if (!identical(...future.workdir, getwd())) 
[18:06:16.394]             setwd(...future.workdir)
[18:06:16.394]         {
[18:06:16.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:16.394]                 ...future.oldOptions$nwarnings <- NULL
[18:06:16.394]             }
[18:06:16.394]             base::options(...future.oldOptions)
[18:06:16.394]             if (.Platform$OS.type == "windows") {
[18:06:16.394]                 old_names <- names(...future.oldEnvVars)
[18:06:16.394]                 envs <- base::Sys.getenv()
[18:06:16.394]                 names <- names(envs)
[18:06:16.394]                 common <- intersect(names, old_names)
[18:06:16.394]                 added <- setdiff(names, old_names)
[18:06:16.394]                 removed <- setdiff(old_names, names)
[18:06:16.394]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:16.394]                   envs[common]]
[18:06:16.394]                 NAMES <- toupper(changed)
[18:06:16.394]                 args <- list()
[18:06:16.394]                 for (kk in seq_along(NAMES)) {
[18:06:16.394]                   name <- changed[[kk]]
[18:06:16.394]                   NAME <- NAMES[[kk]]
[18:06:16.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.394]                     next
[18:06:16.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:16.394]                 }
[18:06:16.394]                 NAMES <- toupper(added)
[18:06:16.394]                 for (kk in seq_along(NAMES)) {
[18:06:16.394]                   name <- added[[kk]]
[18:06:16.394]                   NAME <- NAMES[[kk]]
[18:06:16.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.394]                     next
[18:06:16.394]                   args[[name]] <- ""
[18:06:16.394]                 }
[18:06:16.394]                 NAMES <- toupper(removed)
[18:06:16.394]                 for (kk in seq_along(NAMES)) {
[18:06:16.394]                   name <- removed[[kk]]
[18:06:16.394]                   NAME <- NAMES[[kk]]
[18:06:16.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.394]                     next
[18:06:16.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:16.394]                 }
[18:06:16.394]                 if (length(args) > 0) 
[18:06:16.394]                   base::do.call(base::Sys.setenv, args = args)
[18:06:16.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:16.394]             }
[18:06:16.394]             else {
[18:06:16.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:16.394]             }
[18:06:16.394]             {
[18:06:16.394]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:16.394]                   0L) {
[18:06:16.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:16.394]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:16.394]                   base::options(opts)
[18:06:16.394]                 }
[18:06:16.394]                 {
[18:06:16.394]                   {
[18:06:16.394]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:16.394]                     NULL
[18:06:16.394]                   }
[18:06:16.394]                   options(future.plan = NULL)
[18:06:16.394]                   if (is.na(NA_character_)) 
[18:06:16.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:16.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:16.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:16.394]                     .init = FALSE)
[18:06:16.394]                 }
[18:06:16.394]             }
[18:06:16.394]         }
[18:06:16.394]     })
[18:06:16.394]     if (TRUE) {
[18:06:16.394]         base::sink(type = "output", split = FALSE)
[18:06:16.394]         if (TRUE) {
[18:06:16.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:16.394]         }
[18:06:16.394]         else {
[18:06:16.394]             ...future.result["stdout"] <- base::list(NULL)
[18:06:16.394]         }
[18:06:16.394]         base::close(...future.stdout)
[18:06:16.394]         ...future.stdout <- NULL
[18:06:16.394]     }
[18:06:16.394]     ...future.result$conditions <- ...future.conditions
[18:06:16.394]     ...future.result$finished <- base::Sys.time()
[18:06:16.394]     ...future.result
[18:06:16.394] }
[18:06:16.400] MultisessionFuture started
[18:06:16.400] - Launch lazy future ... done
[18:06:16.401] run() for ‘MultisessionFuture’ ... done
[18:06:16.445] receiveMessageFromWorker() for ClusterFuture ...
[18:06:16.445] - Validating connection of MultisessionFuture
[18:06:16.446] - received message: FutureResult
[18:06:16.447] - Received FutureResult
[18:06:16.447] - Erased future from FutureRegistry
[18:06:16.448] result() for ClusterFuture ...
[18:06:16.448] - result already collected: FutureResult
[18:06:16.448] result() for ClusterFuture ... done
[18:06:16.448] signalConditions() ...
[18:06:16.449]  - include = ‘immediateCondition’
[18:06:16.449]  - exclude = 
[18:06:16.449]  - resignal = FALSE
[18:06:16.450]  - Number of conditions: 1
[18:06:16.450] signalConditions() ... done
[18:06:16.450] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:16.450] A MultisessionFuture was resolved (result was not collected)
[18:06:16.451] getGlobalsAndPackages() ...
[18:06:16.451] Searching for globals...
[18:06:16.453] - globals found: [2] ‘list’, ‘stop’
[18:06:16.453] Searching for globals ... DONE
[18:06:16.454] Resolving globals: FALSE
[18:06:16.454] 
[18:06:16.455] 
[18:06:16.455] getGlobalsAndPackages() ... DONE
[18:06:16.456] run() for ‘Future’ ...
[18:06:16.456] - state: ‘created’
[18:06:16.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:16.483] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:16.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:16.484]   - Field: ‘node’
[18:06:16.484]   - Field: ‘label’
[18:06:16.484]   - Field: ‘local’
[18:06:16.484]   - Field: ‘owner’
[18:06:16.484]   - Field: ‘envir’
[18:06:16.485]   - Field: ‘workers’
[18:06:16.485]   - Field: ‘packages’
[18:06:16.485]   - Field: ‘gc’
[18:06:16.485]   - Field: ‘conditions’
[18:06:16.485]   - Field: ‘persistent’
[18:06:16.486]   - Field: ‘expr’
[18:06:16.486]   - Field: ‘uuid’
[18:06:16.486]   - Field: ‘seed’
[18:06:16.486]   - Field: ‘version’
[18:06:16.487]   - Field: ‘result’
[18:06:16.487]   - Field: ‘asynchronous’
[18:06:16.490]   - Field: ‘calls’
[18:06:16.490]   - Field: ‘globals’
[18:06:16.491]   - Field: ‘stdout’
[18:06:16.491]   - Field: ‘earlySignal’
[18:06:16.491]   - Field: ‘lazy’
[18:06:16.491]   - Field: ‘state’
[18:06:16.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:16.492] - Launch lazy future ...
[18:06:16.492] Packages needed by the future expression (n = 0): <none>
[18:06:16.493] Packages needed by future strategies (n = 0): <none>
[18:06:16.494] {
[18:06:16.494]     {
[18:06:16.494]         {
[18:06:16.494]             ...future.startTime <- base::Sys.time()
[18:06:16.494]             {
[18:06:16.494]                 {
[18:06:16.494]                   {
[18:06:16.494]                     {
[18:06:16.494]                       base::local({
[18:06:16.494]                         has_future <- base::requireNamespace("future", 
[18:06:16.494]                           quietly = TRUE)
[18:06:16.494]                         if (has_future) {
[18:06:16.494]                           ns <- base::getNamespace("future")
[18:06:16.494]                           version <- ns[[".package"]][["version"]]
[18:06:16.494]                           if (is.null(version)) 
[18:06:16.494]                             version <- utils::packageVersion("future")
[18:06:16.494]                         }
[18:06:16.494]                         else {
[18:06:16.494]                           version <- NULL
[18:06:16.494]                         }
[18:06:16.494]                         if (!has_future || version < "1.8.0") {
[18:06:16.494]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:16.494]                             "", base::R.version$version.string), 
[18:06:16.494]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:16.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:16.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:16.494]                               "release", "version")], collapse = " "), 
[18:06:16.494]                             hostname = base::Sys.info()[["nodename"]])
[18:06:16.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:16.494]                             info)
[18:06:16.494]                           info <- base::paste(info, collapse = "; ")
[18:06:16.494]                           if (!has_future) {
[18:06:16.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:16.494]                               info)
[18:06:16.494]                           }
[18:06:16.494]                           else {
[18:06:16.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:16.494]                               info, version)
[18:06:16.494]                           }
[18:06:16.494]                           base::stop(msg)
[18:06:16.494]                         }
[18:06:16.494]                       })
[18:06:16.494]                     }
[18:06:16.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:16.494]                     base::options(mc.cores = 1L)
[18:06:16.494]                   }
[18:06:16.494]                   ...future.strategy.old <- future::plan("list")
[18:06:16.494]                   options(future.plan = NULL)
[18:06:16.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:16.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:16.494]                 }
[18:06:16.494]                 ...future.workdir <- getwd()
[18:06:16.494]             }
[18:06:16.494]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:16.494]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:16.494]         }
[18:06:16.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:16.494]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:16.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:16.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:16.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:16.494]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:16.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:16.494]             base::names(...future.oldOptions))
[18:06:16.494]     }
[18:06:16.494]     if (FALSE) {
[18:06:16.494]     }
[18:06:16.494]     else {
[18:06:16.494]         if (TRUE) {
[18:06:16.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:16.494]                 open = "w")
[18:06:16.494]         }
[18:06:16.494]         else {
[18:06:16.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:16.494]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:16.494]         }
[18:06:16.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:16.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:16.494]             base::sink(type = "output", split = FALSE)
[18:06:16.494]             base::close(...future.stdout)
[18:06:16.494]         }, add = TRUE)
[18:06:16.494]     }
[18:06:16.494]     ...future.frame <- base::sys.nframe()
[18:06:16.494]     ...future.conditions <- base::list()
[18:06:16.494]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:16.494]     if (FALSE) {
[18:06:16.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:16.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:16.494]     }
[18:06:16.494]     ...future.result <- base::tryCatch({
[18:06:16.494]         base::withCallingHandlers({
[18:06:16.494]             ...future.value <- base::withVisible(base::local({
[18:06:16.494]                 ...future.makeSendCondition <- base::local({
[18:06:16.494]                   sendCondition <- NULL
[18:06:16.494]                   function(frame = 1L) {
[18:06:16.494]                     if (is.function(sendCondition)) 
[18:06:16.494]                       return(sendCondition)
[18:06:16.494]                     ns <- getNamespace("parallel")
[18:06:16.494]                     if (exists("sendData", mode = "function", 
[18:06:16.494]                       envir = ns)) {
[18:06:16.494]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:16.494]                         envir = ns)
[18:06:16.494]                       envir <- sys.frame(frame)
[18:06:16.494]                       master <- NULL
[18:06:16.494]                       while (!identical(envir, .GlobalEnv) && 
[18:06:16.494]                         !identical(envir, emptyenv())) {
[18:06:16.494]                         if (exists("master", mode = "list", envir = envir, 
[18:06:16.494]                           inherits = FALSE)) {
[18:06:16.494]                           master <- get("master", mode = "list", 
[18:06:16.494]                             envir = envir, inherits = FALSE)
[18:06:16.494]                           if (inherits(master, c("SOCKnode", 
[18:06:16.494]                             "SOCK0node"))) {
[18:06:16.494]                             sendCondition <<- function(cond) {
[18:06:16.494]                               data <- list(type = "VALUE", value = cond, 
[18:06:16.494]                                 success = TRUE)
[18:06:16.494]                               parallel_sendData(master, data)
[18:06:16.494]                             }
[18:06:16.494]                             return(sendCondition)
[18:06:16.494]                           }
[18:06:16.494]                         }
[18:06:16.494]                         frame <- frame + 1L
[18:06:16.494]                         envir <- sys.frame(frame)
[18:06:16.494]                       }
[18:06:16.494]                     }
[18:06:16.494]                     sendCondition <<- function(cond) NULL
[18:06:16.494]                   }
[18:06:16.494]                 })
[18:06:16.494]                 withCallingHandlers({
[18:06:16.494]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:16.494]                 }, immediateCondition = function(cond) {
[18:06:16.494]                   sendCondition <- ...future.makeSendCondition()
[18:06:16.494]                   sendCondition(cond)
[18:06:16.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.494]                   {
[18:06:16.494]                     inherits <- base::inherits
[18:06:16.494]                     invokeRestart <- base::invokeRestart
[18:06:16.494]                     is.null <- base::is.null
[18:06:16.494]                     muffled <- FALSE
[18:06:16.494]                     if (inherits(cond, "message")) {
[18:06:16.494]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:16.494]                       if (muffled) 
[18:06:16.494]                         invokeRestart("muffleMessage")
[18:06:16.494]                     }
[18:06:16.494]                     else if (inherits(cond, "warning")) {
[18:06:16.494]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:16.494]                       if (muffled) 
[18:06:16.494]                         invokeRestart("muffleWarning")
[18:06:16.494]                     }
[18:06:16.494]                     else if (inherits(cond, "condition")) {
[18:06:16.494]                       if (!is.null(pattern)) {
[18:06:16.494]                         computeRestarts <- base::computeRestarts
[18:06:16.494]                         grepl <- base::grepl
[18:06:16.494]                         restarts <- computeRestarts(cond)
[18:06:16.494]                         for (restart in restarts) {
[18:06:16.494]                           name <- restart$name
[18:06:16.494]                           if (is.null(name)) 
[18:06:16.494]                             next
[18:06:16.494]                           if (!grepl(pattern, name)) 
[18:06:16.494]                             next
[18:06:16.494]                           invokeRestart(restart)
[18:06:16.494]                           muffled <- TRUE
[18:06:16.494]                           break
[18:06:16.494]                         }
[18:06:16.494]                       }
[18:06:16.494]                     }
[18:06:16.494]                     invisible(muffled)
[18:06:16.494]                   }
[18:06:16.494]                   muffleCondition(cond)
[18:06:16.494]                 })
[18:06:16.494]             }))
[18:06:16.494]             future::FutureResult(value = ...future.value$value, 
[18:06:16.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:16.494]                   ...future.rng), globalenv = if (FALSE) 
[18:06:16.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:16.494]                     ...future.globalenv.names))
[18:06:16.494]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:16.494]         }, condition = base::local({
[18:06:16.494]             c <- base::c
[18:06:16.494]             inherits <- base::inherits
[18:06:16.494]             invokeRestart <- base::invokeRestart
[18:06:16.494]             length <- base::length
[18:06:16.494]             list <- base::list
[18:06:16.494]             seq.int <- base::seq.int
[18:06:16.494]             signalCondition <- base::signalCondition
[18:06:16.494]             sys.calls <- base::sys.calls
[18:06:16.494]             `[[` <- base::`[[`
[18:06:16.494]             `+` <- base::`+`
[18:06:16.494]             `<<-` <- base::`<<-`
[18:06:16.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:16.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:16.494]                   3L)]
[18:06:16.494]             }
[18:06:16.494]             function(cond) {
[18:06:16.494]                 is_error <- inherits(cond, "error")
[18:06:16.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:16.494]                   NULL)
[18:06:16.494]                 if (is_error) {
[18:06:16.494]                   sessionInformation <- function() {
[18:06:16.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:16.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:16.494]                       search = base::search(), system = base::Sys.info())
[18:06:16.494]                   }
[18:06:16.494]                   ...future.conditions[[length(...future.conditions) + 
[18:06:16.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:16.494]                     cond$call), session = sessionInformation(), 
[18:06:16.494]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:16.494]                   signalCondition(cond)
[18:06:16.494]                 }
[18:06:16.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:16.494]                 "immediateCondition"))) {
[18:06:16.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:16.494]                   ...future.conditions[[length(...future.conditions) + 
[18:06:16.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:16.494]                   if (TRUE && !signal) {
[18:06:16.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.494]                     {
[18:06:16.494]                       inherits <- base::inherits
[18:06:16.494]                       invokeRestart <- base::invokeRestart
[18:06:16.494]                       is.null <- base::is.null
[18:06:16.494]                       muffled <- FALSE
[18:06:16.494]                       if (inherits(cond, "message")) {
[18:06:16.494]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:16.494]                         if (muffled) 
[18:06:16.494]                           invokeRestart("muffleMessage")
[18:06:16.494]                       }
[18:06:16.494]                       else if (inherits(cond, "warning")) {
[18:06:16.494]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:16.494]                         if (muffled) 
[18:06:16.494]                           invokeRestart("muffleWarning")
[18:06:16.494]                       }
[18:06:16.494]                       else if (inherits(cond, "condition")) {
[18:06:16.494]                         if (!is.null(pattern)) {
[18:06:16.494]                           computeRestarts <- base::computeRestarts
[18:06:16.494]                           grepl <- base::grepl
[18:06:16.494]                           restarts <- computeRestarts(cond)
[18:06:16.494]                           for (restart in restarts) {
[18:06:16.494]                             name <- restart$name
[18:06:16.494]                             if (is.null(name)) 
[18:06:16.494]                               next
[18:06:16.494]                             if (!grepl(pattern, name)) 
[18:06:16.494]                               next
[18:06:16.494]                             invokeRestart(restart)
[18:06:16.494]                             muffled <- TRUE
[18:06:16.494]                             break
[18:06:16.494]                           }
[18:06:16.494]                         }
[18:06:16.494]                       }
[18:06:16.494]                       invisible(muffled)
[18:06:16.494]                     }
[18:06:16.494]                     muffleCondition(cond, pattern = "^muffle")
[18:06:16.494]                   }
[18:06:16.494]                 }
[18:06:16.494]                 else {
[18:06:16.494]                   if (TRUE) {
[18:06:16.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.494]                     {
[18:06:16.494]                       inherits <- base::inherits
[18:06:16.494]                       invokeRestart <- base::invokeRestart
[18:06:16.494]                       is.null <- base::is.null
[18:06:16.494]                       muffled <- FALSE
[18:06:16.494]                       if (inherits(cond, "message")) {
[18:06:16.494]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:16.494]                         if (muffled) 
[18:06:16.494]                           invokeRestart("muffleMessage")
[18:06:16.494]                       }
[18:06:16.494]                       else if (inherits(cond, "warning")) {
[18:06:16.494]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:16.494]                         if (muffled) 
[18:06:16.494]                           invokeRestart("muffleWarning")
[18:06:16.494]                       }
[18:06:16.494]                       else if (inherits(cond, "condition")) {
[18:06:16.494]                         if (!is.null(pattern)) {
[18:06:16.494]                           computeRestarts <- base::computeRestarts
[18:06:16.494]                           grepl <- base::grepl
[18:06:16.494]                           restarts <- computeRestarts(cond)
[18:06:16.494]                           for (restart in restarts) {
[18:06:16.494]                             name <- restart$name
[18:06:16.494]                             if (is.null(name)) 
[18:06:16.494]                               next
[18:06:16.494]                             if (!grepl(pattern, name)) 
[18:06:16.494]                               next
[18:06:16.494]                             invokeRestart(restart)
[18:06:16.494]                             muffled <- TRUE
[18:06:16.494]                             break
[18:06:16.494]                           }
[18:06:16.494]                         }
[18:06:16.494]                       }
[18:06:16.494]                       invisible(muffled)
[18:06:16.494]                     }
[18:06:16.494]                     muffleCondition(cond, pattern = "^muffle")
[18:06:16.494]                   }
[18:06:16.494]                 }
[18:06:16.494]             }
[18:06:16.494]         }))
[18:06:16.494]     }, error = function(ex) {
[18:06:16.494]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:16.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:16.494]                 ...future.rng), started = ...future.startTime, 
[18:06:16.494]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:16.494]             version = "1.8"), class = "FutureResult")
[18:06:16.494]     }, finally = {
[18:06:16.494]         if (!identical(...future.workdir, getwd())) 
[18:06:16.494]             setwd(...future.workdir)
[18:06:16.494]         {
[18:06:16.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:16.494]                 ...future.oldOptions$nwarnings <- NULL
[18:06:16.494]             }
[18:06:16.494]             base::options(...future.oldOptions)
[18:06:16.494]             if (.Platform$OS.type == "windows") {
[18:06:16.494]                 old_names <- names(...future.oldEnvVars)
[18:06:16.494]                 envs <- base::Sys.getenv()
[18:06:16.494]                 names <- names(envs)
[18:06:16.494]                 common <- intersect(names, old_names)
[18:06:16.494]                 added <- setdiff(names, old_names)
[18:06:16.494]                 removed <- setdiff(old_names, names)
[18:06:16.494]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:16.494]                   envs[common]]
[18:06:16.494]                 NAMES <- toupper(changed)
[18:06:16.494]                 args <- list()
[18:06:16.494]                 for (kk in seq_along(NAMES)) {
[18:06:16.494]                   name <- changed[[kk]]
[18:06:16.494]                   NAME <- NAMES[[kk]]
[18:06:16.494]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.494]                     next
[18:06:16.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:16.494]                 }
[18:06:16.494]                 NAMES <- toupper(added)
[18:06:16.494]                 for (kk in seq_along(NAMES)) {
[18:06:16.494]                   name <- added[[kk]]
[18:06:16.494]                   NAME <- NAMES[[kk]]
[18:06:16.494]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.494]                     next
[18:06:16.494]                   args[[name]] <- ""
[18:06:16.494]                 }
[18:06:16.494]                 NAMES <- toupper(removed)
[18:06:16.494]                 for (kk in seq_along(NAMES)) {
[18:06:16.494]                   name <- removed[[kk]]
[18:06:16.494]                   NAME <- NAMES[[kk]]
[18:06:16.494]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.494]                     next
[18:06:16.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:16.494]                 }
[18:06:16.494]                 if (length(args) > 0) 
[18:06:16.494]                   base::do.call(base::Sys.setenv, args = args)
[18:06:16.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:16.494]             }
[18:06:16.494]             else {
[18:06:16.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:16.494]             }
[18:06:16.494]             {
[18:06:16.494]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:16.494]                   0L) {
[18:06:16.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:16.494]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:16.494]                   base::options(opts)
[18:06:16.494]                 }
[18:06:16.494]                 {
[18:06:16.494]                   {
[18:06:16.494]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:16.494]                     NULL
[18:06:16.494]                   }
[18:06:16.494]                   options(future.plan = NULL)
[18:06:16.494]                   if (is.na(NA_character_)) 
[18:06:16.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:16.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:16.494]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:16.494]                     .init = FALSE)
[18:06:16.494]                 }
[18:06:16.494]             }
[18:06:16.494]         }
[18:06:16.494]     })
[18:06:16.494]     if (TRUE) {
[18:06:16.494]         base::sink(type = "output", split = FALSE)
[18:06:16.494]         if (TRUE) {
[18:06:16.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:16.494]         }
[18:06:16.494]         else {
[18:06:16.494]             ...future.result["stdout"] <- base::list(NULL)
[18:06:16.494]         }
[18:06:16.494]         base::close(...future.stdout)
[18:06:16.494]         ...future.stdout <- NULL
[18:06:16.494]     }
[18:06:16.494]     ...future.result$conditions <- ...future.conditions
[18:06:16.494]     ...future.result$finished <- base::Sys.time()
[18:06:16.494]     ...future.result
[18:06:16.494] }
[18:06:16.500] MultisessionFuture started
[18:06:16.500] - Launch lazy future ... done
[18:06:16.500] run() for ‘MultisessionFuture’ ... done
[18:06:16.544] receiveMessageFromWorker() for ClusterFuture ...
[18:06:16.544] - Validating connection of MultisessionFuture
[18:06:16.545] - received message: FutureResult
[18:06:16.545] - Received FutureResult
[18:06:16.546] - Erased future from FutureRegistry
[18:06:16.546] result() for ClusterFuture ...
[18:06:16.546] - result already collected: FutureResult
[18:06:16.546] result() for ClusterFuture ... done
[18:06:16.547] signalConditions() ...
[18:06:16.547]  - include = ‘immediateCondition’
[18:06:16.547]  - exclude = 
[18:06:16.547]  - resignal = FALSE
[18:06:16.548]  - Number of conditions: 1
[18:06:16.548] signalConditions() ... done
[18:06:16.548] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:16.548] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[18:06:16.549] getGlobalsAndPackages() ...
[18:06:16.549] Searching for globals...
[18:06:16.552] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:16.553] Searching for globals ... DONE
[18:06:16.553] Resolving globals: FALSE
[18:06:16.554] 
[18:06:16.554] 
[18:06:16.554] getGlobalsAndPackages() ... DONE
[18:06:16.555] run() for ‘Future’ ...
[18:06:16.555] - state: ‘created’
[18:06:16.556] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:16.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:16.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:16.582]   - Field: ‘node’
[18:06:16.583]   - Field: ‘label’
[18:06:16.583]   - Field: ‘local’
[18:06:16.583]   - Field: ‘owner’
[18:06:16.584]   - Field: ‘envir’
[18:06:16.584]   - Field: ‘workers’
[18:06:16.584]   - Field: ‘packages’
[18:06:16.584]   - Field: ‘gc’
[18:06:16.584]   - Field: ‘conditions’
[18:06:16.585]   - Field: ‘persistent’
[18:06:16.585]   - Field: ‘expr’
[18:06:16.585]   - Field: ‘uuid’
[18:06:16.585]   - Field: ‘seed’
[18:06:16.586]   - Field: ‘version’
[18:06:16.586]   - Field: ‘result’
[18:06:16.586]   - Field: ‘asynchronous’
[18:06:16.586]   - Field: ‘calls’
[18:06:16.587]   - Field: ‘globals’
[18:06:16.587]   - Field: ‘stdout’
[18:06:16.587]   - Field: ‘earlySignal’
[18:06:16.587]   - Field: ‘lazy’
[18:06:16.587]   - Field: ‘state’
[18:06:16.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:16.588] - Launch lazy future ...
[18:06:16.589] Packages needed by the future expression (n = 0): <none>
[18:06:16.589] Packages needed by future strategies (n = 0): <none>
[18:06:16.590] {
[18:06:16.590]     {
[18:06:16.590]         {
[18:06:16.590]             ...future.startTime <- base::Sys.time()
[18:06:16.590]             {
[18:06:16.590]                 {
[18:06:16.590]                   {
[18:06:16.590]                     {
[18:06:16.590]                       base::local({
[18:06:16.590]                         has_future <- base::requireNamespace("future", 
[18:06:16.590]                           quietly = TRUE)
[18:06:16.590]                         if (has_future) {
[18:06:16.590]                           ns <- base::getNamespace("future")
[18:06:16.590]                           version <- ns[[".package"]][["version"]]
[18:06:16.590]                           if (is.null(version)) 
[18:06:16.590]                             version <- utils::packageVersion("future")
[18:06:16.590]                         }
[18:06:16.590]                         else {
[18:06:16.590]                           version <- NULL
[18:06:16.590]                         }
[18:06:16.590]                         if (!has_future || version < "1.8.0") {
[18:06:16.590]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:16.590]                             "", base::R.version$version.string), 
[18:06:16.590]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:16.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:16.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:16.590]                               "release", "version")], collapse = " "), 
[18:06:16.590]                             hostname = base::Sys.info()[["nodename"]])
[18:06:16.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:16.590]                             info)
[18:06:16.590]                           info <- base::paste(info, collapse = "; ")
[18:06:16.590]                           if (!has_future) {
[18:06:16.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:16.590]                               info)
[18:06:16.590]                           }
[18:06:16.590]                           else {
[18:06:16.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:16.590]                               info, version)
[18:06:16.590]                           }
[18:06:16.590]                           base::stop(msg)
[18:06:16.590]                         }
[18:06:16.590]                       })
[18:06:16.590]                     }
[18:06:16.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:16.590]                     base::options(mc.cores = 1L)
[18:06:16.590]                   }
[18:06:16.590]                   ...future.strategy.old <- future::plan("list")
[18:06:16.590]                   options(future.plan = NULL)
[18:06:16.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:16.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:16.590]                 }
[18:06:16.590]                 ...future.workdir <- getwd()
[18:06:16.590]             }
[18:06:16.590]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:16.590]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:16.590]         }
[18:06:16.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:16.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:16.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:16.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:16.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:16.590]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:16.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:16.590]             base::names(...future.oldOptions))
[18:06:16.590]     }
[18:06:16.590]     if (FALSE) {
[18:06:16.590]     }
[18:06:16.590]     else {
[18:06:16.590]         if (TRUE) {
[18:06:16.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:16.590]                 open = "w")
[18:06:16.590]         }
[18:06:16.590]         else {
[18:06:16.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:16.590]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:16.590]         }
[18:06:16.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:16.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:16.590]             base::sink(type = "output", split = FALSE)
[18:06:16.590]             base::close(...future.stdout)
[18:06:16.590]         }, add = TRUE)
[18:06:16.590]     }
[18:06:16.590]     ...future.frame <- base::sys.nframe()
[18:06:16.590]     ...future.conditions <- base::list()
[18:06:16.590]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:16.590]     if (FALSE) {
[18:06:16.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:16.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:16.590]     }
[18:06:16.590]     ...future.result <- base::tryCatch({
[18:06:16.590]         base::withCallingHandlers({
[18:06:16.590]             ...future.value <- base::withVisible(base::local({
[18:06:16.590]                 ...future.makeSendCondition <- base::local({
[18:06:16.590]                   sendCondition <- NULL
[18:06:16.590]                   function(frame = 1L) {
[18:06:16.590]                     if (is.function(sendCondition)) 
[18:06:16.590]                       return(sendCondition)
[18:06:16.590]                     ns <- getNamespace("parallel")
[18:06:16.590]                     if (exists("sendData", mode = "function", 
[18:06:16.590]                       envir = ns)) {
[18:06:16.590]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:16.590]                         envir = ns)
[18:06:16.590]                       envir <- sys.frame(frame)
[18:06:16.590]                       master <- NULL
[18:06:16.590]                       while (!identical(envir, .GlobalEnv) && 
[18:06:16.590]                         !identical(envir, emptyenv())) {
[18:06:16.590]                         if (exists("master", mode = "list", envir = envir, 
[18:06:16.590]                           inherits = FALSE)) {
[18:06:16.590]                           master <- get("master", mode = "list", 
[18:06:16.590]                             envir = envir, inherits = FALSE)
[18:06:16.590]                           if (inherits(master, c("SOCKnode", 
[18:06:16.590]                             "SOCK0node"))) {
[18:06:16.590]                             sendCondition <<- function(cond) {
[18:06:16.590]                               data <- list(type = "VALUE", value = cond, 
[18:06:16.590]                                 success = TRUE)
[18:06:16.590]                               parallel_sendData(master, data)
[18:06:16.590]                             }
[18:06:16.590]                             return(sendCondition)
[18:06:16.590]                           }
[18:06:16.590]                         }
[18:06:16.590]                         frame <- frame + 1L
[18:06:16.590]                         envir <- sys.frame(frame)
[18:06:16.590]                       }
[18:06:16.590]                     }
[18:06:16.590]                     sendCondition <<- function(cond) NULL
[18:06:16.590]                   }
[18:06:16.590]                 })
[18:06:16.590]                 withCallingHandlers({
[18:06:16.590]                   {
[18:06:16.590]                     Sys.sleep(0.5)
[18:06:16.590]                     list(a = 1, b = 42L)
[18:06:16.590]                   }
[18:06:16.590]                 }, immediateCondition = function(cond) {
[18:06:16.590]                   sendCondition <- ...future.makeSendCondition()
[18:06:16.590]                   sendCondition(cond)
[18:06:16.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.590]                   {
[18:06:16.590]                     inherits <- base::inherits
[18:06:16.590]                     invokeRestart <- base::invokeRestart
[18:06:16.590]                     is.null <- base::is.null
[18:06:16.590]                     muffled <- FALSE
[18:06:16.590]                     if (inherits(cond, "message")) {
[18:06:16.590]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:16.590]                       if (muffled) 
[18:06:16.590]                         invokeRestart("muffleMessage")
[18:06:16.590]                     }
[18:06:16.590]                     else if (inherits(cond, "warning")) {
[18:06:16.590]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:16.590]                       if (muffled) 
[18:06:16.590]                         invokeRestart("muffleWarning")
[18:06:16.590]                     }
[18:06:16.590]                     else if (inherits(cond, "condition")) {
[18:06:16.590]                       if (!is.null(pattern)) {
[18:06:16.590]                         computeRestarts <- base::computeRestarts
[18:06:16.590]                         grepl <- base::grepl
[18:06:16.590]                         restarts <- computeRestarts(cond)
[18:06:16.590]                         for (restart in restarts) {
[18:06:16.590]                           name <- restart$name
[18:06:16.590]                           if (is.null(name)) 
[18:06:16.590]                             next
[18:06:16.590]                           if (!grepl(pattern, name)) 
[18:06:16.590]                             next
[18:06:16.590]                           invokeRestart(restart)
[18:06:16.590]                           muffled <- TRUE
[18:06:16.590]                           break
[18:06:16.590]                         }
[18:06:16.590]                       }
[18:06:16.590]                     }
[18:06:16.590]                     invisible(muffled)
[18:06:16.590]                   }
[18:06:16.590]                   muffleCondition(cond)
[18:06:16.590]                 })
[18:06:16.590]             }))
[18:06:16.590]             future::FutureResult(value = ...future.value$value, 
[18:06:16.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:16.590]                   ...future.rng), globalenv = if (FALSE) 
[18:06:16.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:16.590]                     ...future.globalenv.names))
[18:06:16.590]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:16.590]         }, condition = base::local({
[18:06:16.590]             c <- base::c
[18:06:16.590]             inherits <- base::inherits
[18:06:16.590]             invokeRestart <- base::invokeRestart
[18:06:16.590]             length <- base::length
[18:06:16.590]             list <- base::list
[18:06:16.590]             seq.int <- base::seq.int
[18:06:16.590]             signalCondition <- base::signalCondition
[18:06:16.590]             sys.calls <- base::sys.calls
[18:06:16.590]             `[[` <- base::`[[`
[18:06:16.590]             `+` <- base::`+`
[18:06:16.590]             `<<-` <- base::`<<-`
[18:06:16.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:16.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:16.590]                   3L)]
[18:06:16.590]             }
[18:06:16.590]             function(cond) {
[18:06:16.590]                 is_error <- inherits(cond, "error")
[18:06:16.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:16.590]                   NULL)
[18:06:16.590]                 if (is_error) {
[18:06:16.590]                   sessionInformation <- function() {
[18:06:16.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:16.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:16.590]                       search = base::search(), system = base::Sys.info())
[18:06:16.590]                   }
[18:06:16.590]                   ...future.conditions[[length(...future.conditions) + 
[18:06:16.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:16.590]                     cond$call), session = sessionInformation(), 
[18:06:16.590]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:16.590]                   signalCondition(cond)
[18:06:16.590]                 }
[18:06:16.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:16.590]                 "immediateCondition"))) {
[18:06:16.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:16.590]                   ...future.conditions[[length(...future.conditions) + 
[18:06:16.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:16.590]                   if (TRUE && !signal) {
[18:06:16.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.590]                     {
[18:06:16.590]                       inherits <- base::inherits
[18:06:16.590]                       invokeRestart <- base::invokeRestart
[18:06:16.590]                       is.null <- base::is.null
[18:06:16.590]                       muffled <- FALSE
[18:06:16.590]                       if (inherits(cond, "message")) {
[18:06:16.590]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:16.590]                         if (muffled) 
[18:06:16.590]                           invokeRestart("muffleMessage")
[18:06:16.590]                       }
[18:06:16.590]                       else if (inherits(cond, "warning")) {
[18:06:16.590]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:16.590]                         if (muffled) 
[18:06:16.590]                           invokeRestart("muffleWarning")
[18:06:16.590]                       }
[18:06:16.590]                       else if (inherits(cond, "condition")) {
[18:06:16.590]                         if (!is.null(pattern)) {
[18:06:16.590]                           computeRestarts <- base::computeRestarts
[18:06:16.590]                           grepl <- base::grepl
[18:06:16.590]                           restarts <- computeRestarts(cond)
[18:06:16.590]                           for (restart in restarts) {
[18:06:16.590]                             name <- restart$name
[18:06:16.590]                             if (is.null(name)) 
[18:06:16.590]                               next
[18:06:16.590]                             if (!grepl(pattern, name)) 
[18:06:16.590]                               next
[18:06:16.590]                             invokeRestart(restart)
[18:06:16.590]                             muffled <- TRUE
[18:06:16.590]                             break
[18:06:16.590]                           }
[18:06:16.590]                         }
[18:06:16.590]                       }
[18:06:16.590]                       invisible(muffled)
[18:06:16.590]                     }
[18:06:16.590]                     muffleCondition(cond, pattern = "^muffle")
[18:06:16.590]                   }
[18:06:16.590]                 }
[18:06:16.590]                 else {
[18:06:16.590]                   if (TRUE) {
[18:06:16.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:16.590]                     {
[18:06:16.590]                       inherits <- base::inherits
[18:06:16.590]                       invokeRestart <- base::invokeRestart
[18:06:16.590]                       is.null <- base::is.null
[18:06:16.590]                       muffled <- FALSE
[18:06:16.590]                       if (inherits(cond, "message")) {
[18:06:16.590]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:16.590]                         if (muffled) 
[18:06:16.590]                           invokeRestart("muffleMessage")
[18:06:16.590]                       }
[18:06:16.590]                       else if (inherits(cond, "warning")) {
[18:06:16.590]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:16.590]                         if (muffled) 
[18:06:16.590]                           invokeRestart("muffleWarning")
[18:06:16.590]                       }
[18:06:16.590]                       else if (inherits(cond, "condition")) {
[18:06:16.590]                         if (!is.null(pattern)) {
[18:06:16.590]                           computeRestarts <- base::computeRestarts
[18:06:16.590]                           grepl <- base::grepl
[18:06:16.590]                           restarts <- computeRestarts(cond)
[18:06:16.590]                           for (restart in restarts) {
[18:06:16.590]                             name <- restart$name
[18:06:16.590]                             if (is.null(name)) 
[18:06:16.590]                               next
[18:06:16.590]                             if (!grepl(pattern, name)) 
[18:06:16.590]                               next
[18:06:16.590]                             invokeRestart(restart)
[18:06:16.590]                             muffled <- TRUE
[18:06:16.590]                             break
[18:06:16.590]                           }
[18:06:16.590]                         }
[18:06:16.590]                       }
[18:06:16.590]                       invisible(muffled)
[18:06:16.590]                     }
[18:06:16.590]                     muffleCondition(cond, pattern = "^muffle")
[18:06:16.590]                   }
[18:06:16.590]                 }
[18:06:16.590]             }
[18:06:16.590]         }))
[18:06:16.590]     }, error = function(ex) {
[18:06:16.590]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:16.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:16.590]                 ...future.rng), started = ...future.startTime, 
[18:06:16.590]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:16.590]             version = "1.8"), class = "FutureResult")
[18:06:16.590]     }, finally = {
[18:06:16.590]         if (!identical(...future.workdir, getwd())) 
[18:06:16.590]             setwd(...future.workdir)
[18:06:16.590]         {
[18:06:16.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:16.590]                 ...future.oldOptions$nwarnings <- NULL
[18:06:16.590]             }
[18:06:16.590]             base::options(...future.oldOptions)
[18:06:16.590]             if (.Platform$OS.type == "windows") {
[18:06:16.590]                 old_names <- names(...future.oldEnvVars)
[18:06:16.590]                 envs <- base::Sys.getenv()
[18:06:16.590]                 names <- names(envs)
[18:06:16.590]                 common <- intersect(names, old_names)
[18:06:16.590]                 added <- setdiff(names, old_names)
[18:06:16.590]                 removed <- setdiff(old_names, names)
[18:06:16.590]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:16.590]                   envs[common]]
[18:06:16.590]                 NAMES <- toupper(changed)
[18:06:16.590]                 args <- list()
[18:06:16.590]                 for (kk in seq_along(NAMES)) {
[18:06:16.590]                   name <- changed[[kk]]
[18:06:16.590]                   NAME <- NAMES[[kk]]
[18:06:16.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.590]                     next
[18:06:16.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:16.590]                 }
[18:06:16.590]                 NAMES <- toupper(added)
[18:06:16.590]                 for (kk in seq_along(NAMES)) {
[18:06:16.590]                   name <- added[[kk]]
[18:06:16.590]                   NAME <- NAMES[[kk]]
[18:06:16.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.590]                     next
[18:06:16.590]                   args[[name]] <- ""
[18:06:16.590]                 }
[18:06:16.590]                 NAMES <- toupper(removed)
[18:06:16.590]                 for (kk in seq_along(NAMES)) {
[18:06:16.590]                   name <- removed[[kk]]
[18:06:16.590]                   NAME <- NAMES[[kk]]
[18:06:16.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:16.590]                     next
[18:06:16.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:16.590]                 }
[18:06:16.590]                 if (length(args) > 0) 
[18:06:16.590]                   base::do.call(base::Sys.setenv, args = args)
[18:06:16.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:16.590]             }
[18:06:16.590]             else {
[18:06:16.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:16.590]             }
[18:06:16.590]             {
[18:06:16.590]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:16.590]                   0L) {
[18:06:16.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:16.590]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:16.590]                   base::options(opts)
[18:06:16.590]                 }
[18:06:16.590]                 {
[18:06:16.590]                   {
[18:06:16.590]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:16.590]                     NULL
[18:06:16.590]                   }
[18:06:16.590]                   options(future.plan = NULL)
[18:06:16.590]                   if (is.na(NA_character_)) 
[18:06:16.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:16.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:16.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:16.590]                     .init = FALSE)
[18:06:16.590]                 }
[18:06:16.590]             }
[18:06:16.590]         }
[18:06:16.590]     })
[18:06:16.590]     if (TRUE) {
[18:06:16.590]         base::sink(type = "output", split = FALSE)
[18:06:16.590]         if (TRUE) {
[18:06:16.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:16.590]         }
[18:06:16.590]         else {
[18:06:16.590]             ...future.result["stdout"] <- base::list(NULL)
[18:06:16.590]         }
[18:06:16.590]         base::close(...future.stdout)
[18:06:16.590]         ...future.stdout <- NULL
[18:06:16.590]     }
[18:06:16.590]     ...future.result$conditions <- ...future.conditions
[18:06:16.590]     ...future.result$finished <- base::Sys.time()
[18:06:16.590]     ...future.result
[18:06:16.590] }
[18:06:16.596] MultisessionFuture started
[18:06:16.596] - Launch lazy future ... done
[18:06:16.597] run() for ‘MultisessionFuture’ ... done
[18:06:17.141] receiveMessageFromWorker() for ClusterFuture ...
[18:06:17.141] - Validating connection of MultisessionFuture
[18:06:17.141] - received message: FutureResult
[18:06:17.142] - Received FutureResult
[18:06:17.143] - Erased future from FutureRegistry
[18:06:17.143] result() for ClusterFuture ...
[18:06:17.143] - result already collected: FutureResult
[18:06:17.144] result() for ClusterFuture ... done
[18:06:17.144] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:17.144] A MultisessionFuture was resolved (result was not collected)
[18:06:17.144] getGlobalsAndPackages() ...
[18:06:17.144] Searching for globals...
[18:06:17.147] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:17.147] Searching for globals ... DONE
[18:06:17.147] Resolving globals: FALSE
[18:06:17.148] 
[18:06:17.148] 
[18:06:17.148] getGlobalsAndPackages() ... DONE
[18:06:17.149] run() for ‘Future’ ...
[18:06:17.149] - state: ‘created’
[18:06:17.149] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:17.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:17.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:17.174]   - Field: ‘node’
[18:06:17.174]   - Field: ‘label’
[18:06:17.175]   - Field: ‘local’
[18:06:17.175]   - Field: ‘owner’
[18:06:17.175]   - Field: ‘envir’
[18:06:17.175]   - Field: ‘workers’
[18:06:17.175]   - Field: ‘packages’
[18:06:17.176]   - Field: ‘gc’
[18:06:17.176]   - Field: ‘conditions’
[18:06:17.176]   - Field: ‘persistent’
[18:06:17.176]   - Field: ‘expr’
[18:06:17.176]   - Field: ‘uuid’
[18:06:17.177]   - Field: ‘seed’
[18:06:17.177]   - Field: ‘version’
[18:06:17.177]   - Field: ‘result’
[18:06:17.177]   - Field: ‘asynchronous’
[18:06:17.177]   - Field: ‘calls’
[18:06:17.178]   - Field: ‘globals’
[18:06:17.178]   - Field: ‘stdout’
[18:06:17.178]   - Field: ‘earlySignal’
[18:06:17.178]   - Field: ‘lazy’
[18:06:17.178]   - Field: ‘state’
[18:06:17.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:17.179] - Launch lazy future ...
[18:06:17.179] Packages needed by the future expression (n = 0): <none>
[18:06:17.180] Packages needed by future strategies (n = 0): <none>
[18:06:17.181] {
[18:06:17.181]     {
[18:06:17.181]         {
[18:06:17.181]             ...future.startTime <- base::Sys.time()
[18:06:17.181]             {
[18:06:17.181]                 {
[18:06:17.181]                   {
[18:06:17.181]                     {
[18:06:17.181]                       base::local({
[18:06:17.181]                         has_future <- base::requireNamespace("future", 
[18:06:17.181]                           quietly = TRUE)
[18:06:17.181]                         if (has_future) {
[18:06:17.181]                           ns <- base::getNamespace("future")
[18:06:17.181]                           version <- ns[[".package"]][["version"]]
[18:06:17.181]                           if (is.null(version)) 
[18:06:17.181]                             version <- utils::packageVersion("future")
[18:06:17.181]                         }
[18:06:17.181]                         else {
[18:06:17.181]                           version <- NULL
[18:06:17.181]                         }
[18:06:17.181]                         if (!has_future || version < "1.8.0") {
[18:06:17.181]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:17.181]                             "", base::R.version$version.string), 
[18:06:17.181]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:17.181]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:17.181]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:17.181]                               "release", "version")], collapse = " "), 
[18:06:17.181]                             hostname = base::Sys.info()[["nodename"]])
[18:06:17.181]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:17.181]                             info)
[18:06:17.181]                           info <- base::paste(info, collapse = "; ")
[18:06:17.181]                           if (!has_future) {
[18:06:17.181]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:17.181]                               info)
[18:06:17.181]                           }
[18:06:17.181]                           else {
[18:06:17.181]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:17.181]                               info, version)
[18:06:17.181]                           }
[18:06:17.181]                           base::stop(msg)
[18:06:17.181]                         }
[18:06:17.181]                       })
[18:06:17.181]                     }
[18:06:17.181]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:17.181]                     base::options(mc.cores = 1L)
[18:06:17.181]                   }
[18:06:17.181]                   ...future.strategy.old <- future::plan("list")
[18:06:17.181]                   options(future.plan = NULL)
[18:06:17.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:17.181]                 }
[18:06:17.181]                 ...future.workdir <- getwd()
[18:06:17.181]             }
[18:06:17.181]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:17.181]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:17.181]         }
[18:06:17.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:17.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:17.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:17.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:17.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:17.181]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:17.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:17.181]             base::names(...future.oldOptions))
[18:06:17.181]     }
[18:06:17.181]     if (FALSE) {
[18:06:17.181]     }
[18:06:17.181]     else {
[18:06:17.181]         if (TRUE) {
[18:06:17.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:17.181]                 open = "w")
[18:06:17.181]         }
[18:06:17.181]         else {
[18:06:17.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:17.181]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:17.181]         }
[18:06:17.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:17.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:17.181]             base::sink(type = "output", split = FALSE)
[18:06:17.181]             base::close(...future.stdout)
[18:06:17.181]         }, add = TRUE)
[18:06:17.181]     }
[18:06:17.181]     ...future.frame <- base::sys.nframe()
[18:06:17.181]     ...future.conditions <- base::list()
[18:06:17.181]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:17.181]     if (FALSE) {
[18:06:17.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:17.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:17.181]     }
[18:06:17.181]     ...future.result <- base::tryCatch({
[18:06:17.181]         base::withCallingHandlers({
[18:06:17.181]             ...future.value <- base::withVisible(base::local({
[18:06:17.181]                 ...future.makeSendCondition <- base::local({
[18:06:17.181]                   sendCondition <- NULL
[18:06:17.181]                   function(frame = 1L) {
[18:06:17.181]                     if (is.function(sendCondition)) 
[18:06:17.181]                       return(sendCondition)
[18:06:17.181]                     ns <- getNamespace("parallel")
[18:06:17.181]                     if (exists("sendData", mode = "function", 
[18:06:17.181]                       envir = ns)) {
[18:06:17.181]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:17.181]                         envir = ns)
[18:06:17.181]                       envir <- sys.frame(frame)
[18:06:17.181]                       master <- NULL
[18:06:17.181]                       while (!identical(envir, .GlobalEnv) && 
[18:06:17.181]                         !identical(envir, emptyenv())) {
[18:06:17.181]                         if (exists("master", mode = "list", envir = envir, 
[18:06:17.181]                           inherits = FALSE)) {
[18:06:17.181]                           master <- get("master", mode = "list", 
[18:06:17.181]                             envir = envir, inherits = FALSE)
[18:06:17.181]                           if (inherits(master, c("SOCKnode", 
[18:06:17.181]                             "SOCK0node"))) {
[18:06:17.181]                             sendCondition <<- function(cond) {
[18:06:17.181]                               data <- list(type = "VALUE", value = cond, 
[18:06:17.181]                                 success = TRUE)
[18:06:17.181]                               parallel_sendData(master, data)
[18:06:17.181]                             }
[18:06:17.181]                             return(sendCondition)
[18:06:17.181]                           }
[18:06:17.181]                         }
[18:06:17.181]                         frame <- frame + 1L
[18:06:17.181]                         envir <- sys.frame(frame)
[18:06:17.181]                       }
[18:06:17.181]                     }
[18:06:17.181]                     sendCondition <<- function(cond) NULL
[18:06:17.181]                   }
[18:06:17.181]                 })
[18:06:17.181]                 withCallingHandlers({
[18:06:17.181]                   {
[18:06:17.181]                     Sys.sleep(0.5)
[18:06:17.181]                     list(a = 1, b = 42L)
[18:06:17.181]                   }
[18:06:17.181]                 }, immediateCondition = function(cond) {
[18:06:17.181]                   sendCondition <- ...future.makeSendCondition()
[18:06:17.181]                   sendCondition(cond)
[18:06:17.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.181]                   {
[18:06:17.181]                     inherits <- base::inherits
[18:06:17.181]                     invokeRestart <- base::invokeRestart
[18:06:17.181]                     is.null <- base::is.null
[18:06:17.181]                     muffled <- FALSE
[18:06:17.181]                     if (inherits(cond, "message")) {
[18:06:17.181]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:17.181]                       if (muffled) 
[18:06:17.181]                         invokeRestart("muffleMessage")
[18:06:17.181]                     }
[18:06:17.181]                     else if (inherits(cond, "warning")) {
[18:06:17.181]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:17.181]                       if (muffled) 
[18:06:17.181]                         invokeRestart("muffleWarning")
[18:06:17.181]                     }
[18:06:17.181]                     else if (inherits(cond, "condition")) {
[18:06:17.181]                       if (!is.null(pattern)) {
[18:06:17.181]                         computeRestarts <- base::computeRestarts
[18:06:17.181]                         grepl <- base::grepl
[18:06:17.181]                         restarts <- computeRestarts(cond)
[18:06:17.181]                         for (restart in restarts) {
[18:06:17.181]                           name <- restart$name
[18:06:17.181]                           if (is.null(name)) 
[18:06:17.181]                             next
[18:06:17.181]                           if (!grepl(pattern, name)) 
[18:06:17.181]                             next
[18:06:17.181]                           invokeRestart(restart)
[18:06:17.181]                           muffled <- TRUE
[18:06:17.181]                           break
[18:06:17.181]                         }
[18:06:17.181]                       }
[18:06:17.181]                     }
[18:06:17.181]                     invisible(muffled)
[18:06:17.181]                   }
[18:06:17.181]                   muffleCondition(cond)
[18:06:17.181]                 })
[18:06:17.181]             }))
[18:06:17.181]             future::FutureResult(value = ...future.value$value, 
[18:06:17.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.181]                   ...future.rng), globalenv = if (FALSE) 
[18:06:17.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:17.181]                     ...future.globalenv.names))
[18:06:17.181]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:17.181]         }, condition = base::local({
[18:06:17.181]             c <- base::c
[18:06:17.181]             inherits <- base::inherits
[18:06:17.181]             invokeRestart <- base::invokeRestart
[18:06:17.181]             length <- base::length
[18:06:17.181]             list <- base::list
[18:06:17.181]             seq.int <- base::seq.int
[18:06:17.181]             signalCondition <- base::signalCondition
[18:06:17.181]             sys.calls <- base::sys.calls
[18:06:17.181]             `[[` <- base::`[[`
[18:06:17.181]             `+` <- base::`+`
[18:06:17.181]             `<<-` <- base::`<<-`
[18:06:17.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:17.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:17.181]                   3L)]
[18:06:17.181]             }
[18:06:17.181]             function(cond) {
[18:06:17.181]                 is_error <- inherits(cond, "error")
[18:06:17.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:17.181]                   NULL)
[18:06:17.181]                 if (is_error) {
[18:06:17.181]                   sessionInformation <- function() {
[18:06:17.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:17.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:17.181]                       search = base::search(), system = base::Sys.info())
[18:06:17.181]                   }
[18:06:17.181]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:17.181]                     cond$call), session = sessionInformation(), 
[18:06:17.181]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:17.181]                   signalCondition(cond)
[18:06:17.181]                 }
[18:06:17.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:17.181]                 "immediateCondition"))) {
[18:06:17.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:17.181]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:17.181]                   if (TRUE && !signal) {
[18:06:17.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.181]                     {
[18:06:17.181]                       inherits <- base::inherits
[18:06:17.181]                       invokeRestart <- base::invokeRestart
[18:06:17.181]                       is.null <- base::is.null
[18:06:17.181]                       muffled <- FALSE
[18:06:17.181]                       if (inherits(cond, "message")) {
[18:06:17.181]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.181]                         if (muffled) 
[18:06:17.181]                           invokeRestart("muffleMessage")
[18:06:17.181]                       }
[18:06:17.181]                       else if (inherits(cond, "warning")) {
[18:06:17.181]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.181]                         if (muffled) 
[18:06:17.181]                           invokeRestart("muffleWarning")
[18:06:17.181]                       }
[18:06:17.181]                       else if (inherits(cond, "condition")) {
[18:06:17.181]                         if (!is.null(pattern)) {
[18:06:17.181]                           computeRestarts <- base::computeRestarts
[18:06:17.181]                           grepl <- base::grepl
[18:06:17.181]                           restarts <- computeRestarts(cond)
[18:06:17.181]                           for (restart in restarts) {
[18:06:17.181]                             name <- restart$name
[18:06:17.181]                             if (is.null(name)) 
[18:06:17.181]                               next
[18:06:17.181]                             if (!grepl(pattern, name)) 
[18:06:17.181]                               next
[18:06:17.181]                             invokeRestart(restart)
[18:06:17.181]                             muffled <- TRUE
[18:06:17.181]                             break
[18:06:17.181]                           }
[18:06:17.181]                         }
[18:06:17.181]                       }
[18:06:17.181]                       invisible(muffled)
[18:06:17.181]                     }
[18:06:17.181]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.181]                   }
[18:06:17.181]                 }
[18:06:17.181]                 else {
[18:06:17.181]                   if (TRUE) {
[18:06:17.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.181]                     {
[18:06:17.181]                       inherits <- base::inherits
[18:06:17.181]                       invokeRestart <- base::invokeRestart
[18:06:17.181]                       is.null <- base::is.null
[18:06:17.181]                       muffled <- FALSE
[18:06:17.181]                       if (inherits(cond, "message")) {
[18:06:17.181]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.181]                         if (muffled) 
[18:06:17.181]                           invokeRestart("muffleMessage")
[18:06:17.181]                       }
[18:06:17.181]                       else if (inherits(cond, "warning")) {
[18:06:17.181]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.181]                         if (muffled) 
[18:06:17.181]                           invokeRestart("muffleWarning")
[18:06:17.181]                       }
[18:06:17.181]                       else if (inherits(cond, "condition")) {
[18:06:17.181]                         if (!is.null(pattern)) {
[18:06:17.181]                           computeRestarts <- base::computeRestarts
[18:06:17.181]                           grepl <- base::grepl
[18:06:17.181]                           restarts <- computeRestarts(cond)
[18:06:17.181]                           for (restart in restarts) {
[18:06:17.181]                             name <- restart$name
[18:06:17.181]                             if (is.null(name)) 
[18:06:17.181]                               next
[18:06:17.181]                             if (!grepl(pattern, name)) 
[18:06:17.181]                               next
[18:06:17.181]                             invokeRestart(restart)
[18:06:17.181]                             muffled <- TRUE
[18:06:17.181]                             break
[18:06:17.181]                           }
[18:06:17.181]                         }
[18:06:17.181]                       }
[18:06:17.181]                       invisible(muffled)
[18:06:17.181]                     }
[18:06:17.181]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.181]                   }
[18:06:17.181]                 }
[18:06:17.181]             }
[18:06:17.181]         }))
[18:06:17.181]     }, error = function(ex) {
[18:06:17.181]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:17.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.181]                 ...future.rng), started = ...future.startTime, 
[18:06:17.181]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:17.181]             version = "1.8"), class = "FutureResult")
[18:06:17.181]     }, finally = {
[18:06:17.181]         if (!identical(...future.workdir, getwd())) 
[18:06:17.181]             setwd(...future.workdir)
[18:06:17.181]         {
[18:06:17.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:17.181]                 ...future.oldOptions$nwarnings <- NULL
[18:06:17.181]             }
[18:06:17.181]             base::options(...future.oldOptions)
[18:06:17.181]             if (.Platform$OS.type == "windows") {
[18:06:17.181]                 old_names <- names(...future.oldEnvVars)
[18:06:17.181]                 envs <- base::Sys.getenv()
[18:06:17.181]                 names <- names(envs)
[18:06:17.181]                 common <- intersect(names, old_names)
[18:06:17.181]                 added <- setdiff(names, old_names)
[18:06:17.181]                 removed <- setdiff(old_names, names)
[18:06:17.181]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:17.181]                   envs[common]]
[18:06:17.181]                 NAMES <- toupper(changed)
[18:06:17.181]                 args <- list()
[18:06:17.181]                 for (kk in seq_along(NAMES)) {
[18:06:17.181]                   name <- changed[[kk]]
[18:06:17.181]                   NAME <- NAMES[[kk]]
[18:06:17.181]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.181]                     next
[18:06:17.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.181]                 }
[18:06:17.181]                 NAMES <- toupper(added)
[18:06:17.181]                 for (kk in seq_along(NAMES)) {
[18:06:17.181]                   name <- added[[kk]]
[18:06:17.181]                   NAME <- NAMES[[kk]]
[18:06:17.181]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.181]                     next
[18:06:17.181]                   args[[name]] <- ""
[18:06:17.181]                 }
[18:06:17.181]                 NAMES <- toupper(removed)
[18:06:17.181]                 for (kk in seq_along(NAMES)) {
[18:06:17.181]                   name <- removed[[kk]]
[18:06:17.181]                   NAME <- NAMES[[kk]]
[18:06:17.181]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.181]                     next
[18:06:17.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.181]                 }
[18:06:17.181]                 if (length(args) > 0) 
[18:06:17.181]                   base::do.call(base::Sys.setenv, args = args)
[18:06:17.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:17.181]             }
[18:06:17.181]             else {
[18:06:17.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:17.181]             }
[18:06:17.181]             {
[18:06:17.181]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:17.181]                   0L) {
[18:06:17.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:17.181]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:17.181]                   base::options(opts)
[18:06:17.181]                 }
[18:06:17.181]                 {
[18:06:17.181]                   {
[18:06:17.181]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:17.181]                     NULL
[18:06:17.181]                   }
[18:06:17.181]                   options(future.plan = NULL)
[18:06:17.181]                   if (is.na(NA_character_)) 
[18:06:17.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:17.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:17.181]                     .init = FALSE)
[18:06:17.181]                 }
[18:06:17.181]             }
[18:06:17.181]         }
[18:06:17.181]     })
[18:06:17.181]     if (TRUE) {
[18:06:17.181]         base::sink(type = "output", split = FALSE)
[18:06:17.181]         if (TRUE) {
[18:06:17.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:17.181]         }
[18:06:17.181]         else {
[18:06:17.181]             ...future.result["stdout"] <- base::list(NULL)
[18:06:17.181]         }
[18:06:17.181]         base::close(...future.stdout)
[18:06:17.181]         ...future.stdout <- NULL
[18:06:17.181]     }
[18:06:17.181]     ...future.result$conditions <- ...future.conditions
[18:06:17.181]     ...future.result$finished <- base::Sys.time()
[18:06:17.181]     ...future.result
[18:06:17.181] }
[18:06:17.186] MultisessionFuture started
[18:06:17.186] - Launch lazy future ... done
[18:06:17.187] run() for ‘MultisessionFuture’ ... done
[18:06:17.731] receiveMessageFromWorker() for ClusterFuture ...
[18:06:17.732] - Validating connection of MultisessionFuture
[18:06:17.732] - received message: FutureResult
[18:06:17.733] - Received FutureResult
[18:06:17.733] - Erased future from FutureRegistry
[18:06:17.733] result() for ClusterFuture ...
[18:06:17.734] - result already collected: FutureResult
[18:06:17.734] result() for ClusterFuture ... done
[18:06:17.734] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:17.735] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[18:06:17.735] getGlobalsAndPackages() ...
[18:06:17.736] Searching for globals...
[18:06:17.738] - globals found: [2] ‘list’, ‘stop’
[18:06:17.738] Searching for globals ... DONE
[18:06:17.738] Resolving globals: FALSE
[18:06:17.739] 
[18:06:17.740] 
[18:06:17.740] getGlobalsAndPackages() ... DONE
[18:06:17.741] run() for ‘Future’ ...
[18:06:17.741] - state: ‘created’
[18:06:17.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:17.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:17.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:17.776]   - Field: ‘node’
[18:06:17.776]   - Field: ‘label’
[18:06:17.776]   - Field: ‘local’
[18:06:17.777]   - Field: ‘owner’
[18:06:17.777]   - Field: ‘envir’
[18:06:17.777]   - Field: ‘workers’
[18:06:17.778]   - Field: ‘packages’
[18:06:17.778]   - Field: ‘gc’
[18:06:17.778]   - Field: ‘conditions’
[18:06:17.778]   - Field: ‘persistent’
[18:06:17.779]   - Field: ‘expr’
[18:06:17.779]   - Field: ‘uuid’
[18:06:17.779]   - Field: ‘seed’
[18:06:17.780]   - Field: ‘version’
[18:06:17.780]   - Field: ‘result’
[18:06:17.780]   - Field: ‘asynchronous’
[18:06:17.780]   - Field: ‘calls’
[18:06:17.781]   - Field: ‘globals’
[18:06:17.781]   - Field: ‘stdout’
[18:06:17.781]   - Field: ‘earlySignal’
[18:06:17.781]   - Field: ‘lazy’
[18:06:17.782]   - Field: ‘state’
[18:06:17.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:17.782] - Launch lazy future ...
[18:06:17.783] Packages needed by the future expression (n = 0): <none>
[18:06:17.783] Packages needed by future strategies (n = 0): <none>
[18:06:17.784] {
[18:06:17.784]     {
[18:06:17.784]         {
[18:06:17.784]             ...future.startTime <- base::Sys.time()
[18:06:17.784]             {
[18:06:17.784]                 {
[18:06:17.784]                   {
[18:06:17.784]                     {
[18:06:17.784]                       base::local({
[18:06:17.784]                         has_future <- base::requireNamespace("future", 
[18:06:17.784]                           quietly = TRUE)
[18:06:17.784]                         if (has_future) {
[18:06:17.784]                           ns <- base::getNamespace("future")
[18:06:17.784]                           version <- ns[[".package"]][["version"]]
[18:06:17.784]                           if (is.null(version)) 
[18:06:17.784]                             version <- utils::packageVersion("future")
[18:06:17.784]                         }
[18:06:17.784]                         else {
[18:06:17.784]                           version <- NULL
[18:06:17.784]                         }
[18:06:17.784]                         if (!has_future || version < "1.8.0") {
[18:06:17.784]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:17.784]                             "", base::R.version$version.string), 
[18:06:17.784]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:17.784]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:17.784]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:17.784]                               "release", "version")], collapse = " "), 
[18:06:17.784]                             hostname = base::Sys.info()[["nodename"]])
[18:06:17.784]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:17.784]                             info)
[18:06:17.784]                           info <- base::paste(info, collapse = "; ")
[18:06:17.784]                           if (!has_future) {
[18:06:17.784]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:17.784]                               info)
[18:06:17.784]                           }
[18:06:17.784]                           else {
[18:06:17.784]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:17.784]                               info, version)
[18:06:17.784]                           }
[18:06:17.784]                           base::stop(msg)
[18:06:17.784]                         }
[18:06:17.784]                       })
[18:06:17.784]                     }
[18:06:17.784]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:17.784]                     base::options(mc.cores = 1L)
[18:06:17.784]                   }
[18:06:17.784]                   ...future.strategy.old <- future::plan("list")
[18:06:17.784]                   options(future.plan = NULL)
[18:06:17.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:17.784]                 }
[18:06:17.784]                 ...future.workdir <- getwd()
[18:06:17.784]             }
[18:06:17.784]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:17.784]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:17.784]         }
[18:06:17.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:17.784]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:17.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:17.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:17.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:17.784]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:17.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:17.784]             base::names(...future.oldOptions))
[18:06:17.784]     }
[18:06:17.784]     if (FALSE) {
[18:06:17.784]     }
[18:06:17.784]     else {
[18:06:17.784]         if (TRUE) {
[18:06:17.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:17.784]                 open = "w")
[18:06:17.784]         }
[18:06:17.784]         else {
[18:06:17.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:17.784]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:17.784]         }
[18:06:17.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:17.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:17.784]             base::sink(type = "output", split = FALSE)
[18:06:17.784]             base::close(...future.stdout)
[18:06:17.784]         }, add = TRUE)
[18:06:17.784]     }
[18:06:17.784]     ...future.frame <- base::sys.nframe()
[18:06:17.784]     ...future.conditions <- base::list()
[18:06:17.784]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:17.784]     if (FALSE) {
[18:06:17.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:17.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:17.784]     }
[18:06:17.784]     ...future.result <- base::tryCatch({
[18:06:17.784]         base::withCallingHandlers({
[18:06:17.784]             ...future.value <- base::withVisible(base::local({
[18:06:17.784]                 ...future.makeSendCondition <- base::local({
[18:06:17.784]                   sendCondition <- NULL
[18:06:17.784]                   function(frame = 1L) {
[18:06:17.784]                     if (is.function(sendCondition)) 
[18:06:17.784]                       return(sendCondition)
[18:06:17.784]                     ns <- getNamespace("parallel")
[18:06:17.784]                     if (exists("sendData", mode = "function", 
[18:06:17.784]                       envir = ns)) {
[18:06:17.784]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:17.784]                         envir = ns)
[18:06:17.784]                       envir <- sys.frame(frame)
[18:06:17.784]                       master <- NULL
[18:06:17.784]                       while (!identical(envir, .GlobalEnv) && 
[18:06:17.784]                         !identical(envir, emptyenv())) {
[18:06:17.784]                         if (exists("master", mode = "list", envir = envir, 
[18:06:17.784]                           inherits = FALSE)) {
[18:06:17.784]                           master <- get("master", mode = "list", 
[18:06:17.784]                             envir = envir, inherits = FALSE)
[18:06:17.784]                           if (inherits(master, c("SOCKnode", 
[18:06:17.784]                             "SOCK0node"))) {
[18:06:17.784]                             sendCondition <<- function(cond) {
[18:06:17.784]                               data <- list(type = "VALUE", value = cond, 
[18:06:17.784]                                 success = TRUE)
[18:06:17.784]                               parallel_sendData(master, data)
[18:06:17.784]                             }
[18:06:17.784]                             return(sendCondition)
[18:06:17.784]                           }
[18:06:17.784]                         }
[18:06:17.784]                         frame <- frame + 1L
[18:06:17.784]                         envir <- sys.frame(frame)
[18:06:17.784]                       }
[18:06:17.784]                     }
[18:06:17.784]                     sendCondition <<- function(cond) NULL
[18:06:17.784]                   }
[18:06:17.784]                 })
[18:06:17.784]                 withCallingHandlers({
[18:06:17.784]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:17.784]                 }, immediateCondition = function(cond) {
[18:06:17.784]                   sendCondition <- ...future.makeSendCondition()
[18:06:17.784]                   sendCondition(cond)
[18:06:17.784]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.784]                   {
[18:06:17.784]                     inherits <- base::inherits
[18:06:17.784]                     invokeRestart <- base::invokeRestart
[18:06:17.784]                     is.null <- base::is.null
[18:06:17.784]                     muffled <- FALSE
[18:06:17.784]                     if (inherits(cond, "message")) {
[18:06:17.784]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:17.784]                       if (muffled) 
[18:06:17.784]                         invokeRestart("muffleMessage")
[18:06:17.784]                     }
[18:06:17.784]                     else if (inherits(cond, "warning")) {
[18:06:17.784]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:17.784]                       if (muffled) 
[18:06:17.784]                         invokeRestart("muffleWarning")
[18:06:17.784]                     }
[18:06:17.784]                     else if (inherits(cond, "condition")) {
[18:06:17.784]                       if (!is.null(pattern)) {
[18:06:17.784]                         computeRestarts <- base::computeRestarts
[18:06:17.784]                         grepl <- base::grepl
[18:06:17.784]                         restarts <- computeRestarts(cond)
[18:06:17.784]                         for (restart in restarts) {
[18:06:17.784]                           name <- restart$name
[18:06:17.784]                           if (is.null(name)) 
[18:06:17.784]                             next
[18:06:17.784]                           if (!grepl(pattern, name)) 
[18:06:17.784]                             next
[18:06:17.784]                           invokeRestart(restart)
[18:06:17.784]                           muffled <- TRUE
[18:06:17.784]                           break
[18:06:17.784]                         }
[18:06:17.784]                       }
[18:06:17.784]                     }
[18:06:17.784]                     invisible(muffled)
[18:06:17.784]                   }
[18:06:17.784]                   muffleCondition(cond)
[18:06:17.784]                 })
[18:06:17.784]             }))
[18:06:17.784]             future::FutureResult(value = ...future.value$value, 
[18:06:17.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.784]                   ...future.rng), globalenv = if (FALSE) 
[18:06:17.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:17.784]                     ...future.globalenv.names))
[18:06:17.784]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:17.784]         }, condition = base::local({
[18:06:17.784]             c <- base::c
[18:06:17.784]             inherits <- base::inherits
[18:06:17.784]             invokeRestart <- base::invokeRestart
[18:06:17.784]             length <- base::length
[18:06:17.784]             list <- base::list
[18:06:17.784]             seq.int <- base::seq.int
[18:06:17.784]             signalCondition <- base::signalCondition
[18:06:17.784]             sys.calls <- base::sys.calls
[18:06:17.784]             `[[` <- base::`[[`
[18:06:17.784]             `+` <- base::`+`
[18:06:17.784]             `<<-` <- base::`<<-`
[18:06:17.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:17.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:17.784]                   3L)]
[18:06:17.784]             }
[18:06:17.784]             function(cond) {
[18:06:17.784]                 is_error <- inherits(cond, "error")
[18:06:17.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:17.784]                   NULL)
[18:06:17.784]                 if (is_error) {
[18:06:17.784]                   sessionInformation <- function() {
[18:06:17.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:17.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:17.784]                       search = base::search(), system = base::Sys.info())
[18:06:17.784]                   }
[18:06:17.784]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:17.784]                     cond$call), session = sessionInformation(), 
[18:06:17.784]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:17.784]                   signalCondition(cond)
[18:06:17.784]                 }
[18:06:17.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:17.784]                 "immediateCondition"))) {
[18:06:17.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:17.784]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:17.784]                   if (TRUE && !signal) {
[18:06:17.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.784]                     {
[18:06:17.784]                       inherits <- base::inherits
[18:06:17.784]                       invokeRestart <- base::invokeRestart
[18:06:17.784]                       is.null <- base::is.null
[18:06:17.784]                       muffled <- FALSE
[18:06:17.784]                       if (inherits(cond, "message")) {
[18:06:17.784]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.784]                         if (muffled) 
[18:06:17.784]                           invokeRestart("muffleMessage")
[18:06:17.784]                       }
[18:06:17.784]                       else if (inherits(cond, "warning")) {
[18:06:17.784]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.784]                         if (muffled) 
[18:06:17.784]                           invokeRestart("muffleWarning")
[18:06:17.784]                       }
[18:06:17.784]                       else if (inherits(cond, "condition")) {
[18:06:17.784]                         if (!is.null(pattern)) {
[18:06:17.784]                           computeRestarts <- base::computeRestarts
[18:06:17.784]                           grepl <- base::grepl
[18:06:17.784]                           restarts <- computeRestarts(cond)
[18:06:17.784]                           for (restart in restarts) {
[18:06:17.784]                             name <- restart$name
[18:06:17.784]                             if (is.null(name)) 
[18:06:17.784]                               next
[18:06:17.784]                             if (!grepl(pattern, name)) 
[18:06:17.784]                               next
[18:06:17.784]                             invokeRestart(restart)
[18:06:17.784]                             muffled <- TRUE
[18:06:17.784]                             break
[18:06:17.784]                           }
[18:06:17.784]                         }
[18:06:17.784]                       }
[18:06:17.784]                       invisible(muffled)
[18:06:17.784]                     }
[18:06:17.784]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.784]                   }
[18:06:17.784]                 }
[18:06:17.784]                 else {
[18:06:17.784]                   if (TRUE) {
[18:06:17.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.784]                     {
[18:06:17.784]                       inherits <- base::inherits
[18:06:17.784]                       invokeRestart <- base::invokeRestart
[18:06:17.784]                       is.null <- base::is.null
[18:06:17.784]                       muffled <- FALSE
[18:06:17.784]                       if (inherits(cond, "message")) {
[18:06:17.784]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.784]                         if (muffled) 
[18:06:17.784]                           invokeRestart("muffleMessage")
[18:06:17.784]                       }
[18:06:17.784]                       else if (inherits(cond, "warning")) {
[18:06:17.784]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.784]                         if (muffled) 
[18:06:17.784]                           invokeRestart("muffleWarning")
[18:06:17.784]                       }
[18:06:17.784]                       else if (inherits(cond, "condition")) {
[18:06:17.784]                         if (!is.null(pattern)) {
[18:06:17.784]                           computeRestarts <- base::computeRestarts
[18:06:17.784]                           grepl <- base::grepl
[18:06:17.784]                           restarts <- computeRestarts(cond)
[18:06:17.784]                           for (restart in restarts) {
[18:06:17.784]                             name <- restart$name
[18:06:17.784]                             if (is.null(name)) 
[18:06:17.784]                               next
[18:06:17.784]                             if (!grepl(pattern, name)) 
[18:06:17.784]                               next
[18:06:17.784]                             invokeRestart(restart)
[18:06:17.784]                             muffled <- TRUE
[18:06:17.784]                             break
[18:06:17.784]                           }
[18:06:17.784]                         }
[18:06:17.784]                       }
[18:06:17.784]                       invisible(muffled)
[18:06:17.784]                     }
[18:06:17.784]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.784]                   }
[18:06:17.784]                 }
[18:06:17.784]             }
[18:06:17.784]         }))
[18:06:17.784]     }, error = function(ex) {
[18:06:17.784]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:17.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.784]                 ...future.rng), started = ...future.startTime, 
[18:06:17.784]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:17.784]             version = "1.8"), class = "FutureResult")
[18:06:17.784]     }, finally = {
[18:06:17.784]         if (!identical(...future.workdir, getwd())) 
[18:06:17.784]             setwd(...future.workdir)
[18:06:17.784]         {
[18:06:17.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:17.784]                 ...future.oldOptions$nwarnings <- NULL
[18:06:17.784]             }
[18:06:17.784]             base::options(...future.oldOptions)
[18:06:17.784]             if (.Platform$OS.type == "windows") {
[18:06:17.784]                 old_names <- names(...future.oldEnvVars)
[18:06:17.784]                 envs <- base::Sys.getenv()
[18:06:17.784]                 names <- names(envs)
[18:06:17.784]                 common <- intersect(names, old_names)
[18:06:17.784]                 added <- setdiff(names, old_names)
[18:06:17.784]                 removed <- setdiff(old_names, names)
[18:06:17.784]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:17.784]                   envs[common]]
[18:06:17.784]                 NAMES <- toupper(changed)
[18:06:17.784]                 args <- list()
[18:06:17.784]                 for (kk in seq_along(NAMES)) {
[18:06:17.784]                   name <- changed[[kk]]
[18:06:17.784]                   NAME <- NAMES[[kk]]
[18:06:17.784]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.784]                     next
[18:06:17.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.784]                 }
[18:06:17.784]                 NAMES <- toupper(added)
[18:06:17.784]                 for (kk in seq_along(NAMES)) {
[18:06:17.784]                   name <- added[[kk]]
[18:06:17.784]                   NAME <- NAMES[[kk]]
[18:06:17.784]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.784]                     next
[18:06:17.784]                   args[[name]] <- ""
[18:06:17.784]                 }
[18:06:17.784]                 NAMES <- toupper(removed)
[18:06:17.784]                 for (kk in seq_along(NAMES)) {
[18:06:17.784]                   name <- removed[[kk]]
[18:06:17.784]                   NAME <- NAMES[[kk]]
[18:06:17.784]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.784]                     next
[18:06:17.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.784]                 }
[18:06:17.784]                 if (length(args) > 0) 
[18:06:17.784]                   base::do.call(base::Sys.setenv, args = args)
[18:06:17.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:17.784]             }
[18:06:17.784]             else {
[18:06:17.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:17.784]             }
[18:06:17.784]             {
[18:06:17.784]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:17.784]                   0L) {
[18:06:17.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:17.784]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:17.784]                   base::options(opts)
[18:06:17.784]                 }
[18:06:17.784]                 {
[18:06:17.784]                   {
[18:06:17.784]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:17.784]                     NULL
[18:06:17.784]                   }
[18:06:17.784]                   options(future.plan = NULL)
[18:06:17.784]                   if (is.na(NA_character_)) 
[18:06:17.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:17.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:17.784]                     .init = FALSE)
[18:06:17.784]                 }
[18:06:17.784]             }
[18:06:17.784]         }
[18:06:17.784]     })
[18:06:17.784]     if (TRUE) {
[18:06:17.784]         base::sink(type = "output", split = FALSE)
[18:06:17.784]         if (TRUE) {
[18:06:17.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:17.784]         }
[18:06:17.784]         else {
[18:06:17.784]             ...future.result["stdout"] <- base::list(NULL)
[18:06:17.784]         }
[18:06:17.784]         base::close(...future.stdout)
[18:06:17.784]         ...future.stdout <- NULL
[18:06:17.784]     }
[18:06:17.784]     ...future.result$conditions <- ...future.conditions
[18:06:17.784]     ...future.result$finished <- base::Sys.time()
[18:06:17.784]     ...future.result
[18:06:17.784] }
[18:06:17.792] MultisessionFuture started
[18:06:17.792] - Launch lazy future ... done
[18:06:17.792] run() for ‘MultisessionFuture’ ... done
[18:06:17.837] receiveMessageFromWorker() for ClusterFuture ...
[18:06:17.837] - Validating connection of MultisessionFuture
[18:06:17.838] - received message: FutureResult
[18:06:17.839] - Received FutureResult
[18:06:17.839] - Erased future from FutureRegistry
[18:06:17.839] result() for ClusterFuture ...
[18:06:17.840] - result already collected: FutureResult
[18:06:17.840] result() for ClusterFuture ... done
[18:06:17.840] signalConditions() ...
[18:06:17.841]  - include = ‘immediateCondition’
[18:06:17.841]  - exclude = 
[18:06:17.841]  - resignal = FALSE
[18:06:17.842]  - Number of conditions: 1
[18:06:17.842] signalConditions() ... done
[18:06:17.842] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:17.842] A MultisessionFuture was resolved (result was not collected)
[18:06:17.843] getGlobalsAndPackages() ...
[18:06:17.843] Searching for globals...
[18:06:17.845] - globals found: [2] ‘list’, ‘stop’
[18:06:17.845] Searching for globals ... DONE
[18:06:17.846] Resolving globals: FALSE
[18:06:17.847] 
[18:06:17.847] 
[18:06:17.847] getGlobalsAndPackages() ... DONE
[18:06:17.848] run() for ‘Future’ ...
[18:06:17.849] - state: ‘created’
[18:06:17.849] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:17.878] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:17.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:17.879]   - Field: ‘node’
[18:06:17.879]   - Field: ‘label’
[18:06:17.879]   - Field: ‘local’
[18:06:17.880]   - Field: ‘owner’
[18:06:17.880]   - Field: ‘envir’
[18:06:17.880]   - Field: ‘workers’
[18:06:17.880]   - Field: ‘packages’
[18:06:17.880]   - Field: ‘gc’
[18:06:17.881]   - Field: ‘conditions’
[18:06:17.881]   - Field: ‘persistent’
[18:06:17.881]   - Field: ‘expr’
[18:06:17.881]   - Field: ‘uuid’
[18:06:17.882]   - Field: ‘seed’
[18:06:17.882]   - Field: ‘version’
[18:06:17.882]   - Field: ‘result’
[18:06:17.882]   - Field: ‘asynchronous’
[18:06:17.883]   - Field: ‘calls’
[18:06:17.883]   - Field: ‘globals’
[18:06:17.883]   - Field: ‘stdout’
[18:06:17.883]   - Field: ‘earlySignal’
[18:06:17.883]   - Field: ‘lazy’
[18:06:17.884]   - Field: ‘state’
[18:06:17.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:17.884] - Launch lazy future ...
[18:06:17.885] Packages needed by the future expression (n = 0): <none>
[18:06:17.885] Packages needed by future strategies (n = 0): <none>
[18:06:17.886] {
[18:06:17.886]     {
[18:06:17.886]         {
[18:06:17.886]             ...future.startTime <- base::Sys.time()
[18:06:17.886]             {
[18:06:17.886]                 {
[18:06:17.886]                   {
[18:06:17.886]                     {
[18:06:17.886]                       base::local({
[18:06:17.886]                         has_future <- base::requireNamespace("future", 
[18:06:17.886]                           quietly = TRUE)
[18:06:17.886]                         if (has_future) {
[18:06:17.886]                           ns <- base::getNamespace("future")
[18:06:17.886]                           version <- ns[[".package"]][["version"]]
[18:06:17.886]                           if (is.null(version)) 
[18:06:17.886]                             version <- utils::packageVersion("future")
[18:06:17.886]                         }
[18:06:17.886]                         else {
[18:06:17.886]                           version <- NULL
[18:06:17.886]                         }
[18:06:17.886]                         if (!has_future || version < "1.8.0") {
[18:06:17.886]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:17.886]                             "", base::R.version$version.string), 
[18:06:17.886]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:17.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:17.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:17.886]                               "release", "version")], collapse = " "), 
[18:06:17.886]                             hostname = base::Sys.info()[["nodename"]])
[18:06:17.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:17.886]                             info)
[18:06:17.886]                           info <- base::paste(info, collapse = "; ")
[18:06:17.886]                           if (!has_future) {
[18:06:17.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:17.886]                               info)
[18:06:17.886]                           }
[18:06:17.886]                           else {
[18:06:17.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:17.886]                               info, version)
[18:06:17.886]                           }
[18:06:17.886]                           base::stop(msg)
[18:06:17.886]                         }
[18:06:17.886]                       })
[18:06:17.886]                     }
[18:06:17.886]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:17.886]                     base::options(mc.cores = 1L)
[18:06:17.886]                   }
[18:06:17.886]                   ...future.strategy.old <- future::plan("list")
[18:06:17.886]                   options(future.plan = NULL)
[18:06:17.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:17.886]                 }
[18:06:17.886]                 ...future.workdir <- getwd()
[18:06:17.886]             }
[18:06:17.886]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:17.886]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:17.886]         }
[18:06:17.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:17.886]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:17.886]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:17.886]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:17.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:17.886]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:17.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:17.886]             base::names(...future.oldOptions))
[18:06:17.886]     }
[18:06:17.886]     if (FALSE) {
[18:06:17.886]     }
[18:06:17.886]     else {
[18:06:17.886]         if (TRUE) {
[18:06:17.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:17.886]                 open = "w")
[18:06:17.886]         }
[18:06:17.886]         else {
[18:06:17.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:17.886]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:17.886]         }
[18:06:17.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:17.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:17.886]             base::sink(type = "output", split = FALSE)
[18:06:17.886]             base::close(...future.stdout)
[18:06:17.886]         }, add = TRUE)
[18:06:17.886]     }
[18:06:17.886]     ...future.frame <- base::sys.nframe()
[18:06:17.886]     ...future.conditions <- base::list()
[18:06:17.886]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:17.886]     if (FALSE) {
[18:06:17.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:17.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:17.886]     }
[18:06:17.886]     ...future.result <- base::tryCatch({
[18:06:17.886]         base::withCallingHandlers({
[18:06:17.886]             ...future.value <- base::withVisible(base::local({
[18:06:17.886]                 ...future.makeSendCondition <- base::local({
[18:06:17.886]                   sendCondition <- NULL
[18:06:17.886]                   function(frame = 1L) {
[18:06:17.886]                     if (is.function(sendCondition)) 
[18:06:17.886]                       return(sendCondition)
[18:06:17.886]                     ns <- getNamespace("parallel")
[18:06:17.886]                     if (exists("sendData", mode = "function", 
[18:06:17.886]                       envir = ns)) {
[18:06:17.886]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:17.886]                         envir = ns)
[18:06:17.886]                       envir <- sys.frame(frame)
[18:06:17.886]                       master <- NULL
[18:06:17.886]                       while (!identical(envir, .GlobalEnv) && 
[18:06:17.886]                         !identical(envir, emptyenv())) {
[18:06:17.886]                         if (exists("master", mode = "list", envir = envir, 
[18:06:17.886]                           inherits = FALSE)) {
[18:06:17.886]                           master <- get("master", mode = "list", 
[18:06:17.886]                             envir = envir, inherits = FALSE)
[18:06:17.886]                           if (inherits(master, c("SOCKnode", 
[18:06:17.886]                             "SOCK0node"))) {
[18:06:17.886]                             sendCondition <<- function(cond) {
[18:06:17.886]                               data <- list(type = "VALUE", value = cond, 
[18:06:17.886]                                 success = TRUE)
[18:06:17.886]                               parallel_sendData(master, data)
[18:06:17.886]                             }
[18:06:17.886]                             return(sendCondition)
[18:06:17.886]                           }
[18:06:17.886]                         }
[18:06:17.886]                         frame <- frame + 1L
[18:06:17.886]                         envir <- sys.frame(frame)
[18:06:17.886]                       }
[18:06:17.886]                     }
[18:06:17.886]                     sendCondition <<- function(cond) NULL
[18:06:17.886]                   }
[18:06:17.886]                 })
[18:06:17.886]                 withCallingHandlers({
[18:06:17.886]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:17.886]                 }, immediateCondition = function(cond) {
[18:06:17.886]                   sendCondition <- ...future.makeSendCondition()
[18:06:17.886]                   sendCondition(cond)
[18:06:17.886]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.886]                   {
[18:06:17.886]                     inherits <- base::inherits
[18:06:17.886]                     invokeRestart <- base::invokeRestart
[18:06:17.886]                     is.null <- base::is.null
[18:06:17.886]                     muffled <- FALSE
[18:06:17.886]                     if (inherits(cond, "message")) {
[18:06:17.886]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:17.886]                       if (muffled) 
[18:06:17.886]                         invokeRestart("muffleMessage")
[18:06:17.886]                     }
[18:06:17.886]                     else if (inherits(cond, "warning")) {
[18:06:17.886]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:17.886]                       if (muffled) 
[18:06:17.886]                         invokeRestart("muffleWarning")
[18:06:17.886]                     }
[18:06:17.886]                     else if (inherits(cond, "condition")) {
[18:06:17.886]                       if (!is.null(pattern)) {
[18:06:17.886]                         computeRestarts <- base::computeRestarts
[18:06:17.886]                         grepl <- base::grepl
[18:06:17.886]                         restarts <- computeRestarts(cond)
[18:06:17.886]                         for (restart in restarts) {
[18:06:17.886]                           name <- restart$name
[18:06:17.886]                           if (is.null(name)) 
[18:06:17.886]                             next
[18:06:17.886]                           if (!grepl(pattern, name)) 
[18:06:17.886]                             next
[18:06:17.886]                           invokeRestart(restart)
[18:06:17.886]                           muffled <- TRUE
[18:06:17.886]                           break
[18:06:17.886]                         }
[18:06:17.886]                       }
[18:06:17.886]                     }
[18:06:17.886]                     invisible(muffled)
[18:06:17.886]                   }
[18:06:17.886]                   muffleCondition(cond)
[18:06:17.886]                 })
[18:06:17.886]             }))
[18:06:17.886]             future::FutureResult(value = ...future.value$value, 
[18:06:17.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.886]                   ...future.rng), globalenv = if (FALSE) 
[18:06:17.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:17.886]                     ...future.globalenv.names))
[18:06:17.886]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:17.886]         }, condition = base::local({
[18:06:17.886]             c <- base::c
[18:06:17.886]             inherits <- base::inherits
[18:06:17.886]             invokeRestart <- base::invokeRestart
[18:06:17.886]             length <- base::length
[18:06:17.886]             list <- base::list
[18:06:17.886]             seq.int <- base::seq.int
[18:06:17.886]             signalCondition <- base::signalCondition
[18:06:17.886]             sys.calls <- base::sys.calls
[18:06:17.886]             `[[` <- base::`[[`
[18:06:17.886]             `+` <- base::`+`
[18:06:17.886]             `<<-` <- base::`<<-`
[18:06:17.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:17.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:17.886]                   3L)]
[18:06:17.886]             }
[18:06:17.886]             function(cond) {
[18:06:17.886]                 is_error <- inherits(cond, "error")
[18:06:17.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:17.886]                   NULL)
[18:06:17.886]                 if (is_error) {
[18:06:17.886]                   sessionInformation <- function() {
[18:06:17.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:17.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:17.886]                       search = base::search(), system = base::Sys.info())
[18:06:17.886]                   }
[18:06:17.886]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:17.886]                     cond$call), session = sessionInformation(), 
[18:06:17.886]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:17.886]                   signalCondition(cond)
[18:06:17.886]                 }
[18:06:17.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:17.886]                 "immediateCondition"))) {
[18:06:17.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:17.886]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:17.886]                   if (TRUE && !signal) {
[18:06:17.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.886]                     {
[18:06:17.886]                       inherits <- base::inherits
[18:06:17.886]                       invokeRestart <- base::invokeRestart
[18:06:17.886]                       is.null <- base::is.null
[18:06:17.886]                       muffled <- FALSE
[18:06:17.886]                       if (inherits(cond, "message")) {
[18:06:17.886]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.886]                         if (muffled) 
[18:06:17.886]                           invokeRestart("muffleMessage")
[18:06:17.886]                       }
[18:06:17.886]                       else if (inherits(cond, "warning")) {
[18:06:17.886]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.886]                         if (muffled) 
[18:06:17.886]                           invokeRestart("muffleWarning")
[18:06:17.886]                       }
[18:06:17.886]                       else if (inherits(cond, "condition")) {
[18:06:17.886]                         if (!is.null(pattern)) {
[18:06:17.886]                           computeRestarts <- base::computeRestarts
[18:06:17.886]                           grepl <- base::grepl
[18:06:17.886]                           restarts <- computeRestarts(cond)
[18:06:17.886]                           for (restart in restarts) {
[18:06:17.886]                             name <- restart$name
[18:06:17.886]                             if (is.null(name)) 
[18:06:17.886]                               next
[18:06:17.886]                             if (!grepl(pattern, name)) 
[18:06:17.886]                               next
[18:06:17.886]                             invokeRestart(restart)
[18:06:17.886]                             muffled <- TRUE
[18:06:17.886]                             break
[18:06:17.886]                           }
[18:06:17.886]                         }
[18:06:17.886]                       }
[18:06:17.886]                       invisible(muffled)
[18:06:17.886]                     }
[18:06:17.886]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.886]                   }
[18:06:17.886]                 }
[18:06:17.886]                 else {
[18:06:17.886]                   if (TRUE) {
[18:06:17.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.886]                     {
[18:06:17.886]                       inherits <- base::inherits
[18:06:17.886]                       invokeRestart <- base::invokeRestart
[18:06:17.886]                       is.null <- base::is.null
[18:06:17.886]                       muffled <- FALSE
[18:06:17.886]                       if (inherits(cond, "message")) {
[18:06:17.886]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.886]                         if (muffled) 
[18:06:17.886]                           invokeRestart("muffleMessage")
[18:06:17.886]                       }
[18:06:17.886]                       else if (inherits(cond, "warning")) {
[18:06:17.886]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.886]                         if (muffled) 
[18:06:17.886]                           invokeRestart("muffleWarning")
[18:06:17.886]                       }
[18:06:17.886]                       else if (inherits(cond, "condition")) {
[18:06:17.886]                         if (!is.null(pattern)) {
[18:06:17.886]                           computeRestarts <- base::computeRestarts
[18:06:17.886]                           grepl <- base::grepl
[18:06:17.886]                           restarts <- computeRestarts(cond)
[18:06:17.886]                           for (restart in restarts) {
[18:06:17.886]                             name <- restart$name
[18:06:17.886]                             if (is.null(name)) 
[18:06:17.886]                               next
[18:06:17.886]                             if (!grepl(pattern, name)) 
[18:06:17.886]                               next
[18:06:17.886]                             invokeRestart(restart)
[18:06:17.886]                             muffled <- TRUE
[18:06:17.886]                             break
[18:06:17.886]                           }
[18:06:17.886]                         }
[18:06:17.886]                       }
[18:06:17.886]                       invisible(muffled)
[18:06:17.886]                     }
[18:06:17.886]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.886]                   }
[18:06:17.886]                 }
[18:06:17.886]             }
[18:06:17.886]         }))
[18:06:17.886]     }, error = function(ex) {
[18:06:17.886]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:17.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.886]                 ...future.rng), started = ...future.startTime, 
[18:06:17.886]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:17.886]             version = "1.8"), class = "FutureResult")
[18:06:17.886]     }, finally = {
[18:06:17.886]         if (!identical(...future.workdir, getwd())) 
[18:06:17.886]             setwd(...future.workdir)
[18:06:17.886]         {
[18:06:17.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:17.886]                 ...future.oldOptions$nwarnings <- NULL
[18:06:17.886]             }
[18:06:17.886]             base::options(...future.oldOptions)
[18:06:17.886]             if (.Platform$OS.type == "windows") {
[18:06:17.886]                 old_names <- names(...future.oldEnvVars)
[18:06:17.886]                 envs <- base::Sys.getenv()
[18:06:17.886]                 names <- names(envs)
[18:06:17.886]                 common <- intersect(names, old_names)
[18:06:17.886]                 added <- setdiff(names, old_names)
[18:06:17.886]                 removed <- setdiff(old_names, names)
[18:06:17.886]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:17.886]                   envs[common]]
[18:06:17.886]                 NAMES <- toupper(changed)
[18:06:17.886]                 args <- list()
[18:06:17.886]                 for (kk in seq_along(NAMES)) {
[18:06:17.886]                   name <- changed[[kk]]
[18:06:17.886]                   NAME <- NAMES[[kk]]
[18:06:17.886]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.886]                     next
[18:06:17.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.886]                 }
[18:06:17.886]                 NAMES <- toupper(added)
[18:06:17.886]                 for (kk in seq_along(NAMES)) {
[18:06:17.886]                   name <- added[[kk]]
[18:06:17.886]                   NAME <- NAMES[[kk]]
[18:06:17.886]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.886]                     next
[18:06:17.886]                   args[[name]] <- ""
[18:06:17.886]                 }
[18:06:17.886]                 NAMES <- toupper(removed)
[18:06:17.886]                 for (kk in seq_along(NAMES)) {
[18:06:17.886]                   name <- removed[[kk]]
[18:06:17.886]                   NAME <- NAMES[[kk]]
[18:06:17.886]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.886]                     next
[18:06:17.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.886]                 }
[18:06:17.886]                 if (length(args) > 0) 
[18:06:17.886]                   base::do.call(base::Sys.setenv, args = args)
[18:06:17.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:17.886]             }
[18:06:17.886]             else {
[18:06:17.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:17.886]             }
[18:06:17.886]             {
[18:06:17.886]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:17.886]                   0L) {
[18:06:17.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:17.886]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:17.886]                   base::options(opts)
[18:06:17.886]                 }
[18:06:17.886]                 {
[18:06:17.886]                   {
[18:06:17.886]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:17.886]                     NULL
[18:06:17.886]                   }
[18:06:17.886]                   options(future.plan = NULL)
[18:06:17.886]                   if (is.na(NA_character_)) 
[18:06:17.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:17.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:17.886]                     .init = FALSE)
[18:06:17.886]                 }
[18:06:17.886]             }
[18:06:17.886]         }
[18:06:17.886]     })
[18:06:17.886]     if (TRUE) {
[18:06:17.886]         base::sink(type = "output", split = FALSE)
[18:06:17.886]         if (TRUE) {
[18:06:17.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:17.886]         }
[18:06:17.886]         else {
[18:06:17.886]             ...future.result["stdout"] <- base::list(NULL)
[18:06:17.886]         }
[18:06:17.886]         base::close(...future.stdout)
[18:06:17.886]         ...future.stdout <- NULL
[18:06:17.886]     }
[18:06:17.886]     ...future.result$conditions <- ...future.conditions
[18:06:17.886]     ...future.result$finished <- base::Sys.time()
[18:06:17.886]     ...future.result
[18:06:17.886] }
[18:06:17.892] MultisessionFuture started
[18:06:17.893] - Launch lazy future ... done
[18:06:17.893] run() for ‘MultisessionFuture’ ... done
[18:06:17.937] receiveMessageFromWorker() for ClusterFuture ...
[18:06:17.938] - Validating connection of MultisessionFuture
[18:06:17.939] - received message: FutureResult
[18:06:17.939] - Received FutureResult
[18:06:17.940] - Erased future from FutureRegistry
[18:06:17.940] result() for ClusterFuture ...
[18:06:17.940] - result already collected: FutureResult
[18:06:17.941] result() for ClusterFuture ... done
[18:06:17.941] signalConditions() ...
[18:06:17.941]  - include = ‘immediateCondition’
[18:06:17.941]  - exclude = 
[18:06:17.942]  - resignal = FALSE
[18:06:17.942]  - Number of conditions: 1
[18:06:17.942] signalConditions() ... done
[18:06:17.943] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:17.943] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[18:06:17.944] getGlobalsAndPackages() ...
[18:06:17.944] Searching for globals...
[18:06:17.948] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:17.948] Searching for globals ... DONE
[18:06:17.948] Resolving globals: FALSE
[18:06:17.949] 
[18:06:17.950] 
[18:06:17.950] getGlobalsAndPackages() ... DONE
[18:06:17.951] run() for ‘Future’ ...
[18:06:17.951] - state: ‘created’
[18:06:17.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:17.982] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:17.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:17.983]   - Field: ‘node’
[18:06:17.983]   - Field: ‘label’
[18:06:17.983]   - Field: ‘local’
[18:06:17.983]   - Field: ‘owner’
[18:06:17.984]   - Field: ‘envir’
[18:06:17.984]   - Field: ‘workers’
[18:06:17.984]   - Field: ‘packages’
[18:06:17.984]   - Field: ‘gc’
[18:06:17.984]   - Field: ‘conditions’
[18:06:17.985]   - Field: ‘persistent’
[18:06:17.985]   - Field: ‘expr’
[18:06:17.985]   - Field: ‘uuid’
[18:06:17.985]   - Field: ‘seed’
[18:06:17.986]   - Field: ‘version’
[18:06:17.986]   - Field: ‘result’
[18:06:17.989]   - Field: ‘asynchronous’
[18:06:17.990]   - Field: ‘calls’
[18:06:17.990]   - Field: ‘globals’
[18:06:17.990]   - Field: ‘stdout’
[18:06:17.990]   - Field: ‘earlySignal’
[18:06:17.991]   - Field: ‘lazy’
[18:06:17.991]   - Field: ‘state’
[18:06:17.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:17.991] - Launch lazy future ...
[18:06:17.992] Packages needed by the future expression (n = 0): <none>
[18:06:17.992] Packages needed by future strategies (n = 0): <none>
[18:06:17.993] {
[18:06:17.993]     {
[18:06:17.993]         {
[18:06:17.993]             ...future.startTime <- base::Sys.time()
[18:06:17.993]             {
[18:06:17.993]                 {
[18:06:17.993]                   {
[18:06:17.993]                     {
[18:06:17.993]                       base::local({
[18:06:17.993]                         has_future <- base::requireNamespace("future", 
[18:06:17.993]                           quietly = TRUE)
[18:06:17.993]                         if (has_future) {
[18:06:17.993]                           ns <- base::getNamespace("future")
[18:06:17.993]                           version <- ns[[".package"]][["version"]]
[18:06:17.993]                           if (is.null(version)) 
[18:06:17.993]                             version <- utils::packageVersion("future")
[18:06:17.993]                         }
[18:06:17.993]                         else {
[18:06:17.993]                           version <- NULL
[18:06:17.993]                         }
[18:06:17.993]                         if (!has_future || version < "1.8.0") {
[18:06:17.993]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:17.993]                             "", base::R.version$version.string), 
[18:06:17.993]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:17.993]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:17.993]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:17.993]                               "release", "version")], collapse = " "), 
[18:06:17.993]                             hostname = base::Sys.info()[["nodename"]])
[18:06:17.993]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:17.993]                             info)
[18:06:17.993]                           info <- base::paste(info, collapse = "; ")
[18:06:17.993]                           if (!has_future) {
[18:06:17.993]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:17.993]                               info)
[18:06:17.993]                           }
[18:06:17.993]                           else {
[18:06:17.993]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:17.993]                               info, version)
[18:06:17.993]                           }
[18:06:17.993]                           base::stop(msg)
[18:06:17.993]                         }
[18:06:17.993]                       })
[18:06:17.993]                     }
[18:06:17.993]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:17.993]                     base::options(mc.cores = 1L)
[18:06:17.993]                   }
[18:06:17.993]                   ...future.strategy.old <- future::plan("list")
[18:06:17.993]                   options(future.plan = NULL)
[18:06:17.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:17.993]                 }
[18:06:17.993]                 ...future.workdir <- getwd()
[18:06:17.993]             }
[18:06:17.993]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:17.993]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:17.993]         }
[18:06:17.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:17.993]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:17.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:17.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:17.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:17.993]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:17.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:17.993]             base::names(...future.oldOptions))
[18:06:17.993]     }
[18:06:17.993]     if (FALSE) {
[18:06:17.993]     }
[18:06:17.993]     else {
[18:06:17.993]         if (TRUE) {
[18:06:17.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:17.993]                 open = "w")
[18:06:17.993]         }
[18:06:17.993]         else {
[18:06:17.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:17.993]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:17.993]         }
[18:06:17.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:17.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:17.993]             base::sink(type = "output", split = FALSE)
[18:06:17.993]             base::close(...future.stdout)
[18:06:17.993]         }, add = TRUE)
[18:06:17.993]     }
[18:06:17.993]     ...future.frame <- base::sys.nframe()
[18:06:17.993]     ...future.conditions <- base::list()
[18:06:17.993]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:17.993]     if (FALSE) {
[18:06:17.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:17.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:17.993]     }
[18:06:17.993]     ...future.result <- base::tryCatch({
[18:06:17.993]         base::withCallingHandlers({
[18:06:17.993]             ...future.value <- base::withVisible(base::local({
[18:06:17.993]                 ...future.makeSendCondition <- base::local({
[18:06:17.993]                   sendCondition <- NULL
[18:06:17.993]                   function(frame = 1L) {
[18:06:17.993]                     if (is.function(sendCondition)) 
[18:06:17.993]                       return(sendCondition)
[18:06:17.993]                     ns <- getNamespace("parallel")
[18:06:17.993]                     if (exists("sendData", mode = "function", 
[18:06:17.993]                       envir = ns)) {
[18:06:17.993]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:17.993]                         envir = ns)
[18:06:17.993]                       envir <- sys.frame(frame)
[18:06:17.993]                       master <- NULL
[18:06:17.993]                       while (!identical(envir, .GlobalEnv) && 
[18:06:17.993]                         !identical(envir, emptyenv())) {
[18:06:17.993]                         if (exists("master", mode = "list", envir = envir, 
[18:06:17.993]                           inherits = FALSE)) {
[18:06:17.993]                           master <- get("master", mode = "list", 
[18:06:17.993]                             envir = envir, inherits = FALSE)
[18:06:17.993]                           if (inherits(master, c("SOCKnode", 
[18:06:17.993]                             "SOCK0node"))) {
[18:06:17.993]                             sendCondition <<- function(cond) {
[18:06:17.993]                               data <- list(type = "VALUE", value = cond, 
[18:06:17.993]                                 success = TRUE)
[18:06:17.993]                               parallel_sendData(master, data)
[18:06:17.993]                             }
[18:06:17.993]                             return(sendCondition)
[18:06:17.993]                           }
[18:06:17.993]                         }
[18:06:17.993]                         frame <- frame + 1L
[18:06:17.993]                         envir <- sys.frame(frame)
[18:06:17.993]                       }
[18:06:17.993]                     }
[18:06:17.993]                     sendCondition <<- function(cond) NULL
[18:06:17.993]                   }
[18:06:17.993]                 })
[18:06:17.993]                 withCallingHandlers({
[18:06:17.993]                   {
[18:06:17.993]                     Sys.sleep(0.5)
[18:06:17.993]                     list(a = 1, b = 42L)
[18:06:17.993]                   }
[18:06:17.993]                 }, immediateCondition = function(cond) {
[18:06:17.993]                   sendCondition <- ...future.makeSendCondition()
[18:06:17.993]                   sendCondition(cond)
[18:06:17.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.993]                   {
[18:06:17.993]                     inherits <- base::inherits
[18:06:17.993]                     invokeRestart <- base::invokeRestart
[18:06:17.993]                     is.null <- base::is.null
[18:06:17.993]                     muffled <- FALSE
[18:06:17.993]                     if (inherits(cond, "message")) {
[18:06:17.993]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:17.993]                       if (muffled) 
[18:06:17.993]                         invokeRestart("muffleMessage")
[18:06:17.993]                     }
[18:06:17.993]                     else if (inherits(cond, "warning")) {
[18:06:17.993]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:17.993]                       if (muffled) 
[18:06:17.993]                         invokeRestart("muffleWarning")
[18:06:17.993]                     }
[18:06:17.993]                     else if (inherits(cond, "condition")) {
[18:06:17.993]                       if (!is.null(pattern)) {
[18:06:17.993]                         computeRestarts <- base::computeRestarts
[18:06:17.993]                         grepl <- base::grepl
[18:06:17.993]                         restarts <- computeRestarts(cond)
[18:06:17.993]                         for (restart in restarts) {
[18:06:17.993]                           name <- restart$name
[18:06:17.993]                           if (is.null(name)) 
[18:06:17.993]                             next
[18:06:17.993]                           if (!grepl(pattern, name)) 
[18:06:17.993]                             next
[18:06:17.993]                           invokeRestart(restart)
[18:06:17.993]                           muffled <- TRUE
[18:06:17.993]                           break
[18:06:17.993]                         }
[18:06:17.993]                       }
[18:06:17.993]                     }
[18:06:17.993]                     invisible(muffled)
[18:06:17.993]                   }
[18:06:17.993]                   muffleCondition(cond)
[18:06:17.993]                 })
[18:06:17.993]             }))
[18:06:17.993]             future::FutureResult(value = ...future.value$value, 
[18:06:17.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.993]                   ...future.rng), globalenv = if (FALSE) 
[18:06:17.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:17.993]                     ...future.globalenv.names))
[18:06:17.993]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:17.993]         }, condition = base::local({
[18:06:17.993]             c <- base::c
[18:06:17.993]             inherits <- base::inherits
[18:06:17.993]             invokeRestart <- base::invokeRestart
[18:06:17.993]             length <- base::length
[18:06:17.993]             list <- base::list
[18:06:17.993]             seq.int <- base::seq.int
[18:06:17.993]             signalCondition <- base::signalCondition
[18:06:17.993]             sys.calls <- base::sys.calls
[18:06:17.993]             `[[` <- base::`[[`
[18:06:17.993]             `+` <- base::`+`
[18:06:17.993]             `<<-` <- base::`<<-`
[18:06:17.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:17.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:17.993]                   3L)]
[18:06:17.993]             }
[18:06:17.993]             function(cond) {
[18:06:17.993]                 is_error <- inherits(cond, "error")
[18:06:17.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:17.993]                   NULL)
[18:06:17.993]                 if (is_error) {
[18:06:17.993]                   sessionInformation <- function() {
[18:06:17.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:17.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:17.993]                       search = base::search(), system = base::Sys.info())
[18:06:17.993]                   }
[18:06:17.993]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:17.993]                     cond$call), session = sessionInformation(), 
[18:06:17.993]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:17.993]                   signalCondition(cond)
[18:06:17.993]                 }
[18:06:17.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:17.993]                 "immediateCondition"))) {
[18:06:17.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:17.993]                   ...future.conditions[[length(...future.conditions) + 
[18:06:17.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:17.993]                   if (TRUE && !signal) {
[18:06:17.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.993]                     {
[18:06:17.993]                       inherits <- base::inherits
[18:06:17.993]                       invokeRestart <- base::invokeRestart
[18:06:17.993]                       is.null <- base::is.null
[18:06:17.993]                       muffled <- FALSE
[18:06:17.993]                       if (inherits(cond, "message")) {
[18:06:17.993]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.993]                         if (muffled) 
[18:06:17.993]                           invokeRestart("muffleMessage")
[18:06:17.993]                       }
[18:06:17.993]                       else if (inherits(cond, "warning")) {
[18:06:17.993]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.993]                         if (muffled) 
[18:06:17.993]                           invokeRestart("muffleWarning")
[18:06:17.993]                       }
[18:06:17.993]                       else if (inherits(cond, "condition")) {
[18:06:17.993]                         if (!is.null(pattern)) {
[18:06:17.993]                           computeRestarts <- base::computeRestarts
[18:06:17.993]                           grepl <- base::grepl
[18:06:17.993]                           restarts <- computeRestarts(cond)
[18:06:17.993]                           for (restart in restarts) {
[18:06:17.993]                             name <- restart$name
[18:06:17.993]                             if (is.null(name)) 
[18:06:17.993]                               next
[18:06:17.993]                             if (!grepl(pattern, name)) 
[18:06:17.993]                               next
[18:06:17.993]                             invokeRestart(restart)
[18:06:17.993]                             muffled <- TRUE
[18:06:17.993]                             break
[18:06:17.993]                           }
[18:06:17.993]                         }
[18:06:17.993]                       }
[18:06:17.993]                       invisible(muffled)
[18:06:17.993]                     }
[18:06:17.993]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.993]                   }
[18:06:17.993]                 }
[18:06:17.993]                 else {
[18:06:17.993]                   if (TRUE) {
[18:06:17.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:17.993]                     {
[18:06:17.993]                       inherits <- base::inherits
[18:06:17.993]                       invokeRestart <- base::invokeRestart
[18:06:17.993]                       is.null <- base::is.null
[18:06:17.993]                       muffled <- FALSE
[18:06:17.993]                       if (inherits(cond, "message")) {
[18:06:17.993]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:17.993]                         if (muffled) 
[18:06:17.993]                           invokeRestart("muffleMessage")
[18:06:17.993]                       }
[18:06:17.993]                       else if (inherits(cond, "warning")) {
[18:06:17.993]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:17.993]                         if (muffled) 
[18:06:17.993]                           invokeRestart("muffleWarning")
[18:06:17.993]                       }
[18:06:17.993]                       else if (inherits(cond, "condition")) {
[18:06:17.993]                         if (!is.null(pattern)) {
[18:06:17.993]                           computeRestarts <- base::computeRestarts
[18:06:17.993]                           grepl <- base::grepl
[18:06:17.993]                           restarts <- computeRestarts(cond)
[18:06:17.993]                           for (restart in restarts) {
[18:06:17.993]                             name <- restart$name
[18:06:17.993]                             if (is.null(name)) 
[18:06:17.993]                               next
[18:06:17.993]                             if (!grepl(pattern, name)) 
[18:06:17.993]                               next
[18:06:17.993]                             invokeRestart(restart)
[18:06:17.993]                             muffled <- TRUE
[18:06:17.993]                             break
[18:06:17.993]                           }
[18:06:17.993]                         }
[18:06:17.993]                       }
[18:06:17.993]                       invisible(muffled)
[18:06:17.993]                     }
[18:06:17.993]                     muffleCondition(cond, pattern = "^muffle")
[18:06:17.993]                   }
[18:06:17.993]                 }
[18:06:17.993]             }
[18:06:17.993]         }))
[18:06:17.993]     }, error = function(ex) {
[18:06:17.993]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:17.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:17.993]                 ...future.rng), started = ...future.startTime, 
[18:06:17.993]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:17.993]             version = "1.8"), class = "FutureResult")
[18:06:17.993]     }, finally = {
[18:06:17.993]         if (!identical(...future.workdir, getwd())) 
[18:06:17.993]             setwd(...future.workdir)
[18:06:17.993]         {
[18:06:17.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:17.993]                 ...future.oldOptions$nwarnings <- NULL
[18:06:17.993]             }
[18:06:17.993]             base::options(...future.oldOptions)
[18:06:17.993]             if (.Platform$OS.type == "windows") {
[18:06:17.993]                 old_names <- names(...future.oldEnvVars)
[18:06:17.993]                 envs <- base::Sys.getenv()
[18:06:17.993]                 names <- names(envs)
[18:06:17.993]                 common <- intersect(names, old_names)
[18:06:17.993]                 added <- setdiff(names, old_names)
[18:06:17.993]                 removed <- setdiff(old_names, names)
[18:06:17.993]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:17.993]                   envs[common]]
[18:06:17.993]                 NAMES <- toupper(changed)
[18:06:17.993]                 args <- list()
[18:06:17.993]                 for (kk in seq_along(NAMES)) {
[18:06:17.993]                   name <- changed[[kk]]
[18:06:17.993]                   NAME <- NAMES[[kk]]
[18:06:17.993]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.993]                     next
[18:06:17.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.993]                 }
[18:06:17.993]                 NAMES <- toupper(added)
[18:06:17.993]                 for (kk in seq_along(NAMES)) {
[18:06:17.993]                   name <- added[[kk]]
[18:06:17.993]                   NAME <- NAMES[[kk]]
[18:06:17.993]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.993]                     next
[18:06:17.993]                   args[[name]] <- ""
[18:06:17.993]                 }
[18:06:17.993]                 NAMES <- toupper(removed)
[18:06:17.993]                 for (kk in seq_along(NAMES)) {
[18:06:17.993]                   name <- removed[[kk]]
[18:06:17.993]                   NAME <- NAMES[[kk]]
[18:06:17.993]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:17.993]                     next
[18:06:17.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:17.993]                 }
[18:06:17.993]                 if (length(args) > 0) 
[18:06:17.993]                   base::do.call(base::Sys.setenv, args = args)
[18:06:17.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:17.993]             }
[18:06:17.993]             else {
[18:06:17.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:17.993]             }
[18:06:17.993]             {
[18:06:17.993]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:17.993]                   0L) {
[18:06:17.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:17.993]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:17.993]                   base::options(opts)
[18:06:17.993]                 }
[18:06:17.993]                 {
[18:06:17.993]                   {
[18:06:17.993]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:17.993]                     NULL
[18:06:17.993]                   }
[18:06:17.993]                   options(future.plan = NULL)
[18:06:17.993]                   if (is.na(NA_character_)) 
[18:06:17.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:17.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:17.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:17.993]                     .init = FALSE)
[18:06:17.993]                 }
[18:06:17.993]             }
[18:06:17.993]         }
[18:06:17.993]     })
[18:06:17.993]     if (TRUE) {
[18:06:17.993]         base::sink(type = "output", split = FALSE)
[18:06:17.993]         if (TRUE) {
[18:06:17.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:17.993]         }
[18:06:17.993]         else {
[18:06:17.993]             ...future.result["stdout"] <- base::list(NULL)
[18:06:17.993]         }
[18:06:17.993]         base::close(...future.stdout)
[18:06:17.993]         ...future.stdout <- NULL
[18:06:17.993]     }
[18:06:17.993]     ...future.result$conditions <- ...future.conditions
[18:06:17.993]     ...future.result$finished <- base::Sys.time()
[18:06:17.993]     ...future.result
[18:06:17.993] }
[18:06:17.999] MultisessionFuture started
[18:06:17.999] - Launch lazy future ... done
[18:06:18.000] run() for ‘MultisessionFuture’ ... done
[18:06:18.543] receiveMessageFromWorker() for ClusterFuture ...
[18:06:18.544] - Validating connection of MultisessionFuture
[18:06:18.544] - received message: FutureResult
[18:06:18.545] - Received FutureResult
[18:06:18.545] - Erased future from FutureRegistry
[18:06:18.546] result() for ClusterFuture ...
[18:06:18.546] - result already collected: FutureResult
[18:06:18.547] result() for ClusterFuture ... done
[18:06:18.547] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:18.547] A MultisessionFuture was resolved (result was not collected)
[18:06:18.548] getGlobalsAndPackages() ...
[18:06:18.548] Searching for globals...
[18:06:18.551] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:18.552] Searching for globals ... DONE
[18:06:18.552] Resolving globals: FALSE
[18:06:18.553] 
[18:06:18.554] 
[18:06:18.554] getGlobalsAndPackages() ... DONE
[18:06:18.555] run() for ‘Future’ ...
[18:06:18.555] - state: ‘created’
[18:06:18.555] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:18.593] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:18.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:18.593]   - Field: ‘node’
[18:06:18.594]   - Field: ‘label’
[18:06:18.594]   - Field: ‘local’
[18:06:18.594]   - Field: ‘owner’
[18:06:18.595]   - Field: ‘envir’
[18:06:18.595]   - Field: ‘workers’
[18:06:18.595]   - Field: ‘packages’
[18:06:18.596]   - Field: ‘gc’
[18:06:18.596]   - Field: ‘conditions’
[18:06:18.596]   - Field: ‘persistent’
[18:06:18.597]   - Field: ‘expr’
[18:06:18.597]   - Field: ‘uuid’
[18:06:18.597]   - Field: ‘seed’
[18:06:18.598]   - Field: ‘version’
[18:06:18.598]   - Field: ‘result’
[18:06:18.598]   - Field: ‘asynchronous’
[18:06:18.599]   - Field: ‘calls’
[18:06:18.599]   - Field: ‘globals’
[18:06:18.599]   - Field: ‘stdout’
[18:06:18.600]   - Field: ‘earlySignal’
[18:06:18.600]   - Field: ‘lazy’
[18:06:18.600]   - Field: ‘state’
[18:06:18.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:18.602] - Launch lazy future ...
[18:06:18.602] Packages needed by the future expression (n = 0): <none>
[18:06:18.603] Packages needed by future strategies (n = 0): <none>
[18:06:18.604] {
[18:06:18.604]     {
[18:06:18.604]         {
[18:06:18.604]             ...future.startTime <- base::Sys.time()
[18:06:18.604]             {
[18:06:18.604]                 {
[18:06:18.604]                   {
[18:06:18.604]                     {
[18:06:18.604]                       base::local({
[18:06:18.604]                         has_future <- base::requireNamespace("future", 
[18:06:18.604]                           quietly = TRUE)
[18:06:18.604]                         if (has_future) {
[18:06:18.604]                           ns <- base::getNamespace("future")
[18:06:18.604]                           version <- ns[[".package"]][["version"]]
[18:06:18.604]                           if (is.null(version)) 
[18:06:18.604]                             version <- utils::packageVersion("future")
[18:06:18.604]                         }
[18:06:18.604]                         else {
[18:06:18.604]                           version <- NULL
[18:06:18.604]                         }
[18:06:18.604]                         if (!has_future || version < "1.8.0") {
[18:06:18.604]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:18.604]                             "", base::R.version$version.string), 
[18:06:18.604]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:18.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:18.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:18.604]                               "release", "version")], collapse = " "), 
[18:06:18.604]                             hostname = base::Sys.info()[["nodename"]])
[18:06:18.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:18.604]                             info)
[18:06:18.604]                           info <- base::paste(info, collapse = "; ")
[18:06:18.604]                           if (!has_future) {
[18:06:18.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:18.604]                               info)
[18:06:18.604]                           }
[18:06:18.604]                           else {
[18:06:18.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:18.604]                               info, version)
[18:06:18.604]                           }
[18:06:18.604]                           base::stop(msg)
[18:06:18.604]                         }
[18:06:18.604]                       })
[18:06:18.604]                     }
[18:06:18.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:18.604]                     base::options(mc.cores = 1L)
[18:06:18.604]                   }
[18:06:18.604]                   ...future.strategy.old <- future::plan("list")
[18:06:18.604]                   options(future.plan = NULL)
[18:06:18.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:18.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:18.604]                 }
[18:06:18.604]                 ...future.workdir <- getwd()
[18:06:18.604]             }
[18:06:18.604]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:18.604]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:18.604]         }
[18:06:18.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:18.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:18.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:18.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:18.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:18.604]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:18.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:18.604]             base::names(...future.oldOptions))
[18:06:18.604]     }
[18:06:18.604]     if (FALSE) {
[18:06:18.604]     }
[18:06:18.604]     else {
[18:06:18.604]         if (TRUE) {
[18:06:18.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:18.604]                 open = "w")
[18:06:18.604]         }
[18:06:18.604]         else {
[18:06:18.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:18.604]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:18.604]         }
[18:06:18.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:18.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:18.604]             base::sink(type = "output", split = FALSE)
[18:06:18.604]             base::close(...future.stdout)
[18:06:18.604]         }, add = TRUE)
[18:06:18.604]     }
[18:06:18.604]     ...future.frame <- base::sys.nframe()
[18:06:18.604]     ...future.conditions <- base::list()
[18:06:18.604]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:18.604]     if (FALSE) {
[18:06:18.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:18.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:18.604]     }
[18:06:18.604]     ...future.result <- base::tryCatch({
[18:06:18.604]         base::withCallingHandlers({
[18:06:18.604]             ...future.value <- base::withVisible(base::local({
[18:06:18.604]                 ...future.makeSendCondition <- base::local({
[18:06:18.604]                   sendCondition <- NULL
[18:06:18.604]                   function(frame = 1L) {
[18:06:18.604]                     if (is.function(sendCondition)) 
[18:06:18.604]                       return(sendCondition)
[18:06:18.604]                     ns <- getNamespace("parallel")
[18:06:18.604]                     if (exists("sendData", mode = "function", 
[18:06:18.604]                       envir = ns)) {
[18:06:18.604]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:18.604]                         envir = ns)
[18:06:18.604]                       envir <- sys.frame(frame)
[18:06:18.604]                       master <- NULL
[18:06:18.604]                       while (!identical(envir, .GlobalEnv) && 
[18:06:18.604]                         !identical(envir, emptyenv())) {
[18:06:18.604]                         if (exists("master", mode = "list", envir = envir, 
[18:06:18.604]                           inherits = FALSE)) {
[18:06:18.604]                           master <- get("master", mode = "list", 
[18:06:18.604]                             envir = envir, inherits = FALSE)
[18:06:18.604]                           if (inherits(master, c("SOCKnode", 
[18:06:18.604]                             "SOCK0node"))) {
[18:06:18.604]                             sendCondition <<- function(cond) {
[18:06:18.604]                               data <- list(type = "VALUE", value = cond, 
[18:06:18.604]                                 success = TRUE)
[18:06:18.604]                               parallel_sendData(master, data)
[18:06:18.604]                             }
[18:06:18.604]                             return(sendCondition)
[18:06:18.604]                           }
[18:06:18.604]                         }
[18:06:18.604]                         frame <- frame + 1L
[18:06:18.604]                         envir <- sys.frame(frame)
[18:06:18.604]                       }
[18:06:18.604]                     }
[18:06:18.604]                     sendCondition <<- function(cond) NULL
[18:06:18.604]                   }
[18:06:18.604]                 })
[18:06:18.604]                 withCallingHandlers({
[18:06:18.604]                   {
[18:06:18.604]                     Sys.sleep(0.5)
[18:06:18.604]                     list(a = 1, b = 42L)
[18:06:18.604]                   }
[18:06:18.604]                 }, immediateCondition = function(cond) {
[18:06:18.604]                   sendCondition <- ...future.makeSendCondition()
[18:06:18.604]                   sendCondition(cond)
[18:06:18.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:18.604]                   {
[18:06:18.604]                     inherits <- base::inherits
[18:06:18.604]                     invokeRestart <- base::invokeRestart
[18:06:18.604]                     is.null <- base::is.null
[18:06:18.604]                     muffled <- FALSE
[18:06:18.604]                     if (inherits(cond, "message")) {
[18:06:18.604]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:18.604]                       if (muffled) 
[18:06:18.604]                         invokeRestart("muffleMessage")
[18:06:18.604]                     }
[18:06:18.604]                     else if (inherits(cond, "warning")) {
[18:06:18.604]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:18.604]                       if (muffled) 
[18:06:18.604]                         invokeRestart("muffleWarning")
[18:06:18.604]                     }
[18:06:18.604]                     else if (inherits(cond, "condition")) {
[18:06:18.604]                       if (!is.null(pattern)) {
[18:06:18.604]                         computeRestarts <- base::computeRestarts
[18:06:18.604]                         grepl <- base::grepl
[18:06:18.604]                         restarts <- computeRestarts(cond)
[18:06:18.604]                         for (restart in restarts) {
[18:06:18.604]                           name <- restart$name
[18:06:18.604]                           if (is.null(name)) 
[18:06:18.604]                             next
[18:06:18.604]                           if (!grepl(pattern, name)) 
[18:06:18.604]                             next
[18:06:18.604]                           invokeRestart(restart)
[18:06:18.604]                           muffled <- TRUE
[18:06:18.604]                           break
[18:06:18.604]                         }
[18:06:18.604]                       }
[18:06:18.604]                     }
[18:06:18.604]                     invisible(muffled)
[18:06:18.604]                   }
[18:06:18.604]                   muffleCondition(cond)
[18:06:18.604]                 })
[18:06:18.604]             }))
[18:06:18.604]             future::FutureResult(value = ...future.value$value, 
[18:06:18.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:18.604]                   ...future.rng), globalenv = if (FALSE) 
[18:06:18.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:18.604]                     ...future.globalenv.names))
[18:06:18.604]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:18.604]         }, condition = base::local({
[18:06:18.604]             c <- base::c
[18:06:18.604]             inherits <- base::inherits
[18:06:18.604]             invokeRestart <- base::invokeRestart
[18:06:18.604]             length <- base::length
[18:06:18.604]             list <- base::list
[18:06:18.604]             seq.int <- base::seq.int
[18:06:18.604]             signalCondition <- base::signalCondition
[18:06:18.604]             sys.calls <- base::sys.calls
[18:06:18.604]             `[[` <- base::`[[`
[18:06:18.604]             `+` <- base::`+`
[18:06:18.604]             `<<-` <- base::`<<-`
[18:06:18.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:18.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:18.604]                   3L)]
[18:06:18.604]             }
[18:06:18.604]             function(cond) {
[18:06:18.604]                 is_error <- inherits(cond, "error")
[18:06:18.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:18.604]                   NULL)
[18:06:18.604]                 if (is_error) {
[18:06:18.604]                   sessionInformation <- function() {
[18:06:18.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:18.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:18.604]                       search = base::search(), system = base::Sys.info())
[18:06:18.604]                   }
[18:06:18.604]                   ...future.conditions[[length(...future.conditions) + 
[18:06:18.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:18.604]                     cond$call), session = sessionInformation(), 
[18:06:18.604]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:18.604]                   signalCondition(cond)
[18:06:18.604]                 }
[18:06:18.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:18.604]                 "immediateCondition"))) {
[18:06:18.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:18.604]                   ...future.conditions[[length(...future.conditions) + 
[18:06:18.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:18.604]                   if (TRUE && !signal) {
[18:06:18.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:18.604]                     {
[18:06:18.604]                       inherits <- base::inherits
[18:06:18.604]                       invokeRestart <- base::invokeRestart
[18:06:18.604]                       is.null <- base::is.null
[18:06:18.604]                       muffled <- FALSE
[18:06:18.604]                       if (inherits(cond, "message")) {
[18:06:18.604]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:18.604]                         if (muffled) 
[18:06:18.604]                           invokeRestart("muffleMessage")
[18:06:18.604]                       }
[18:06:18.604]                       else if (inherits(cond, "warning")) {
[18:06:18.604]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:18.604]                         if (muffled) 
[18:06:18.604]                           invokeRestart("muffleWarning")
[18:06:18.604]                       }
[18:06:18.604]                       else if (inherits(cond, "condition")) {
[18:06:18.604]                         if (!is.null(pattern)) {
[18:06:18.604]                           computeRestarts <- base::computeRestarts
[18:06:18.604]                           grepl <- base::grepl
[18:06:18.604]                           restarts <- computeRestarts(cond)
[18:06:18.604]                           for (restart in restarts) {
[18:06:18.604]                             name <- restart$name
[18:06:18.604]                             if (is.null(name)) 
[18:06:18.604]                               next
[18:06:18.604]                             if (!grepl(pattern, name)) 
[18:06:18.604]                               next
[18:06:18.604]                             invokeRestart(restart)
[18:06:18.604]                             muffled <- TRUE
[18:06:18.604]                             break
[18:06:18.604]                           }
[18:06:18.604]                         }
[18:06:18.604]                       }
[18:06:18.604]                       invisible(muffled)
[18:06:18.604]                     }
[18:06:18.604]                     muffleCondition(cond, pattern = "^muffle")
[18:06:18.604]                   }
[18:06:18.604]                 }
[18:06:18.604]                 else {
[18:06:18.604]                   if (TRUE) {
[18:06:18.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:18.604]                     {
[18:06:18.604]                       inherits <- base::inherits
[18:06:18.604]                       invokeRestart <- base::invokeRestart
[18:06:18.604]                       is.null <- base::is.null
[18:06:18.604]                       muffled <- FALSE
[18:06:18.604]                       if (inherits(cond, "message")) {
[18:06:18.604]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:18.604]                         if (muffled) 
[18:06:18.604]                           invokeRestart("muffleMessage")
[18:06:18.604]                       }
[18:06:18.604]                       else if (inherits(cond, "warning")) {
[18:06:18.604]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:18.604]                         if (muffled) 
[18:06:18.604]                           invokeRestart("muffleWarning")
[18:06:18.604]                       }
[18:06:18.604]                       else if (inherits(cond, "condition")) {
[18:06:18.604]                         if (!is.null(pattern)) {
[18:06:18.604]                           computeRestarts <- base::computeRestarts
[18:06:18.604]                           grepl <- base::grepl
[18:06:18.604]                           restarts <- computeRestarts(cond)
[18:06:18.604]                           for (restart in restarts) {
[18:06:18.604]                             name <- restart$name
[18:06:18.604]                             if (is.null(name)) 
[18:06:18.604]                               next
[18:06:18.604]                             if (!grepl(pattern, name)) 
[18:06:18.604]                               next
[18:06:18.604]                             invokeRestart(restart)
[18:06:18.604]                             muffled <- TRUE
[18:06:18.604]                             break
[18:06:18.604]                           }
[18:06:18.604]                         }
[18:06:18.604]                       }
[18:06:18.604]                       invisible(muffled)
[18:06:18.604]                     }
[18:06:18.604]                     muffleCondition(cond, pattern = "^muffle")
[18:06:18.604]                   }
[18:06:18.604]                 }
[18:06:18.604]             }
[18:06:18.604]         }))
[18:06:18.604]     }, error = function(ex) {
[18:06:18.604]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:18.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:18.604]                 ...future.rng), started = ...future.startTime, 
[18:06:18.604]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:18.604]             version = "1.8"), class = "FutureResult")
[18:06:18.604]     }, finally = {
[18:06:18.604]         if (!identical(...future.workdir, getwd())) 
[18:06:18.604]             setwd(...future.workdir)
[18:06:18.604]         {
[18:06:18.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:18.604]                 ...future.oldOptions$nwarnings <- NULL
[18:06:18.604]             }
[18:06:18.604]             base::options(...future.oldOptions)
[18:06:18.604]             if (.Platform$OS.type == "windows") {
[18:06:18.604]                 old_names <- names(...future.oldEnvVars)
[18:06:18.604]                 envs <- base::Sys.getenv()
[18:06:18.604]                 names <- names(envs)
[18:06:18.604]                 common <- intersect(names, old_names)
[18:06:18.604]                 added <- setdiff(names, old_names)
[18:06:18.604]                 removed <- setdiff(old_names, names)
[18:06:18.604]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:18.604]                   envs[common]]
[18:06:18.604]                 NAMES <- toupper(changed)
[18:06:18.604]                 args <- list()
[18:06:18.604]                 for (kk in seq_along(NAMES)) {
[18:06:18.604]                   name <- changed[[kk]]
[18:06:18.604]                   NAME <- NAMES[[kk]]
[18:06:18.604]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:18.604]                     next
[18:06:18.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:18.604]                 }
[18:06:18.604]                 NAMES <- toupper(added)
[18:06:18.604]                 for (kk in seq_along(NAMES)) {
[18:06:18.604]                   name <- added[[kk]]
[18:06:18.604]                   NAME <- NAMES[[kk]]
[18:06:18.604]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:18.604]                     next
[18:06:18.604]                   args[[name]] <- ""
[18:06:18.604]                 }
[18:06:18.604]                 NAMES <- toupper(removed)
[18:06:18.604]                 for (kk in seq_along(NAMES)) {
[18:06:18.604]                   name <- removed[[kk]]
[18:06:18.604]                   NAME <- NAMES[[kk]]
[18:06:18.604]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:18.604]                     next
[18:06:18.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:18.604]                 }
[18:06:18.604]                 if (length(args) > 0) 
[18:06:18.604]                   base::do.call(base::Sys.setenv, args = args)
[18:06:18.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:18.604]             }
[18:06:18.604]             else {
[18:06:18.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:18.604]             }
[18:06:18.604]             {
[18:06:18.604]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:18.604]                   0L) {
[18:06:18.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:18.604]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:18.604]                   base::options(opts)
[18:06:18.604]                 }
[18:06:18.604]                 {
[18:06:18.604]                   {
[18:06:18.604]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:18.604]                     NULL
[18:06:18.604]                   }
[18:06:18.604]                   options(future.plan = NULL)
[18:06:18.604]                   if (is.na(NA_character_)) 
[18:06:18.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:18.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:18.604]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:18.604]                     .init = FALSE)
[18:06:18.604]                 }
[18:06:18.604]             }
[18:06:18.604]         }
[18:06:18.604]     })
[18:06:18.604]     if (TRUE) {
[18:06:18.604]         base::sink(type = "output", split = FALSE)
[18:06:18.604]         if (TRUE) {
[18:06:18.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:18.604]         }
[18:06:18.604]         else {
[18:06:18.604]             ...future.result["stdout"] <- base::list(NULL)
[18:06:18.604]         }
[18:06:18.604]         base::close(...future.stdout)
[18:06:18.604]         ...future.stdout <- NULL
[18:06:18.604]     }
[18:06:18.604]     ...future.result$conditions <- ...future.conditions
[18:06:18.604]     ...future.result$finished <- base::Sys.time()
[18:06:18.604]     ...future.result
[18:06:18.604] }
[18:06:18.612] MultisessionFuture started
[18:06:18.612] - Launch lazy future ... done
[18:06:18.612] run() for ‘MultisessionFuture’ ... done
[18:06:19.156] receiveMessageFromWorker() for ClusterFuture ...
[18:06:19.157] - Validating connection of MultisessionFuture
[18:06:19.157] - received message: FutureResult
[18:06:19.158] - Received FutureResult
[18:06:19.158] - Erased future from FutureRegistry
[18:06:19.158] result() for ClusterFuture ...
[18:06:19.159] - result already collected: FutureResult
[18:06:19.159] result() for ClusterFuture ... done
[18:06:19.159] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:19.159] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[18:06:19.160] getGlobalsAndPackages() ...
[18:06:19.160] Searching for globals...
[18:06:19.162] - globals found: [2] ‘list’, ‘stop’
[18:06:19.163] Searching for globals ... DONE
[18:06:19.163] Resolving globals: FALSE
[18:06:19.164] 
[18:06:19.164] 
[18:06:19.165] getGlobalsAndPackages() ... DONE
[18:06:19.165] run() for ‘Future’ ...
[18:06:19.166] - state: ‘created’
[18:06:19.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:19.196] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:19.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:19.197]   - Field: ‘node’
[18:06:19.197]   - Field: ‘label’
[18:06:19.197]   - Field: ‘local’
[18:06:19.197]   - Field: ‘owner’
[18:06:19.198]   - Field: ‘envir’
[18:06:19.198]   - Field: ‘workers’
[18:06:19.198]   - Field: ‘packages’
[18:06:19.198]   - Field: ‘gc’
[18:06:19.199]   - Field: ‘conditions’
[18:06:19.199]   - Field: ‘persistent’
[18:06:19.199]   - Field: ‘expr’
[18:06:19.199]   - Field: ‘uuid’
[18:06:19.200]   - Field: ‘seed’
[18:06:19.200]   - Field: ‘version’
[18:06:19.200]   - Field: ‘result’
[18:06:19.200]   - Field: ‘asynchronous’
[18:06:19.201]   - Field: ‘calls’
[18:06:19.201]   - Field: ‘globals’
[18:06:19.201]   - Field: ‘stdout’
[18:06:19.201]   - Field: ‘earlySignal’
[18:06:19.202]   - Field: ‘lazy’
[18:06:19.202]   - Field: ‘state’
[18:06:19.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:19.202] - Launch lazy future ...
[18:06:19.203] Packages needed by the future expression (n = 0): <none>
[18:06:19.203] Packages needed by future strategies (n = 0): <none>
[18:06:19.204] {
[18:06:19.204]     {
[18:06:19.204]         {
[18:06:19.204]             ...future.startTime <- base::Sys.time()
[18:06:19.204]             {
[18:06:19.204]                 {
[18:06:19.204]                   {
[18:06:19.204]                     {
[18:06:19.204]                       base::local({
[18:06:19.204]                         has_future <- base::requireNamespace("future", 
[18:06:19.204]                           quietly = TRUE)
[18:06:19.204]                         if (has_future) {
[18:06:19.204]                           ns <- base::getNamespace("future")
[18:06:19.204]                           version <- ns[[".package"]][["version"]]
[18:06:19.204]                           if (is.null(version)) 
[18:06:19.204]                             version <- utils::packageVersion("future")
[18:06:19.204]                         }
[18:06:19.204]                         else {
[18:06:19.204]                           version <- NULL
[18:06:19.204]                         }
[18:06:19.204]                         if (!has_future || version < "1.8.0") {
[18:06:19.204]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:19.204]                             "", base::R.version$version.string), 
[18:06:19.204]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:19.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:19.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:19.204]                               "release", "version")], collapse = " "), 
[18:06:19.204]                             hostname = base::Sys.info()[["nodename"]])
[18:06:19.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:19.204]                             info)
[18:06:19.204]                           info <- base::paste(info, collapse = "; ")
[18:06:19.204]                           if (!has_future) {
[18:06:19.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:19.204]                               info)
[18:06:19.204]                           }
[18:06:19.204]                           else {
[18:06:19.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:19.204]                               info, version)
[18:06:19.204]                           }
[18:06:19.204]                           base::stop(msg)
[18:06:19.204]                         }
[18:06:19.204]                       })
[18:06:19.204]                     }
[18:06:19.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:19.204]                     base::options(mc.cores = 1L)
[18:06:19.204]                   }
[18:06:19.204]                   ...future.strategy.old <- future::plan("list")
[18:06:19.204]                   options(future.plan = NULL)
[18:06:19.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:19.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:19.204]                 }
[18:06:19.204]                 ...future.workdir <- getwd()
[18:06:19.204]             }
[18:06:19.204]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:19.204]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:19.204]         }
[18:06:19.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:19.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:19.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:19.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:19.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:19.204]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:19.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:19.204]             base::names(...future.oldOptions))
[18:06:19.204]     }
[18:06:19.204]     if (FALSE) {
[18:06:19.204]     }
[18:06:19.204]     else {
[18:06:19.204]         if (TRUE) {
[18:06:19.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:19.204]                 open = "w")
[18:06:19.204]         }
[18:06:19.204]         else {
[18:06:19.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:19.204]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:19.204]         }
[18:06:19.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:19.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:19.204]             base::sink(type = "output", split = FALSE)
[18:06:19.204]             base::close(...future.stdout)
[18:06:19.204]         }, add = TRUE)
[18:06:19.204]     }
[18:06:19.204]     ...future.frame <- base::sys.nframe()
[18:06:19.204]     ...future.conditions <- base::list()
[18:06:19.204]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:19.204]     if (FALSE) {
[18:06:19.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:19.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:19.204]     }
[18:06:19.204]     ...future.result <- base::tryCatch({
[18:06:19.204]         base::withCallingHandlers({
[18:06:19.204]             ...future.value <- base::withVisible(base::local({
[18:06:19.204]                 ...future.makeSendCondition <- base::local({
[18:06:19.204]                   sendCondition <- NULL
[18:06:19.204]                   function(frame = 1L) {
[18:06:19.204]                     if (is.function(sendCondition)) 
[18:06:19.204]                       return(sendCondition)
[18:06:19.204]                     ns <- getNamespace("parallel")
[18:06:19.204]                     if (exists("sendData", mode = "function", 
[18:06:19.204]                       envir = ns)) {
[18:06:19.204]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:19.204]                         envir = ns)
[18:06:19.204]                       envir <- sys.frame(frame)
[18:06:19.204]                       master <- NULL
[18:06:19.204]                       while (!identical(envir, .GlobalEnv) && 
[18:06:19.204]                         !identical(envir, emptyenv())) {
[18:06:19.204]                         if (exists("master", mode = "list", envir = envir, 
[18:06:19.204]                           inherits = FALSE)) {
[18:06:19.204]                           master <- get("master", mode = "list", 
[18:06:19.204]                             envir = envir, inherits = FALSE)
[18:06:19.204]                           if (inherits(master, c("SOCKnode", 
[18:06:19.204]                             "SOCK0node"))) {
[18:06:19.204]                             sendCondition <<- function(cond) {
[18:06:19.204]                               data <- list(type = "VALUE", value = cond, 
[18:06:19.204]                                 success = TRUE)
[18:06:19.204]                               parallel_sendData(master, data)
[18:06:19.204]                             }
[18:06:19.204]                             return(sendCondition)
[18:06:19.204]                           }
[18:06:19.204]                         }
[18:06:19.204]                         frame <- frame + 1L
[18:06:19.204]                         envir <- sys.frame(frame)
[18:06:19.204]                       }
[18:06:19.204]                     }
[18:06:19.204]                     sendCondition <<- function(cond) NULL
[18:06:19.204]                   }
[18:06:19.204]                 })
[18:06:19.204]                 withCallingHandlers({
[18:06:19.204]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:19.204]                 }, immediateCondition = function(cond) {
[18:06:19.204]                   sendCondition <- ...future.makeSendCondition()
[18:06:19.204]                   sendCondition(cond)
[18:06:19.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.204]                   {
[18:06:19.204]                     inherits <- base::inherits
[18:06:19.204]                     invokeRestart <- base::invokeRestart
[18:06:19.204]                     is.null <- base::is.null
[18:06:19.204]                     muffled <- FALSE
[18:06:19.204]                     if (inherits(cond, "message")) {
[18:06:19.204]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:19.204]                       if (muffled) 
[18:06:19.204]                         invokeRestart("muffleMessage")
[18:06:19.204]                     }
[18:06:19.204]                     else if (inherits(cond, "warning")) {
[18:06:19.204]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:19.204]                       if (muffled) 
[18:06:19.204]                         invokeRestart("muffleWarning")
[18:06:19.204]                     }
[18:06:19.204]                     else if (inherits(cond, "condition")) {
[18:06:19.204]                       if (!is.null(pattern)) {
[18:06:19.204]                         computeRestarts <- base::computeRestarts
[18:06:19.204]                         grepl <- base::grepl
[18:06:19.204]                         restarts <- computeRestarts(cond)
[18:06:19.204]                         for (restart in restarts) {
[18:06:19.204]                           name <- restart$name
[18:06:19.204]                           if (is.null(name)) 
[18:06:19.204]                             next
[18:06:19.204]                           if (!grepl(pattern, name)) 
[18:06:19.204]                             next
[18:06:19.204]                           invokeRestart(restart)
[18:06:19.204]                           muffled <- TRUE
[18:06:19.204]                           break
[18:06:19.204]                         }
[18:06:19.204]                       }
[18:06:19.204]                     }
[18:06:19.204]                     invisible(muffled)
[18:06:19.204]                   }
[18:06:19.204]                   muffleCondition(cond)
[18:06:19.204]                 })
[18:06:19.204]             }))
[18:06:19.204]             future::FutureResult(value = ...future.value$value, 
[18:06:19.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:19.204]                   ...future.rng), globalenv = if (FALSE) 
[18:06:19.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:19.204]                     ...future.globalenv.names))
[18:06:19.204]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:19.204]         }, condition = base::local({
[18:06:19.204]             c <- base::c
[18:06:19.204]             inherits <- base::inherits
[18:06:19.204]             invokeRestart <- base::invokeRestart
[18:06:19.204]             length <- base::length
[18:06:19.204]             list <- base::list
[18:06:19.204]             seq.int <- base::seq.int
[18:06:19.204]             signalCondition <- base::signalCondition
[18:06:19.204]             sys.calls <- base::sys.calls
[18:06:19.204]             `[[` <- base::`[[`
[18:06:19.204]             `+` <- base::`+`
[18:06:19.204]             `<<-` <- base::`<<-`
[18:06:19.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:19.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:19.204]                   3L)]
[18:06:19.204]             }
[18:06:19.204]             function(cond) {
[18:06:19.204]                 is_error <- inherits(cond, "error")
[18:06:19.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:19.204]                   NULL)
[18:06:19.204]                 if (is_error) {
[18:06:19.204]                   sessionInformation <- function() {
[18:06:19.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:19.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:19.204]                       search = base::search(), system = base::Sys.info())
[18:06:19.204]                   }
[18:06:19.204]                   ...future.conditions[[length(...future.conditions) + 
[18:06:19.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:19.204]                     cond$call), session = sessionInformation(), 
[18:06:19.204]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:19.204]                   signalCondition(cond)
[18:06:19.204]                 }
[18:06:19.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:19.204]                 "immediateCondition"))) {
[18:06:19.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:19.204]                   ...future.conditions[[length(...future.conditions) + 
[18:06:19.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:19.204]                   if (TRUE && !signal) {
[18:06:19.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.204]                     {
[18:06:19.204]                       inherits <- base::inherits
[18:06:19.204]                       invokeRestart <- base::invokeRestart
[18:06:19.204]                       is.null <- base::is.null
[18:06:19.204]                       muffled <- FALSE
[18:06:19.204]                       if (inherits(cond, "message")) {
[18:06:19.204]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:19.204]                         if (muffled) 
[18:06:19.204]                           invokeRestart("muffleMessage")
[18:06:19.204]                       }
[18:06:19.204]                       else if (inherits(cond, "warning")) {
[18:06:19.204]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:19.204]                         if (muffled) 
[18:06:19.204]                           invokeRestart("muffleWarning")
[18:06:19.204]                       }
[18:06:19.204]                       else if (inherits(cond, "condition")) {
[18:06:19.204]                         if (!is.null(pattern)) {
[18:06:19.204]                           computeRestarts <- base::computeRestarts
[18:06:19.204]                           grepl <- base::grepl
[18:06:19.204]                           restarts <- computeRestarts(cond)
[18:06:19.204]                           for (restart in restarts) {
[18:06:19.204]                             name <- restart$name
[18:06:19.204]                             if (is.null(name)) 
[18:06:19.204]                               next
[18:06:19.204]                             if (!grepl(pattern, name)) 
[18:06:19.204]                               next
[18:06:19.204]                             invokeRestart(restart)
[18:06:19.204]                             muffled <- TRUE
[18:06:19.204]                             break
[18:06:19.204]                           }
[18:06:19.204]                         }
[18:06:19.204]                       }
[18:06:19.204]                       invisible(muffled)
[18:06:19.204]                     }
[18:06:19.204]                     muffleCondition(cond, pattern = "^muffle")
[18:06:19.204]                   }
[18:06:19.204]                 }
[18:06:19.204]                 else {
[18:06:19.204]                   if (TRUE) {
[18:06:19.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.204]                     {
[18:06:19.204]                       inherits <- base::inherits
[18:06:19.204]                       invokeRestart <- base::invokeRestart
[18:06:19.204]                       is.null <- base::is.null
[18:06:19.204]                       muffled <- FALSE
[18:06:19.204]                       if (inherits(cond, "message")) {
[18:06:19.204]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:19.204]                         if (muffled) 
[18:06:19.204]                           invokeRestart("muffleMessage")
[18:06:19.204]                       }
[18:06:19.204]                       else if (inherits(cond, "warning")) {
[18:06:19.204]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:19.204]                         if (muffled) 
[18:06:19.204]                           invokeRestart("muffleWarning")
[18:06:19.204]                       }
[18:06:19.204]                       else if (inherits(cond, "condition")) {
[18:06:19.204]                         if (!is.null(pattern)) {
[18:06:19.204]                           computeRestarts <- base::computeRestarts
[18:06:19.204]                           grepl <- base::grepl
[18:06:19.204]                           restarts <- computeRestarts(cond)
[18:06:19.204]                           for (restart in restarts) {
[18:06:19.204]                             name <- restart$name
[18:06:19.204]                             if (is.null(name)) 
[18:06:19.204]                               next
[18:06:19.204]                             if (!grepl(pattern, name)) 
[18:06:19.204]                               next
[18:06:19.204]                             invokeRestart(restart)
[18:06:19.204]                             muffled <- TRUE
[18:06:19.204]                             break
[18:06:19.204]                           }
[18:06:19.204]                         }
[18:06:19.204]                       }
[18:06:19.204]                       invisible(muffled)
[18:06:19.204]                     }
[18:06:19.204]                     muffleCondition(cond, pattern = "^muffle")
[18:06:19.204]                   }
[18:06:19.204]                 }
[18:06:19.204]             }
[18:06:19.204]         }))
[18:06:19.204]     }, error = function(ex) {
[18:06:19.204]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:19.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:19.204]                 ...future.rng), started = ...future.startTime, 
[18:06:19.204]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:19.204]             version = "1.8"), class = "FutureResult")
[18:06:19.204]     }, finally = {
[18:06:19.204]         if (!identical(...future.workdir, getwd())) 
[18:06:19.204]             setwd(...future.workdir)
[18:06:19.204]         {
[18:06:19.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:19.204]                 ...future.oldOptions$nwarnings <- NULL
[18:06:19.204]             }
[18:06:19.204]             base::options(...future.oldOptions)
[18:06:19.204]             if (.Platform$OS.type == "windows") {
[18:06:19.204]                 old_names <- names(...future.oldEnvVars)
[18:06:19.204]                 envs <- base::Sys.getenv()
[18:06:19.204]                 names <- names(envs)
[18:06:19.204]                 common <- intersect(names, old_names)
[18:06:19.204]                 added <- setdiff(names, old_names)
[18:06:19.204]                 removed <- setdiff(old_names, names)
[18:06:19.204]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:19.204]                   envs[common]]
[18:06:19.204]                 NAMES <- toupper(changed)
[18:06:19.204]                 args <- list()
[18:06:19.204]                 for (kk in seq_along(NAMES)) {
[18:06:19.204]                   name <- changed[[kk]]
[18:06:19.204]                   NAME <- NAMES[[kk]]
[18:06:19.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.204]                     next
[18:06:19.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:19.204]                 }
[18:06:19.204]                 NAMES <- toupper(added)
[18:06:19.204]                 for (kk in seq_along(NAMES)) {
[18:06:19.204]                   name <- added[[kk]]
[18:06:19.204]                   NAME <- NAMES[[kk]]
[18:06:19.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.204]                     next
[18:06:19.204]                   args[[name]] <- ""
[18:06:19.204]                 }
[18:06:19.204]                 NAMES <- toupper(removed)
[18:06:19.204]                 for (kk in seq_along(NAMES)) {
[18:06:19.204]                   name <- removed[[kk]]
[18:06:19.204]                   NAME <- NAMES[[kk]]
[18:06:19.204]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.204]                     next
[18:06:19.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:19.204]                 }
[18:06:19.204]                 if (length(args) > 0) 
[18:06:19.204]                   base::do.call(base::Sys.setenv, args = args)
[18:06:19.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:19.204]             }
[18:06:19.204]             else {
[18:06:19.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:19.204]             }
[18:06:19.204]             {
[18:06:19.204]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:19.204]                   0L) {
[18:06:19.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:19.204]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:19.204]                   base::options(opts)
[18:06:19.204]                 }
[18:06:19.204]                 {
[18:06:19.204]                   {
[18:06:19.204]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:19.204]                     NULL
[18:06:19.204]                   }
[18:06:19.204]                   options(future.plan = NULL)
[18:06:19.204]                   if (is.na(NA_character_)) 
[18:06:19.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:19.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:19.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:19.204]                     .init = FALSE)
[18:06:19.204]                 }
[18:06:19.204]             }
[18:06:19.204]         }
[18:06:19.204]     })
[18:06:19.204]     if (TRUE) {
[18:06:19.204]         base::sink(type = "output", split = FALSE)
[18:06:19.204]         if (TRUE) {
[18:06:19.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:19.204]         }
[18:06:19.204]         else {
[18:06:19.204]             ...future.result["stdout"] <- base::list(NULL)
[18:06:19.204]         }
[18:06:19.204]         base::close(...future.stdout)
[18:06:19.204]         ...future.stdout <- NULL
[18:06:19.204]     }
[18:06:19.204]     ...future.result$conditions <- ...future.conditions
[18:06:19.204]     ...future.result$finished <- base::Sys.time()
[18:06:19.204]     ...future.result
[18:06:19.204] }
[18:06:19.211] MultisessionFuture started
[18:06:19.211] - Launch lazy future ... done
[18:06:19.212] run() for ‘MultisessionFuture’ ... done
[18:06:19.257] receiveMessageFromWorker() for ClusterFuture ...
[18:06:19.258] - Validating connection of MultisessionFuture
[18:06:19.259] - received message: FutureResult
[18:06:19.259] - Received FutureResult
[18:06:19.260] - Erased future from FutureRegistry
[18:06:19.260] result() for ClusterFuture ...
[18:06:19.260] - result already collected: FutureResult
[18:06:19.261] result() for ClusterFuture ... done
[18:06:19.261] signalConditions() ...
[18:06:19.261]  - include = ‘immediateCondition’
[18:06:19.262]  - exclude = 
[18:06:19.262]  - resignal = FALSE
[18:06:19.262]  - Number of conditions: 1
[18:06:19.262] signalConditions() ... done
[18:06:19.263] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:19.263] A MultisessionFuture was resolved (result was not collected)
[18:06:19.263] getGlobalsAndPackages() ...
[18:06:19.264] Searching for globals...
[18:06:19.266] - globals found: [2] ‘list’, ‘stop’
[18:06:19.266] Searching for globals ... DONE
[18:06:19.267] Resolving globals: FALSE
[18:06:19.268] 
[18:06:19.268] 
[18:06:19.268] getGlobalsAndPackages() ... DONE
[18:06:19.269] run() for ‘Future’ ...
[18:06:19.269] - state: ‘created’
[18:06:19.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:19.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:19.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:19.296]   - Field: ‘node’
[18:06:19.296]   - Field: ‘label’
[18:06:19.296]   - Field: ‘local’
[18:06:19.296]   - Field: ‘owner’
[18:06:19.297]   - Field: ‘envir’
[18:06:19.297]   - Field: ‘workers’
[18:06:19.297]   - Field: ‘packages’
[18:06:19.297]   - Field: ‘gc’
[18:06:19.297]   - Field: ‘conditions’
[18:06:19.298]   - Field: ‘persistent’
[18:06:19.298]   - Field: ‘expr’
[18:06:19.298]   - Field: ‘uuid’
[18:06:19.298]   - Field: ‘seed’
[18:06:19.298]   - Field: ‘version’
[18:06:19.299]   - Field: ‘result’
[18:06:19.299]   - Field: ‘asynchronous’
[18:06:19.299]   - Field: ‘calls’
[18:06:19.299]   - Field: ‘globals’
[18:06:19.299]   - Field: ‘stdout’
[18:06:19.300]   - Field: ‘earlySignal’
[18:06:19.300]   - Field: ‘lazy’
[18:06:19.300]   - Field: ‘state’
[18:06:19.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:19.300] - Launch lazy future ...
[18:06:19.301] Packages needed by the future expression (n = 0): <none>
[18:06:19.301] Packages needed by future strategies (n = 0): <none>
[18:06:19.302] {
[18:06:19.302]     {
[18:06:19.302]         {
[18:06:19.302]             ...future.startTime <- base::Sys.time()
[18:06:19.302]             {
[18:06:19.302]                 {
[18:06:19.302]                   {
[18:06:19.302]                     {
[18:06:19.302]                       base::local({
[18:06:19.302]                         has_future <- base::requireNamespace("future", 
[18:06:19.302]                           quietly = TRUE)
[18:06:19.302]                         if (has_future) {
[18:06:19.302]                           ns <- base::getNamespace("future")
[18:06:19.302]                           version <- ns[[".package"]][["version"]]
[18:06:19.302]                           if (is.null(version)) 
[18:06:19.302]                             version <- utils::packageVersion("future")
[18:06:19.302]                         }
[18:06:19.302]                         else {
[18:06:19.302]                           version <- NULL
[18:06:19.302]                         }
[18:06:19.302]                         if (!has_future || version < "1.8.0") {
[18:06:19.302]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:19.302]                             "", base::R.version$version.string), 
[18:06:19.302]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:19.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:19.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:19.302]                               "release", "version")], collapse = " "), 
[18:06:19.302]                             hostname = base::Sys.info()[["nodename"]])
[18:06:19.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:19.302]                             info)
[18:06:19.302]                           info <- base::paste(info, collapse = "; ")
[18:06:19.302]                           if (!has_future) {
[18:06:19.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:19.302]                               info)
[18:06:19.302]                           }
[18:06:19.302]                           else {
[18:06:19.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:19.302]                               info, version)
[18:06:19.302]                           }
[18:06:19.302]                           base::stop(msg)
[18:06:19.302]                         }
[18:06:19.302]                       })
[18:06:19.302]                     }
[18:06:19.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:19.302]                     base::options(mc.cores = 1L)
[18:06:19.302]                   }
[18:06:19.302]                   ...future.strategy.old <- future::plan("list")
[18:06:19.302]                   options(future.plan = NULL)
[18:06:19.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:19.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:19.302]                 }
[18:06:19.302]                 ...future.workdir <- getwd()
[18:06:19.302]             }
[18:06:19.302]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:19.302]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:19.302]         }
[18:06:19.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:19.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:19.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:19.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:19.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:19.302]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:19.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:19.302]             base::names(...future.oldOptions))
[18:06:19.302]     }
[18:06:19.302]     if (FALSE) {
[18:06:19.302]     }
[18:06:19.302]     else {
[18:06:19.302]         if (TRUE) {
[18:06:19.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:19.302]                 open = "w")
[18:06:19.302]         }
[18:06:19.302]         else {
[18:06:19.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:19.302]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:19.302]         }
[18:06:19.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:19.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:19.302]             base::sink(type = "output", split = FALSE)
[18:06:19.302]             base::close(...future.stdout)
[18:06:19.302]         }, add = TRUE)
[18:06:19.302]     }
[18:06:19.302]     ...future.frame <- base::sys.nframe()
[18:06:19.302]     ...future.conditions <- base::list()
[18:06:19.302]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:19.302]     if (FALSE) {
[18:06:19.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:19.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:19.302]     }
[18:06:19.302]     ...future.result <- base::tryCatch({
[18:06:19.302]         base::withCallingHandlers({
[18:06:19.302]             ...future.value <- base::withVisible(base::local({
[18:06:19.302]                 ...future.makeSendCondition <- base::local({
[18:06:19.302]                   sendCondition <- NULL
[18:06:19.302]                   function(frame = 1L) {
[18:06:19.302]                     if (is.function(sendCondition)) 
[18:06:19.302]                       return(sendCondition)
[18:06:19.302]                     ns <- getNamespace("parallel")
[18:06:19.302]                     if (exists("sendData", mode = "function", 
[18:06:19.302]                       envir = ns)) {
[18:06:19.302]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:19.302]                         envir = ns)
[18:06:19.302]                       envir <- sys.frame(frame)
[18:06:19.302]                       master <- NULL
[18:06:19.302]                       while (!identical(envir, .GlobalEnv) && 
[18:06:19.302]                         !identical(envir, emptyenv())) {
[18:06:19.302]                         if (exists("master", mode = "list", envir = envir, 
[18:06:19.302]                           inherits = FALSE)) {
[18:06:19.302]                           master <- get("master", mode = "list", 
[18:06:19.302]                             envir = envir, inherits = FALSE)
[18:06:19.302]                           if (inherits(master, c("SOCKnode", 
[18:06:19.302]                             "SOCK0node"))) {
[18:06:19.302]                             sendCondition <<- function(cond) {
[18:06:19.302]                               data <- list(type = "VALUE", value = cond, 
[18:06:19.302]                                 success = TRUE)
[18:06:19.302]                               parallel_sendData(master, data)
[18:06:19.302]                             }
[18:06:19.302]                             return(sendCondition)
[18:06:19.302]                           }
[18:06:19.302]                         }
[18:06:19.302]                         frame <- frame + 1L
[18:06:19.302]                         envir <- sys.frame(frame)
[18:06:19.302]                       }
[18:06:19.302]                     }
[18:06:19.302]                     sendCondition <<- function(cond) NULL
[18:06:19.302]                   }
[18:06:19.302]                 })
[18:06:19.302]                 withCallingHandlers({
[18:06:19.302]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:19.302]                 }, immediateCondition = function(cond) {
[18:06:19.302]                   sendCondition <- ...future.makeSendCondition()
[18:06:19.302]                   sendCondition(cond)
[18:06:19.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.302]                   {
[18:06:19.302]                     inherits <- base::inherits
[18:06:19.302]                     invokeRestart <- base::invokeRestart
[18:06:19.302]                     is.null <- base::is.null
[18:06:19.302]                     muffled <- FALSE
[18:06:19.302]                     if (inherits(cond, "message")) {
[18:06:19.302]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:19.302]                       if (muffled) 
[18:06:19.302]                         invokeRestart("muffleMessage")
[18:06:19.302]                     }
[18:06:19.302]                     else if (inherits(cond, "warning")) {
[18:06:19.302]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:19.302]                       if (muffled) 
[18:06:19.302]                         invokeRestart("muffleWarning")
[18:06:19.302]                     }
[18:06:19.302]                     else if (inherits(cond, "condition")) {
[18:06:19.302]                       if (!is.null(pattern)) {
[18:06:19.302]                         computeRestarts <- base::computeRestarts
[18:06:19.302]                         grepl <- base::grepl
[18:06:19.302]                         restarts <- computeRestarts(cond)
[18:06:19.302]                         for (restart in restarts) {
[18:06:19.302]                           name <- restart$name
[18:06:19.302]                           if (is.null(name)) 
[18:06:19.302]                             next
[18:06:19.302]                           if (!grepl(pattern, name)) 
[18:06:19.302]                             next
[18:06:19.302]                           invokeRestart(restart)
[18:06:19.302]                           muffled <- TRUE
[18:06:19.302]                           break
[18:06:19.302]                         }
[18:06:19.302]                       }
[18:06:19.302]                     }
[18:06:19.302]                     invisible(muffled)
[18:06:19.302]                   }
[18:06:19.302]                   muffleCondition(cond)
[18:06:19.302]                 })
[18:06:19.302]             }))
[18:06:19.302]             future::FutureResult(value = ...future.value$value, 
[18:06:19.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:19.302]                   ...future.rng), globalenv = if (FALSE) 
[18:06:19.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:19.302]                     ...future.globalenv.names))
[18:06:19.302]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:19.302]         }, condition = base::local({
[18:06:19.302]             c <- base::c
[18:06:19.302]             inherits <- base::inherits
[18:06:19.302]             invokeRestart <- base::invokeRestart
[18:06:19.302]             length <- base::length
[18:06:19.302]             list <- base::list
[18:06:19.302]             seq.int <- base::seq.int
[18:06:19.302]             signalCondition <- base::signalCondition
[18:06:19.302]             sys.calls <- base::sys.calls
[18:06:19.302]             `[[` <- base::`[[`
[18:06:19.302]             `+` <- base::`+`
[18:06:19.302]             `<<-` <- base::`<<-`
[18:06:19.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:19.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:19.302]                   3L)]
[18:06:19.302]             }
[18:06:19.302]             function(cond) {
[18:06:19.302]                 is_error <- inherits(cond, "error")
[18:06:19.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:19.302]                   NULL)
[18:06:19.302]                 if (is_error) {
[18:06:19.302]                   sessionInformation <- function() {
[18:06:19.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:19.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:19.302]                       search = base::search(), system = base::Sys.info())
[18:06:19.302]                   }
[18:06:19.302]                   ...future.conditions[[length(...future.conditions) + 
[18:06:19.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:19.302]                     cond$call), session = sessionInformation(), 
[18:06:19.302]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:19.302]                   signalCondition(cond)
[18:06:19.302]                 }
[18:06:19.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:19.302]                 "immediateCondition"))) {
[18:06:19.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:19.302]                   ...future.conditions[[length(...future.conditions) + 
[18:06:19.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:19.302]                   if (TRUE && !signal) {
[18:06:19.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.302]                     {
[18:06:19.302]                       inherits <- base::inherits
[18:06:19.302]                       invokeRestart <- base::invokeRestart
[18:06:19.302]                       is.null <- base::is.null
[18:06:19.302]                       muffled <- FALSE
[18:06:19.302]                       if (inherits(cond, "message")) {
[18:06:19.302]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:19.302]                         if (muffled) 
[18:06:19.302]                           invokeRestart("muffleMessage")
[18:06:19.302]                       }
[18:06:19.302]                       else if (inherits(cond, "warning")) {
[18:06:19.302]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:19.302]                         if (muffled) 
[18:06:19.302]                           invokeRestart("muffleWarning")
[18:06:19.302]                       }
[18:06:19.302]                       else if (inherits(cond, "condition")) {
[18:06:19.302]                         if (!is.null(pattern)) {
[18:06:19.302]                           computeRestarts <- base::computeRestarts
[18:06:19.302]                           grepl <- base::grepl
[18:06:19.302]                           restarts <- computeRestarts(cond)
[18:06:19.302]                           for (restart in restarts) {
[18:06:19.302]                             name <- restart$name
[18:06:19.302]                             if (is.null(name)) 
[18:06:19.302]                               next
[18:06:19.302]                             if (!grepl(pattern, name)) 
[18:06:19.302]                               next
[18:06:19.302]                             invokeRestart(restart)
[18:06:19.302]                             muffled <- TRUE
[18:06:19.302]                             break
[18:06:19.302]                           }
[18:06:19.302]                         }
[18:06:19.302]                       }
[18:06:19.302]                       invisible(muffled)
[18:06:19.302]                     }
[18:06:19.302]                     muffleCondition(cond, pattern = "^muffle")
[18:06:19.302]                   }
[18:06:19.302]                 }
[18:06:19.302]                 else {
[18:06:19.302]                   if (TRUE) {
[18:06:19.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.302]                     {
[18:06:19.302]                       inherits <- base::inherits
[18:06:19.302]                       invokeRestart <- base::invokeRestart
[18:06:19.302]                       is.null <- base::is.null
[18:06:19.302]                       muffled <- FALSE
[18:06:19.302]                       if (inherits(cond, "message")) {
[18:06:19.302]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:19.302]                         if (muffled) 
[18:06:19.302]                           invokeRestart("muffleMessage")
[18:06:19.302]                       }
[18:06:19.302]                       else if (inherits(cond, "warning")) {
[18:06:19.302]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:19.302]                         if (muffled) 
[18:06:19.302]                           invokeRestart("muffleWarning")
[18:06:19.302]                       }
[18:06:19.302]                       else if (inherits(cond, "condition")) {
[18:06:19.302]                         if (!is.null(pattern)) {
[18:06:19.302]                           computeRestarts <- base::computeRestarts
[18:06:19.302]                           grepl <- base::grepl
[18:06:19.302]                           restarts <- computeRestarts(cond)
[18:06:19.302]                           for (restart in restarts) {
[18:06:19.302]                             name <- restart$name
[18:06:19.302]                             if (is.null(name)) 
[18:06:19.302]                               next
[18:06:19.302]                             if (!grepl(pattern, name)) 
[18:06:19.302]                               next
[18:06:19.302]                             invokeRestart(restart)
[18:06:19.302]                             muffled <- TRUE
[18:06:19.302]                             break
[18:06:19.302]                           }
[18:06:19.302]                         }
[18:06:19.302]                       }
[18:06:19.302]                       invisible(muffled)
[18:06:19.302]                     }
[18:06:19.302]                     muffleCondition(cond, pattern = "^muffle")
[18:06:19.302]                   }
[18:06:19.302]                 }
[18:06:19.302]             }
[18:06:19.302]         }))
[18:06:19.302]     }, error = function(ex) {
[18:06:19.302]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:19.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:19.302]                 ...future.rng), started = ...future.startTime, 
[18:06:19.302]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:19.302]             version = "1.8"), class = "FutureResult")
[18:06:19.302]     }, finally = {
[18:06:19.302]         if (!identical(...future.workdir, getwd())) 
[18:06:19.302]             setwd(...future.workdir)
[18:06:19.302]         {
[18:06:19.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:19.302]                 ...future.oldOptions$nwarnings <- NULL
[18:06:19.302]             }
[18:06:19.302]             base::options(...future.oldOptions)
[18:06:19.302]             if (.Platform$OS.type == "windows") {
[18:06:19.302]                 old_names <- names(...future.oldEnvVars)
[18:06:19.302]                 envs <- base::Sys.getenv()
[18:06:19.302]                 names <- names(envs)
[18:06:19.302]                 common <- intersect(names, old_names)
[18:06:19.302]                 added <- setdiff(names, old_names)
[18:06:19.302]                 removed <- setdiff(old_names, names)
[18:06:19.302]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:19.302]                   envs[common]]
[18:06:19.302]                 NAMES <- toupper(changed)
[18:06:19.302]                 args <- list()
[18:06:19.302]                 for (kk in seq_along(NAMES)) {
[18:06:19.302]                   name <- changed[[kk]]
[18:06:19.302]                   NAME <- NAMES[[kk]]
[18:06:19.302]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.302]                     next
[18:06:19.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:19.302]                 }
[18:06:19.302]                 NAMES <- toupper(added)
[18:06:19.302]                 for (kk in seq_along(NAMES)) {
[18:06:19.302]                   name <- added[[kk]]
[18:06:19.302]                   NAME <- NAMES[[kk]]
[18:06:19.302]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.302]                     next
[18:06:19.302]                   args[[name]] <- ""
[18:06:19.302]                 }
[18:06:19.302]                 NAMES <- toupper(removed)
[18:06:19.302]                 for (kk in seq_along(NAMES)) {
[18:06:19.302]                   name <- removed[[kk]]
[18:06:19.302]                   NAME <- NAMES[[kk]]
[18:06:19.302]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.302]                     next
[18:06:19.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:19.302]                 }
[18:06:19.302]                 if (length(args) > 0) 
[18:06:19.302]                   base::do.call(base::Sys.setenv, args = args)
[18:06:19.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:19.302]             }
[18:06:19.302]             else {
[18:06:19.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:19.302]             }
[18:06:19.302]             {
[18:06:19.302]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:19.302]                   0L) {
[18:06:19.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:19.302]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:19.302]                   base::options(opts)
[18:06:19.302]                 }
[18:06:19.302]                 {
[18:06:19.302]                   {
[18:06:19.302]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:19.302]                     NULL
[18:06:19.302]                   }
[18:06:19.302]                   options(future.plan = NULL)
[18:06:19.302]                   if (is.na(NA_character_)) 
[18:06:19.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:19.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:19.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:19.302]                     .init = FALSE)
[18:06:19.302]                 }
[18:06:19.302]             }
[18:06:19.302]         }
[18:06:19.302]     })
[18:06:19.302]     if (TRUE) {
[18:06:19.302]         base::sink(type = "output", split = FALSE)
[18:06:19.302]         if (TRUE) {
[18:06:19.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:19.302]         }
[18:06:19.302]         else {
[18:06:19.302]             ...future.result["stdout"] <- base::list(NULL)
[18:06:19.302]         }
[18:06:19.302]         base::close(...future.stdout)
[18:06:19.302]         ...future.stdout <- NULL
[18:06:19.302]     }
[18:06:19.302]     ...future.result$conditions <- ...future.conditions
[18:06:19.302]     ...future.result$finished <- base::Sys.time()
[18:06:19.302]     ...future.result
[18:06:19.302] }
[18:06:19.308] MultisessionFuture started
[18:06:19.308] - Launch lazy future ... done
[18:06:19.308] run() for ‘MultisessionFuture’ ... done
[18:06:19.352] receiveMessageFromWorker() for ClusterFuture ...
[18:06:19.352] - Validating connection of MultisessionFuture
[18:06:19.353] - received message: FutureResult
[18:06:19.353] - Received FutureResult
[18:06:19.353] - Erased future from FutureRegistry
[18:06:19.354] result() for ClusterFuture ...
[18:06:19.354] - result already collected: FutureResult
[18:06:19.354] result() for ClusterFuture ... done
[18:06:19.354] signalConditions() ...
[18:06:19.354]  - include = ‘immediateCondition’
[18:06:19.355]  - exclude = 
[18:06:19.355]  - resignal = FALSE
[18:06:19.355]  - Number of conditions: 1
[18:06:19.355] signalConditions() ... done
[18:06:19.355] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:19.356] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[18:06:19.356] getGlobalsAndPackages() ...
[18:06:19.356] Searching for globals...
[18:06:19.358] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:19.359] Searching for globals ... DONE
[18:06:19.359] Resolving globals: FALSE
[18:06:19.359] 
[18:06:19.360] 
[18:06:19.360] getGlobalsAndPackages() ... DONE
[18:06:19.360] run() for ‘Future’ ...
[18:06:19.361] - state: ‘created’
[18:06:19.361] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:19.387] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:19.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:19.387]   - Field: ‘node’
[18:06:19.388]   - Field: ‘label’
[18:06:19.388]   - Field: ‘local’
[18:06:19.388]   - Field: ‘owner’
[18:06:19.388]   - Field: ‘envir’
[18:06:19.388]   - Field: ‘workers’
[18:06:19.389]   - Field: ‘packages’
[18:06:19.389]   - Field: ‘gc’
[18:06:19.389]   - Field: ‘conditions’
[18:06:19.389]   - Field: ‘persistent’
[18:06:19.389]   - Field: ‘expr’
[18:06:19.390]   - Field: ‘uuid’
[18:06:19.390]   - Field: ‘seed’
[18:06:19.390]   - Field: ‘version’
[18:06:19.390]   - Field: ‘result’
[18:06:19.390]   - Field: ‘asynchronous’
[18:06:19.391]   - Field: ‘calls’
[18:06:19.391]   - Field: ‘globals’
[18:06:19.391]   - Field: ‘stdout’
[18:06:19.391]   - Field: ‘earlySignal’
[18:06:19.391]   - Field: ‘lazy’
[18:06:19.392]   - Field: ‘state’
[18:06:19.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:19.392] - Launch lazy future ...
[18:06:19.393] Packages needed by the future expression (n = 0): <none>
[18:06:19.393] Packages needed by future strategies (n = 0): <none>
[18:06:19.394] {
[18:06:19.394]     {
[18:06:19.394]         {
[18:06:19.394]             ...future.startTime <- base::Sys.time()
[18:06:19.394]             {
[18:06:19.394]                 {
[18:06:19.394]                   {
[18:06:19.394]                     {
[18:06:19.394]                       base::local({
[18:06:19.394]                         has_future <- base::requireNamespace("future", 
[18:06:19.394]                           quietly = TRUE)
[18:06:19.394]                         if (has_future) {
[18:06:19.394]                           ns <- base::getNamespace("future")
[18:06:19.394]                           version <- ns[[".package"]][["version"]]
[18:06:19.394]                           if (is.null(version)) 
[18:06:19.394]                             version <- utils::packageVersion("future")
[18:06:19.394]                         }
[18:06:19.394]                         else {
[18:06:19.394]                           version <- NULL
[18:06:19.394]                         }
[18:06:19.394]                         if (!has_future || version < "1.8.0") {
[18:06:19.394]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:19.394]                             "", base::R.version$version.string), 
[18:06:19.394]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:19.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:19.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:19.394]                               "release", "version")], collapse = " "), 
[18:06:19.394]                             hostname = base::Sys.info()[["nodename"]])
[18:06:19.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:19.394]                             info)
[18:06:19.394]                           info <- base::paste(info, collapse = "; ")
[18:06:19.394]                           if (!has_future) {
[18:06:19.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:19.394]                               info)
[18:06:19.394]                           }
[18:06:19.394]                           else {
[18:06:19.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:19.394]                               info, version)
[18:06:19.394]                           }
[18:06:19.394]                           base::stop(msg)
[18:06:19.394]                         }
[18:06:19.394]                       })
[18:06:19.394]                     }
[18:06:19.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:19.394]                     base::options(mc.cores = 1L)
[18:06:19.394]                   }
[18:06:19.394]                   ...future.strategy.old <- future::plan("list")
[18:06:19.394]                   options(future.plan = NULL)
[18:06:19.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:19.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:19.394]                 }
[18:06:19.394]                 ...future.workdir <- getwd()
[18:06:19.394]             }
[18:06:19.394]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:19.394]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:19.394]         }
[18:06:19.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:19.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:19.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:19.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:19.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:19.394]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:19.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:19.394]             base::names(...future.oldOptions))
[18:06:19.394]     }
[18:06:19.394]     if (FALSE) {
[18:06:19.394]     }
[18:06:19.394]     else {
[18:06:19.394]         if (TRUE) {
[18:06:19.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:19.394]                 open = "w")
[18:06:19.394]         }
[18:06:19.394]         else {
[18:06:19.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:19.394]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:19.394]         }
[18:06:19.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:19.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:19.394]             base::sink(type = "output", split = FALSE)
[18:06:19.394]             base::close(...future.stdout)
[18:06:19.394]         }, add = TRUE)
[18:06:19.394]     }
[18:06:19.394]     ...future.frame <- base::sys.nframe()
[18:06:19.394]     ...future.conditions <- base::list()
[18:06:19.394]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:19.394]     if (FALSE) {
[18:06:19.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:19.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:19.394]     }
[18:06:19.394]     ...future.result <- base::tryCatch({
[18:06:19.394]         base::withCallingHandlers({
[18:06:19.394]             ...future.value <- base::withVisible(base::local({
[18:06:19.394]                 ...future.makeSendCondition <- base::local({
[18:06:19.394]                   sendCondition <- NULL
[18:06:19.394]                   function(frame = 1L) {
[18:06:19.394]                     if (is.function(sendCondition)) 
[18:06:19.394]                       return(sendCondition)
[18:06:19.394]                     ns <- getNamespace("parallel")
[18:06:19.394]                     if (exists("sendData", mode = "function", 
[18:06:19.394]                       envir = ns)) {
[18:06:19.394]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:19.394]                         envir = ns)
[18:06:19.394]                       envir <- sys.frame(frame)
[18:06:19.394]                       master <- NULL
[18:06:19.394]                       while (!identical(envir, .GlobalEnv) && 
[18:06:19.394]                         !identical(envir, emptyenv())) {
[18:06:19.394]                         if (exists("master", mode = "list", envir = envir, 
[18:06:19.394]                           inherits = FALSE)) {
[18:06:19.394]                           master <- get("master", mode = "list", 
[18:06:19.394]                             envir = envir, inherits = FALSE)
[18:06:19.394]                           if (inherits(master, c("SOCKnode", 
[18:06:19.394]                             "SOCK0node"))) {
[18:06:19.394]                             sendCondition <<- function(cond) {
[18:06:19.394]                               data <- list(type = "VALUE", value = cond, 
[18:06:19.394]                                 success = TRUE)
[18:06:19.394]                               parallel_sendData(master, data)
[18:06:19.394]                             }
[18:06:19.394]                             return(sendCondition)
[18:06:19.394]                           }
[18:06:19.394]                         }
[18:06:19.394]                         frame <- frame + 1L
[18:06:19.394]                         envir <- sys.frame(frame)
[18:06:19.394]                       }
[18:06:19.394]                     }
[18:06:19.394]                     sendCondition <<- function(cond) NULL
[18:06:19.394]                   }
[18:06:19.394]                 })
[18:06:19.394]                 withCallingHandlers({
[18:06:19.394]                   {
[18:06:19.394]                     Sys.sleep(0.5)
[18:06:19.394]                     list(a = 1, b = 42L)
[18:06:19.394]                   }
[18:06:19.394]                 }, immediateCondition = function(cond) {
[18:06:19.394]                   sendCondition <- ...future.makeSendCondition()
[18:06:19.394]                   sendCondition(cond)
[18:06:19.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.394]                   {
[18:06:19.394]                     inherits <- base::inherits
[18:06:19.394]                     invokeRestart <- base::invokeRestart
[18:06:19.394]                     is.null <- base::is.null
[18:06:19.394]                     muffled <- FALSE
[18:06:19.394]                     if (inherits(cond, "message")) {
[18:06:19.394]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:19.394]                       if (muffled) 
[18:06:19.394]                         invokeRestart("muffleMessage")
[18:06:19.394]                     }
[18:06:19.394]                     else if (inherits(cond, "warning")) {
[18:06:19.394]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:19.394]                       if (muffled) 
[18:06:19.394]                         invokeRestart("muffleWarning")
[18:06:19.394]                     }
[18:06:19.394]                     else if (inherits(cond, "condition")) {
[18:06:19.394]                       if (!is.null(pattern)) {
[18:06:19.394]                         computeRestarts <- base::computeRestarts
[18:06:19.394]                         grepl <- base::grepl
[18:06:19.394]                         restarts <- computeRestarts(cond)
[18:06:19.394]                         for (restart in restarts) {
[18:06:19.394]                           name <- restart$name
[18:06:19.394]                           if (is.null(name)) 
[18:06:19.394]                             next
[18:06:19.394]                           if (!grepl(pattern, name)) 
[18:06:19.394]                             next
[18:06:19.394]                           invokeRestart(restart)
[18:06:19.394]                           muffled <- TRUE
[18:06:19.394]                           break
[18:06:19.394]                         }
[18:06:19.394]                       }
[18:06:19.394]                     }
[18:06:19.394]                     invisible(muffled)
[18:06:19.394]                   }
[18:06:19.394]                   muffleCondition(cond)
[18:06:19.394]                 })
[18:06:19.394]             }))
[18:06:19.394]             future::FutureResult(value = ...future.value$value, 
[18:06:19.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:19.394]                   ...future.rng), globalenv = if (FALSE) 
[18:06:19.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:19.394]                     ...future.globalenv.names))
[18:06:19.394]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:19.394]         }, condition = base::local({
[18:06:19.394]             c <- base::c
[18:06:19.394]             inherits <- base::inherits
[18:06:19.394]             invokeRestart <- base::invokeRestart
[18:06:19.394]             length <- base::length
[18:06:19.394]             list <- base::list
[18:06:19.394]             seq.int <- base::seq.int
[18:06:19.394]             signalCondition <- base::signalCondition
[18:06:19.394]             sys.calls <- base::sys.calls
[18:06:19.394]             `[[` <- base::`[[`
[18:06:19.394]             `+` <- base::`+`
[18:06:19.394]             `<<-` <- base::`<<-`
[18:06:19.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:19.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:19.394]                   3L)]
[18:06:19.394]             }
[18:06:19.394]             function(cond) {
[18:06:19.394]                 is_error <- inherits(cond, "error")
[18:06:19.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:19.394]                   NULL)
[18:06:19.394]                 if (is_error) {
[18:06:19.394]                   sessionInformation <- function() {
[18:06:19.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:19.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:19.394]                       search = base::search(), system = base::Sys.info())
[18:06:19.394]                   }
[18:06:19.394]                   ...future.conditions[[length(...future.conditions) + 
[18:06:19.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:19.394]                     cond$call), session = sessionInformation(), 
[18:06:19.394]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:19.394]                   signalCondition(cond)
[18:06:19.394]                 }
[18:06:19.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:19.394]                 "immediateCondition"))) {
[18:06:19.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:19.394]                   ...future.conditions[[length(...future.conditions) + 
[18:06:19.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:19.394]                   if (TRUE && !signal) {
[18:06:19.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.394]                     {
[18:06:19.394]                       inherits <- base::inherits
[18:06:19.394]                       invokeRestart <- base::invokeRestart
[18:06:19.394]                       is.null <- base::is.null
[18:06:19.394]                       muffled <- FALSE
[18:06:19.394]                       if (inherits(cond, "message")) {
[18:06:19.394]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:19.394]                         if (muffled) 
[18:06:19.394]                           invokeRestart("muffleMessage")
[18:06:19.394]                       }
[18:06:19.394]                       else if (inherits(cond, "warning")) {
[18:06:19.394]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:19.394]                         if (muffled) 
[18:06:19.394]                           invokeRestart("muffleWarning")
[18:06:19.394]                       }
[18:06:19.394]                       else if (inherits(cond, "condition")) {
[18:06:19.394]                         if (!is.null(pattern)) {
[18:06:19.394]                           computeRestarts <- base::computeRestarts
[18:06:19.394]                           grepl <- base::grepl
[18:06:19.394]                           restarts <- computeRestarts(cond)
[18:06:19.394]                           for (restart in restarts) {
[18:06:19.394]                             name <- restart$name
[18:06:19.394]                             if (is.null(name)) 
[18:06:19.394]                               next
[18:06:19.394]                             if (!grepl(pattern, name)) 
[18:06:19.394]                               next
[18:06:19.394]                             invokeRestart(restart)
[18:06:19.394]                             muffled <- TRUE
[18:06:19.394]                             break
[18:06:19.394]                           }
[18:06:19.394]                         }
[18:06:19.394]                       }
[18:06:19.394]                       invisible(muffled)
[18:06:19.394]                     }
[18:06:19.394]                     muffleCondition(cond, pattern = "^muffle")
[18:06:19.394]                   }
[18:06:19.394]                 }
[18:06:19.394]                 else {
[18:06:19.394]                   if (TRUE) {
[18:06:19.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:19.394]                     {
[18:06:19.394]                       inherits <- base::inherits
[18:06:19.394]                       invokeRestart <- base::invokeRestart
[18:06:19.394]                       is.null <- base::is.null
[18:06:19.394]                       muffled <- FALSE
[18:06:19.394]                       if (inherits(cond, "message")) {
[18:06:19.394]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:19.394]                         if (muffled) 
[18:06:19.394]                           invokeRestart("muffleMessage")
[18:06:19.394]                       }
[18:06:19.394]                       else if (inherits(cond, "warning")) {
[18:06:19.394]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:19.394]                         if (muffled) 
[18:06:19.394]                           invokeRestart("muffleWarning")
[18:06:19.394]                       }
[18:06:19.394]                       else if (inherits(cond, "condition")) {
[18:06:19.394]                         if (!is.null(pattern)) {
[18:06:19.394]                           computeRestarts <- base::computeRestarts
[18:06:19.394]                           grepl <- base::grepl
[18:06:19.394]                           restarts <- computeRestarts(cond)
[18:06:19.394]                           for (restart in restarts) {
[18:06:19.394]                             name <- restart$name
[18:06:19.394]                             if (is.null(name)) 
[18:06:19.394]                               next
[18:06:19.394]                             if (!grepl(pattern, name)) 
[18:06:19.394]                               next
[18:06:19.394]                             invokeRestart(restart)
[18:06:19.394]                             muffled <- TRUE
[18:06:19.394]                             break
[18:06:19.394]                           }
[18:06:19.394]                         }
[18:06:19.394]                       }
[18:06:19.394]                       invisible(muffled)
[18:06:19.394]                     }
[18:06:19.394]                     muffleCondition(cond, pattern = "^muffle")
[18:06:19.394]                   }
[18:06:19.394]                 }
[18:06:19.394]             }
[18:06:19.394]         }))
[18:06:19.394]     }, error = function(ex) {
[18:06:19.394]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:19.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:19.394]                 ...future.rng), started = ...future.startTime, 
[18:06:19.394]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:19.394]             version = "1.8"), class = "FutureResult")
[18:06:19.394]     }, finally = {
[18:06:19.394]         if (!identical(...future.workdir, getwd())) 
[18:06:19.394]             setwd(...future.workdir)
[18:06:19.394]         {
[18:06:19.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:19.394]                 ...future.oldOptions$nwarnings <- NULL
[18:06:19.394]             }
[18:06:19.394]             base::options(...future.oldOptions)
[18:06:19.394]             if (.Platform$OS.type == "windows") {
[18:06:19.394]                 old_names <- names(...future.oldEnvVars)
[18:06:19.394]                 envs <- base::Sys.getenv()
[18:06:19.394]                 names <- names(envs)
[18:06:19.394]                 common <- intersect(names, old_names)
[18:06:19.394]                 added <- setdiff(names, old_names)
[18:06:19.394]                 removed <- setdiff(old_names, names)
[18:06:19.394]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:19.394]                   envs[common]]
[18:06:19.394]                 NAMES <- toupper(changed)
[18:06:19.394]                 args <- list()
[18:06:19.394]                 for (kk in seq_along(NAMES)) {
[18:06:19.394]                   name <- changed[[kk]]
[18:06:19.394]                   NAME <- NAMES[[kk]]
[18:06:19.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.394]                     next
[18:06:19.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:19.394]                 }
[18:06:19.394]                 NAMES <- toupper(added)
[18:06:19.394]                 for (kk in seq_along(NAMES)) {
[18:06:19.394]                   name <- added[[kk]]
[18:06:19.394]                   NAME <- NAMES[[kk]]
[18:06:19.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.394]                     next
[18:06:19.394]                   args[[name]] <- ""
[18:06:19.394]                 }
[18:06:19.394]                 NAMES <- toupper(removed)
[18:06:19.394]                 for (kk in seq_along(NAMES)) {
[18:06:19.394]                   name <- removed[[kk]]
[18:06:19.394]                   NAME <- NAMES[[kk]]
[18:06:19.394]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:19.394]                     next
[18:06:19.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:19.394]                 }
[18:06:19.394]                 if (length(args) > 0) 
[18:06:19.394]                   base::do.call(base::Sys.setenv, args = args)
[18:06:19.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:19.394]             }
[18:06:19.394]             else {
[18:06:19.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:19.394]             }
[18:06:19.394]             {
[18:06:19.394]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:19.394]                   0L) {
[18:06:19.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:19.394]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:19.394]                   base::options(opts)
[18:06:19.394]                 }
[18:06:19.394]                 {
[18:06:19.394]                   {
[18:06:19.394]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:19.394]                     NULL
[18:06:19.394]                   }
[18:06:19.394]                   options(future.plan = NULL)
[18:06:19.394]                   if (is.na(NA_character_)) 
[18:06:19.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:19.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:19.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:19.394]                     .init = FALSE)
[18:06:19.394]                 }
[18:06:19.394]             }
[18:06:19.394]         }
[18:06:19.394]     })
[18:06:19.394]     if (TRUE) {
[18:06:19.394]         base::sink(type = "output", split = FALSE)
[18:06:19.394]         if (TRUE) {
[18:06:19.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:19.394]         }
[18:06:19.394]         else {
[18:06:19.394]             ...future.result["stdout"] <- base::list(NULL)
[18:06:19.394]         }
[18:06:19.394]         base::close(...future.stdout)
[18:06:19.394]         ...future.stdout <- NULL
[18:06:19.394]     }
[18:06:19.394]     ...future.result$conditions <- ...future.conditions
[18:06:19.394]     ...future.result$finished <- base::Sys.time()
[18:06:19.394]     ...future.result
[18:06:19.394] }
[18:06:19.399] MultisessionFuture started
[18:06:19.400] - Launch lazy future ... done
[18:06:19.400] run() for ‘MultisessionFuture’ ... done
[18:06:19.955] receiveMessageFromWorker() for ClusterFuture ...
[18:06:19.956] - Validating connection of MultisessionFuture
[18:06:19.956] - received message: FutureResult
[18:06:19.957] - Received FutureResult
[18:06:19.957] - Erased future from FutureRegistry
[18:06:19.957] result() for ClusterFuture ...
[18:06:19.958] - result already collected: FutureResult
[18:06:19.958] result() for ClusterFuture ... done
[18:06:19.958] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:19.959] A MultisessionFuture was resolved
[18:06:19.959] getGlobalsAndPackages() ...
[18:06:19.959] Searching for globals...
[18:06:19.967] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:19.967] Searching for globals ... DONE
[18:06:19.967] Resolving globals: FALSE
[18:06:19.968] 
[18:06:19.969] 
[18:06:19.969] getGlobalsAndPackages() ... DONE
[18:06:19.970] run() for ‘Future’ ...
[18:06:19.970] - state: ‘created’
[18:06:19.971] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:20.007] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:20.007] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:20.008]   - Field: ‘node’
[18:06:20.008]   - Field: ‘label’
[18:06:20.008]   - Field: ‘local’
[18:06:20.009]   - Field: ‘owner’
[18:06:20.009]   - Field: ‘envir’
[18:06:20.009]   - Field: ‘workers’
[18:06:20.010]   - Field: ‘packages’
[18:06:20.010]   - Field: ‘gc’
[18:06:20.010]   - Field: ‘conditions’
[18:06:20.011]   - Field: ‘persistent’
[18:06:20.011]   - Field: ‘expr’
[18:06:20.011]   - Field: ‘uuid’
[18:06:20.012]   - Field: ‘seed’
[18:06:20.012]   - Field: ‘version’
[18:06:20.012]   - Field: ‘result’
[18:06:20.013]   - Field: ‘asynchronous’
[18:06:20.013]   - Field: ‘calls’
[18:06:20.013]   - Field: ‘globals’
[18:06:20.013]   - Field: ‘stdout’
[18:06:20.014]   - Field: ‘earlySignal’
[18:06:20.014]   - Field: ‘lazy’
[18:06:20.014]   - Field: ‘state’
[18:06:20.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:20.015] - Launch lazy future ...
[18:06:20.016] Packages needed by the future expression (n = 0): <none>
[18:06:20.016] Packages needed by future strategies (n = 0): <none>
[18:06:20.017] {
[18:06:20.017]     {
[18:06:20.017]         {
[18:06:20.017]             ...future.startTime <- base::Sys.time()
[18:06:20.017]             {
[18:06:20.017]                 {
[18:06:20.017]                   {
[18:06:20.017]                     {
[18:06:20.017]                       base::local({
[18:06:20.017]                         has_future <- base::requireNamespace("future", 
[18:06:20.017]                           quietly = TRUE)
[18:06:20.017]                         if (has_future) {
[18:06:20.017]                           ns <- base::getNamespace("future")
[18:06:20.017]                           version <- ns[[".package"]][["version"]]
[18:06:20.017]                           if (is.null(version)) 
[18:06:20.017]                             version <- utils::packageVersion("future")
[18:06:20.017]                         }
[18:06:20.017]                         else {
[18:06:20.017]                           version <- NULL
[18:06:20.017]                         }
[18:06:20.017]                         if (!has_future || version < "1.8.0") {
[18:06:20.017]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:20.017]                             "", base::R.version$version.string), 
[18:06:20.017]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:20.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:20.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:20.017]                               "release", "version")], collapse = " "), 
[18:06:20.017]                             hostname = base::Sys.info()[["nodename"]])
[18:06:20.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:20.017]                             info)
[18:06:20.017]                           info <- base::paste(info, collapse = "; ")
[18:06:20.017]                           if (!has_future) {
[18:06:20.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:20.017]                               info)
[18:06:20.017]                           }
[18:06:20.017]                           else {
[18:06:20.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:20.017]                               info, version)
[18:06:20.017]                           }
[18:06:20.017]                           base::stop(msg)
[18:06:20.017]                         }
[18:06:20.017]                       })
[18:06:20.017]                     }
[18:06:20.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:20.017]                     base::options(mc.cores = 1L)
[18:06:20.017]                   }
[18:06:20.017]                   ...future.strategy.old <- future::plan("list")
[18:06:20.017]                   options(future.plan = NULL)
[18:06:20.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:20.017]                 }
[18:06:20.017]                 ...future.workdir <- getwd()
[18:06:20.017]             }
[18:06:20.017]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:20.017]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:20.017]         }
[18:06:20.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:20.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:20.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:20.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:20.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:20.017]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:20.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:20.017]             base::names(...future.oldOptions))
[18:06:20.017]     }
[18:06:20.017]     if (FALSE) {
[18:06:20.017]     }
[18:06:20.017]     else {
[18:06:20.017]         if (TRUE) {
[18:06:20.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:20.017]                 open = "w")
[18:06:20.017]         }
[18:06:20.017]         else {
[18:06:20.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:20.017]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:20.017]         }
[18:06:20.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:20.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:20.017]             base::sink(type = "output", split = FALSE)
[18:06:20.017]             base::close(...future.stdout)
[18:06:20.017]         }, add = TRUE)
[18:06:20.017]     }
[18:06:20.017]     ...future.frame <- base::sys.nframe()
[18:06:20.017]     ...future.conditions <- base::list()
[18:06:20.017]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:20.017]     if (FALSE) {
[18:06:20.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:20.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:20.017]     }
[18:06:20.017]     ...future.result <- base::tryCatch({
[18:06:20.017]         base::withCallingHandlers({
[18:06:20.017]             ...future.value <- base::withVisible(base::local({
[18:06:20.017]                 ...future.makeSendCondition <- base::local({
[18:06:20.017]                   sendCondition <- NULL
[18:06:20.017]                   function(frame = 1L) {
[18:06:20.017]                     if (is.function(sendCondition)) 
[18:06:20.017]                       return(sendCondition)
[18:06:20.017]                     ns <- getNamespace("parallel")
[18:06:20.017]                     if (exists("sendData", mode = "function", 
[18:06:20.017]                       envir = ns)) {
[18:06:20.017]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:20.017]                         envir = ns)
[18:06:20.017]                       envir <- sys.frame(frame)
[18:06:20.017]                       master <- NULL
[18:06:20.017]                       while (!identical(envir, .GlobalEnv) && 
[18:06:20.017]                         !identical(envir, emptyenv())) {
[18:06:20.017]                         if (exists("master", mode = "list", envir = envir, 
[18:06:20.017]                           inherits = FALSE)) {
[18:06:20.017]                           master <- get("master", mode = "list", 
[18:06:20.017]                             envir = envir, inherits = FALSE)
[18:06:20.017]                           if (inherits(master, c("SOCKnode", 
[18:06:20.017]                             "SOCK0node"))) {
[18:06:20.017]                             sendCondition <<- function(cond) {
[18:06:20.017]                               data <- list(type = "VALUE", value = cond, 
[18:06:20.017]                                 success = TRUE)
[18:06:20.017]                               parallel_sendData(master, data)
[18:06:20.017]                             }
[18:06:20.017]                             return(sendCondition)
[18:06:20.017]                           }
[18:06:20.017]                         }
[18:06:20.017]                         frame <- frame + 1L
[18:06:20.017]                         envir <- sys.frame(frame)
[18:06:20.017]                       }
[18:06:20.017]                     }
[18:06:20.017]                     sendCondition <<- function(cond) NULL
[18:06:20.017]                   }
[18:06:20.017]                 })
[18:06:20.017]                 withCallingHandlers({
[18:06:20.017]                   {
[18:06:20.017]                     Sys.sleep(0.5)
[18:06:20.017]                     list(a = 1, b = 42L)
[18:06:20.017]                   }
[18:06:20.017]                 }, immediateCondition = function(cond) {
[18:06:20.017]                   sendCondition <- ...future.makeSendCondition()
[18:06:20.017]                   sendCondition(cond)
[18:06:20.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.017]                   {
[18:06:20.017]                     inherits <- base::inherits
[18:06:20.017]                     invokeRestart <- base::invokeRestart
[18:06:20.017]                     is.null <- base::is.null
[18:06:20.017]                     muffled <- FALSE
[18:06:20.017]                     if (inherits(cond, "message")) {
[18:06:20.017]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:20.017]                       if (muffled) 
[18:06:20.017]                         invokeRestart("muffleMessage")
[18:06:20.017]                     }
[18:06:20.017]                     else if (inherits(cond, "warning")) {
[18:06:20.017]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:20.017]                       if (muffled) 
[18:06:20.017]                         invokeRestart("muffleWarning")
[18:06:20.017]                     }
[18:06:20.017]                     else if (inherits(cond, "condition")) {
[18:06:20.017]                       if (!is.null(pattern)) {
[18:06:20.017]                         computeRestarts <- base::computeRestarts
[18:06:20.017]                         grepl <- base::grepl
[18:06:20.017]                         restarts <- computeRestarts(cond)
[18:06:20.017]                         for (restart in restarts) {
[18:06:20.017]                           name <- restart$name
[18:06:20.017]                           if (is.null(name)) 
[18:06:20.017]                             next
[18:06:20.017]                           if (!grepl(pattern, name)) 
[18:06:20.017]                             next
[18:06:20.017]                           invokeRestart(restart)
[18:06:20.017]                           muffled <- TRUE
[18:06:20.017]                           break
[18:06:20.017]                         }
[18:06:20.017]                       }
[18:06:20.017]                     }
[18:06:20.017]                     invisible(muffled)
[18:06:20.017]                   }
[18:06:20.017]                   muffleCondition(cond)
[18:06:20.017]                 })
[18:06:20.017]             }))
[18:06:20.017]             future::FutureResult(value = ...future.value$value, 
[18:06:20.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.017]                   ...future.rng), globalenv = if (FALSE) 
[18:06:20.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:20.017]                     ...future.globalenv.names))
[18:06:20.017]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:20.017]         }, condition = base::local({
[18:06:20.017]             c <- base::c
[18:06:20.017]             inherits <- base::inherits
[18:06:20.017]             invokeRestart <- base::invokeRestart
[18:06:20.017]             length <- base::length
[18:06:20.017]             list <- base::list
[18:06:20.017]             seq.int <- base::seq.int
[18:06:20.017]             signalCondition <- base::signalCondition
[18:06:20.017]             sys.calls <- base::sys.calls
[18:06:20.017]             `[[` <- base::`[[`
[18:06:20.017]             `+` <- base::`+`
[18:06:20.017]             `<<-` <- base::`<<-`
[18:06:20.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:20.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:20.017]                   3L)]
[18:06:20.017]             }
[18:06:20.017]             function(cond) {
[18:06:20.017]                 is_error <- inherits(cond, "error")
[18:06:20.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:20.017]                   NULL)
[18:06:20.017]                 if (is_error) {
[18:06:20.017]                   sessionInformation <- function() {
[18:06:20.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:20.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:20.017]                       search = base::search(), system = base::Sys.info())
[18:06:20.017]                   }
[18:06:20.017]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:20.017]                     cond$call), session = sessionInformation(), 
[18:06:20.017]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:20.017]                   signalCondition(cond)
[18:06:20.017]                 }
[18:06:20.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:20.017]                 "immediateCondition"))) {
[18:06:20.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:20.017]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:20.017]                   if (TRUE && !signal) {
[18:06:20.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.017]                     {
[18:06:20.017]                       inherits <- base::inherits
[18:06:20.017]                       invokeRestart <- base::invokeRestart
[18:06:20.017]                       is.null <- base::is.null
[18:06:20.017]                       muffled <- FALSE
[18:06:20.017]                       if (inherits(cond, "message")) {
[18:06:20.017]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.017]                         if (muffled) 
[18:06:20.017]                           invokeRestart("muffleMessage")
[18:06:20.017]                       }
[18:06:20.017]                       else if (inherits(cond, "warning")) {
[18:06:20.017]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.017]                         if (muffled) 
[18:06:20.017]                           invokeRestart("muffleWarning")
[18:06:20.017]                       }
[18:06:20.017]                       else if (inherits(cond, "condition")) {
[18:06:20.017]                         if (!is.null(pattern)) {
[18:06:20.017]                           computeRestarts <- base::computeRestarts
[18:06:20.017]                           grepl <- base::grepl
[18:06:20.017]                           restarts <- computeRestarts(cond)
[18:06:20.017]                           for (restart in restarts) {
[18:06:20.017]                             name <- restart$name
[18:06:20.017]                             if (is.null(name)) 
[18:06:20.017]                               next
[18:06:20.017]                             if (!grepl(pattern, name)) 
[18:06:20.017]                               next
[18:06:20.017]                             invokeRestart(restart)
[18:06:20.017]                             muffled <- TRUE
[18:06:20.017]                             break
[18:06:20.017]                           }
[18:06:20.017]                         }
[18:06:20.017]                       }
[18:06:20.017]                       invisible(muffled)
[18:06:20.017]                     }
[18:06:20.017]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.017]                   }
[18:06:20.017]                 }
[18:06:20.017]                 else {
[18:06:20.017]                   if (TRUE) {
[18:06:20.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.017]                     {
[18:06:20.017]                       inherits <- base::inherits
[18:06:20.017]                       invokeRestart <- base::invokeRestart
[18:06:20.017]                       is.null <- base::is.null
[18:06:20.017]                       muffled <- FALSE
[18:06:20.017]                       if (inherits(cond, "message")) {
[18:06:20.017]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.017]                         if (muffled) 
[18:06:20.017]                           invokeRestart("muffleMessage")
[18:06:20.017]                       }
[18:06:20.017]                       else if (inherits(cond, "warning")) {
[18:06:20.017]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.017]                         if (muffled) 
[18:06:20.017]                           invokeRestart("muffleWarning")
[18:06:20.017]                       }
[18:06:20.017]                       else if (inherits(cond, "condition")) {
[18:06:20.017]                         if (!is.null(pattern)) {
[18:06:20.017]                           computeRestarts <- base::computeRestarts
[18:06:20.017]                           grepl <- base::grepl
[18:06:20.017]                           restarts <- computeRestarts(cond)
[18:06:20.017]                           for (restart in restarts) {
[18:06:20.017]                             name <- restart$name
[18:06:20.017]                             if (is.null(name)) 
[18:06:20.017]                               next
[18:06:20.017]                             if (!grepl(pattern, name)) 
[18:06:20.017]                               next
[18:06:20.017]                             invokeRestart(restart)
[18:06:20.017]                             muffled <- TRUE
[18:06:20.017]                             break
[18:06:20.017]                           }
[18:06:20.017]                         }
[18:06:20.017]                       }
[18:06:20.017]                       invisible(muffled)
[18:06:20.017]                     }
[18:06:20.017]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.017]                   }
[18:06:20.017]                 }
[18:06:20.017]             }
[18:06:20.017]         }))
[18:06:20.017]     }, error = function(ex) {
[18:06:20.017]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:20.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.017]                 ...future.rng), started = ...future.startTime, 
[18:06:20.017]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:20.017]             version = "1.8"), class = "FutureResult")
[18:06:20.017]     }, finally = {
[18:06:20.017]         if (!identical(...future.workdir, getwd())) 
[18:06:20.017]             setwd(...future.workdir)
[18:06:20.017]         {
[18:06:20.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:20.017]                 ...future.oldOptions$nwarnings <- NULL
[18:06:20.017]             }
[18:06:20.017]             base::options(...future.oldOptions)
[18:06:20.017]             if (.Platform$OS.type == "windows") {
[18:06:20.017]                 old_names <- names(...future.oldEnvVars)
[18:06:20.017]                 envs <- base::Sys.getenv()
[18:06:20.017]                 names <- names(envs)
[18:06:20.017]                 common <- intersect(names, old_names)
[18:06:20.017]                 added <- setdiff(names, old_names)
[18:06:20.017]                 removed <- setdiff(old_names, names)
[18:06:20.017]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:20.017]                   envs[common]]
[18:06:20.017]                 NAMES <- toupper(changed)
[18:06:20.017]                 args <- list()
[18:06:20.017]                 for (kk in seq_along(NAMES)) {
[18:06:20.017]                   name <- changed[[kk]]
[18:06:20.017]                   NAME <- NAMES[[kk]]
[18:06:20.017]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.017]                     next
[18:06:20.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.017]                 }
[18:06:20.017]                 NAMES <- toupper(added)
[18:06:20.017]                 for (kk in seq_along(NAMES)) {
[18:06:20.017]                   name <- added[[kk]]
[18:06:20.017]                   NAME <- NAMES[[kk]]
[18:06:20.017]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.017]                     next
[18:06:20.017]                   args[[name]] <- ""
[18:06:20.017]                 }
[18:06:20.017]                 NAMES <- toupper(removed)
[18:06:20.017]                 for (kk in seq_along(NAMES)) {
[18:06:20.017]                   name <- removed[[kk]]
[18:06:20.017]                   NAME <- NAMES[[kk]]
[18:06:20.017]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.017]                     next
[18:06:20.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.017]                 }
[18:06:20.017]                 if (length(args) > 0) 
[18:06:20.017]                   base::do.call(base::Sys.setenv, args = args)
[18:06:20.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:20.017]             }
[18:06:20.017]             else {
[18:06:20.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:20.017]             }
[18:06:20.017]             {
[18:06:20.017]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:20.017]                   0L) {
[18:06:20.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:20.017]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:20.017]                   base::options(opts)
[18:06:20.017]                 }
[18:06:20.017]                 {
[18:06:20.017]                   {
[18:06:20.017]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:20.017]                     NULL
[18:06:20.017]                   }
[18:06:20.017]                   options(future.plan = NULL)
[18:06:20.017]                   if (is.na(NA_character_)) 
[18:06:20.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:20.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:20.017]                     .init = FALSE)
[18:06:20.017]                 }
[18:06:20.017]             }
[18:06:20.017]         }
[18:06:20.017]     })
[18:06:20.017]     if (TRUE) {
[18:06:20.017]         base::sink(type = "output", split = FALSE)
[18:06:20.017]         if (TRUE) {
[18:06:20.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:20.017]         }
[18:06:20.017]         else {
[18:06:20.017]             ...future.result["stdout"] <- base::list(NULL)
[18:06:20.017]         }
[18:06:20.017]         base::close(...future.stdout)
[18:06:20.017]         ...future.stdout <- NULL
[18:06:20.017]     }
[18:06:20.017]     ...future.result$conditions <- ...future.conditions
[18:06:20.017]     ...future.result$finished <- base::Sys.time()
[18:06:20.017]     ...future.result
[18:06:20.017] }
[18:06:20.025] MultisessionFuture started
[18:06:20.025] - Launch lazy future ... done
[18:06:20.026] run() for ‘MultisessionFuture’ ... done
[18:06:20.570] receiveMessageFromWorker() for ClusterFuture ...
[18:06:20.571] - Validating connection of MultisessionFuture
[18:06:20.571] - received message: FutureResult
[18:06:20.572] - Received FutureResult
[18:06:20.572] - Erased future from FutureRegistry
[18:06:20.572] result() for ClusterFuture ...
[18:06:20.573] - result already collected: FutureResult
[18:06:20.573] result() for ClusterFuture ... done
[18:06:20.573] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:20.574] A MultisessionFuture was resolved
- w/ exception ...
[18:06:20.574] getGlobalsAndPackages() ...
[18:06:20.574] Searching for globals...
[18:06:20.576] - globals found: [2] ‘list’, ‘stop’
[18:06:20.577] Searching for globals ... DONE
[18:06:20.577] Resolving globals: FALSE
[18:06:20.578] 
[18:06:20.578] 
[18:06:20.579] getGlobalsAndPackages() ... DONE
[18:06:20.579] run() for ‘Future’ ...
[18:06:20.580] - state: ‘created’
[18:06:20.580] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:20.611] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:20.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:20.612]   - Field: ‘node’
[18:06:20.612]   - Field: ‘label’
[18:06:20.613]   - Field: ‘local’
[18:06:20.613]   - Field: ‘owner’
[18:06:20.613]   - Field: ‘envir’
[18:06:20.613]   - Field: ‘workers’
[18:06:20.614]   - Field: ‘packages’
[18:06:20.614]   - Field: ‘gc’
[18:06:20.614]   - Field: ‘conditions’
[18:06:20.615]   - Field: ‘persistent’
[18:06:20.615]   - Field: ‘expr’
[18:06:20.615]   - Field: ‘uuid’
[18:06:20.615]   - Field: ‘seed’
[18:06:20.616]   - Field: ‘version’
[18:06:20.616]   - Field: ‘result’
[18:06:20.616]   - Field: ‘asynchronous’
[18:06:20.616]   - Field: ‘calls’
[18:06:20.617]   - Field: ‘globals’
[18:06:20.617]   - Field: ‘stdout’
[18:06:20.617]   - Field: ‘earlySignal’
[18:06:20.617]   - Field: ‘lazy’
[18:06:20.618]   - Field: ‘state’
[18:06:20.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:20.618] - Launch lazy future ...
[18:06:20.619] Packages needed by the future expression (n = 0): <none>
[18:06:20.619] Packages needed by future strategies (n = 0): <none>
[18:06:20.620] {
[18:06:20.620]     {
[18:06:20.620]         {
[18:06:20.620]             ...future.startTime <- base::Sys.time()
[18:06:20.620]             {
[18:06:20.620]                 {
[18:06:20.620]                   {
[18:06:20.620]                     {
[18:06:20.620]                       base::local({
[18:06:20.620]                         has_future <- base::requireNamespace("future", 
[18:06:20.620]                           quietly = TRUE)
[18:06:20.620]                         if (has_future) {
[18:06:20.620]                           ns <- base::getNamespace("future")
[18:06:20.620]                           version <- ns[[".package"]][["version"]]
[18:06:20.620]                           if (is.null(version)) 
[18:06:20.620]                             version <- utils::packageVersion("future")
[18:06:20.620]                         }
[18:06:20.620]                         else {
[18:06:20.620]                           version <- NULL
[18:06:20.620]                         }
[18:06:20.620]                         if (!has_future || version < "1.8.0") {
[18:06:20.620]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:20.620]                             "", base::R.version$version.string), 
[18:06:20.620]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:20.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:20.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:20.620]                               "release", "version")], collapse = " "), 
[18:06:20.620]                             hostname = base::Sys.info()[["nodename"]])
[18:06:20.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:20.620]                             info)
[18:06:20.620]                           info <- base::paste(info, collapse = "; ")
[18:06:20.620]                           if (!has_future) {
[18:06:20.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:20.620]                               info)
[18:06:20.620]                           }
[18:06:20.620]                           else {
[18:06:20.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:20.620]                               info, version)
[18:06:20.620]                           }
[18:06:20.620]                           base::stop(msg)
[18:06:20.620]                         }
[18:06:20.620]                       })
[18:06:20.620]                     }
[18:06:20.620]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:20.620]                     base::options(mc.cores = 1L)
[18:06:20.620]                   }
[18:06:20.620]                   ...future.strategy.old <- future::plan("list")
[18:06:20.620]                   options(future.plan = NULL)
[18:06:20.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:20.620]                 }
[18:06:20.620]                 ...future.workdir <- getwd()
[18:06:20.620]             }
[18:06:20.620]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:20.620]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:20.620]         }
[18:06:20.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:20.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:20.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:20.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:20.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:20.620]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:20.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:20.620]             base::names(...future.oldOptions))
[18:06:20.620]     }
[18:06:20.620]     if (FALSE) {
[18:06:20.620]     }
[18:06:20.620]     else {
[18:06:20.620]         if (TRUE) {
[18:06:20.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:20.620]                 open = "w")
[18:06:20.620]         }
[18:06:20.620]         else {
[18:06:20.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:20.620]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:20.620]         }
[18:06:20.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:20.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:20.620]             base::sink(type = "output", split = FALSE)
[18:06:20.620]             base::close(...future.stdout)
[18:06:20.620]         }, add = TRUE)
[18:06:20.620]     }
[18:06:20.620]     ...future.frame <- base::sys.nframe()
[18:06:20.620]     ...future.conditions <- base::list()
[18:06:20.620]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:20.620]     if (FALSE) {
[18:06:20.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:20.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:20.620]     }
[18:06:20.620]     ...future.result <- base::tryCatch({
[18:06:20.620]         base::withCallingHandlers({
[18:06:20.620]             ...future.value <- base::withVisible(base::local({
[18:06:20.620]                 ...future.makeSendCondition <- base::local({
[18:06:20.620]                   sendCondition <- NULL
[18:06:20.620]                   function(frame = 1L) {
[18:06:20.620]                     if (is.function(sendCondition)) 
[18:06:20.620]                       return(sendCondition)
[18:06:20.620]                     ns <- getNamespace("parallel")
[18:06:20.620]                     if (exists("sendData", mode = "function", 
[18:06:20.620]                       envir = ns)) {
[18:06:20.620]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:20.620]                         envir = ns)
[18:06:20.620]                       envir <- sys.frame(frame)
[18:06:20.620]                       master <- NULL
[18:06:20.620]                       while (!identical(envir, .GlobalEnv) && 
[18:06:20.620]                         !identical(envir, emptyenv())) {
[18:06:20.620]                         if (exists("master", mode = "list", envir = envir, 
[18:06:20.620]                           inherits = FALSE)) {
[18:06:20.620]                           master <- get("master", mode = "list", 
[18:06:20.620]                             envir = envir, inherits = FALSE)
[18:06:20.620]                           if (inherits(master, c("SOCKnode", 
[18:06:20.620]                             "SOCK0node"))) {
[18:06:20.620]                             sendCondition <<- function(cond) {
[18:06:20.620]                               data <- list(type = "VALUE", value = cond, 
[18:06:20.620]                                 success = TRUE)
[18:06:20.620]                               parallel_sendData(master, data)
[18:06:20.620]                             }
[18:06:20.620]                             return(sendCondition)
[18:06:20.620]                           }
[18:06:20.620]                         }
[18:06:20.620]                         frame <- frame + 1L
[18:06:20.620]                         envir <- sys.frame(frame)
[18:06:20.620]                       }
[18:06:20.620]                     }
[18:06:20.620]                     sendCondition <<- function(cond) NULL
[18:06:20.620]                   }
[18:06:20.620]                 })
[18:06:20.620]                 withCallingHandlers({
[18:06:20.620]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:20.620]                 }, immediateCondition = function(cond) {
[18:06:20.620]                   sendCondition <- ...future.makeSendCondition()
[18:06:20.620]                   sendCondition(cond)
[18:06:20.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.620]                   {
[18:06:20.620]                     inherits <- base::inherits
[18:06:20.620]                     invokeRestart <- base::invokeRestart
[18:06:20.620]                     is.null <- base::is.null
[18:06:20.620]                     muffled <- FALSE
[18:06:20.620]                     if (inherits(cond, "message")) {
[18:06:20.620]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:20.620]                       if (muffled) 
[18:06:20.620]                         invokeRestart("muffleMessage")
[18:06:20.620]                     }
[18:06:20.620]                     else if (inherits(cond, "warning")) {
[18:06:20.620]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:20.620]                       if (muffled) 
[18:06:20.620]                         invokeRestart("muffleWarning")
[18:06:20.620]                     }
[18:06:20.620]                     else if (inherits(cond, "condition")) {
[18:06:20.620]                       if (!is.null(pattern)) {
[18:06:20.620]                         computeRestarts <- base::computeRestarts
[18:06:20.620]                         grepl <- base::grepl
[18:06:20.620]                         restarts <- computeRestarts(cond)
[18:06:20.620]                         for (restart in restarts) {
[18:06:20.620]                           name <- restart$name
[18:06:20.620]                           if (is.null(name)) 
[18:06:20.620]                             next
[18:06:20.620]                           if (!grepl(pattern, name)) 
[18:06:20.620]                             next
[18:06:20.620]                           invokeRestart(restart)
[18:06:20.620]                           muffled <- TRUE
[18:06:20.620]                           break
[18:06:20.620]                         }
[18:06:20.620]                       }
[18:06:20.620]                     }
[18:06:20.620]                     invisible(muffled)
[18:06:20.620]                   }
[18:06:20.620]                   muffleCondition(cond)
[18:06:20.620]                 })
[18:06:20.620]             }))
[18:06:20.620]             future::FutureResult(value = ...future.value$value, 
[18:06:20.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.620]                   ...future.rng), globalenv = if (FALSE) 
[18:06:20.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:20.620]                     ...future.globalenv.names))
[18:06:20.620]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:20.620]         }, condition = base::local({
[18:06:20.620]             c <- base::c
[18:06:20.620]             inherits <- base::inherits
[18:06:20.620]             invokeRestart <- base::invokeRestart
[18:06:20.620]             length <- base::length
[18:06:20.620]             list <- base::list
[18:06:20.620]             seq.int <- base::seq.int
[18:06:20.620]             signalCondition <- base::signalCondition
[18:06:20.620]             sys.calls <- base::sys.calls
[18:06:20.620]             `[[` <- base::`[[`
[18:06:20.620]             `+` <- base::`+`
[18:06:20.620]             `<<-` <- base::`<<-`
[18:06:20.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:20.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:20.620]                   3L)]
[18:06:20.620]             }
[18:06:20.620]             function(cond) {
[18:06:20.620]                 is_error <- inherits(cond, "error")
[18:06:20.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:20.620]                   NULL)
[18:06:20.620]                 if (is_error) {
[18:06:20.620]                   sessionInformation <- function() {
[18:06:20.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:20.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:20.620]                       search = base::search(), system = base::Sys.info())
[18:06:20.620]                   }
[18:06:20.620]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:20.620]                     cond$call), session = sessionInformation(), 
[18:06:20.620]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:20.620]                   signalCondition(cond)
[18:06:20.620]                 }
[18:06:20.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:20.620]                 "immediateCondition"))) {
[18:06:20.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:20.620]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:20.620]                   if (TRUE && !signal) {
[18:06:20.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.620]                     {
[18:06:20.620]                       inherits <- base::inherits
[18:06:20.620]                       invokeRestart <- base::invokeRestart
[18:06:20.620]                       is.null <- base::is.null
[18:06:20.620]                       muffled <- FALSE
[18:06:20.620]                       if (inherits(cond, "message")) {
[18:06:20.620]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.620]                         if (muffled) 
[18:06:20.620]                           invokeRestart("muffleMessage")
[18:06:20.620]                       }
[18:06:20.620]                       else if (inherits(cond, "warning")) {
[18:06:20.620]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.620]                         if (muffled) 
[18:06:20.620]                           invokeRestart("muffleWarning")
[18:06:20.620]                       }
[18:06:20.620]                       else if (inherits(cond, "condition")) {
[18:06:20.620]                         if (!is.null(pattern)) {
[18:06:20.620]                           computeRestarts <- base::computeRestarts
[18:06:20.620]                           grepl <- base::grepl
[18:06:20.620]                           restarts <- computeRestarts(cond)
[18:06:20.620]                           for (restart in restarts) {
[18:06:20.620]                             name <- restart$name
[18:06:20.620]                             if (is.null(name)) 
[18:06:20.620]                               next
[18:06:20.620]                             if (!grepl(pattern, name)) 
[18:06:20.620]                               next
[18:06:20.620]                             invokeRestart(restart)
[18:06:20.620]                             muffled <- TRUE
[18:06:20.620]                             break
[18:06:20.620]                           }
[18:06:20.620]                         }
[18:06:20.620]                       }
[18:06:20.620]                       invisible(muffled)
[18:06:20.620]                     }
[18:06:20.620]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.620]                   }
[18:06:20.620]                 }
[18:06:20.620]                 else {
[18:06:20.620]                   if (TRUE) {
[18:06:20.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.620]                     {
[18:06:20.620]                       inherits <- base::inherits
[18:06:20.620]                       invokeRestart <- base::invokeRestart
[18:06:20.620]                       is.null <- base::is.null
[18:06:20.620]                       muffled <- FALSE
[18:06:20.620]                       if (inherits(cond, "message")) {
[18:06:20.620]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.620]                         if (muffled) 
[18:06:20.620]                           invokeRestart("muffleMessage")
[18:06:20.620]                       }
[18:06:20.620]                       else if (inherits(cond, "warning")) {
[18:06:20.620]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.620]                         if (muffled) 
[18:06:20.620]                           invokeRestart("muffleWarning")
[18:06:20.620]                       }
[18:06:20.620]                       else if (inherits(cond, "condition")) {
[18:06:20.620]                         if (!is.null(pattern)) {
[18:06:20.620]                           computeRestarts <- base::computeRestarts
[18:06:20.620]                           grepl <- base::grepl
[18:06:20.620]                           restarts <- computeRestarts(cond)
[18:06:20.620]                           for (restart in restarts) {
[18:06:20.620]                             name <- restart$name
[18:06:20.620]                             if (is.null(name)) 
[18:06:20.620]                               next
[18:06:20.620]                             if (!grepl(pattern, name)) 
[18:06:20.620]                               next
[18:06:20.620]                             invokeRestart(restart)
[18:06:20.620]                             muffled <- TRUE
[18:06:20.620]                             break
[18:06:20.620]                           }
[18:06:20.620]                         }
[18:06:20.620]                       }
[18:06:20.620]                       invisible(muffled)
[18:06:20.620]                     }
[18:06:20.620]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.620]                   }
[18:06:20.620]                 }
[18:06:20.620]             }
[18:06:20.620]         }))
[18:06:20.620]     }, error = function(ex) {
[18:06:20.620]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:20.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.620]                 ...future.rng), started = ...future.startTime, 
[18:06:20.620]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:20.620]             version = "1.8"), class = "FutureResult")
[18:06:20.620]     }, finally = {
[18:06:20.620]         if (!identical(...future.workdir, getwd())) 
[18:06:20.620]             setwd(...future.workdir)
[18:06:20.620]         {
[18:06:20.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:20.620]                 ...future.oldOptions$nwarnings <- NULL
[18:06:20.620]             }
[18:06:20.620]             base::options(...future.oldOptions)
[18:06:20.620]             if (.Platform$OS.type == "windows") {
[18:06:20.620]                 old_names <- names(...future.oldEnvVars)
[18:06:20.620]                 envs <- base::Sys.getenv()
[18:06:20.620]                 names <- names(envs)
[18:06:20.620]                 common <- intersect(names, old_names)
[18:06:20.620]                 added <- setdiff(names, old_names)
[18:06:20.620]                 removed <- setdiff(old_names, names)
[18:06:20.620]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:20.620]                   envs[common]]
[18:06:20.620]                 NAMES <- toupper(changed)
[18:06:20.620]                 args <- list()
[18:06:20.620]                 for (kk in seq_along(NAMES)) {
[18:06:20.620]                   name <- changed[[kk]]
[18:06:20.620]                   NAME <- NAMES[[kk]]
[18:06:20.620]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.620]                     next
[18:06:20.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.620]                 }
[18:06:20.620]                 NAMES <- toupper(added)
[18:06:20.620]                 for (kk in seq_along(NAMES)) {
[18:06:20.620]                   name <- added[[kk]]
[18:06:20.620]                   NAME <- NAMES[[kk]]
[18:06:20.620]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.620]                     next
[18:06:20.620]                   args[[name]] <- ""
[18:06:20.620]                 }
[18:06:20.620]                 NAMES <- toupper(removed)
[18:06:20.620]                 for (kk in seq_along(NAMES)) {
[18:06:20.620]                   name <- removed[[kk]]
[18:06:20.620]                   NAME <- NAMES[[kk]]
[18:06:20.620]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.620]                     next
[18:06:20.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.620]                 }
[18:06:20.620]                 if (length(args) > 0) 
[18:06:20.620]                   base::do.call(base::Sys.setenv, args = args)
[18:06:20.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:20.620]             }
[18:06:20.620]             else {
[18:06:20.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:20.620]             }
[18:06:20.620]             {
[18:06:20.620]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:20.620]                   0L) {
[18:06:20.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:20.620]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:20.620]                   base::options(opts)
[18:06:20.620]                 }
[18:06:20.620]                 {
[18:06:20.620]                   {
[18:06:20.620]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:20.620]                     NULL
[18:06:20.620]                   }
[18:06:20.620]                   options(future.plan = NULL)
[18:06:20.620]                   if (is.na(NA_character_)) 
[18:06:20.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:20.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:20.620]                     .init = FALSE)
[18:06:20.620]                 }
[18:06:20.620]             }
[18:06:20.620]         }
[18:06:20.620]     })
[18:06:20.620]     if (TRUE) {
[18:06:20.620]         base::sink(type = "output", split = FALSE)
[18:06:20.620]         if (TRUE) {
[18:06:20.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:20.620]         }
[18:06:20.620]         else {
[18:06:20.620]             ...future.result["stdout"] <- base::list(NULL)
[18:06:20.620]         }
[18:06:20.620]         base::close(...future.stdout)
[18:06:20.620]         ...future.stdout <- NULL
[18:06:20.620]     }
[18:06:20.620]     ...future.result$conditions <- ...future.conditions
[18:06:20.620]     ...future.result$finished <- base::Sys.time()
[18:06:20.620]     ...future.result
[18:06:20.620] }
[18:06:20.628] MultisessionFuture started
[18:06:20.628] - Launch lazy future ... done
[18:06:20.628] run() for ‘MultisessionFuture’ ... done
[18:06:20.672] receiveMessageFromWorker() for ClusterFuture ...
[18:06:20.673] - Validating connection of MultisessionFuture
[18:06:20.674] - received message: FutureResult
[18:06:20.674] - Received FutureResult
[18:06:20.675] - Erased future from FutureRegistry
[18:06:20.675] result() for ClusterFuture ...
[18:06:20.675] - result already collected: FutureResult
[18:06:20.676] result() for ClusterFuture ... done
[18:06:20.676] signalConditions() ...
[18:06:20.676]  - include = ‘immediateCondition’
[18:06:20.677]  - exclude = 
[18:06:20.677]  - resignal = FALSE
[18:06:20.677]  - Number of conditions: 1
[18:06:20.678] signalConditions() ... done
[18:06:20.678] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:20.678] A MultisessionFuture was resolved
[18:06:20.679] getGlobalsAndPackages() ...
[18:06:20.679] Searching for globals...
[18:06:20.681] - globals found: [2] ‘list’, ‘stop’
[18:06:20.681] Searching for globals ... DONE
[18:06:20.682] Resolving globals: FALSE
[18:06:20.682] 
[18:06:20.683] 
[18:06:20.683] getGlobalsAndPackages() ... DONE
[18:06:20.684] run() for ‘Future’ ...
[18:06:20.684] - state: ‘created’
[18:06:20.685] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:20.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:20.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:20.724]   - Field: ‘node’
[18:06:20.724]   - Field: ‘label’
[18:06:20.725]   - Field: ‘local’
[18:06:20.725]   - Field: ‘owner’
[18:06:20.725]   - Field: ‘envir’
[18:06:20.726]   - Field: ‘workers’
[18:06:20.726]   - Field: ‘packages’
[18:06:20.726]   - Field: ‘gc’
[18:06:20.726]   - Field: ‘conditions’
[18:06:20.727]   - Field: ‘persistent’
[18:06:20.727]   - Field: ‘expr’
[18:06:20.727]   - Field: ‘uuid’
[18:06:20.727]   - Field: ‘seed’
[18:06:20.728]   - Field: ‘version’
[18:06:20.728]   - Field: ‘result’
[18:06:20.728]   - Field: ‘asynchronous’
[18:06:20.729]   - Field: ‘calls’
[18:06:20.729]   - Field: ‘globals’
[18:06:20.729]   - Field: ‘stdout’
[18:06:20.729]   - Field: ‘earlySignal’
[18:06:20.730]   - Field: ‘lazy’
[18:06:20.730]   - Field: ‘state’
[18:06:20.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:20.730] - Launch lazy future ...
[18:06:20.731] Packages needed by the future expression (n = 0): <none>
[18:06:20.731] Packages needed by future strategies (n = 0): <none>
[18:06:20.733] {
[18:06:20.733]     {
[18:06:20.733]         {
[18:06:20.733]             ...future.startTime <- base::Sys.time()
[18:06:20.733]             {
[18:06:20.733]                 {
[18:06:20.733]                   {
[18:06:20.733]                     {
[18:06:20.733]                       base::local({
[18:06:20.733]                         has_future <- base::requireNamespace("future", 
[18:06:20.733]                           quietly = TRUE)
[18:06:20.733]                         if (has_future) {
[18:06:20.733]                           ns <- base::getNamespace("future")
[18:06:20.733]                           version <- ns[[".package"]][["version"]]
[18:06:20.733]                           if (is.null(version)) 
[18:06:20.733]                             version <- utils::packageVersion("future")
[18:06:20.733]                         }
[18:06:20.733]                         else {
[18:06:20.733]                           version <- NULL
[18:06:20.733]                         }
[18:06:20.733]                         if (!has_future || version < "1.8.0") {
[18:06:20.733]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:20.733]                             "", base::R.version$version.string), 
[18:06:20.733]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:20.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:20.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:20.733]                               "release", "version")], collapse = " "), 
[18:06:20.733]                             hostname = base::Sys.info()[["nodename"]])
[18:06:20.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:20.733]                             info)
[18:06:20.733]                           info <- base::paste(info, collapse = "; ")
[18:06:20.733]                           if (!has_future) {
[18:06:20.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:20.733]                               info)
[18:06:20.733]                           }
[18:06:20.733]                           else {
[18:06:20.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:20.733]                               info, version)
[18:06:20.733]                           }
[18:06:20.733]                           base::stop(msg)
[18:06:20.733]                         }
[18:06:20.733]                       })
[18:06:20.733]                     }
[18:06:20.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:20.733]                     base::options(mc.cores = 1L)
[18:06:20.733]                   }
[18:06:20.733]                   ...future.strategy.old <- future::plan("list")
[18:06:20.733]                   options(future.plan = NULL)
[18:06:20.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:20.733]                 }
[18:06:20.733]                 ...future.workdir <- getwd()
[18:06:20.733]             }
[18:06:20.733]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:20.733]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:20.733]         }
[18:06:20.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:20.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:20.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:20.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:20.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:20.733]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:20.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:20.733]             base::names(...future.oldOptions))
[18:06:20.733]     }
[18:06:20.733]     if (FALSE) {
[18:06:20.733]     }
[18:06:20.733]     else {
[18:06:20.733]         if (TRUE) {
[18:06:20.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:20.733]                 open = "w")
[18:06:20.733]         }
[18:06:20.733]         else {
[18:06:20.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:20.733]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:20.733]         }
[18:06:20.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:20.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:20.733]             base::sink(type = "output", split = FALSE)
[18:06:20.733]             base::close(...future.stdout)
[18:06:20.733]         }, add = TRUE)
[18:06:20.733]     }
[18:06:20.733]     ...future.frame <- base::sys.nframe()
[18:06:20.733]     ...future.conditions <- base::list()
[18:06:20.733]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:20.733]     if (FALSE) {
[18:06:20.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:20.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:20.733]     }
[18:06:20.733]     ...future.result <- base::tryCatch({
[18:06:20.733]         base::withCallingHandlers({
[18:06:20.733]             ...future.value <- base::withVisible(base::local({
[18:06:20.733]                 ...future.makeSendCondition <- base::local({
[18:06:20.733]                   sendCondition <- NULL
[18:06:20.733]                   function(frame = 1L) {
[18:06:20.733]                     if (is.function(sendCondition)) 
[18:06:20.733]                       return(sendCondition)
[18:06:20.733]                     ns <- getNamespace("parallel")
[18:06:20.733]                     if (exists("sendData", mode = "function", 
[18:06:20.733]                       envir = ns)) {
[18:06:20.733]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:20.733]                         envir = ns)
[18:06:20.733]                       envir <- sys.frame(frame)
[18:06:20.733]                       master <- NULL
[18:06:20.733]                       while (!identical(envir, .GlobalEnv) && 
[18:06:20.733]                         !identical(envir, emptyenv())) {
[18:06:20.733]                         if (exists("master", mode = "list", envir = envir, 
[18:06:20.733]                           inherits = FALSE)) {
[18:06:20.733]                           master <- get("master", mode = "list", 
[18:06:20.733]                             envir = envir, inherits = FALSE)
[18:06:20.733]                           if (inherits(master, c("SOCKnode", 
[18:06:20.733]                             "SOCK0node"))) {
[18:06:20.733]                             sendCondition <<- function(cond) {
[18:06:20.733]                               data <- list(type = "VALUE", value = cond, 
[18:06:20.733]                                 success = TRUE)
[18:06:20.733]                               parallel_sendData(master, data)
[18:06:20.733]                             }
[18:06:20.733]                             return(sendCondition)
[18:06:20.733]                           }
[18:06:20.733]                         }
[18:06:20.733]                         frame <- frame + 1L
[18:06:20.733]                         envir <- sys.frame(frame)
[18:06:20.733]                       }
[18:06:20.733]                     }
[18:06:20.733]                     sendCondition <<- function(cond) NULL
[18:06:20.733]                   }
[18:06:20.733]                 })
[18:06:20.733]                 withCallingHandlers({
[18:06:20.733]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:20.733]                 }, immediateCondition = function(cond) {
[18:06:20.733]                   sendCondition <- ...future.makeSendCondition()
[18:06:20.733]                   sendCondition(cond)
[18:06:20.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.733]                   {
[18:06:20.733]                     inherits <- base::inherits
[18:06:20.733]                     invokeRestart <- base::invokeRestart
[18:06:20.733]                     is.null <- base::is.null
[18:06:20.733]                     muffled <- FALSE
[18:06:20.733]                     if (inherits(cond, "message")) {
[18:06:20.733]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:20.733]                       if (muffled) 
[18:06:20.733]                         invokeRestart("muffleMessage")
[18:06:20.733]                     }
[18:06:20.733]                     else if (inherits(cond, "warning")) {
[18:06:20.733]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:20.733]                       if (muffled) 
[18:06:20.733]                         invokeRestart("muffleWarning")
[18:06:20.733]                     }
[18:06:20.733]                     else if (inherits(cond, "condition")) {
[18:06:20.733]                       if (!is.null(pattern)) {
[18:06:20.733]                         computeRestarts <- base::computeRestarts
[18:06:20.733]                         grepl <- base::grepl
[18:06:20.733]                         restarts <- computeRestarts(cond)
[18:06:20.733]                         for (restart in restarts) {
[18:06:20.733]                           name <- restart$name
[18:06:20.733]                           if (is.null(name)) 
[18:06:20.733]                             next
[18:06:20.733]                           if (!grepl(pattern, name)) 
[18:06:20.733]                             next
[18:06:20.733]                           invokeRestart(restart)
[18:06:20.733]                           muffled <- TRUE
[18:06:20.733]                           break
[18:06:20.733]                         }
[18:06:20.733]                       }
[18:06:20.733]                     }
[18:06:20.733]                     invisible(muffled)
[18:06:20.733]                   }
[18:06:20.733]                   muffleCondition(cond)
[18:06:20.733]                 })
[18:06:20.733]             }))
[18:06:20.733]             future::FutureResult(value = ...future.value$value, 
[18:06:20.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.733]                   ...future.rng), globalenv = if (FALSE) 
[18:06:20.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:20.733]                     ...future.globalenv.names))
[18:06:20.733]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:20.733]         }, condition = base::local({
[18:06:20.733]             c <- base::c
[18:06:20.733]             inherits <- base::inherits
[18:06:20.733]             invokeRestart <- base::invokeRestart
[18:06:20.733]             length <- base::length
[18:06:20.733]             list <- base::list
[18:06:20.733]             seq.int <- base::seq.int
[18:06:20.733]             signalCondition <- base::signalCondition
[18:06:20.733]             sys.calls <- base::sys.calls
[18:06:20.733]             `[[` <- base::`[[`
[18:06:20.733]             `+` <- base::`+`
[18:06:20.733]             `<<-` <- base::`<<-`
[18:06:20.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:20.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:20.733]                   3L)]
[18:06:20.733]             }
[18:06:20.733]             function(cond) {
[18:06:20.733]                 is_error <- inherits(cond, "error")
[18:06:20.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:20.733]                   NULL)
[18:06:20.733]                 if (is_error) {
[18:06:20.733]                   sessionInformation <- function() {
[18:06:20.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:20.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:20.733]                       search = base::search(), system = base::Sys.info())
[18:06:20.733]                   }
[18:06:20.733]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:20.733]                     cond$call), session = sessionInformation(), 
[18:06:20.733]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:20.733]                   signalCondition(cond)
[18:06:20.733]                 }
[18:06:20.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:20.733]                 "immediateCondition"))) {
[18:06:20.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:20.733]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:20.733]                   if (TRUE && !signal) {
[18:06:20.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.733]                     {
[18:06:20.733]                       inherits <- base::inherits
[18:06:20.733]                       invokeRestart <- base::invokeRestart
[18:06:20.733]                       is.null <- base::is.null
[18:06:20.733]                       muffled <- FALSE
[18:06:20.733]                       if (inherits(cond, "message")) {
[18:06:20.733]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.733]                         if (muffled) 
[18:06:20.733]                           invokeRestart("muffleMessage")
[18:06:20.733]                       }
[18:06:20.733]                       else if (inherits(cond, "warning")) {
[18:06:20.733]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.733]                         if (muffled) 
[18:06:20.733]                           invokeRestart("muffleWarning")
[18:06:20.733]                       }
[18:06:20.733]                       else if (inherits(cond, "condition")) {
[18:06:20.733]                         if (!is.null(pattern)) {
[18:06:20.733]                           computeRestarts <- base::computeRestarts
[18:06:20.733]                           grepl <- base::grepl
[18:06:20.733]                           restarts <- computeRestarts(cond)
[18:06:20.733]                           for (restart in restarts) {
[18:06:20.733]                             name <- restart$name
[18:06:20.733]                             if (is.null(name)) 
[18:06:20.733]                               next
[18:06:20.733]                             if (!grepl(pattern, name)) 
[18:06:20.733]                               next
[18:06:20.733]                             invokeRestart(restart)
[18:06:20.733]                             muffled <- TRUE
[18:06:20.733]                             break
[18:06:20.733]                           }
[18:06:20.733]                         }
[18:06:20.733]                       }
[18:06:20.733]                       invisible(muffled)
[18:06:20.733]                     }
[18:06:20.733]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.733]                   }
[18:06:20.733]                 }
[18:06:20.733]                 else {
[18:06:20.733]                   if (TRUE) {
[18:06:20.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.733]                     {
[18:06:20.733]                       inherits <- base::inherits
[18:06:20.733]                       invokeRestart <- base::invokeRestart
[18:06:20.733]                       is.null <- base::is.null
[18:06:20.733]                       muffled <- FALSE
[18:06:20.733]                       if (inherits(cond, "message")) {
[18:06:20.733]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.733]                         if (muffled) 
[18:06:20.733]                           invokeRestart("muffleMessage")
[18:06:20.733]                       }
[18:06:20.733]                       else if (inherits(cond, "warning")) {
[18:06:20.733]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.733]                         if (muffled) 
[18:06:20.733]                           invokeRestart("muffleWarning")
[18:06:20.733]                       }
[18:06:20.733]                       else if (inherits(cond, "condition")) {
[18:06:20.733]                         if (!is.null(pattern)) {
[18:06:20.733]                           computeRestarts <- base::computeRestarts
[18:06:20.733]                           grepl <- base::grepl
[18:06:20.733]                           restarts <- computeRestarts(cond)
[18:06:20.733]                           for (restart in restarts) {
[18:06:20.733]                             name <- restart$name
[18:06:20.733]                             if (is.null(name)) 
[18:06:20.733]                               next
[18:06:20.733]                             if (!grepl(pattern, name)) 
[18:06:20.733]                               next
[18:06:20.733]                             invokeRestart(restart)
[18:06:20.733]                             muffled <- TRUE
[18:06:20.733]                             break
[18:06:20.733]                           }
[18:06:20.733]                         }
[18:06:20.733]                       }
[18:06:20.733]                       invisible(muffled)
[18:06:20.733]                     }
[18:06:20.733]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.733]                   }
[18:06:20.733]                 }
[18:06:20.733]             }
[18:06:20.733]         }))
[18:06:20.733]     }, error = function(ex) {
[18:06:20.733]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:20.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.733]                 ...future.rng), started = ...future.startTime, 
[18:06:20.733]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:20.733]             version = "1.8"), class = "FutureResult")
[18:06:20.733]     }, finally = {
[18:06:20.733]         if (!identical(...future.workdir, getwd())) 
[18:06:20.733]             setwd(...future.workdir)
[18:06:20.733]         {
[18:06:20.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:20.733]                 ...future.oldOptions$nwarnings <- NULL
[18:06:20.733]             }
[18:06:20.733]             base::options(...future.oldOptions)
[18:06:20.733]             if (.Platform$OS.type == "windows") {
[18:06:20.733]                 old_names <- names(...future.oldEnvVars)
[18:06:20.733]                 envs <- base::Sys.getenv()
[18:06:20.733]                 names <- names(envs)
[18:06:20.733]                 common <- intersect(names, old_names)
[18:06:20.733]                 added <- setdiff(names, old_names)
[18:06:20.733]                 removed <- setdiff(old_names, names)
[18:06:20.733]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:20.733]                   envs[common]]
[18:06:20.733]                 NAMES <- toupper(changed)
[18:06:20.733]                 args <- list()
[18:06:20.733]                 for (kk in seq_along(NAMES)) {
[18:06:20.733]                   name <- changed[[kk]]
[18:06:20.733]                   NAME <- NAMES[[kk]]
[18:06:20.733]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.733]                     next
[18:06:20.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.733]                 }
[18:06:20.733]                 NAMES <- toupper(added)
[18:06:20.733]                 for (kk in seq_along(NAMES)) {
[18:06:20.733]                   name <- added[[kk]]
[18:06:20.733]                   NAME <- NAMES[[kk]]
[18:06:20.733]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.733]                     next
[18:06:20.733]                   args[[name]] <- ""
[18:06:20.733]                 }
[18:06:20.733]                 NAMES <- toupper(removed)
[18:06:20.733]                 for (kk in seq_along(NAMES)) {
[18:06:20.733]                   name <- removed[[kk]]
[18:06:20.733]                   NAME <- NAMES[[kk]]
[18:06:20.733]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.733]                     next
[18:06:20.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.733]                 }
[18:06:20.733]                 if (length(args) > 0) 
[18:06:20.733]                   base::do.call(base::Sys.setenv, args = args)
[18:06:20.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:20.733]             }
[18:06:20.733]             else {
[18:06:20.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:20.733]             }
[18:06:20.733]             {
[18:06:20.733]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:20.733]                   0L) {
[18:06:20.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:20.733]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:20.733]                   base::options(opts)
[18:06:20.733]                 }
[18:06:20.733]                 {
[18:06:20.733]                   {
[18:06:20.733]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:20.733]                     NULL
[18:06:20.733]                   }
[18:06:20.733]                   options(future.plan = NULL)
[18:06:20.733]                   if (is.na(NA_character_)) 
[18:06:20.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:20.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:20.733]                     .init = FALSE)
[18:06:20.733]                 }
[18:06:20.733]             }
[18:06:20.733]         }
[18:06:20.733]     })
[18:06:20.733]     if (TRUE) {
[18:06:20.733]         base::sink(type = "output", split = FALSE)
[18:06:20.733]         if (TRUE) {
[18:06:20.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:20.733]         }
[18:06:20.733]         else {
[18:06:20.733]             ...future.result["stdout"] <- base::list(NULL)
[18:06:20.733]         }
[18:06:20.733]         base::close(...future.stdout)
[18:06:20.733]         ...future.stdout <- NULL
[18:06:20.733]     }
[18:06:20.733]     ...future.result$conditions <- ...future.conditions
[18:06:20.733]     ...future.result$finished <- base::Sys.time()
[18:06:20.733]     ...future.result
[18:06:20.733] }
[18:06:20.740] MultisessionFuture started
[18:06:20.741] - Launch lazy future ... done
[18:06:20.741] run() for ‘MultisessionFuture’ ... done
[18:06:20.785] receiveMessageFromWorker() for ClusterFuture ...
[18:06:20.785] - Validating connection of MultisessionFuture
[18:06:20.786] - received message: FutureResult
[18:06:20.787] - Received FutureResult
[18:06:20.787] - Erased future from FutureRegistry
[18:06:20.788] result() for ClusterFuture ...
[18:06:20.788] - result already collected: FutureResult
[18:06:20.788] result() for ClusterFuture ... done
[18:06:20.789] signalConditions() ...
[18:06:20.789]  - include = ‘immediateCondition’
[18:06:20.789]  - exclude = 
[18:06:20.789]  - resignal = FALSE
[18:06:20.790]  - Number of conditions: 1
[18:06:20.790] signalConditions() ... done
[18:06:20.790] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:20.791] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[18:06:20.791] getGlobalsAndPackages() ...
[18:06:20.792] Searching for globals...
[18:06:20.795] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:20.796] Searching for globals ... DONE
[18:06:20.796] Resolving globals: FALSE
[18:06:20.797] 
[18:06:20.797] 
[18:06:20.798] getGlobalsAndPackages() ... DONE
[18:06:20.798] run() for ‘Future’ ...
[18:06:20.799] - state: ‘created’
[18:06:20.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:20.832] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:20.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:20.833]   - Field: ‘node’
[18:06:20.833]   - Field: ‘label’
[18:06:20.833]   - Field: ‘local’
[18:06:20.834]   - Field: ‘owner’
[18:06:20.834]   - Field: ‘envir’
[18:06:20.834]   - Field: ‘workers’
[18:06:20.834]   - Field: ‘packages’
[18:06:20.835]   - Field: ‘gc’
[18:06:20.835]   - Field: ‘conditions’
[18:06:20.835]   - Field: ‘persistent’
[18:06:20.836]   - Field: ‘expr’
[18:06:20.836]   - Field: ‘uuid’
[18:06:20.836]   - Field: ‘seed’
[18:06:20.836]   - Field: ‘version’
[18:06:20.837]   - Field: ‘result’
[18:06:20.837]   - Field: ‘asynchronous’
[18:06:20.837]   - Field: ‘calls’
[18:06:20.837]   - Field: ‘globals’
[18:06:20.838]   - Field: ‘stdout’
[18:06:20.838]   - Field: ‘earlySignal’
[18:06:20.838]   - Field: ‘lazy’
[18:06:20.838]   - Field: ‘state’
[18:06:20.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:20.839] - Launch lazy future ...
[18:06:20.840] Packages needed by the future expression (n = 0): <none>
[18:06:20.840] Packages needed by future strategies (n = 0): <none>
[18:06:20.841] {
[18:06:20.841]     {
[18:06:20.841]         {
[18:06:20.841]             ...future.startTime <- base::Sys.time()
[18:06:20.841]             {
[18:06:20.841]                 {
[18:06:20.841]                   {
[18:06:20.841]                     {
[18:06:20.841]                       base::local({
[18:06:20.841]                         has_future <- base::requireNamespace("future", 
[18:06:20.841]                           quietly = TRUE)
[18:06:20.841]                         if (has_future) {
[18:06:20.841]                           ns <- base::getNamespace("future")
[18:06:20.841]                           version <- ns[[".package"]][["version"]]
[18:06:20.841]                           if (is.null(version)) 
[18:06:20.841]                             version <- utils::packageVersion("future")
[18:06:20.841]                         }
[18:06:20.841]                         else {
[18:06:20.841]                           version <- NULL
[18:06:20.841]                         }
[18:06:20.841]                         if (!has_future || version < "1.8.0") {
[18:06:20.841]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:20.841]                             "", base::R.version$version.string), 
[18:06:20.841]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:20.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:20.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:20.841]                               "release", "version")], collapse = " "), 
[18:06:20.841]                             hostname = base::Sys.info()[["nodename"]])
[18:06:20.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:20.841]                             info)
[18:06:20.841]                           info <- base::paste(info, collapse = "; ")
[18:06:20.841]                           if (!has_future) {
[18:06:20.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:20.841]                               info)
[18:06:20.841]                           }
[18:06:20.841]                           else {
[18:06:20.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:20.841]                               info, version)
[18:06:20.841]                           }
[18:06:20.841]                           base::stop(msg)
[18:06:20.841]                         }
[18:06:20.841]                       })
[18:06:20.841]                     }
[18:06:20.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:20.841]                     base::options(mc.cores = 1L)
[18:06:20.841]                   }
[18:06:20.841]                   ...future.strategy.old <- future::plan("list")
[18:06:20.841]                   options(future.plan = NULL)
[18:06:20.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:20.841]                 }
[18:06:20.841]                 ...future.workdir <- getwd()
[18:06:20.841]             }
[18:06:20.841]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:20.841]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:20.841]         }
[18:06:20.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:20.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:20.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:20.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:20.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:20.841]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:20.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:20.841]             base::names(...future.oldOptions))
[18:06:20.841]     }
[18:06:20.841]     if (FALSE) {
[18:06:20.841]     }
[18:06:20.841]     else {
[18:06:20.841]         if (TRUE) {
[18:06:20.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:20.841]                 open = "w")
[18:06:20.841]         }
[18:06:20.841]         else {
[18:06:20.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:20.841]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:20.841]         }
[18:06:20.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:20.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:20.841]             base::sink(type = "output", split = FALSE)
[18:06:20.841]             base::close(...future.stdout)
[18:06:20.841]         }, add = TRUE)
[18:06:20.841]     }
[18:06:20.841]     ...future.frame <- base::sys.nframe()
[18:06:20.841]     ...future.conditions <- base::list()
[18:06:20.841]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:20.841]     if (FALSE) {
[18:06:20.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:20.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:20.841]     }
[18:06:20.841]     ...future.result <- base::tryCatch({
[18:06:20.841]         base::withCallingHandlers({
[18:06:20.841]             ...future.value <- base::withVisible(base::local({
[18:06:20.841]                 ...future.makeSendCondition <- base::local({
[18:06:20.841]                   sendCondition <- NULL
[18:06:20.841]                   function(frame = 1L) {
[18:06:20.841]                     if (is.function(sendCondition)) 
[18:06:20.841]                       return(sendCondition)
[18:06:20.841]                     ns <- getNamespace("parallel")
[18:06:20.841]                     if (exists("sendData", mode = "function", 
[18:06:20.841]                       envir = ns)) {
[18:06:20.841]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:20.841]                         envir = ns)
[18:06:20.841]                       envir <- sys.frame(frame)
[18:06:20.841]                       master <- NULL
[18:06:20.841]                       while (!identical(envir, .GlobalEnv) && 
[18:06:20.841]                         !identical(envir, emptyenv())) {
[18:06:20.841]                         if (exists("master", mode = "list", envir = envir, 
[18:06:20.841]                           inherits = FALSE)) {
[18:06:20.841]                           master <- get("master", mode = "list", 
[18:06:20.841]                             envir = envir, inherits = FALSE)
[18:06:20.841]                           if (inherits(master, c("SOCKnode", 
[18:06:20.841]                             "SOCK0node"))) {
[18:06:20.841]                             sendCondition <<- function(cond) {
[18:06:20.841]                               data <- list(type = "VALUE", value = cond, 
[18:06:20.841]                                 success = TRUE)
[18:06:20.841]                               parallel_sendData(master, data)
[18:06:20.841]                             }
[18:06:20.841]                             return(sendCondition)
[18:06:20.841]                           }
[18:06:20.841]                         }
[18:06:20.841]                         frame <- frame + 1L
[18:06:20.841]                         envir <- sys.frame(frame)
[18:06:20.841]                       }
[18:06:20.841]                     }
[18:06:20.841]                     sendCondition <<- function(cond) NULL
[18:06:20.841]                   }
[18:06:20.841]                 })
[18:06:20.841]                 withCallingHandlers({
[18:06:20.841]                   {
[18:06:20.841]                     Sys.sleep(0.5)
[18:06:20.841]                     list(a = 1, b = 42L)
[18:06:20.841]                   }
[18:06:20.841]                 }, immediateCondition = function(cond) {
[18:06:20.841]                   sendCondition <- ...future.makeSendCondition()
[18:06:20.841]                   sendCondition(cond)
[18:06:20.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.841]                   {
[18:06:20.841]                     inherits <- base::inherits
[18:06:20.841]                     invokeRestart <- base::invokeRestart
[18:06:20.841]                     is.null <- base::is.null
[18:06:20.841]                     muffled <- FALSE
[18:06:20.841]                     if (inherits(cond, "message")) {
[18:06:20.841]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:20.841]                       if (muffled) 
[18:06:20.841]                         invokeRestart("muffleMessage")
[18:06:20.841]                     }
[18:06:20.841]                     else if (inherits(cond, "warning")) {
[18:06:20.841]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:20.841]                       if (muffled) 
[18:06:20.841]                         invokeRestart("muffleWarning")
[18:06:20.841]                     }
[18:06:20.841]                     else if (inherits(cond, "condition")) {
[18:06:20.841]                       if (!is.null(pattern)) {
[18:06:20.841]                         computeRestarts <- base::computeRestarts
[18:06:20.841]                         grepl <- base::grepl
[18:06:20.841]                         restarts <- computeRestarts(cond)
[18:06:20.841]                         for (restart in restarts) {
[18:06:20.841]                           name <- restart$name
[18:06:20.841]                           if (is.null(name)) 
[18:06:20.841]                             next
[18:06:20.841]                           if (!grepl(pattern, name)) 
[18:06:20.841]                             next
[18:06:20.841]                           invokeRestart(restart)
[18:06:20.841]                           muffled <- TRUE
[18:06:20.841]                           break
[18:06:20.841]                         }
[18:06:20.841]                       }
[18:06:20.841]                     }
[18:06:20.841]                     invisible(muffled)
[18:06:20.841]                   }
[18:06:20.841]                   muffleCondition(cond)
[18:06:20.841]                 })
[18:06:20.841]             }))
[18:06:20.841]             future::FutureResult(value = ...future.value$value, 
[18:06:20.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.841]                   ...future.rng), globalenv = if (FALSE) 
[18:06:20.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:20.841]                     ...future.globalenv.names))
[18:06:20.841]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:20.841]         }, condition = base::local({
[18:06:20.841]             c <- base::c
[18:06:20.841]             inherits <- base::inherits
[18:06:20.841]             invokeRestart <- base::invokeRestart
[18:06:20.841]             length <- base::length
[18:06:20.841]             list <- base::list
[18:06:20.841]             seq.int <- base::seq.int
[18:06:20.841]             signalCondition <- base::signalCondition
[18:06:20.841]             sys.calls <- base::sys.calls
[18:06:20.841]             `[[` <- base::`[[`
[18:06:20.841]             `+` <- base::`+`
[18:06:20.841]             `<<-` <- base::`<<-`
[18:06:20.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:20.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:20.841]                   3L)]
[18:06:20.841]             }
[18:06:20.841]             function(cond) {
[18:06:20.841]                 is_error <- inherits(cond, "error")
[18:06:20.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:20.841]                   NULL)
[18:06:20.841]                 if (is_error) {
[18:06:20.841]                   sessionInformation <- function() {
[18:06:20.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:20.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:20.841]                       search = base::search(), system = base::Sys.info())
[18:06:20.841]                   }
[18:06:20.841]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:20.841]                     cond$call), session = sessionInformation(), 
[18:06:20.841]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:20.841]                   signalCondition(cond)
[18:06:20.841]                 }
[18:06:20.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:20.841]                 "immediateCondition"))) {
[18:06:20.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:20.841]                   ...future.conditions[[length(...future.conditions) + 
[18:06:20.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:20.841]                   if (TRUE && !signal) {
[18:06:20.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.841]                     {
[18:06:20.841]                       inherits <- base::inherits
[18:06:20.841]                       invokeRestart <- base::invokeRestart
[18:06:20.841]                       is.null <- base::is.null
[18:06:20.841]                       muffled <- FALSE
[18:06:20.841]                       if (inherits(cond, "message")) {
[18:06:20.841]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.841]                         if (muffled) 
[18:06:20.841]                           invokeRestart("muffleMessage")
[18:06:20.841]                       }
[18:06:20.841]                       else if (inherits(cond, "warning")) {
[18:06:20.841]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.841]                         if (muffled) 
[18:06:20.841]                           invokeRestart("muffleWarning")
[18:06:20.841]                       }
[18:06:20.841]                       else if (inherits(cond, "condition")) {
[18:06:20.841]                         if (!is.null(pattern)) {
[18:06:20.841]                           computeRestarts <- base::computeRestarts
[18:06:20.841]                           grepl <- base::grepl
[18:06:20.841]                           restarts <- computeRestarts(cond)
[18:06:20.841]                           for (restart in restarts) {
[18:06:20.841]                             name <- restart$name
[18:06:20.841]                             if (is.null(name)) 
[18:06:20.841]                               next
[18:06:20.841]                             if (!grepl(pattern, name)) 
[18:06:20.841]                               next
[18:06:20.841]                             invokeRestart(restart)
[18:06:20.841]                             muffled <- TRUE
[18:06:20.841]                             break
[18:06:20.841]                           }
[18:06:20.841]                         }
[18:06:20.841]                       }
[18:06:20.841]                       invisible(muffled)
[18:06:20.841]                     }
[18:06:20.841]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.841]                   }
[18:06:20.841]                 }
[18:06:20.841]                 else {
[18:06:20.841]                   if (TRUE) {
[18:06:20.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:20.841]                     {
[18:06:20.841]                       inherits <- base::inherits
[18:06:20.841]                       invokeRestart <- base::invokeRestart
[18:06:20.841]                       is.null <- base::is.null
[18:06:20.841]                       muffled <- FALSE
[18:06:20.841]                       if (inherits(cond, "message")) {
[18:06:20.841]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:20.841]                         if (muffled) 
[18:06:20.841]                           invokeRestart("muffleMessage")
[18:06:20.841]                       }
[18:06:20.841]                       else if (inherits(cond, "warning")) {
[18:06:20.841]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:20.841]                         if (muffled) 
[18:06:20.841]                           invokeRestart("muffleWarning")
[18:06:20.841]                       }
[18:06:20.841]                       else if (inherits(cond, "condition")) {
[18:06:20.841]                         if (!is.null(pattern)) {
[18:06:20.841]                           computeRestarts <- base::computeRestarts
[18:06:20.841]                           grepl <- base::grepl
[18:06:20.841]                           restarts <- computeRestarts(cond)
[18:06:20.841]                           for (restart in restarts) {
[18:06:20.841]                             name <- restart$name
[18:06:20.841]                             if (is.null(name)) 
[18:06:20.841]                               next
[18:06:20.841]                             if (!grepl(pattern, name)) 
[18:06:20.841]                               next
[18:06:20.841]                             invokeRestart(restart)
[18:06:20.841]                             muffled <- TRUE
[18:06:20.841]                             break
[18:06:20.841]                           }
[18:06:20.841]                         }
[18:06:20.841]                       }
[18:06:20.841]                       invisible(muffled)
[18:06:20.841]                     }
[18:06:20.841]                     muffleCondition(cond, pattern = "^muffle")
[18:06:20.841]                   }
[18:06:20.841]                 }
[18:06:20.841]             }
[18:06:20.841]         }))
[18:06:20.841]     }, error = function(ex) {
[18:06:20.841]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:20.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:20.841]                 ...future.rng), started = ...future.startTime, 
[18:06:20.841]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:20.841]             version = "1.8"), class = "FutureResult")
[18:06:20.841]     }, finally = {
[18:06:20.841]         if (!identical(...future.workdir, getwd())) 
[18:06:20.841]             setwd(...future.workdir)
[18:06:20.841]         {
[18:06:20.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:20.841]                 ...future.oldOptions$nwarnings <- NULL
[18:06:20.841]             }
[18:06:20.841]             base::options(...future.oldOptions)
[18:06:20.841]             if (.Platform$OS.type == "windows") {
[18:06:20.841]                 old_names <- names(...future.oldEnvVars)
[18:06:20.841]                 envs <- base::Sys.getenv()
[18:06:20.841]                 names <- names(envs)
[18:06:20.841]                 common <- intersect(names, old_names)
[18:06:20.841]                 added <- setdiff(names, old_names)
[18:06:20.841]                 removed <- setdiff(old_names, names)
[18:06:20.841]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:20.841]                   envs[common]]
[18:06:20.841]                 NAMES <- toupper(changed)
[18:06:20.841]                 args <- list()
[18:06:20.841]                 for (kk in seq_along(NAMES)) {
[18:06:20.841]                   name <- changed[[kk]]
[18:06:20.841]                   NAME <- NAMES[[kk]]
[18:06:20.841]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.841]                     next
[18:06:20.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.841]                 }
[18:06:20.841]                 NAMES <- toupper(added)
[18:06:20.841]                 for (kk in seq_along(NAMES)) {
[18:06:20.841]                   name <- added[[kk]]
[18:06:20.841]                   NAME <- NAMES[[kk]]
[18:06:20.841]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.841]                     next
[18:06:20.841]                   args[[name]] <- ""
[18:06:20.841]                 }
[18:06:20.841]                 NAMES <- toupper(removed)
[18:06:20.841]                 for (kk in seq_along(NAMES)) {
[18:06:20.841]                   name <- removed[[kk]]
[18:06:20.841]                   NAME <- NAMES[[kk]]
[18:06:20.841]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:20.841]                     next
[18:06:20.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:20.841]                 }
[18:06:20.841]                 if (length(args) > 0) 
[18:06:20.841]                   base::do.call(base::Sys.setenv, args = args)
[18:06:20.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:20.841]             }
[18:06:20.841]             else {
[18:06:20.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:20.841]             }
[18:06:20.841]             {
[18:06:20.841]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:20.841]                   0L) {
[18:06:20.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:20.841]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:20.841]                   base::options(opts)
[18:06:20.841]                 }
[18:06:20.841]                 {
[18:06:20.841]                   {
[18:06:20.841]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:20.841]                     NULL
[18:06:20.841]                   }
[18:06:20.841]                   options(future.plan = NULL)
[18:06:20.841]                   if (is.na(NA_character_)) 
[18:06:20.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:20.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:20.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:20.841]                     .init = FALSE)
[18:06:20.841]                 }
[18:06:20.841]             }
[18:06:20.841]         }
[18:06:20.841]     })
[18:06:20.841]     if (TRUE) {
[18:06:20.841]         base::sink(type = "output", split = FALSE)
[18:06:20.841]         if (TRUE) {
[18:06:20.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:20.841]         }
[18:06:20.841]         else {
[18:06:20.841]             ...future.result["stdout"] <- base::list(NULL)
[18:06:20.841]         }
[18:06:20.841]         base::close(...future.stdout)
[18:06:20.841]         ...future.stdout <- NULL
[18:06:20.841]     }
[18:06:20.841]     ...future.result$conditions <- ...future.conditions
[18:06:20.841]     ...future.result$finished <- base::Sys.time()
[18:06:20.841]     ...future.result
[18:06:20.841] }
[18:06:20.848] MultisessionFuture started
[18:06:20.848] - Launch lazy future ... done
[18:06:20.848] run() for ‘MultisessionFuture’ ... done
[18:06:21.391] receiveMessageFromWorker() for ClusterFuture ...
[18:06:21.392] - Validating connection of MultisessionFuture
[18:06:21.392] - received message: FutureResult
[18:06:21.393] - Received FutureResult
[18:06:21.393] - Erased future from FutureRegistry
[18:06:21.394] result() for ClusterFuture ...
[18:06:21.394] - result already collected: FutureResult
[18:06:21.394] result() for ClusterFuture ... done
[18:06:21.394] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:21.395] resolve() on list ...
[18:06:21.395]  recursive: 98
[18:06:21.395]  length: 2
[18:06:21.396]  elements: ‘a’, ‘b’
[18:06:21.396]  length: 1 (resolved future 1)
[18:06:21.397]  length: 0 (resolved future 2)
[18:06:21.397] resolve() on list ... DONE
[18:06:21.397] A MultisessionFuture was resolved (and resolved itself)
[18:06:21.397] getGlobalsAndPackages() ...
[18:06:21.398] Searching for globals...
[18:06:21.401] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:21.402] Searching for globals ... DONE
[18:06:21.402] Resolving globals: FALSE
[18:06:21.403] 
[18:06:21.403] 
[18:06:21.404] getGlobalsAndPackages() ... DONE
[18:06:21.404] run() for ‘Future’ ...
[18:06:21.405] - state: ‘created’
[18:06:21.405] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:21.435] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:21.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:21.436]   - Field: ‘node’
[18:06:21.436]   - Field: ‘label’
[18:06:21.436]   - Field: ‘local’
[18:06:21.436]   - Field: ‘owner’
[18:06:21.437]   - Field: ‘envir’
[18:06:21.437]   - Field: ‘workers’
[18:06:21.437]   - Field: ‘packages’
[18:06:21.437]   - Field: ‘gc’
[18:06:21.438]   - Field: ‘conditions’
[18:06:21.438]   - Field: ‘persistent’
[18:06:21.438]   - Field: ‘expr’
[18:06:21.438]   - Field: ‘uuid’
[18:06:21.439]   - Field: ‘seed’
[18:06:21.439]   - Field: ‘version’
[18:06:21.439]   - Field: ‘result’
[18:06:21.439]   - Field: ‘asynchronous’
[18:06:21.440]   - Field: ‘calls’
[18:06:21.440]   - Field: ‘globals’
[18:06:21.440]   - Field: ‘stdout’
[18:06:21.440]   - Field: ‘earlySignal’
[18:06:21.440]   - Field: ‘lazy’
[18:06:21.441]   - Field: ‘state’
[18:06:21.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:21.441] - Launch lazy future ...
[18:06:21.442] Packages needed by the future expression (n = 0): <none>
[18:06:21.442] Packages needed by future strategies (n = 0): <none>
[18:06:21.443] {
[18:06:21.443]     {
[18:06:21.443]         {
[18:06:21.443]             ...future.startTime <- base::Sys.time()
[18:06:21.443]             {
[18:06:21.443]                 {
[18:06:21.443]                   {
[18:06:21.443]                     {
[18:06:21.443]                       base::local({
[18:06:21.443]                         has_future <- base::requireNamespace("future", 
[18:06:21.443]                           quietly = TRUE)
[18:06:21.443]                         if (has_future) {
[18:06:21.443]                           ns <- base::getNamespace("future")
[18:06:21.443]                           version <- ns[[".package"]][["version"]]
[18:06:21.443]                           if (is.null(version)) 
[18:06:21.443]                             version <- utils::packageVersion("future")
[18:06:21.443]                         }
[18:06:21.443]                         else {
[18:06:21.443]                           version <- NULL
[18:06:21.443]                         }
[18:06:21.443]                         if (!has_future || version < "1.8.0") {
[18:06:21.443]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:21.443]                             "", base::R.version$version.string), 
[18:06:21.443]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:21.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:21.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:21.443]                               "release", "version")], collapse = " "), 
[18:06:21.443]                             hostname = base::Sys.info()[["nodename"]])
[18:06:21.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:21.443]                             info)
[18:06:21.443]                           info <- base::paste(info, collapse = "; ")
[18:06:21.443]                           if (!has_future) {
[18:06:21.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:21.443]                               info)
[18:06:21.443]                           }
[18:06:21.443]                           else {
[18:06:21.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:21.443]                               info, version)
[18:06:21.443]                           }
[18:06:21.443]                           base::stop(msg)
[18:06:21.443]                         }
[18:06:21.443]                       })
[18:06:21.443]                     }
[18:06:21.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:21.443]                     base::options(mc.cores = 1L)
[18:06:21.443]                   }
[18:06:21.443]                   ...future.strategy.old <- future::plan("list")
[18:06:21.443]                   options(future.plan = NULL)
[18:06:21.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:21.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:21.443]                 }
[18:06:21.443]                 ...future.workdir <- getwd()
[18:06:21.443]             }
[18:06:21.443]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:21.443]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:21.443]         }
[18:06:21.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:21.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:21.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:21.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:21.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:21.443]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:21.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:21.443]             base::names(...future.oldOptions))
[18:06:21.443]     }
[18:06:21.443]     if (FALSE) {
[18:06:21.443]     }
[18:06:21.443]     else {
[18:06:21.443]         if (TRUE) {
[18:06:21.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:21.443]                 open = "w")
[18:06:21.443]         }
[18:06:21.443]         else {
[18:06:21.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:21.443]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:21.443]         }
[18:06:21.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:21.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:21.443]             base::sink(type = "output", split = FALSE)
[18:06:21.443]             base::close(...future.stdout)
[18:06:21.443]         }, add = TRUE)
[18:06:21.443]     }
[18:06:21.443]     ...future.frame <- base::sys.nframe()
[18:06:21.443]     ...future.conditions <- base::list()
[18:06:21.443]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:21.443]     if (FALSE) {
[18:06:21.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:21.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:21.443]     }
[18:06:21.443]     ...future.result <- base::tryCatch({
[18:06:21.443]         base::withCallingHandlers({
[18:06:21.443]             ...future.value <- base::withVisible(base::local({
[18:06:21.443]                 ...future.makeSendCondition <- base::local({
[18:06:21.443]                   sendCondition <- NULL
[18:06:21.443]                   function(frame = 1L) {
[18:06:21.443]                     if (is.function(sendCondition)) 
[18:06:21.443]                       return(sendCondition)
[18:06:21.443]                     ns <- getNamespace("parallel")
[18:06:21.443]                     if (exists("sendData", mode = "function", 
[18:06:21.443]                       envir = ns)) {
[18:06:21.443]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:21.443]                         envir = ns)
[18:06:21.443]                       envir <- sys.frame(frame)
[18:06:21.443]                       master <- NULL
[18:06:21.443]                       while (!identical(envir, .GlobalEnv) && 
[18:06:21.443]                         !identical(envir, emptyenv())) {
[18:06:21.443]                         if (exists("master", mode = "list", envir = envir, 
[18:06:21.443]                           inherits = FALSE)) {
[18:06:21.443]                           master <- get("master", mode = "list", 
[18:06:21.443]                             envir = envir, inherits = FALSE)
[18:06:21.443]                           if (inherits(master, c("SOCKnode", 
[18:06:21.443]                             "SOCK0node"))) {
[18:06:21.443]                             sendCondition <<- function(cond) {
[18:06:21.443]                               data <- list(type = "VALUE", value = cond, 
[18:06:21.443]                                 success = TRUE)
[18:06:21.443]                               parallel_sendData(master, data)
[18:06:21.443]                             }
[18:06:21.443]                             return(sendCondition)
[18:06:21.443]                           }
[18:06:21.443]                         }
[18:06:21.443]                         frame <- frame + 1L
[18:06:21.443]                         envir <- sys.frame(frame)
[18:06:21.443]                       }
[18:06:21.443]                     }
[18:06:21.443]                     sendCondition <<- function(cond) NULL
[18:06:21.443]                   }
[18:06:21.443]                 })
[18:06:21.443]                 withCallingHandlers({
[18:06:21.443]                   {
[18:06:21.443]                     Sys.sleep(0.5)
[18:06:21.443]                     list(a = 1, b = 42L)
[18:06:21.443]                   }
[18:06:21.443]                 }, immediateCondition = function(cond) {
[18:06:21.443]                   sendCondition <- ...future.makeSendCondition()
[18:06:21.443]                   sendCondition(cond)
[18:06:21.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:21.443]                   {
[18:06:21.443]                     inherits <- base::inherits
[18:06:21.443]                     invokeRestart <- base::invokeRestart
[18:06:21.443]                     is.null <- base::is.null
[18:06:21.443]                     muffled <- FALSE
[18:06:21.443]                     if (inherits(cond, "message")) {
[18:06:21.443]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:21.443]                       if (muffled) 
[18:06:21.443]                         invokeRestart("muffleMessage")
[18:06:21.443]                     }
[18:06:21.443]                     else if (inherits(cond, "warning")) {
[18:06:21.443]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:21.443]                       if (muffled) 
[18:06:21.443]                         invokeRestart("muffleWarning")
[18:06:21.443]                     }
[18:06:21.443]                     else if (inherits(cond, "condition")) {
[18:06:21.443]                       if (!is.null(pattern)) {
[18:06:21.443]                         computeRestarts <- base::computeRestarts
[18:06:21.443]                         grepl <- base::grepl
[18:06:21.443]                         restarts <- computeRestarts(cond)
[18:06:21.443]                         for (restart in restarts) {
[18:06:21.443]                           name <- restart$name
[18:06:21.443]                           if (is.null(name)) 
[18:06:21.443]                             next
[18:06:21.443]                           if (!grepl(pattern, name)) 
[18:06:21.443]                             next
[18:06:21.443]                           invokeRestart(restart)
[18:06:21.443]                           muffled <- TRUE
[18:06:21.443]                           break
[18:06:21.443]                         }
[18:06:21.443]                       }
[18:06:21.443]                     }
[18:06:21.443]                     invisible(muffled)
[18:06:21.443]                   }
[18:06:21.443]                   muffleCondition(cond)
[18:06:21.443]                 })
[18:06:21.443]             }))
[18:06:21.443]             future::FutureResult(value = ...future.value$value, 
[18:06:21.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:21.443]                   ...future.rng), globalenv = if (FALSE) 
[18:06:21.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:21.443]                     ...future.globalenv.names))
[18:06:21.443]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:21.443]         }, condition = base::local({
[18:06:21.443]             c <- base::c
[18:06:21.443]             inherits <- base::inherits
[18:06:21.443]             invokeRestart <- base::invokeRestart
[18:06:21.443]             length <- base::length
[18:06:21.443]             list <- base::list
[18:06:21.443]             seq.int <- base::seq.int
[18:06:21.443]             signalCondition <- base::signalCondition
[18:06:21.443]             sys.calls <- base::sys.calls
[18:06:21.443]             `[[` <- base::`[[`
[18:06:21.443]             `+` <- base::`+`
[18:06:21.443]             `<<-` <- base::`<<-`
[18:06:21.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:21.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:21.443]                   3L)]
[18:06:21.443]             }
[18:06:21.443]             function(cond) {
[18:06:21.443]                 is_error <- inherits(cond, "error")
[18:06:21.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:21.443]                   NULL)
[18:06:21.443]                 if (is_error) {
[18:06:21.443]                   sessionInformation <- function() {
[18:06:21.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:21.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:21.443]                       search = base::search(), system = base::Sys.info())
[18:06:21.443]                   }
[18:06:21.443]                   ...future.conditions[[length(...future.conditions) + 
[18:06:21.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:21.443]                     cond$call), session = sessionInformation(), 
[18:06:21.443]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:21.443]                   signalCondition(cond)
[18:06:21.443]                 }
[18:06:21.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:21.443]                 "immediateCondition"))) {
[18:06:21.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:21.443]                   ...future.conditions[[length(...future.conditions) + 
[18:06:21.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:21.443]                   if (TRUE && !signal) {
[18:06:21.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:21.443]                     {
[18:06:21.443]                       inherits <- base::inherits
[18:06:21.443]                       invokeRestart <- base::invokeRestart
[18:06:21.443]                       is.null <- base::is.null
[18:06:21.443]                       muffled <- FALSE
[18:06:21.443]                       if (inherits(cond, "message")) {
[18:06:21.443]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:21.443]                         if (muffled) 
[18:06:21.443]                           invokeRestart("muffleMessage")
[18:06:21.443]                       }
[18:06:21.443]                       else if (inherits(cond, "warning")) {
[18:06:21.443]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:21.443]                         if (muffled) 
[18:06:21.443]                           invokeRestart("muffleWarning")
[18:06:21.443]                       }
[18:06:21.443]                       else if (inherits(cond, "condition")) {
[18:06:21.443]                         if (!is.null(pattern)) {
[18:06:21.443]                           computeRestarts <- base::computeRestarts
[18:06:21.443]                           grepl <- base::grepl
[18:06:21.443]                           restarts <- computeRestarts(cond)
[18:06:21.443]                           for (restart in restarts) {
[18:06:21.443]                             name <- restart$name
[18:06:21.443]                             if (is.null(name)) 
[18:06:21.443]                               next
[18:06:21.443]                             if (!grepl(pattern, name)) 
[18:06:21.443]                               next
[18:06:21.443]                             invokeRestart(restart)
[18:06:21.443]                             muffled <- TRUE
[18:06:21.443]                             break
[18:06:21.443]                           }
[18:06:21.443]                         }
[18:06:21.443]                       }
[18:06:21.443]                       invisible(muffled)
[18:06:21.443]                     }
[18:06:21.443]                     muffleCondition(cond, pattern = "^muffle")
[18:06:21.443]                   }
[18:06:21.443]                 }
[18:06:21.443]                 else {
[18:06:21.443]                   if (TRUE) {
[18:06:21.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:21.443]                     {
[18:06:21.443]                       inherits <- base::inherits
[18:06:21.443]                       invokeRestart <- base::invokeRestart
[18:06:21.443]                       is.null <- base::is.null
[18:06:21.443]                       muffled <- FALSE
[18:06:21.443]                       if (inherits(cond, "message")) {
[18:06:21.443]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:21.443]                         if (muffled) 
[18:06:21.443]                           invokeRestart("muffleMessage")
[18:06:21.443]                       }
[18:06:21.443]                       else if (inherits(cond, "warning")) {
[18:06:21.443]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:21.443]                         if (muffled) 
[18:06:21.443]                           invokeRestart("muffleWarning")
[18:06:21.443]                       }
[18:06:21.443]                       else if (inherits(cond, "condition")) {
[18:06:21.443]                         if (!is.null(pattern)) {
[18:06:21.443]                           computeRestarts <- base::computeRestarts
[18:06:21.443]                           grepl <- base::grepl
[18:06:21.443]                           restarts <- computeRestarts(cond)
[18:06:21.443]                           for (restart in restarts) {
[18:06:21.443]                             name <- restart$name
[18:06:21.443]                             if (is.null(name)) 
[18:06:21.443]                               next
[18:06:21.443]                             if (!grepl(pattern, name)) 
[18:06:21.443]                               next
[18:06:21.443]                             invokeRestart(restart)
[18:06:21.443]                             muffled <- TRUE
[18:06:21.443]                             break
[18:06:21.443]                           }
[18:06:21.443]                         }
[18:06:21.443]                       }
[18:06:21.443]                       invisible(muffled)
[18:06:21.443]                     }
[18:06:21.443]                     muffleCondition(cond, pattern = "^muffle")
[18:06:21.443]                   }
[18:06:21.443]                 }
[18:06:21.443]             }
[18:06:21.443]         }))
[18:06:21.443]     }, error = function(ex) {
[18:06:21.443]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:21.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:21.443]                 ...future.rng), started = ...future.startTime, 
[18:06:21.443]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:21.443]             version = "1.8"), class = "FutureResult")
[18:06:21.443]     }, finally = {
[18:06:21.443]         if (!identical(...future.workdir, getwd())) 
[18:06:21.443]             setwd(...future.workdir)
[18:06:21.443]         {
[18:06:21.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:21.443]                 ...future.oldOptions$nwarnings <- NULL
[18:06:21.443]             }
[18:06:21.443]             base::options(...future.oldOptions)
[18:06:21.443]             if (.Platform$OS.type == "windows") {
[18:06:21.443]                 old_names <- names(...future.oldEnvVars)
[18:06:21.443]                 envs <- base::Sys.getenv()
[18:06:21.443]                 names <- names(envs)
[18:06:21.443]                 common <- intersect(names, old_names)
[18:06:21.443]                 added <- setdiff(names, old_names)
[18:06:21.443]                 removed <- setdiff(old_names, names)
[18:06:21.443]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:21.443]                   envs[common]]
[18:06:21.443]                 NAMES <- toupper(changed)
[18:06:21.443]                 args <- list()
[18:06:21.443]                 for (kk in seq_along(NAMES)) {
[18:06:21.443]                   name <- changed[[kk]]
[18:06:21.443]                   NAME <- NAMES[[kk]]
[18:06:21.443]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:21.443]                     next
[18:06:21.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:21.443]                 }
[18:06:21.443]                 NAMES <- toupper(added)
[18:06:21.443]                 for (kk in seq_along(NAMES)) {
[18:06:21.443]                   name <- added[[kk]]
[18:06:21.443]                   NAME <- NAMES[[kk]]
[18:06:21.443]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:21.443]                     next
[18:06:21.443]                   args[[name]] <- ""
[18:06:21.443]                 }
[18:06:21.443]                 NAMES <- toupper(removed)
[18:06:21.443]                 for (kk in seq_along(NAMES)) {
[18:06:21.443]                   name <- removed[[kk]]
[18:06:21.443]                   NAME <- NAMES[[kk]]
[18:06:21.443]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:21.443]                     next
[18:06:21.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:21.443]                 }
[18:06:21.443]                 if (length(args) > 0) 
[18:06:21.443]                   base::do.call(base::Sys.setenv, args = args)
[18:06:21.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:21.443]             }
[18:06:21.443]             else {
[18:06:21.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:21.443]             }
[18:06:21.443]             {
[18:06:21.443]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:21.443]                   0L) {
[18:06:21.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:21.443]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:21.443]                   base::options(opts)
[18:06:21.443]                 }
[18:06:21.443]                 {
[18:06:21.443]                   {
[18:06:21.443]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:21.443]                     NULL
[18:06:21.443]                   }
[18:06:21.443]                   options(future.plan = NULL)
[18:06:21.443]                   if (is.na(NA_character_)) 
[18:06:21.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:21.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:21.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:21.443]                     .init = FALSE)
[18:06:21.443]                 }
[18:06:21.443]             }
[18:06:21.443]         }
[18:06:21.443]     })
[18:06:21.443]     if (TRUE) {
[18:06:21.443]         base::sink(type = "output", split = FALSE)
[18:06:21.443]         if (TRUE) {
[18:06:21.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:21.443]         }
[18:06:21.443]         else {
[18:06:21.443]             ...future.result["stdout"] <- base::list(NULL)
[18:06:21.443]         }
[18:06:21.443]         base::close(...future.stdout)
[18:06:21.443]         ...future.stdout <- NULL
[18:06:21.443]     }
[18:06:21.443]     ...future.result$conditions <- ...future.conditions
[18:06:21.443]     ...future.result$finished <- base::Sys.time()
[18:06:21.443]     ...future.result
[18:06:21.443] }
[18:06:21.450] MultisessionFuture started
[18:06:21.450] - Launch lazy future ... done
[18:06:21.451] run() for ‘MultisessionFuture’ ... done
[18:06:21.995] receiveMessageFromWorker() for ClusterFuture ...
[18:06:21.996] - Validating connection of MultisessionFuture
[18:06:21.997] - received message: FutureResult
[18:06:21.997] - Received FutureResult
[18:06:21.997] - Erased future from FutureRegistry
[18:06:21.998] result() for ClusterFuture ...
[18:06:21.998] - result already collected: FutureResult
[18:06:21.998] result() for ClusterFuture ... done
[18:06:21.999] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:21.999] resolve() on list ...
[18:06:21.999]  recursive: 98
[18:06:22.000]  length: 2
[18:06:22.000]  elements: ‘a’, ‘b’
[18:06:22.000]  length: 1 (resolved future 1)
[18:06:22.001]  length: 0 (resolved future 2)
[18:06:22.001] resolve() on list ... DONE
[18:06:22.001] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[18:06:22.002] getGlobalsAndPackages() ...
[18:06:22.002] Searching for globals...
[18:06:22.004] - globals found: [2] ‘list’, ‘stop’
[18:06:22.005] Searching for globals ... DONE
[18:06:22.005] Resolving globals: FALSE
[18:06:22.006] 
[18:06:22.006] 
[18:06:22.006] getGlobalsAndPackages() ... DONE
[18:06:22.007] run() for ‘Future’ ...
[18:06:22.008] - state: ‘created’
[18:06:22.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:22.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:22.045] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:22.045]   - Field: ‘node’
[18:06:22.046]   - Field: ‘label’
[18:06:22.046]   - Field: ‘local’
[18:06:22.046]   - Field: ‘owner’
[18:06:22.047]   - Field: ‘envir’
[18:06:22.047]   - Field: ‘workers’
[18:06:22.047]   - Field: ‘packages’
[18:06:22.048]   - Field: ‘gc’
[18:06:22.048]   - Field: ‘conditions’
[18:06:22.048]   - Field: ‘persistent’
[18:06:22.049]   - Field: ‘expr’
[18:06:22.049]   - Field: ‘uuid’
[18:06:22.049]   - Field: ‘seed’
[18:06:22.049]   - Field: ‘version’
[18:06:22.050]   - Field: ‘result’
[18:06:22.050]   - Field: ‘asynchronous’
[18:06:22.050]   - Field: ‘calls’
[18:06:22.051]   - Field: ‘globals’
[18:06:22.051]   - Field: ‘stdout’
[18:06:22.051]   - Field: ‘earlySignal’
[18:06:22.052]   - Field: ‘lazy’
[18:06:22.052]   - Field: ‘state’
[18:06:22.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:22.053] - Launch lazy future ...
[18:06:22.053] Packages needed by the future expression (n = 0): <none>
[18:06:22.054] Packages needed by future strategies (n = 0): <none>
[18:06:22.055] {
[18:06:22.055]     {
[18:06:22.055]         {
[18:06:22.055]             ...future.startTime <- base::Sys.time()
[18:06:22.055]             {
[18:06:22.055]                 {
[18:06:22.055]                   {
[18:06:22.055]                     {
[18:06:22.055]                       base::local({
[18:06:22.055]                         has_future <- base::requireNamespace("future", 
[18:06:22.055]                           quietly = TRUE)
[18:06:22.055]                         if (has_future) {
[18:06:22.055]                           ns <- base::getNamespace("future")
[18:06:22.055]                           version <- ns[[".package"]][["version"]]
[18:06:22.055]                           if (is.null(version)) 
[18:06:22.055]                             version <- utils::packageVersion("future")
[18:06:22.055]                         }
[18:06:22.055]                         else {
[18:06:22.055]                           version <- NULL
[18:06:22.055]                         }
[18:06:22.055]                         if (!has_future || version < "1.8.0") {
[18:06:22.055]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:22.055]                             "", base::R.version$version.string), 
[18:06:22.055]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:22.055]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:22.055]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:22.055]                               "release", "version")], collapse = " "), 
[18:06:22.055]                             hostname = base::Sys.info()[["nodename"]])
[18:06:22.055]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:22.055]                             info)
[18:06:22.055]                           info <- base::paste(info, collapse = "; ")
[18:06:22.055]                           if (!has_future) {
[18:06:22.055]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:22.055]                               info)
[18:06:22.055]                           }
[18:06:22.055]                           else {
[18:06:22.055]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:22.055]                               info, version)
[18:06:22.055]                           }
[18:06:22.055]                           base::stop(msg)
[18:06:22.055]                         }
[18:06:22.055]                       })
[18:06:22.055]                     }
[18:06:22.055]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:22.055]                     base::options(mc.cores = 1L)
[18:06:22.055]                   }
[18:06:22.055]                   ...future.strategy.old <- future::plan("list")
[18:06:22.055]                   options(future.plan = NULL)
[18:06:22.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:22.055]                 }
[18:06:22.055]                 ...future.workdir <- getwd()
[18:06:22.055]             }
[18:06:22.055]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:22.055]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:22.055]         }
[18:06:22.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:22.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:22.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:22.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:22.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:22.055]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:22.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:22.055]             base::names(...future.oldOptions))
[18:06:22.055]     }
[18:06:22.055]     if (FALSE) {
[18:06:22.055]     }
[18:06:22.055]     else {
[18:06:22.055]         if (TRUE) {
[18:06:22.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:22.055]                 open = "w")
[18:06:22.055]         }
[18:06:22.055]         else {
[18:06:22.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:22.055]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:22.055]         }
[18:06:22.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:22.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:22.055]             base::sink(type = "output", split = FALSE)
[18:06:22.055]             base::close(...future.stdout)
[18:06:22.055]         }, add = TRUE)
[18:06:22.055]     }
[18:06:22.055]     ...future.frame <- base::sys.nframe()
[18:06:22.055]     ...future.conditions <- base::list()
[18:06:22.055]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:22.055]     if (FALSE) {
[18:06:22.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:22.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:22.055]     }
[18:06:22.055]     ...future.result <- base::tryCatch({
[18:06:22.055]         base::withCallingHandlers({
[18:06:22.055]             ...future.value <- base::withVisible(base::local({
[18:06:22.055]                 ...future.makeSendCondition <- base::local({
[18:06:22.055]                   sendCondition <- NULL
[18:06:22.055]                   function(frame = 1L) {
[18:06:22.055]                     if (is.function(sendCondition)) 
[18:06:22.055]                       return(sendCondition)
[18:06:22.055]                     ns <- getNamespace("parallel")
[18:06:22.055]                     if (exists("sendData", mode = "function", 
[18:06:22.055]                       envir = ns)) {
[18:06:22.055]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:22.055]                         envir = ns)
[18:06:22.055]                       envir <- sys.frame(frame)
[18:06:22.055]                       master <- NULL
[18:06:22.055]                       while (!identical(envir, .GlobalEnv) && 
[18:06:22.055]                         !identical(envir, emptyenv())) {
[18:06:22.055]                         if (exists("master", mode = "list", envir = envir, 
[18:06:22.055]                           inherits = FALSE)) {
[18:06:22.055]                           master <- get("master", mode = "list", 
[18:06:22.055]                             envir = envir, inherits = FALSE)
[18:06:22.055]                           if (inherits(master, c("SOCKnode", 
[18:06:22.055]                             "SOCK0node"))) {
[18:06:22.055]                             sendCondition <<- function(cond) {
[18:06:22.055]                               data <- list(type = "VALUE", value = cond, 
[18:06:22.055]                                 success = TRUE)
[18:06:22.055]                               parallel_sendData(master, data)
[18:06:22.055]                             }
[18:06:22.055]                             return(sendCondition)
[18:06:22.055]                           }
[18:06:22.055]                         }
[18:06:22.055]                         frame <- frame + 1L
[18:06:22.055]                         envir <- sys.frame(frame)
[18:06:22.055]                       }
[18:06:22.055]                     }
[18:06:22.055]                     sendCondition <<- function(cond) NULL
[18:06:22.055]                   }
[18:06:22.055]                 })
[18:06:22.055]                 withCallingHandlers({
[18:06:22.055]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:22.055]                 }, immediateCondition = function(cond) {
[18:06:22.055]                   sendCondition <- ...future.makeSendCondition()
[18:06:22.055]                   sendCondition(cond)
[18:06:22.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.055]                   {
[18:06:22.055]                     inherits <- base::inherits
[18:06:22.055]                     invokeRestart <- base::invokeRestart
[18:06:22.055]                     is.null <- base::is.null
[18:06:22.055]                     muffled <- FALSE
[18:06:22.055]                     if (inherits(cond, "message")) {
[18:06:22.055]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:22.055]                       if (muffled) 
[18:06:22.055]                         invokeRestart("muffleMessage")
[18:06:22.055]                     }
[18:06:22.055]                     else if (inherits(cond, "warning")) {
[18:06:22.055]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:22.055]                       if (muffled) 
[18:06:22.055]                         invokeRestart("muffleWarning")
[18:06:22.055]                     }
[18:06:22.055]                     else if (inherits(cond, "condition")) {
[18:06:22.055]                       if (!is.null(pattern)) {
[18:06:22.055]                         computeRestarts <- base::computeRestarts
[18:06:22.055]                         grepl <- base::grepl
[18:06:22.055]                         restarts <- computeRestarts(cond)
[18:06:22.055]                         for (restart in restarts) {
[18:06:22.055]                           name <- restart$name
[18:06:22.055]                           if (is.null(name)) 
[18:06:22.055]                             next
[18:06:22.055]                           if (!grepl(pattern, name)) 
[18:06:22.055]                             next
[18:06:22.055]                           invokeRestart(restart)
[18:06:22.055]                           muffled <- TRUE
[18:06:22.055]                           break
[18:06:22.055]                         }
[18:06:22.055]                       }
[18:06:22.055]                     }
[18:06:22.055]                     invisible(muffled)
[18:06:22.055]                   }
[18:06:22.055]                   muffleCondition(cond)
[18:06:22.055]                 })
[18:06:22.055]             }))
[18:06:22.055]             future::FutureResult(value = ...future.value$value, 
[18:06:22.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.055]                   ...future.rng), globalenv = if (FALSE) 
[18:06:22.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:22.055]                     ...future.globalenv.names))
[18:06:22.055]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:22.055]         }, condition = base::local({
[18:06:22.055]             c <- base::c
[18:06:22.055]             inherits <- base::inherits
[18:06:22.055]             invokeRestart <- base::invokeRestart
[18:06:22.055]             length <- base::length
[18:06:22.055]             list <- base::list
[18:06:22.055]             seq.int <- base::seq.int
[18:06:22.055]             signalCondition <- base::signalCondition
[18:06:22.055]             sys.calls <- base::sys.calls
[18:06:22.055]             `[[` <- base::`[[`
[18:06:22.055]             `+` <- base::`+`
[18:06:22.055]             `<<-` <- base::`<<-`
[18:06:22.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:22.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:22.055]                   3L)]
[18:06:22.055]             }
[18:06:22.055]             function(cond) {
[18:06:22.055]                 is_error <- inherits(cond, "error")
[18:06:22.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:22.055]                   NULL)
[18:06:22.055]                 if (is_error) {
[18:06:22.055]                   sessionInformation <- function() {
[18:06:22.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:22.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:22.055]                       search = base::search(), system = base::Sys.info())
[18:06:22.055]                   }
[18:06:22.055]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:22.055]                     cond$call), session = sessionInformation(), 
[18:06:22.055]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:22.055]                   signalCondition(cond)
[18:06:22.055]                 }
[18:06:22.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:22.055]                 "immediateCondition"))) {
[18:06:22.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:22.055]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:22.055]                   if (TRUE && !signal) {
[18:06:22.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.055]                     {
[18:06:22.055]                       inherits <- base::inherits
[18:06:22.055]                       invokeRestart <- base::invokeRestart
[18:06:22.055]                       is.null <- base::is.null
[18:06:22.055]                       muffled <- FALSE
[18:06:22.055]                       if (inherits(cond, "message")) {
[18:06:22.055]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.055]                         if (muffled) 
[18:06:22.055]                           invokeRestart("muffleMessage")
[18:06:22.055]                       }
[18:06:22.055]                       else if (inherits(cond, "warning")) {
[18:06:22.055]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.055]                         if (muffled) 
[18:06:22.055]                           invokeRestart("muffleWarning")
[18:06:22.055]                       }
[18:06:22.055]                       else if (inherits(cond, "condition")) {
[18:06:22.055]                         if (!is.null(pattern)) {
[18:06:22.055]                           computeRestarts <- base::computeRestarts
[18:06:22.055]                           grepl <- base::grepl
[18:06:22.055]                           restarts <- computeRestarts(cond)
[18:06:22.055]                           for (restart in restarts) {
[18:06:22.055]                             name <- restart$name
[18:06:22.055]                             if (is.null(name)) 
[18:06:22.055]                               next
[18:06:22.055]                             if (!grepl(pattern, name)) 
[18:06:22.055]                               next
[18:06:22.055]                             invokeRestart(restart)
[18:06:22.055]                             muffled <- TRUE
[18:06:22.055]                             break
[18:06:22.055]                           }
[18:06:22.055]                         }
[18:06:22.055]                       }
[18:06:22.055]                       invisible(muffled)
[18:06:22.055]                     }
[18:06:22.055]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.055]                   }
[18:06:22.055]                 }
[18:06:22.055]                 else {
[18:06:22.055]                   if (TRUE) {
[18:06:22.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.055]                     {
[18:06:22.055]                       inherits <- base::inherits
[18:06:22.055]                       invokeRestart <- base::invokeRestart
[18:06:22.055]                       is.null <- base::is.null
[18:06:22.055]                       muffled <- FALSE
[18:06:22.055]                       if (inherits(cond, "message")) {
[18:06:22.055]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.055]                         if (muffled) 
[18:06:22.055]                           invokeRestart("muffleMessage")
[18:06:22.055]                       }
[18:06:22.055]                       else if (inherits(cond, "warning")) {
[18:06:22.055]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.055]                         if (muffled) 
[18:06:22.055]                           invokeRestart("muffleWarning")
[18:06:22.055]                       }
[18:06:22.055]                       else if (inherits(cond, "condition")) {
[18:06:22.055]                         if (!is.null(pattern)) {
[18:06:22.055]                           computeRestarts <- base::computeRestarts
[18:06:22.055]                           grepl <- base::grepl
[18:06:22.055]                           restarts <- computeRestarts(cond)
[18:06:22.055]                           for (restart in restarts) {
[18:06:22.055]                             name <- restart$name
[18:06:22.055]                             if (is.null(name)) 
[18:06:22.055]                               next
[18:06:22.055]                             if (!grepl(pattern, name)) 
[18:06:22.055]                               next
[18:06:22.055]                             invokeRestart(restart)
[18:06:22.055]                             muffled <- TRUE
[18:06:22.055]                             break
[18:06:22.055]                           }
[18:06:22.055]                         }
[18:06:22.055]                       }
[18:06:22.055]                       invisible(muffled)
[18:06:22.055]                     }
[18:06:22.055]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.055]                   }
[18:06:22.055]                 }
[18:06:22.055]             }
[18:06:22.055]         }))
[18:06:22.055]     }, error = function(ex) {
[18:06:22.055]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:22.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.055]                 ...future.rng), started = ...future.startTime, 
[18:06:22.055]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:22.055]             version = "1.8"), class = "FutureResult")
[18:06:22.055]     }, finally = {
[18:06:22.055]         if (!identical(...future.workdir, getwd())) 
[18:06:22.055]             setwd(...future.workdir)
[18:06:22.055]         {
[18:06:22.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:22.055]                 ...future.oldOptions$nwarnings <- NULL
[18:06:22.055]             }
[18:06:22.055]             base::options(...future.oldOptions)
[18:06:22.055]             if (.Platform$OS.type == "windows") {
[18:06:22.055]                 old_names <- names(...future.oldEnvVars)
[18:06:22.055]                 envs <- base::Sys.getenv()
[18:06:22.055]                 names <- names(envs)
[18:06:22.055]                 common <- intersect(names, old_names)
[18:06:22.055]                 added <- setdiff(names, old_names)
[18:06:22.055]                 removed <- setdiff(old_names, names)
[18:06:22.055]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:22.055]                   envs[common]]
[18:06:22.055]                 NAMES <- toupper(changed)
[18:06:22.055]                 args <- list()
[18:06:22.055]                 for (kk in seq_along(NAMES)) {
[18:06:22.055]                   name <- changed[[kk]]
[18:06:22.055]                   NAME <- NAMES[[kk]]
[18:06:22.055]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.055]                     next
[18:06:22.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.055]                 }
[18:06:22.055]                 NAMES <- toupper(added)
[18:06:22.055]                 for (kk in seq_along(NAMES)) {
[18:06:22.055]                   name <- added[[kk]]
[18:06:22.055]                   NAME <- NAMES[[kk]]
[18:06:22.055]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.055]                     next
[18:06:22.055]                   args[[name]] <- ""
[18:06:22.055]                 }
[18:06:22.055]                 NAMES <- toupper(removed)
[18:06:22.055]                 for (kk in seq_along(NAMES)) {
[18:06:22.055]                   name <- removed[[kk]]
[18:06:22.055]                   NAME <- NAMES[[kk]]
[18:06:22.055]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.055]                     next
[18:06:22.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.055]                 }
[18:06:22.055]                 if (length(args) > 0) 
[18:06:22.055]                   base::do.call(base::Sys.setenv, args = args)
[18:06:22.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:22.055]             }
[18:06:22.055]             else {
[18:06:22.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:22.055]             }
[18:06:22.055]             {
[18:06:22.055]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:22.055]                   0L) {
[18:06:22.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:22.055]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:22.055]                   base::options(opts)
[18:06:22.055]                 }
[18:06:22.055]                 {
[18:06:22.055]                   {
[18:06:22.055]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:22.055]                     NULL
[18:06:22.055]                   }
[18:06:22.055]                   options(future.plan = NULL)
[18:06:22.055]                   if (is.na(NA_character_)) 
[18:06:22.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:22.055]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:22.055]                     .init = FALSE)
[18:06:22.055]                 }
[18:06:22.055]             }
[18:06:22.055]         }
[18:06:22.055]     })
[18:06:22.055]     if (TRUE) {
[18:06:22.055]         base::sink(type = "output", split = FALSE)
[18:06:22.055]         if (TRUE) {
[18:06:22.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:22.055]         }
[18:06:22.055]         else {
[18:06:22.055]             ...future.result["stdout"] <- base::list(NULL)
[18:06:22.055]         }
[18:06:22.055]         base::close(...future.stdout)
[18:06:22.055]         ...future.stdout <- NULL
[18:06:22.055]     }
[18:06:22.055]     ...future.result$conditions <- ...future.conditions
[18:06:22.055]     ...future.result$finished <- base::Sys.time()
[18:06:22.055]     ...future.result
[18:06:22.055] }
[18:06:22.062] MultisessionFuture started
[18:06:22.064] - Launch lazy future ... done
[18:06:22.064] run() for ‘MultisessionFuture’ ... done
[18:06:22.108] receiveMessageFromWorker() for ClusterFuture ...
[18:06:22.109] - Validating connection of MultisessionFuture
[18:06:22.110] - received message: FutureResult
[18:06:22.110] - Received FutureResult
[18:06:22.111] - Erased future from FutureRegistry
[18:06:22.111] result() for ClusterFuture ...
[18:06:22.111] - result already collected: FutureResult
[18:06:22.111] result() for ClusterFuture ... done
[18:06:22.112] signalConditions() ...
[18:06:22.112]  - include = ‘immediateCondition’
[18:06:22.112]  - exclude = 
[18:06:22.113]  - resignal = FALSE
[18:06:22.113]  - Number of conditions: 1
[18:06:22.113] signalConditions() ... done
[18:06:22.114] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:22.114] A MultisessionFuture was resolved (and resolved itself)
[18:06:22.114] getGlobalsAndPackages() ...
[18:06:22.115] Searching for globals...
[18:06:22.117] - globals found: [2] ‘list’, ‘stop’
[18:06:22.117] Searching for globals ... DONE
[18:06:22.117] Resolving globals: FALSE
[18:06:22.118] 
[18:06:22.119] 
[18:06:22.119] getGlobalsAndPackages() ... DONE
[18:06:22.120] run() for ‘Future’ ...
[18:06:22.120] - state: ‘created’
[18:06:22.120] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:22.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:22.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:22.161]   - Field: ‘node’
[18:06:22.162]   - Field: ‘label’
[18:06:22.163]   - Field: ‘local’
[18:06:22.163]   - Field: ‘owner’
[18:06:22.163]   - Field: ‘envir’
[18:06:22.164]   - Field: ‘workers’
[18:06:22.164]   - Field: ‘packages’
[18:06:22.164]   - Field: ‘gc’
[18:06:22.165]   - Field: ‘conditions’
[18:06:22.165]   - Field: ‘persistent’
[18:06:22.165]   - Field: ‘expr’
[18:06:22.165]   - Field: ‘uuid’
[18:06:22.166]   - Field: ‘seed’
[18:06:22.166]   - Field: ‘version’
[18:06:22.166]   - Field: ‘result’
[18:06:22.167]   - Field: ‘asynchronous’
[18:06:22.167]   - Field: ‘calls’
[18:06:22.167]   - Field: ‘globals’
[18:06:22.167]   - Field: ‘stdout’
[18:06:22.168]   - Field: ‘earlySignal’
[18:06:22.168]   - Field: ‘lazy’
[18:06:22.168]   - Field: ‘state’
[18:06:22.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:22.169] - Launch lazy future ...
[18:06:22.169] Packages needed by the future expression (n = 0): <none>
[18:06:22.169] Packages needed by future strategies (n = 0): <none>
[18:06:22.170] {
[18:06:22.170]     {
[18:06:22.170]         {
[18:06:22.170]             ...future.startTime <- base::Sys.time()
[18:06:22.170]             {
[18:06:22.170]                 {
[18:06:22.170]                   {
[18:06:22.170]                     {
[18:06:22.170]                       base::local({
[18:06:22.170]                         has_future <- base::requireNamespace("future", 
[18:06:22.170]                           quietly = TRUE)
[18:06:22.170]                         if (has_future) {
[18:06:22.170]                           ns <- base::getNamespace("future")
[18:06:22.170]                           version <- ns[[".package"]][["version"]]
[18:06:22.170]                           if (is.null(version)) 
[18:06:22.170]                             version <- utils::packageVersion("future")
[18:06:22.170]                         }
[18:06:22.170]                         else {
[18:06:22.170]                           version <- NULL
[18:06:22.170]                         }
[18:06:22.170]                         if (!has_future || version < "1.8.0") {
[18:06:22.170]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:22.170]                             "", base::R.version$version.string), 
[18:06:22.170]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:22.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:22.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:22.170]                               "release", "version")], collapse = " "), 
[18:06:22.170]                             hostname = base::Sys.info()[["nodename"]])
[18:06:22.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:22.170]                             info)
[18:06:22.170]                           info <- base::paste(info, collapse = "; ")
[18:06:22.170]                           if (!has_future) {
[18:06:22.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:22.170]                               info)
[18:06:22.170]                           }
[18:06:22.170]                           else {
[18:06:22.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:22.170]                               info, version)
[18:06:22.170]                           }
[18:06:22.170]                           base::stop(msg)
[18:06:22.170]                         }
[18:06:22.170]                       })
[18:06:22.170]                     }
[18:06:22.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:22.170]                     base::options(mc.cores = 1L)
[18:06:22.170]                   }
[18:06:22.170]                   ...future.strategy.old <- future::plan("list")
[18:06:22.170]                   options(future.plan = NULL)
[18:06:22.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:22.170]                 }
[18:06:22.170]                 ...future.workdir <- getwd()
[18:06:22.170]             }
[18:06:22.170]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:22.170]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:22.170]         }
[18:06:22.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:22.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:22.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:22.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:22.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:22.170]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:22.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:22.170]             base::names(...future.oldOptions))
[18:06:22.170]     }
[18:06:22.170]     if (FALSE) {
[18:06:22.170]     }
[18:06:22.170]     else {
[18:06:22.170]         if (TRUE) {
[18:06:22.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:22.170]                 open = "w")
[18:06:22.170]         }
[18:06:22.170]         else {
[18:06:22.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:22.170]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:22.170]         }
[18:06:22.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:22.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:22.170]             base::sink(type = "output", split = FALSE)
[18:06:22.170]             base::close(...future.stdout)
[18:06:22.170]         }, add = TRUE)
[18:06:22.170]     }
[18:06:22.170]     ...future.frame <- base::sys.nframe()
[18:06:22.170]     ...future.conditions <- base::list()
[18:06:22.170]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:22.170]     if (FALSE) {
[18:06:22.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:22.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:22.170]     }
[18:06:22.170]     ...future.result <- base::tryCatch({
[18:06:22.170]         base::withCallingHandlers({
[18:06:22.170]             ...future.value <- base::withVisible(base::local({
[18:06:22.170]                 ...future.makeSendCondition <- base::local({
[18:06:22.170]                   sendCondition <- NULL
[18:06:22.170]                   function(frame = 1L) {
[18:06:22.170]                     if (is.function(sendCondition)) 
[18:06:22.170]                       return(sendCondition)
[18:06:22.170]                     ns <- getNamespace("parallel")
[18:06:22.170]                     if (exists("sendData", mode = "function", 
[18:06:22.170]                       envir = ns)) {
[18:06:22.170]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:22.170]                         envir = ns)
[18:06:22.170]                       envir <- sys.frame(frame)
[18:06:22.170]                       master <- NULL
[18:06:22.170]                       while (!identical(envir, .GlobalEnv) && 
[18:06:22.170]                         !identical(envir, emptyenv())) {
[18:06:22.170]                         if (exists("master", mode = "list", envir = envir, 
[18:06:22.170]                           inherits = FALSE)) {
[18:06:22.170]                           master <- get("master", mode = "list", 
[18:06:22.170]                             envir = envir, inherits = FALSE)
[18:06:22.170]                           if (inherits(master, c("SOCKnode", 
[18:06:22.170]                             "SOCK0node"))) {
[18:06:22.170]                             sendCondition <<- function(cond) {
[18:06:22.170]                               data <- list(type = "VALUE", value = cond, 
[18:06:22.170]                                 success = TRUE)
[18:06:22.170]                               parallel_sendData(master, data)
[18:06:22.170]                             }
[18:06:22.170]                             return(sendCondition)
[18:06:22.170]                           }
[18:06:22.170]                         }
[18:06:22.170]                         frame <- frame + 1L
[18:06:22.170]                         envir <- sys.frame(frame)
[18:06:22.170]                       }
[18:06:22.170]                     }
[18:06:22.170]                     sendCondition <<- function(cond) NULL
[18:06:22.170]                   }
[18:06:22.170]                 })
[18:06:22.170]                 withCallingHandlers({
[18:06:22.170]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:22.170]                 }, immediateCondition = function(cond) {
[18:06:22.170]                   sendCondition <- ...future.makeSendCondition()
[18:06:22.170]                   sendCondition(cond)
[18:06:22.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.170]                   {
[18:06:22.170]                     inherits <- base::inherits
[18:06:22.170]                     invokeRestart <- base::invokeRestart
[18:06:22.170]                     is.null <- base::is.null
[18:06:22.170]                     muffled <- FALSE
[18:06:22.170]                     if (inherits(cond, "message")) {
[18:06:22.170]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:22.170]                       if (muffled) 
[18:06:22.170]                         invokeRestart("muffleMessage")
[18:06:22.170]                     }
[18:06:22.170]                     else if (inherits(cond, "warning")) {
[18:06:22.170]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:22.170]                       if (muffled) 
[18:06:22.170]                         invokeRestart("muffleWarning")
[18:06:22.170]                     }
[18:06:22.170]                     else if (inherits(cond, "condition")) {
[18:06:22.170]                       if (!is.null(pattern)) {
[18:06:22.170]                         computeRestarts <- base::computeRestarts
[18:06:22.170]                         grepl <- base::grepl
[18:06:22.170]                         restarts <- computeRestarts(cond)
[18:06:22.170]                         for (restart in restarts) {
[18:06:22.170]                           name <- restart$name
[18:06:22.170]                           if (is.null(name)) 
[18:06:22.170]                             next
[18:06:22.170]                           if (!grepl(pattern, name)) 
[18:06:22.170]                             next
[18:06:22.170]                           invokeRestart(restart)
[18:06:22.170]                           muffled <- TRUE
[18:06:22.170]                           break
[18:06:22.170]                         }
[18:06:22.170]                       }
[18:06:22.170]                     }
[18:06:22.170]                     invisible(muffled)
[18:06:22.170]                   }
[18:06:22.170]                   muffleCondition(cond)
[18:06:22.170]                 })
[18:06:22.170]             }))
[18:06:22.170]             future::FutureResult(value = ...future.value$value, 
[18:06:22.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.170]                   ...future.rng), globalenv = if (FALSE) 
[18:06:22.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:22.170]                     ...future.globalenv.names))
[18:06:22.170]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:22.170]         }, condition = base::local({
[18:06:22.170]             c <- base::c
[18:06:22.170]             inherits <- base::inherits
[18:06:22.170]             invokeRestart <- base::invokeRestart
[18:06:22.170]             length <- base::length
[18:06:22.170]             list <- base::list
[18:06:22.170]             seq.int <- base::seq.int
[18:06:22.170]             signalCondition <- base::signalCondition
[18:06:22.170]             sys.calls <- base::sys.calls
[18:06:22.170]             `[[` <- base::`[[`
[18:06:22.170]             `+` <- base::`+`
[18:06:22.170]             `<<-` <- base::`<<-`
[18:06:22.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:22.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:22.170]                   3L)]
[18:06:22.170]             }
[18:06:22.170]             function(cond) {
[18:06:22.170]                 is_error <- inherits(cond, "error")
[18:06:22.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:22.170]                   NULL)
[18:06:22.170]                 if (is_error) {
[18:06:22.170]                   sessionInformation <- function() {
[18:06:22.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:22.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:22.170]                       search = base::search(), system = base::Sys.info())
[18:06:22.170]                   }
[18:06:22.170]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:22.170]                     cond$call), session = sessionInformation(), 
[18:06:22.170]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:22.170]                   signalCondition(cond)
[18:06:22.170]                 }
[18:06:22.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:22.170]                 "immediateCondition"))) {
[18:06:22.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:22.170]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:22.170]                   if (TRUE && !signal) {
[18:06:22.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.170]                     {
[18:06:22.170]                       inherits <- base::inherits
[18:06:22.170]                       invokeRestart <- base::invokeRestart
[18:06:22.170]                       is.null <- base::is.null
[18:06:22.170]                       muffled <- FALSE
[18:06:22.170]                       if (inherits(cond, "message")) {
[18:06:22.170]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.170]                         if (muffled) 
[18:06:22.170]                           invokeRestart("muffleMessage")
[18:06:22.170]                       }
[18:06:22.170]                       else if (inherits(cond, "warning")) {
[18:06:22.170]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.170]                         if (muffled) 
[18:06:22.170]                           invokeRestart("muffleWarning")
[18:06:22.170]                       }
[18:06:22.170]                       else if (inherits(cond, "condition")) {
[18:06:22.170]                         if (!is.null(pattern)) {
[18:06:22.170]                           computeRestarts <- base::computeRestarts
[18:06:22.170]                           grepl <- base::grepl
[18:06:22.170]                           restarts <- computeRestarts(cond)
[18:06:22.170]                           for (restart in restarts) {
[18:06:22.170]                             name <- restart$name
[18:06:22.170]                             if (is.null(name)) 
[18:06:22.170]                               next
[18:06:22.170]                             if (!grepl(pattern, name)) 
[18:06:22.170]                               next
[18:06:22.170]                             invokeRestart(restart)
[18:06:22.170]                             muffled <- TRUE
[18:06:22.170]                             break
[18:06:22.170]                           }
[18:06:22.170]                         }
[18:06:22.170]                       }
[18:06:22.170]                       invisible(muffled)
[18:06:22.170]                     }
[18:06:22.170]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.170]                   }
[18:06:22.170]                 }
[18:06:22.170]                 else {
[18:06:22.170]                   if (TRUE) {
[18:06:22.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.170]                     {
[18:06:22.170]                       inherits <- base::inherits
[18:06:22.170]                       invokeRestart <- base::invokeRestart
[18:06:22.170]                       is.null <- base::is.null
[18:06:22.170]                       muffled <- FALSE
[18:06:22.170]                       if (inherits(cond, "message")) {
[18:06:22.170]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.170]                         if (muffled) 
[18:06:22.170]                           invokeRestart("muffleMessage")
[18:06:22.170]                       }
[18:06:22.170]                       else if (inherits(cond, "warning")) {
[18:06:22.170]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.170]                         if (muffled) 
[18:06:22.170]                           invokeRestart("muffleWarning")
[18:06:22.170]                       }
[18:06:22.170]                       else if (inherits(cond, "condition")) {
[18:06:22.170]                         if (!is.null(pattern)) {
[18:06:22.170]                           computeRestarts <- base::computeRestarts
[18:06:22.170]                           grepl <- base::grepl
[18:06:22.170]                           restarts <- computeRestarts(cond)
[18:06:22.170]                           for (restart in restarts) {
[18:06:22.170]                             name <- restart$name
[18:06:22.170]                             if (is.null(name)) 
[18:06:22.170]                               next
[18:06:22.170]                             if (!grepl(pattern, name)) 
[18:06:22.170]                               next
[18:06:22.170]                             invokeRestart(restart)
[18:06:22.170]                             muffled <- TRUE
[18:06:22.170]                             break
[18:06:22.170]                           }
[18:06:22.170]                         }
[18:06:22.170]                       }
[18:06:22.170]                       invisible(muffled)
[18:06:22.170]                     }
[18:06:22.170]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.170]                   }
[18:06:22.170]                 }
[18:06:22.170]             }
[18:06:22.170]         }))
[18:06:22.170]     }, error = function(ex) {
[18:06:22.170]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:22.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.170]                 ...future.rng), started = ...future.startTime, 
[18:06:22.170]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:22.170]             version = "1.8"), class = "FutureResult")
[18:06:22.170]     }, finally = {
[18:06:22.170]         if (!identical(...future.workdir, getwd())) 
[18:06:22.170]             setwd(...future.workdir)
[18:06:22.170]         {
[18:06:22.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:22.170]                 ...future.oldOptions$nwarnings <- NULL
[18:06:22.170]             }
[18:06:22.170]             base::options(...future.oldOptions)
[18:06:22.170]             if (.Platform$OS.type == "windows") {
[18:06:22.170]                 old_names <- names(...future.oldEnvVars)
[18:06:22.170]                 envs <- base::Sys.getenv()
[18:06:22.170]                 names <- names(envs)
[18:06:22.170]                 common <- intersect(names, old_names)
[18:06:22.170]                 added <- setdiff(names, old_names)
[18:06:22.170]                 removed <- setdiff(old_names, names)
[18:06:22.170]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:22.170]                   envs[common]]
[18:06:22.170]                 NAMES <- toupper(changed)
[18:06:22.170]                 args <- list()
[18:06:22.170]                 for (kk in seq_along(NAMES)) {
[18:06:22.170]                   name <- changed[[kk]]
[18:06:22.170]                   NAME <- NAMES[[kk]]
[18:06:22.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.170]                     next
[18:06:22.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.170]                 }
[18:06:22.170]                 NAMES <- toupper(added)
[18:06:22.170]                 for (kk in seq_along(NAMES)) {
[18:06:22.170]                   name <- added[[kk]]
[18:06:22.170]                   NAME <- NAMES[[kk]]
[18:06:22.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.170]                     next
[18:06:22.170]                   args[[name]] <- ""
[18:06:22.170]                 }
[18:06:22.170]                 NAMES <- toupper(removed)
[18:06:22.170]                 for (kk in seq_along(NAMES)) {
[18:06:22.170]                   name <- removed[[kk]]
[18:06:22.170]                   NAME <- NAMES[[kk]]
[18:06:22.170]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.170]                     next
[18:06:22.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.170]                 }
[18:06:22.170]                 if (length(args) > 0) 
[18:06:22.170]                   base::do.call(base::Sys.setenv, args = args)
[18:06:22.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:22.170]             }
[18:06:22.170]             else {
[18:06:22.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:22.170]             }
[18:06:22.170]             {
[18:06:22.170]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:22.170]                   0L) {
[18:06:22.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:22.170]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:22.170]                   base::options(opts)
[18:06:22.170]                 }
[18:06:22.170]                 {
[18:06:22.170]                   {
[18:06:22.170]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:22.170]                     NULL
[18:06:22.170]                   }
[18:06:22.170]                   options(future.plan = NULL)
[18:06:22.170]                   if (is.na(NA_character_)) 
[18:06:22.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:22.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:22.170]                     .init = FALSE)
[18:06:22.170]                 }
[18:06:22.170]             }
[18:06:22.170]         }
[18:06:22.170]     })
[18:06:22.170]     if (TRUE) {
[18:06:22.170]         base::sink(type = "output", split = FALSE)
[18:06:22.170]         if (TRUE) {
[18:06:22.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:22.170]         }
[18:06:22.170]         else {
[18:06:22.170]             ...future.result["stdout"] <- base::list(NULL)
[18:06:22.170]         }
[18:06:22.170]         base::close(...future.stdout)
[18:06:22.170]         ...future.stdout <- NULL
[18:06:22.170]     }
[18:06:22.170]     ...future.result$conditions <- ...future.conditions
[18:06:22.170]     ...future.result$finished <- base::Sys.time()
[18:06:22.170]     ...future.result
[18:06:22.170] }
[18:06:22.177] MultisessionFuture started
[18:06:22.177] - Launch lazy future ... done
[18:06:22.177] run() for ‘MultisessionFuture’ ... done
[18:06:22.222] receiveMessageFromWorker() for ClusterFuture ...
[18:06:22.222] - Validating connection of MultisessionFuture
[18:06:22.223] - received message: FutureResult
[18:06:22.224] - Received FutureResult
[18:06:22.224] - Erased future from FutureRegistry
[18:06:22.224] result() for ClusterFuture ...
[18:06:22.225] - result already collected: FutureResult
[18:06:22.225] result() for ClusterFuture ... done
[18:06:22.225] signalConditions() ...
[18:06:22.226]  - include = ‘immediateCondition’
[18:06:22.226]  - exclude = 
[18:06:22.226]  - resignal = FALSE
[18:06:22.226]  - Number of conditions: 1
[18:06:22.227] signalConditions() ... done
[18:06:22.227] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:22.227] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[18:06:22.228] getGlobalsAndPackages() ...
[18:06:22.228] Searching for globals...
[18:06:22.231] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:22.232] Searching for globals ... DONE
[18:06:22.232] Resolving globals: FALSE
[18:06:22.233] 
[18:06:22.233] 
[18:06:22.234] getGlobalsAndPackages() ... DONE
[18:06:22.234] run() for ‘Future’ ...
[18:06:22.235] - state: ‘created’
[18:06:22.235] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:22.268] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:22.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:22.269]   - Field: ‘node’
[18:06:22.269]   - Field: ‘label’
[18:06:22.269]   - Field: ‘local’
[18:06:22.270]   - Field: ‘owner’
[18:06:22.270]   - Field: ‘envir’
[18:06:22.270]   - Field: ‘workers’
[18:06:22.270]   - Field: ‘packages’
[18:06:22.271]   - Field: ‘gc’
[18:06:22.271]   - Field: ‘conditions’
[18:06:22.271]   - Field: ‘persistent’
[18:06:22.271]   - Field: ‘expr’
[18:06:22.272]   - Field: ‘uuid’
[18:06:22.272]   - Field: ‘seed’
[18:06:22.272]   - Field: ‘version’
[18:06:22.272]   - Field: ‘result’
[18:06:22.273]   - Field: ‘asynchronous’
[18:06:22.273]   - Field: ‘calls’
[18:06:22.273]   - Field: ‘globals’
[18:06:22.273]   - Field: ‘stdout’
[18:06:22.274]   - Field: ‘earlySignal’
[18:06:22.274]   - Field: ‘lazy’
[18:06:22.274]   - Field: ‘state’
[18:06:22.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:22.275] - Launch lazy future ...
[18:06:22.275] Packages needed by the future expression (n = 0): <none>
[18:06:22.275] Packages needed by future strategies (n = 0): <none>
[18:06:22.276] {
[18:06:22.276]     {
[18:06:22.276]         {
[18:06:22.276]             ...future.startTime <- base::Sys.time()
[18:06:22.276]             {
[18:06:22.276]                 {
[18:06:22.276]                   {
[18:06:22.276]                     {
[18:06:22.276]                       base::local({
[18:06:22.276]                         has_future <- base::requireNamespace("future", 
[18:06:22.276]                           quietly = TRUE)
[18:06:22.276]                         if (has_future) {
[18:06:22.276]                           ns <- base::getNamespace("future")
[18:06:22.276]                           version <- ns[[".package"]][["version"]]
[18:06:22.276]                           if (is.null(version)) 
[18:06:22.276]                             version <- utils::packageVersion("future")
[18:06:22.276]                         }
[18:06:22.276]                         else {
[18:06:22.276]                           version <- NULL
[18:06:22.276]                         }
[18:06:22.276]                         if (!has_future || version < "1.8.0") {
[18:06:22.276]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:22.276]                             "", base::R.version$version.string), 
[18:06:22.276]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:22.276]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:22.276]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:22.276]                               "release", "version")], collapse = " "), 
[18:06:22.276]                             hostname = base::Sys.info()[["nodename"]])
[18:06:22.276]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:22.276]                             info)
[18:06:22.276]                           info <- base::paste(info, collapse = "; ")
[18:06:22.276]                           if (!has_future) {
[18:06:22.276]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:22.276]                               info)
[18:06:22.276]                           }
[18:06:22.276]                           else {
[18:06:22.276]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:22.276]                               info, version)
[18:06:22.276]                           }
[18:06:22.276]                           base::stop(msg)
[18:06:22.276]                         }
[18:06:22.276]                       })
[18:06:22.276]                     }
[18:06:22.276]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:22.276]                     base::options(mc.cores = 1L)
[18:06:22.276]                   }
[18:06:22.276]                   ...future.strategy.old <- future::plan("list")
[18:06:22.276]                   options(future.plan = NULL)
[18:06:22.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:22.276]                 }
[18:06:22.276]                 ...future.workdir <- getwd()
[18:06:22.276]             }
[18:06:22.276]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:22.276]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:22.276]         }
[18:06:22.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:22.276]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:22.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:22.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:22.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:22.276]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:22.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:22.276]             base::names(...future.oldOptions))
[18:06:22.276]     }
[18:06:22.276]     if (FALSE) {
[18:06:22.276]     }
[18:06:22.276]     else {
[18:06:22.276]         if (TRUE) {
[18:06:22.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:22.276]                 open = "w")
[18:06:22.276]         }
[18:06:22.276]         else {
[18:06:22.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:22.276]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:22.276]         }
[18:06:22.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:22.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:22.276]             base::sink(type = "output", split = FALSE)
[18:06:22.276]             base::close(...future.stdout)
[18:06:22.276]         }, add = TRUE)
[18:06:22.276]     }
[18:06:22.276]     ...future.frame <- base::sys.nframe()
[18:06:22.276]     ...future.conditions <- base::list()
[18:06:22.276]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:22.276]     if (FALSE) {
[18:06:22.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:22.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:22.276]     }
[18:06:22.276]     ...future.result <- base::tryCatch({
[18:06:22.276]         base::withCallingHandlers({
[18:06:22.276]             ...future.value <- base::withVisible(base::local({
[18:06:22.276]                 ...future.makeSendCondition <- base::local({
[18:06:22.276]                   sendCondition <- NULL
[18:06:22.276]                   function(frame = 1L) {
[18:06:22.276]                     if (is.function(sendCondition)) 
[18:06:22.276]                       return(sendCondition)
[18:06:22.276]                     ns <- getNamespace("parallel")
[18:06:22.276]                     if (exists("sendData", mode = "function", 
[18:06:22.276]                       envir = ns)) {
[18:06:22.276]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:22.276]                         envir = ns)
[18:06:22.276]                       envir <- sys.frame(frame)
[18:06:22.276]                       master <- NULL
[18:06:22.276]                       while (!identical(envir, .GlobalEnv) && 
[18:06:22.276]                         !identical(envir, emptyenv())) {
[18:06:22.276]                         if (exists("master", mode = "list", envir = envir, 
[18:06:22.276]                           inherits = FALSE)) {
[18:06:22.276]                           master <- get("master", mode = "list", 
[18:06:22.276]                             envir = envir, inherits = FALSE)
[18:06:22.276]                           if (inherits(master, c("SOCKnode", 
[18:06:22.276]                             "SOCK0node"))) {
[18:06:22.276]                             sendCondition <<- function(cond) {
[18:06:22.276]                               data <- list(type = "VALUE", value = cond, 
[18:06:22.276]                                 success = TRUE)
[18:06:22.276]                               parallel_sendData(master, data)
[18:06:22.276]                             }
[18:06:22.276]                             return(sendCondition)
[18:06:22.276]                           }
[18:06:22.276]                         }
[18:06:22.276]                         frame <- frame + 1L
[18:06:22.276]                         envir <- sys.frame(frame)
[18:06:22.276]                       }
[18:06:22.276]                     }
[18:06:22.276]                     sendCondition <<- function(cond) NULL
[18:06:22.276]                   }
[18:06:22.276]                 })
[18:06:22.276]                 withCallingHandlers({
[18:06:22.276]                   {
[18:06:22.276]                     Sys.sleep(0.5)
[18:06:22.276]                     list(a = 1, b = 42L)
[18:06:22.276]                   }
[18:06:22.276]                 }, immediateCondition = function(cond) {
[18:06:22.276]                   sendCondition <- ...future.makeSendCondition()
[18:06:22.276]                   sendCondition(cond)
[18:06:22.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.276]                   {
[18:06:22.276]                     inherits <- base::inherits
[18:06:22.276]                     invokeRestart <- base::invokeRestart
[18:06:22.276]                     is.null <- base::is.null
[18:06:22.276]                     muffled <- FALSE
[18:06:22.276]                     if (inherits(cond, "message")) {
[18:06:22.276]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:22.276]                       if (muffled) 
[18:06:22.276]                         invokeRestart("muffleMessage")
[18:06:22.276]                     }
[18:06:22.276]                     else if (inherits(cond, "warning")) {
[18:06:22.276]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:22.276]                       if (muffled) 
[18:06:22.276]                         invokeRestart("muffleWarning")
[18:06:22.276]                     }
[18:06:22.276]                     else if (inherits(cond, "condition")) {
[18:06:22.276]                       if (!is.null(pattern)) {
[18:06:22.276]                         computeRestarts <- base::computeRestarts
[18:06:22.276]                         grepl <- base::grepl
[18:06:22.276]                         restarts <- computeRestarts(cond)
[18:06:22.276]                         for (restart in restarts) {
[18:06:22.276]                           name <- restart$name
[18:06:22.276]                           if (is.null(name)) 
[18:06:22.276]                             next
[18:06:22.276]                           if (!grepl(pattern, name)) 
[18:06:22.276]                             next
[18:06:22.276]                           invokeRestart(restart)
[18:06:22.276]                           muffled <- TRUE
[18:06:22.276]                           break
[18:06:22.276]                         }
[18:06:22.276]                       }
[18:06:22.276]                     }
[18:06:22.276]                     invisible(muffled)
[18:06:22.276]                   }
[18:06:22.276]                   muffleCondition(cond)
[18:06:22.276]                 })
[18:06:22.276]             }))
[18:06:22.276]             future::FutureResult(value = ...future.value$value, 
[18:06:22.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.276]                   ...future.rng), globalenv = if (FALSE) 
[18:06:22.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:22.276]                     ...future.globalenv.names))
[18:06:22.276]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:22.276]         }, condition = base::local({
[18:06:22.276]             c <- base::c
[18:06:22.276]             inherits <- base::inherits
[18:06:22.276]             invokeRestart <- base::invokeRestart
[18:06:22.276]             length <- base::length
[18:06:22.276]             list <- base::list
[18:06:22.276]             seq.int <- base::seq.int
[18:06:22.276]             signalCondition <- base::signalCondition
[18:06:22.276]             sys.calls <- base::sys.calls
[18:06:22.276]             `[[` <- base::`[[`
[18:06:22.276]             `+` <- base::`+`
[18:06:22.276]             `<<-` <- base::`<<-`
[18:06:22.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:22.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:22.276]                   3L)]
[18:06:22.276]             }
[18:06:22.276]             function(cond) {
[18:06:22.276]                 is_error <- inherits(cond, "error")
[18:06:22.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:22.276]                   NULL)
[18:06:22.276]                 if (is_error) {
[18:06:22.276]                   sessionInformation <- function() {
[18:06:22.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:22.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:22.276]                       search = base::search(), system = base::Sys.info())
[18:06:22.276]                   }
[18:06:22.276]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:22.276]                     cond$call), session = sessionInformation(), 
[18:06:22.276]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:22.276]                   signalCondition(cond)
[18:06:22.276]                 }
[18:06:22.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:22.276]                 "immediateCondition"))) {
[18:06:22.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:22.276]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:22.276]                   if (TRUE && !signal) {
[18:06:22.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.276]                     {
[18:06:22.276]                       inherits <- base::inherits
[18:06:22.276]                       invokeRestart <- base::invokeRestart
[18:06:22.276]                       is.null <- base::is.null
[18:06:22.276]                       muffled <- FALSE
[18:06:22.276]                       if (inherits(cond, "message")) {
[18:06:22.276]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.276]                         if (muffled) 
[18:06:22.276]                           invokeRestart("muffleMessage")
[18:06:22.276]                       }
[18:06:22.276]                       else if (inherits(cond, "warning")) {
[18:06:22.276]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.276]                         if (muffled) 
[18:06:22.276]                           invokeRestart("muffleWarning")
[18:06:22.276]                       }
[18:06:22.276]                       else if (inherits(cond, "condition")) {
[18:06:22.276]                         if (!is.null(pattern)) {
[18:06:22.276]                           computeRestarts <- base::computeRestarts
[18:06:22.276]                           grepl <- base::grepl
[18:06:22.276]                           restarts <- computeRestarts(cond)
[18:06:22.276]                           for (restart in restarts) {
[18:06:22.276]                             name <- restart$name
[18:06:22.276]                             if (is.null(name)) 
[18:06:22.276]                               next
[18:06:22.276]                             if (!grepl(pattern, name)) 
[18:06:22.276]                               next
[18:06:22.276]                             invokeRestart(restart)
[18:06:22.276]                             muffled <- TRUE
[18:06:22.276]                             break
[18:06:22.276]                           }
[18:06:22.276]                         }
[18:06:22.276]                       }
[18:06:22.276]                       invisible(muffled)
[18:06:22.276]                     }
[18:06:22.276]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.276]                   }
[18:06:22.276]                 }
[18:06:22.276]                 else {
[18:06:22.276]                   if (TRUE) {
[18:06:22.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.276]                     {
[18:06:22.276]                       inherits <- base::inherits
[18:06:22.276]                       invokeRestart <- base::invokeRestart
[18:06:22.276]                       is.null <- base::is.null
[18:06:22.276]                       muffled <- FALSE
[18:06:22.276]                       if (inherits(cond, "message")) {
[18:06:22.276]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.276]                         if (muffled) 
[18:06:22.276]                           invokeRestart("muffleMessage")
[18:06:22.276]                       }
[18:06:22.276]                       else if (inherits(cond, "warning")) {
[18:06:22.276]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.276]                         if (muffled) 
[18:06:22.276]                           invokeRestart("muffleWarning")
[18:06:22.276]                       }
[18:06:22.276]                       else if (inherits(cond, "condition")) {
[18:06:22.276]                         if (!is.null(pattern)) {
[18:06:22.276]                           computeRestarts <- base::computeRestarts
[18:06:22.276]                           grepl <- base::grepl
[18:06:22.276]                           restarts <- computeRestarts(cond)
[18:06:22.276]                           for (restart in restarts) {
[18:06:22.276]                             name <- restart$name
[18:06:22.276]                             if (is.null(name)) 
[18:06:22.276]                               next
[18:06:22.276]                             if (!grepl(pattern, name)) 
[18:06:22.276]                               next
[18:06:22.276]                             invokeRestart(restart)
[18:06:22.276]                             muffled <- TRUE
[18:06:22.276]                             break
[18:06:22.276]                           }
[18:06:22.276]                         }
[18:06:22.276]                       }
[18:06:22.276]                       invisible(muffled)
[18:06:22.276]                     }
[18:06:22.276]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.276]                   }
[18:06:22.276]                 }
[18:06:22.276]             }
[18:06:22.276]         }))
[18:06:22.276]     }, error = function(ex) {
[18:06:22.276]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:22.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.276]                 ...future.rng), started = ...future.startTime, 
[18:06:22.276]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:22.276]             version = "1.8"), class = "FutureResult")
[18:06:22.276]     }, finally = {
[18:06:22.276]         if (!identical(...future.workdir, getwd())) 
[18:06:22.276]             setwd(...future.workdir)
[18:06:22.276]         {
[18:06:22.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:22.276]                 ...future.oldOptions$nwarnings <- NULL
[18:06:22.276]             }
[18:06:22.276]             base::options(...future.oldOptions)
[18:06:22.276]             if (.Platform$OS.type == "windows") {
[18:06:22.276]                 old_names <- names(...future.oldEnvVars)
[18:06:22.276]                 envs <- base::Sys.getenv()
[18:06:22.276]                 names <- names(envs)
[18:06:22.276]                 common <- intersect(names, old_names)
[18:06:22.276]                 added <- setdiff(names, old_names)
[18:06:22.276]                 removed <- setdiff(old_names, names)
[18:06:22.276]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:22.276]                   envs[common]]
[18:06:22.276]                 NAMES <- toupper(changed)
[18:06:22.276]                 args <- list()
[18:06:22.276]                 for (kk in seq_along(NAMES)) {
[18:06:22.276]                   name <- changed[[kk]]
[18:06:22.276]                   NAME <- NAMES[[kk]]
[18:06:22.276]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.276]                     next
[18:06:22.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.276]                 }
[18:06:22.276]                 NAMES <- toupper(added)
[18:06:22.276]                 for (kk in seq_along(NAMES)) {
[18:06:22.276]                   name <- added[[kk]]
[18:06:22.276]                   NAME <- NAMES[[kk]]
[18:06:22.276]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.276]                     next
[18:06:22.276]                   args[[name]] <- ""
[18:06:22.276]                 }
[18:06:22.276]                 NAMES <- toupper(removed)
[18:06:22.276]                 for (kk in seq_along(NAMES)) {
[18:06:22.276]                   name <- removed[[kk]]
[18:06:22.276]                   NAME <- NAMES[[kk]]
[18:06:22.276]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.276]                     next
[18:06:22.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.276]                 }
[18:06:22.276]                 if (length(args) > 0) 
[18:06:22.276]                   base::do.call(base::Sys.setenv, args = args)
[18:06:22.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:22.276]             }
[18:06:22.276]             else {
[18:06:22.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:22.276]             }
[18:06:22.276]             {
[18:06:22.276]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:22.276]                   0L) {
[18:06:22.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:22.276]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:22.276]                   base::options(opts)
[18:06:22.276]                 }
[18:06:22.276]                 {
[18:06:22.276]                   {
[18:06:22.276]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:22.276]                     NULL
[18:06:22.276]                   }
[18:06:22.276]                   options(future.plan = NULL)
[18:06:22.276]                   if (is.na(NA_character_)) 
[18:06:22.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:22.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:22.276]                     .init = FALSE)
[18:06:22.276]                 }
[18:06:22.276]             }
[18:06:22.276]         }
[18:06:22.276]     })
[18:06:22.276]     if (TRUE) {
[18:06:22.276]         base::sink(type = "output", split = FALSE)
[18:06:22.276]         if (TRUE) {
[18:06:22.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:22.276]         }
[18:06:22.276]         else {
[18:06:22.276]             ...future.result["stdout"] <- base::list(NULL)
[18:06:22.276]         }
[18:06:22.276]         base::close(...future.stdout)
[18:06:22.276]         ...future.stdout <- NULL
[18:06:22.276]     }
[18:06:22.276]     ...future.result$conditions <- ...future.conditions
[18:06:22.276]     ...future.result$finished <- base::Sys.time()
[18:06:22.276]     ...future.result
[18:06:22.276] }
[18:06:22.283] MultisessionFuture started
[18:06:22.283] - Launch lazy future ... done
[18:06:22.283] run() for ‘MultisessionFuture’ ... done
[18:06:22.284] getGlobalsAndPackages() ...
[18:06:22.284] Searching for globals...
[18:06:22.287] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:22.287] Searching for globals ... DONE
[18:06:22.287] Resolving globals: FALSE
[18:06:22.288] 
[18:06:22.288] 
[18:06:22.289] getGlobalsAndPackages() ... DONE
- w/ exception ...
[18:06:22.289] getGlobalsAndPackages() ...
[18:06:22.289] Searching for globals...
[18:06:22.291] - globals found: [2] ‘list’, ‘stop’
[18:06:22.291] Searching for globals ... DONE
[18:06:22.291] Resolving globals: FALSE
[18:06:22.293] 
[18:06:22.293] 
[18:06:22.293] getGlobalsAndPackages() ... DONE
[18:06:22.294] run() for ‘Future’ ...
[18:06:22.294] - state: ‘created’
[18:06:22.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:22.322] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:22.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:22.323]   - Field: ‘node’
[18:06:22.323]   - Field: ‘label’
[18:06:22.323]   - Field: ‘local’
[18:06:22.324]   - Field: ‘owner’
[18:06:22.324]   - Field: ‘envir’
[18:06:22.324]   - Field: ‘workers’
[18:06:22.324]   - Field: ‘packages’
[18:06:22.325]   - Field: ‘gc’
[18:06:22.325]   - Field: ‘conditions’
[18:06:22.325]   - Field: ‘persistent’
[18:06:22.325]   - Field: ‘expr’
[18:06:22.326]   - Field: ‘uuid’
[18:06:22.326]   - Field: ‘seed’
[18:06:22.326]   - Field: ‘version’
[18:06:22.326]   - Field: ‘result’
[18:06:22.326]   - Field: ‘asynchronous’
[18:06:22.327]   - Field: ‘calls’
[18:06:22.327]   - Field: ‘globals’
[18:06:22.327]   - Field: ‘stdout’
[18:06:22.327]   - Field: ‘earlySignal’
[18:06:22.327]   - Field: ‘lazy’
[18:06:22.328]   - Field: ‘state’
[18:06:22.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:22.328] - Launch lazy future ...
[18:06:22.329] Packages needed by the future expression (n = 0): <none>
[18:06:22.329] Packages needed by future strategies (n = 0): <none>
[18:06:22.330] {
[18:06:22.330]     {
[18:06:22.330]         {
[18:06:22.330]             ...future.startTime <- base::Sys.time()
[18:06:22.330]             {
[18:06:22.330]                 {
[18:06:22.330]                   {
[18:06:22.330]                     {
[18:06:22.330]                       base::local({
[18:06:22.330]                         has_future <- base::requireNamespace("future", 
[18:06:22.330]                           quietly = TRUE)
[18:06:22.330]                         if (has_future) {
[18:06:22.330]                           ns <- base::getNamespace("future")
[18:06:22.330]                           version <- ns[[".package"]][["version"]]
[18:06:22.330]                           if (is.null(version)) 
[18:06:22.330]                             version <- utils::packageVersion("future")
[18:06:22.330]                         }
[18:06:22.330]                         else {
[18:06:22.330]                           version <- NULL
[18:06:22.330]                         }
[18:06:22.330]                         if (!has_future || version < "1.8.0") {
[18:06:22.330]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:22.330]                             "", base::R.version$version.string), 
[18:06:22.330]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:22.330]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:22.330]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:22.330]                               "release", "version")], collapse = " "), 
[18:06:22.330]                             hostname = base::Sys.info()[["nodename"]])
[18:06:22.330]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:22.330]                             info)
[18:06:22.330]                           info <- base::paste(info, collapse = "; ")
[18:06:22.330]                           if (!has_future) {
[18:06:22.330]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:22.330]                               info)
[18:06:22.330]                           }
[18:06:22.330]                           else {
[18:06:22.330]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:22.330]                               info, version)
[18:06:22.330]                           }
[18:06:22.330]                           base::stop(msg)
[18:06:22.330]                         }
[18:06:22.330]                       })
[18:06:22.330]                     }
[18:06:22.330]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:22.330]                     base::options(mc.cores = 1L)
[18:06:22.330]                   }
[18:06:22.330]                   ...future.strategy.old <- future::plan("list")
[18:06:22.330]                   options(future.plan = NULL)
[18:06:22.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:22.330]                 }
[18:06:22.330]                 ...future.workdir <- getwd()
[18:06:22.330]             }
[18:06:22.330]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:22.330]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:22.330]         }
[18:06:22.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:22.330]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:22.330]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:22.330]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:22.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:22.330]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:22.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:22.330]             base::names(...future.oldOptions))
[18:06:22.330]     }
[18:06:22.330]     if (FALSE) {
[18:06:22.330]     }
[18:06:22.330]     else {
[18:06:22.330]         if (TRUE) {
[18:06:22.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:22.330]                 open = "w")
[18:06:22.330]         }
[18:06:22.330]         else {
[18:06:22.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:22.330]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:22.330]         }
[18:06:22.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:22.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:22.330]             base::sink(type = "output", split = FALSE)
[18:06:22.330]             base::close(...future.stdout)
[18:06:22.330]         }, add = TRUE)
[18:06:22.330]     }
[18:06:22.330]     ...future.frame <- base::sys.nframe()
[18:06:22.330]     ...future.conditions <- base::list()
[18:06:22.330]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:22.330]     if (FALSE) {
[18:06:22.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:22.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:22.330]     }
[18:06:22.330]     ...future.result <- base::tryCatch({
[18:06:22.330]         base::withCallingHandlers({
[18:06:22.330]             ...future.value <- base::withVisible(base::local({
[18:06:22.330]                 ...future.makeSendCondition <- base::local({
[18:06:22.330]                   sendCondition <- NULL
[18:06:22.330]                   function(frame = 1L) {
[18:06:22.330]                     if (is.function(sendCondition)) 
[18:06:22.330]                       return(sendCondition)
[18:06:22.330]                     ns <- getNamespace("parallel")
[18:06:22.330]                     if (exists("sendData", mode = "function", 
[18:06:22.330]                       envir = ns)) {
[18:06:22.330]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:22.330]                         envir = ns)
[18:06:22.330]                       envir <- sys.frame(frame)
[18:06:22.330]                       master <- NULL
[18:06:22.330]                       while (!identical(envir, .GlobalEnv) && 
[18:06:22.330]                         !identical(envir, emptyenv())) {
[18:06:22.330]                         if (exists("master", mode = "list", envir = envir, 
[18:06:22.330]                           inherits = FALSE)) {
[18:06:22.330]                           master <- get("master", mode = "list", 
[18:06:22.330]                             envir = envir, inherits = FALSE)
[18:06:22.330]                           if (inherits(master, c("SOCKnode", 
[18:06:22.330]                             "SOCK0node"))) {
[18:06:22.330]                             sendCondition <<- function(cond) {
[18:06:22.330]                               data <- list(type = "VALUE", value = cond, 
[18:06:22.330]                                 success = TRUE)
[18:06:22.330]                               parallel_sendData(master, data)
[18:06:22.330]                             }
[18:06:22.330]                             return(sendCondition)
[18:06:22.330]                           }
[18:06:22.330]                         }
[18:06:22.330]                         frame <- frame + 1L
[18:06:22.330]                         envir <- sys.frame(frame)
[18:06:22.330]                       }
[18:06:22.330]                     }
[18:06:22.330]                     sendCondition <<- function(cond) NULL
[18:06:22.330]                   }
[18:06:22.330]                 })
[18:06:22.330]                 withCallingHandlers({
[18:06:22.330]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:22.330]                 }, immediateCondition = function(cond) {
[18:06:22.330]                   sendCondition <- ...future.makeSendCondition()
[18:06:22.330]                   sendCondition(cond)
[18:06:22.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.330]                   {
[18:06:22.330]                     inherits <- base::inherits
[18:06:22.330]                     invokeRestart <- base::invokeRestart
[18:06:22.330]                     is.null <- base::is.null
[18:06:22.330]                     muffled <- FALSE
[18:06:22.330]                     if (inherits(cond, "message")) {
[18:06:22.330]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:22.330]                       if (muffled) 
[18:06:22.330]                         invokeRestart("muffleMessage")
[18:06:22.330]                     }
[18:06:22.330]                     else if (inherits(cond, "warning")) {
[18:06:22.330]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:22.330]                       if (muffled) 
[18:06:22.330]                         invokeRestart("muffleWarning")
[18:06:22.330]                     }
[18:06:22.330]                     else if (inherits(cond, "condition")) {
[18:06:22.330]                       if (!is.null(pattern)) {
[18:06:22.330]                         computeRestarts <- base::computeRestarts
[18:06:22.330]                         grepl <- base::grepl
[18:06:22.330]                         restarts <- computeRestarts(cond)
[18:06:22.330]                         for (restart in restarts) {
[18:06:22.330]                           name <- restart$name
[18:06:22.330]                           if (is.null(name)) 
[18:06:22.330]                             next
[18:06:22.330]                           if (!grepl(pattern, name)) 
[18:06:22.330]                             next
[18:06:22.330]                           invokeRestart(restart)
[18:06:22.330]                           muffled <- TRUE
[18:06:22.330]                           break
[18:06:22.330]                         }
[18:06:22.330]                       }
[18:06:22.330]                     }
[18:06:22.330]                     invisible(muffled)
[18:06:22.330]                   }
[18:06:22.330]                   muffleCondition(cond)
[18:06:22.330]                 })
[18:06:22.330]             }))
[18:06:22.330]             future::FutureResult(value = ...future.value$value, 
[18:06:22.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.330]                   ...future.rng), globalenv = if (FALSE) 
[18:06:22.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:22.330]                     ...future.globalenv.names))
[18:06:22.330]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:22.330]         }, condition = base::local({
[18:06:22.330]             c <- base::c
[18:06:22.330]             inherits <- base::inherits
[18:06:22.330]             invokeRestart <- base::invokeRestart
[18:06:22.330]             length <- base::length
[18:06:22.330]             list <- base::list
[18:06:22.330]             seq.int <- base::seq.int
[18:06:22.330]             signalCondition <- base::signalCondition
[18:06:22.330]             sys.calls <- base::sys.calls
[18:06:22.330]             `[[` <- base::`[[`
[18:06:22.330]             `+` <- base::`+`
[18:06:22.330]             `<<-` <- base::`<<-`
[18:06:22.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:22.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:22.330]                   3L)]
[18:06:22.330]             }
[18:06:22.330]             function(cond) {
[18:06:22.330]                 is_error <- inherits(cond, "error")
[18:06:22.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:22.330]                   NULL)
[18:06:22.330]                 if (is_error) {
[18:06:22.330]                   sessionInformation <- function() {
[18:06:22.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:22.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:22.330]                       search = base::search(), system = base::Sys.info())
[18:06:22.330]                   }
[18:06:22.330]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:22.330]                     cond$call), session = sessionInformation(), 
[18:06:22.330]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:22.330]                   signalCondition(cond)
[18:06:22.330]                 }
[18:06:22.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:22.330]                 "immediateCondition"))) {
[18:06:22.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:22.330]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:22.330]                   if (TRUE && !signal) {
[18:06:22.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.330]                     {
[18:06:22.330]                       inherits <- base::inherits
[18:06:22.330]                       invokeRestart <- base::invokeRestart
[18:06:22.330]                       is.null <- base::is.null
[18:06:22.330]                       muffled <- FALSE
[18:06:22.330]                       if (inherits(cond, "message")) {
[18:06:22.330]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.330]                         if (muffled) 
[18:06:22.330]                           invokeRestart("muffleMessage")
[18:06:22.330]                       }
[18:06:22.330]                       else if (inherits(cond, "warning")) {
[18:06:22.330]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.330]                         if (muffled) 
[18:06:22.330]                           invokeRestart("muffleWarning")
[18:06:22.330]                       }
[18:06:22.330]                       else if (inherits(cond, "condition")) {
[18:06:22.330]                         if (!is.null(pattern)) {
[18:06:22.330]                           computeRestarts <- base::computeRestarts
[18:06:22.330]                           grepl <- base::grepl
[18:06:22.330]                           restarts <- computeRestarts(cond)
[18:06:22.330]                           for (restart in restarts) {
[18:06:22.330]                             name <- restart$name
[18:06:22.330]                             if (is.null(name)) 
[18:06:22.330]                               next
[18:06:22.330]                             if (!grepl(pattern, name)) 
[18:06:22.330]                               next
[18:06:22.330]                             invokeRestart(restart)
[18:06:22.330]                             muffled <- TRUE
[18:06:22.330]                             break
[18:06:22.330]                           }
[18:06:22.330]                         }
[18:06:22.330]                       }
[18:06:22.330]                       invisible(muffled)
[18:06:22.330]                     }
[18:06:22.330]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.330]                   }
[18:06:22.330]                 }
[18:06:22.330]                 else {
[18:06:22.330]                   if (TRUE) {
[18:06:22.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.330]                     {
[18:06:22.330]                       inherits <- base::inherits
[18:06:22.330]                       invokeRestart <- base::invokeRestart
[18:06:22.330]                       is.null <- base::is.null
[18:06:22.330]                       muffled <- FALSE
[18:06:22.330]                       if (inherits(cond, "message")) {
[18:06:22.330]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.330]                         if (muffled) 
[18:06:22.330]                           invokeRestart("muffleMessage")
[18:06:22.330]                       }
[18:06:22.330]                       else if (inherits(cond, "warning")) {
[18:06:22.330]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.330]                         if (muffled) 
[18:06:22.330]                           invokeRestart("muffleWarning")
[18:06:22.330]                       }
[18:06:22.330]                       else if (inherits(cond, "condition")) {
[18:06:22.330]                         if (!is.null(pattern)) {
[18:06:22.330]                           computeRestarts <- base::computeRestarts
[18:06:22.330]                           grepl <- base::grepl
[18:06:22.330]                           restarts <- computeRestarts(cond)
[18:06:22.330]                           for (restart in restarts) {
[18:06:22.330]                             name <- restart$name
[18:06:22.330]                             if (is.null(name)) 
[18:06:22.330]                               next
[18:06:22.330]                             if (!grepl(pattern, name)) 
[18:06:22.330]                               next
[18:06:22.330]                             invokeRestart(restart)
[18:06:22.330]                             muffled <- TRUE
[18:06:22.330]                             break
[18:06:22.330]                           }
[18:06:22.330]                         }
[18:06:22.330]                       }
[18:06:22.330]                       invisible(muffled)
[18:06:22.330]                     }
[18:06:22.330]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.330]                   }
[18:06:22.330]                 }
[18:06:22.330]             }
[18:06:22.330]         }))
[18:06:22.330]     }, error = function(ex) {
[18:06:22.330]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:22.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.330]                 ...future.rng), started = ...future.startTime, 
[18:06:22.330]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:22.330]             version = "1.8"), class = "FutureResult")
[18:06:22.330]     }, finally = {
[18:06:22.330]         if (!identical(...future.workdir, getwd())) 
[18:06:22.330]             setwd(...future.workdir)
[18:06:22.330]         {
[18:06:22.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:22.330]                 ...future.oldOptions$nwarnings <- NULL
[18:06:22.330]             }
[18:06:22.330]             base::options(...future.oldOptions)
[18:06:22.330]             if (.Platform$OS.type == "windows") {
[18:06:22.330]                 old_names <- names(...future.oldEnvVars)
[18:06:22.330]                 envs <- base::Sys.getenv()
[18:06:22.330]                 names <- names(envs)
[18:06:22.330]                 common <- intersect(names, old_names)
[18:06:22.330]                 added <- setdiff(names, old_names)
[18:06:22.330]                 removed <- setdiff(old_names, names)
[18:06:22.330]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:22.330]                   envs[common]]
[18:06:22.330]                 NAMES <- toupper(changed)
[18:06:22.330]                 args <- list()
[18:06:22.330]                 for (kk in seq_along(NAMES)) {
[18:06:22.330]                   name <- changed[[kk]]
[18:06:22.330]                   NAME <- NAMES[[kk]]
[18:06:22.330]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.330]                     next
[18:06:22.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.330]                 }
[18:06:22.330]                 NAMES <- toupper(added)
[18:06:22.330]                 for (kk in seq_along(NAMES)) {
[18:06:22.330]                   name <- added[[kk]]
[18:06:22.330]                   NAME <- NAMES[[kk]]
[18:06:22.330]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.330]                     next
[18:06:22.330]                   args[[name]] <- ""
[18:06:22.330]                 }
[18:06:22.330]                 NAMES <- toupper(removed)
[18:06:22.330]                 for (kk in seq_along(NAMES)) {
[18:06:22.330]                   name <- removed[[kk]]
[18:06:22.330]                   NAME <- NAMES[[kk]]
[18:06:22.330]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.330]                     next
[18:06:22.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.330]                 }
[18:06:22.330]                 if (length(args) > 0) 
[18:06:22.330]                   base::do.call(base::Sys.setenv, args = args)
[18:06:22.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:22.330]             }
[18:06:22.330]             else {
[18:06:22.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:22.330]             }
[18:06:22.330]             {
[18:06:22.330]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:22.330]                   0L) {
[18:06:22.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:22.330]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:22.330]                   base::options(opts)
[18:06:22.330]                 }
[18:06:22.330]                 {
[18:06:22.330]                   {
[18:06:22.330]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:22.330]                     NULL
[18:06:22.330]                   }
[18:06:22.330]                   options(future.plan = NULL)
[18:06:22.330]                   if (is.na(NA_character_)) 
[18:06:22.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:22.330]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:22.330]                     .init = FALSE)
[18:06:22.330]                 }
[18:06:22.330]             }
[18:06:22.330]         }
[18:06:22.330]     })
[18:06:22.330]     if (TRUE) {
[18:06:22.330]         base::sink(type = "output", split = FALSE)
[18:06:22.330]         if (TRUE) {
[18:06:22.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:22.330]         }
[18:06:22.330]         else {
[18:06:22.330]             ...future.result["stdout"] <- base::list(NULL)
[18:06:22.330]         }
[18:06:22.330]         base::close(...future.stdout)
[18:06:22.330]         ...future.stdout <- NULL
[18:06:22.330]     }
[18:06:22.330]     ...future.result$conditions <- ...future.conditions
[18:06:22.330]     ...future.result$finished <- base::Sys.time()
[18:06:22.330]     ...future.result
[18:06:22.330] }
[18:06:22.334] Poll #1 (0): usedNodes() = 2, workers = 2
[18:06:22.345] receiveMessageFromWorker() for ClusterFuture ...
[18:06:22.346] - Validating connection of MultisessionFuture
[18:06:22.346] - received message: FutureResult
[18:06:22.346] - Received FutureResult
[18:06:22.346] - Erased future from FutureRegistry
[18:06:22.347] result() for ClusterFuture ...
[18:06:22.347] - result already collected: FutureResult
[18:06:22.347] result() for ClusterFuture ... done
[18:06:22.347] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:22.347] result() for ClusterFuture ...
[18:06:22.348] - result already collected: FutureResult
[18:06:22.348] result() for ClusterFuture ... done
[18:06:22.348] result() for ClusterFuture ...
[18:06:22.348] - result already collected: FutureResult
[18:06:22.348] result() for ClusterFuture ... done
[18:06:22.350] MultisessionFuture started
[18:06:22.351] - Launch lazy future ... done
[18:06:22.351] run() for ‘MultisessionFuture’ ... done
[18:06:22.351] getGlobalsAndPackages() ...
[18:06:22.351] Searching for globals...
[18:06:22.353] - globals found: [2] ‘list’, ‘stop’
[18:06:22.353] Searching for globals ... DONE
[18:06:22.354] Resolving globals: FALSE
[18:06:22.354] 
[18:06:22.355] 
[18:06:22.355] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[18:06:22.356] getGlobalsAndPackages() ...
[18:06:22.356] Searching for globals...
[18:06:22.358] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:22.359] Searching for globals ... DONE
[18:06:22.359] Resolving globals: FALSE
[18:06:22.360] 
[18:06:22.360] 
[18:06:22.360] getGlobalsAndPackages() ... DONE
[18:06:22.361] run() for ‘Future’ ...
[18:06:22.361] - state: ‘created’
[18:06:22.361] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:22.388] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:22.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:22.388]   - Field: ‘node’
[18:06:22.389]   - Field: ‘label’
[18:06:22.389]   - Field: ‘local’
[18:06:22.389]   - Field: ‘owner’
[18:06:22.389]   - Field: ‘envir’
[18:06:22.389]   - Field: ‘workers’
[18:06:22.390]   - Field: ‘packages’
[18:06:22.390]   - Field: ‘gc’
[18:06:22.390]   - Field: ‘conditions’
[18:06:22.390]   - Field: ‘persistent’
[18:06:22.391]   - Field: ‘expr’
[18:06:22.391]   - Field: ‘uuid’
[18:06:22.391]   - Field: ‘seed’
[18:06:22.392]   - Field: ‘version’
[18:06:22.392]   - Field: ‘result’
[18:06:22.392]   - Field: ‘asynchronous’
[18:06:22.392]   - Field: ‘calls’
[18:06:22.392]   - Field: ‘globals’
[18:06:22.393]   - Field: ‘stdout’
[18:06:22.393]   - Field: ‘earlySignal’
[18:06:22.393]   - Field: ‘lazy’
[18:06:22.393]   - Field: ‘state’
[18:06:22.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:22.394] - Launch lazy future ...
[18:06:22.394] Packages needed by the future expression (n = 0): <none>
[18:06:22.394] Packages needed by future strategies (n = 0): <none>
[18:06:22.395] {
[18:06:22.395]     {
[18:06:22.395]         {
[18:06:22.395]             ...future.startTime <- base::Sys.time()
[18:06:22.395]             {
[18:06:22.395]                 {
[18:06:22.395]                   {
[18:06:22.395]                     {
[18:06:22.395]                       base::local({
[18:06:22.395]                         has_future <- base::requireNamespace("future", 
[18:06:22.395]                           quietly = TRUE)
[18:06:22.395]                         if (has_future) {
[18:06:22.395]                           ns <- base::getNamespace("future")
[18:06:22.395]                           version <- ns[[".package"]][["version"]]
[18:06:22.395]                           if (is.null(version)) 
[18:06:22.395]                             version <- utils::packageVersion("future")
[18:06:22.395]                         }
[18:06:22.395]                         else {
[18:06:22.395]                           version <- NULL
[18:06:22.395]                         }
[18:06:22.395]                         if (!has_future || version < "1.8.0") {
[18:06:22.395]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:22.395]                             "", base::R.version$version.string), 
[18:06:22.395]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:22.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:22.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:22.395]                               "release", "version")], collapse = " "), 
[18:06:22.395]                             hostname = base::Sys.info()[["nodename"]])
[18:06:22.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:22.395]                             info)
[18:06:22.395]                           info <- base::paste(info, collapse = "; ")
[18:06:22.395]                           if (!has_future) {
[18:06:22.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:22.395]                               info)
[18:06:22.395]                           }
[18:06:22.395]                           else {
[18:06:22.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:22.395]                               info, version)
[18:06:22.395]                           }
[18:06:22.395]                           base::stop(msg)
[18:06:22.395]                         }
[18:06:22.395]                       })
[18:06:22.395]                     }
[18:06:22.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:22.395]                     base::options(mc.cores = 1L)
[18:06:22.395]                   }
[18:06:22.395]                   ...future.strategy.old <- future::plan("list")
[18:06:22.395]                   options(future.plan = NULL)
[18:06:22.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:22.395]                 }
[18:06:22.395]                 ...future.workdir <- getwd()
[18:06:22.395]             }
[18:06:22.395]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:22.395]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:22.395]         }
[18:06:22.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:22.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:22.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:22.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:22.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:22.395]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:22.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:22.395]             base::names(...future.oldOptions))
[18:06:22.395]     }
[18:06:22.395]     if (FALSE) {
[18:06:22.395]     }
[18:06:22.395]     else {
[18:06:22.395]         if (TRUE) {
[18:06:22.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:22.395]                 open = "w")
[18:06:22.395]         }
[18:06:22.395]         else {
[18:06:22.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:22.395]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:22.395]         }
[18:06:22.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:22.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:22.395]             base::sink(type = "output", split = FALSE)
[18:06:22.395]             base::close(...future.stdout)
[18:06:22.395]         }, add = TRUE)
[18:06:22.395]     }
[18:06:22.395]     ...future.frame <- base::sys.nframe()
[18:06:22.395]     ...future.conditions <- base::list()
[18:06:22.395]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:22.395]     if (FALSE) {
[18:06:22.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:22.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:22.395]     }
[18:06:22.395]     ...future.result <- base::tryCatch({
[18:06:22.395]         base::withCallingHandlers({
[18:06:22.395]             ...future.value <- base::withVisible(base::local({
[18:06:22.395]                 ...future.makeSendCondition <- base::local({
[18:06:22.395]                   sendCondition <- NULL
[18:06:22.395]                   function(frame = 1L) {
[18:06:22.395]                     if (is.function(sendCondition)) 
[18:06:22.395]                       return(sendCondition)
[18:06:22.395]                     ns <- getNamespace("parallel")
[18:06:22.395]                     if (exists("sendData", mode = "function", 
[18:06:22.395]                       envir = ns)) {
[18:06:22.395]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:22.395]                         envir = ns)
[18:06:22.395]                       envir <- sys.frame(frame)
[18:06:22.395]                       master <- NULL
[18:06:22.395]                       while (!identical(envir, .GlobalEnv) && 
[18:06:22.395]                         !identical(envir, emptyenv())) {
[18:06:22.395]                         if (exists("master", mode = "list", envir = envir, 
[18:06:22.395]                           inherits = FALSE)) {
[18:06:22.395]                           master <- get("master", mode = "list", 
[18:06:22.395]                             envir = envir, inherits = FALSE)
[18:06:22.395]                           if (inherits(master, c("SOCKnode", 
[18:06:22.395]                             "SOCK0node"))) {
[18:06:22.395]                             sendCondition <<- function(cond) {
[18:06:22.395]                               data <- list(type = "VALUE", value = cond, 
[18:06:22.395]                                 success = TRUE)
[18:06:22.395]                               parallel_sendData(master, data)
[18:06:22.395]                             }
[18:06:22.395]                             return(sendCondition)
[18:06:22.395]                           }
[18:06:22.395]                         }
[18:06:22.395]                         frame <- frame + 1L
[18:06:22.395]                         envir <- sys.frame(frame)
[18:06:22.395]                       }
[18:06:22.395]                     }
[18:06:22.395]                     sendCondition <<- function(cond) NULL
[18:06:22.395]                   }
[18:06:22.395]                 })
[18:06:22.395]                 withCallingHandlers({
[18:06:22.395]                   {
[18:06:22.395]                     Sys.sleep(0.5)
[18:06:22.395]                     list(a = 1, b = 42L)
[18:06:22.395]                   }
[18:06:22.395]                 }, immediateCondition = function(cond) {
[18:06:22.395]                   sendCondition <- ...future.makeSendCondition()
[18:06:22.395]                   sendCondition(cond)
[18:06:22.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.395]                   {
[18:06:22.395]                     inherits <- base::inherits
[18:06:22.395]                     invokeRestart <- base::invokeRestart
[18:06:22.395]                     is.null <- base::is.null
[18:06:22.395]                     muffled <- FALSE
[18:06:22.395]                     if (inherits(cond, "message")) {
[18:06:22.395]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:22.395]                       if (muffled) 
[18:06:22.395]                         invokeRestart("muffleMessage")
[18:06:22.395]                     }
[18:06:22.395]                     else if (inherits(cond, "warning")) {
[18:06:22.395]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:22.395]                       if (muffled) 
[18:06:22.395]                         invokeRestart("muffleWarning")
[18:06:22.395]                     }
[18:06:22.395]                     else if (inherits(cond, "condition")) {
[18:06:22.395]                       if (!is.null(pattern)) {
[18:06:22.395]                         computeRestarts <- base::computeRestarts
[18:06:22.395]                         grepl <- base::grepl
[18:06:22.395]                         restarts <- computeRestarts(cond)
[18:06:22.395]                         for (restart in restarts) {
[18:06:22.395]                           name <- restart$name
[18:06:22.395]                           if (is.null(name)) 
[18:06:22.395]                             next
[18:06:22.395]                           if (!grepl(pattern, name)) 
[18:06:22.395]                             next
[18:06:22.395]                           invokeRestart(restart)
[18:06:22.395]                           muffled <- TRUE
[18:06:22.395]                           break
[18:06:22.395]                         }
[18:06:22.395]                       }
[18:06:22.395]                     }
[18:06:22.395]                     invisible(muffled)
[18:06:22.395]                   }
[18:06:22.395]                   muffleCondition(cond)
[18:06:22.395]                 })
[18:06:22.395]             }))
[18:06:22.395]             future::FutureResult(value = ...future.value$value, 
[18:06:22.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.395]                   ...future.rng), globalenv = if (FALSE) 
[18:06:22.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:22.395]                     ...future.globalenv.names))
[18:06:22.395]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:22.395]         }, condition = base::local({
[18:06:22.395]             c <- base::c
[18:06:22.395]             inherits <- base::inherits
[18:06:22.395]             invokeRestart <- base::invokeRestart
[18:06:22.395]             length <- base::length
[18:06:22.395]             list <- base::list
[18:06:22.395]             seq.int <- base::seq.int
[18:06:22.395]             signalCondition <- base::signalCondition
[18:06:22.395]             sys.calls <- base::sys.calls
[18:06:22.395]             `[[` <- base::`[[`
[18:06:22.395]             `+` <- base::`+`
[18:06:22.395]             `<<-` <- base::`<<-`
[18:06:22.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:22.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:22.395]                   3L)]
[18:06:22.395]             }
[18:06:22.395]             function(cond) {
[18:06:22.395]                 is_error <- inherits(cond, "error")
[18:06:22.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:22.395]                   NULL)
[18:06:22.395]                 if (is_error) {
[18:06:22.395]                   sessionInformation <- function() {
[18:06:22.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:22.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:22.395]                       search = base::search(), system = base::Sys.info())
[18:06:22.395]                   }
[18:06:22.395]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:22.395]                     cond$call), session = sessionInformation(), 
[18:06:22.395]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:22.395]                   signalCondition(cond)
[18:06:22.395]                 }
[18:06:22.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:22.395]                 "immediateCondition"))) {
[18:06:22.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:22.395]                   ...future.conditions[[length(...future.conditions) + 
[18:06:22.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:22.395]                   if (TRUE && !signal) {
[18:06:22.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.395]                     {
[18:06:22.395]                       inherits <- base::inherits
[18:06:22.395]                       invokeRestart <- base::invokeRestart
[18:06:22.395]                       is.null <- base::is.null
[18:06:22.395]                       muffled <- FALSE
[18:06:22.395]                       if (inherits(cond, "message")) {
[18:06:22.395]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.395]                         if (muffled) 
[18:06:22.395]                           invokeRestart("muffleMessage")
[18:06:22.395]                       }
[18:06:22.395]                       else if (inherits(cond, "warning")) {
[18:06:22.395]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.395]                         if (muffled) 
[18:06:22.395]                           invokeRestart("muffleWarning")
[18:06:22.395]                       }
[18:06:22.395]                       else if (inherits(cond, "condition")) {
[18:06:22.395]                         if (!is.null(pattern)) {
[18:06:22.395]                           computeRestarts <- base::computeRestarts
[18:06:22.395]                           grepl <- base::grepl
[18:06:22.395]                           restarts <- computeRestarts(cond)
[18:06:22.395]                           for (restart in restarts) {
[18:06:22.395]                             name <- restart$name
[18:06:22.395]                             if (is.null(name)) 
[18:06:22.395]                               next
[18:06:22.395]                             if (!grepl(pattern, name)) 
[18:06:22.395]                               next
[18:06:22.395]                             invokeRestart(restart)
[18:06:22.395]                             muffled <- TRUE
[18:06:22.395]                             break
[18:06:22.395]                           }
[18:06:22.395]                         }
[18:06:22.395]                       }
[18:06:22.395]                       invisible(muffled)
[18:06:22.395]                     }
[18:06:22.395]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.395]                   }
[18:06:22.395]                 }
[18:06:22.395]                 else {
[18:06:22.395]                   if (TRUE) {
[18:06:22.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:22.395]                     {
[18:06:22.395]                       inherits <- base::inherits
[18:06:22.395]                       invokeRestart <- base::invokeRestart
[18:06:22.395]                       is.null <- base::is.null
[18:06:22.395]                       muffled <- FALSE
[18:06:22.395]                       if (inherits(cond, "message")) {
[18:06:22.395]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:22.395]                         if (muffled) 
[18:06:22.395]                           invokeRestart("muffleMessage")
[18:06:22.395]                       }
[18:06:22.395]                       else if (inherits(cond, "warning")) {
[18:06:22.395]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:22.395]                         if (muffled) 
[18:06:22.395]                           invokeRestart("muffleWarning")
[18:06:22.395]                       }
[18:06:22.395]                       else if (inherits(cond, "condition")) {
[18:06:22.395]                         if (!is.null(pattern)) {
[18:06:22.395]                           computeRestarts <- base::computeRestarts
[18:06:22.395]                           grepl <- base::grepl
[18:06:22.395]                           restarts <- computeRestarts(cond)
[18:06:22.395]                           for (restart in restarts) {
[18:06:22.395]                             name <- restart$name
[18:06:22.395]                             if (is.null(name)) 
[18:06:22.395]                               next
[18:06:22.395]                             if (!grepl(pattern, name)) 
[18:06:22.395]                               next
[18:06:22.395]                             invokeRestart(restart)
[18:06:22.395]                             muffled <- TRUE
[18:06:22.395]                             break
[18:06:22.395]                           }
[18:06:22.395]                         }
[18:06:22.395]                       }
[18:06:22.395]                       invisible(muffled)
[18:06:22.395]                     }
[18:06:22.395]                     muffleCondition(cond, pattern = "^muffle")
[18:06:22.395]                   }
[18:06:22.395]                 }
[18:06:22.395]             }
[18:06:22.395]         }))
[18:06:22.395]     }, error = function(ex) {
[18:06:22.395]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:22.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:22.395]                 ...future.rng), started = ...future.startTime, 
[18:06:22.395]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:22.395]             version = "1.8"), class = "FutureResult")
[18:06:22.395]     }, finally = {
[18:06:22.395]         if (!identical(...future.workdir, getwd())) 
[18:06:22.395]             setwd(...future.workdir)
[18:06:22.395]         {
[18:06:22.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:22.395]                 ...future.oldOptions$nwarnings <- NULL
[18:06:22.395]             }
[18:06:22.395]             base::options(...future.oldOptions)
[18:06:22.395]             if (.Platform$OS.type == "windows") {
[18:06:22.395]                 old_names <- names(...future.oldEnvVars)
[18:06:22.395]                 envs <- base::Sys.getenv()
[18:06:22.395]                 names <- names(envs)
[18:06:22.395]                 common <- intersect(names, old_names)
[18:06:22.395]                 added <- setdiff(names, old_names)
[18:06:22.395]                 removed <- setdiff(old_names, names)
[18:06:22.395]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:22.395]                   envs[common]]
[18:06:22.395]                 NAMES <- toupper(changed)
[18:06:22.395]                 args <- list()
[18:06:22.395]                 for (kk in seq_along(NAMES)) {
[18:06:22.395]                   name <- changed[[kk]]
[18:06:22.395]                   NAME <- NAMES[[kk]]
[18:06:22.395]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.395]                     next
[18:06:22.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.395]                 }
[18:06:22.395]                 NAMES <- toupper(added)
[18:06:22.395]                 for (kk in seq_along(NAMES)) {
[18:06:22.395]                   name <- added[[kk]]
[18:06:22.395]                   NAME <- NAMES[[kk]]
[18:06:22.395]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.395]                     next
[18:06:22.395]                   args[[name]] <- ""
[18:06:22.395]                 }
[18:06:22.395]                 NAMES <- toupper(removed)
[18:06:22.395]                 for (kk in seq_along(NAMES)) {
[18:06:22.395]                   name <- removed[[kk]]
[18:06:22.395]                   NAME <- NAMES[[kk]]
[18:06:22.395]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:22.395]                     next
[18:06:22.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:22.395]                 }
[18:06:22.395]                 if (length(args) > 0) 
[18:06:22.395]                   base::do.call(base::Sys.setenv, args = args)
[18:06:22.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:22.395]             }
[18:06:22.395]             else {
[18:06:22.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:22.395]             }
[18:06:22.395]             {
[18:06:22.395]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:22.395]                   0L) {
[18:06:22.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:22.395]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:22.395]                   base::options(opts)
[18:06:22.395]                 }
[18:06:22.395]                 {
[18:06:22.395]                   {
[18:06:22.395]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:22.395]                     NULL
[18:06:22.395]                   }
[18:06:22.395]                   options(future.plan = NULL)
[18:06:22.395]                   if (is.na(NA_character_)) 
[18:06:22.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:22.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:22.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:22.395]                     .init = FALSE)
[18:06:22.395]                 }
[18:06:22.395]             }
[18:06:22.395]         }
[18:06:22.395]     })
[18:06:22.395]     if (TRUE) {
[18:06:22.395]         base::sink(type = "output", split = FALSE)
[18:06:22.395]         if (TRUE) {
[18:06:22.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:22.395]         }
[18:06:22.395]         else {
[18:06:22.395]             ...future.result["stdout"] <- base::list(NULL)
[18:06:22.395]         }
[18:06:22.395]         base::close(...future.stdout)
[18:06:22.395]         ...future.stdout <- NULL
[18:06:22.395]     }
[18:06:22.395]     ...future.result$conditions <- ...future.conditions
[18:06:22.395]     ...future.result$finished <- base::Sys.time()
[18:06:22.395]     ...future.result
[18:06:22.395] }
[18:06:22.400] Poll #1 (0): usedNodes() = 2, workers = 2
[18:06:22.423] receiveMessageFromWorker() for ClusterFuture ...
[18:06:22.423] - Validating connection of MultisessionFuture
[18:06:22.424] - received message: FutureResult
[18:06:22.424] - Received FutureResult
[18:06:22.425] - Erased future from FutureRegistry
[18:06:22.425] result() for ClusterFuture ...
[18:06:22.425] - result already collected: FutureResult
[18:06:22.425] result() for ClusterFuture ... done
[18:06:22.425] signalConditions() ...
[18:06:22.425]  - include = ‘immediateCondition’
[18:06:22.426]  - exclude = 
[18:06:22.426]  - resignal = FALSE
[18:06:22.426]  - Number of conditions: 1
[18:06:22.426] signalConditions() ... done
[18:06:22.426] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:22.427] result() for ClusterFuture ...
[18:06:22.427] - result already collected: FutureResult
[18:06:22.427] result() for ClusterFuture ... done
[18:06:22.427] result() for ClusterFuture ...
[18:06:22.427] - result already collected: FutureResult
[18:06:22.428] result() for ClusterFuture ... done
[18:06:22.428] signalConditions() ...
[18:06:22.428]  - include = ‘immediateCondition’
[18:06:22.428]  - exclude = 
[18:06:22.428]  - resignal = FALSE
[18:06:22.429]  - Number of conditions: 1
[18:06:22.429] signalConditions() ... done
[18:06:22.431] MultisessionFuture started
[18:06:22.431] - Launch lazy future ... done
[18:06:22.431] run() for ‘MultisessionFuture’ ... done
[18:06:22.975] receiveMessageFromWorker() for ClusterFuture ...
[18:06:22.976] - Validating connection of MultisessionFuture
[18:06:22.976] - received message: FutureResult
[18:06:22.977] - Received FutureResult
[18:06:22.977] - Erased future from FutureRegistry
[18:06:22.977] result() for ClusterFuture ...
[18:06:22.978] - result already collected: FutureResult
[18:06:22.978] result() for ClusterFuture ... done
[18:06:22.978] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:22.979] A MultisessionFuture was resolved
[18:06:22.979] getGlobalsAndPackages() ...
[18:06:22.979] Searching for globals...
[18:06:22.983] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:22.983] Searching for globals ... DONE
[18:06:22.983] Resolving globals: FALSE
[18:06:22.984] 
[18:06:22.985] 
[18:06:22.985] getGlobalsAndPackages() ... DONE
[18:06:22.986] run() for ‘Future’ ...
[18:06:22.987] - state: ‘created’
[18:06:22.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:23.023] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:23.023] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:23.024]   - Field: ‘node’
[18:06:23.024]   - Field: ‘label’
[18:06:23.025]   - Field: ‘local’
[18:06:23.025]   - Field: ‘owner’
[18:06:23.025]   - Field: ‘envir’
[18:06:23.026]   - Field: ‘workers’
[18:06:23.026]   - Field: ‘packages’
[18:06:23.026]   - Field: ‘gc’
[18:06:23.027]   - Field: ‘conditions’
[18:06:23.027]   - Field: ‘persistent’
[18:06:23.027]   - Field: ‘expr’
[18:06:23.028]   - Field: ‘uuid’
[18:06:23.028]   - Field: ‘seed’
[18:06:23.028]   - Field: ‘version’
[18:06:23.029]   - Field: ‘result’
[18:06:23.029]   - Field: ‘asynchronous’
[18:06:23.029]   - Field: ‘calls’
[18:06:23.029]   - Field: ‘globals’
[18:06:23.030]   - Field: ‘stdout’
[18:06:23.030]   - Field: ‘earlySignal’
[18:06:23.030]   - Field: ‘lazy’
[18:06:23.031]   - Field: ‘state’
[18:06:23.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:23.031] - Launch lazy future ...
[18:06:23.032] Packages needed by the future expression (n = 0): <none>
[18:06:23.033] Packages needed by future strategies (n = 0): <none>
[18:06:23.034] {
[18:06:23.034]     {
[18:06:23.034]         {
[18:06:23.034]             ...future.startTime <- base::Sys.time()
[18:06:23.034]             {
[18:06:23.034]                 {
[18:06:23.034]                   {
[18:06:23.034]                     {
[18:06:23.034]                       base::local({
[18:06:23.034]                         has_future <- base::requireNamespace("future", 
[18:06:23.034]                           quietly = TRUE)
[18:06:23.034]                         if (has_future) {
[18:06:23.034]                           ns <- base::getNamespace("future")
[18:06:23.034]                           version <- ns[[".package"]][["version"]]
[18:06:23.034]                           if (is.null(version)) 
[18:06:23.034]                             version <- utils::packageVersion("future")
[18:06:23.034]                         }
[18:06:23.034]                         else {
[18:06:23.034]                           version <- NULL
[18:06:23.034]                         }
[18:06:23.034]                         if (!has_future || version < "1.8.0") {
[18:06:23.034]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:23.034]                             "", base::R.version$version.string), 
[18:06:23.034]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:23.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:23.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:23.034]                               "release", "version")], collapse = " "), 
[18:06:23.034]                             hostname = base::Sys.info()[["nodename"]])
[18:06:23.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:23.034]                             info)
[18:06:23.034]                           info <- base::paste(info, collapse = "; ")
[18:06:23.034]                           if (!has_future) {
[18:06:23.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:23.034]                               info)
[18:06:23.034]                           }
[18:06:23.034]                           else {
[18:06:23.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:23.034]                               info, version)
[18:06:23.034]                           }
[18:06:23.034]                           base::stop(msg)
[18:06:23.034]                         }
[18:06:23.034]                       })
[18:06:23.034]                     }
[18:06:23.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:23.034]                     base::options(mc.cores = 1L)
[18:06:23.034]                   }
[18:06:23.034]                   ...future.strategy.old <- future::plan("list")
[18:06:23.034]                   options(future.plan = NULL)
[18:06:23.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:23.034]                 }
[18:06:23.034]                 ...future.workdir <- getwd()
[18:06:23.034]             }
[18:06:23.034]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:23.034]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:23.034]         }
[18:06:23.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:23.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:23.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:23.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:23.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:23.034]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:23.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:23.034]             base::names(...future.oldOptions))
[18:06:23.034]     }
[18:06:23.034]     if (FALSE) {
[18:06:23.034]     }
[18:06:23.034]     else {
[18:06:23.034]         if (TRUE) {
[18:06:23.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:23.034]                 open = "w")
[18:06:23.034]         }
[18:06:23.034]         else {
[18:06:23.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:23.034]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:23.034]         }
[18:06:23.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:23.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:23.034]             base::sink(type = "output", split = FALSE)
[18:06:23.034]             base::close(...future.stdout)
[18:06:23.034]         }, add = TRUE)
[18:06:23.034]     }
[18:06:23.034]     ...future.frame <- base::sys.nframe()
[18:06:23.034]     ...future.conditions <- base::list()
[18:06:23.034]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:23.034]     if (FALSE) {
[18:06:23.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:23.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:23.034]     }
[18:06:23.034]     ...future.result <- base::tryCatch({
[18:06:23.034]         base::withCallingHandlers({
[18:06:23.034]             ...future.value <- base::withVisible(base::local({
[18:06:23.034]                 ...future.makeSendCondition <- base::local({
[18:06:23.034]                   sendCondition <- NULL
[18:06:23.034]                   function(frame = 1L) {
[18:06:23.034]                     if (is.function(sendCondition)) 
[18:06:23.034]                       return(sendCondition)
[18:06:23.034]                     ns <- getNamespace("parallel")
[18:06:23.034]                     if (exists("sendData", mode = "function", 
[18:06:23.034]                       envir = ns)) {
[18:06:23.034]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:23.034]                         envir = ns)
[18:06:23.034]                       envir <- sys.frame(frame)
[18:06:23.034]                       master <- NULL
[18:06:23.034]                       while (!identical(envir, .GlobalEnv) && 
[18:06:23.034]                         !identical(envir, emptyenv())) {
[18:06:23.034]                         if (exists("master", mode = "list", envir = envir, 
[18:06:23.034]                           inherits = FALSE)) {
[18:06:23.034]                           master <- get("master", mode = "list", 
[18:06:23.034]                             envir = envir, inherits = FALSE)
[18:06:23.034]                           if (inherits(master, c("SOCKnode", 
[18:06:23.034]                             "SOCK0node"))) {
[18:06:23.034]                             sendCondition <<- function(cond) {
[18:06:23.034]                               data <- list(type = "VALUE", value = cond, 
[18:06:23.034]                                 success = TRUE)
[18:06:23.034]                               parallel_sendData(master, data)
[18:06:23.034]                             }
[18:06:23.034]                             return(sendCondition)
[18:06:23.034]                           }
[18:06:23.034]                         }
[18:06:23.034]                         frame <- frame + 1L
[18:06:23.034]                         envir <- sys.frame(frame)
[18:06:23.034]                       }
[18:06:23.034]                     }
[18:06:23.034]                     sendCondition <<- function(cond) NULL
[18:06:23.034]                   }
[18:06:23.034]                 })
[18:06:23.034]                 withCallingHandlers({
[18:06:23.034]                   {
[18:06:23.034]                     Sys.sleep(0.5)
[18:06:23.034]                     list(a = 1, b = 42L)
[18:06:23.034]                   }
[18:06:23.034]                 }, immediateCondition = function(cond) {
[18:06:23.034]                   sendCondition <- ...future.makeSendCondition()
[18:06:23.034]                   sendCondition(cond)
[18:06:23.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.034]                   {
[18:06:23.034]                     inherits <- base::inherits
[18:06:23.034]                     invokeRestart <- base::invokeRestart
[18:06:23.034]                     is.null <- base::is.null
[18:06:23.034]                     muffled <- FALSE
[18:06:23.034]                     if (inherits(cond, "message")) {
[18:06:23.034]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:23.034]                       if (muffled) 
[18:06:23.034]                         invokeRestart("muffleMessage")
[18:06:23.034]                     }
[18:06:23.034]                     else if (inherits(cond, "warning")) {
[18:06:23.034]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:23.034]                       if (muffled) 
[18:06:23.034]                         invokeRestart("muffleWarning")
[18:06:23.034]                     }
[18:06:23.034]                     else if (inherits(cond, "condition")) {
[18:06:23.034]                       if (!is.null(pattern)) {
[18:06:23.034]                         computeRestarts <- base::computeRestarts
[18:06:23.034]                         grepl <- base::grepl
[18:06:23.034]                         restarts <- computeRestarts(cond)
[18:06:23.034]                         for (restart in restarts) {
[18:06:23.034]                           name <- restart$name
[18:06:23.034]                           if (is.null(name)) 
[18:06:23.034]                             next
[18:06:23.034]                           if (!grepl(pattern, name)) 
[18:06:23.034]                             next
[18:06:23.034]                           invokeRestart(restart)
[18:06:23.034]                           muffled <- TRUE
[18:06:23.034]                           break
[18:06:23.034]                         }
[18:06:23.034]                       }
[18:06:23.034]                     }
[18:06:23.034]                     invisible(muffled)
[18:06:23.034]                   }
[18:06:23.034]                   muffleCondition(cond)
[18:06:23.034]                 })
[18:06:23.034]             }))
[18:06:23.034]             future::FutureResult(value = ...future.value$value, 
[18:06:23.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.034]                   ...future.rng), globalenv = if (FALSE) 
[18:06:23.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:23.034]                     ...future.globalenv.names))
[18:06:23.034]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:23.034]         }, condition = base::local({
[18:06:23.034]             c <- base::c
[18:06:23.034]             inherits <- base::inherits
[18:06:23.034]             invokeRestart <- base::invokeRestart
[18:06:23.034]             length <- base::length
[18:06:23.034]             list <- base::list
[18:06:23.034]             seq.int <- base::seq.int
[18:06:23.034]             signalCondition <- base::signalCondition
[18:06:23.034]             sys.calls <- base::sys.calls
[18:06:23.034]             `[[` <- base::`[[`
[18:06:23.034]             `+` <- base::`+`
[18:06:23.034]             `<<-` <- base::`<<-`
[18:06:23.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:23.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:23.034]                   3L)]
[18:06:23.034]             }
[18:06:23.034]             function(cond) {
[18:06:23.034]                 is_error <- inherits(cond, "error")
[18:06:23.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:23.034]                   NULL)
[18:06:23.034]                 if (is_error) {
[18:06:23.034]                   sessionInformation <- function() {
[18:06:23.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:23.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:23.034]                       search = base::search(), system = base::Sys.info())
[18:06:23.034]                   }
[18:06:23.034]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:23.034]                     cond$call), session = sessionInformation(), 
[18:06:23.034]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:23.034]                   signalCondition(cond)
[18:06:23.034]                 }
[18:06:23.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:23.034]                 "immediateCondition"))) {
[18:06:23.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:23.034]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:23.034]                   if (TRUE && !signal) {
[18:06:23.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.034]                     {
[18:06:23.034]                       inherits <- base::inherits
[18:06:23.034]                       invokeRestart <- base::invokeRestart
[18:06:23.034]                       is.null <- base::is.null
[18:06:23.034]                       muffled <- FALSE
[18:06:23.034]                       if (inherits(cond, "message")) {
[18:06:23.034]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.034]                         if (muffled) 
[18:06:23.034]                           invokeRestart("muffleMessage")
[18:06:23.034]                       }
[18:06:23.034]                       else if (inherits(cond, "warning")) {
[18:06:23.034]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.034]                         if (muffled) 
[18:06:23.034]                           invokeRestart("muffleWarning")
[18:06:23.034]                       }
[18:06:23.034]                       else if (inherits(cond, "condition")) {
[18:06:23.034]                         if (!is.null(pattern)) {
[18:06:23.034]                           computeRestarts <- base::computeRestarts
[18:06:23.034]                           grepl <- base::grepl
[18:06:23.034]                           restarts <- computeRestarts(cond)
[18:06:23.034]                           for (restart in restarts) {
[18:06:23.034]                             name <- restart$name
[18:06:23.034]                             if (is.null(name)) 
[18:06:23.034]                               next
[18:06:23.034]                             if (!grepl(pattern, name)) 
[18:06:23.034]                               next
[18:06:23.034]                             invokeRestart(restart)
[18:06:23.034]                             muffled <- TRUE
[18:06:23.034]                             break
[18:06:23.034]                           }
[18:06:23.034]                         }
[18:06:23.034]                       }
[18:06:23.034]                       invisible(muffled)
[18:06:23.034]                     }
[18:06:23.034]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.034]                   }
[18:06:23.034]                 }
[18:06:23.034]                 else {
[18:06:23.034]                   if (TRUE) {
[18:06:23.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.034]                     {
[18:06:23.034]                       inherits <- base::inherits
[18:06:23.034]                       invokeRestart <- base::invokeRestart
[18:06:23.034]                       is.null <- base::is.null
[18:06:23.034]                       muffled <- FALSE
[18:06:23.034]                       if (inherits(cond, "message")) {
[18:06:23.034]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.034]                         if (muffled) 
[18:06:23.034]                           invokeRestart("muffleMessage")
[18:06:23.034]                       }
[18:06:23.034]                       else if (inherits(cond, "warning")) {
[18:06:23.034]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.034]                         if (muffled) 
[18:06:23.034]                           invokeRestart("muffleWarning")
[18:06:23.034]                       }
[18:06:23.034]                       else if (inherits(cond, "condition")) {
[18:06:23.034]                         if (!is.null(pattern)) {
[18:06:23.034]                           computeRestarts <- base::computeRestarts
[18:06:23.034]                           grepl <- base::grepl
[18:06:23.034]                           restarts <- computeRestarts(cond)
[18:06:23.034]                           for (restart in restarts) {
[18:06:23.034]                             name <- restart$name
[18:06:23.034]                             if (is.null(name)) 
[18:06:23.034]                               next
[18:06:23.034]                             if (!grepl(pattern, name)) 
[18:06:23.034]                               next
[18:06:23.034]                             invokeRestart(restart)
[18:06:23.034]                             muffled <- TRUE
[18:06:23.034]                             break
[18:06:23.034]                           }
[18:06:23.034]                         }
[18:06:23.034]                       }
[18:06:23.034]                       invisible(muffled)
[18:06:23.034]                     }
[18:06:23.034]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.034]                   }
[18:06:23.034]                 }
[18:06:23.034]             }
[18:06:23.034]         }))
[18:06:23.034]     }, error = function(ex) {
[18:06:23.034]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:23.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.034]                 ...future.rng), started = ...future.startTime, 
[18:06:23.034]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:23.034]             version = "1.8"), class = "FutureResult")
[18:06:23.034]     }, finally = {
[18:06:23.034]         if (!identical(...future.workdir, getwd())) 
[18:06:23.034]             setwd(...future.workdir)
[18:06:23.034]         {
[18:06:23.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:23.034]                 ...future.oldOptions$nwarnings <- NULL
[18:06:23.034]             }
[18:06:23.034]             base::options(...future.oldOptions)
[18:06:23.034]             if (.Platform$OS.type == "windows") {
[18:06:23.034]                 old_names <- names(...future.oldEnvVars)
[18:06:23.034]                 envs <- base::Sys.getenv()
[18:06:23.034]                 names <- names(envs)
[18:06:23.034]                 common <- intersect(names, old_names)
[18:06:23.034]                 added <- setdiff(names, old_names)
[18:06:23.034]                 removed <- setdiff(old_names, names)
[18:06:23.034]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:23.034]                   envs[common]]
[18:06:23.034]                 NAMES <- toupper(changed)
[18:06:23.034]                 args <- list()
[18:06:23.034]                 for (kk in seq_along(NAMES)) {
[18:06:23.034]                   name <- changed[[kk]]
[18:06:23.034]                   NAME <- NAMES[[kk]]
[18:06:23.034]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.034]                     next
[18:06:23.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.034]                 }
[18:06:23.034]                 NAMES <- toupper(added)
[18:06:23.034]                 for (kk in seq_along(NAMES)) {
[18:06:23.034]                   name <- added[[kk]]
[18:06:23.034]                   NAME <- NAMES[[kk]]
[18:06:23.034]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.034]                     next
[18:06:23.034]                   args[[name]] <- ""
[18:06:23.034]                 }
[18:06:23.034]                 NAMES <- toupper(removed)
[18:06:23.034]                 for (kk in seq_along(NAMES)) {
[18:06:23.034]                   name <- removed[[kk]]
[18:06:23.034]                   NAME <- NAMES[[kk]]
[18:06:23.034]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.034]                     next
[18:06:23.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.034]                 }
[18:06:23.034]                 if (length(args) > 0) 
[18:06:23.034]                   base::do.call(base::Sys.setenv, args = args)
[18:06:23.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:23.034]             }
[18:06:23.034]             else {
[18:06:23.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:23.034]             }
[18:06:23.034]             {
[18:06:23.034]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:23.034]                   0L) {
[18:06:23.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:23.034]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:23.034]                   base::options(opts)
[18:06:23.034]                 }
[18:06:23.034]                 {
[18:06:23.034]                   {
[18:06:23.034]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:23.034]                     NULL
[18:06:23.034]                   }
[18:06:23.034]                   options(future.plan = NULL)
[18:06:23.034]                   if (is.na(NA_character_)) 
[18:06:23.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:23.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:23.034]                     .init = FALSE)
[18:06:23.034]                 }
[18:06:23.034]             }
[18:06:23.034]         }
[18:06:23.034]     })
[18:06:23.034]     if (TRUE) {
[18:06:23.034]         base::sink(type = "output", split = FALSE)
[18:06:23.034]         if (TRUE) {
[18:06:23.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:23.034]         }
[18:06:23.034]         else {
[18:06:23.034]             ...future.result["stdout"] <- base::list(NULL)
[18:06:23.034]         }
[18:06:23.034]         base::close(...future.stdout)
[18:06:23.034]         ...future.stdout <- NULL
[18:06:23.034]     }
[18:06:23.034]     ...future.result$conditions <- ...future.conditions
[18:06:23.034]     ...future.result$finished <- base::Sys.time()
[18:06:23.034]     ...future.result
[18:06:23.034] }
[18:06:23.042] MultisessionFuture started
[18:06:23.042] - Launch lazy future ... done
[18:06:23.042] run() for ‘MultisessionFuture’ ... done
[18:06:23.586] receiveMessageFromWorker() for ClusterFuture ...
[18:06:23.587] - Validating connection of MultisessionFuture
[18:06:23.587] - received message: FutureResult
[18:06:23.588] - Received FutureResult
[18:06:23.588] - Erased future from FutureRegistry
[18:06:23.588] result() for ClusterFuture ...
[18:06:23.589] - result already collected: FutureResult
[18:06:23.589] result() for ClusterFuture ... done
[18:06:23.589] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:23.590] A MultisessionFuture was resolved
- w/ exception ...
[18:06:23.590] getGlobalsAndPackages() ...
[18:06:23.590] Searching for globals...
[18:06:23.592] - globals found: [2] ‘list’, ‘stop’
[18:06:23.593] Searching for globals ... DONE
[18:06:23.593] Resolving globals: FALSE
[18:06:23.594] 
[18:06:23.595] 
[18:06:23.595] getGlobalsAndPackages() ... DONE
[18:06:23.596] run() for ‘Future’ ...
[18:06:23.596] - state: ‘created’
[18:06:23.596] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:23.633] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:23.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:23.634]   - Field: ‘node’
[18:06:23.634]   - Field: ‘label’
[18:06:23.635]   - Field: ‘local’
[18:06:23.635]   - Field: ‘owner’
[18:06:23.635]   - Field: ‘envir’
[18:06:23.636]   - Field: ‘workers’
[18:06:23.636]   - Field: ‘packages’
[18:06:23.636]   - Field: ‘gc’
[18:06:23.637]   - Field: ‘conditions’
[18:06:23.637]   - Field: ‘persistent’
[18:06:23.637]   - Field: ‘expr’
[18:06:23.637]   - Field: ‘uuid’
[18:06:23.638]   - Field: ‘seed’
[18:06:23.638]   - Field: ‘version’
[18:06:23.638]   - Field: ‘result’
[18:06:23.638]   - Field: ‘asynchronous’
[18:06:23.639]   - Field: ‘calls’
[18:06:23.639]   - Field: ‘globals’
[18:06:23.639]   - Field: ‘stdout’
[18:06:23.640]   - Field: ‘earlySignal’
[18:06:23.640]   - Field: ‘lazy’
[18:06:23.640]   - Field: ‘state’
[18:06:23.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:23.641] - Launch lazy future ...
[18:06:23.641] Packages needed by the future expression (n = 0): <none>
[18:06:23.642] Packages needed by future strategies (n = 0): <none>
[18:06:23.643] {
[18:06:23.643]     {
[18:06:23.643]         {
[18:06:23.643]             ...future.startTime <- base::Sys.time()
[18:06:23.643]             {
[18:06:23.643]                 {
[18:06:23.643]                   {
[18:06:23.643]                     {
[18:06:23.643]                       base::local({
[18:06:23.643]                         has_future <- base::requireNamespace("future", 
[18:06:23.643]                           quietly = TRUE)
[18:06:23.643]                         if (has_future) {
[18:06:23.643]                           ns <- base::getNamespace("future")
[18:06:23.643]                           version <- ns[[".package"]][["version"]]
[18:06:23.643]                           if (is.null(version)) 
[18:06:23.643]                             version <- utils::packageVersion("future")
[18:06:23.643]                         }
[18:06:23.643]                         else {
[18:06:23.643]                           version <- NULL
[18:06:23.643]                         }
[18:06:23.643]                         if (!has_future || version < "1.8.0") {
[18:06:23.643]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:23.643]                             "", base::R.version$version.string), 
[18:06:23.643]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:23.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:23.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:23.643]                               "release", "version")], collapse = " "), 
[18:06:23.643]                             hostname = base::Sys.info()[["nodename"]])
[18:06:23.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:23.643]                             info)
[18:06:23.643]                           info <- base::paste(info, collapse = "; ")
[18:06:23.643]                           if (!has_future) {
[18:06:23.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:23.643]                               info)
[18:06:23.643]                           }
[18:06:23.643]                           else {
[18:06:23.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:23.643]                               info, version)
[18:06:23.643]                           }
[18:06:23.643]                           base::stop(msg)
[18:06:23.643]                         }
[18:06:23.643]                       })
[18:06:23.643]                     }
[18:06:23.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:23.643]                     base::options(mc.cores = 1L)
[18:06:23.643]                   }
[18:06:23.643]                   ...future.strategy.old <- future::plan("list")
[18:06:23.643]                   options(future.plan = NULL)
[18:06:23.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:23.643]                 }
[18:06:23.643]                 ...future.workdir <- getwd()
[18:06:23.643]             }
[18:06:23.643]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:23.643]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:23.643]         }
[18:06:23.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:23.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:23.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:23.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:23.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:23.643]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:23.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:23.643]             base::names(...future.oldOptions))
[18:06:23.643]     }
[18:06:23.643]     if (FALSE) {
[18:06:23.643]     }
[18:06:23.643]     else {
[18:06:23.643]         if (TRUE) {
[18:06:23.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:23.643]                 open = "w")
[18:06:23.643]         }
[18:06:23.643]         else {
[18:06:23.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:23.643]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:23.643]         }
[18:06:23.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:23.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:23.643]             base::sink(type = "output", split = FALSE)
[18:06:23.643]             base::close(...future.stdout)
[18:06:23.643]         }, add = TRUE)
[18:06:23.643]     }
[18:06:23.643]     ...future.frame <- base::sys.nframe()
[18:06:23.643]     ...future.conditions <- base::list()
[18:06:23.643]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:23.643]     if (FALSE) {
[18:06:23.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:23.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:23.643]     }
[18:06:23.643]     ...future.result <- base::tryCatch({
[18:06:23.643]         base::withCallingHandlers({
[18:06:23.643]             ...future.value <- base::withVisible(base::local({
[18:06:23.643]                 ...future.makeSendCondition <- base::local({
[18:06:23.643]                   sendCondition <- NULL
[18:06:23.643]                   function(frame = 1L) {
[18:06:23.643]                     if (is.function(sendCondition)) 
[18:06:23.643]                       return(sendCondition)
[18:06:23.643]                     ns <- getNamespace("parallel")
[18:06:23.643]                     if (exists("sendData", mode = "function", 
[18:06:23.643]                       envir = ns)) {
[18:06:23.643]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:23.643]                         envir = ns)
[18:06:23.643]                       envir <- sys.frame(frame)
[18:06:23.643]                       master <- NULL
[18:06:23.643]                       while (!identical(envir, .GlobalEnv) && 
[18:06:23.643]                         !identical(envir, emptyenv())) {
[18:06:23.643]                         if (exists("master", mode = "list", envir = envir, 
[18:06:23.643]                           inherits = FALSE)) {
[18:06:23.643]                           master <- get("master", mode = "list", 
[18:06:23.643]                             envir = envir, inherits = FALSE)
[18:06:23.643]                           if (inherits(master, c("SOCKnode", 
[18:06:23.643]                             "SOCK0node"))) {
[18:06:23.643]                             sendCondition <<- function(cond) {
[18:06:23.643]                               data <- list(type = "VALUE", value = cond, 
[18:06:23.643]                                 success = TRUE)
[18:06:23.643]                               parallel_sendData(master, data)
[18:06:23.643]                             }
[18:06:23.643]                             return(sendCondition)
[18:06:23.643]                           }
[18:06:23.643]                         }
[18:06:23.643]                         frame <- frame + 1L
[18:06:23.643]                         envir <- sys.frame(frame)
[18:06:23.643]                       }
[18:06:23.643]                     }
[18:06:23.643]                     sendCondition <<- function(cond) NULL
[18:06:23.643]                   }
[18:06:23.643]                 })
[18:06:23.643]                 withCallingHandlers({
[18:06:23.643]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:23.643]                 }, immediateCondition = function(cond) {
[18:06:23.643]                   sendCondition <- ...future.makeSendCondition()
[18:06:23.643]                   sendCondition(cond)
[18:06:23.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.643]                   {
[18:06:23.643]                     inherits <- base::inherits
[18:06:23.643]                     invokeRestart <- base::invokeRestart
[18:06:23.643]                     is.null <- base::is.null
[18:06:23.643]                     muffled <- FALSE
[18:06:23.643]                     if (inherits(cond, "message")) {
[18:06:23.643]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:23.643]                       if (muffled) 
[18:06:23.643]                         invokeRestart("muffleMessage")
[18:06:23.643]                     }
[18:06:23.643]                     else if (inherits(cond, "warning")) {
[18:06:23.643]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:23.643]                       if (muffled) 
[18:06:23.643]                         invokeRestart("muffleWarning")
[18:06:23.643]                     }
[18:06:23.643]                     else if (inherits(cond, "condition")) {
[18:06:23.643]                       if (!is.null(pattern)) {
[18:06:23.643]                         computeRestarts <- base::computeRestarts
[18:06:23.643]                         grepl <- base::grepl
[18:06:23.643]                         restarts <- computeRestarts(cond)
[18:06:23.643]                         for (restart in restarts) {
[18:06:23.643]                           name <- restart$name
[18:06:23.643]                           if (is.null(name)) 
[18:06:23.643]                             next
[18:06:23.643]                           if (!grepl(pattern, name)) 
[18:06:23.643]                             next
[18:06:23.643]                           invokeRestart(restart)
[18:06:23.643]                           muffled <- TRUE
[18:06:23.643]                           break
[18:06:23.643]                         }
[18:06:23.643]                       }
[18:06:23.643]                     }
[18:06:23.643]                     invisible(muffled)
[18:06:23.643]                   }
[18:06:23.643]                   muffleCondition(cond)
[18:06:23.643]                 })
[18:06:23.643]             }))
[18:06:23.643]             future::FutureResult(value = ...future.value$value, 
[18:06:23.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.643]                   ...future.rng), globalenv = if (FALSE) 
[18:06:23.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:23.643]                     ...future.globalenv.names))
[18:06:23.643]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:23.643]         }, condition = base::local({
[18:06:23.643]             c <- base::c
[18:06:23.643]             inherits <- base::inherits
[18:06:23.643]             invokeRestart <- base::invokeRestart
[18:06:23.643]             length <- base::length
[18:06:23.643]             list <- base::list
[18:06:23.643]             seq.int <- base::seq.int
[18:06:23.643]             signalCondition <- base::signalCondition
[18:06:23.643]             sys.calls <- base::sys.calls
[18:06:23.643]             `[[` <- base::`[[`
[18:06:23.643]             `+` <- base::`+`
[18:06:23.643]             `<<-` <- base::`<<-`
[18:06:23.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:23.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:23.643]                   3L)]
[18:06:23.643]             }
[18:06:23.643]             function(cond) {
[18:06:23.643]                 is_error <- inherits(cond, "error")
[18:06:23.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:23.643]                   NULL)
[18:06:23.643]                 if (is_error) {
[18:06:23.643]                   sessionInformation <- function() {
[18:06:23.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:23.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:23.643]                       search = base::search(), system = base::Sys.info())
[18:06:23.643]                   }
[18:06:23.643]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:23.643]                     cond$call), session = sessionInformation(), 
[18:06:23.643]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:23.643]                   signalCondition(cond)
[18:06:23.643]                 }
[18:06:23.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:23.643]                 "immediateCondition"))) {
[18:06:23.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:23.643]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:23.643]                   if (TRUE && !signal) {
[18:06:23.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.643]                     {
[18:06:23.643]                       inherits <- base::inherits
[18:06:23.643]                       invokeRestart <- base::invokeRestart
[18:06:23.643]                       is.null <- base::is.null
[18:06:23.643]                       muffled <- FALSE
[18:06:23.643]                       if (inherits(cond, "message")) {
[18:06:23.643]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.643]                         if (muffled) 
[18:06:23.643]                           invokeRestart("muffleMessage")
[18:06:23.643]                       }
[18:06:23.643]                       else if (inherits(cond, "warning")) {
[18:06:23.643]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.643]                         if (muffled) 
[18:06:23.643]                           invokeRestart("muffleWarning")
[18:06:23.643]                       }
[18:06:23.643]                       else if (inherits(cond, "condition")) {
[18:06:23.643]                         if (!is.null(pattern)) {
[18:06:23.643]                           computeRestarts <- base::computeRestarts
[18:06:23.643]                           grepl <- base::grepl
[18:06:23.643]                           restarts <- computeRestarts(cond)
[18:06:23.643]                           for (restart in restarts) {
[18:06:23.643]                             name <- restart$name
[18:06:23.643]                             if (is.null(name)) 
[18:06:23.643]                               next
[18:06:23.643]                             if (!grepl(pattern, name)) 
[18:06:23.643]                               next
[18:06:23.643]                             invokeRestart(restart)
[18:06:23.643]                             muffled <- TRUE
[18:06:23.643]                             break
[18:06:23.643]                           }
[18:06:23.643]                         }
[18:06:23.643]                       }
[18:06:23.643]                       invisible(muffled)
[18:06:23.643]                     }
[18:06:23.643]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.643]                   }
[18:06:23.643]                 }
[18:06:23.643]                 else {
[18:06:23.643]                   if (TRUE) {
[18:06:23.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.643]                     {
[18:06:23.643]                       inherits <- base::inherits
[18:06:23.643]                       invokeRestart <- base::invokeRestart
[18:06:23.643]                       is.null <- base::is.null
[18:06:23.643]                       muffled <- FALSE
[18:06:23.643]                       if (inherits(cond, "message")) {
[18:06:23.643]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.643]                         if (muffled) 
[18:06:23.643]                           invokeRestart("muffleMessage")
[18:06:23.643]                       }
[18:06:23.643]                       else if (inherits(cond, "warning")) {
[18:06:23.643]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.643]                         if (muffled) 
[18:06:23.643]                           invokeRestart("muffleWarning")
[18:06:23.643]                       }
[18:06:23.643]                       else if (inherits(cond, "condition")) {
[18:06:23.643]                         if (!is.null(pattern)) {
[18:06:23.643]                           computeRestarts <- base::computeRestarts
[18:06:23.643]                           grepl <- base::grepl
[18:06:23.643]                           restarts <- computeRestarts(cond)
[18:06:23.643]                           for (restart in restarts) {
[18:06:23.643]                             name <- restart$name
[18:06:23.643]                             if (is.null(name)) 
[18:06:23.643]                               next
[18:06:23.643]                             if (!grepl(pattern, name)) 
[18:06:23.643]                               next
[18:06:23.643]                             invokeRestart(restart)
[18:06:23.643]                             muffled <- TRUE
[18:06:23.643]                             break
[18:06:23.643]                           }
[18:06:23.643]                         }
[18:06:23.643]                       }
[18:06:23.643]                       invisible(muffled)
[18:06:23.643]                     }
[18:06:23.643]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.643]                   }
[18:06:23.643]                 }
[18:06:23.643]             }
[18:06:23.643]         }))
[18:06:23.643]     }, error = function(ex) {
[18:06:23.643]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:23.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.643]                 ...future.rng), started = ...future.startTime, 
[18:06:23.643]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:23.643]             version = "1.8"), class = "FutureResult")
[18:06:23.643]     }, finally = {
[18:06:23.643]         if (!identical(...future.workdir, getwd())) 
[18:06:23.643]             setwd(...future.workdir)
[18:06:23.643]         {
[18:06:23.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:23.643]                 ...future.oldOptions$nwarnings <- NULL
[18:06:23.643]             }
[18:06:23.643]             base::options(...future.oldOptions)
[18:06:23.643]             if (.Platform$OS.type == "windows") {
[18:06:23.643]                 old_names <- names(...future.oldEnvVars)
[18:06:23.643]                 envs <- base::Sys.getenv()
[18:06:23.643]                 names <- names(envs)
[18:06:23.643]                 common <- intersect(names, old_names)
[18:06:23.643]                 added <- setdiff(names, old_names)
[18:06:23.643]                 removed <- setdiff(old_names, names)
[18:06:23.643]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:23.643]                   envs[common]]
[18:06:23.643]                 NAMES <- toupper(changed)
[18:06:23.643]                 args <- list()
[18:06:23.643]                 for (kk in seq_along(NAMES)) {
[18:06:23.643]                   name <- changed[[kk]]
[18:06:23.643]                   NAME <- NAMES[[kk]]
[18:06:23.643]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.643]                     next
[18:06:23.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.643]                 }
[18:06:23.643]                 NAMES <- toupper(added)
[18:06:23.643]                 for (kk in seq_along(NAMES)) {
[18:06:23.643]                   name <- added[[kk]]
[18:06:23.643]                   NAME <- NAMES[[kk]]
[18:06:23.643]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.643]                     next
[18:06:23.643]                   args[[name]] <- ""
[18:06:23.643]                 }
[18:06:23.643]                 NAMES <- toupper(removed)
[18:06:23.643]                 for (kk in seq_along(NAMES)) {
[18:06:23.643]                   name <- removed[[kk]]
[18:06:23.643]                   NAME <- NAMES[[kk]]
[18:06:23.643]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.643]                     next
[18:06:23.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.643]                 }
[18:06:23.643]                 if (length(args) > 0) 
[18:06:23.643]                   base::do.call(base::Sys.setenv, args = args)
[18:06:23.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:23.643]             }
[18:06:23.643]             else {
[18:06:23.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:23.643]             }
[18:06:23.643]             {
[18:06:23.643]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:23.643]                   0L) {
[18:06:23.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:23.643]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:23.643]                   base::options(opts)
[18:06:23.643]                 }
[18:06:23.643]                 {
[18:06:23.643]                   {
[18:06:23.643]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:23.643]                     NULL
[18:06:23.643]                   }
[18:06:23.643]                   options(future.plan = NULL)
[18:06:23.643]                   if (is.na(NA_character_)) 
[18:06:23.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:23.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:23.643]                     .init = FALSE)
[18:06:23.643]                 }
[18:06:23.643]             }
[18:06:23.643]         }
[18:06:23.643]     })
[18:06:23.643]     if (TRUE) {
[18:06:23.643]         base::sink(type = "output", split = FALSE)
[18:06:23.643]         if (TRUE) {
[18:06:23.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:23.643]         }
[18:06:23.643]         else {
[18:06:23.643]             ...future.result["stdout"] <- base::list(NULL)
[18:06:23.643]         }
[18:06:23.643]         base::close(...future.stdout)
[18:06:23.643]         ...future.stdout <- NULL
[18:06:23.643]     }
[18:06:23.643]     ...future.result$conditions <- ...future.conditions
[18:06:23.643]     ...future.result$finished <- base::Sys.time()
[18:06:23.643]     ...future.result
[18:06:23.643] }
[18:06:23.650] MultisessionFuture started
[18:06:23.650] - Launch lazy future ... done
[18:06:23.650] run() for ‘MultisessionFuture’ ... done
[18:06:23.695] receiveMessageFromWorker() for ClusterFuture ...
[18:06:23.695] - Validating connection of MultisessionFuture
[18:06:23.697] - received message: FutureResult
[18:06:23.697] - Received FutureResult
[18:06:23.697] - Erased future from FutureRegistry
[18:06:23.698] result() for ClusterFuture ...
[18:06:23.698] - result already collected: FutureResult
[18:06:23.698] result() for ClusterFuture ... done
[18:06:23.699] signalConditions() ...
[18:06:23.699]  - include = ‘immediateCondition’
[18:06:23.699]  - exclude = 
[18:06:23.699]  - resignal = FALSE
[18:06:23.700]  - Number of conditions: 1
[18:06:23.700] signalConditions() ... done
[18:06:23.700] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:23.701] A MultisessionFuture was resolved
[18:06:23.701] getGlobalsAndPackages() ...
[18:06:23.701] Searching for globals...
[18:06:23.703] - globals found: [2] ‘list’, ‘stop’
[18:06:23.704] Searching for globals ... DONE
[18:06:23.704] Resolving globals: FALSE
[18:06:23.705] 
[18:06:23.705] 
[18:06:23.706] getGlobalsAndPackages() ... DONE
[18:06:23.706] run() for ‘Future’ ...
[18:06:23.707] - state: ‘created’
[18:06:23.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:23.733] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:23.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:23.734]   - Field: ‘node’
[18:06:23.734]   - Field: ‘label’
[18:06:23.734]   - Field: ‘local’
[18:06:23.734]   - Field: ‘owner’
[18:06:23.734]   - Field: ‘envir’
[18:06:23.735]   - Field: ‘workers’
[18:06:23.735]   - Field: ‘packages’
[18:06:23.735]   - Field: ‘gc’
[18:06:23.735]   - Field: ‘conditions’
[18:06:23.735]   - Field: ‘persistent’
[18:06:23.736]   - Field: ‘expr’
[18:06:23.736]   - Field: ‘uuid’
[18:06:23.736]   - Field: ‘seed’
[18:06:23.736]   - Field: ‘version’
[18:06:23.736]   - Field: ‘result’
[18:06:23.737]   - Field: ‘asynchronous’
[18:06:23.737]   - Field: ‘calls’
[18:06:23.737]   - Field: ‘globals’
[18:06:23.737]   - Field: ‘stdout’
[18:06:23.737]   - Field: ‘earlySignal’
[18:06:23.738]   - Field: ‘lazy’
[18:06:23.738]   - Field: ‘state’
[18:06:23.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:23.738] - Launch lazy future ...
[18:06:23.739] Packages needed by the future expression (n = 0): <none>
[18:06:23.739] Packages needed by future strategies (n = 0): <none>
[18:06:23.740] {
[18:06:23.740]     {
[18:06:23.740]         {
[18:06:23.740]             ...future.startTime <- base::Sys.time()
[18:06:23.740]             {
[18:06:23.740]                 {
[18:06:23.740]                   {
[18:06:23.740]                     {
[18:06:23.740]                       base::local({
[18:06:23.740]                         has_future <- base::requireNamespace("future", 
[18:06:23.740]                           quietly = TRUE)
[18:06:23.740]                         if (has_future) {
[18:06:23.740]                           ns <- base::getNamespace("future")
[18:06:23.740]                           version <- ns[[".package"]][["version"]]
[18:06:23.740]                           if (is.null(version)) 
[18:06:23.740]                             version <- utils::packageVersion("future")
[18:06:23.740]                         }
[18:06:23.740]                         else {
[18:06:23.740]                           version <- NULL
[18:06:23.740]                         }
[18:06:23.740]                         if (!has_future || version < "1.8.0") {
[18:06:23.740]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:23.740]                             "", base::R.version$version.string), 
[18:06:23.740]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:23.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:23.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:23.740]                               "release", "version")], collapse = " "), 
[18:06:23.740]                             hostname = base::Sys.info()[["nodename"]])
[18:06:23.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:23.740]                             info)
[18:06:23.740]                           info <- base::paste(info, collapse = "; ")
[18:06:23.740]                           if (!has_future) {
[18:06:23.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:23.740]                               info)
[18:06:23.740]                           }
[18:06:23.740]                           else {
[18:06:23.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:23.740]                               info, version)
[18:06:23.740]                           }
[18:06:23.740]                           base::stop(msg)
[18:06:23.740]                         }
[18:06:23.740]                       })
[18:06:23.740]                     }
[18:06:23.740]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:23.740]                     base::options(mc.cores = 1L)
[18:06:23.740]                   }
[18:06:23.740]                   ...future.strategy.old <- future::plan("list")
[18:06:23.740]                   options(future.plan = NULL)
[18:06:23.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:23.740]                 }
[18:06:23.740]                 ...future.workdir <- getwd()
[18:06:23.740]             }
[18:06:23.740]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:23.740]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:23.740]         }
[18:06:23.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:23.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:23.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:23.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:23.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:23.740]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:23.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:23.740]             base::names(...future.oldOptions))
[18:06:23.740]     }
[18:06:23.740]     if (FALSE) {
[18:06:23.740]     }
[18:06:23.740]     else {
[18:06:23.740]         if (TRUE) {
[18:06:23.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:23.740]                 open = "w")
[18:06:23.740]         }
[18:06:23.740]         else {
[18:06:23.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:23.740]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:23.740]         }
[18:06:23.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:23.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:23.740]             base::sink(type = "output", split = FALSE)
[18:06:23.740]             base::close(...future.stdout)
[18:06:23.740]         }, add = TRUE)
[18:06:23.740]     }
[18:06:23.740]     ...future.frame <- base::sys.nframe()
[18:06:23.740]     ...future.conditions <- base::list()
[18:06:23.740]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:23.740]     if (FALSE) {
[18:06:23.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:23.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:23.740]     }
[18:06:23.740]     ...future.result <- base::tryCatch({
[18:06:23.740]         base::withCallingHandlers({
[18:06:23.740]             ...future.value <- base::withVisible(base::local({
[18:06:23.740]                 ...future.makeSendCondition <- base::local({
[18:06:23.740]                   sendCondition <- NULL
[18:06:23.740]                   function(frame = 1L) {
[18:06:23.740]                     if (is.function(sendCondition)) 
[18:06:23.740]                       return(sendCondition)
[18:06:23.740]                     ns <- getNamespace("parallel")
[18:06:23.740]                     if (exists("sendData", mode = "function", 
[18:06:23.740]                       envir = ns)) {
[18:06:23.740]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:23.740]                         envir = ns)
[18:06:23.740]                       envir <- sys.frame(frame)
[18:06:23.740]                       master <- NULL
[18:06:23.740]                       while (!identical(envir, .GlobalEnv) && 
[18:06:23.740]                         !identical(envir, emptyenv())) {
[18:06:23.740]                         if (exists("master", mode = "list", envir = envir, 
[18:06:23.740]                           inherits = FALSE)) {
[18:06:23.740]                           master <- get("master", mode = "list", 
[18:06:23.740]                             envir = envir, inherits = FALSE)
[18:06:23.740]                           if (inherits(master, c("SOCKnode", 
[18:06:23.740]                             "SOCK0node"))) {
[18:06:23.740]                             sendCondition <<- function(cond) {
[18:06:23.740]                               data <- list(type = "VALUE", value = cond, 
[18:06:23.740]                                 success = TRUE)
[18:06:23.740]                               parallel_sendData(master, data)
[18:06:23.740]                             }
[18:06:23.740]                             return(sendCondition)
[18:06:23.740]                           }
[18:06:23.740]                         }
[18:06:23.740]                         frame <- frame + 1L
[18:06:23.740]                         envir <- sys.frame(frame)
[18:06:23.740]                       }
[18:06:23.740]                     }
[18:06:23.740]                     sendCondition <<- function(cond) NULL
[18:06:23.740]                   }
[18:06:23.740]                 })
[18:06:23.740]                 withCallingHandlers({
[18:06:23.740]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:23.740]                 }, immediateCondition = function(cond) {
[18:06:23.740]                   sendCondition <- ...future.makeSendCondition()
[18:06:23.740]                   sendCondition(cond)
[18:06:23.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.740]                   {
[18:06:23.740]                     inherits <- base::inherits
[18:06:23.740]                     invokeRestart <- base::invokeRestart
[18:06:23.740]                     is.null <- base::is.null
[18:06:23.740]                     muffled <- FALSE
[18:06:23.740]                     if (inherits(cond, "message")) {
[18:06:23.740]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:23.740]                       if (muffled) 
[18:06:23.740]                         invokeRestart("muffleMessage")
[18:06:23.740]                     }
[18:06:23.740]                     else if (inherits(cond, "warning")) {
[18:06:23.740]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:23.740]                       if (muffled) 
[18:06:23.740]                         invokeRestart("muffleWarning")
[18:06:23.740]                     }
[18:06:23.740]                     else if (inherits(cond, "condition")) {
[18:06:23.740]                       if (!is.null(pattern)) {
[18:06:23.740]                         computeRestarts <- base::computeRestarts
[18:06:23.740]                         grepl <- base::grepl
[18:06:23.740]                         restarts <- computeRestarts(cond)
[18:06:23.740]                         for (restart in restarts) {
[18:06:23.740]                           name <- restart$name
[18:06:23.740]                           if (is.null(name)) 
[18:06:23.740]                             next
[18:06:23.740]                           if (!grepl(pattern, name)) 
[18:06:23.740]                             next
[18:06:23.740]                           invokeRestart(restart)
[18:06:23.740]                           muffled <- TRUE
[18:06:23.740]                           break
[18:06:23.740]                         }
[18:06:23.740]                       }
[18:06:23.740]                     }
[18:06:23.740]                     invisible(muffled)
[18:06:23.740]                   }
[18:06:23.740]                   muffleCondition(cond)
[18:06:23.740]                 })
[18:06:23.740]             }))
[18:06:23.740]             future::FutureResult(value = ...future.value$value, 
[18:06:23.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.740]                   ...future.rng), globalenv = if (FALSE) 
[18:06:23.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:23.740]                     ...future.globalenv.names))
[18:06:23.740]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:23.740]         }, condition = base::local({
[18:06:23.740]             c <- base::c
[18:06:23.740]             inherits <- base::inherits
[18:06:23.740]             invokeRestart <- base::invokeRestart
[18:06:23.740]             length <- base::length
[18:06:23.740]             list <- base::list
[18:06:23.740]             seq.int <- base::seq.int
[18:06:23.740]             signalCondition <- base::signalCondition
[18:06:23.740]             sys.calls <- base::sys.calls
[18:06:23.740]             `[[` <- base::`[[`
[18:06:23.740]             `+` <- base::`+`
[18:06:23.740]             `<<-` <- base::`<<-`
[18:06:23.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:23.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:23.740]                   3L)]
[18:06:23.740]             }
[18:06:23.740]             function(cond) {
[18:06:23.740]                 is_error <- inherits(cond, "error")
[18:06:23.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:23.740]                   NULL)
[18:06:23.740]                 if (is_error) {
[18:06:23.740]                   sessionInformation <- function() {
[18:06:23.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:23.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:23.740]                       search = base::search(), system = base::Sys.info())
[18:06:23.740]                   }
[18:06:23.740]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:23.740]                     cond$call), session = sessionInformation(), 
[18:06:23.740]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:23.740]                   signalCondition(cond)
[18:06:23.740]                 }
[18:06:23.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:23.740]                 "immediateCondition"))) {
[18:06:23.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:23.740]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:23.740]                   if (TRUE && !signal) {
[18:06:23.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.740]                     {
[18:06:23.740]                       inherits <- base::inherits
[18:06:23.740]                       invokeRestart <- base::invokeRestart
[18:06:23.740]                       is.null <- base::is.null
[18:06:23.740]                       muffled <- FALSE
[18:06:23.740]                       if (inherits(cond, "message")) {
[18:06:23.740]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.740]                         if (muffled) 
[18:06:23.740]                           invokeRestart("muffleMessage")
[18:06:23.740]                       }
[18:06:23.740]                       else if (inherits(cond, "warning")) {
[18:06:23.740]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.740]                         if (muffled) 
[18:06:23.740]                           invokeRestart("muffleWarning")
[18:06:23.740]                       }
[18:06:23.740]                       else if (inherits(cond, "condition")) {
[18:06:23.740]                         if (!is.null(pattern)) {
[18:06:23.740]                           computeRestarts <- base::computeRestarts
[18:06:23.740]                           grepl <- base::grepl
[18:06:23.740]                           restarts <- computeRestarts(cond)
[18:06:23.740]                           for (restart in restarts) {
[18:06:23.740]                             name <- restart$name
[18:06:23.740]                             if (is.null(name)) 
[18:06:23.740]                               next
[18:06:23.740]                             if (!grepl(pattern, name)) 
[18:06:23.740]                               next
[18:06:23.740]                             invokeRestart(restart)
[18:06:23.740]                             muffled <- TRUE
[18:06:23.740]                             break
[18:06:23.740]                           }
[18:06:23.740]                         }
[18:06:23.740]                       }
[18:06:23.740]                       invisible(muffled)
[18:06:23.740]                     }
[18:06:23.740]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.740]                   }
[18:06:23.740]                 }
[18:06:23.740]                 else {
[18:06:23.740]                   if (TRUE) {
[18:06:23.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.740]                     {
[18:06:23.740]                       inherits <- base::inherits
[18:06:23.740]                       invokeRestart <- base::invokeRestart
[18:06:23.740]                       is.null <- base::is.null
[18:06:23.740]                       muffled <- FALSE
[18:06:23.740]                       if (inherits(cond, "message")) {
[18:06:23.740]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.740]                         if (muffled) 
[18:06:23.740]                           invokeRestart("muffleMessage")
[18:06:23.740]                       }
[18:06:23.740]                       else if (inherits(cond, "warning")) {
[18:06:23.740]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.740]                         if (muffled) 
[18:06:23.740]                           invokeRestart("muffleWarning")
[18:06:23.740]                       }
[18:06:23.740]                       else if (inherits(cond, "condition")) {
[18:06:23.740]                         if (!is.null(pattern)) {
[18:06:23.740]                           computeRestarts <- base::computeRestarts
[18:06:23.740]                           grepl <- base::grepl
[18:06:23.740]                           restarts <- computeRestarts(cond)
[18:06:23.740]                           for (restart in restarts) {
[18:06:23.740]                             name <- restart$name
[18:06:23.740]                             if (is.null(name)) 
[18:06:23.740]                               next
[18:06:23.740]                             if (!grepl(pattern, name)) 
[18:06:23.740]                               next
[18:06:23.740]                             invokeRestart(restart)
[18:06:23.740]                             muffled <- TRUE
[18:06:23.740]                             break
[18:06:23.740]                           }
[18:06:23.740]                         }
[18:06:23.740]                       }
[18:06:23.740]                       invisible(muffled)
[18:06:23.740]                     }
[18:06:23.740]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.740]                   }
[18:06:23.740]                 }
[18:06:23.740]             }
[18:06:23.740]         }))
[18:06:23.740]     }, error = function(ex) {
[18:06:23.740]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:23.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.740]                 ...future.rng), started = ...future.startTime, 
[18:06:23.740]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:23.740]             version = "1.8"), class = "FutureResult")
[18:06:23.740]     }, finally = {
[18:06:23.740]         if (!identical(...future.workdir, getwd())) 
[18:06:23.740]             setwd(...future.workdir)
[18:06:23.740]         {
[18:06:23.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:23.740]                 ...future.oldOptions$nwarnings <- NULL
[18:06:23.740]             }
[18:06:23.740]             base::options(...future.oldOptions)
[18:06:23.740]             if (.Platform$OS.type == "windows") {
[18:06:23.740]                 old_names <- names(...future.oldEnvVars)
[18:06:23.740]                 envs <- base::Sys.getenv()
[18:06:23.740]                 names <- names(envs)
[18:06:23.740]                 common <- intersect(names, old_names)
[18:06:23.740]                 added <- setdiff(names, old_names)
[18:06:23.740]                 removed <- setdiff(old_names, names)
[18:06:23.740]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:23.740]                   envs[common]]
[18:06:23.740]                 NAMES <- toupper(changed)
[18:06:23.740]                 args <- list()
[18:06:23.740]                 for (kk in seq_along(NAMES)) {
[18:06:23.740]                   name <- changed[[kk]]
[18:06:23.740]                   NAME <- NAMES[[kk]]
[18:06:23.740]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.740]                     next
[18:06:23.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.740]                 }
[18:06:23.740]                 NAMES <- toupper(added)
[18:06:23.740]                 for (kk in seq_along(NAMES)) {
[18:06:23.740]                   name <- added[[kk]]
[18:06:23.740]                   NAME <- NAMES[[kk]]
[18:06:23.740]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.740]                     next
[18:06:23.740]                   args[[name]] <- ""
[18:06:23.740]                 }
[18:06:23.740]                 NAMES <- toupper(removed)
[18:06:23.740]                 for (kk in seq_along(NAMES)) {
[18:06:23.740]                   name <- removed[[kk]]
[18:06:23.740]                   NAME <- NAMES[[kk]]
[18:06:23.740]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.740]                     next
[18:06:23.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.740]                 }
[18:06:23.740]                 if (length(args) > 0) 
[18:06:23.740]                   base::do.call(base::Sys.setenv, args = args)
[18:06:23.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:23.740]             }
[18:06:23.740]             else {
[18:06:23.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:23.740]             }
[18:06:23.740]             {
[18:06:23.740]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:23.740]                   0L) {
[18:06:23.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:23.740]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:23.740]                   base::options(opts)
[18:06:23.740]                 }
[18:06:23.740]                 {
[18:06:23.740]                   {
[18:06:23.740]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:23.740]                     NULL
[18:06:23.740]                   }
[18:06:23.740]                   options(future.plan = NULL)
[18:06:23.740]                   if (is.na(NA_character_)) 
[18:06:23.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:23.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:23.740]                     .init = FALSE)
[18:06:23.740]                 }
[18:06:23.740]             }
[18:06:23.740]         }
[18:06:23.740]     })
[18:06:23.740]     if (TRUE) {
[18:06:23.740]         base::sink(type = "output", split = FALSE)
[18:06:23.740]         if (TRUE) {
[18:06:23.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:23.740]         }
[18:06:23.740]         else {
[18:06:23.740]             ...future.result["stdout"] <- base::list(NULL)
[18:06:23.740]         }
[18:06:23.740]         base::close(...future.stdout)
[18:06:23.740]         ...future.stdout <- NULL
[18:06:23.740]     }
[18:06:23.740]     ...future.result$conditions <- ...future.conditions
[18:06:23.740]     ...future.result$finished <- base::Sys.time()
[18:06:23.740]     ...future.result
[18:06:23.740] }
[18:06:23.746] MultisessionFuture started
[18:06:23.746] - Launch lazy future ... done
[18:06:23.746] run() for ‘MultisessionFuture’ ... done
[18:06:23.791] receiveMessageFromWorker() for ClusterFuture ...
[18:06:23.791] - Validating connection of MultisessionFuture
[18:06:23.793] - received message: FutureResult
[18:06:23.793] - Received FutureResult
[18:06:23.793] - Erased future from FutureRegistry
[18:06:23.794] result() for ClusterFuture ...
[18:06:23.794] - result already collected: FutureResult
[18:06:23.794] result() for ClusterFuture ... done
[18:06:23.795] signalConditions() ...
[18:06:23.795]  - include = ‘immediateCondition’
[18:06:23.795]  - exclude = 
[18:06:23.795]  - resignal = FALSE
[18:06:23.796]  - Number of conditions: 1
[18:06:23.796] signalConditions() ... done
[18:06:23.796] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:23.797] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[18:06:23.798] getGlobalsAndPackages() ...
[18:06:23.798] Searching for globals...
[18:06:23.801] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:23.802] Searching for globals ... DONE
[18:06:23.802] Resolving globals: FALSE
[18:06:23.803] 
[18:06:23.803] 
[18:06:23.804] getGlobalsAndPackages() ... DONE
[18:06:23.804] run() for ‘Future’ ...
[18:06:23.805] - state: ‘created’
[18:06:23.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:23.834] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:23.834] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:23.834]   - Field: ‘node’
[18:06:23.834]   - Field: ‘label’
[18:06:23.835]   - Field: ‘local’
[18:06:23.835]   - Field: ‘owner’
[18:06:23.835]   - Field: ‘envir’
[18:06:23.835]   - Field: ‘workers’
[18:06:23.836]   - Field: ‘packages’
[18:06:23.836]   - Field: ‘gc’
[18:06:23.836]   - Field: ‘conditions’
[18:06:23.836]   - Field: ‘persistent’
[18:06:23.836]   - Field: ‘expr’
[18:06:23.837]   - Field: ‘uuid’
[18:06:23.837]   - Field: ‘seed’
[18:06:23.837]   - Field: ‘version’
[18:06:23.838]   - Field: ‘result’
[18:06:23.838]   - Field: ‘asynchronous’
[18:06:23.838]   - Field: ‘calls’
[18:06:23.838]   - Field: ‘globals’
[18:06:23.839]   - Field: ‘stdout’
[18:06:23.839]   - Field: ‘earlySignal’
[18:06:23.839]   - Field: ‘lazy’
[18:06:23.839]   - Field: ‘state’
[18:06:23.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:23.840] - Launch lazy future ...
[18:06:23.840] Packages needed by the future expression (n = 0): <none>
[18:06:23.840] Packages needed by future strategies (n = 0): <none>
[18:06:23.841] {
[18:06:23.841]     {
[18:06:23.841]         {
[18:06:23.841]             ...future.startTime <- base::Sys.time()
[18:06:23.841]             {
[18:06:23.841]                 {
[18:06:23.841]                   {
[18:06:23.841]                     {
[18:06:23.841]                       base::local({
[18:06:23.841]                         has_future <- base::requireNamespace("future", 
[18:06:23.841]                           quietly = TRUE)
[18:06:23.841]                         if (has_future) {
[18:06:23.841]                           ns <- base::getNamespace("future")
[18:06:23.841]                           version <- ns[[".package"]][["version"]]
[18:06:23.841]                           if (is.null(version)) 
[18:06:23.841]                             version <- utils::packageVersion("future")
[18:06:23.841]                         }
[18:06:23.841]                         else {
[18:06:23.841]                           version <- NULL
[18:06:23.841]                         }
[18:06:23.841]                         if (!has_future || version < "1.8.0") {
[18:06:23.841]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:23.841]                             "", base::R.version$version.string), 
[18:06:23.841]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:23.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:23.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:23.841]                               "release", "version")], collapse = " "), 
[18:06:23.841]                             hostname = base::Sys.info()[["nodename"]])
[18:06:23.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:23.841]                             info)
[18:06:23.841]                           info <- base::paste(info, collapse = "; ")
[18:06:23.841]                           if (!has_future) {
[18:06:23.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:23.841]                               info)
[18:06:23.841]                           }
[18:06:23.841]                           else {
[18:06:23.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:23.841]                               info, version)
[18:06:23.841]                           }
[18:06:23.841]                           base::stop(msg)
[18:06:23.841]                         }
[18:06:23.841]                       })
[18:06:23.841]                     }
[18:06:23.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:23.841]                     base::options(mc.cores = 1L)
[18:06:23.841]                   }
[18:06:23.841]                   ...future.strategy.old <- future::plan("list")
[18:06:23.841]                   options(future.plan = NULL)
[18:06:23.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:23.841]                 }
[18:06:23.841]                 ...future.workdir <- getwd()
[18:06:23.841]             }
[18:06:23.841]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:23.841]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:23.841]         }
[18:06:23.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:23.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:23.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:23.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:23.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:23.841]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:23.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:23.841]             base::names(...future.oldOptions))
[18:06:23.841]     }
[18:06:23.841]     if (FALSE) {
[18:06:23.841]     }
[18:06:23.841]     else {
[18:06:23.841]         if (TRUE) {
[18:06:23.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:23.841]                 open = "w")
[18:06:23.841]         }
[18:06:23.841]         else {
[18:06:23.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:23.841]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:23.841]         }
[18:06:23.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:23.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:23.841]             base::sink(type = "output", split = FALSE)
[18:06:23.841]             base::close(...future.stdout)
[18:06:23.841]         }, add = TRUE)
[18:06:23.841]     }
[18:06:23.841]     ...future.frame <- base::sys.nframe()
[18:06:23.841]     ...future.conditions <- base::list()
[18:06:23.841]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:23.841]     if (FALSE) {
[18:06:23.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:23.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:23.841]     }
[18:06:23.841]     ...future.result <- base::tryCatch({
[18:06:23.841]         base::withCallingHandlers({
[18:06:23.841]             ...future.value <- base::withVisible(base::local({
[18:06:23.841]                 ...future.makeSendCondition <- base::local({
[18:06:23.841]                   sendCondition <- NULL
[18:06:23.841]                   function(frame = 1L) {
[18:06:23.841]                     if (is.function(sendCondition)) 
[18:06:23.841]                       return(sendCondition)
[18:06:23.841]                     ns <- getNamespace("parallel")
[18:06:23.841]                     if (exists("sendData", mode = "function", 
[18:06:23.841]                       envir = ns)) {
[18:06:23.841]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:23.841]                         envir = ns)
[18:06:23.841]                       envir <- sys.frame(frame)
[18:06:23.841]                       master <- NULL
[18:06:23.841]                       while (!identical(envir, .GlobalEnv) && 
[18:06:23.841]                         !identical(envir, emptyenv())) {
[18:06:23.841]                         if (exists("master", mode = "list", envir = envir, 
[18:06:23.841]                           inherits = FALSE)) {
[18:06:23.841]                           master <- get("master", mode = "list", 
[18:06:23.841]                             envir = envir, inherits = FALSE)
[18:06:23.841]                           if (inherits(master, c("SOCKnode", 
[18:06:23.841]                             "SOCK0node"))) {
[18:06:23.841]                             sendCondition <<- function(cond) {
[18:06:23.841]                               data <- list(type = "VALUE", value = cond, 
[18:06:23.841]                                 success = TRUE)
[18:06:23.841]                               parallel_sendData(master, data)
[18:06:23.841]                             }
[18:06:23.841]                             return(sendCondition)
[18:06:23.841]                           }
[18:06:23.841]                         }
[18:06:23.841]                         frame <- frame + 1L
[18:06:23.841]                         envir <- sys.frame(frame)
[18:06:23.841]                       }
[18:06:23.841]                     }
[18:06:23.841]                     sendCondition <<- function(cond) NULL
[18:06:23.841]                   }
[18:06:23.841]                 })
[18:06:23.841]                 withCallingHandlers({
[18:06:23.841]                   {
[18:06:23.841]                     Sys.sleep(0.5)
[18:06:23.841]                     list(a = 1, b = 42L)
[18:06:23.841]                   }
[18:06:23.841]                 }, immediateCondition = function(cond) {
[18:06:23.841]                   sendCondition <- ...future.makeSendCondition()
[18:06:23.841]                   sendCondition(cond)
[18:06:23.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.841]                   {
[18:06:23.841]                     inherits <- base::inherits
[18:06:23.841]                     invokeRestart <- base::invokeRestart
[18:06:23.841]                     is.null <- base::is.null
[18:06:23.841]                     muffled <- FALSE
[18:06:23.841]                     if (inherits(cond, "message")) {
[18:06:23.841]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:23.841]                       if (muffled) 
[18:06:23.841]                         invokeRestart("muffleMessage")
[18:06:23.841]                     }
[18:06:23.841]                     else if (inherits(cond, "warning")) {
[18:06:23.841]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:23.841]                       if (muffled) 
[18:06:23.841]                         invokeRestart("muffleWarning")
[18:06:23.841]                     }
[18:06:23.841]                     else if (inherits(cond, "condition")) {
[18:06:23.841]                       if (!is.null(pattern)) {
[18:06:23.841]                         computeRestarts <- base::computeRestarts
[18:06:23.841]                         grepl <- base::grepl
[18:06:23.841]                         restarts <- computeRestarts(cond)
[18:06:23.841]                         for (restart in restarts) {
[18:06:23.841]                           name <- restart$name
[18:06:23.841]                           if (is.null(name)) 
[18:06:23.841]                             next
[18:06:23.841]                           if (!grepl(pattern, name)) 
[18:06:23.841]                             next
[18:06:23.841]                           invokeRestart(restart)
[18:06:23.841]                           muffled <- TRUE
[18:06:23.841]                           break
[18:06:23.841]                         }
[18:06:23.841]                       }
[18:06:23.841]                     }
[18:06:23.841]                     invisible(muffled)
[18:06:23.841]                   }
[18:06:23.841]                   muffleCondition(cond)
[18:06:23.841]                 })
[18:06:23.841]             }))
[18:06:23.841]             future::FutureResult(value = ...future.value$value, 
[18:06:23.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.841]                   ...future.rng), globalenv = if (FALSE) 
[18:06:23.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:23.841]                     ...future.globalenv.names))
[18:06:23.841]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:23.841]         }, condition = base::local({
[18:06:23.841]             c <- base::c
[18:06:23.841]             inherits <- base::inherits
[18:06:23.841]             invokeRestart <- base::invokeRestart
[18:06:23.841]             length <- base::length
[18:06:23.841]             list <- base::list
[18:06:23.841]             seq.int <- base::seq.int
[18:06:23.841]             signalCondition <- base::signalCondition
[18:06:23.841]             sys.calls <- base::sys.calls
[18:06:23.841]             `[[` <- base::`[[`
[18:06:23.841]             `+` <- base::`+`
[18:06:23.841]             `<<-` <- base::`<<-`
[18:06:23.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:23.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:23.841]                   3L)]
[18:06:23.841]             }
[18:06:23.841]             function(cond) {
[18:06:23.841]                 is_error <- inherits(cond, "error")
[18:06:23.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:23.841]                   NULL)
[18:06:23.841]                 if (is_error) {
[18:06:23.841]                   sessionInformation <- function() {
[18:06:23.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:23.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:23.841]                       search = base::search(), system = base::Sys.info())
[18:06:23.841]                   }
[18:06:23.841]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:23.841]                     cond$call), session = sessionInformation(), 
[18:06:23.841]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:23.841]                   signalCondition(cond)
[18:06:23.841]                 }
[18:06:23.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:23.841]                 "immediateCondition"))) {
[18:06:23.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:23.841]                   ...future.conditions[[length(...future.conditions) + 
[18:06:23.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:23.841]                   if (TRUE && !signal) {
[18:06:23.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.841]                     {
[18:06:23.841]                       inherits <- base::inherits
[18:06:23.841]                       invokeRestart <- base::invokeRestart
[18:06:23.841]                       is.null <- base::is.null
[18:06:23.841]                       muffled <- FALSE
[18:06:23.841]                       if (inherits(cond, "message")) {
[18:06:23.841]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.841]                         if (muffled) 
[18:06:23.841]                           invokeRestart("muffleMessage")
[18:06:23.841]                       }
[18:06:23.841]                       else if (inherits(cond, "warning")) {
[18:06:23.841]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.841]                         if (muffled) 
[18:06:23.841]                           invokeRestart("muffleWarning")
[18:06:23.841]                       }
[18:06:23.841]                       else if (inherits(cond, "condition")) {
[18:06:23.841]                         if (!is.null(pattern)) {
[18:06:23.841]                           computeRestarts <- base::computeRestarts
[18:06:23.841]                           grepl <- base::grepl
[18:06:23.841]                           restarts <- computeRestarts(cond)
[18:06:23.841]                           for (restart in restarts) {
[18:06:23.841]                             name <- restart$name
[18:06:23.841]                             if (is.null(name)) 
[18:06:23.841]                               next
[18:06:23.841]                             if (!grepl(pattern, name)) 
[18:06:23.841]                               next
[18:06:23.841]                             invokeRestart(restart)
[18:06:23.841]                             muffled <- TRUE
[18:06:23.841]                             break
[18:06:23.841]                           }
[18:06:23.841]                         }
[18:06:23.841]                       }
[18:06:23.841]                       invisible(muffled)
[18:06:23.841]                     }
[18:06:23.841]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.841]                   }
[18:06:23.841]                 }
[18:06:23.841]                 else {
[18:06:23.841]                   if (TRUE) {
[18:06:23.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:23.841]                     {
[18:06:23.841]                       inherits <- base::inherits
[18:06:23.841]                       invokeRestart <- base::invokeRestart
[18:06:23.841]                       is.null <- base::is.null
[18:06:23.841]                       muffled <- FALSE
[18:06:23.841]                       if (inherits(cond, "message")) {
[18:06:23.841]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:23.841]                         if (muffled) 
[18:06:23.841]                           invokeRestart("muffleMessage")
[18:06:23.841]                       }
[18:06:23.841]                       else if (inherits(cond, "warning")) {
[18:06:23.841]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:23.841]                         if (muffled) 
[18:06:23.841]                           invokeRestart("muffleWarning")
[18:06:23.841]                       }
[18:06:23.841]                       else if (inherits(cond, "condition")) {
[18:06:23.841]                         if (!is.null(pattern)) {
[18:06:23.841]                           computeRestarts <- base::computeRestarts
[18:06:23.841]                           grepl <- base::grepl
[18:06:23.841]                           restarts <- computeRestarts(cond)
[18:06:23.841]                           for (restart in restarts) {
[18:06:23.841]                             name <- restart$name
[18:06:23.841]                             if (is.null(name)) 
[18:06:23.841]                               next
[18:06:23.841]                             if (!grepl(pattern, name)) 
[18:06:23.841]                               next
[18:06:23.841]                             invokeRestart(restart)
[18:06:23.841]                             muffled <- TRUE
[18:06:23.841]                             break
[18:06:23.841]                           }
[18:06:23.841]                         }
[18:06:23.841]                       }
[18:06:23.841]                       invisible(muffled)
[18:06:23.841]                     }
[18:06:23.841]                     muffleCondition(cond, pattern = "^muffle")
[18:06:23.841]                   }
[18:06:23.841]                 }
[18:06:23.841]             }
[18:06:23.841]         }))
[18:06:23.841]     }, error = function(ex) {
[18:06:23.841]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:23.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:23.841]                 ...future.rng), started = ...future.startTime, 
[18:06:23.841]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:23.841]             version = "1.8"), class = "FutureResult")
[18:06:23.841]     }, finally = {
[18:06:23.841]         if (!identical(...future.workdir, getwd())) 
[18:06:23.841]             setwd(...future.workdir)
[18:06:23.841]         {
[18:06:23.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:23.841]                 ...future.oldOptions$nwarnings <- NULL
[18:06:23.841]             }
[18:06:23.841]             base::options(...future.oldOptions)
[18:06:23.841]             if (.Platform$OS.type == "windows") {
[18:06:23.841]                 old_names <- names(...future.oldEnvVars)
[18:06:23.841]                 envs <- base::Sys.getenv()
[18:06:23.841]                 names <- names(envs)
[18:06:23.841]                 common <- intersect(names, old_names)
[18:06:23.841]                 added <- setdiff(names, old_names)
[18:06:23.841]                 removed <- setdiff(old_names, names)
[18:06:23.841]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:23.841]                   envs[common]]
[18:06:23.841]                 NAMES <- toupper(changed)
[18:06:23.841]                 args <- list()
[18:06:23.841]                 for (kk in seq_along(NAMES)) {
[18:06:23.841]                   name <- changed[[kk]]
[18:06:23.841]                   NAME <- NAMES[[kk]]
[18:06:23.841]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.841]                     next
[18:06:23.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.841]                 }
[18:06:23.841]                 NAMES <- toupper(added)
[18:06:23.841]                 for (kk in seq_along(NAMES)) {
[18:06:23.841]                   name <- added[[kk]]
[18:06:23.841]                   NAME <- NAMES[[kk]]
[18:06:23.841]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.841]                     next
[18:06:23.841]                   args[[name]] <- ""
[18:06:23.841]                 }
[18:06:23.841]                 NAMES <- toupper(removed)
[18:06:23.841]                 for (kk in seq_along(NAMES)) {
[18:06:23.841]                   name <- removed[[kk]]
[18:06:23.841]                   NAME <- NAMES[[kk]]
[18:06:23.841]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:23.841]                     next
[18:06:23.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:23.841]                 }
[18:06:23.841]                 if (length(args) > 0) 
[18:06:23.841]                   base::do.call(base::Sys.setenv, args = args)
[18:06:23.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:23.841]             }
[18:06:23.841]             else {
[18:06:23.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:23.841]             }
[18:06:23.841]             {
[18:06:23.841]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:23.841]                   0L) {
[18:06:23.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:23.841]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:23.841]                   base::options(opts)
[18:06:23.841]                 }
[18:06:23.841]                 {
[18:06:23.841]                   {
[18:06:23.841]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:23.841]                     NULL
[18:06:23.841]                   }
[18:06:23.841]                   options(future.plan = NULL)
[18:06:23.841]                   if (is.na(NA_character_)) 
[18:06:23.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:23.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:23.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:23.841]                     .init = FALSE)
[18:06:23.841]                 }
[18:06:23.841]             }
[18:06:23.841]         }
[18:06:23.841]     })
[18:06:23.841]     if (TRUE) {
[18:06:23.841]         base::sink(type = "output", split = FALSE)
[18:06:23.841]         if (TRUE) {
[18:06:23.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:23.841]         }
[18:06:23.841]         else {
[18:06:23.841]             ...future.result["stdout"] <- base::list(NULL)
[18:06:23.841]         }
[18:06:23.841]         base::close(...future.stdout)
[18:06:23.841]         ...future.stdout <- NULL
[18:06:23.841]     }
[18:06:23.841]     ...future.result$conditions <- ...future.conditions
[18:06:23.841]     ...future.result$finished <- base::Sys.time()
[18:06:23.841]     ...future.result
[18:06:23.841] }
[18:06:23.848] MultisessionFuture started
[18:06:23.848] - Launch lazy future ... done
[18:06:23.848] run() for ‘MultisessionFuture’ ... done
[18:06:24.392] receiveMessageFromWorker() for ClusterFuture ...
[18:06:24.392] - Validating connection of MultisessionFuture
[18:06:24.393] - received message: FutureResult
[18:06:24.393] - Received FutureResult
[18:06:24.394] - Erased future from FutureRegistry
[18:06:24.394] result() for ClusterFuture ...
[18:06:24.394] - result already collected: FutureResult
[18:06:24.395] result() for ClusterFuture ... done
[18:06:24.395] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:24.395] resolve() on list ...
[18:06:24.396]  recursive: 0
[18:06:24.396]  length: 2
[18:06:24.396]  elements: ‘a’, ‘b’
[18:06:24.397]  length: 1 (resolved future 1)
[18:06:24.397]  length: 0 (resolved future 2)
[18:06:24.397] resolve() on list ... DONE
[18:06:24.398] A MultisessionFuture was resolved (and resolved itself)
[18:06:24.398] getGlobalsAndPackages() ...
[18:06:24.398] Searching for globals...
[18:06:24.402] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:24.402] Searching for globals ... DONE
[18:06:24.403] Resolving globals: FALSE
[18:06:24.404] 
[18:06:24.404] 
[18:06:24.404] getGlobalsAndPackages() ... DONE
[18:06:24.405] run() for ‘Future’ ...
[18:06:24.414] - state: ‘created’
[18:06:24.415] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:24.444] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:24.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:24.445]   - Field: ‘node’
[18:06:24.445]   - Field: ‘label’
[18:06:24.445]   - Field: ‘local’
[18:06:24.446]   - Field: ‘owner’
[18:06:24.446]   - Field: ‘envir’
[18:06:24.446]   - Field: ‘workers’
[18:06:24.446]   - Field: ‘packages’
[18:06:24.447]   - Field: ‘gc’
[18:06:24.447]   - Field: ‘conditions’
[18:06:24.447]   - Field: ‘persistent’
[18:06:24.447]   - Field: ‘expr’
[18:06:24.447]   - Field: ‘uuid’
[18:06:24.448]   - Field: ‘seed’
[18:06:24.448]   - Field: ‘version’
[18:06:24.448]   - Field: ‘result’
[18:06:24.448]   - Field: ‘asynchronous’
[18:06:24.449]   - Field: ‘calls’
[18:06:24.449]   - Field: ‘globals’
[18:06:24.449]   - Field: ‘stdout’
[18:06:24.449]   - Field: ‘earlySignal’
[18:06:24.450]   - Field: ‘lazy’
[18:06:24.450]   - Field: ‘state’
[18:06:24.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:24.450] - Launch lazy future ...
[18:06:24.451] Packages needed by the future expression (n = 0): <none>
[18:06:24.451] Packages needed by future strategies (n = 0): <none>
[18:06:24.452] {
[18:06:24.452]     {
[18:06:24.452]         {
[18:06:24.452]             ...future.startTime <- base::Sys.time()
[18:06:24.452]             {
[18:06:24.452]                 {
[18:06:24.452]                   {
[18:06:24.452]                     {
[18:06:24.452]                       base::local({
[18:06:24.452]                         has_future <- base::requireNamespace("future", 
[18:06:24.452]                           quietly = TRUE)
[18:06:24.452]                         if (has_future) {
[18:06:24.452]                           ns <- base::getNamespace("future")
[18:06:24.452]                           version <- ns[[".package"]][["version"]]
[18:06:24.452]                           if (is.null(version)) 
[18:06:24.452]                             version <- utils::packageVersion("future")
[18:06:24.452]                         }
[18:06:24.452]                         else {
[18:06:24.452]                           version <- NULL
[18:06:24.452]                         }
[18:06:24.452]                         if (!has_future || version < "1.8.0") {
[18:06:24.452]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:24.452]                             "", base::R.version$version.string), 
[18:06:24.452]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:24.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:24.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:24.452]                               "release", "version")], collapse = " "), 
[18:06:24.452]                             hostname = base::Sys.info()[["nodename"]])
[18:06:24.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:24.452]                             info)
[18:06:24.452]                           info <- base::paste(info, collapse = "; ")
[18:06:24.452]                           if (!has_future) {
[18:06:24.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:24.452]                               info)
[18:06:24.452]                           }
[18:06:24.452]                           else {
[18:06:24.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:24.452]                               info, version)
[18:06:24.452]                           }
[18:06:24.452]                           base::stop(msg)
[18:06:24.452]                         }
[18:06:24.452]                       })
[18:06:24.452]                     }
[18:06:24.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:24.452]                     base::options(mc.cores = 1L)
[18:06:24.452]                   }
[18:06:24.452]                   ...future.strategy.old <- future::plan("list")
[18:06:24.452]                   options(future.plan = NULL)
[18:06:24.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:24.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:24.452]                 }
[18:06:24.452]                 ...future.workdir <- getwd()
[18:06:24.452]             }
[18:06:24.452]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:24.452]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:24.452]         }
[18:06:24.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:24.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:24.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:24.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:24.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:24.452]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:24.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:24.452]             base::names(...future.oldOptions))
[18:06:24.452]     }
[18:06:24.452]     if (FALSE) {
[18:06:24.452]     }
[18:06:24.452]     else {
[18:06:24.452]         if (TRUE) {
[18:06:24.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:24.452]                 open = "w")
[18:06:24.452]         }
[18:06:24.452]         else {
[18:06:24.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:24.452]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:24.452]         }
[18:06:24.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:24.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:24.452]             base::sink(type = "output", split = FALSE)
[18:06:24.452]             base::close(...future.stdout)
[18:06:24.452]         }, add = TRUE)
[18:06:24.452]     }
[18:06:24.452]     ...future.frame <- base::sys.nframe()
[18:06:24.452]     ...future.conditions <- base::list()
[18:06:24.452]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:24.452]     if (FALSE) {
[18:06:24.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:24.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:24.452]     }
[18:06:24.452]     ...future.result <- base::tryCatch({
[18:06:24.452]         base::withCallingHandlers({
[18:06:24.452]             ...future.value <- base::withVisible(base::local({
[18:06:24.452]                 ...future.makeSendCondition <- base::local({
[18:06:24.452]                   sendCondition <- NULL
[18:06:24.452]                   function(frame = 1L) {
[18:06:24.452]                     if (is.function(sendCondition)) 
[18:06:24.452]                       return(sendCondition)
[18:06:24.452]                     ns <- getNamespace("parallel")
[18:06:24.452]                     if (exists("sendData", mode = "function", 
[18:06:24.452]                       envir = ns)) {
[18:06:24.452]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:24.452]                         envir = ns)
[18:06:24.452]                       envir <- sys.frame(frame)
[18:06:24.452]                       master <- NULL
[18:06:24.452]                       while (!identical(envir, .GlobalEnv) && 
[18:06:24.452]                         !identical(envir, emptyenv())) {
[18:06:24.452]                         if (exists("master", mode = "list", envir = envir, 
[18:06:24.452]                           inherits = FALSE)) {
[18:06:24.452]                           master <- get("master", mode = "list", 
[18:06:24.452]                             envir = envir, inherits = FALSE)
[18:06:24.452]                           if (inherits(master, c("SOCKnode", 
[18:06:24.452]                             "SOCK0node"))) {
[18:06:24.452]                             sendCondition <<- function(cond) {
[18:06:24.452]                               data <- list(type = "VALUE", value = cond, 
[18:06:24.452]                                 success = TRUE)
[18:06:24.452]                               parallel_sendData(master, data)
[18:06:24.452]                             }
[18:06:24.452]                             return(sendCondition)
[18:06:24.452]                           }
[18:06:24.452]                         }
[18:06:24.452]                         frame <- frame + 1L
[18:06:24.452]                         envir <- sys.frame(frame)
[18:06:24.452]                       }
[18:06:24.452]                     }
[18:06:24.452]                     sendCondition <<- function(cond) NULL
[18:06:24.452]                   }
[18:06:24.452]                 })
[18:06:24.452]                 withCallingHandlers({
[18:06:24.452]                   {
[18:06:24.452]                     Sys.sleep(0.5)
[18:06:24.452]                     list(a = 1, b = 42L)
[18:06:24.452]                   }
[18:06:24.452]                 }, immediateCondition = function(cond) {
[18:06:24.452]                   sendCondition <- ...future.makeSendCondition()
[18:06:24.452]                   sendCondition(cond)
[18:06:24.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:24.452]                   {
[18:06:24.452]                     inherits <- base::inherits
[18:06:24.452]                     invokeRestart <- base::invokeRestart
[18:06:24.452]                     is.null <- base::is.null
[18:06:24.452]                     muffled <- FALSE
[18:06:24.452]                     if (inherits(cond, "message")) {
[18:06:24.452]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:24.452]                       if (muffled) 
[18:06:24.452]                         invokeRestart("muffleMessage")
[18:06:24.452]                     }
[18:06:24.452]                     else if (inherits(cond, "warning")) {
[18:06:24.452]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:24.452]                       if (muffled) 
[18:06:24.452]                         invokeRestart("muffleWarning")
[18:06:24.452]                     }
[18:06:24.452]                     else if (inherits(cond, "condition")) {
[18:06:24.452]                       if (!is.null(pattern)) {
[18:06:24.452]                         computeRestarts <- base::computeRestarts
[18:06:24.452]                         grepl <- base::grepl
[18:06:24.452]                         restarts <- computeRestarts(cond)
[18:06:24.452]                         for (restart in restarts) {
[18:06:24.452]                           name <- restart$name
[18:06:24.452]                           if (is.null(name)) 
[18:06:24.452]                             next
[18:06:24.452]                           if (!grepl(pattern, name)) 
[18:06:24.452]                             next
[18:06:24.452]                           invokeRestart(restart)
[18:06:24.452]                           muffled <- TRUE
[18:06:24.452]                           break
[18:06:24.452]                         }
[18:06:24.452]                       }
[18:06:24.452]                     }
[18:06:24.452]                     invisible(muffled)
[18:06:24.452]                   }
[18:06:24.452]                   muffleCondition(cond)
[18:06:24.452]                 })
[18:06:24.452]             }))
[18:06:24.452]             future::FutureResult(value = ...future.value$value, 
[18:06:24.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:24.452]                   ...future.rng), globalenv = if (FALSE) 
[18:06:24.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:24.452]                     ...future.globalenv.names))
[18:06:24.452]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:24.452]         }, condition = base::local({
[18:06:24.452]             c <- base::c
[18:06:24.452]             inherits <- base::inherits
[18:06:24.452]             invokeRestart <- base::invokeRestart
[18:06:24.452]             length <- base::length
[18:06:24.452]             list <- base::list
[18:06:24.452]             seq.int <- base::seq.int
[18:06:24.452]             signalCondition <- base::signalCondition
[18:06:24.452]             sys.calls <- base::sys.calls
[18:06:24.452]             `[[` <- base::`[[`
[18:06:24.452]             `+` <- base::`+`
[18:06:24.452]             `<<-` <- base::`<<-`
[18:06:24.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:24.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:24.452]                   3L)]
[18:06:24.452]             }
[18:06:24.452]             function(cond) {
[18:06:24.452]                 is_error <- inherits(cond, "error")
[18:06:24.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:24.452]                   NULL)
[18:06:24.452]                 if (is_error) {
[18:06:24.452]                   sessionInformation <- function() {
[18:06:24.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:24.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:24.452]                       search = base::search(), system = base::Sys.info())
[18:06:24.452]                   }
[18:06:24.452]                   ...future.conditions[[length(...future.conditions) + 
[18:06:24.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:24.452]                     cond$call), session = sessionInformation(), 
[18:06:24.452]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:24.452]                   signalCondition(cond)
[18:06:24.452]                 }
[18:06:24.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:24.452]                 "immediateCondition"))) {
[18:06:24.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:24.452]                   ...future.conditions[[length(...future.conditions) + 
[18:06:24.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:24.452]                   if (TRUE && !signal) {
[18:06:24.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:24.452]                     {
[18:06:24.452]                       inherits <- base::inherits
[18:06:24.452]                       invokeRestart <- base::invokeRestart
[18:06:24.452]                       is.null <- base::is.null
[18:06:24.452]                       muffled <- FALSE
[18:06:24.452]                       if (inherits(cond, "message")) {
[18:06:24.452]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:24.452]                         if (muffled) 
[18:06:24.452]                           invokeRestart("muffleMessage")
[18:06:24.452]                       }
[18:06:24.452]                       else if (inherits(cond, "warning")) {
[18:06:24.452]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:24.452]                         if (muffled) 
[18:06:24.452]                           invokeRestart("muffleWarning")
[18:06:24.452]                       }
[18:06:24.452]                       else if (inherits(cond, "condition")) {
[18:06:24.452]                         if (!is.null(pattern)) {
[18:06:24.452]                           computeRestarts <- base::computeRestarts
[18:06:24.452]                           grepl <- base::grepl
[18:06:24.452]                           restarts <- computeRestarts(cond)
[18:06:24.452]                           for (restart in restarts) {
[18:06:24.452]                             name <- restart$name
[18:06:24.452]                             if (is.null(name)) 
[18:06:24.452]                               next
[18:06:24.452]                             if (!grepl(pattern, name)) 
[18:06:24.452]                               next
[18:06:24.452]                             invokeRestart(restart)
[18:06:24.452]                             muffled <- TRUE
[18:06:24.452]                             break
[18:06:24.452]                           }
[18:06:24.452]                         }
[18:06:24.452]                       }
[18:06:24.452]                       invisible(muffled)
[18:06:24.452]                     }
[18:06:24.452]                     muffleCondition(cond, pattern = "^muffle")
[18:06:24.452]                   }
[18:06:24.452]                 }
[18:06:24.452]                 else {
[18:06:24.452]                   if (TRUE) {
[18:06:24.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:24.452]                     {
[18:06:24.452]                       inherits <- base::inherits
[18:06:24.452]                       invokeRestart <- base::invokeRestart
[18:06:24.452]                       is.null <- base::is.null
[18:06:24.452]                       muffled <- FALSE
[18:06:24.452]                       if (inherits(cond, "message")) {
[18:06:24.452]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:24.452]                         if (muffled) 
[18:06:24.452]                           invokeRestart("muffleMessage")
[18:06:24.452]                       }
[18:06:24.452]                       else if (inherits(cond, "warning")) {
[18:06:24.452]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:24.452]                         if (muffled) 
[18:06:24.452]                           invokeRestart("muffleWarning")
[18:06:24.452]                       }
[18:06:24.452]                       else if (inherits(cond, "condition")) {
[18:06:24.452]                         if (!is.null(pattern)) {
[18:06:24.452]                           computeRestarts <- base::computeRestarts
[18:06:24.452]                           grepl <- base::grepl
[18:06:24.452]                           restarts <- computeRestarts(cond)
[18:06:24.452]                           for (restart in restarts) {
[18:06:24.452]                             name <- restart$name
[18:06:24.452]                             if (is.null(name)) 
[18:06:24.452]                               next
[18:06:24.452]                             if (!grepl(pattern, name)) 
[18:06:24.452]                               next
[18:06:24.452]                             invokeRestart(restart)
[18:06:24.452]                             muffled <- TRUE
[18:06:24.452]                             break
[18:06:24.452]                           }
[18:06:24.452]                         }
[18:06:24.452]                       }
[18:06:24.452]                       invisible(muffled)
[18:06:24.452]                     }
[18:06:24.452]                     muffleCondition(cond, pattern = "^muffle")
[18:06:24.452]                   }
[18:06:24.452]                 }
[18:06:24.452]             }
[18:06:24.452]         }))
[18:06:24.452]     }, error = function(ex) {
[18:06:24.452]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:24.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:24.452]                 ...future.rng), started = ...future.startTime, 
[18:06:24.452]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:24.452]             version = "1.8"), class = "FutureResult")
[18:06:24.452]     }, finally = {
[18:06:24.452]         if (!identical(...future.workdir, getwd())) 
[18:06:24.452]             setwd(...future.workdir)
[18:06:24.452]         {
[18:06:24.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:24.452]                 ...future.oldOptions$nwarnings <- NULL
[18:06:24.452]             }
[18:06:24.452]             base::options(...future.oldOptions)
[18:06:24.452]             if (.Platform$OS.type == "windows") {
[18:06:24.452]                 old_names <- names(...future.oldEnvVars)
[18:06:24.452]                 envs <- base::Sys.getenv()
[18:06:24.452]                 names <- names(envs)
[18:06:24.452]                 common <- intersect(names, old_names)
[18:06:24.452]                 added <- setdiff(names, old_names)
[18:06:24.452]                 removed <- setdiff(old_names, names)
[18:06:24.452]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:24.452]                   envs[common]]
[18:06:24.452]                 NAMES <- toupper(changed)
[18:06:24.452]                 args <- list()
[18:06:24.452]                 for (kk in seq_along(NAMES)) {
[18:06:24.452]                   name <- changed[[kk]]
[18:06:24.452]                   NAME <- NAMES[[kk]]
[18:06:24.452]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:24.452]                     next
[18:06:24.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:24.452]                 }
[18:06:24.452]                 NAMES <- toupper(added)
[18:06:24.452]                 for (kk in seq_along(NAMES)) {
[18:06:24.452]                   name <- added[[kk]]
[18:06:24.452]                   NAME <- NAMES[[kk]]
[18:06:24.452]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:24.452]                     next
[18:06:24.452]                   args[[name]] <- ""
[18:06:24.452]                 }
[18:06:24.452]                 NAMES <- toupper(removed)
[18:06:24.452]                 for (kk in seq_along(NAMES)) {
[18:06:24.452]                   name <- removed[[kk]]
[18:06:24.452]                   NAME <- NAMES[[kk]]
[18:06:24.452]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:24.452]                     next
[18:06:24.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:24.452]                 }
[18:06:24.452]                 if (length(args) > 0) 
[18:06:24.452]                   base::do.call(base::Sys.setenv, args = args)
[18:06:24.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:24.452]             }
[18:06:24.452]             else {
[18:06:24.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:24.452]             }
[18:06:24.452]             {
[18:06:24.452]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:24.452]                   0L) {
[18:06:24.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:24.452]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:24.452]                   base::options(opts)
[18:06:24.452]                 }
[18:06:24.452]                 {
[18:06:24.452]                   {
[18:06:24.452]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:24.452]                     NULL
[18:06:24.452]                   }
[18:06:24.452]                   options(future.plan = NULL)
[18:06:24.452]                   if (is.na(NA_character_)) 
[18:06:24.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:24.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:24.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:24.452]                     .init = FALSE)
[18:06:24.452]                 }
[18:06:24.452]             }
[18:06:24.452]         }
[18:06:24.452]     })
[18:06:24.452]     if (TRUE) {
[18:06:24.452]         base::sink(type = "output", split = FALSE)
[18:06:24.452]         if (TRUE) {
[18:06:24.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:24.452]         }
[18:06:24.452]         else {
[18:06:24.452]             ...future.result["stdout"] <- base::list(NULL)
[18:06:24.452]         }
[18:06:24.452]         base::close(...future.stdout)
[18:06:24.452]         ...future.stdout <- NULL
[18:06:24.452]     }
[18:06:24.452]     ...future.result$conditions <- ...future.conditions
[18:06:24.452]     ...future.result$finished <- base::Sys.time()
[18:06:24.452]     ...future.result
[18:06:24.452] }
[18:06:24.459] MultisessionFuture started
[18:06:24.459] - Launch lazy future ... done
[18:06:24.459] run() for ‘MultisessionFuture’ ... done
[18:06:25.002] receiveMessageFromWorker() for ClusterFuture ...
[18:06:25.003] - Validating connection of MultisessionFuture
[18:06:25.004] - received message: FutureResult
[18:06:25.004] - Received FutureResult
[18:06:25.004] - Erased future from FutureRegistry
[18:06:25.005] result() for ClusterFuture ...
[18:06:25.005] - result already collected: FutureResult
[18:06:25.005] result() for ClusterFuture ... done
[18:06:25.006] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:25.006] resolve() on list ...
[18:06:25.006]  recursive: 0
[18:06:25.007]  length: 2
[18:06:25.007]  elements: ‘a’, ‘b’
[18:06:25.007]  length: 1 (resolved future 1)
[18:06:25.008]  length: 0 (resolved future 2)
[18:06:25.008] resolve() on list ... DONE
[18:06:25.008] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[18:06:25.009] getGlobalsAndPackages() ...
[18:06:25.009] Searching for globals...
[18:06:25.011] - globals found: [2] ‘list’, ‘stop’
[18:06:25.011] Searching for globals ... DONE
[18:06:25.012] Resolving globals: FALSE
[18:06:25.013] 
[18:06:25.013] 
[18:06:25.013] getGlobalsAndPackages() ... DONE
[18:06:25.014] run() for ‘Future’ ...
[18:06:25.014] - state: ‘created’
[18:06:25.015] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:25.045] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:25.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:25.046]   - Field: ‘node’
[18:06:25.046]   - Field: ‘label’
[18:06:25.047]   - Field: ‘local’
[18:06:25.047]   - Field: ‘owner’
[18:06:25.047]   - Field: ‘envir’
[18:06:25.047]   - Field: ‘workers’
[18:06:25.048]   - Field: ‘packages’
[18:06:25.048]   - Field: ‘gc’
[18:06:25.048]   - Field: ‘conditions’
[18:06:25.048]   - Field: ‘persistent’
[18:06:25.049]   - Field: ‘expr’
[18:06:25.049]   - Field: ‘uuid’
[18:06:25.049]   - Field: ‘seed’
[18:06:25.050]   - Field: ‘version’
[18:06:25.050]   - Field: ‘result’
[18:06:25.050]   - Field: ‘asynchronous’
[18:06:25.050]   - Field: ‘calls’
[18:06:25.051]   - Field: ‘globals’
[18:06:25.051]   - Field: ‘stdout’
[18:06:25.051]   - Field: ‘earlySignal’
[18:06:25.051]   - Field: ‘lazy’
[18:06:25.052]   - Field: ‘state’
[18:06:25.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:25.052] - Launch lazy future ...
[18:06:25.053] Packages needed by the future expression (n = 0): <none>
[18:06:25.053] Packages needed by future strategies (n = 0): <none>
[18:06:25.054] {
[18:06:25.054]     {
[18:06:25.054]         {
[18:06:25.054]             ...future.startTime <- base::Sys.time()
[18:06:25.054]             {
[18:06:25.054]                 {
[18:06:25.054]                   {
[18:06:25.054]                     {
[18:06:25.054]                       base::local({
[18:06:25.054]                         has_future <- base::requireNamespace("future", 
[18:06:25.054]                           quietly = TRUE)
[18:06:25.054]                         if (has_future) {
[18:06:25.054]                           ns <- base::getNamespace("future")
[18:06:25.054]                           version <- ns[[".package"]][["version"]]
[18:06:25.054]                           if (is.null(version)) 
[18:06:25.054]                             version <- utils::packageVersion("future")
[18:06:25.054]                         }
[18:06:25.054]                         else {
[18:06:25.054]                           version <- NULL
[18:06:25.054]                         }
[18:06:25.054]                         if (!has_future || version < "1.8.0") {
[18:06:25.054]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:25.054]                             "", base::R.version$version.string), 
[18:06:25.054]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:25.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:25.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:25.054]                               "release", "version")], collapse = " "), 
[18:06:25.054]                             hostname = base::Sys.info()[["nodename"]])
[18:06:25.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:25.054]                             info)
[18:06:25.054]                           info <- base::paste(info, collapse = "; ")
[18:06:25.054]                           if (!has_future) {
[18:06:25.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:25.054]                               info)
[18:06:25.054]                           }
[18:06:25.054]                           else {
[18:06:25.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:25.054]                               info, version)
[18:06:25.054]                           }
[18:06:25.054]                           base::stop(msg)
[18:06:25.054]                         }
[18:06:25.054]                       })
[18:06:25.054]                     }
[18:06:25.054]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:25.054]                     base::options(mc.cores = 1L)
[18:06:25.054]                   }
[18:06:25.054]                   ...future.strategy.old <- future::plan("list")
[18:06:25.054]                   options(future.plan = NULL)
[18:06:25.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:25.054]                 }
[18:06:25.054]                 ...future.workdir <- getwd()
[18:06:25.054]             }
[18:06:25.054]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:25.054]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:25.054]         }
[18:06:25.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:25.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:25.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:25.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:25.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:25.054]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:25.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:25.054]             base::names(...future.oldOptions))
[18:06:25.054]     }
[18:06:25.054]     if (FALSE) {
[18:06:25.054]     }
[18:06:25.054]     else {
[18:06:25.054]         if (TRUE) {
[18:06:25.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:25.054]                 open = "w")
[18:06:25.054]         }
[18:06:25.054]         else {
[18:06:25.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:25.054]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:25.054]         }
[18:06:25.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:25.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:25.054]             base::sink(type = "output", split = FALSE)
[18:06:25.054]             base::close(...future.stdout)
[18:06:25.054]         }, add = TRUE)
[18:06:25.054]     }
[18:06:25.054]     ...future.frame <- base::sys.nframe()
[18:06:25.054]     ...future.conditions <- base::list()
[18:06:25.054]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:25.054]     if (FALSE) {
[18:06:25.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:25.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:25.054]     }
[18:06:25.054]     ...future.result <- base::tryCatch({
[18:06:25.054]         base::withCallingHandlers({
[18:06:25.054]             ...future.value <- base::withVisible(base::local({
[18:06:25.054]                 ...future.makeSendCondition <- base::local({
[18:06:25.054]                   sendCondition <- NULL
[18:06:25.054]                   function(frame = 1L) {
[18:06:25.054]                     if (is.function(sendCondition)) 
[18:06:25.054]                       return(sendCondition)
[18:06:25.054]                     ns <- getNamespace("parallel")
[18:06:25.054]                     if (exists("sendData", mode = "function", 
[18:06:25.054]                       envir = ns)) {
[18:06:25.054]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:25.054]                         envir = ns)
[18:06:25.054]                       envir <- sys.frame(frame)
[18:06:25.054]                       master <- NULL
[18:06:25.054]                       while (!identical(envir, .GlobalEnv) && 
[18:06:25.054]                         !identical(envir, emptyenv())) {
[18:06:25.054]                         if (exists("master", mode = "list", envir = envir, 
[18:06:25.054]                           inherits = FALSE)) {
[18:06:25.054]                           master <- get("master", mode = "list", 
[18:06:25.054]                             envir = envir, inherits = FALSE)
[18:06:25.054]                           if (inherits(master, c("SOCKnode", 
[18:06:25.054]                             "SOCK0node"))) {
[18:06:25.054]                             sendCondition <<- function(cond) {
[18:06:25.054]                               data <- list(type = "VALUE", value = cond, 
[18:06:25.054]                                 success = TRUE)
[18:06:25.054]                               parallel_sendData(master, data)
[18:06:25.054]                             }
[18:06:25.054]                             return(sendCondition)
[18:06:25.054]                           }
[18:06:25.054]                         }
[18:06:25.054]                         frame <- frame + 1L
[18:06:25.054]                         envir <- sys.frame(frame)
[18:06:25.054]                       }
[18:06:25.054]                     }
[18:06:25.054]                     sendCondition <<- function(cond) NULL
[18:06:25.054]                   }
[18:06:25.054]                 })
[18:06:25.054]                 withCallingHandlers({
[18:06:25.054]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:25.054]                 }, immediateCondition = function(cond) {
[18:06:25.054]                   sendCondition <- ...future.makeSendCondition()
[18:06:25.054]                   sendCondition(cond)
[18:06:25.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.054]                   {
[18:06:25.054]                     inherits <- base::inherits
[18:06:25.054]                     invokeRestart <- base::invokeRestart
[18:06:25.054]                     is.null <- base::is.null
[18:06:25.054]                     muffled <- FALSE
[18:06:25.054]                     if (inherits(cond, "message")) {
[18:06:25.054]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:25.054]                       if (muffled) 
[18:06:25.054]                         invokeRestart("muffleMessage")
[18:06:25.054]                     }
[18:06:25.054]                     else if (inherits(cond, "warning")) {
[18:06:25.054]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:25.054]                       if (muffled) 
[18:06:25.054]                         invokeRestart("muffleWarning")
[18:06:25.054]                     }
[18:06:25.054]                     else if (inherits(cond, "condition")) {
[18:06:25.054]                       if (!is.null(pattern)) {
[18:06:25.054]                         computeRestarts <- base::computeRestarts
[18:06:25.054]                         grepl <- base::grepl
[18:06:25.054]                         restarts <- computeRestarts(cond)
[18:06:25.054]                         for (restart in restarts) {
[18:06:25.054]                           name <- restart$name
[18:06:25.054]                           if (is.null(name)) 
[18:06:25.054]                             next
[18:06:25.054]                           if (!grepl(pattern, name)) 
[18:06:25.054]                             next
[18:06:25.054]                           invokeRestart(restart)
[18:06:25.054]                           muffled <- TRUE
[18:06:25.054]                           break
[18:06:25.054]                         }
[18:06:25.054]                       }
[18:06:25.054]                     }
[18:06:25.054]                     invisible(muffled)
[18:06:25.054]                   }
[18:06:25.054]                   muffleCondition(cond)
[18:06:25.054]                 })
[18:06:25.054]             }))
[18:06:25.054]             future::FutureResult(value = ...future.value$value, 
[18:06:25.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.054]                   ...future.rng), globalenv = if (FALSE) 
[18:06:25.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:25.054]                     ...future.globalenv.names))
[18:06:25.054]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:25.054]         }, condition = base::local({
[18:06:25.054]             c <- base::c
[18:06:25.054]             inherits <- base::inherits
[18:06:25.054]             invokeRestart <- base::invokeRestart
[18:06:25.054]             length <- base::length
[18:06:25.054]             list <- base::list
[18:06:25.054]             seq.int <- base::seq.int
[18:06:25.054]             signalCondition <- base::signalCondition
[18:06:25.054]             sys.calls <- base::sys.calls
[18:06:25.054]             `[[` <- base::`[[`
[18:06:25.054]             `+` <- base::`+`
[18:06:25.054]             `<<-` <- base::`<<-`
[18:06:25.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:25.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:25.054]                   3L)]
[18:06:25.054]             }
[18:06:25.054]             function(cond) {
[18:06:25.054]                 is_error <- inherits(cond, "error")
[18:06:25.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:25.054]                   NULL)
[18:06:25.054]                 if (is_error) {
[18:06:25.054]                   sessionInformation <- function() {
[18:06:25.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:25.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:25.054]                       search = base::search(), system = base::Sys.info())
[18:06:25.054]                   }
[18:06:25.054]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:25.054]                     cond$call), session = sessionInformation(), 
[18:06:25.054]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:25.054]                   signalCondition(cond)
[18:06:25.054]                 }
[18:06:25.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:25.054]                 "immediateCondition"))) {
[18:06:25.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:25.054]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:25.054]                   if (TRUE && !signal) {
[18:06:25.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.054]                     {
[18:06:25.054]                       inherits <- base::inherits
[18:06:25.054]                       invokeRestart <- base::invokeRestart
[18:06:25.054]                       is.null <- base::is.null
[18:06:25.054]                       muffled <- FALSE
[18:06:25.054]                       if (inherits(cond, "message")) {
[18:06:25.054]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.054]                         if (muffled) 
[18:06:25.054]                           invokeRestart("muffleMessage")
[18:06:25.054]                       }
[18:06:25.054]                       else if (inherits(cond, "warning")) {
[18:06:25.054]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.054]                         if (muffled) 
[18:06:25.054]                           invokeRestart("muffleWarning")
[18:06:25.054]                       }
[18:06:25.054]                       else if (inherits(cond, "condition")) {
[18:06:25.054]                         if (!is.null(pattern)) {
[18:06:25.054]                           computeRestarts <- base::computeRestarts
[18:06:25.054]                           grepl <- base::grepl
[18:06:25.054]                           restarts <- computeRestarts(cond)
[18:06:25.054]                           for (restart in restarts) {
[18:06:25.054]                             name <- restart$name
[18:06:25.054]                             if (is.null(name)) 
[18:06:25.054]                               next
[18:06:25.054]                             if (!grepl(pattern, name)) 
[18:06:25.054]                               next
[18:06:25.054]                             invokeRestart(restart)
[18:06:25.054]                             muffled <- TRUE
[18:06:25.054]                             break
[18:06:25.054]                           }
[18:06:25.054]                         }
[18:06:25.054]                       }
[18:06:25.054]                       invisible(muffled)
[18:06:25.054]                     }
[18:06:25.054]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.054]                   }
[18:06:25.054]                 }
[18:06:25.054]                 else {
[18:06:25.054]                   if (TRUE) {
[18:06:25.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.054]                     {
[18:06:25.054]                       inherits <- base::inherits
[18:06:25.054]                       invokeRestart <- base::invokeRestart
[18:06:25.054]                       is.null <- base::is.null
[18:06:25.054]                       muffled <- FALSE
[18:06:25.054]                       if (inherits(cond, "message")) {
[18:06:25.054]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.054]                         if (muffled) 
[18:06:25.054]                           invokeRestart("muffleMessage")
[18:06:25.054]                       }
[18:06:25.054]                       else if (inherits(cond, "warning")) {
[18:06:25.054]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.054]                         if (muffled) 
[18:06:25.054]                           invokeRestart("muffleWarning")
[18:06:25.054]                       }
[18:06:25.054]                       else if (inherits(cond, "condition")) {
[18:06:25.054]                         if (!is.null(pattern)) {
[18:06:25.054]                           computeRestarts <- base::computeRestarts
[18:06:25.054]                           grepl <- base::grepl
[18:06:25.054]                           restarts <- computeRestarts(cond)
[18:06:25.054]                           for (restart in restarts) {
[18:06:25.054]                             name <- restart$name
[18:06:25.054]                             if (is.null(name)) 
[18:06:25.054]                               next
[18:06:25.054]                             if (!grepl(pattern, name)) 
[18:06:25.054]                               next
[18:06:25.054]                             invokeRestart(restart)
[18:06:25.054]                             muffled <- TRUE
[18:06:25.054]                             break
[18:06:25.054]                           }
[18:06:25.054]                         }
[18:06:25.054]                       }
[18:06:25.054]                       invisible(muffled)
[18:06:25.054]                     }
[18:06:25.054]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.054]                   }
[18:06:25.054]                 }
[18:06:25.054]             }
[18:06:25.054]         }))
[18:06:25.054]     }, error = function(ex) {
[18:06:25.054]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:25.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.054]                 ...future.rng), started = ...future.startTime, 
[18:06:25.054]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:25.054]             version = "1.8"), class = "FutureResult")
[18:06:25.054]     }, finally = {
[18:06:25.054]         if (!identical(...future.workdir, getwd())) 
[18:06:25.054]             setwd(...future.workdir)
[18:06:25.054]         {
[18:06:25.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:25.054]                 ...future.oldOptions$nwarnings <- NULL
[18:06:25.054]             }
[18:06:25.054]             base::options(...future.oldOptions)
[18:06:25.054]             if (.Platform$OS.type == "windows") {
[18:06:25.054]                 old_names <- names(...future.oldEnvVars)
[18:06:25.054]                 envs <- base::Sys.getenv()
[18:06:25.054]                 names <- names(envs)
[18:06:25.054]                 common <- intersect(names, old_names)
[18:06:25.054]                 added <- setdiff(names, old_names)
[18:06:25.054]                 removed <- setdiff(old_names, names)
[18:06:25.054]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:25.054]                   envs[common]]
[18:06:25.054]                 NAMES <- toupper(changed)
[18:06:25.054]                 args <- list()
[18:06:25.054]                 for (kk in seq_along(NAMES)) {
[18:06:25.054]                   name <- changed[[kk]]
[18:06:25.054]                   NAME <- NAMES[[kk]]
[18:06:25.054]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.054]                     next
[18:06:25.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.054]                 }
[18:06:25.054]                 NAMES <- toupper(added)
[18:06:25.054]                 for (kk in seq_along(NAMES)) {
[18:06:25.054]                   name <- added[[kk]]
[18:06:25.054]                   NAME <- NAMES[[kk]]
[18:06:25.054]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.054]                     next
[18:06:25.054]                   args[[name]] <- ""
[18:06:25.054]                 }
[18:06:25.054]                 NAMES <- toupper(removed)
[18:06:25.054]                 for (kk in seq_along(NAMES)) {
[18:06:25.054]                   name <- removed[[kk]]
[18:06:25.054]                   NAME <- NAMES[[kk]]
[18:06:25.054]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.054]                     next
[18:06:25.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.054]                 }
[18:06:25.054]                 if (length(args) > 0) 
[18:06:25.054]                   base::do.call(base::Sys.setenv, args = args)
[18:06:25.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:25.054]             }
[18:06:25.054]             else {
[18:06:25.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:25.054]             }
[18:06:25.054]             {
[18:06:25.054]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:25.054]                   0L) {
[18:06:25.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:25.054]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:25.054]                   base::options(opts)
[18:06:25.054]                 }
[18:06:25.054]                 {
[18:06:25.054]                   {
[18:06:25.054]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:25.054]                     NULL
[18:06:25.054]                   }
[18:06:25.054]                   options(future.plan = NULL)
[18:06:25.054]                   if (is.na(NA_character_)) 
[18:06:25.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:25.054]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:25.054]                     .init = FALSE)
[18:06:25.054]                 }
[18:06:25.054]             }
[18:06:25.054]         }
[18:06:25.054]     })
[18:06:25.054]     if (TRUE) {
[18:06:25.054]         base::sink(type = "output", split = FALSE)
[18:06:25.054]         if (TRUE) {
[18:06:25.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:25.054]         }
[18:06:25.054]         else {
[18:06:25.054]             ...future.result["stdout"] <- base::list(NULL)
[18:06:25.054]         }
[18:06:25.054]         base::close(...future.stdout)
[18:06:25.054]         ...future.stdout <- NULL
[18:06:25.054]     }
[18:06:25.054]     ...future.result$conditions <- ...future.conditions
[18:06:25.054]     ...future.result$finished <- base::Sys.time()
[18:06:25.054]     ...future.result
[18:06:25.054] }
[18:06:25.062] MultisessionFuture started
[18:06:25.062] - Launch lazy future ... done
[18:06:25.062] run() for ‘MultisessionFuture’ ... done
[18:06:25.106] receiveMessageFromWorker() for ClusterFuture ...
[18:06:25.107] - Validating connection of MultisessionFuture
[18:06:25.108] - received message: FutureResult
[18:06:25.108] - Received FutureResult
[18:06:25.109] - Erased future from FutureRegistry
[18:06:25.109] result() for ClusterFuture ...
[18:06:25.109] - result already collected: FutureResult
[18:06:25.110] result() for ClusterFuture ... done
[18:06:25.110] signalConditions() ...
[18:06:25.110]  - include = ‘immediateCondition’
[18:06:25.111]  - exclude = 
[18:06:25.111]  - resignal = FALSE
[18:06:25.111]  - Number of conditions: 1
[18:06:25.111] signalConditions() ... done
[18:06:25.112] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:25.112] A MultisessionFuture was resolved (and resolved itself)
[18:06:25.112] getGlobalsAndPackages() ...
[18:06:25.113] Searching for globals...
[18:06:25.115] - globals found: [2] ‘list’, ‘stop’
[18:06:25.115] Searching for globals ... DONE
[18:06:25.116] Resolving globals: FALSE
[18:06:25.116] 
[18:06:25.117] 
[18:06:25.117] getGlobalsAndPackages() ... DONE
[18:06:25.118] run() for ‘Future’ ...
[18:06:25.118] - state: ‘created’
[18:06:25.119] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:25.148] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:25.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:25.149]   - Field: ‘node’
[18:06:25.149]   - Field: ‘label’
[18:06:25.149]   - Field: ‘local’
[18:06:25.150]   - Field: ‘owner’
[18:06:25.150]   - Field: ‘envir’
[18:06:25.150]   - Field: ‘workers’
[18:06:25.150]   - Field: ‘packages’
[18:06:25.151]   - Field: ‘gc’
[18:06:25.151]   - Field: ‘conditions’
[18:06:25.151]   - Field: ‘persistent’
[18:06:25.151]   - Field: ‘expr’
[18:06:25.152]   - Field: ‘uuid’
[18:06:25.152]   - Field: ‘seed’
[18:06:25.152]   - Field: ‘version’
[18:06:25.152]   - Field: ‘result’
[18:06:25.153]   - Field: ‘asynchronous’
[18:06:25.153]   - Field: ‘calls’
[18:06:25.153]   - Field: ‘globals’
[18:06:25.153]   - Field: ‘stdout’
[18:06:25.154]   - Field: ‘earlySignal’
[18:06:25.154]   - Field: ‘lazy’
[18:06:25.154]   - Field: ‘state’
[18:06:25.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:25.155] - Launch lazy future ...
[18:06:25.155] Packages needed by the future expression (n = 0): <none>
[18:06:25.155] Packages needed by future strategies (n = 0): <none>
[18:06:25.156] {
[18:06:25.156]     {
[18:06:25.156]         {
[18:06:25.156]             ...future.startTime <- base::Sys.time()
[18:06:25.156]             {
[18:06:25.156]                 {
[18:06:25.156]                   {
[18:06:25.156]                     {
[18:06:25.156]                       base::local({
[18:06:25.156]                         has_future <- base::requireNamespace("future", 
[18:06:25.156]                           quietly = TRUE)
[18:06:25.156]                         if (has_future) {
[18:06:25.156]                           ns <- base::getNamespace("future")
[18:06:25.156]                           version <- ns[[".package"]][["version"]]
[18:06:25.156]                           if (is.null(version)) 
[18:06:25.156]                             version <- utils::packageVersion("future")
[18:06:25.156]                         }
[18:06:25.156]                         else {
[18:06:25.156]                           version <- NULL
[18:06:25.156]                         }
[18:06:25.156]                         if (!has_future || version < "1.8.0") {
[18:06:25.156]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:25.156]                             "", base::R.version$version.string), 
[18:06:25.156]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:25.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:25.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:25.156]                               "release", "version")], collapse = " "), 
[18:06:25.156]                             hostname = base::Sys.info()[["nodename"]])
[18:06:25.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:25.156]                             info)
[18:06:25.156]                           info <- base::paste(info, collapse = "; ")
[18:06:25.156]                           if (!has_future) {
[18:06:25.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:25.156]                               info)
[18:06:25.156]                           }
[18:06:25.156]                           else {
[18:06:25.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:25.156]                               info, version)
[18:06:25.156]                           }
[18:06:25.156]                           base::stop(msg)
[18:06:25.156]                         }
[18:06:25.156]                       })
[18:06:25.156]                     }
[18:06:25.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:25.156]                     base::options(mc.cores = 1L)
[18:06:25.156]                   }
[18:06:25.156]                   ...future.strategy.old <- future::plan("list")
[18:06:25.156]                   options(future.plan = NULL)
[18:06:25.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:25.156]                 }
[18:06:25.156]                 ...future.workdir <- getwd()
[18:06:25.156]             }
[18:06:25.156]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:25.156]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:25.156]         }
[18:06:25.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:25.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:25.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:25.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:25.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:25.156]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:25.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:25.156]             base::names(...future.oldOptions))
[18:06:25.156]     }
[18:06:25.156]     if (FALSE) {
[18:06:25.156]     }
[18:06:25.156]     else {
[18:06:25.156]         if (TRUE) {
[18:06:25.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:25.156]                 open = "w")
[18:06:25.156]         }
[18:06:25.156]         else {
[18:06:25.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:25.156]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:25.156]         }
[18:06:25.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:25.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:25.156]             base::sink(type = "output", split = FALSE)
[18:06:25.156]             base::close(...future.stdout)
[18:06:25.156]         }, add = TRUE)
[18:06:25.156]     }
[18:06:25.156]     ...future.frame <- base::sys.nframe()
[18:06:25.156]     ...future.conditions <- base::list()
[18:06:25.156]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:25.156]     if (FALSE) {
[18:06:25.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:25.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:25.156]     }
[18:06:25.156]     ...future.result <- base::tryCatch({
[18:06:25.156]         base::withCallingHandlers({
[18:06:25.156]             ...future.value <- base::withVisible(base::local({
[18:06:25.156]                 ...future.makeSendCondition <- base::local({
[18:06:25.156]                   sendCondition <- NULL
[18:06:25.156]                   function(frame = 1L) {
[18:06:25.156]                     if (is.function(sendCondition)) 
[18:06:25.156]                       return(sendCondition)
[18:06:25.156]                     ns <- getNamespace("parallel")
[18:06:25.156]                     if (exists("sendData", mode = "function", 
[18:06:25.156]                       envir = ns)) {
[18:06:25.156]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:25.156]                         envir = ns)
[18:06:25.156]                       envir <- sys.frame(frame)
[18:06:25.156]                       master <- NULL
[18:06:25.156]                       while (!identical(envir, .GlobalEnv) && 
[18:06:25.156]                         !identical(envir, emptyenv())) {
[18:06:25.156]                         if (exists("master", mode = "list", envir = envir, 
[18:06:25.156]                           inherits = FALSE)) {
[18:06:25.156]                           master <- get("master", mode = "list", 
[18:06:25.156]                             envir = envir, inherits = FALSE)
[18:06:25.156]                           if (inherits(master, c("SOCKnode", 
[18:06:25.156]                             "SOCK0node"))) {
[18:06:25.156]                             sendCondition <<- function(cond) {
[18:06:25.156]                               data <- list(type = "VALUE", value = cond, 
[18:06:25.156]                                 success = TRUE)
[18:06:25.156]                               parallel_sendData(master, data)
[18:06:25.156]                             }
[18:06:25.156]                             return(sendCondition)
[18:06:25.156]                           }
[18:06:25.156]                         }
[18:06:25.156]                         frame <- frame + 1L
[18:06:25.156]                         envir <- sys.frame(frame)
[18:06:25.156]                       }
[18:06:25.156]                     }
[18:06:25.156]                     sendCondition <<- function(cond) NULL
[18:06:25.156]                   }
[18:06:25.156]                 })
[18:06:25.156]                 withCallingHandlers({
[18:06:25.156]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:25.156]                 }, immediateCondition = function(cond) {
[18:06:25.156]                   sendCondition <- ...future.makeSendCondition()
[18:06:25.156]                   sendCondition(cond)
[18:06:25.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.156]                   {
[18:06:25.156]                     inherits <- base::inherits
[18:06:25.156]                     invokeRestart <- base::invokeRestart
[18:06:25.156]                     is.null <- base::is.null
[18:06:25.156]                     muffled <- FALSE
[18:06:25.156]                     if (inherits(cond, "message")) {
[18:06:25.156]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:25.156]                       if (muffled) 
[18:06:25.156]                         invokeRestart("muffleMessage")
[18:06:25.156]                     }
[18:06:25.156]                     else if (inherits(cond, "warning")) {
[18:06:25.156]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:25.156]                       if (muffled) 
[18:06:25.156]                         invokeRestart("muffleWarning")
[18:06:25.156]                     }
[18:06:25.156]                     else if (inherits(cond, "condition")) {
[18:06:25.156]                       if (!is.null(pattern)) {
[18:06:25.156]                         computeRestarts <- base::computeRestarts
[18:06:25.156]                         grepl <- base::grepl
[18:06:25.156]                         restarts <- computeRestarts(cond)
[18:06:25.156]                         for (restart in restarts) {
[18:06:25.156]                           name <- restart$name
[18:06:25.156]                           if (is.null(name)) 
[18:06:25.156]                             next
[18:06:25.156]                           if (!grepl(pattern, name)) 
[18:06:25.156]                             next
[18:06:25.156]                           invokeRestart(restart)
[18:06:25.156]                           muffled <- TRUE
[18:06:25.156]                           break
[18:06:25.156]                         }
[18:06:25.156]                       }
[18:06:25.156]                     }
[18:06:25.156]                     invisible(muffled)
[18:06:25.156]                   }
[18:06:25.156]                   muffleCondition(cond)
[18:06:25.156]                 })
[18:06:25.156]             }))
[18:06:25.156]             future::FutureResult(value = ...future.value$value, 
[18:06:25.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.156]                   ...future.rng), globalenv = if (FALSE) 
[18:06:25.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:25.156]                     ...future.globalenv.names))
[18:06:25.156]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:25.156]         }, condition = base::local({
[18:06:25.156]             c <- base::c
[18:06:25.156]             inherits <- base::inherits
[18:06:25.156]             invokeRestart <- base::invokeRestart
[18:06:25.156]             length <- base::length
[18:06:25.156]             list <- base::list
[18:06:25.156]             seq.int <- base::seq.int
[18:06:25.156]             signalCondition <- base::signalCondition
[18:06:25.156]             sys.calls <- base::sys.calls
[18:06:25.156]             `[[` <- base::`[[`
[18:06:25.156]             `+` <- base::`+`
[18:06:25.156]             `<<-` <- base::`<<-`
[18:06:25.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:25.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:25.156]                   3L)]
[18:06:25.156]             }
[18:06:25.156]             function(cond) {
[18:06:25.156]                 is_error <- inherits(cond, "error")
[18:06:25.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:25.156]                   NULL)
[18:06:25.156]                 if (is_error) {
[18:06:25.156]                   sessionInformation <- function() {
[18:06:25.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:25.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:25.156]                       search = base::search(), system = base::Sys.info())
[18:06:25.156]                   }
[18:06:25.156]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:25.156]                     cond$call), session = sessionInformation(), 
[18:06:25.156]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:25.156]                   signalCondition(cond)
[18:06:25.156]                 }
[18:06:25.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:25.156]                 "immediateCondition"))) {
[18:06:25.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:25.156]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:25.156]                   if (TRUE && !signal) {
[18:06:25.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.156]                     {
[18:06:25.156]                       inherits <- base::inherits
[18:06:25.156]                       invokeRestart <- base::invokeRestart
[18:06:25.156]                       is.null <- base::is.null
[18:06:25.156]                       muffled <- FALSE
[18:06:25.156]                       if (inherits(cond, "message")) {
[18:06:25.156]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.156]                         if (muffled) 
[18:06:25.156]                           invokeRestart("muffleMessage")
[18:06:25.156]                       }
[18:06:25.156]                       else if (inherits(cond, "warning")) {
[18:06:25.156]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.156]                         if (muffled) 
[18:06:25.156]                           invokeRestart("muffleWarning")
[18:06:25.156]                       }
[18:06:25.156]                       else if (inherits(cond, "condition")) {
[18:06:25.156]                         if (!is.null(pattern)) {
[18:06:25.156]                           computeRestarts <- base::computeRestarts
[18:06:25.156]                           grepl <- base::grepl
[18:06:25.156]                           restarts <- computeRestarts(cond)
[18:06:25.156]                           for (restart in restarts) {
[18:06:25.156]                             name <- restart$name
[18:06:25.156]                             if (is.null(name)) 
[18:06:25.156]                               next
[18:06:25.156]                             if (!grepl(pattern, name)) 
[18:06:25.156]                               next
[18:06:25.156]                             invokeRestart(restart)
[18:06:25.156]                             muffled <- TRUE
[18:06:25.156]                             break
[18:06:25.156]                           }
[18:06:25.156]                         }
[18:06:25.156]                       }
[18:06:25.156]                       invisible(muffled)
[18:06:25.156]                     }
[18:06:25.156]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.156]                   }
[18:06:25.156]                 }
[18:06:25.156]                 else {
[18:06:25.156]                   if (TRUE) {
[18:06:25.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.156]                     {
[18:06:25.156]                       inherits <- base::inherits
[18:06:25.156]                       invokeRestart <- base::invokeRestart
[18:06:25.156]                       is.null <- base::is.null
[18:06:25.156]                       muffled <- FALSE
[18:06:25.156]                       if (inherits(cond, "message")) {
[18:06:25.156]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.156]                         if (muffled) 
[18:06:25.156]                           invokeRestart("muffleMessage")
[18:06:25.156]                       }
[18:06:25.156]                       else if (inherits(cond, "warning")) {
[18:06:25.156]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.156]                         if (muffled) 
[18:06:25.156]                           invokeRestart("muffleWarning")
[18:06:25.156]                       }
[18:06:25.156]                       else if (inherits(cond, "condition")) {
[18:06:25.156]                         if (!is.null(pattern)) {
[18:06:25.156]                           computeRestarts <- base::computeRestarts
[18:06:25.156]                           grepl <- base::grepl
[18:06:25.156]                           restarts <- computeRestarts(cond)
[18:06:25.156]                           for (restart in restarts) {
[18:06:25.156]                             name <- restart$name
[18:06:25.156]                             if (is.null(name)) 
[18:06:25.156]                               next
[18:06:25.156]                             if (!grepl(pattern, name)) 
[18:06:25.156]                               next
[18:06:25.156]                             invokeRestart(restart)
[18:06:25.156]                             muffled <- TRUE
[18:06:25.156]                             break
[18:06:25.156]                           }
[18:06:25.156]                         }
[18:06:25.156]                       }
[18:06:25.156]                       invisible(muffled)
[18:06:25.156]                     }
[18:06:25.156]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.156]                   }
[18:06:25.156]                 }
[18:06:25.156]             }
[18:06:25.156]         }))
[18:06:25.156]     }, error = function(ex) {
[18:06:25.156]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:25.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.156]                 ...future.rng), started = ...future.startTime, 
[18:06:25.156]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:25.156]             version = "1.8"), class = "FutureResult")
[18:06:25.156]     }, finally = {
[18:06:25.156]         if (!identical(...future.workdir, getwd())) 
[18:06:25.156]             setwd(...future.workdir)
[18:06:25.156]         {
[18:06:25.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:25.156]                 ...future.oldOptions$nwarnings <- NULL
[18:06:25.156]             }
[18:06:25.156]             base::options(...future.oldOptions)
[18:06:25.156]             if (.Platform$OS.type == "windows") {
[18:06:25.156]                 old_names <- names(...future.oldEnvVars)
[18:06:25.156]                 envs <- base::Sys.getenv()
[18:06:25.156]                 names <- names(envs)
[18:06:25.156]                 common <- intersect(names, old_names)
[18:06:25.156]                 added <- setdiff(names, old_names)
[18:06:25.156]                 removed <- setdiff(old_names, names)
[18:06:25.156]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:25.156]                   envs[common]]
[18:06:25.156]                 NAMES <- toupper(changed)
[18:06:25.156]                 args <- list()
[18:06:25.156]                 for (kk in seq_along(NAMES)) {
[18:06:25.156]                   name <- changed[[kk]]
[18:06:25.156]                   NAME <- NAMES[[kk]]
[18:06:25.156]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.156]                     next
[18:06:25.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.156]                 }
[18:06:25.156]                 NAMES <- toupper(added)
[18:06:25.156]                 for (kk in seq_along(NAMES)) {
[18:06:25.156]                   name <- added[[kk]]
[18:06:25.156]                   NAME <- NAMES[[kk]]
[18:06:25.156]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.156]                     next
[18:06:25.156]                   args[[name]] <- ""
[18:06:25.156]                 }
[18:06:25.156]                 NAMES <- toupper(removed)
[18:06:25.156]                 for (kk in seq_along(NAMES)) {
[18:06:25.156]                   name <- removed[[kk]]
[18:06:25.156]                   NAME <- NAMES[[kk]]
[18:06:25.156]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.156]                     next
[18:06:25.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.156]                 }
[18:06:25.156]                 if (length(args) > 0) 
[18:06:25.156]                   base::do.call(base::Sys.setenv, args = args)
[18:06:25.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:25.156]             }
[18:06:25.156]             else {
[18:06:25.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:25.156]             }
[18:06:25.156]             {
[18:06:25.156]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:25.156]                   0L) {
[18:06:25.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:25.156]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:25.156]                   base::options(opts)
[18:06:25.156]                 }
[18:06:25.156]                 {
[18:06:25.156]                   {
[18:06:25.156]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:25.156]                     NULL
[18:06:25.156]                   }
[18:06:25.156]                   options(future.plan = NULL)
[18:06:25.156]                   if (is.na(NA_character_)) 
[18:06:25.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:25.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:25.156]                     .init = FALSE)
[18:06:25.156]                 }
[18:06:25.156]             }
[18:06:25.156]         }
[18:06:25.156]     })
[18:06:25.156]     if (TRUE) {
[18:06:25.156]         base::sink(type = "output", split = FALSE)
[18:06:25.156]         if (TRUE) {
[18:06:25.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:25.156]         }
[18:06:25.156]         else {
[18:06:25.156]             ...future.result["stdout"] <- base::list(NULL)
[18:06:25.156]         }
[18:06:25.156]         base::close(...future.stdout)
[18:06:25.156]         ...future.stdout <- NULL
[18:06:25.156]     }
[18:06:25.156]     ...future.result$conditions <- ...future.conditions
[18:06:25.156]     ...future.result$finished <- base::Sys.time()
[18:06:25.156]     ...future.result
[18:06:25.156] }
[18:06:25.163] MultisessionFuture started
[18:06:25.163] - Launch lazy future ... done
[18:06:25.164] run() for ‘MultisessionFuture’ ... done
[18:06:25.209] receiveMessageFromWorker() for ClusterFuture ...
[18:06:25.210] - Validating connection of MultisessionFuture
[18:06:25.212] - received message: FutureResult
[18:06:25.212] - Received FutureResult
[18:06:25.213] - Erased future from FutureRegistry
[18:06:25.213] result() for ClusterFuture ...
[18:06:25.213] - result already collected: FutureResult
[18:06:25.214] result() for ClusterFuture ... done
[18:06:25.214] signalConditions() ...
[18:06:25.214]  - include = ‘immediateCondition’
[18:06:25.215]  - exclude = 
[18:06:25.215]  - resignal = FALSE
[18:06:25.215]  - Number of conditions: 1
[18:06:25.215] signalConditions() ... done
[18:06:25.216] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:25.216] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[18:06:25.217] getGlobalsAndPackages() ...
[18:06:25.217] Searching for globals...
[18:06:25.220] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:25.221] Searching for globals ... DONE
[18:06:25.221] Resolving globals: FALSE
[18:06:25.222] 
[18:06:25.222] 
[18:06:25.223] getGlobalsAndPackages() ... DONE
[18:06:25.223] run() for ‘Future’ ...
[18:06:25.224] - state: ‘created’
[18:06:25.224] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:25.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:25.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:25.250]   - Field: ‘node’
[18:06:25.250]   - Field: ‘label’
[18:06:25.250]   - Field: ‘local’
[18:06:25.250]   - Field: ‘owner’
[18:06:25.251]   - Field: ‘envir’
[18:06:25.251]   - Field: ‘workers’
[18:06:25.251]   - Field: ‘packages’
[18:06:25.251]   - Field: ‘gc’
[18:06:25.251]   - Field: ‘conditions’
[18:06:25.252]   - Field: ‘persistent’
[18:06:25.252]   - Field: ‘expr’
[18:06:25.252]   - Field: ‘uuid’
[18:06:25.252]   - Field: ‘seed’
[18:06:25.252]   - Field: ‘version’
[18:06:25.253]   - Field: ‘result’
[18:06:25.253]   - Field: ‘asynchronous’
[18:06:25.253]   - Field: ‘calls’
[18:06:25.253]   - Field: ‘globals’
[18:06:25.253]   - Field: ‘stdout’
[18:06:25.254]   - Field: ‘earlySignal’
[18:06:25.254]   - Field: ‘lazy’
[18:06:25.254]   - Field: ‘state’
[18:06:25.254] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:25.254] - Launch lazy future ...
[18:06:25.255] Packages needed by the future expression (n = 0): <none>
[18:06:25.255] Packages needed by future strategies (n = 0): <none>
[18:06:25.256] {
[18:06:25.256]     {
[18:06:25.256]         {
[18:06:25.256]             ...future.startTime <- base::Sys.time()
[18:06:25.256]             {
[18:06:25.256]                 {
[18:06:25.256]                   {
[18:06:25.256]                     {
[18:06:25.256]                       base::local({
[18:06:25.256]                         has_future <- base::requireNamespace("future", 
[18:06:25.256]                           quietly = TRUE)
[18:06:25.256]                         if (has_future) {
[18:06:25.256]                           ns <- base::getNamespace("future")
[18:06:25.256]                           version <- ns[[".package"]][["version"]]
[18:06:25.256]                           if (is.null(version)) 
[18:06:25.256]                             version <- utils::packageVersion("future")
[18:06:25.256]                         }
[18:06:25.256]                         else {
[18:06:25.256]                           version <- NULL
[18:06:25.256]                         }
[18:06:25.256]                         if (!has_future || version < "1.8.0") {
[18:06:25.256]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:25.256]                             "", base::R.version$version.string), 
[18:06:25.256]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:25.256]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:25.256]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:25.256]                               "release", "version")], collapse = " "), 
[18:06:25.256]                             hostname = base::Sys.info()[["nodename"]])
[18:06:25.256]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:25.256]                             info)
[18:06:25.256]                           info <- base::paste(info, collapse = "; ")
[18:06:25.256]                           if (!has_future) {
[18:06:25.256]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:25.256]                               info)
[18:06:25.256]                           }
[18:06:25.256]                           else {
[18:06:25.256]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:25.256]                               info, version)
[18:06:25.256]                           }
[18:06:25.256]                           base::stop(msg)
[18:06:25.256]                         }
[18:06:25.256]                       })
[18:06:25.256]                     }
[18:06:25.256]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:25.256]                     base::options(mc.cores = 1L)
[18:06:25.256]                   }
[18:06:25.256]                   ...future.strategy.old <- future::plan("list")
[18:06:25.256]                   options(future.plan = NULL)
[18:06:25.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:25.256]                 }
[18:06:25.256]                 ...future.workdir <- getwd()
[18:06:25.256]             }
[18:06:25.256]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:25.256]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:25.256]         }
[18:06:25.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:25.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:25.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:25.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:25.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:25.256]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:25.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:25.256]             base::names(...future.oldOptions))
[18:06:25.256]     }
[18:06:25.256]     if (FALSE) {
[18:06:25.256]     }
[18:06:25.256]     else {
[18:06:25.256]         if (TRUE) {
[18:06:25.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:25.256]                 open = "w")
[18:06:25.256]         }
[18:06:25.256]         else {
[18:06:25.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:25.256]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:25.256]         }
[18:06:25.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:25.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:25.256]             base::sink(type = "output", split = FALSE)
[18:06:25.256]             base::close(...future.stdout)
[18:06:25.256]         }, add = TRUE)
[18:06:25.256]     }
[18:06:25.256]     ...future.frame <- base::sys.nframe()
[18:06:25.256]     ...future.conditions <- base::list()
[18:06:25.256]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:25.256]     if (FALSE) {
[18:06:25.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:25.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:25.256]     }
[18:06:25.256]     ...future.result <- base::tryCatch({
[18:06:25.256]         base::withCallingHandlers({
[18:06:25.256]             ...future.value <- base::withVisible(base::local({
[18:06:25.256]                 ...future.makeSendCondition <- base::local({
[18:06:25.256]                   sendCondition <- NULL
[18:06:25.256]                   function(frame = 1L) {
[18:06:25.256]                     if (is.function(sendCondition)) 
[18:06:25.256]                       return(sendCondition)
[18:06:25.256]                     ns <- getNamespace("parallel")
[18:06:25.256]                     if (exists("sendData", mode = "function", 
[18:06:25.256]                       envir = ns)) {
[18:06:25.256]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:25.256]                         envir = ns)
[18:06:25.256]                       envir <- sys.frame(frame)
[18:06:25.256]                       master <- NULL
[18:06:25.256]                       while (!identical(envir, .GlobalEnv) && 
[18:06:25.256]                         !identical(envir, emptyenv())) {
[18:06:25.256]                         if (exists("master", mode = "list", envir = envir, 
[18:06:25.256]                           inherits = FALSE)) {
[18:06:25.256]                           master <- get("master", mode = "list", 
[18:06:25.256]                             envir = envir, inherits = FALSE)
[18:06:25.256]                           if (inherits(master, c("SOCKnode", 
[18:06:25.256]                             "SOCK0node"))) {
[18:06:25.256]                             sendCondition <<- function(cond) {
[18:06:25.256]                               data <- list(type = "VALUE", value = cond, 
[18:06:25.256]                                 success = TRUE)
[18:06:25.256]                               parallel_sendData(master, data)
[18:06:25.256]                             }
[18:06:25.256]                             return(sendCondition)
[18:06:25.256]                           }
[18:06:25.256]                         }
[18:06:25.256]                         frame <- frame + 1L
[18:06:25.256]                         envir <- sys.frame(frame)
[18:06:25.256]                       }
[18:06:25.256]                     }
[18:06:25.256]                     sendCondition <<- function(cond) NULL
[18:06:25.256]                   }
[18:06:25.256]                 })
[18:06:25.256]                 withCallingHandlers({
[18:06:25.256]                   {
[18:06:25.256]                     Sys.sleep(0.5)
[18:06:25.256]                     list(a = 1, b = 42L)
[18:06:25.256]                   }
[18:06:25.256]                 }, immediateCondition = function(cond) {
[18:06:25.256]                   sendCondition <- ...future.makeSendCondition()
[18:06:25.256]                   sendCondition(cond)
[18:06:25.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.256]                   {
[18:06:25.256]                     inherits <- base::inherits
[18:06:25.256]                     invokeRestart <- base::invokeRestart
[18:06:25.256]                     is.null <- base::is.null
[18:06:25.256]                     muffled <- FALSE
[18:06:25.256]                     if (inherits(cond, "message")) {
[18:06:25.256]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:25.256]                       if (muffled) 
[18:06:25.256]                         invokeRestart("muffleMessage")
[18:06:25.256]                     }
[18:06:25.256]                     else if (inherits(cond, "warning")) {
[18:06:25.256]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:25.256]                       if (muffled) 
[18:06:25.256]                         invokeRestart("muffleWarning")
[18:06:25.256]                     }
[18:06:25.256]                     else if (inherits(cond, "condition")) {
[18:06:25.256]                       if (!is.null(pattern)) {
[18:06:25.256]                         computeRestarts <- base::computeRestarts
[18:06:25.256]                         grepl <- base::grepl
[18:06:25.256]                         restarts <- computeRestarts(cond)
[18:06:25.256]                         for (restart in restarts) {
[18:06:25.256]                           name <- restart$name
[18:06:25.256]                           if (is.null(name)) 
[18:06:25.256]                             next
[18:06:25.256]                           if (!grepl(pattern, name)) 
[18:06:25.256]                             next
[18:06:25.256]                           invokeRestart(restart)
[18:06:25.256]                           muffled <- TRUE
[18:06:25.256]                           break
[18:06:25.256]                         }
[18:06:25.256]                       }
[18:06:25.256]                     }
[18:06:25.256]                     invisible(muffled)
[18:06:25.256]                   }
[18:06:25.256]                   muffleCondition(cond)
[18:06:25.256]                 })
[18:06:25.256]             }))
[18:06:25.256]             future::FutureResult(value = ...future.value$value, 
[18:06:25.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.256]                   ...future.rng), globalenv = if (FALSE) 
[18:06:25.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:25.256]                     ...future.globalenv.names))
[18:06:25.256]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:25.256]         }, condition = base::local({
[18:06:25.256]             c <- base::c
[18:06:25.256]             inherits <- base::inherits
[18:06:25.256]             invokeRestart <- base::invokeRestart
[18:06:25.256]             length <- base::length
[18:06:25.256]             list <- base::list
[18:06:25.256]             seq.int <- base::seq.int
[18:06:25.256]             signalCondition <- base::signalCondition
[18:06:25.256]             sys.calls <- base::sys.calls
[18:06:25.256]             `[[` <- base::`[[`
[18:06:25.256]             `+` <- base::`+`
[18:06:25.256]             `<<-` <- base::`<<-`
[18:06:25.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:25.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:25.256]                   3L)]
[18:06:25.256]             }
[18:06:25.256]             function(cond) {
[18:06:25.256]                 is_error <- inherits(cond, "error")
[18:06:25.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:25.256]                   NULL)
[18:06:25.256]                 if (is_error) {
[18:06:25.256]                   sessionInformation <- function() {
[18:06:25.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:25.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:25.256]                       search = base::search(), system = base::Sys.info())
[18:06:25.256]                   }
[18:06:25.256]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:25.256]                     cond$call), session = sessionInformation(), 
[18:06:25.256]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:25.256]                   signalCondition(cond)
[18:06:25.256]                 }
[18:06:25.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:25.256]                 "immediateCondition"))) {
[18:06:25.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:25.256]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:25.256]                   if (TRUE && !signal) {
[18:06:25.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.256]                     {
[18:06:25.256]                       inherits <- base::inherits
[18:06:25.256]                       invokeRestart <- base::invokeRestart
[18:06:25.256]                       is.null <- base::is.null
[18:06:25.256]                       muffled <- FALSE
[18:06:25.256]                       if (inherits(cond, "message")) {
[18:06:25.256]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.256]                         if (muffled) 
[18:06:25.256]                           invokeRestart("muffleMessage")
[18:06:25.256]                       }
[18:06:25.256]                       else if (inherits(cond, "warning")) {
[18:06:25.256]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.256]                         if (muffled) 
[18:06:25.256]                           invokeRestart("muffleWarning")
[18:06:25.256]                       }
[18:06:25.256]                       else if (inherits(cond, "condition")) {
[18:06:25.256]                         if (!is.null(pattern)) {
[18:06:25.256]                           computeRestarts <- base::computeRestarts
[18:06:25.256]                           grepl <- base::grepl
[18:06:25.256]                           restarts <- computeRestarts(cond)
[18:06:25.256]                           for (restart in restarts) {
[18:06:25.256]                             name <- restart$name
[18:06:25.256]                             if (is.null(name)) 
[18:06:25.256]                               next
[18:06:25.256]                             if (!grepl(pattern, name)) 
[18:06:25.256]                               next
[18:06:25.256]                             invokeRestart(restart)
[18:06:25.256]                             muffled <- TRUE
[18:06:25.256]                             break
[18:06:25.256]                           }
[18:06:25.256]                         }
[18:06:25.256]                       }
[18:06:25.256]                       invisible(muffled)
[18:06:25.256]                     }
[18:06:25.256]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.256]                   }
[18:06:25.256]                 }
[18:06:25.256]                 else {
[18:06:25.256]                   if (TRUE) {
[18:06:25.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.256]                     {
[18:06:25.256]                       inherits <- base::inherits
[18:06:25.256]                       invokeRestart <- base::invokeRestart
[18:06:25.256]                       is.null <- base::is.null
[18:06:25.256]                       muffled <- FALSE
[18:06:25.256]                       if (inherits(cond, "message")) {
[18:06:25.256]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.256]                         if (muffled) 
[18:06:25.256]                           invokeRestart("muffleMessage")
[18:06:25.256]                       }
[18:06:25.256]                       else if (inherits(cond, "warning")) {
[18:06:25.256]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.256]                         if (muffled) 
[18:06:25.256]                           invokeRestart("muffleWarning")
[18:06:25.256]                       }
[18:06:25.256]                       else if (inherits(cond, "condition")) {
[18:06:25.256]                         if (!is.null(pattern)) {
[18:06:25.256]                           computeRestarts <- base::computeRestarts
[18:06:25.256]                           grepl <- base::grepl
[18:06:25.256]                           restarts <- computeRestarts(cond)
[18:06:25.256]                           for (restart in restarts) {
[18:06:25.256]                             name <- restart$name
[18:06:25.256]                             if (is.null(name)) 
[18:06:25.256]                               next
[18:06:25.256]                             if (!grepl(pattern, name)) 
[18:06:25.256]                               next
[18:06:25.256]                             invokeRestart(restart)
[18:06:25.256]                             muffled <- TRUE
[18:06:25.256]                             break
[18:06:25.256]                           }
[18:06:25.256]                         }
[18:06:25.256]                       }
[18:06:25.256]                       invisible(muffled)
[18:06:25.256]                     }
[18:06:25.256]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.256]                   }
[18:06:25.256]                 }
[18:06:25.256]             }
[18:06:25.256]         }))
[18:06:25.256]     }, error = function(ex) {
[18:06:25.256]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:25.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.256]                 ...future.rng), started = ...future.startTime, 
[18:06:25.256]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:25.256]             version = "1.8"), class = "FutureResult")
[18:06:25.256]     }, finally = {
[18:06:25.256]         if (!identical(...future.workdir, getwd())) 
[18:06:25.256]             setwd(...future.workdir)
[18:06:25.256]         {
[18:06:25.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:25.256]                 ...future.oldOptions$nwarnings <- NULL
[18:06:25.256]             }
[18:06:25.256]             base::options(...future.oldOptions)
[18:06:25.256]             if (.Platform$OS.type == "windows") {
[18:06:25.256]                 old_names <- names(...future.oldEnvVars)
[18:06:25.256]                 envs <- base::Sys.getenv()
[18:06:25.256]                 names <- names(envs)
[18:06:25.256]                 common <- intersect(names, old_names)
[18:06:25.256]                 added <- setdiff(names, old_names)
[18:06:25.256]                 removed <- setdiff(old_names, names)
[18:06:25.256]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:25.256]                   envs[common]]
[18:06:25.256]                 NAMES <- toupper(changed)
[18:06:25.256]                 args <- list()
[18:06:25.256]                 for (kk in seq_along(NAMES)) {
[18:06:25.256]                   name <- changed[[kk]]
[18:06:25.256]                   NAME <- NAMES[[kk]]
[18:06:25.256]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.256]                     next
[18:06:25.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.256]                 }
[18:06:25.256]                 NAMES <- toupper(added)
[18:06:25.256]                 for (kk in seq_along(NAMES)) {
[18:06:25.256]                   name <- added[[kk]]
[18:06:25.256]                   NAME <- NAMES[[kk]]
[18:06:25.256]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.256]                     next
[18:06:25.256]                   args[[name]] <- ""
[18:06:25.256]                 }
[18:06:25.256]                 NAMES <- toupper(removed)
[18:06:25.256]                 for (kk in seq_along(NAMES)) {
[18:06:25.256]                   name <- removed[[kk]]
[18:06:25.256]                   NAME <- NAMES[[kk]]
[18:06:25.256]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.256]                     next
[18:06:25.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.256]                 }
[18:06:25.256]                 if (length(args) > 0) 
[18:06:25.256]                   base::do.call(base::Sys.setenv, args = args)
[18:06:25.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:25.256]             }
[18:06:25.256]             else {
[18:06:25.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:25.256]             }
[18:06:25.256]             {
[18:06:25.256]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:25.256]                   0L) {
[18:06:25.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:25.256]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:25.256]                   base::options(opts)
[18:06:25.256]                 }
[18:06:25.256]                 {
[18:06:25.256]                   {
[18:06:25.256]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:25.256]                     NULL
[18:06:25.256]                   }
[18:06:25.256]                   options(future.plan = NULL)
[18:06:25.256]                   if (is.na(NA_character_)) 
[18:06:25.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:25.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:25.256]                     .init = FALSE)
[18:06:25.256]                 }
[18:06:25.256]             }
[18:06:25.256]         }
[18:06:25.256]     })
[18:06:25.256]     if (TRUE) {
[18:06:25.256]         base::sink(type = "output", split = FALSE)
[18:06:25.256]         if (TRUE) {
[18:06:25.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:25.256]         }
[18:06:25.256]         else {
[18:06:25.256]             ...future.result["stdout"] <- base::list(NULL)
[18:06:25.256]         }
[18:06:25.256]         base::close(...future.stdout)
[18:06:25.256]         ...future.stdout <- NULL
[18:06:25.256]     }
[18:06:25.256]     ...future.result$conditions <- ...future.conditions
[18:06:25.256]     ...future.result$finished <- base::Sys.time()
[18:06:25.256]     ...future.result
[18:06:25.256] }
[18:06:25.262] MultisessionFuture started
[18:06:25.262] - Launch lazy future ... done
[18:06:25.262] run() for ‘MultisessionFuture’ ... done
[18:06:25.806] receiveMessageFromWorker() for ClusterFuture ...
[18:06:25.807] - Validating connection of MultisessionFuture
[18:06:25.808] - received message: FutureResult
[18:06:25.808] - Received FutureResult
[18:06:25.808] - Erased future from FutureRegistry
[18:06:25.809] result() for ClusterFuture ...
[18:06:25.809] - result already collected: FutureResult
[18:06:25.809] result() for ClusterFuture ... done
[18:06:25.810] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:25.810] resolve() on list ...
[18:06:25.810]  recursive: 1
[18:06:25.811]  length: 2
[18:06:25.811]  elements: ‘a’, ‘b’
[18:06:25.811]  length: 1 (resolved future 1)
[18:06:25.812]  length: 0 (resolved future 2)
[18:06:25.812] resolve() on list ... DONE
[18:06:25.812] A MultisessionFuture was resolved (and resolved itself)
[18:06:25.813] getGlobalsAndPackages() ...
[18:06:25.813] Searching for globals...
[18:06:25.816] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:25.817] Searching for globals ... DONE
[18:06:25.817] Resolving globals: FALSE
[18:06:25.818] 
[18:06:25.818] 
[18:06:25.819] getGlobalsAndPackages() ... DONE
[18:06:25.820] run() for ‘Future’ ...
[18:06:25.820] - state: ‘created’
[18:06:25.820] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:25.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:25.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:25.853]   - Field: ‘node’
[18:06:25.854]   - Field: ‘label’
[18:06:25.854]   - Field: ‘local’
[18:06:25.854]   - Field: ‘owner’
[18:06:25.854]   - Field: ‘envir’
[18:06:25.855]   - Field: ‘workers’
[18:06:25.855]   - Field: ‘packages’
[18:06:25.855]   - Field: ‘gc’
[18:06:25.856]   - Field: ‘conditions’
[18:06:25.856]   - Field: ‘persistent’
[18:06:25.856]   - Field: ‘expr’
[18:06:25.856]   - Field: ‘uuid’
[18:06:25.857]   - Field: ‘seed’
[18:06:25.857]   - Field: ‘version’
[18:06:25.857]   - Field: ‘result’
[18:06:25.857]   - Field: ‘asynchronous’
[18:06:25.858]   - Field: ‘calls’
[18:06:25.858]   - Field: ‘globals’
[18:06:25.858]   - Field: ‘stdout’
[18:06:25.858]   - Field: ‘earlySignal’
[18:06:25.859]   - Field: ‘lazy’
[18:06:25.859]   - Field: ‘state’
[18:06:25.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:25.859] - Launch lazy future ...
[18:06:25.860] Packages needed by the future expression (n = 0): <none>
[18:06:25.860] Packages needed by future strategies (n = 0): <none>
[18:06:25.862] {
[18:06:25.862]     {
[18:06:25.862]         {
[18:06:25.862]             ...future.startTime <- base::Sys.time()
[18:06:25.862]             {
[18:06:25.862]                 {
[18:06:25.862]                   {
[18:06:25.862]                     {
[18:06:25.862]                       base::local({
[18:06:25.862]                         has_future <- base::requireNamespace("future", 
[18:06:25.862]                           quietly = TRUE)
[18:06:25.862]                         if (has_future) {
[18:06:25.862]                           ns <- base::getNamespace("future")
[18:06:25.862]                           version <- ns[[".package"]][["version"]]
[18:06:25.862]                           if (is.null(version)) 
[18:06:25.862]                             version <- utils::packageVersion("future")
[18:06:25.862]                         }
[18:06:25.862]                         else {
[18:06:25.862]                           version <- NULL
[18:06:25.862]                         }
[18:06:25.862]                         if (!has_future || version < "1.8.0") {
[18:06:25.862]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:25.862]                             "", base::R.version$version.string), 
[18:06:25.862]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:25.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:25.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:25.862]                               "release", "version")], collapse = " "), 
[18:06:25.862]                             hostname = base::Sys.info()[["nodename"]])
[18:06:25.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:25.862]                             info)
[18:06:25.862]                           info <- base::paste(info, collapse = "; ")
[18:06:25.862]                           if (!has_future) {
[18:06:25.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:25.862]                               info)
[18:06:25.862]                           }
[18:06:25.862]                           else {
[18:06:25.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:25.862]                               info, version)
[18:06:25.862]                           }
[18:06:25.862]                           base::stop(msg)
[18:06:25.862]                         }
[18:06:25.862]                       })
[18:06:25.862]                     }
[18:06:25.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:25.862]                     base::options(mc.cores = 1L)
[18:06:25.862]                   }
[18:06:25.862]                   ...future.strategy.old <- future::plan("list")
[18:06:25.862]                   options(future.plan = NULL)
[18:06:25.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:25.862]                 }
[18:06:25.862]                 ...future.workdir <- getwd()
[18:06:25.862]             }
[18:06:25.862]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:25.862]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:25.862]         }
[18:06:25.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:25.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:25.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:25.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:25.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:25.862]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:25.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:25.862]             base::names(...future.oldOptions))
[18:06:25.862]     }
[18:06:25.862]     if (FALSE) {
[18:06:25.862]     }
[18:06:25.862]     else {
[18:06:25.862]         if (TRUE) {
[18:06:25.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:25.862]                 open = "w")
[18:06:25.862]         }
[18:06:25.862]         else {
[18:06:25.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:25.862]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:25.862]         }
[18:06:25.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:25.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:25.862]             base::sink(type = "output", split = FALSE)
[18:06:25.862]             base::close(...future.stdout)
[18:06:25.862]         }, add = TRUE)
[18:06:25.862]     }
[18:06:25.862]     ...future.frame <- base::sys.nframe()
[18:06:25.862]     ...future.conditions <- base::list()
[18:06:25.862]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:25.862]     if (FALSE) {
[18:06:25.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:25.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:25.862]     }
[18:06:25.862]     ...future.result <- base::tryCatch({
[18:06:25.862]         base::withCallingHandlers({
[18:06:25.862]             ...future.value <- base::withVisible(base::local({
[18:06:25.862]                 ...future.makeSendCondition <- base::local({
[18:06:25.862]                   sendCondition <- NULL
[18:06:25.862]                   function(frame = 1L) {
[18:06:25.862]                     if (is.function(sendCondition)) 
[18:06:25.862]                       return(sendCondition)
[18:06:25.862]                     ns <- getNamespace("parallel")
[18:06:25.862]                     if (exists("sendData", mode = "function", 
[18:06:25.862]                       envir = ns)) {
[18:06:25.862]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:25.862]                         envir = ns)
[18:06:25.862]                       envir <- sys.frame(frame)
[18:06:25.862]                       master <- NULL
[18:06:25.862]                       while (!identical(envir, .GlobalEnv) && 
[18:06:25.862]                         !identical(envir, emptyenv())) {
[18:06:25.862]                         if (exists("master", mode = "list", envir = envir, 
[18:06:25.862]                           inherits = FALSE)) {
[18:06:25.862]                           master <- get("master", mode = "list", 
[18:06:25.862]                             envir = envir, inherits = FALSE)
[18:06:25.862]                           if (inherits(master, c("SOCKnode", 
[18:06:25.862]                             "SOCK0node"))) {
[18:06:25.862]                             sendCondition <<- function(cond) {
[18:06:25.862]                               data <- list(type = "VALUE", value = cond, 
[18:06:25.862]                                 success = TRUE)
[18:06:25.862]                               parallel_sendData(master, data)
[18:06:25.862]                             }
[18:06:25.862]                             return(sendCondition)
[18:06:25.862]                           }
[18:06:25.862]                         }
[18:06:25.862]                         frame <- frame + 1L
[18:06:25.862]                         envir <- sys.frame(frame)
[18:06:25.862]                       }
[18:06:25.862]                     }
[18:06:25.862]                     sendCondition <<- function(cond) NULL
[18:06:25.862]                   }
[18:06:25.862]                 })
[18:06:25.862]                 withCallingHandlers({
[18:06:25.862]                   {
[18:06:25.862]                     Sys.sleep(0.5)
[18:06:25.862]                     list(a = 1, b = 42L)
[18:06:25.862]                   }
[18:06:25.862]                 }, immediateCondition = function(cond) {
[18:06:25.862]                   sendCondition <- ...future.makeSendCondition()
[18:06:25.862]                   sendCondition(cond)
[18:06:25.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.862]                   {
[18:06:25.862]                     inherits <- base::inherits
[18:06:25.862]                     invokeRestart <- base::invokeRestart
[18:06:25.862]                     is.null <- base::is.null
[18:06:25.862]                     muffled <- FALSE
[18:06:25.862]                     if (inherits(cond, "message")) {
[18:06:25.862]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:25.862]                       if (muffled) 
[18:06:25.862]                         invokeRestart("muffleMessage")
[18:06:25.862]                     }
[18:06:25.862]                     else if (inherits(cond, "warning")) {
[18:06:25.862]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:25.862]                       if (muffled) 
[18:06:25.862]                         invokeRestart("muffleWarning")
[18:06:25.862]                     }
[18:06:25.862]                     else if (inherits(cond, "condition")) {
[18:06:25.862]                       if (!is.null(pattern)) {
[18:06:25.862]                         computeRestarts <- base::computeRestarts
[18:06:25.862]                         grepl <- base::grepl
[18:06:25.862]                         restarts <- computeRestarts(cond)
[18:06:25.862]                         for (restart in restarts) {
[18:06:25.862]                           name <- restart$name
[18:06:25.862]                           if (is.null(name)) 
[18:06:25.862]                             next
[18:06:25.862]                           if (!grepl(pattern, name)) 
[18:06:25.862]                             next
[18:06:25.862]                           invokeRestart(restart)
[18:06:25.862]                           muffled <- TRUE
[18:06:25.862]                           break
[18:06:25.862]                         }
[18:06:25.862]                       }
[18:06:25.862]                     }
[18:06:25.862]                     invisible(muffled)
[18:06:25.862]                   }
[18:06:25.862]                   muffleCondition(cond)
[18:06:25.862]                 })
[18:06:25.862]             }))
[18:06:25.862]             future::FutureResult(value = ...future.value$value, 
[18:06:25.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.862]                   ...future.rng), globalenv = if (FALSE) 
[18:06:25.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:25.862]                     ...future.globalenv.names))
[18:06:25.862]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:25.862]         }, condition = base::local({
[18:06:25.862]             c <- base::c
[18:06:25.862]             inherits <- base::inherits
[18:06:25.862]             invokeRestart <- base::invokeRestart
[18:06:25.862]             length <- base::length
[18:06:25.862]             list <- base::list
[18:06:25.862]             seq.int <- base::seq.int
[18:06:25.862]             signalCondition <- base::signalCondition
[18:06:25.862]             sys.calls <- base::sys.calls
[18:06:25.862]             `[[` <- base::`[[`
[18:06:25.862]             `+` <- base::`+`
[18:06:25.862]             `<<-` <- base::`<<-`
[18:06:25.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:25.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:25.862]                   3L)]
[18:06:25.862]             }
[18:06:25.862]             function(cond) {
[18:06:25.862]                 is_error <- inherits(cond, "error")
[18:06:25.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:25.862]                   NULL)
[18:06:25.862]                 if (is_error) {
[18:06:25.862]                   sessionInformation <- function() {
[18:06:25.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:25.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:25.862]                       search = base::search(), system = base::Sys.info())
[18:06:25.862]                   }
[18:06:25.862]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:25.862]                     cond$call), session = sessionInformation(), 
[18:06:25.862]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:25.862]                   signalCondition(cond)
[18:06:25.862]                 }
[18:06:25.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:25.862]                 "immediateCondition"))) {
[18:06:25.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:25.862]                   ...future.conditions[[length(...future.conditions) + 
[18:06:25.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:25.862]                   if (TRUE && !signal) {
[18:06:25.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.862]                     {
[18:06:25.862]                       inherits <- base::inherits
[18:06:25.862]                       invokeRestart <- base::invokeRestart
[18:06:25.862]                       is.null <- base::is.null
[18:06:25.862]                       muffled <- FALSE
[18:06:25.862]                       if (inherits(cond, "message")) {
[18:06:25.862]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.862]                         if (muffled) 
[18:06:25.862]                           invokeRestart("muffleMessage")
[18:06:25.862]                       }
[18:06:25.862]                       else if (inherits(cond, "warning")) {
[18:06:25.862]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.862]                         if (muffled) 
[18:06:25.862]                           invokeRestart("muffleWarning")
[18:06:25.862]                       }
[18:06:25.862]                       else if (inherits(cond, "condition")) {
[18:06:25.862]                         if (!is.null(pattern)) {
[18:06:25.862]                           computeRestarts <- base::computeRestarts
[18:06:25.862]                           grepl <- base::grepl
[18:06:25.862]                           restarts <- computeRestarts(cond)
[18:06:25.862]                           for (restart in restarts) {
[18:06:25.862]                             name <- restart$name
[18:06:25.862]                             if (is.null(name)) 
[18:06:25.862]                               next
[18:06:25.862]                             if (!grepl(pattern, name)) 
[18:06:25.862]                               next
[18:06:25.862]                             invokeRestart(restart)
[18:06:25.862]                             muffled <- TRUE
[18:06:25.862]                             break
[18:06:25.862]                           }
[18:06:25.862]                         }
[18:06:25.862]                       }
[18:06:25.862]                       invisible(muffled)
[18:06:25.862]                     }
[18:06:25.862]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.862]                   }
[18:06:25.862]                 }
[18:06:25.862]                 else {
[18:06:25.862]                   if (TRUE) {
[18:06:25.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:25.862]                     {
[18:06:25.862]                       inherits <- base::inherits
[18:06:25.862]                       invokeRestart <- base::invokeRestart
[18:06:25.862]                       is.null <- base::is.null
[18:06:25.862]                       muffled <- FALSE
[18:06:25.862]                       if (inherits(cond, "message")) {
[18:06:25.862]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:25.862]                         if (muffled) 
[18:06:25.862]                           invokeRestart("muffleMessage")
[18:06:25.862]                       }
[18:06:25.862]                       else if (inherits(cond, "warning")) {
[18:06:25.862]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:25.862]                         if (muffled) 
[18:06:25.862]                           invokeRestart("muffleWarning")
[18:06:25.862]                       }
[18:06:25.862]                       else if (inherits(cond, "condition")) {
[18:06:25.862]                         if (!is.null(pattern)) {
[18:06:25.862]                           computeRestarts <- base::computeRestarts
[18:06:25.862]                           grepl <- base::grepl
[18:06:25.862]                           restarts <- computeRestarts(cond)
[18:06:25.862]                           for (restart in restarts) {
[18:06:25.862]                             name <- restart$name
[18:06:25.862]                             if (is.null(name)) 
[18:06:25.862]                               next
[18:06:25.862]                             if (!grepl(pattern, name)) 
[18:06:25.862]                               next
[18:06:25.862]                             invokeRestart(restart)
[18:06:25.862]                             muffled <- TRUE
[18:06:25.862]                             break
[18:06:25.862]                           }
[18:06:25.862]                         }
[18:06:25.862]                       }
[18:06:25.862]                       invisible(muffled)
[18:06:25.862]                     }
[18:06:25.862]                     muffleCondition(cond, pattern = "^muffle")
[18:06:25.862]                   }
[18:06:25.862]                 }
[18:06:25.862]             }
[18:06:25.862]         }))
[18:06:25.862]     }, error = function(ex) {
[18:06:25.862]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:25.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:25.862]                 ...future.rng), started = ...future.startTime, 
[18:06:25.862]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:25.862]             version = "1.8"), class = "FutureResult")
[18:06:25.862]     }, finally = {
[18:06:25.862]         if (!identical(...future.workdir, getwd())) 
[18:06:25.862]             setwd(...future.workdir)
[18:06:25.862]         {
[18:06:25.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:25.862]                 ...future.oldOptions$nwarnings <- NULL
[18:06:25.862]             }
[18:06:25.862]             base::options(...future.oldOptions)
[18:06:25.862]             if (.Platform$OS.type == "windows") {
[18:06:25.862]                 old_names <- names(...future.oldEnvVars)
[18:06:25.862]                 envs <- base::Sys.getenv()
[18:06:25.862]                 names <- names(envs)
[18:06:25.862]                 common <- intersect(names, old_names)
[18:06:25.862]                 added <- setdiff(names, old_names)
[18:06:25.862]                 removed <- setdiff(old_names, names)
[18:06:25.862]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:25.862]                   envs[common]]
[18:06:25.862]                 NAMES <- toupper(changed)
[18:06:25.862]                 args <- list()
[18:06:25.862]                 for (kk in seq_along(NAMES)) {
[18:06:25.862]                   name <- changed[[kk]]
[18:06:25.862]                   NAME <- NAMES[[kk]]
[18:06:25.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.862]                     next
[18:06:25.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.862]                 }
[18:06:25.862]                 NAMES <- toupper(added)
[18:06:25.862]                 for (kk in seq_along(NAMES)) {
[18:06:25.862]                   name <- added[[kk]]
[18:06:25.862]                   NAME <- NAMES[[kk]]
[18:06:25.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.862]                     next
[18:06:25.862]                   args[[name]] <- ""
[18:06:25.862]                 }
[18:06:25.862]                 NAMES <- toupper(removed)
[18:06:25.862]                 for (kk in seq_along(NAMES)) {
[18:06:25.862]                   name <- removed[[kk]]
[18:06:25.862]                   NAME <- NAMES[[kk]]
[18:06:25.862]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:25.862]                     next
[18:06:25.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:25.862]                 }
[18:06:25.862]                 if (length(args) > 0) 
[18:06:25.862]                   base::do.call(base::Sys.setenv, args = args)
[18:06:25.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:25.862]             }
[18:06:25.862]             else {
[18:06:25.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:25.862]             }
[18:06:25.862]             {
[18:06:25.862]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:25.862]                   0L) {
[18:06:25.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:25.862]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:25.862]                   base::options(opts)
[18:06:25.862]                 }
[18:06:25.862]                 {
[18:06:25.862]                   {
[18:06:25.862]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:25.862]                     NULL
[18:06:25.862]                   }
[18:06:25.862]                   options(future.plan = NULL)
[18:06:25.862]                   if (is.na(NA_character_)) 
[18:06:25.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:25.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:25.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:25.862]                     .init = FALSE)
[18:06:25.862]                 }
[18:06:25.862]             }
[18:06:25.862]         }
[18:06:25.862]     })
[18:06:25.862]     if (TRUE) {
[18:06:25.862]         base::sink(type = "output", split = FALSE)
[18:06:25.862]         if (TRUE) {
[18:06:25.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:25.862]         }
[18:06:25.862]         else {
[18:06:25.862]             ...future.result["stdout"] <- base::list(NULL)
[18:06:25.862]         }
[18:06:25.862]         base::close(...future.stdout)
[18:06:25.862]         ...future.stdout <- NULL
[18:06:25.862]     }
[18:06:25.862]     ...future.result$conditions <- ...future.conditions
[18:06:25.862]     ...future.result$finished <- base::Sys.time()
[18:06:25.862]     ...future.result
[18:06:25.862] }
[18:06:25.869] MultisessionFuture started
[18:06:25.869] - Launch lazy future ... done
[18:06:25.869] run() for ‘MultisessionFuture’ ... done
[18:06:26.413] receiveMessageFromWorker() for ClusterFuture ...
[18:06:26.414] - Validating connection of MultisessionFuture
[18:06:26.414] - received message: FutureResult
[18:06:26.415] - Received FutureResult
[18:06:26.415] - Erased future from FutureRegistry
[18:06:26.415] result() for ClusterFuture ...
[18:06:26.416] - result already collected: FutureResult
[18:06:26.416] result() for ClusterFuture ... done
[18:06:26.416] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:26.417] resolve() on list ...
[18:06:26.417]  recursive: 1
[18:06:26.417]  length: 2
[18:06:26.418]  elements: ‘a’, ‘b’
[18:06:26.418]  length: 1 (resolved future 1)
[18:06:26.418]  length: 0 (resolved future 2)
[18:06:26.419] resolve() on list ... DONE
[18:06:26.419] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[18:06:26.419] getGlobalsAndPackages() ...
[18:06:26.420] Searching for globals...
[18:06:26.422] - globals found: [2] ‘list’, ‘stop’
[18:06:26.422] Searching for globals ... DONE
[18:06:26.422] Resolving globals: FALSE
[18:06:26.423] 
[18:06:26.424] 
[18:06:26.424] getGlobalsAndPackages() ... DONE
[18:06:26.425] run() for ‘Future’ ...
[18:06:26.425] - state: ‘created’
[18:06:26.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:26.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:26.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:26.453]   - Field: ‘node’
[18:06:26.453]   - Field: ‘label’
[18:06:26.453]   - Field: ‘local’
[18:06:26.454]   - Field: ‘owner’
[18:06:26.454]   - Field: ‘envir’
[18:06:26.454]   - Field: ‘workers’
[18:06:26.454]   - Field: ‘packages’
[18:06:26.455]   - Field: ‘gc’
[18:06:26.455]   - Field: ‘conditions’
[18:06:26.455]   - Field: ‘persistent’
[18:06:26.455]   - Field: ‘expr’
[18:06:26.455]   - Field: ‘uuid’
[18:06:26.456]   - Field: ‘seed’
[18:06:26.456]   - Field: ‘version’
[18:06:26.456]   - Field: ‘result’
[18:06:26.456]   - Field: ‘asynchronous’
[18:06:26.457]   - Field: ‘calls’
[18:06:26.457]   - Field: ‘globals’
[18:06:26.457]   - Field: ‘stdout’
[18:06:26.457]   - Field: ‘earlySignal’
[18:06:26.457]   - Field: ‘lazy’
[18:06:26.458]   - Field: ‘state’
[18:06:26.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:26.458] - Launch lazy future ...
[18:06:26.459] Packages needed by the future expression (n = 0): <none>
[18:06:26.459] Packages needed by future strategies (n = 0): <none>
[18:06:26.460] {
[18:06:26.460]     {
[18:06:26.460]         {
[18:06:26.460]             ...future.startTime <- base::Sys.time()
[18:06:26.460]             {
[18:06:26.460]                 {
[18:06:26.460]                   {
[18:06:26.460]                     {
[18:06:26.460]                       base::local({
[18:06:26.460]                         has_future <- base::requireNamespace("future", 
[18:06:26.460]                           quietly = TRUE)
[18:06:26.460]                         if (has_future) {
[18:06:26.460]                           ns <- base::getNamespace("future")
[18:06:26.460]                           version <- ns[[".package"]][["version"]]
[18:06:26.460]                           if (is.null(version)) 
[18:06:26.460]                             version <- utils::packageVersion("future")
[18:06:26.460]                         }
[18:06:26.460]                         else {
[18:06:26.460]                           version <- NULL
[18:06:26.460]                         }
[18:06:26.460]                         if (!has_future || version < "1.8.0") {
[18:06:26.460]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:26.460]                             "", base::R.version$version.string), 
[18:06:26.460]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:26.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:26.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:26.460]                               "release", "version")], collapse = " "), 
[18:06:26.460]                             hostname = base::Sys.info()[["nodename"]])
[18:06:26.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:26.460]                             info)
[18:06:26.460]                           info <- base::paste(info, collapse = "; ")
[18:06:26.460]                           if (!has_future) {
[18:06:26.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:26.460]                               info)
[18:06:26.460]                           }
[18:06:26.460]                           else {
[18:06:26.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:26.460]                               info, version)
[18:06:26.460]                           }
[18:06:26.460]                           base::stop(msg)
[18:06:26.460]                         }
[18:06:26.460]                       })
[18:06:26.460]                     }
[18:06:26.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:26.460]                     base::options(mc.cores = 1L)
[18:06:26.460]                   }
[18:06:26.460]                   ...future.strategy.old <- future::plan("list")
[18:06:26.460]                   options(future.plan = NULL)
[18:06:26.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:26.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:26.460]                 }
[18:06:26.460]                 ...future.workdir <- getwd()
[18:06:26.460]             }
[18:06:26.460]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:26.460]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:26.460]         }
[18:06:26.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:26.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:26.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:26.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:26.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:26.460]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:26.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:26.460]             base::names(...future.oldOptions))
[18:06:26.460]     }
[18:06:26.460]     if (FALSE) {
[18:06:26.460]     }
[18:06:26.460]     else {
[18:06:26.460]         if (TRUE) {
[18:06:26.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:26.460]                 open = "w")
[18:06:26.460]         }
[18:06:26.460]         else {
[18:06:26.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:26.460]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:26.460]         }
[18:06:26.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:26.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:26.460]             base::sink(type = "output", split = FALSE)
[18:06:26.460]             base::close(...future.stdout)
[18:06:26.460]         }, add = TRUE)
[18:06:26.460]     }
[18:06:26.460]     ...future.frame <- base::sys.nframe()
[18:06:26.460]     ...future.conditions <- base::list()
[18:06:26.460]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:26.460]     if (FALSE) {
[18:06:26.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:26.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:26.460]     }
[18:06:26.460]     ...future.result <- base::tryCatch({
[18:06:26.460]         base::withCallingHandlers({
[18:06:26.460]             ...future.value <- base::withVisible(base::local({
[18:06:26.460]                 ...future.makeSendCondition <- base::local({
[18:06:26.460]                   sendCondition <- NULL
[18:06:26.460]                   function(frame = 1L) {
[18:06:26.460]                     if (is.function(sendCondition)) 
[18:06:26.460]                       return(sendCondition)
[18:06:26.460]                     ns <- getNamespace("parallel")
[18:06:26.460]                     if (exists("sendData", mode = "function", 
[18:06:26.460]                       envir = ns)) {
[18:06:26.460]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:26.460]                         envir = ns)
[18:06:26.460]                       envir <- sys.frame(frame)
[18:06:26.460]                       master <- NULL
[18:06:26.460]                       while (!identical(envir, .GlobalEnv) && 
[18:06:26.460]                         !identical(envir, emptyenv())) {
[18:06:26.460]                         if (exists("master", mode = "list", envir = envir, 
[18:06:26.460]                           inherits = FALSE)) {
[18:06:26.460]                           master <- get("master", mode = "list", 
[18:06:26.460]                             envir = envir, inherits = FALSE)
[18:06:26.460]                           if (inherits(master, c("SOCKnode", 
[18:06:26.460]                             "SOCK0node"))) {
[18:06:26.460]                             sendCondition <<- function(cond) {
[18:06:26.460]                               data <- list(type = "VALUE", value = cond, 
[18:06:26.460]                                 success = TRUE)
[18:06:26.460]                               parallel_sendData(master, data)
[18:06:26.460]                             }
[18:06:26.460]                             return(sendCondition)
[18:06:26.460]                           }
[18:06:26.460]                         }
[18:06:26.460]                         frame <- frame + 1L
[18:06:26.460]                         envir <- sys.frame(frame)
[18:06:26.460]                       }
[18:06:26.460]                     }
[18:06:26.460]                     sendCondition <<- function(cond) NULL
[18:06:26.460]                   }
[18:06:26.460]                 })
[18:06:26.460]                 withCallingHandlers({
[18:06:26.460]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:26.460]                 }, immediateCondition = function(cond) {
[18:06:26.460]                   sendCondition <- ...future.makeSendCondition()
[18:06:26.460]                   sendCondition(cond)
[18:06:26.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.460]                   {
[18:06:26.460]                     inherits <- base::inherits
[18:06:26.460]                     invokeRestart <- base::invokeRestart
[18:06:26.460]                     is.null <- base::is.null
[18:06:26.460]                     muffled <- FALSE
[18:06:26.460]                     if (inherits(cond, "message")) {
[18:06:26.460]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:26.460]                       if (muffled) 
[18:06:26.460]                         invokeRestart("muffleMessage")
[18:06:26.460]                     }
[18:06:26.460]                     else if (inherits(cond, "warning")) {
[18:06:26.460]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:26.460]                       if (muffled) 
[18:06:26.460]                         invokeRestart("muffleWarning")
[18:06:26.460]                     }
[18:06:26.460]                     else if (inherits(cond, "condition")) {
[18:06:26.460]                       if (!is.null(pattern)) {
[18:06:26.460]                         computeRestarts <- base::computeRestarts
[18:06:26.460]                         grepl <- base::grepl
[18:06:26.460]                         restarts <- computeRestarts(cond)
[18:06:26.460]                         for (restart in restarts) {
[18:06:26.460]                           name <- restart$name
[18:06:26.460]                           if (is.null(name)) 
[18:06:26.460]                             next
[18:06:26.460]                           if (!grepl(pattern, name)) 
[18:06:26.460]                             next
[18:06:26.460]                           invokeRestart(restart)
[18:06:26.460]                           muffled <- TRUE
[18:06:26.460]                           break
[18:06:26.460]                         }
[18:06:26.460]                       }
[18:06:26.460]                     }
[18:06:26.460]                     invisible(muffled)
[18:06:26.460]                   }
[18:06:26.460]                   muffleCondition(cond)
[18:06:26.460]                 })
[18:06:26.460]             }))
[18:06:26.460]             future::FutureResult(value = ...future.value$value, 
[18:06:26.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:26.460]                   ...future.rng), globalenv = if (FALSE) 
[18:06:26.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:26.460]                     ...future.globalenv.names))
[18:06:26.460]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:26.460]         }, condition = base::local({
[18:06:26.460]             c <- base::c
[18:06:26.460]             inherits <- base::inherits
[18:06:26.460]             invokeRestart <- base::invokeRestart
[18:06:26.460]             length <- base::length
[18:06:26.460]             list <- base::list
[18:06:26.460]             seq.int <- base::seq.int
[18:06:26.460]             signalCondition <- base::signalCondition
[18:06:26.460]             sys.calls <- base::sys.calls
[18:06:26.460]             `[[` <- base::`[[`
[18:06:26.460]             `+` <- base::`+`
[18:06:26.460]             `<<-` <- base::`<<-`
[18:06:26.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:26.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:26.460]                   3L)]
[18:06:26.460]             }
[18:06:26.460]             function(cond) {
[18:06:26.460]                 is_error <- inherits(cond, "error")
[18:06:26.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:26.460]                   NULL)
[18:06:26.460]                 if (is_error) {
[18:06:26.460]                   sessionInformation <- function() {
[18:06:26.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:26.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:26.460]                       search = base::search(), system = base::Sys.info())
[18:06:26.460]                   }
[18:06:26.460]                   ...future.conditions[[length(...future.conditions) + 
[18:06:26.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:26.460]                     cond$call), session = sessionInformation(), 
[18:06:26.460]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:26.460]                   signalCondition(cond)
[18:06:26.460]                 }
[18:06:26.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:26.460]                 "immediateCondition"))) {
[18:06:26.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:26.460]                   ...future.conditions[[length(...future.conditions) + 
[18:06:26.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:26.460]                   if (TRUE && !signal) {
[18:06:26.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.460]                     {
[18:06:26.460]                       inherits <- base::inherits
[18:06:26.460]                       invokeRestart <- base::invokeRestart
[18:06:26.460]                       is.null <- base::is.null
[18:06:26.460]                       muffled <- FALSE
[18:06:26.460]                       if (inherits(cond, "message")) {
[18:06:26.460]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:26.460]                         if (muffled) 
[18:06:26.460]                           invokeRestart("muffleMessage")
[18:06:26.460]                       }
[18:06:26.460]                       else if (inherits(cond, "warning")) {
[18:06:26.460]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:26.460]                         if (muffled) 
[18:06:26.460]                           invokeRestart("muffleWarning")
[18:06:26.460]                       }
[18:06:26.460]                       else if (inherits(cond, "condition")) {
[18:06:26.460]                         if (!is.null(pattern)) {
[18:06:26.460]                           computeRestarts <- base::computeRestarts
[18:06:26.460]                           grepl <- base::grepl
[18:06:26.460]                           restarts <- computeRestarts(cond)
[18:06:26.460]                           for (restart in restarts) {
[18:06:26.460]                             name <- restart$name
[18:06:26.460]                             if (is.null(name)) 
[18:06:26.460]                               next
[18:06:26.460]                             if (!grepl(pattern, name)) 
[18:06:26.460]                               next
[18:06:26.460]                             invokeRestart(restart)
[18:06:26.460]                             muffled <- TRUE
[18:06:26.460]                             break
[18:06:26.460]                           }
[18:06:26.460]                         }
[18:06:26.460]                       }
[18:06:26.460]                       invisible(muffled)
[18:06:26.460]                     }
[18:06:26.460]                     muffleCondition(cond, pattern = "^muffle")
[18:06:26.460]                   }
[18:06:26.460]                 }
[18:06:26.460]                 else {
[18:06:26.460]                   if (TRUE) {
[18:06:26.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.460]                     {
[18:06:26.460]                       inherits <- base::inherits
[18:06:26.460]                       invokeRestart <- base::invokeRestart
[18:06:26.460]                       is.null <- base::is.null
[18:06:26.460]                       muffled <- FALSE
[18:06:26.460]                       if (inherits(cond, "message")) {
[18:06:26.460]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:26.460]                         if (muffled) 
[18:06:26.460]                           invokeRestart("muffleMessage")
[18:06:26.460]                       }
[18:06:26.460]                       else if (inherits(cond, "warning")) {
[18:06:26.460]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:26.460]                         if (muffled) 
[18:06:26.460]                           invokeRestart("muffleWarning")
[18:06:26.460]                       }
[18:06:26.460]                       else if (inherits(cond, "condition")) {
[18:06:26.460]                         if (!is.null(pattern)) {
[18:06:26.460]                           computeRestarts <- base::computeRestarts
[18:06:26.460]                           grepl <- base::grepl
[18:06:26.460]                           restarts <- computeRestarts(cond)
[18:06:26.460]                           for (restart in restarts) {
[18:06:26.460]                             name <- restart$name
[18:06:26.460]                             if (is.null(name)) 
[18:06:26.460]                               next
[18:06:26.460]                             if (!grepl(pattern, name)) 
[18:06:26.460]                               next
[18:06:26.460]                             invokeRestart(restart)
[18:06:26.460]                             muffled <- TRUE
[18:06:26.460]                             break
[18:06:26.460]                           }
[18:06:26.460]                         }
[18:06:26.460]                       }
[18:06:26.460]                       invisible(muffled)
[18:06:26.460]                     }
[18:06:26.460]                     muffleCondition(cond, pattern = "^muffle")
[18:06:26.460]                   }
[18:06:26.460]                 }
[18:06:26.460]             }
[18:06:26.460]         }))
[18:06:26.460]     }, error = function(ex) {
[18:06:26.460]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:26.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:26.460]                 ...future.rng), started = ...future.startTime, 
[18:06:26.460]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:26.460]             version = "1.8"), class = "FutureResult")
[18:06:26.460]     }, finally = {
[18:06:26.460]         if (!identical(...future.workdir, getwd())) 
[18:06:26.460]             setwd(...future.workdir)
[18:06:26.460]         {
[18:06:26.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:26.460]                 ...future.oldOptions$nwarnings <- NULL
[18:06:26.460]             }
[18:06:26.460]             base::options(...future.oldOptions)
[18:06:26.460]             if (.Platform$OS.type == "windows") {
[18:06:26.460]                 old_names <- names(...future.oldEnvVars)
[18:06:26.460]                 envs <- base::Sys.getenv()
[18:06:26.460]                 names <- names(envs)
[18:06:26.460]                 common <- intersect(names, old_names)
[18:06:26.460]                 added <- setdiff(names, old_names)
[18:06:26.460]                 removed <- setdiff(old_names, names)
[18:06:26.460]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:26.460]                   envs[common]]
[18:06:26.460]                 NAMES <- toupper(changed)
[18:06:26.460]                 args <- list()
[18:06:26.460]                 for (kk in seq_along(NAMES)) {
[18:06:26.460]                   name <- changed[[kk]]
[18:06:26.460]                   NAME <- NAMES[[kk]]
[18:06:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.460]                     next
[18:06:26.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:26.460]                 }
[18:06:26.460]                 NAMES <- toupper(added)
[18:06:26.460]                 for (kk in seq_along(NAMES)) {
[18:06:26.460]                   name <- added[[kk]]
[18:06:26.460]                   NAME <- NAMES[[kk]]
[18:06:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.460]                     next
[18:06:26.460]                   args[[name]] <- ""
[18:06:26.460]                 }
[18:06:26.460]                 NAMES <- toupper(removed)
[18:06:26.460]                 for (kk in seq_along(NAMES)) {
[18:06:26.460]                   name <- removed[[kk]]
[18:06:26.460]                   NAME <- NAMES[[kk]]
[18:06:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.460]                     next
[18:06:26.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:26.460]                 }
[18:06:26.460]                 if (length(args) > 0) 
[18:06:26.460]                   base::do.call(base::Sys.setenv, args = args)
[18:06:26.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:26.460]             }
[18:06:26.460]             else {
[18:06:26.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:26.460]             }
[18:06:26.460]             {
[18:06:26.460]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:26.460]                   0L) {
[18:06:26.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:26.460]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:26.460]                   base::options(opts)
[18:06:26.460]                 }
[18:06:26.460]                 {
[18:06:26.460]                   {
[18:06:26.460]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:26.460]                     NULL
[18:06:26.460]                   }
[18:06:26.460]                   options(future.plan = NULL)
[18:06:26.460]                   if (is.na(NA_character_)) 
[18:06:26.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:26.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:26.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:26.460]                     .init = FALSE)
[18:06:26.460]                 }
[18:06:26.460]             }
[18:06:26.460]         }
[18:06:26.460]     })
[18:06:26.460]     if (TRUE) {
[18:06:26.460]         base::sink(type = "output", split = FALSE)
[18:06:26.460]         if (TRUE) {
[18:06:26.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:26.460]         }
[18:06:26.460]         else {
[18:06:26.460]             ...future.result["stdout"] <- base::list(NULL)
[18:06:26.460]         }
[18:06:26.460]         base::close(...future.stdout)
[18:06:26.460]         ...future.stdout <- NULL
[18:06:26.460]     }
[18:06:26.460]     ...future.result$conditions <- ...future.conditions
[18:06:26.460]     ...future.result$finished <- base::Sys.time()
[18:06:26.460]     ...future.result
[18:06:26.460] }
[18:06:26.466] MultisessionFuture started
[18:06:26.467] - Launch lazy future ... done
[18:06:26.467] run() for ‘MultisessionFuture’ ... done
[18:06:26.511] receiveMessageFromWorker() for ClusterFuture ...
[18:06:26.511] - Validating connection of MultisessionFuture
[18:06:26.513] - received message: FutureResult
[18:06:26.513] - Received FutureResult
[18:06:26.514] - Erased future from FutureRegistry
[18:06:26.514] result() for ClusterFuture ...
[18:06:26.514] - result already collected: FutureResult
[18:06:26.515] result() for ClusterFuture ... done
[18:06:26.515] signalConditions() ...
[18:06:26.515]  - include = ‘immediateCondition’
[18:06:26.515]  - exclude = 
[18:06:26.516]  - resignal = FALSE
[18:06:26.516]  - Number of conditions: 1
[18:06:26.517] signalConditions() ... done
[18:06:26.517] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:26.517] A MultisessionFuture was resolved (and resolved itself)
[18:06:26.518] getGlobalsAndPackages() ...
[18:06:26.518] Searching for globals...
[18:06:26.520] - globals found: [2] ‘list’, ‘stop’
[18:06:26.520] Searching for globals ... DONE
[18:06:26.521] Resolving globals: FALSE
[18:06:26.522] 
[18:06:26.522] 
[18:06:26.523] getGlobalsAndPackages() ... DONE
[18:06:26.523] run() for ‘Future’ ...
[18:06:26.524] - state: ‘created’
[18:06:26.524] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:26.549] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:26.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:26.549]   - Field: ‘node’
[18:06:26.549]   - Field: ‘label’
[18:06:26.550]   - Field: ‘local’
[18:06:26.550]   - Field: ‘owner’
[18:06:26.550]   - Field: ‘envir’
[18:06:26.550]   - Field: ‘workers’
[18:06:26.551]   - Field: ‘packages’
[18:06:26.551]   - Field: ‘gc’
[18:06:26.551]   - Field: ‘conditions’
[18:06:26.551]   - Field: ‘persistent’
[18:06:26.551]   - Field: ‘expr’
[18:06:26.551]   - Field: ‘uuid’
[18:06:26.552]   - Field: ‘seed’
[18:06:26.552]   - Field: ‘version’
[18:06:26.552]   - Field: ‘result’
[18:06:26.552]   - Field: ‘asynchronous’
[18:06:26.552]   - Field: ‘calls’
[18:06:26.553]   - Field: ‘globals’
[18:06:26.553]   - Field: ‘stdout’
[18:06:26.553]   - Field: ‘earlySignal’
[18:06:26.553]   - Field: ‘lazy’
[18:06:26.553]   - Field: ‘state’
[18:06:26.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:26.554] - Launch lazy future ...
[18:06:26.554] Packages needed by the future expression (n = 0): <none>
[18:06:26.555] Packages needed by future strategies (n = 0): <none>
[18:06:26.555] {
[18:06:26.555]     {
[18:06:26.555]         {
[18:06:26.555]             ...future.startTime <- base::Sys.time()
[18:06:26.555]             {
[18:06:26.555]                 {
[18:06:26.555]                   {
[18:06:26.555]                     {
[18:06:26.555]                       base::local({
[18:06:26.555]                         has_future <- base::requireNamespace("future", 
[18:06:26.555]                           quietly = TRUE)
[18:06:26.555]                         if (has_future) {
[18:06:26.555]                           ns <- base::getNamespace("future")
[18:06:26.555]                           version <- ns[[".package"]][["version"]]
[18:06:26.555]                           if (is.null(version)) 
[18:06:26.555]                             version <- utils::packageVersion("future")
[18:06:26.555]                         }
[18:06:26.555]                         else {
[18:06:26.555]                           version <- NULL
[18:06:26.555]                         }
[18:06:26.555]                         if (!has_future || version < "1.8.0") {
[18:06:26.555]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:26.555]                             "", base::R.version$version.string), 
[18:06:26.555]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:26.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:26.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:26.555]                               "release", "version")], collapse = " "), 
[18:06:26.555]                             hostname = base::Sys.info()[["nodename"]])
[18:06:26.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:26.555]                             info)
[18:06:26.555]                           info <- base::paste(info, collapse = "; ")
[18:06:26.555]                           if (!has_future) {
[18:06:26.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:26.555]                               info)
[18:06:26.555]                           }
[18:06:26.555]                           else {
[18:06:26.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:26.555]                               info, version)
[18:06:26.555]                           }
[18:06:26.555]                           base::stop(msg)
[18:06:26.555]                         }
[18:06:26.555]                       })
[18:06:26.555]                     }
[18:06:26.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:26.555]                     base::options(mc.cores = 1L)
[18:06:26.555]                   }
[18:06:26.555]                   ...future.strategy.old <- future::plan("list")
[18:06:26.555]                   options(future.plan = NULL)
[18:06:26.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:26.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:26.555]                 }
[18:06:26.555]                 ...future.workdir <- getwd()
[18:06:26.555]             }
[18:06:26.555]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:26.555]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:26.555]         }
[18:06:26.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:26.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:26.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:26.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:26.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:26.555]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:26.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:26.555]             base::names(...future.oldOptions))
[18:06:26.555]     }
[18:06:26.555]     if (FALSE) {
[18:06:26.555]     }
[18:06:26.555]     else {
[18:06:26.555]         if (TRUE) {
[18:06:26.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:26.555]                 open = "w")
[18:06:26.555]         }
[18:06:26.555]         else {
[18:06:26.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:26.555]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:26.555]         }
[18:06:26.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:26.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:26.555]             base::sink(type = "output", split = FALSE)
[18:06:26.555]             base::close(...future.stdout)
[18:06:26.555]         }, add = TRUE)
[18:06:26.555]     }
[18:06:26.555]     ...future.frame <- base::sys.nframe()
[18:06:26.555]     ...future.conditions <- base::list()
[18:06:26.555]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:26.555]     if (FALSE) {
[18:06:26.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:26.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:26.555]     }
[18:06:26.555]     ...future.result <- base::tryCatch({
[18:06:26.555]         base::withCallingHandlers({
[18:06:26.555]             ...future.value <- base::withVisible(base::local({
[18:06:26.555]                 ...future.makeSendCondition <- base::local({
[18:06:26.555]                   sendCondition <- NULL
[18:06:26.555]                   function(frame = 1L) {
[18:06:26.555]                     if (is.function(sendCondition)) 
[18:06:26.555]                       return(sendCondition)
[18:06:26.555]                     ns <- getNamespace("parallel")
[18:06:26.555]                     if (exists("sendData", mode = "function", 
[18:06:26.555]                       envir = ns)) {
[18:06:26.555]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:26.555]                         envir = ns)
[18:06:26.555]                       envir <- sys.frame(frame)
[18:06:26.555]                       master <- NULL
[18:06:26.555]                       while (!identical(envir, .GlobalEnv) && 
[18:06:26.555]                         !identical(envir, emptyenv())) {
[18:06:26.555]                         if (exists("master", mode = "list", envir = envir, 
[18:06:26.555]                           inherits = FALSE)) {
[18:06:26.555]                           master <- get("master", mode = "list", 
[18:06:26.555]                             envir = envir, inherits = FALSE)
[18:06:26.555]                           if (inherits(master, c("SOCKnode", 
[18:06:26.555]                             "SOCK0node"))) {
[18:06:26.555]                             sendCondition <<- function(cond) {
[18:06:26.555]                               data <- list(type = "VALUE", value = cond, 
[18:06:26.555]                                 success = TRUE)
[18:06:26.555]                               parallel_sendData(master, data)
[18:06:26.555]                             }
[18:06:26.555]                             return(sendCondition)
[18:06:26.555]                           }
[18:06:26.555]                         }
[18:06:26.555]                         frame <- frame + 1L
[18:06:26.555]                         envir <- sys.frame(frame)
[18:06:26.555]                       }
[18:06:26.555]                     }
[18:06:26.555]                     sendCondition <<- function(cond) NULL
[18:06:26.555]                   }
[18:06:26.555]                 })
[18:06:26.555]                 withCallingHandlers({
[18:06:26.555]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:26.555]                 }, immediateCondition = function(cond) {
[18:06:26.555]                   sendCondition <- ...future.makeSendCondition()
[18:06:26.555]                   sendCondition(cond)
[18:06:26.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.555]                   {
[18:06:26.555]                     inherits <- base::inherits
[18:06:26.555]                     invokeRestart <- base::invokeRestart
[18:06:26.555]                     is.null <- base::is.null
[18:06:26.555]                     muffled <- FALSE
[18:06:26.555]                     if (inherits(cond, "message")) {
[18:06:26.555]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:26.555]                       if (muffled) 
[18:06:26.555]                         invokeRestart("muffleMessage")
[18:06:26.555]                     }
[18:06:26.555]                     else if (inherits(cond, "warning")) {
[18:06:26.555]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:26.555]                       if (muffled) 
[18:06:26.555]                         invokeRestart("muffleWarning")
[18:06:26.555]                     }
[18:06:26.555]                     else if (inherits(cond, "condition")) {
[18:06:26.555]                       if (!is.null(pattern)) {
[18:06:26.555]                         computeRestarts <- base::computeRestarts
[18:06:26.555]                         grepl <- base::grepl
[18:06:26.555]                         restarts <- computeRestarts(cond)
[18:06:26.555]                         for (restart in restarts) {
[18:06:26.555]                           name <- restart$name
[18:06:26.555]                           if (is.null(name)) 
[18:06:26.555]                             next
[18:06:26.555]                           if (!grepl(pattern, name)) 
[18:06:26.555]                             next
[18:06:26.555]                           invokeRestart(restart)
[18:06:26.555]                           muffled <- TRUE
[18:06:26.555]                           break
[18:06:26.555]                         }
[18:06:26.555]                       }
[18:06:26.555]                     }
[18:06:26.555]                     invisible(muffled)
[18:06:26.555]                   }
[18:06:26.555]                   muffleCondition(cond)
[18:06:26.555]                 })
[18:06:26.555]             }))
[18:06:26.555]             future::FutureResult(value = ...future.value$value, 
[18:06:26.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:26.555]                   ...future.rng), globalenv = if (FALSE) 
[18:06:26.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:26.555]                     ...future.globalenv.names))
[18:06:26.555]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:26.555]         }, condition = base::local({
[18:06:26.555]             c <- base::c
[18:06:26.555]             inherits <- base::inherits
[18:06:26.555]             invokeRestart <- base::invokeRestart
[18:06:26.555]             length <- base::length
[18:06:26.555]             list <- base::list
[18:06:26.555]             seq.int <- base::seq.int
[18:06:26.555]             signalCondition <- base::signalCondition
[18:06:26.555]             sys.calls <- base::sys.calls
[18:06:26.555]             `[[` <- base::`[[`
[18:06:26.555]             `+` <- base::`+`
[18:06:26.555]             `<<-` <- base::`<<-`
[18:06:26.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:26.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:26.555]                   3L)]
[18:06:26.555]             }
[18:06:26.555]             function(cond) {
[18:06:26.555]                 is_error <- inherits(cond, "error")
[18:06:26.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:26.555]                   NULL)
[18:06:26.555]                 if (is_error) {
[18:06:26.555]                   sessionInformation <- function() {
[18:06:26.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:26.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:26.555]                       search = base::search(), system = base::Sys.info())
[18:06:26.555]                   }
[18:06:26.555]                   ...future.conditions[[length(...future.conditions) + 
[18:06:26.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:26.555]                     cond$call), session = sessionInformation(), 
[18:06:26.555]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:26.555]                   signalCondition(cond)
[18:06:26.555]                 }
[18:06:26.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:26.555]                 "immediateCondition"))) {
[18:06:26.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:26.555]                   ...future.conditions[[length(...future.conditions) + 
[18:06:26.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:26.555]                   if (TRUE && !signal) {
[18:06:26.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.555]                     {
[18:06:26.555]                       inherits <- base::inherits
[18:06:26.555]                       invokeRestart <- base::invokeRestart
[18:06:26.555]                       is.null <- base::is.null
[18:06:26.555]                       muffled <- FALSE
[18:06:26.555]                       if (inherits(cond, "message")) {
[18:06:26.555]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:26.555]                         if (muffled) 
[18:06:26.555]                           invokeRestart("muffleMessage")
[18:06:26.555]                       }
[18:06:26.555]                       else if (inherits(cond, "warning")) {
[18:06:26.555]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:26.555]                         if (muffled) 
[18:06:26.555]                           invokeRestart("muffleWarning")
[18:06:26.555]                       }
[18:06:26.555]                       else if (inherits(cond, "condition")) {
[18:06:26.555]                         if (!is.null(pattern)) {
[18:06:26.555]                           computeRestarts <- base::computeRestarts
[18:06:26.555]                           grepl <- base::grepl
[18:06:26.555]                           restarts <- computeRestarts(cond)
[18:06:26.555]                           for (restart in restarts) {
[18:06:26.555]                             name <- restart$name
[18:06:26.555]                             if (is.null(name)) 
[18:06:26.555]                               next
[18:06:26.555]                             if (!grepl(pattern, name)) 
[18:06:26.555]                               next
[18:06:26.555]                             invokeRestart(restart)
[18:06:26.555]                             muffled <- TRUE
[18:06:26.555]                             break
[18:06:26.555]                           }
[18:06:26.555]                         }
[18:06:26.555]                       }
[18:06:26.555]                       invisible(muffled)
[18:06:26.555]                     }
[18:06:26.555]                     muffleCondition(cond, pattern = "^muffle")
[18:06:26.555]                   }
[18:06:26.555]                 }
[18:06:26.555]                 else {
[18:06:26.555]                   if (TRUE) {
[18:06:26.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.555]                     {
[18:06:26.555]                       inherits <- base::inherits
[18:06:26.555]                       invokeRestart <- base::invokeRestart
[18:06:26.555]                       is.null <- base::is.null
[18:06:26.555]                       muffled <- FALSE
[18:06:26.555]                       if (inherits(cond, "message")) {
[18:06:26.555]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:26.555]                         if (muffled) 
[18:06:26.555]                           invokeRestart("muffleMessage")
[18:06:26.555]                       }
[18:06:26.555]                       else if (inherits(cond, "warning")) {
[18:06:26.555]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:26.555]                         if (muffled) 
[18:06:26.555]                           invokeRestart("muffleWarning")
[18:06:26.555]                       }
[18:06:26.555]                       else if (inherits(cond, "condition")) {
[18:06:26.555]                         if (!is.null(pattern)) {
[18:06:26.555]                           computeRestarts <- base::computeRestarts
[18:06:26.555]                           grepl <- base::grepl
[18:06:26.555]                           restarts <- computeRestarts(cond)
[18:06:26.555]                           for (restart in restarts) {
[18:06:26.555]                             name <- restart$name
[18:06:26.555]                             if (is.null(name)) 
[18:06:26.555]                               next
[18:06:26.555]                             if (!grepl(pattern, name)) 
[18:06:26.555]                               next
[18:06:26.555]                             invokeRestart(restart)
[18:06:26.555]                             muffled <- TRUE
[18:06:26.555]                             break
[18:06:26.555]                           }
[18:06:26.555]                         }
[18:06:26.555]                       }
[18:06:26.555]                       invisible(muffled)
[18:06:26.555]                     }
[18:06:26.555]                     muffleCondition(cond, pattern = "^muffle")
[18:06:26.555]                   }
[18:06:26.555]                 }
[18:06:26.555]             }
[18:06:26.555]         }))
[18:06:26.555]     }, error = function(ex) {
[18:06:26.555]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:26.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:26.555]                 ...future.rng), started = ...future.startTime, 
[18:06:26.555]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:26.555]             version = "1.8"), class = "FutureResult")
[18:06:26.555]     }, finally = {
[18:06:26.555]         if (!identical(...future.workdir, getwd())) 
[18:06:26.555]             setwd(...future.workdir)
[18:06:26.555]         {
[18:06:26.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:26.555]                 ...future.oldOptions$nwarnings <- NULL
[18:06:26.555]             }
[18:06:26.555]             base::options(...future.oldOptions)
[18:06:26.555]             if (.Platform$OS.type == "windows") {
[18:06:26.555]                 old_names <- names(...future.oldEnvVars)
[18:06:26.555]                 envs <- base::Sys.getenv()
[18:06:26.555]                 names <- names(envs)
[18:06:26.555]                 common <- intersect(names, old_names)
[18:06:26.555]                 added <- setdiff(names, old_names)
[18:06:26.555]                 removed <- setdiff(old_names, names)
[18:06:26.555]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:26.555]                   envs[common]]
[18:06:26.555]                 NAMES <- toupper(changed)
[18:06:26.555]                 args <- list()
[18:06:26.555]                 for (kk in seq_along(NAMES)) {
[18:06:26.555]                   name <- changed[[kk]]
[18:06:26.555]                   NAME <- NAMES[[kk]]
[18:06:26.555]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.555]                     next
[18:06:26.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:26.555]                 }
[18:06:26.555]                 NAMES <- toupper(added)
[18:06:26.555]                 for (kk in seq_along(NAMES)) {
[18:06:26.555]                   name <- added[[kk]]
[18:06:26.555]                   NAME <- NAMES[[kk]]
[18:06:26.555]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.555]                     next
[18:06:26.555]                   args[[name]] <- ""
[18:06:26.555]                 }
[18:06:26.555]                 NAMES <- toupper(removed)
[18:06:26.555]                 for (kk in seq_along(NAMES)) {
[18:06:26.555]                   name <- removed[[kk]]
[18:06:26.555]                   NAME <- NAMES[[kk]]
[18:06:26.555]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.555]                     next
[18:06:26.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:26.555]                 }
[18:06:26.555]                 if (length(args) > 0) 
[18:06:26.555]                   base::do.call(base::Sys.setenv, args = args)
[18:06:26.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:26.555]             }
[18:06:26.555]             else {
[18:06:26.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:26.555]             }
[18:06:26.555]             {
[18:06:26.555]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:26.555]                   0L) {
[18:06:26.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:26.555]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:26.555]                   base::options(opts)
[18:06:26.555]                 }
[18:06:26.555]                 {
[18:06:26.555]                   {
[18:06:26.555]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:26.555]                     NULL
[18:06:26.555]                   }
[18:06:26.555]                   options(future.plan = NULL)
[18:06:26.555]                   if (is.na(NA_character_)) 
[18:06:26.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:26.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:26.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:26.555]                     .init = FALSE)
[18:06:26.555]                 }
[18:06:26.555]             }
[18:06:26.555]         }
[18:06:26.555]     })
[18:06:26.555]     if (TRUE) {
[18:06:26.555]         base::sink(type = "output", split = FALSE)
[18:06:26.555]         if (TRUE) {
[18:06:26.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:26.555]         }
[18:06:26.555]         else {
[18:06:26.555]             ...future.result["stdout"] <- base::list(NULL)
[18:06:26.555]         }
[18:06:26.555]         base::close(...future.stdout)
[18:06:26.555]         ...future.stdout <- NULL
[18:06:26.555]     }
[18:06:26.555]     ...future.result$conditions <- ...future.conditions
[18:06:26.555]     ...future.result$finished <- base::Sys.time()
[18:06:26.555]     ...future.result
[18:06:26.555] }
[18:06:26.561] MultisessionFuture started
[18:06:26.561] - Launch lazy future ... done
[18:06:26.562] run() for ‘MultisessionFuture’ ... done
[18:06:26.607] receiveMessageFromWorker() for ClusterFuture ...
[18:06:26.607] - Validating connection of MultisessionFuture
[18:06:26.608] - received message: FutureResult
[18:06:26.608] - Received FutureResult
[18:06:26.608] - Erased future from FutureRegistry
[18:06:26.609] result() for ClusterFuture ...
[18:06:26.609] - result already collected: FutureResult
[18:06:26.609] result() for ClusterFuture ... done
[18:06:26.609] signalConditions() ...
[18:06:26.610]  - include = ‘immediateCondition’
[18:06:26.610]  - exclude = 
[18:06:26.610]  - resignal = FALSE
[18:06:26.610]  - Number of conditions: 1
[18:06:26.610] signalConditions() ... done
[18:06:26.611] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:26.611] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[18:06:26.611] getGlobalsAndPackages() ...
[18:06:26.612] Searching for globals...
[18:06:26.614] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:26.615] Searching for globals ... DONE
[18:06:26.615] Resolving globals: FALSE
[18:06:26.616] 
[18:06:26.616] 
[18:06:26.616] getGlobalsAndPackages() ... DONE
[18:06:26.616] run() for ‘Future’ ...
[18:06:26.617] - state: ‘created’
[18:06:26.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:26.641] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:26.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:26.641]   - Field: ‘node’
[18:06:26.642]   - Field: ‘label’
[18:06:26.642]   - Field: ‘local’
[18:06:26.642]   - Field: ‘owner’
[18:06:26.642]   - Field: ‘envir’
[18:06:26.642]   - Field: ‘workers’
[18:06:26.643]   - Field: ‘packages’
[18:06:26.643]   - Field: ‘gc’
[18:06:26.643]   - Field: ‘conditions’
[18:06:26.643]   - Field: ‘persistent’
[18:06:26.643]   - Field: ‘expr’
[18:06:26.644]   - Field: ‘uuid’
[18:06:26.644]   - Field: ‘seed’
[18:06:26.644]   - Field: ‘version’
[18:06:26.644]   - Field: ‘result’
[18:06:26.644]   - Field: ‘asynchronous’
[18:06:26.645]   - Field: ‘calls’
[18:06:26.645]   - Field: ‘globals’
[18:06:26.645]   - Field: ‘stdout’
[18:06:26.645]   - Field: ‘earlySignal’
[18:06:26.645]   - Field: ‘lazy’
[18:06:26.646]   - Field: ‘state’
[18:06:26.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:26.646] - Launch lazy future ...
[18:06:26.647] Packages needed by the future expression (n = 0): <none>
[18:06:26.647] Packages needed by future strategies (n = 0): <none>
[18:06:26.648] {
[18:06:26.648]     {
[18:06:26.648]         {
[18:06:26.648]             ...future.startTime <- base::Sys.time()
[18:06:26.648]             {
[18:06:26.648]                 {
[18:06:26.648]                   {
[18:06:26.648]                     {
[18:06:26.648]                       base::local({
[18:06:26.648]                         has_future <- base::requireNamespace("future", 
[18:06:26.648]                           quietly = TRUE)
[18:06:26.648]                         if (has_future) {
[18:06:26.648]                           ns <- base::getNamespace("future")
[18:06:26.648]                           version <- ns[[".package"]][["version"]]
[18:06:26.648]                           if (is.null(version)) 
[18:06:26.648]                             version <- utils::packageVersion("future")
[18:06:26.648]                         }
[18:06:26.648]                         else {
[18:06:26.648]                           version <- NULL
[18:06:26.648]                         }
[18:06:26.648]                         if (!has_future || version < "1.8.0") {
[18:06:26.648]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:26.648]                             "", base::R.version$version.string), 
[18:06:26.648]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:26.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:26.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:26.648]                               "release", "version")], collapse = " "), 
[18:06:26.648]                             hostname = base::Sys.info()[["nodename"]])
[18:06:26.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:26.648]                             info)
[18:06:26.648]                           info <- base::paste(info, collapse = "; ")
[18:06:26.648]                           if (!has_future) {
[18:06:26.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:26.648]                               info)
[18:06:26.648]                           }
[18:06:26.648]                           else {
[18:06:26.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:26.648]                               info, version)
[18:06:26.648]                           }
[18:06:26.648]                           base::stop(msg)
[18:06:26.648]                         }
[18:06:26.648]                       })
[18:06:26.648]                     }
[18:06:26.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:26.648]                     base::options(mc.cores = 1L)
[18:06:26.648]                   }
[18:06:26.648]                   ...future.strategy.old <- future::plan("list")
[18:06:26.648]                   options(future.plan = NULL)
[18:06:26.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:26.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:26.648]                 }
[18:06:26.648]                 ...future.workdir <- getwd()
[18:06:26.648]             }
[18:06:26.648]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:26.648]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:26.648]         }
[18:06:26.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:26.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:26.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:26.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:26.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:26.648]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:26.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:26.648]             base::names(...future.oldOptions))
[18:06:26.648]     }
[18:06:26.648]     if (FALSE) {
[18:06:26.648]     }
[18:06:26.648]     else {
[18:06:26.648]         if (TRUE) {
[18:06:26.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:26.648]                 open = "w")
[18:06:26.648]         }
[18:06:26.648]         else {
[18:06:26.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:26.648]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:26.648]         }
[18:06:26.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:26.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:26.648]             base::sink(type = "output", split = FALSE)
[18:06:26.648]             base::close(...future.stdout)
[18:06:26.648]         }, add = TRUE)
[18:06:26.648]     }
[18:06:26.648]     ...future.frame <- base::sys.nframe()
[18:06:26.648]     ...future.conditions <- base::list()
[18:06:26.648]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:26.648]     if (FALSE) {
[18:06:26.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:26.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:26.648]     }
[18:06:26.648]     ...future.result <- base::tryCatch({
[18:06:26.648]         base::withCallingHandlers({
[18:06:26.648]             ...future.value <- base::withVisible(base::local({
[18:06:26.648]                 ...future.makeSendCondition <- base::local({
[18:06:26.648]                   sendCondition <- NULL
[18:06:26.648]                   function(frame = 1L) {
[18:06:26.648]                     if (is.function(sendCondition)) 
[18:06:26.648]                       return(sendCondition)
[18:06:26.648]                     ns <- getNamespace("parallel")
[18:06:26.648]                     if (exists("sendData", mode = "function", 
[18:06:26.648]                       envir = ns)) {
[18:06:26.648]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:26.648]                         envir = ns)
[18:06:26.648]                       envir <- sys.frame(frame)
[18:06:26.648]                       master <- NULL
[18:06:26.648]                       while (!identical(envir, .GlobalEnv) && 
[18:06:26.648]                         !identical(envir, emptyenv())) {
[18:06:26.648]                         if (exists("master", mode = "list", envir = envir, 
[18:06:26.648]                           inherits = FALSE)) {
[18:06:26.648]                           master <- get("master", mode = "list", 
[18:06:26.648]                             envir = envir, inherits = FALSE)
[18:06:26.648]                           if (inherits(master, c("SOCKnode", 
[18:06:26.648]                             "SOCK0node"))) {
[18:06:26.648]                             sendCondition <<- function(cond) {
[18:06:26.648]                               data <- list(type = "VALUE", value = cond, 
[18:06:26.648]                                 success = TRUE)
[18:06:26.648]                               parallel_sendData(master, data)
[18:06:26.648]                             }
[18:06:26.648]                             return(sendCondition)
[18:06:26.648]                           }
[18:06:26.648]                         }
[18:06:26.648]                         frame <- frame + 1L
[18:06:26.648]                         envir <- sys.frame(frame)
[18:06:26.648]                       }
[18:06:26.648]                     }
[18:06:26.648]                     sendCondition <<- function(cond) NULL
[18:06:26.648]                   }
[18:06:26.648]                 })
[18:06:26.648]                 withCallingHandlers({
[18:06:26.648]                   {
[18:06:26.648]                     Sys.sleep(0.5)
[18:06:26.648]                     list(a = 1, b = 42L)
[18:06:26.648]                   }
[18:06:26.648]                 }, immediateCondition = function(cond) {
[18:06:26.648]                   sendCondition <- ...future.makeSendCondition()
[18:06:26.648]                   sendCondition(cond)
[18:06:26.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.648]                   {
[18:06:26.648]                     inherits <- base::inherits
[18:06:26.648]                     invokeRestart <- base::invokeRestart
[18:06:26.648]                     is.null <- base::is.null
[18:06:26.648]                     muffled <- FALSE
[18:06:26.648]                     if (inherits(cond, "message")) {
[18:06:26.648]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:26.648]                       if (muffled) 
[18:06:26.648]                         invokeRestart("muffleMessage")
[18:06:26.648]                     }
[18:06:26.648]                     else if (inherits(cond, "warning")) {
[18:06:26.648]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:26.648]                       if (muffled) 
[18:06:26.648]                         invokeRestart("muffleWarning")
[18:06:26.648]                     }
[18:06:26.648]                     else if (inherits(cond, "condition")) {
[18:06:26.648]                       if (!is.null(pattern)) {
[18:06:26.648]                         computeRestarts <- base::computeRestarts
[18:06:26.648]                         grepl <- base::grepl
[18:06:26.648]                         restarts <- computeRestarts(cond)
[18:06:26.648]                         for (restart in restarts) {
[18:06:26.648]                           name <- restart$name
[18:06:26.648]                           if (is.null(name)) 
[18:06:26.648]                             next
[18:06:26.648]                           if (!grepl(pattern, name)) 
[18:06:26.648]                             next
[18:06:26.648]                           invokeRestart(restart)
[18:06:26.648]                           muffled <- TRUE
[18:06:26.648]                           break
[18:06:26.648]                         }
[18:06:26.648]                       }
[18:06:26.648]                     }
[18:06:26.648]                     invisible(muffled)
[18:06:26.648]                   }
[18:06:26.648]                   muffleCondition(cond)
[18:06:26.648]                 })
[18:06:26.648]             }))
[18:06:26.648]             future::FutureResult(value = ...future.value$value, 
[18:06:26.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:26.648]                   ...future.rng), globalenv = if (FALSE) 
[18:06:26.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:26.648]                     ...future.globalenv.names))
[18:06:26.648]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:26.648]         }, condition = base::local({
[18:06:26.648]             c <- base::c
[18:06:26.648]             inherits <- base::inherits
[18:06:26.648]             invokeRestart <- base::invokeRestart
[18:06:26.648]             length <- base::length
[18:06:26.648]             list <- base::list
[18:06:26.648]             seq.int <- base::seq.int
[18:06:26.648]             signalCondition <- base::signalCondition
[18:06:26.648]             sys.calls <- base::sys.calls
[18:06:26.648]             `[[` <- base::`[[`
[18:06:26.648]             `+` <- base::`+`
[18:06:26.648]             `<<-` <- base::`<<-`
[18:06:26.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:26.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:26.648]                   3L)]
[18:06:26.648]             }
[18:06:26.648]             function(cond) {
[18:06:26.648]                 is_error <- inherits(cond, "error")
[18:06:26.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:26.648]                   NULL)
[18:06:26.648]                 if (is_error) {
[18:06:26.648]                   sessionInformation <- function() {
[18:06:26.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:26.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:26.648]                       search = base::search(), system = base::Sys.info())
[18:06:26.648]                   }
[18:06:26.648]                   ...future.conditions[[length(...future.conditions) + 
[18:06:26.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:26.648]                     cond$call), session = sessionInformation(), 
[18:06:26.648]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:26.648]                   signalCondition(cond)
[18:06:26.648]                 }
[18:06:26.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:26.648]                 "immediateCondition"))) {
[18:06:26.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:26.648]                   ...future.conditions[[length(...future.conditions) + 
[18:06:26.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:26.648]                   if (TRUE && !signal) {
[18:06:26.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.648]                     {
[18:06:26.648]                       inherits <- base::inherits
[18:06:26.648]                       invokeRestart <- base::invokeRestart
[18:06:26.648]                       is.null <- base::is.null
[18:06:26.648]                       muffled <- FALSE
[18:06:26.648]                       if (inherits(cond, "message")) {
[18:06:26.648]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:26.648]                         if (muffled) 
[18:06:26.648]                           invokeRestart("muffleMessage")
[18:06:26.648]                       }
[18:06:26.648]                       else if (inherits(cond, "warning")) {
[18:06:26.648]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:26.648]                         if (muffled) 
[18:06:26.648]                           invokeRestart("muffleWarning")
[18:06:26.648]                       }
[18:06:26.648]                       else if (inherits(cond, "condition")) {
[18:06:26.648]                         if (!is.null(pattern)) {
[18:06:26.648]                           computeRestarts <- base::computeRestarts
[18:06:26.648]                           grepl <- base::grepl
[18:06:26.648]                           restarts <- computeRestarts(cond)
[18:06:26.648]                           for (restart in restarts) {
[18:06:26.648]                             name <- restart$name
[18:06:26.648]                             if (is.null(name)) 
[18:06:26.648]                               next
[18:06:26.648]                             if (!grepl(pattern, name)) 
[18:06:26.648]                               next
[18:06:26.648]                             invokeRestart(restart)
[18:06:26.648]                             muffled <- TRUE
[18:06:26.648]                             break
[18:06:26.648]                           }
[18:06:26.648]                         }
[18:06:26.648]                       }
[18:06:26.648]                       invisible(muffled)
[18:06:26.648]                     }
[18:06:26.648]                     muffleCondition(cond, pattern = "^muffle")
[18:06:26.648]                   }
[18:06:26.648]                 }
[18:06:26.648]                 else {
[18:06:26.648]                   if (TRUE) {
[18:06:26.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:26.648]                     {
[18:06:26.648]                       inherits <- base::inherits
[18:06:26.648]                       invokeRestart <- base::invokeRestart
[18:06:26.648]                       is.null <- base::is.null
[18:06:26.648]                       muffled <- FALSE
[18:06:26.648]                       if (inherits(cond, "message")) {
[18:06:26.648]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:26.648]                         if (muffled) 
[18:06:26.648]                           invokeRestart("muffleMessage")
[18:06:26.648]                       }
[18:06:26.648]                       else if (inherits(cond, "warning")) {
[18:06:26.648]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:26.648]                         if (muffled) 
[18:06:26.648]                           invokeRestart("muffleWarning")
[18:06:26.648]                       }
[18:06:26.648]                       else if (inherits(cond, "condition")) {
[18:06:26.648]                         if (!is.null(pattern)) {
[18:06:26.648]                           computeRestarts <- base::computeRestarts
[18:06:26.648]                           grepl <- base::grepl
[18:06:26.648]                           restarts <- computeRestarts(cond)
[18:06:26.648]                           for (restart in restarts) {
[18:06:26.648]                             name <- restart$name
[18:06:26.648]                             if (is.null(name)) 
[18:06:26.648]                               next
[18:06:26.648]                             if (!grepl(pattern, name)) 
[18:06:26.648]                               next
[18:06:26.648]                             invokeRestart(restart)
[18:06:26.648]                             muffled <- TRUE
[18:06:26.648]                             break
[18:06:26.648]                           }
[18:06:26.648]                         }
[18:06:26.648]                       }
[18:06:26.648]                       invisible(muffled)
[18:06:26.648]                     }
[18:06:26.648]                     muffleCondition(cond, pattern = "^muffle")
[18:06:26.648]                   }
[18:06:26.648]                 }
[18:06:26.648]             }
[18:06:26.648]         }))
[18:06:26.648]     }, error = function(ex) {
[18:06:26.648]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:26.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:26.648]                 ...future.rng), started = ...future.startTime, 
[18:06:26.648]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:26.648]             version = "1.8"), class = "FutureResult")
[18:06:26.648]     }, finally = {
[18:06:26.648]         if (!identical(...future.workdir, getwd())) 
[18:06:26.648]             setwd(...future.workdir)
[18:06:26.648]         {
[18:06:26.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:26.648]                 ...future.oldOptions$nwarnings <- NULL
[18:06:26.648]             }
[18:06:26.648]             base::options(...future.oldOptions)
[18:06:26.648]             if (.Platform$OS.type == "windows") {
[18:06:26.648]                 old_names <- names(...future.oldEnvVars)
[18:06:26.648]                 envs <- base::Sys.getenv()
[18:06:26.648]                 names <- names(envs)
[18:06:26.648]                 common <- intersect(names, old_names)
[18:06:26.648]                 added <- setdiff(names, old_names)
[18:06:26.648]                 removed <- setdiff(old_names, names)
[18:06:26.648]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:26.648]                   envs[common]]
[18:06:26.648]                 NAMES <- toupper(changed)
[18:06:26.648]                 args <- list()
[18:06:26.648]                 for (kk in seq_along(NAMES)) {
[18:06:26.648]                   name <- changed[[kk]]
[18:06:26.648]                   NAME <- NAMES[[kk]]
[18:06:26.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.648]                     next
[18:06:26.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:26.648]                 }
[18:06:26.648]                 NAMES <- toupper(added)
[18:06:26.648]                 for (kk in seq_along(NAMES)) {
[18:06:26.648]                   name <- added[[kk]]
[18:06:26.648]                   NAME <- NAMES[[kk]]
[18:06:26.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.648]                     next
[18:06:26.648]                   args[[name]] <- ""
[18:06:26.648]                 }
[18:06:26.648]                 NAMES <- toupper(removed)
[18:06:26.648]                 for (kk in seq_along(NAMES)) {
[18:06:26.648]                   name <- removed[[kk]]
[18:06:26.648]                   NAME <- NAMES[[kk]]
[18:06:26.648]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:26.648]                     next
[18:06:26.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:26.648]                 }
[18:06:26.648]                 if (length(args) > 0) 
[18:06:26.648]                   base::do.call(base::Sys.setenv, args = args)
[18:06:26.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:26.648]             }
[18:06:26.648]             else {
[18:06:26.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:26.648]             }
[18:06:26.648]             {
[18:06:26.648]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:26.648]                   0L) {
[18:06:26.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:26.648]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:26.648]                   base::options(opts)
[18:06:26.648]                 }
[18:06:26.648]                 {
[18:06:26.648]                   {
[18:06:26.648]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:26.648]                     NULL
[18:06:26.648]                   }
[18:06:26.648]                   options(future.plan = NULL)
[18:06:26.648]                   if (is.na(NA_character_)) 
[18:06:26.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:26.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:26.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:26.648]                     .init = FALSE)
[18:06:26.648]                 }
[18:06:26.648]             }
[18:06:26.648]         }
[18:06:26.648]     })
[18:06:26.648]     if (TRUE) {
[18:06:26.648]         base::sink(type = "output", split = FALSE)
[18:06:26.648]         if (TRUE) {
[18:06:26.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:26.648]         }
[18:06:26.648]         else {
[18:06:26.648]             ...future.result["stdout"] <- base::list(NULL)
[18:06:26.648]         }
[18:06:26.648]         base::close(...future.stdout)
[18:06:26.648]         ...future.stdout <- NULL
[18:06:26.648]     }
[18:06:26.648]     ...future.result$conditions <- ...future.conditions
[18:06:26.648]     ...future.result$finished <- base::Sys.time()
[18:06:26.648]     ...future.result
[18:06:26.648] }
[18:06:26.654] MultisessionFuture started
[18:06:26.654] - Launch lazy future ... done
[18:06:26.654] run() for ‘MultisessionFuture’ ... done
[18:06:27.198] receiveMessageFromWorker() for ClusterFuture ...
[18:06:27.199] - Validating connection of MultisessionFuture
[18:06:27.201] - received message: FutureResult
[18:06:27.201] - Received FutureResult
[18:06:27.202] - Erased future from FutureRegistry
[18:06:27.202] result() for ClusterFuture ...
[18:06:27.202] - result already collected: FutureResult
[18:06:27.203] result() for ClusterFuture ... done
[18:06:27.203] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:27.203] resolve() on list ...
[18:06:27.204]  recursive: Inf
[18:06:27.204]  length: 2
[18:06:27.204]  elements: ‘a’, ‘b’
[18:06:27.205]  length: 1 (resolved future 1)
[18:06:27.205]  length: 0 (resolved future 2)
[18:06:27.205] resolve() on list ... DONE
[18:06:27.206] A MultisessionFuture was resolved (and resolved itself)
[18:06:27.206] getGlobalsAndPackages() ...
[18:06:27.206] Searching for globals...
[18:06:27.210] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[18:06:27.210] Searching for globals ... DONE
[18:06:27.210] Resolving globals: FALSE
[18:06:27.211] 
[18:06:27.212] 
[18:06:27.212] getGlobalsAndPackages() ... DONE
[18:06:27.213] run() for ‘Future’ ...
[18:06:27.213] - state: ‘created’
[18:06:27.214] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:27.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:27.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:27.246]   - Field: ‘node’
[18:06:27.246]   - Field: ‘label’
[18:06:27.246]   - Field: ‘local’
[18:06:27.246]   - Field: ‘owner’
[18:06:27.247]   - Field: ‘envir’
[18:06:27.247]   - Field: ‘workers’
[18:06:27.247]   - Field: ‘packages’
[18:06:27.248]   - Field: ‘gc’
[18:06:27.248]   - Field: ‘conditions’
[18:06:27.248]   - Field: ‘persistent’
[18:06:27.248]   - Field: ‘expr’
[18:06:27.249]   - Field: ‘uuid’
[18:06:27.249]   - Field: ‘seed’
[18:06:27.249]   - Field: ‘version’
[18:06:27.249]   - Field: ‘result’
[18:06:27.249]   - Field: ‘asynchronous’
[18:06:27.250]   - Field: ‘calls’
[18:06:27.250]   - Field: ‘globals’
[18:06:27.250]   - Field: ‘stdout’
[18:06:27.250]   - Field: ‘earlySignal’
[18:06:27.251]   - Field: ‘lazy’
[18:06:27.251]   - Field: ‘state’
[18:06:27.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:27.252] - Launch lazy future ...
[18:06:27.252] Packages needed by the future expression (n = 0): <none>
[18:06:27.252] Packages needed by future strategies (n = 0): <none>
[18:06:27.254] {
[18:06:27.254]     {
[18:06:27.254]         {
[18:06:27.254]             ...future.startTime <- base::Sys.time()
[18:06:27.254]             {
[18:06:27.254]                 {
[18:06:27.254]                   {
[18:06:27.254]                     {
[18:06:27.254]                       base::local({
[18:06:27.254]                         has_future <- base::requireNamespace("future", 
[18:06:27.254]                           quietly = TRUE)
[18:06:27.254]                         if (has_future) {
[18:06:27.254]                           ns <- base::getNamespace("future")
[18:06:27.254]                           version <- ns[[".package"]][["version"]]
[18:06:27.254]                           if (is.null(version)) 
[18:06:27.254]                             version <- utils::packageVersion("future")
[18:06:27.254]                         }
[18:06:27.254]                         else {
[18:06:27.254]                           version <- NULL
[18:06:27.254]                         }
[18:06:27.254]                         if (!has_future || version < "1.8.0") {
[18:06:27.254]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:27.254]                             "", base::R.version$version.string), 
[18:06:27.254]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:27.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:27.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:27.254]                               "release", "version")], collapse = " "), 
[18:06:27.254]                             hostname = base::Sys.info()[["nodename"]])
[18:06:27.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:27.254]                             info)
[18:06:27.254]                           info <- base::paste(info, collapse = "; ")
[18:06:27.254]                           if (!has_future) {
[18:06:27.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:27.254]                               info)
[18:06:27.254]                           }
[18:06:27.254]                           else {
[18:06:27.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:27.254]                               info, version)
[18:06:27.254]                           }
[18:06:27.254]                           base::stop(msg)
[18:06:27.254]                         }
[18:06:27.254]                       })
[18:06:27.254]                     }
[18:06:27.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:27.254]                     base::options(mc.cores = 1L)
[18:06:27.254]                   }
[18:06:27.254]                   ...future.strategy.old <- future::plan("list")
[18:06:27.254]                   options(future.plan = NULL)
[18:06:27.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:27.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:27.254]                 }
[18:06:27.254]                 ...future.workdir <- getwd()
[18:06:27.254]             }
[18:06:27.254]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:27.254]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:27.254]         }
[18:06:27.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:27.254]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:27.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:27.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:27.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:27.254]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:27.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:27.254]             base::names(...future.oldOptions))
[18:06:27.254]     }
[18:06:27.254]     if (FALSE) {
[18:06:27.254]     }
[18:06:27.254]     else {
[18:06:27.254]         if (TRUE) {
[18:06:27.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:27.254]                 open = "w")
[18:06:27.254]         }
[18:06:27.254]         else {
[18:06:27.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:27.254]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:27.254]         }
[18:06:27.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:27.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:27.254]             base::sink(type = "output", split = FALSE)
[18:06:27.254]             base::close(...future.stdout)
[18:06:27.254]         }, add = TRUE)
[18:06:27.254]     }
[18:06:27.254]     ...future.frame <- base::sys.nframe()
[18:06:27.254]     ...future.conditions <- base::list()
[18:06:27.254]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:27.254]     if (FALSE) {
[18:06:27.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:27.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:27.254]     }
[18:06:27.254]     ...future.result <- base::tryCatch({
[18:06:27.254]         base::withCallingHandlers({
[18:06:27.254]             ...future.value <- base::withVisible(base::local({
[18:06:27.254]                 ...future.makeSendCondition <- base::local({
[18:06:27.254]                   sendCondition <- NULL
[18:06:27.254]                   function(frame = 1L) {
[18:06:27.254]                     if (is.function(sendCondition)) 
[18:06:27.254]                       return(sendCondition)
[18:06:27.254]                     ns <- getNamespace("parallel")
[18:06:27.254]                     if (exists("sendData", mode = "function", 
[18:06:27.254]                       envir = ns)) {
[18:06:27.254]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:27.254]                         envir = ns)
[18:06:27.254]                       envir <- sys.frame(frame)
[18:06:27.254]                       master <- NULL
[18:06:27.254]                       while (!identical(envir, .GlobalEnv) && 
[18:06:27.254]                         !identical(envir, emptyenv())) {
[18:06:27.254]                         if (exists("master", mode = "list", envir = envir, 
[18:06:27.254]                           inherits = FALSE)) {
[18:06:27.254]                           master <- get("master", mode = "list", 
[18:06:27.254]                             envir = envir, inherits = FALSE)
[18:06:27.254]                           if (inherits(master, c("SOCKnode", 
[18:06:27.254]                             "SOCK0node"))) {
[18:06:27.254]                             sendCondition <<- function(cond) {
[18:06:27.254]                               data <- list(type = "VALUE", value = cond, 
[18:06:27.254]                                 success = TRUE)
[18:06:27.254]                               parallel_sendData(master, data)
[18:06:27.254]                             }
[18:06:27.254]                             return(sendCondition)
[18:06:27.254]                           }
[18:06:27.254]                         }
[18:06:27.254]                         frame <- frame + 1L
[18:06:27.254]                         envir <- sys.frame(frame)
[18:06:27.254]                       }
[18:06:27.254]                     }
[18:06:27.254]                     sendCondition <<- function(cond) NULL
[18:06:27.254]                   }
[18:06:27.254]                 })
[18:06:27.254]                 withCallingHandlers({
[18:06:27.254]                   {
[18:06:27.254]                     Sys.sleep(0.5)
[18:06:27.254]                     list(a = 1, b = 42L)
[18:06:27.254]                   }
[18:06:27.254]                 }, immediateCondition = function(cond) {
[18:06:27.254]                   sendCondition <- ...future.makeSendCondition()
[18:06:27.254]                   sendCondition(cond)
[18:06:27.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.254]                   {
[18:06:27.254]                     inherits <- base::inherits
[18:06:27.254]                     invokeRestart <- base::invokeRestart
[18:06:27.254]                     is.null <- base::is.null
[18:06:27.254]                     muffled <- FALSE
[18:06:27.254]                     if (inherits(cond, "message")) {
[18:06:27.254]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:27.254]                       if (muffled) 
[18:06:27.254]                         invokeRestart("muffleMessage")
[18:06:27.254]                     }
[18:06:27.254]                     else if (inherits(cond, "warning")) {
[18:06:27.254]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:27.254]                       if (muffled) 
[18:06:27.254]                         invokeRestart("muffleWarning")
[18:06:27.254]                     }
[18:06:27.254]                     else if (inherits(cond, "condition")) {
[18:06:27.254]                       if (!is.null(pattern)) {
[18:06:27.254]                         computeRestarts <- base::computeRestarts
[18:06:27.254]                         grepl <- base::grepl
[18:06:27.254]                         restarts <- computeRestarts(cond)
[18:06:27.254]                         for (restart in restarts) {
[18:06:27.254]                           name <- restart$name
[18:06:27.254]                           if (is.null(name)) 
[18:06:27.254]                             next
[18:06:27.254]                           if (!grepl(pattern, name)) 
[18:06:27.254]                             next
[18:06:27.254]                           invokeRestart(restart)
[18:06:27.254]                           muffled <- TRUE
[18:06:27.254]                           break
[18:06:27.254]                         }
[18:06:27.254]                       }
[18:06:27.254]                     }
[18:06:27.254]                     invisible(muffled)
[18:06:27.254]                   }
[18:06:27.254]                   muffleCondition(cond)
[18:06:27.254]                 })
[18:06:27.254]             }))
[18:06:27.254]             future::FutureResult(value = ...future.value$value, 
[18:06:27.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:27.254]                   ...future.rng), globalenv = if (FALSE) 
[18:06:27.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:27.254]                     ...future.globalenv.names))
[18:06:27.254]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:27.254]         }, condition = base::local({
[18:06:27.254]             c <- base::c
[18:06:27.254]             inherits <- base::inherits
[18:06:27.254]             invokeRestart <- base::invokeRestart
[18:06:27.254]             length <- base::length
[18:06:27.254]             list <- base::list
[18:06:27.254]             seq.int <- base::seq.int
[18:06:27.254]             signalCondition <- base::signalCondition
[18:06:27.254]             sys.calls <- base::sys.calls
[18:06:27.254]             `[[` <- base::`[[`
[18:06:27.254]             `+` <- base::`+`
[18:06:27.254]             `<<-` <- base::`<<-`
[18:06:27.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:27.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:27.254]                   3L)]
[18:06:27.254]             }
[18:06:27.254]             function(cond) {
[18:06:27.254]                 is_error <- inherits(cond, "error")
[18:06:27.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:27.254]                   NULL)
[18:06:27.254]                 if (is_error) {
[18:06:27.254]                   sessionInformation <- function() {
[18:06:27.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:27.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:27.254]                       search = base::search(), system = base::Sys.info())
[18:06:27.254]                   }
[18:06:27.254]                   ...future.conditions[[length(...future.conditions) + 
[18:06:27.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:27.254]                     cond$call), session = sessionInformation(), 
[18:06:27.254]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:27.254]                   signalCondition(cond)
[18:06:27.254]                 }
[18:06:27.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:27.254]                 "immediateCondition"))) {
[18:06:27.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:27.254]                   ...future.conditions[[length(...future.conditions) + 
[18:06:27.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:27.254]                   if (TRUE && !signal) {
[18:06:27.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.254]                     {
[18:06:27.254]                       inherits <- base::inherits
[18:06:27.254]                       invokeRestart <- base::invokeRestart
[18:06:27.254]                       is.null <- base::is.null
[18:06:27.254]                       muffled <- FALSE
[18:06:27.254]                       if (inherits(cond, "message")) {
[18:06:27.254]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:27.254]                         if (muffled) 
[18:06:27.254]                           invokeRestart("muffleMessage")
[18:06:27.254]                       }
[18:06:27.254]                       else if (inherits(cond, "warning")) {
[18:06:27.254]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:27.254]                         if (muffled) 
[18:06:27.254]                           invokeRestart("muffleWarning")
[18:06:27.254]                       }
[18:06:27.254]                       else if (inherits(cond, "condition")) {
[18:06:27.254]                         if (!is.null(pattern)) {
[18:06:27.254]                           computeRestarts <- base::computeRestarts
[18:06:27.254]                           grepl <- base::grepl
[18:06:27.254]                           restarts <- computeRestarts(cond)
[18:06:27.254]                           for (restart in restarts) {
[18:06:27.254]                             name <- restart$name
[18:06:27.254]                             if (is.null(name)) 
[18:06:27.254]                               next
[18:06:27.254]                             if (!grepl(pattern, name)) 
[18:06:27.254]                               next
[18:06:27.254]                             invokeRestart(restart)
[18:06:27.254]                             muffled <- TRUE
[18:06:27.254]                             break
[18:06:27.254]                           }
[18:06:27.254]                         }
[18:06:27.254]                       }
[18:06:27.254]                       invisible(muffled)
[18:06:27.254]                     }
[18:06:27.254]                     muffleCondition(cond, pattern = "^muffle")
[18:06:27.254]                   }
[18:06:27.254]                 }
[18:06:27.254]                 else {
[18:06:27.254]                   if (TRUE) {
[18:06:27.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.254]                     {
[18:06:27.254]                       inherits <- base::inherits
[18:06:27.254]                       invokeRestart <- base::invokeRestart
[18:06:27.254]                       is.null <- base::is.null
[18:06:27.254]                       muffled <- FALSE
[18:06:27.254]                       if (inherits(cond, "message")) {
[18:06:27.254]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:27.254]                         if (muffled) 
[18:06:27.254]                           invokeRestart("muffleMessage")
[18:06:27.254]                       }
[18:06:27.254]                       else if (inherits(cond, "warning")) {
[18:06:27.254]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:27.254]                         if (muffled) 
[18:06:27.254]                           invokeRestart("muffleWarning")
[18:06:27.254]                       }
[18:06:27.254]                       else if (inherits(cond, "condition")) {
[18:06:27.254]                         if (!is.null(pattern)) {
[18:06:27.254]                           computeRestarts <- base::computeRestarts
[18:06:27.254]                           grepl <- base::grepl
[18:06:27.254]                           restarts <- computeRestarts(cond)
[18:06:27.254]                           for (restart in restarts) {
[18:06:27.254]                             name <- restart$name
[18:06:27.254]                             if (is.null(name)) 
[18:06:27.254]                               next
[18:06:27.254]                             if (!grepl(pattern, name)) 
[18:06:27.254]                               next
[18:06:27.254]                             invokeRestart(restart)
[18:06:27.254]                             muffled <- TRUE
[18:06:27.254]                             break
[18:06:27.254]                           }
[18:06:27.254]                         }
[18:06:27.254]                       }
[18:06:27.254]                       invisible(muffled)
[18:06:27.254]                     }
[18:06:27.254]                     muffleCondition(cond, pattern = "^muffle")
[18:06:27.254]                   }
[18:06:27.254]                 }
[18:06:27.254]             }
[18:06:27.254]         }))
[18:06:27.254]     }, error = function(ex) {
[18:06:27.254]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:27.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:27.254]                 ...future.rng), started = ...future.startTime, 
[18:06:27.254]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:27.254]             version = "1.8"), class = "FutureResult")
[18:06:27.254]     }, finally = {
[18:06:27.254]         if (!identical(...future.workdir, getwd())) 
[18:06:27.254]             setwd(...future.workdir)
[18:06:27.254]         {
[18:06:27.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:27.254]                 ...future.oldOptions$nwarnings <- NULL
[18:06:27.254]             }
[18:06:27.254]             base::options(...future.oldOptions)
[18:06:27.254]             if (.Platform$OS.type == "windows") {
[18:06:27.254]                 old_names <- names(...future.oldEnvVars)
[18:06:27.254]                 envs <- base::Sys.getenv()
[18:06:27.254]                 names <- names(envs)
[18:06:27.254]                 common <- intersect(names, old_names)
[18:06:27.254]                 added <- setdiff(names, old_names)
[18:06:27.254]                 removed <- setdiff(old_names, names)
[18:06:27.254]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:27.254]                   envs[common]]
[18:06:27.254]                 NAMES <- toupper(changed)
[18:06:27.254]                 args <- list()
[18:06:27.254]                 for (kk in seq_along(NAMES)) {
[18:06:27.254]                   name <- changed[[kk]]
[18:06:27.254]                   NAME <- NAMES[[kk]]
[18:06:27.254]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.254]                     next
[18:06:27.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:27.254]                 }
[18:06:27.254]                 NAMES <- toupper(added)
[18:06:27.254]                 for (kk in seq_along(NAMES)) {
[18:06:27.254]                   name <- added[[kk]]
[18:06:27.254]                   NAME <- NAMES[[kk]]
[18:06:27.254]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.254]                     next
[18:06:27.254]                   args[[name]] <- ""
[18:06:27.254]                 }
[18:06:27.254]                 NAMES <- toupper(removed)
[18:06:27.254]                 for (kk in seq_along(NAMES)) {
[18:06:27.254]                   name <- removed[[kk]]
[18:06:27.254]                   NAME <- NAMES[[kk]]
[18:06:27.254]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.254]                     next
[18:06:27.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:27.254]                 }
[18:06:27.254]                 if (length(args) > 0) 
[18:06:27.254]                   base::do.call(base::Sys.setenv, args = args)
[18:06:27.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:27.254]             }
[18:06:27.254]             else {
[18:06:27.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:27.254]             }
[18:06:27.254]             {
[18:06:27.254]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:27.254]                   0L) {
[18:06:27.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:27.254]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:27.254]                   base::options(opts)
[18:06:27.254]                 }
[18:06:27.254]                 {
[18:06:27.254]                   {
[18:06:27.254]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:27.254]                     NULL
[18:06:27.254]                   }
[18:06:27.254]                   options(future.plan = NULL)
[18:06:27.254]                   if (is.na(NA_character_)) 
[18:06:27.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:27.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:27.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:27.254]                     .init = FALSE)
[18:06:27.254]                 }
[18:06:27.254]             }
[18:06:27.254]         }
[18:06:27.254]     })
[18:06:27.254]     if (TRUE) {
[18:06:27.254]         base::sink(type = "output", split = FALSE)
[18:06:27.254]         if (TRUE) {
[18:06:27.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:27.254]         }
[18:06:27.254]         else {
[18:06:27.254]             ...future.result["stdout"] <- base::list(NULL)
[18:06:27.254]         }
[18:06:27.254]         base::close(...future.stdout)
[18:06:27.254]         ...future.stdout <- NULL
[18:06:27.254]     }
[18:06:27.254]     ...future.result$conditions <- ...future.conditions
[18:06:27.254]     ...future.result$finished <- base::Sys.time()
[18:06:27.254]     ...future.result
[18:06:27.254] }
[18:06:27.261] MultisessionFuture started
[18:06:27.261] - Launch lazy future ... done
[18:06:27.261] run() for ‘MultisessionFuture’ ... done
[18:06:27.805] receiveMessageFromWorker() for ClusterFuture ...
[18:06:27.806] - Validating connection of MultisessionFuture
[18:06:27.806] - received message: FutureResult
[18:06:27.807] - Received FutureResult
[18:06:27.807] - Erased future from FutureRegistry
[18:06:27.807] result() for ClusterFuture ...
[18:06:27.808] - result already collected: FutureResult
[18:06:27.808] result() for ClusterFuture ... done
[18:06:27.808] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:27.809] resolve() on list ...
[18:06:27.809]  recursive: Inf
[18:06:27.809]  length: 2
[18:06:27.810]  elements: ‘a’, ‘b’
[18:06:27.810]  length: 1 (resolved future 1)
[18:06:27.810]  length: 0 (resolved future 2)
[18:06:27.811] resolve() on list ... DONE
[18:06:27.811] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[18:06:27.811] getGlobalsAndPackages() ...
[18:06:27.812] Searching for globals...
[18:06:27.814] - globals found: [2] ‘list’, ‘stop’
[18:06:27.814] Searching for globals ... DONE
[18:06:27.815] Resolving globals: FALSE
[18:06:27.816] 
[18:06:27.816] 
[18:06:27.816] getGlobalsAndPackages() ... DONE
[18:06:27.817] run() for ‘Future’ ...
[18:06:27.818] - state: ‘created’
[18:06:27.818] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:27.844] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:27.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:27.844]   - Field: ‘node’
[18:06:27.845]   - Field: ‘label’
[18:06:27.845]   - Field: ‘local’
[18:06:27.845]   - Field: ‘owner’
[18:06:27.845]   - Field: ‘envir’
[18:06:27.846]   - Field: ‘workers’
[18:06:27.846]   - Field: ‘packages’
[18:06:27.846]   - Field: ‘gc’
[18:06:27.846]   - Field: ‘conditions’
[18:06:27.846]   - Field: ‘persistent’
[18:06:27.847]   - Field: ‘expr’
[18:06:27.847]   - Field: ‘uuid’
[18:06:27.847]   - Field: ‘seed’
[18:06:27.847]   - Field: ‘version’
[18:06:27.847]   - Field: ‘result’
[18:06:27.848]   - Field: ‘asynchronous’
[18:06:27.848]   - Field: ‘calls’
[18:06:27.848]   - Field: ‘globals’
[18:06:27.848]   - Field: ‘stdout’
[18:06:27.848]   - Field: ‘earlySignal’
[18:06:27.848]   - Field: ‘lazy’
[18:06:27.849]   - Field: ‘state’
[18:06:27.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:27.852] - Launch lazy future ...
[18:06:27.853] Packages needed by the future expression (n = 0): <none>
[18:06:27.853] Packages needed by future strategies (n = 0): <none>
[18:06:27.854] {
[18:06:27.854]     {
[18:06:27.854]         {
[18:06:27.854]             ...future.startTime <- base::Sys.time()
[18:06:27.854]             {
[18:06:27.854]                 {
[18:06:27.854]                   {
[18:06:27.854]                     {
[18:06:27.854]                       base::local({
[18:06:27.854]                         has_future <- base::requireNamespace("future", 
[18:06:27.854]                           quietly = TRUE)
[18:06:27.854]                         if (has_future) {
[18:06:27.854]                           ns <- base::getNamespace("future")
[18:06:27.854]                           version <- ns[[".package"]][["version"]]
[18:06:27.854]                           if (is.null(version)) 
[18:06:27.854]                             version <- utils::packageVersion("future")
[18:06:27.854]                         }
[18:06:27.854]                         else {
[18:06:27.854]                           version <- NULL
[18:06:27.854]                         }
[18:06:27.854]                         if (!has_future || version < "1.8.0") {
[18:06:27.854]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:27.854]                             "", base::R.version$version.string), 
[18:06:27.854]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:27.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:27.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:27.854]                               "release", "version")], collapse = " "), 
[18:06:27.854]                             hostname = base::Sys.info()[["nodename"]])
[18:06:27.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:27.854]                             info)
[18:06:27.854]                           info <- base::paste(info, collapse = "; ")
[18:06:27.854]                           if (!has_future) {
[18:06:27.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:27.854]                               info)
[18:06:27.854]                           }
[18:06:27.854]                           else {
[18:06:27.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:27.854]                               info, version)
[18:06:27.854]                           }
[18:06:27.854]                           base::stop(msg)
[18:06:27.854]                         }
[18:06:27.854]                       })
[18:06:27.854]                     }
[18:06:27.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:27.854]                     base::options(mc.cores = 1L)
[18:06:27.854]                   }
[18:06:27.854]                   ...future.strategy.old <- future::plan("list")
[18:06:27.854]                   options(future.plan = NULL)
[18:06:27.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:27.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:27.854]                 }
[18:06:27.854]                 ...future.workdir <- getwd()
[18:06:27.854]             }
[18:06:27.854]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:27.854]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:27.854]         }
[18:06:27.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:27.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:27.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:27.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:27.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:27.854]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:27.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:27.854]             base::names(...future.oldOptions))
[18:06:27.854]     }
[18:06:27.854]     if (FALSE) {
[18:06:27.854]     }
[18:06:27.854]     else {
[18:06:27.854]         if (TRUE) {
[18:06:27.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:27.854]                 open = "w")
[18:06:27.854]         }
[18:06:27.854]         else {
[18:06:27.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:27.854]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:27.854]         }
[18:06:27.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:27.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:27.854]             base::sink(type = "output", split = FALSE)
[18:06:27.854]             base::close(...future.stdout)
[18:06:27.854]         }, add = TRUE)
[18:06:27.854]     }
[18:06:27.854]     ...future.frame <- base::sys.nframe()
[18:06:27.854]     ...future.conditions <- base::list()
[18:06:27.854]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:27.854]     if (FALSE) {
[18:06:27.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:27.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:27.854]     }
[18:06:27.854]     ...future.result <- base::tryCatch({
[18:06:27.854]         base::withCallingHandlers({
[18:06:27.854]             ...future.value <- base::withVisible(base::local({
[18:06:27.854]                 ...future.makeSendCondition <- base::local({
[18:06:27.854]                   sendCondition <- NULL
[18:06:27.854]                   function(frame = 1L) {
[18:06:27.854]                     if (is.function(sendCondition)) 
[18:06:27.854]                       return(sendCondition)
[18:06:27.854]                     ns <- getNamespace("parallel")
[18:06:27.854]                     if (exists("sendData", mode = "function", 
[18:06:27.854]                       envir = ns)) {
[18:06:27.854]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:27.854]                         envir = ns)
[18:06:27.854]                       envir <- sys.frame(frame)
[18:06:27.854]                       master <- NULL
[18:06:27.854]                       while (!identical(envir, .GlobalEnv) && 
[18:06:27.854]                         !identical(envir, emptyenv())) {
[18:06:27.854]                         if (exists("master", mode = "list", envir = envir, 
[18:06:27.854]                           inherits = FALSE)) {
[18:06:27.854]                           master <- get("master", mode = "list", 
[18:06:27.854]                             envir = envir, inherits = FALSE)
[18:06:27.854]                           if (inherits(master, c("SOCKnode", 
[18:06:27.854]                             "SOCK0node"))) {
[18:06:27.854]                             sendCondition <<- function(cond) {
[18:06:27.854]                               data <- list(type = "VALUE", value = cond, 
[18:06:27.854]                                 success = TRUE)
[18:06:27.854]                               parallel_sendData(master, data)
[18:06:27.854]                             }
[18:06:27.854]                             return(sendCondition)
[18:06:27.854]                           }
[18:06:27.854]                         }
[18:06:27.854]                         frame <- frame + 1L
[18:06:27.854]                         envir <- sys.frame(frame)
[18:06:27.854]                       }
[18:06:27.854]                     }
[18:06:27.854]                     sendCondition <<- function(cond) NULL
[18:06:27.854]                   }
[18:06:27.854]                 })
[18:06:27.854]                 withCallingHandlers({
[18:06:27.854]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:27.854]                 }, immediateCondition = function(cond) {
[18:06:27.854]                   sendCondition <- ...future.makeSendCondition()
[18:06:27.854]                   sendCondition(cond)
[18:06:27.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.854]                   {
[18:06:27.854]                     inherits <- base::inherits
[18:06:27.854]                     invokeRestart <- base::invokeRestart
[18:06:27.854]                     is.null <- base::is.null
[18:06:27.854]                     muffled <- FALSE
[18:06:27.854]                     if (inherits(cond, "message")) {
[18:06:27.854]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:27.854]                       if (muffled) 
[18:06:27.854]                         invokeRestart("muffleMessage")
[18:06:27.854]                     }
[18:06:27.854]                     else if (inherits(cond, "warning")) {
[18:06:27.854]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:27.854]                       if (muffled) 
[18:06:27.854]                         invokeRestart("muffleWarning")
[18:06:27.854]                     }
[18:06:27.854]                     else if (inherits(cond, "condition")) {
[18:06:27.854]                       if (!is.null(pattern)) {
[18:06:27.854]                         computeRestarts <- base::computeRestarts
[18:06:27.854]                         grepl <- base::grepl
[18:06:27.854]                         restarts <- computeRestarts(cond)
[18:06:27.854]                         for (restart in restarts) {
[18:06:27.854]                           name <- restart$name
[18:06:27.854]                           if (is.null(name)) 
[18:06:27.854]                             next
[18:06:27.854]                           if (!grepl(pattern, name)) 
[18:06:27.854]                             next
[18:06:27.854]                           invokeRestart(restart)
[18:06:27.854]                           muffled <- TRUE
[18:06:27.854]                           break
[18:06:27.854]                         }
[18:06:27.854]                       }
[18:06:27.854]                     }
[18:06:27.854]                     invisible(muffled)
[18:06:27.854]                   }
[18:06:27.854]                   muffleCondition(cond)
[18:06:27.854]                 })
[18:06:27.854]             }))
[18:06:27.854]             future::FutureResult(value = ...future.value$value, 
[18:06:27.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:27.854]                   ...future.rng), globalenv = if (FALSE) 
[18:06:27.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:27.854]                     ...future.globalenv.names))
[18:06:27.854]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:27.854]         }, condition = base::local({
[18:06:27.854]             c <- base::c
[18:06:27.854]             inherits <- base::inherits
[18:06:27.854]             invokeRestart <- base::invokeRestart
[18:06:27.854]             length <- base::length
[18:06:27.854]             list <- base::list
[18:06:27.854]             seq.int <- base::seq.int
[18:06:27.854]             signalCondition <- base::signalCondition
[18:06:27.854]             sys.calls <- base::sys.calls
[18:06:27.854]             `[[` <- base::`[[`
[18:06:27.854]             `+` <- base::`+`
[18:06:27.854]             `<<-` <- base::`<<-`
[18:06:27.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:27.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:27.854]                   3L)]
[18:06:27.854]             }
[18:06:27.854]             function(cond) {
[18:06:27.854]                 is_error <- inherits(cond, "error")
[18:06:27.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:27.854]                   NULL)
[18:06:27.854]                 if (is_error) {
[18:06:27.854]                   sessionInformation <- function() {
[18:06:27.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:27.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:27.854]                       search = base::search(), system = base::Sys.info())
[18:06:27.854]                   }
[18:06:27.854]                   ...future.conditions[[length(...future.conditions) + 
[18:06:27.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:27.854]                     cond$call), session = sessionInformation(), 
[18:06:27.854]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:27.854]                   signalCondition(cond)
[18:06:27.854]                 }
[18:06:27.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:27.854]                 "immediateCondition"))) {
[18:06:27.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:27.854]                   ...future.conditions[[length(...future.conditions) + 
[18:06:27.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:27.854]                   if (TRUE && !signal) {
[18:06:27.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.854]                     {
[18:06:27.854]                       inherits <- base::inherits
[18:06:27.854]                       invokeRestart <- base::invokeRestart
[18:06:27.854]                       is.null <- base::is.null
[18:06:27.854]                       muffled <- FALSE
[18:06:27.854]                       if (inherits(cond, "message")) {
[18:06:27.854]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:27.854]                         if (muffled) 
[18:06:27.854]                           invokeRestart("muffleMessage")
[18:06:27.854]                       }
[18:06:27.854]                       else if (inherits(cond, "warning")) {
[18:06:27.854]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:27.854]                         if (muffled) 
[18:06:27.854]                           invokeRestart("muffleWarning")
[18:06:27.854]                       }
[18:06:27.854]                       else if (inherits(cond, "condition")) {
[18:06:27.854]                         if (!is.null(pattern)) {
[18:06:27.854]                           computeRestarts <- base::computeRestarts
[18:06:27.854]                           grepl <- base::grepl
[18:06:27.854]                           restarts <- computeRestarts(cond)
[18:06:27.854]                           for (restart in restarts) {
[18:06:27.854]                             name <- restart$name
[18:06:27.854]                             if (is.null(name)) 
[18:06:27.854]                               next
[18:06:27.854]                             if (!grepl(pattern, name)) 
[18:06:27.854]                               next
[18:06:27.854]                             invokeRestart(restart)
[18:06:27.854]                             muffled <- TRUE
[18:06:27.854]                             break
[18:06:27.854]                           }
[18:06:27.854]                         }
[18:06:27.854]                       }
[18:06:27.854]                       invisible(muffled)
[18:06:27.854]                     }
[18:06:27.854]                     muffleCondition(cond, pattern = "^muffle")
[18:06:27.854]                   }
[18:06:27.854]                 }
[18:06:27.854]                 else {
[18:06:27.854]                   if (TRUE) {
[18:06:27.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.854]                     {
[18:06:27.854]                       inherits <- base::inherits
[18:06:27.854]                       invokeRestart <- base::invokeRestart
[18:06:27.854]                       is.null <- base::is.null
[18:06:27.854]                       muffled <- FALSE
[18:06:27.854]                       if (inherits(cond, "message")) {
[18:06:27.854]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:27.854]                         if (muffled) 
[18:06:27.854]                           invokeRestart("muffleMessage")
[18:06:27.854]                       }
[18:06:27.854]                       else if (inherits(cond, "warning")) {
[18:06:27.854]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:27.854]                         if (muffled) 
[18:06:27.854]                           invokeRestart("muffleWarning")
[18:06:27.854]                       }
[18:06:27.854]                       else if (inherits(cond, "condition")) {
[18:06:27.854]                         if (!is.null(pattern)) {
[18:06:27.854]                           computeRestarts <- base::computeRestarts
[18:06:27.854]                           grepl <- base::grepl
[18:06:27.854]                           restarts <- computeRestarts(cond)
[18:06:27.854]                           for (restart in restarts) {
[18:06:27.854]                             name <- restart$name
[18:06:27.854]                             if (is.null(name)) 
[18:06:27.854]                               next
[18:06:27.854]                             if (!grepl(pattern, name)) 
[18:06:27.854]                               next
[18:06:27.854]                             invokeRestart(restart)
[18:06:27.854]                             muffled <- TRUE
[18:06:27.854]                             break
[18:06:27.854]                           }
[18:06:27.854]                         }
[18:06:27.854]                       }
[18:06:27.854]                       invisible(muffled)
[18:06:27.854]                     }
[18:06:27.854]                     muffleCondition(cond, pattern = "^muffle")
[18:06:27.854]                   }
[18:06:27.854]                 }
[18:06:27.854]             }
[18:06:27.854]         }))
[18:06:27.854]     }, error = function(ex) {
[18:06:27.854]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:27.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:27.854]                 ...future.rng), started = ...future.startTime, 
[18:06:27.854]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:27.854]             version = "1.8"), class = "FutureResult")
[18:06:27.854]     }, finally = {
[18:06:27.854]         if (!identical(...future.workdir, getwd())) 
[18:06:27.854]             setwd(...future.workdir)
[18:06:27.854]         {
[18:06:27.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:27.854]                 ...future.oldOptions$nwarnings <- NULL
[18:06:27.854]             }
[18:06:27.854]             base::options(...future.oldOptions)
[18:06:27.854]             if (.Platform$OS.type == "windows") {
[18:06:27.854]                 old_names <- names(...future.oldEnvVars)
[18:06:27.854]                 envs <- base::Sys.getenv()
[18:06:27.854]                 names <- names(envs)
[18:06:27.854]                 common <- intersect(names, old_names)
[18:06:27.854]                 added <- setdiff(names, old_names)
[18:06:27.854]                 removed <- setdiff(old_names, names)
[18:06:27.854]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:27.854]                   envs[common]]
[18:06:27.854]                 NAMES <- toupper(changed)
[18:06:27.854]                 args <- list()
[18:06:27.854]                 for (kk in seq_along(NAMES)) {
[18:06:27.854]                   name <- changed[[kk]]
[18:06:27.854]                   NAME <- NAMES[[kk]]
[18:06:27.854]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.854]                     next
[18:06:27.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:27.854]                 }
[18:06:27.854]                 NAMES <- toupper(added)
[18:06:27.854]                 for (kk in seq_along(NAMES)) {
[18:06:27.854]                   name <- added[[kk]]
[18:06:27.854]                   NAME <- NAMES[[kk]]
[18:06:27.854]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.854]                     next
[18:06:27.854]                   args[[name]] <- ""
[18:06:27.854]                 }
[18:06:27.854]                 NAMES <- toupper(removed)
[18:06:27.854]                 for (kk in seq_along(NAMES)) {
[18:06:27.854]                   name <- removed[[kk]]
[18:06:27.854]                   NAME <- NAMES[[kk]]
[18:06:27.854]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.854]                     next
[18:06:27.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:27.854]                 }
[18:06:27.854]                 if (length(args) > 0) 
[18:06:27.854]                   base::do.call(base::Sys.setenv, args = args)
[18:06:27.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:27.854]             }
[18:06:27.854]             else {
[18:06:27.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:27.854]             }
[18:06:27.854]             {
[18:06:27.854]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:27.854]                   0L) {
[18:06:27.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:27.854]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:27.854]                   base::options(opts)
[18:06:27.854]                 }
[18:06:27.854]                 {
[18:06:27.854]                   {
[18:06:27.854]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:27.854]                     NULL
[18:06:27.854]                   }
[18:06:27.854]                   options(future.plan = NULL)
[18:06:27.854]                   if (is.na(NA_character_)) 
[18:06:27.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:27.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:27.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:27.854]                     .init = FALSE)
[18:06:27.854]                 }
[18:06:27.854]             }
[18:06:27.854]         }
[18:06:27.854]     })
[18:06:27.854]     if (TRUE) {
[18:06:27.854]         base::sink(type = "output", split = FALSE)
[18:06:27.854]         if (TRUE) {
[18:06:27.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:27.854]         }
[18:06:27.854]         else {
[18:06:27.854]             ...future.result["stdout"] <- base::list(NULL)
[18:06:27.854]         }
[18:06:27.854]         base::close(...future.stdout)
[18:06:27.854]         ...future.stdout <- NULL
[18:06:27.854]     }
[18:06:27.854]     ...future.result$conditions <- ...future.conditions
[18:06:27.854]     ...future.result$finished <- base::Sys.time()
[18:06:27.854]     ...future.result
[18:06:27.854] }
[18:06:27.860] MultisessionFuture started
[18:06:27.861] - Launch lazy future ... done
[18:06:27.861] run() for ‘MultisessionFuture’ ... done
[18:06:27.905] receiveMessageFromWorker() for ClusterFuture ...
[18:06:27.905] - Validating connection of MultisessionFuture
[18:06:27.907] - received message: FutureResult
[18:06:27.907] - Received FutureResult
[18:06:27.907] - Erased future from FutureRegistry
[18:06:27.908] result() for ClusterFuture ...
[18:06:27.908] - result already collected: FutureResult
[18:06:27.908] result() for ClusterFuture ... done
[18:06:27.909] signalConditions() ...
[18:06:27.909]  - include = ‘immediateCondition’
[18:06:27.909]  - exclude = 
[18:06:27.909]  - resignal = FALSE
[18:06:27.910]  - Number of conditions: 1
[18:06:27.910] signalConditions() ... done
[18:06:27.910] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:27.911] A MultisessionFuture was resolved (and resolved itself)
[18:06:27.911] getGlobalsAndPackages() ...
[18:06:27.911] Searching for globals...
[18:06:27.913] - globals found: [2] ‘list’, ‘stop’
[18:06:27.914] Searching for globals ... DONE
[18:06:27.914] Resolving globals: FALSE
[18:06:27.915] 
[18:06:27.915] 
[18:06:27.915] getGlobalsAndPackages() ... DONE
[18:06:27.916] run() for ‘Future’ ...
[18:06:27.916] - state: ‘created’
[18:06:27.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:27.950] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:27.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:27.951]   - Field: ‘node’
[18:06:27.952]   - Field: ‘label’
[18:06:27.952]   - Field: ‘local’
[18:06:27.952]   - Field: ‘owner’
[18:06:27.952]   - Field: ‘envir’
[18:06:27.953]   - Field: ‘workers’
[18:06:27.953]   - Field: ‘packages’
[18:06:27.953]   - Field: ‘gc’
[18:06:27.953]   - Field: ‘conditions’
[18:06:27.954]   - Field: ‘persistent’
[18:06:27.954]   - Field: ‘expr’
[18:06:27.954]   - Field: ‘uuid’
[18:06:27.955]   - Field: ‘seed’
[18:06:27.955]   - Field: ‘version’
[18:06:27.955]   - Field: ‘result’
[18:06:27.955]   - Field: ‘asynchronous’
[18:06:27.956]   - Field: ‘calls’
[18:06:27.956]   - Field: ‘globals’
[18:06:27.956]   - Field: ‘stdout’
[18:06:27.956]   - Field: ‘earlySignal’
[18:06:27.957]   - Field: ‘lazy’
[18:06:27.957]   - Field: ‘state’
[18:06:27.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:27.957] - Launch lazy future ...
[18:06:27.958] Packages needed by the future expression (n = 0): <none>
[18:06:27.958] Packages needed by future strategies (n = 0): <none>
[18:06:27.959] {
[18:06:27.959]     {
[18:06:27.959]         {
[18:06:27.959]             ...future.startTime <- base::Sys.time()
[18:06:27.959]             {
[18:06:27.959]                 {
[18:06:27.959]                   {
[18:06:27.959]                     {
[18:06:27.959]                       base::local({
[18:06:27.959]                         has_future <- base::requireNamespace("future", 
[18:06:27.959]                           quietly = TRUE)
[18:06:27.959]                         if (has_future) {
[18:06:27.959]                           ns <- base::getNamespace("future")
[18:06:27.959]                           version <- ns[[".package"]][["version"]]
[18:06:27.959]                           if (is.null(version)) 
[18:06:27.959]                             version <- utils::packageVersion("future")
[18:06:27.959]                         }
[18:06:27.959]                         else {
[18:06:27.959]                           version <- NULL
[18:06:27.959]                         }
[18:06:27.959]                         if (!has_future || version < "1.8.0") {
[18:06:27.959]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:27.959]                             "", base::R.version$version.string), 
[18:06:27.959]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:27.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:27.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:27.959]                               "release", "version")], collapse = " "), 
[18:06:27.959]                             hostname = base::Sys.info()[["nodename"]])
[18:06:27.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:27.959]                             info)
[18:06:27.959]                           info <- base::paste(info, collapse = "; ")
[18:06:27.959]                           if (!has_future) {
[18:06:27.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:27.959]                               info)
[18:06:27.959]                           }
[18:06:27.959]                           else {
[18:06:27.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:27.959]                               info, version)
[18:06:27.959]                           }
[18:06:27.959]                           base::stop(msg)
[18:06:27.959]                         }
[18:06:27.959]                       })
[18:06:27.959]                     }
[18:06:27.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:27.959]                     base::options(mc.cores = 1L)
[18:06:27.959]                   }
[18:06:27.959]                   ...future.strategy.old <- future::plan("list")
[18:06:27.959]                   options(future.plan = NULL)
[18:06:27.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:27.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:27.959]                 }
[18:06:27.959]                 ...future.workdir <- getwd()
[18:06:27.959]             }
[18:06:27.959]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:27.959]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:27.959]         }
[18:06:27.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:27.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:27.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:27.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:27.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:27.959]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:27.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:27.959]             base::names(...future.oldOptions))
[18:06:27.959]     }
[18:06:27.959]     if (FALSE) {
[18:06:27.959]     }
[18:06:27.959]     else {
[18:06:27.959]         if (TRUE) {
[18:06:27.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:27.959]                 open = "w")
[18:06:27.959]         }
[18:06:27.959]         else {
[18:06:27.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:27.959]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:27.959]         }
[18:06:27.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:27.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:27.959]             base::sink(type = "output", split = FALSE)
[18:06:27.959]             base::close(...future.stdout)
[18:06:27.959]         }, add = TRUE)
[18:06:27.959]     }
[18:06:27.959]     ...future.frame <- base::sys.nframe()
[18:06:27.959]     ...future.conditions <- base::list()
[18:06:27.959]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:27.959]     if (FALSE) {
[18:06:27.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:27.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:27.959]     }
[18:06:27.959]     ...future.result <- base::tryCatch({
[18:06:27.959]         base::withCallingHandlers({
[18:06:27.959]             ...future.value <- base::withVisible(base::local({
[18:06:27.959]                 ...future.makeSendCondition <- base::local({
[18:06:27.959]                   sendCondition <- NULL
[18:06:27.959]                   function(frame = 1L) {
[18:06:27.959]                     if (is.function(sendCondition)) 
[18:06:27.959]                       return(sendCondition)
[18:06:27.959]                     ns <- getNamespace("parallel")
[18:06:27.959]                     if (exists("sendData", mode = "function", 
[18:06:27.959]                       envir = ns)) {
[18:06:27.959]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:27.959]                         envir = ns)
[18:06:27.959]                       envir <- sys.frame(frame)
[18:06:27.959]                       master <- NULL
[18:06:27.959]                       while (!identical(envir, .GlobalEnv) && 
[18:06:27.959]                         !identical(envir, emptyenv())) {
[18:06:27.959]                         if (exists("master", mode = "list", envir = envir, 
[18:06:27.959]                           inherits = FALSE)) {
[18:06:27.959]                           master <- get("master", mode = "list", 
[18:06:27.959]                             envir = envir, inherits = FALSE)
[18:06:27.959]                           if (inherits(master, c("SOCKnode", 
[18:06:27.959]                             "SOCK0node"))) {
[18:06:27.959]                             sendCondition <<- function(cond) {
[18:06:27.959]                               data <- list(type = "VALUE", value = cond, 
[18:06:27.959]                                 success = TRUE)
[18:06:27.959]                               parallel_sendData(master, data)
[18:06:27.959]                             }
[18:06:27.959]                             return(sendCondition)
[18:06:27.959]                           }
[18:06:27.959]                         }
[18:06:27.959]                         frame <- frame + 1L
[18:06:27.959]                         envir <- sys.frame(frame)
[18:06:27.959]                       }
[18:06:27.959]                     }
[18:06:27.959]                     sendCondition <<- function(cond) NULL
[18:06:27.959]                   }
[18:06:27.959]                 })
[18:06:27.959]                 withCallingHandlers({
[18:06:27.959]                   list(a = 1, b = 42L, c = stop("Nah!"))
[18:06:27.959]                 }, immediateCondition = function(cond) {
[18:06:27.959]                   sendCondition <- ...future.makeSendCondition()
[18:06:27.959]                   sendCondition(cond)
[18:06:27.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.959]                   {
[18:06:27.959]                     inherits <- base::inherits
[18:06:27.959]                     invokeRestart <- base::invokeRestart
[18:06:27.959]                     is.null <- base::is.null
[18:06:27.959]                     muffled <- FALSE
[18:06:27.959]                     if (inherits(cond, "message")) {
[18:06:27.959]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:27.959]                       if (muffled) 
[18:06:27.959]                         invokeRestart("muffleMessage")
[18:06:27.959]                     }
[18:06:27.959]                     else if (inherits(cond, "warning")) {
[18:06:27.959]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:27.959]                       if (muffled) 
[18:06:27.959]                         invokeRestart("muffleWarning")
[18:06:27.959]                     }
[18:06:27.959]                     else if (inherits(cond, "condition")) {
[18:06:27.959]                       if (!is.null(pattern)) {
[18:06:27.959]                         computeRestarts <- base::computeRestarts
[18:06:27.959]                         grepl <- base::grepl
[18:06:27.959]                         restarts <- computeRestarts(cond)
[18:06:27.959]                         for (restart in restarts) {
[18:06:27.959]                           name <- restart$name
[18:06:27.959]                           if (is.null(name)) 
[18:06:27.959]                             next
[18:06:27.959]                           if (!grepl(pattern, name)) 
[18:06:27.959]                             next
[18:06:27.959]                           invokeRestart(restart)
[18:06:27.959]                           muffled <- TRUE
[18:06:27.959]                           break
[18:06:27.959]                         }
[18:06:27.959]                       }
[18:06:27.959]                     }
[18:06:27.959]                     invisible(muffled)
[18:06:27.959]                   }
[18:06:27.959]                   muffleCondition(cond)
[18:06:27.959]                 })
[18:06:27.959]             }))
[18:06:27.959]             future::FutureResult(value = ...future.value$value, 
[18:06:27.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:27.959]                   ...future.rng), globalenv = if (FALSE) 
[18:06:27.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:27.959]                     ...future.globalenv.names))
[18:06:27.959]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:27.959]         }, condition = base::local({
[18:06:27.959]             c <- base::c
[18:06:27.959]             inherits <- base::inherits
[18:06:27.959]             invokeRestart <- base::invokeRestart
[18:06:27.959]             length <- base::length
[18:06:27.959]             list <- base::list
[18:06:27.959]             seq.int <- base::seq.int
[18:06:27.959]             signalCondition <- base::signalCondition
[18:06:27.959]             sys.calls <- base::sys.calls
[18:06:27.959]             `[[` <- base::`[[`
[18:06:27.959]             `+` <- base::`+`
[18:06:27.959]             `<<-` <- base::`<<-`
[18:06:27.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:27.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:27.959]                   3L)]
[18:06:27.959]             }
[18:06:27.959]             function(cond) {
[18:06:27.959]                 is_error <- inherits(cond, "error")
[18:06:27.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:27.959]                   NULL)
[18:06:27.959]                 if (is_error) {
[18:06:27.959]                   sessionInformation <- function() {
[18:06:27.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:27.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:27.959]                       search = base::search(), system = base::Sys.info())
[18:06:27.959]                   }
[18:06:27.959]                   ...future.conditions[[length(...future.conditions) + 
[18:06:27.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:27.959]                     cond$call), session = sessionInformation(), 
[18:06:27.959]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:27.959]                   signalCondition(cond)
[18:06:27.959]                 }
[18:06:27.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:27.959]                 "immediateCondition"))) {
[18:06:27.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:27.959]                   ...future.conditions[[length(...future.conditions) + 
[18:06:27.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:27.959]                   if (TRUE && !signal) {
[18:06:27.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.959]                     {
[18:06:27.959]                       inherits <- base::inherits
[18:06:27.959]                       invokeRestart <- base::invokeRestart
[18:06:27.959]                       is.null <- base::is.null
[18:06:27.959]                       muffled <- FALSE
[18:06:27.959]                       if (inherits(cond, "message")) {
[18:06:27.959]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:27.959]                         if (muffled) 
[18:06:27.959]                           invokeRestart("muffleMessage")
[18:06:27.959]                       }
[18:06:27.959]                       else if (inherits(cond, "warning")) {
[18:06:27.959]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:27.959]                         if (muffled) 
[18:06:27.959]                           invokeRestart("muffleWarning")
[18:06:27.959]                       }
[18:06:27.959]                       else if (inherits(cond, "condition")) {
[18:06:27.959]                         if (!is.null(pattern)) {
[18:06:27.959]                           computeRestarts <- base::computeRestarts
[18:06:27.959]                           grepl <- base::grepl
[18:06:27.959]                           restarts <- computeRestarts(cond)
[18:06:27.959]                           for (restart in restarts) {
[18:06:27.959]                             name <- restart$name
[18:06:27.959]                             if (is.null(name)) 
[18:06:27.959]                               next
[18:06:27.959]                             if (!grepl(pattern, name)) 
[18:06:27.959]                               next
[18:06:27.959]                             invokeRestart(restart)
[18:06:27.959]                             muffled <- TRUE
[18:06:27.959]                             break
[18:06:27.959]                           }
[18:06:27.959]                         }
[18:06:27.959]                       }
[18:06:27.959]                       invisible(muffled)
[18:06:27.959]                     }
[18:06:27.959]                     muffleCondition(cond, pattern = "^muffle")
[18:06:27.959]                   }
[18:06:27.959]                 }
[18:06:27.959]                 else {
[18:06:27.959]                   if (TRUE) {
[18:06:27.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:27.959]                     {
[18:06:27.959]                       inherits <- base::inherits
[18:06:27.959]                       invokeRestart <- base::invokeRestart
[18:06:27.959]                       is.null <- base::is.null
[18:06:27.959]                       muffled <- FALSE
[18:06:27.959]                       if (inherits(cond, "message")) {
[18:06:27.959]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:27.959]                         if (muffled) 
[18:06:27.959]                           invokeRestart("muffleMessage")
[18:06:27.959]                       }
[18:06:27.959]                       else if (inherits(cond, "warning")) {
[18:06:27.959]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:27.959]                         if (muffled) 
[18:06:27.959]                           invokeRestart("muffleWarning")
[18:06:27.959]                       }
[18:06:27.959]                       else if (inherits(cond, "condition")) {
[18:06:27.959]                         if (!is.null(pattern)) {
[18:06:27.959]                           computeRestarts <- base::computeRestarts
[18:06:27.959]                           grepl <- base::grepl
[18:06:27.959]                           restarts <- computeRestarts(cond)
[18:06:27.959]                           for (restart in restarts) {
[18:06:27.959]                             name <- restart$name
[18:06:27.959]                             if (is.null(name)) 
[18:06:27.959]                               next
[18:06:27.959]                             if (!grepl(pattern, name)) 
[18:06:27.959]                               next
[18:06:27.959]                             invokeRestart(restart)
[18:06:27.959]                             muffled <- TRUE
[18:06:27.959]                             break
[18:06:27.959]                           }
[18:06:27.959]                         }
[18:06:27.959]                       }
[18:06:27.959]                       invisible(muffled)
[18:06:27.959]                     }
[18:06:27.959]                     muffleCondition(cond, pattern = "^muffle")
[18:06:27.959]                   }
[18:06:27.959]                 }
[18:06:27.959]             }
[18:06:27.959]         }))
[18:06:27.959]     }, error = function(ex) {
[18:06:27.959]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:27.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:27.959]                 ...future.rng), started = ...future.startTime, 
[18:06:27.959]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:27.959]             version = "1.8"), class = "FutureResult")
[18:06:27.959]     }, finally = {
[18:06:27.959]         if (!identical(...future.workdir, getwd())) 
[18:06:27.959]             setwd(...future.workdir)
[18:06:27.959]         {
[18:06:27.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:27.959]                 ...future.oldOptions$nwarnings <- NULL
[18:06:27.959]             }
[18:06:27.959]             base::options(...future.oldOptions)
[18:06:27.959]             if (.Platform$OS.type == "windows") {
[18:06:27.959]                 old_names <- names(...future.oldEnvVars)
[18:06:27.959]                 envs <- base::Sys.getenv()
[18:06:27.959]                 names <- names(envs)
[18:06:27.959]                 common <- intersect(names, old_names)
[18:06:27.959]                 added <- setdiff(names, old_names)
[18:06:27.959]                 removed <- setdiff(old_names, names)
[18:06:27.959]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:27.959]                   envs[common]]
[18:06:27.959]                 NAMES <- toupper(changed)
[18:06:27.959]                 args <- list()
[18:06:27.959]                 for (kk in seq_along(NAMES)) {
[18:06:27.959]                   name <- changed[[kk]]
[18:06:27.959]                   NAME <- NAMES[[kk]]
[18:06:27.959]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.959]                     next
[18:06:27.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:27.959]                 }
[18:06:27.959]                 NAMES <- toupper(added)
[18:06:27.959]                 for (kk in seq_along(NAMES)) {
[18:06:27.959]                   name <- added[[kk]]
[18:06:27.959]                   NAME <- NAMES[[kk]]
[18:06:27.959]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.959]                     next
[18:06:27.959]                   args[[name]] <- ""
[18:06:27.959]                 }
[18:06:27.959]                 NAMES <- toupper(removed)
[18:06:27.959]                 for (kk in seq_along(NAMES)) {
[18:06:27.959]                   name <- removed[[kk]]
[18:06:27.959]                   NAME <- NAMES[[kk]]
[18:06:27.959]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:27.959]                     next
[18:06:27.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:27.959]                 }
[18:06:27.959]                 if (length(args) > 0) 
[18:06:27.959]                   base::do.call(base::Sys.setenv, args = args)
[18:06:27.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:27.959]             }
[18:06:27.959]             else {
[18:06:27.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:27.959]             }
[18:06:27.959]             {
[18:06:27.959]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:27.959]                   0L) {
[18:06:27.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:27.959]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:27.959]                   base::options(opts)
[18:06:27.959]                 }
[18:06:27.959]                 {
[18:06:27.959]                   {
[18:06:27.959]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:27.959]                     NULL
[18:06:27.959]                   }
[18:06:27.959]                   options(future.plan = NULL)
[18:06:27.959]                   if (is.na(NA_character_)) 
[18:06:27.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:27.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:27.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:27.959]                     .init = FALSE)
[18:06:27.959]                 }
[18:06:27.959]             }
[18:06:27.959]         }
[18:06:27.959]     })
[18:06:27.959]     if (TRUE) {
[18:06:27.959]         base::sink(type = "output", split = FALSE)
[18:06:27.959]         if (TRUE) {
[18:06:27.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:27.959]         }
[18:06:27.959]         else {
[18:06:27.959]             ...future.result["stdout"] <- base::list(NULL)
[18:06:27.959]         }
[18:06:27.959]         base::close(...future.stdout)
[18:06:27.959]         ...future.stdout <- NULL
[18:06:27.959]     }
[18:06:27.959]     ...future.result$conditions <- ...future.conditions
[18:06:27.959]     ...future.result$finished <- base::Sys.time()
[18:06:27.959]     ...future.result
[18:06:27.959] }
[18:06:27.966] MultisessionFuture started
[18:06:27.967] - Launch lazy future ... done
[18:06:27.967] run() for ‘MultisessionFuture’ ... done
[18:06:28.011] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.011] - Validating connection of MultisessionFuture
[18:06:28.013] - received message: FutureResult
[18:06:28.013] - Received FutureResult
[18:06:28.013] - Erased future from FutureRegistry
[18:06:28.014] result() for ClusterFuture ...
[18:06:28.014] - result already collected: FutureResult
[18:06:28.014] result() for ClusterFuture ... done
[18:06:28.015] signalConditions() ...
[18:06:28.015]  - include = ‘immediateCondition’
[18:06:28.015]  - exclude = 
[18:06:28.016]  - resignal = FALSE
[18:06:28.016]  - Number of conditions: 1
[18:06:28.016] signalConditions() ... done
[18:06:28.017] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.017] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[18:06:28.018] resolve() on list ...
[18:06:28.018]  recursive: 0
[18:06:28.018]  length: 2
[18:06:28.019]  elements: ‘a’, ‘b’
[18:06:28.019]  length: 1 (resolved future 1)
[18:06:28.019]  length: 0 (resolved future 2)
[18:06:28.020] resolve() on list ... DONE
[18:06:28.020] getGlobalsAndPackages() ...
[18:06:28.020] Searching for globals...
[18:06:28.021] 
[18:06:28.022] Searching for globals ... DONE
[18:06:28.022] - globals: [0] <none>
[18:06:28.022] getGlobalsAndPackages() ... DONE
[18:06:28.023] run() for ‘Future’ ...
[18:06:28.023] - state: ‘created’
[18:06:28.024] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.052]   - Field: ‘node’
[18:06:28.052]   - Field: ‘label’
[18:06:28.053]   - Field: ‘local’
[18:06:28.053]   - Field: ‘owner’
[18:06:28.053]   - Field: ‘envir’
[18:06:28.053]   - Field: ‘workers’
[18:06:28.053]   - Field: ‘packages’
[18:06:28.054]   - Field: ‘gc’
[18:06:28.054]   - Field: ‘conditions’
[18:06:28.054]   - Field: ‘persistent’
[18:06:28.054]   - Field: ‘expr’
[18:06:28.055]   - Field: ‘uuid’
[18:06:28.055]   - Field: ‘seed’
[18:06:28.055]   - Field: ‘version’
[18:06:28.055]   - Field: ‘result’
[18:06:28.056]   - Field: ‘asynchronous’
[18:06:28.056]   - Field: ‘calls’
[18:06:28.056]   - Field: ‘globals’
[18:06:28.056]   - Field: ‘stdout’
[18:06:28.056]   - Field: ‘earlySignal’
[18:06:28.057]   - Field: ‘lazy’
[18:06:28.057]   - Field: ‘state’
[18:06:28.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.057] - Launch lazy future ...
[18:06:28.058] Packages needed by the future expression (n = 0): <none>
[18:06:28.058] Packages needed by future strategies (n = 0): <none>
[18:06:28.059] {
[18:06:28.059]     {
[18:06:28.059]         {
[18:06:28.059]             ...future.startTime <- base::Sys.time()
[18:06:28.059]             {
[18:06:28.059]                 {
[18:06:28.059]                   {
[18:06:28.059]                     {
[18:06:28.059]                       base::local({
[18:06:28.059]                         has_future <- base::requireNamespace("future", 
[18:06:28.059]                           quietly = TRUE)
[18:06:28.059]                         if (has_future) {
[18:06:28.059]                           ns <- base::getNamespace("future")
[18:06:28.059]                           version <- ns[[".package"]][["version"]]
[18:06:28.059]                           if (is.null(version)) 
[18:06:28.059]                             version <- utils::packageVersion("future")
[18:06:28.059]                         }
[18:06:28.059]                         else {
[18:06:28.059]                           version <- NULL
[18:06:28.059]                         }
[18:06:28.059]                         if (!has_future || version < "1.8.0") {
[18:06:28.059]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.059]                             "", base::R.version$version.string), 
[18:06:28.059]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.059]                               "release", "version")], collapse = " "), 
[18:06:28.059]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.059]                             info)
[18:06:28.059]                           info <- base::paste(info, collapse = "; ")
[18:06:28.059]                           if (!has_future) {
[18:06:28.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.059]                               info)
[18:06:28.059]                           }
[18:06:28.059]                           else {
[18:06:28.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.059]                               info, version)
[18:06:28.059]                           }
[18:06:28.059]                           base::stop(msg)
[18:06:28.059]                         }
[18:06:28.059]                       })
[18:06:28.059]                     }
[18:06:28.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.059]                     base::options(mc.cores = 1L)
[18:06:28.059]                   }
[18:06:28.059]                   ...future.strategy.old <- future::plan("list")
[18:06:28.059]                   options(future.plan = NULL)
[18:06:28.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.059]                 }
[18:06:28.059]                 ...future.workdir <- getwd()
[18:06:28.059]             }
[18:06:28.059]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.059]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.059]         }
[18:06:28.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.059]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.059]             base::names(...future.oldOptions))
[18:06:28.059]     }
[18:06:28.059]     if (FALSE) {
[18:06:28.059]     }
[18:06:28.059]     else {
[18:06:28.059]         if (TRUE) {
[18:06:28.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.059]                 open = "w")
[18:06:28.059]         }
[18:06:28.059]         else {
[18:06:28.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.059]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.059]         }
[18:06:28.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.059]             base::sink(type = "output", split = FALSE)
[18:06:28.059]             base::close(...future.stdout)
[18:06:28.059]         }, add = TRUE)
[18:06:28.059]     }
[18:06:28.059]     ...future.frame <- base::sys.nframe()
[18:06:28.059]     ...future.conditions <- base::list()
[18:06:28.059]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.059]     if (FALSE) {
[18:06:28.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.059]     }
[18:06:28.059]     ...future.result <- base::tryCatch({
[18:06:28.059]         base::withCallingHandlers({
[18:06:28.059]             ...future.value <- base::withVisible(base::local({
[18:06:28.059]                 ...future.makeSendCondition <- base::local({
[18:06:28.059]                   sendCondition <- NULL
[18:06:28.059]                   function(frame = 1L) {
[18:06:28.059]                     if (is.function(sendCondition)) 
[18:06:28.059]                       return(sendCondition)
[18:06:28.059]                     ns <- getNamespace("parallel")
[18:06:28.059]                     if (exists("sendData", mode = "function", 
[18:06:28.059]                       envir = ns)) {
[18:06:28.059]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.059]                         envir = ns)
[18:06:28.059]                       envir <- sys.frame(frame)
[18:06:28.059]                       master <- NULL
[18:06:28.059]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.059]                         !identical(envir, emptyenv())) {
[18:06:28.059]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.059]                           inherits = FALSE)) {
[18:06:28.059]                           master <- get("master", mode = "list", 
[18:06:28.059]                             envir = envir, inherits = FALSE)
[18:06:28.059]                           if (inherits(master, c("SOCKnode", 
[18:06:28.059]                             "SOCK0node"))) {
[18:06:28.059]                             sendCondition <<- function(cond) {
[18:06:28.059]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.059]                                 success = TRUE)
[18:06:28.059]                               parallel_sendData(master, data)
[18:06:28.059]                             }
[18:06:28.059]                             return(sendCondition)
[18:06:28.059]                           }
[18:06:28.059]                         }
[18:06:28.059]                         frame <- frame + 1L
[18:06:28.059]                         envir <- sys.frame(frame)
[18:06:28.059]                       }
[18:06:28.059]                     }
[18:06:28.059]                     sendCondition <<- function(cond) NULL
[18:06:28.059]                   }
[18:06:28.059]                 })
[18:06:28.059]                 withCallingHandlers({
[18:06:28.059]                   1
[18:06:28.059]                 }, immediateCondition = function(cond) {
[18:06:28.059]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.059]                   sendCondition(cond)
[18:06:28.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.059]                   {
[18:06:28.059]                     inherits <- base::inherits
[18:06:28.059]                     invokeRestart <- base::invokeRestart
[18:06:28.059]                     is.null <- base::is.null
[18:06:28.059]                     muffled <- FALSE
[18:06:28.059]                     if (inherits(cond, "message")) {
[18:06:28.059]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.059]                       if (muffled) 
[18:06:28.059]                         invokeRestart("muffleMessage")
[18:06:28.059]                     }
[18:06:28.059]                     else if (inherits(cond, "warning")) {
[18:06:28.059]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.059]                       if (muffled) 
[18:06:28.059]                         invokeRestart("muffleWarning")
[18:06:28.059]                     }
[18:06:28.059]                     else if (inherits(cond, "condition")) {
[18:06:28.059]                       if (!is.null(pattern)) {
[18:06:28.059]                         computeRestarts <- base::computeRestarts
[18:06:28.059]                         grepl <- base::grepl
[18:06:28.059]                         restarts <- computeRestarts(cond)
[18:06:28.059]                         for (restart in restarts) {
[18:06:28.059]                           name <- restart$name
[18:06:28.059]                           if (is.null(name)) 
[18:06:28.059]                             next
[18:06:28.059]                           if (!grepl(pattern, name)) 
[18:06:28.059]                             next
[18:06:28.059]                           invokeRestart(restart)
[18:06:28.059]                           muffled <- TRUE
[18:06:28.059]                           break
[18:06:28.059]                         }
[18:06:28.059]                       }
[18:06:28.059]                     }
[18:06:28.059]                     invisible(muffled)
[18:06:28.059]                   }
[18:06:28.059]                   muffleCondition(cond)
[18:06:28.059]                 })
[18:06:28.059]             }))
[18:06:28.059]             future::FutureResult(value = ...future.value$value, 
[18:06:28.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.059]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.059]                     ...future.globalenv.names))
[18:06:28.059]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.059]         }, condition = base::local({
[18:06:28.059]             c <- base::c
[18:06:28.059]             inherits <- base::inherits
[18:06:28.059]             invokeRestart <- base::invokeRestart
[18:06:28.059]             length <- base::length
[18:06:28.059]             list <- base::list
[18:06:28.059]             seq.int <- base::seq.int
[18:06:28.059]             signalCondition <- base::signalCondition
[18:06:28.059]             sys.calls <- base::sys.calls
[18:06:28.059]             `[[` <- base::`[[`
[18:06:28.059]             `+` <- base::`+`
[18:06:28.059]             `<<-` <- base::`<<-`
[18:06:28.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.059]                   3L)]
[18:06:28.059]             }
[18:06:28.059]             function(cond) {
[18:06:28.059]                 is_error <- inherits(cond, "error")
[18:06:28.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.059]                   NULL)
[18:06:28.059]                 if (is_error) {
[18:06:28.059]                   sessionInformation <- function() {
[18:06:28.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.059]                       search = base::search(), system = base::Sys.info())
[18:06:28.059]                   }
[18:06:28.059]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.059]                     cond$call), session = sessionInformation(), 
[18:06:28.059]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.059]                   signalCondition(cond)
[18:06:28.059]                 }
[18:06:28.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.059]                 "immediateCondition"))) {
[18:06:28.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.059]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.059]                   if (TRUE && !signal) {
[18:06:28.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.059]                     {
[18:06:28.059]                       inherits <- base::inherits
[18:06:28.059]                       invokeRestart <- base::invokeRestart
[18:06:28.059]                       is.null <- base::is.null
[18:06:28.059]                       muffled <- FALSE
[18:06:28.059]                       if (inherits(cond, "message")) {
[18:06:28.059]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.059]                         if (muffled) 
[18:06:28.059]                           invokeRestart("muffleMessage")
[18:06:28.059]                       }
[18:06:28.059]                       else if (inherits(cond, "warning")) {
[18:06:28.059]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.059]                         if (muffled) 
[18:06:28.059]                           invokeRestart("muffleWarning")
[18:06:28.059]                       }
[18:06:28.059]                       else if (inherits(cond, "condition")) {
[18:06:28.059]                         if (!is.null(pattern)) {
[18:06:28.059]                           computeRestarts <- base::computeRestarts
[18:06:28.059]                           grepl <- base::grepl
[18:06:28.059]                           restarts <- computeRestarts(cond)
[18:06:28.059]                           for (restart in restarts) {
[18:06:28.059]                             name <- restart$name
[18:06:28.059]                             if (is.null(name)) 
[18:06:28.059]                               next
[18:06:28.059]                             if (!grepl(pattern, name)) 
[18:06:28.059]                               next
[18:06:28.059]                             invokeRestart(restart)
[18:06:28.059]                             muffled <- TRUE
[18:06:28.059]                             break
[18:06:28.059]                           }
[18:06:28.059]                         }
[18:06:28.059]                       }
[18:06:28.059]                       invisible(muffled)
[18:06:28.059]                     }
[18:06:28.059]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.059]                   }
[18:06:28.059]                 }
[18:06:28.059]                 else {
[18:06:28.059]                   if (TRUE) {
[18:06:28.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.059]                     {
[18:06:28.059]                       inherits <- base::inherits
[18:06:28.059]                       invokeRestart <- base::invokeRestart
[18:06:28.059]                       is.null <- base::is.null
[18:06:28.059]                       muffled <- FALSE
[18:06:28.059]                       if (inherits(cond, "message")) {
[18:06:28.059]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.059]                         if (muffled) 
[18:06:28.059]                           invokeRestart("muffleMessage")
[18:06:28.059]                       }
[18:06:28.059]                       else if (inherits(cond, "warning")) {
[18:06:28.059]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.059]                         if (muffled) 
[18:06:28.059]                           invokeRestart("muffleWarning")
[18:06:28.059]                       }
[18:06:28.059]                       else if (inherits(cond, "condition")) {
[18:06:28.059]                         if (!is.null(pattern)) {
[18:06:28.059]                           computeRestarts <- base::computeRestarts
[18:06:28.059]                           grepl <- base::grepl
[18:06:28.059]                           restarts <- computeRestarts(cond)
[18:06:28.059]                           for (restart in restarts) {
[18:06:28.059]                             name <- restart$name
[18:06:28.059]                             if (is.null(name)) 
[18:06:28.059]                               next
[18:06:28.059]                             if (!grepl(pattern, name)) 
[18:06:28.059]                               next
[18:06:28.059]                             invokeRestart(restart)
[18:06:28.059]                             muffled <- TRUE
[18:06:28.059]                             break
[18:06:28.059]                           }
[18:06:28.059]                         }
[18:06:28.059]                       }
[18:06:28.059]                       invisible(muffled)
[18:06:28.059]                     }
[18:06:28.059]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.059]                   }
[18:06:28.059]                 }
[18:06:28.059]             }
[18:06:28.059]         }))
[18:06:28.059]     }, error = function(ex) {
[18:06:28.059]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.059]                 ...future.rng), started = ...future.startTime, 
[18:06:28.059]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.059]             version = "1.8"), class = "FutureResult")
[18:06:28.059]     }, finally = {
[18:06:28.059]         if (!identical(...future.workdir, getwd())) 
[18:06:28.059]             setwd(...future.workdir)
[18:06:28.059]         {
[18:06:28.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.059]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.059]             }
[18:06:28.059]             base::options(...future.oldOptions)
[18:06:28.059]             if (.Platform$OS.type == "windows") {
[18:06:28.059]                 old_names <- names(...future.oldEnvVars)
[18:06:28.059]                 envs <- base::Sys.getenv()
[18:06:28.059]                 names <- names(envs)
[18:06:28.059]                 common <- intersect(names, old_names)
[18:06:28.059]                 added <- setdiff(names, old_names)
[18:06:28.059]                 removed <- setdiff(old_names, names)
[18:06:28.059]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.059]                   envs[common]]
[18:06:28.059]                 NAMES <- toupper(changed)
[18:06:28.059]                 args <- list()
[18:06:28.059]                 for (kk in seq_along(NAMES)) {
[18:06:28.059]                   name <- changed[[kk]]
[18:06:28.059]                   NAME <- NAMES[[kk]]
[18:06:28.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.059]                     next
[18:06:28.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.059]                 }
[18:06:28.059]                 NAMES <- toupper(added)
[18:06:28.059]                 for (kk in seq_along(NAMES)) {
[18:06:28.059]                   name <- added[[kk]]
[18:06:28.059]                   NAME <- NAMES[[kk]]
[18:06:28.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.059]                     next
[18:06:28.059]                   args[[name]] <- ""
[18:06:28.059]                 }
[18:06:28.059]                 NAMES <- toupper(removed)
[18:06:28.059]                 for (kk in seq_along(NAMES)) {
[18:06:28.059]                   name <- removed[[kk]]
[18:06:28.059]                   NAME <- NAMES[[kk]]
[18:06:28.059]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.059]                     next
[18:06:28.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.059]                 }
[18:06:28.059]                 if (length(args) > 0) 
[18:06:28.059]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.059]             }
[18:06:28.059]             else {
[18:06:28.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.059]             }
[18:06:28.059]             {
[18:06:28.059]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.059]                   0L) {
[18:06:28.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.059]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.059]                   base::options(opts)
[18:06:28.059]                 }
[18:06:28.059]                 {
[18:06:28.059]                   {
[18:06:28.059]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.059]                     NULL
[18:06:28.059]                   }
[18:06:28.059]                   options(future.plan = NULL)
[18:06:28.059]                   if (is.na(NA_character_)) 
[18:06:28.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.059]                     .init = FALSE)
[18:06:28.059]                 }
[18:06:28.059]             }
[18:06:28.059]         }
[18:06:28.059]     })
[18:06:28.059]     if (TRUE) {
[18:06:28.059]         base::sink(type = "output", split = FALSE)
[18:06:28.059]         if (TRUE) {
[18:06:28.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.059]         }
[18:06:28.059]         else {
[18:06:28.059]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.059]         }
[18:06:28.059]         base::close(...future.stdout)
[18:06:28.059]         ...future.stdout <- NULL
[18:06:28.059]     }
[18:06:28.059]     ...future.result$conditions <- ...future.conditions
[18:06:28.059]     ...future.result$finished <- base::Sys.time()
[18:06:28.059]     ...future.result
[18:06:28.059] }
[18:06:28.066] MultisessionFuture started
[18:06:28.066] - Launch lazy future ... done
[18:06:28.066] run() for ‘MultisessionFuture’ ... done
[18:06:28.067] getGlobalsAndPackages() ...
[18:06:28.067] Searching for globals...
[18:06:28.068] 
[18:06:28.068] Searching for globals ... DONE
[18:06:28.068] - globals: [0] <none>
[18:06:28.069] getGlobalsAndPackages() ... DONE
[18:06:28.069] run() for ‘Future’ ...
[18:06:28.069] - state: ‘created’
[18:06:28.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.097]   - Field: ‘node’
[18:06:28.097]   - Field: ‘label’
[18:06:28.097]   - Field: ‘local’
[18:06:28.097]   - Field: ‘owner’
[18:06:28.097]   - Field: ‘envir’
[18:06:28.098]   - Field: ‘workers’
[18:06:28.098]   - Field: ‘packages’
[18:06:28.098]   - Field: ‘gc’
[18:06:28.098]   - Field: ‘conditions’
[18:06:28.098]   - Field: ‘persistent’
[18:06:28.099]   - Field: ‘expr’
[18:06:28.099]   - Field: ‘uuid’
[18:06:28.099]   - Field: ‘seed’
[18:06:28.099]   - Field: ‘version’
[18:06:28.099]   - Field: ‘result’
[18:06:28.100]   - Field: ‘asynchronous’
[18:06:28.100]   - Field: ‘calls’
[18:06:28.100]   - Field: ‘globals’
[18:06:28.100]   - Field: ‘stdout’
[18:06:28.100]   - Field: ‘earlySignal’
[18:06:28.101]   - Field: ‘lazy’
[18:06:28.101]   - Field: ‘state’
[18:06:28.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.101] - Launch lazy future ...
[18:06:28.102] Packages needed by the future expression (n = 0): <none>
[18:06:28.102] Packages needed by future strategies (n = 0): <none>
[18:06:28.103] {
[18:06:28.103]     {
[18:06:28.103]         {
[18:06:28.103]             ...future.startTime <- base::Sys.time()
[18:06:28.103]             {
[18:06:28.103]                 {
[18:06:28.103]                   {
[18:06:28.103]                     {
[18:06:28.103]                       base::local({
[18:06:28.103]                         has_future <- base::requireNamespace("future", 
[18:06:28.103]                           quietly = TRUE)
[18:06:28.103]                         if (has_future) {
[18:06:28.103]                           ns <- base::getNamespace("future")
[18:06:28.103]                           version <- ns[[".package"]][["version"]]
[18:06:28.103]                           if (is.null(version)) 
[18:06:28.103]                             version <- utils::packageVersion("future")
[18:06:28.103]                         }
[18:06:28.103]                         else {
[18:06:28.103]                           version <- NULL
[18:06:28.103]                         }
[18:06:28.103]                         if (!has_future || version < "1.8.0") {
[18:06:28.103]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.103]                             "", base::R.version$version.string), 
[18:06:28.103]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.103]                               "release", "version")], collapse = " "), 
[18:06:28.103]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.103]                             info)
[18:06:28.103]                           info <- base::paste(info, collapse = "; ")
[18:06:28.103]                           if (!has_future) {
[18:06:28.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.103]                               info)
[18:06:28.103]                           }
[18:06:28.103]                           else {
[18:06:28.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.103]                               info, version)
[18:06:28.103]                           }
[18:06:28.103]                           base::stop(msg)
[18:06:28.103]                         }
[18:06:28.103]                       })
[18:06:28.103]                     }
[18:06:28.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.103]                     base::options(mc.cores = 1L)
[18:06:28.103]                   }
[18:06:28.103]                   ...future.strategy.old <- future::plan("list")
[18:06:28.103]                   options(future.plan = NULL)
[18:06:28.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.103]                 }
[18:06:28.103]                 ...future.workdir <- getwd()
[18:06:28.103]             }
[18:06:28.103]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.103]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.103]         }
[18:06:28.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.103]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.103]             base::names(...future.oldOptions))
[18:06:28.103]     }
[18:06:28.103]     if (FALSE) {
[18:06:28.103]     }
[18:06:28.103]     else {
[18:06:28.103]         if (TRUE) {
[18:06:28.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.103]                 open = "w")
[18:06:28.103]         }
[18:06:28.103]         else {
[18:06:28.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.103]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.103]         }
[18:06:28.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.103]             base::sink(type = "output", split = FALSE)
[18:06:28.103]             base::close(...future.stdout)
[18:06:28.103]         }, add = TRUE)
[18:06:28.103]     }
[18:06:28.103]     ...future.frame <- base::sys.nframe()
[18:06:28.103]     ...future.conditions <- base::list()
[18:06:28.103]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.103]     if (FALSE) {
[18:06:28.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.103]     }
[18:06:28.103]     ...future.result <- base::tryCatch({
[18:06:28.103]         base::withCallingHandlers({
[18:06:28.103]             ...future.value <- base::withVisible(base::local({
[18:06:28.103]                 ...future.makeSendCondition <- base::local({
[18:06:28.103]                   sendCondition <- NULL
[18:06:28.103]                   function(frame = 1L) {
[18:06:28.103]                     if (is.function(sendCondition)) 
[18:06:28.103]                       return(sendCondition)
[18:06:28.103]                     ns <- getNamespace("parallel")
[18:06:28.103]                     if (exists("sendData", mode = "function", 
[18:06:28.103]                       envir = ns)) {
[18:06:28.103]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.103]                         envir = ns)
[18:06:28.103]                       envir <- sys.frame(frame)
[18:06:28.103]                       master <- NULL
[18:06:28.103]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.103]                         !identical(envir, emptyenv())) {
[18:06:28.103]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.103]                           inherits = FALSE)) {
[18:06:28.103]                           master <- get("master", mode = "list", 
[18:06:28.103]                             envir = envir, inherits = FALSE)
[18:06:28.103]                           if (inherits(master, c("SOCKnode", 
[18:06:28.103]                             "SOCK0node"))) {
[18:06:28.103]                             sendCondition <<- function(cond) {
[18:06:28.103]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.103]                                 success = TRUE)
[18:06:28.103]                               parallel_sendData(master, data)
[18:06:28.103]                             }
[18:06:28.103]                             return(sendCondition)
[18:06:28.103]                           }
[18:06:28.103]                         }
[18:06:28.103]                         frame <- frame + 1L
[18:06:28.103]                         envir <- sys.frame(frame)
[18:06:28.103]                       }
[18:06:28.103]                     }
[18:06:28.103]                     sendCondition <<- function(cond) NULL
[18:06:28.103]                   }
[18:06:28.103]                 })
[18:06:28.103]                 withCallingHandlers({
[18:06:28.103]                   2
[18:06:28.103]                 }, immediateCondition = function(cond) {
[18:06:28.103]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.103]                   sendCondition(cond)
[18:06:28.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.103]                   {
[18:06:28.103]                     inherits <- base::inherits
[18:06:28.103]                     invokeRestart <- base::invokeRestart
[18:06:28.103]                     is.null <- base::is.null
[18:06:28.103]                     muffled <- FALSE
[18:06:28.103]                     if (inherits(cond, "message")) {
[18:06:28.103]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.103]                       if (muffled) 
[18:06:28.103]                         invokeRestart("muffleMessage")
[18:06:28.103]                     }
[18:06:28.103]                     else if (inherits(cond, "warning")) {
[18:06:28.103]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.103]                       if (muffled) 
[18:06:28.103]                         invokeRestart("muffleWarning")
[18:06:28.103]                     }
[18:06:28.103]                     else if (inherits(cond, "condition")) {
[18:06:28.103]                       if (!is.null(pattern)) {
[18:06:28.103]                         computeRestarts <- base::computeRestarts
[18:06:28.103]                         grepl <- base::grepl
[18:06:28.103]                         restarts <- computeRestarts(cond)
[18:06:28.103]                         for (restart in restarts) {
[18:06:28.103]                           name <- restart$name
[18:06:28.103]                           if (is.null(name)) 
[18:06:28.103]                             next
[18:06:28.103]                           if (!grepl(pattern, name)) 
[18:06:28.103]                             next
[18:06:28.103]                           invokeRestart(restart)
[18:06:28.103]                           muffled <- TRUE
[18:06:28.103]                           break
[18:06:28.103]                         }
[18:06:28.103]                       }
[18:06:28.103]                     }
[18:06:28.103]                     invisible(muffled)
[18:06:28.103]                   }
[18:06:28.103]                   muffleCondition(cond)
[18:06:28.103]                 })
[18:06:28.103]             }))
[18:06:28.103]             future::FutureResult(value = ...future.value$value, 
[18:06:28.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.103]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.103]                     ...future.globalenv.names))
[18:06:28.103]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.103]         }, condition = base::local({
[18:06:28.103]             c <- base::c
[18:06:28.103]             inherits <- base::inherits
[18:06:28.103]             invokeRestart <- base::invokeRestart
[18:06:28.103]             length <- base::length
[18:06:28.103]             list <- base::list
[18:06:28.103]             seq.int <- base::seq.int
[18:06:28.103]             signalCondition <- base::signalCondition
[18:06:28.103]             sys.calls <- base::sys.calls
[18:06:28.103]             `[[` <- base::`[[`
[18:06:28.103]             `+` <- base::`+`
[18:06:28.103]             `<<-` <- base::`<<-`
[18:06:28.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.103]                   3L)]
[18:06:28.103]             }
[18:06:28.103]             function(cond) {
[18:06:28.103]                 is_error <- inherits(cond, "error")
[18:06:28.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.103]                   NULL)
[18:06:28.103]                 if (is_error) {
[18:06:28.103]                   sessionInformation <- function() {
[18:06:28.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.103]                       search = base::search(), system = base::Sys.info())
[18:06:28.103]                   }
[18:06:28.103]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.103]                     cond$call), session = sessionInformation(), 
[18:06:28.103]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.103]                   signalCondition(cond)
[18:06:28.103]                 }
[18:06:28.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.103]                 "immediateCondition"))) {
[18:06:28.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.103]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.103]                   if (TRUE && !signal) {
[18:06:28.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.103]                     {
[18:06:28.103]                       inherits <- base::inherits
[18:06:28.103]                       invokeRestart <- base::invokeRestart
[18:06:28.103]                       is.null <- base::is.null
[18:06:28.103]                       muffled <- FALSE
[18:06:28.103]                       if (inherits(cond, "message")) {
[18:06:28.103]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.103]                         if (muffled) 
[18:06:28.103]                           invokeRestart("muffleMessage")
[18:06:28.103]                       }
[18:06:28.103]                       else if (inherits(cond, "warning")) {
[18:06:28.103]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.103]                         if (muffled) 
[18:06:28.103]                           invokeRestart("muffleWarning")
[18:06:28.103]                       }
[18:06:28.103]                       else if (inherits(cond, "condition")) {
[18:06:28.103]                         if (!is.null(pattern)) {
[18:06:28.103]                           computeRestarts <- base::computeRestarts
[18:06:28.103]                           grepl <- base::grepl
[18:06:28.103]                           restarts <- computeRestarts(cond)
[18:06:28.103]                           for (restart in restarts) {
[18:06:28.103]                             name <- restart$name
[18:06:28.103]                             if (is.null(name)) 
[18:06:28.103]                               next
[18:06:28.103]                             if (!grepl(pattern, name)) 
[18:06:28.103]                               next
[18:06:28.103]                             invokeRestart(restart)
[18:06:28.103]                             muffled <- TRUE
[18:06:28.103]                             break
[18:06:28.103]                           }
[18:06:28.103]                         }
[18:06:28.103]                       }
[18:06:28.103]                       invisible(muffled)
[18:06:28.103]                     }
[18:06:28.103]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.103]                   }
[18:06:28.103]                 }
[18:06:28.103]                 else {
[18:06:28.103]                   if (TRUE) {
[18:06:28.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.103]                     {
[18:06:28.103]                       inherits <- base::inherits
[18:06:28.103]                       invokeRestart <- base::invokeRestart
[18:06:28.103]                       is.null <- base::is.null
[18:06:28.103]                       muffled <- FALSE
[18:06:28.103]                       if (inherits(cond, "message")) {
[18:06:28.103]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.103]                         if (muffled) 
[18:06:28.103]                           invokeRestart("muffleMessage")
[18:06:28.103]                       }
[18:06:28.103]                       else if (inherits(cond, "warning")) {
[18:06:28.103]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.103]                         if (muffled) 
[18:06:28.103]                           invokeRestart("muffleWarning")
[18:06:28.103]                       }
[18:06:28.103]                       else if (inherits(cond, "condition")) {
[18:06:28.103]                         if (!is.null(pattern)) {
[18:06:28.103]                           computeRestarts <- base::computeRestarts
[18:06:28.103]                           grepl <- base::grepl
[18:06:28.103]                           restarts <- computeRestarts(cond)
[18:06:28.103]                           for (restart in restarts) {
[18:06:28.103]                             name <- restart$name
[18:06:28.103]                             if (is.null(name)) 
[18:06:28.103]                               next
[18:06:28.103]                             if (!grepl(pattern, name)) 
[18:06:28.103]                               next
[18:06:28.103]                             invokeRestart(restart)
[18:06:28.103]                             muffled <- TRUE
[18:06:28.103]                             break
[18:06:28.103]                           }
[18:06:28.103]                         }
[18:06:28.103]                       }
[18:06:28.103]                       invisible(muffled)
[18:06:28.103]                     }
[18:06:28.103]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.103]                   }
[18:06:28.103]                 }
[18:06:28.103]             }
[18:06:28.103]         }))
[18:06:28.103]     }, error = function(ex) {
[18:06:28.103]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.103]                 ...future.rng), started = ...future.startTime, 
[18:06:28.103]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.103]             version = "1.8"), class = "FutureResult")
[18:06:28.103]     }, finally = {
[18:06:28.103]         if (!identical(...future.workdir, getwd())) 
[18:06:28.103]             setwd(...future.workdir)
[18:06:28.103]         {
[18:06:28.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.103]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.103]             }
[18:06:28.103]             base::options(...future.oldOptions)
[18:06:28.103]             if (.Platform$OS.type == "windows") {
[18:06:28.103]                 old_names <- names(...future.oldEnvVars)
[18:06:28.103]                 envs <- base::Sys.getenv()
[18:06:28.103]                 names <- names(envs)
[18:06:28.103]                 common <- intersect(names, old_names)
[18:06:28.103]                 added <- setdiff(names, old_names)
[18:06:28.103]                 removed <- setdiff(old_names, names)
[18:06:28.103]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.103]                   envs[common]]
[18:06:28.103]                 NAMES <- toupper(changed)
[18:06:28.103]                 args <- list()
[18:06:28.103]                 for (kk in seq_along(NAMES)) {
[18:06:28.103]                   name <- changed[[kk]]
[18:06:28.103]                   NAME <- NAMES[[kk]]
[18:06:28.103]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.103]                     next
[18:06:28.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.103]                 }
[18:06:28.103]                 NAMES <- toupper(added)
[18:06:28.103]                 for (kk in seq_along(NAMES)) {
[18:06:28.103]                   name <- added[[kk]]
[18:06:28.103]                   NAME <- NAMES[[kk]]
[18:06:28.103]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.103]                     next
[18:06:28.103]                   args[[name]] <- ""
[18:06:28.103]                 }
[18:06:28.103]                 NAMES <- toupper(removed)
[18:06:28.103]                 for (kk in seq_along(NAMES)) {
[18:06:28.103]                   name <- removed[[kk]]
[18:06:28.103]                   NAME <- NAMES[[kk]]
[18:06:28.103]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.103]                     next
[18:06:28.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.103]                 }
[18:06:28.103]                 if (length(args) > 0) 
[18:06:28.103]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.103]             }
[18:06:28.103]             else {
[18:06:28.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.103]             }
[18:06:28.103]             {
[18:06:28.103]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.103]                   0L) {
[18:06:28.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.103]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.103]                   base::options(opts)
[18:06:28.103]                 }
[18:06:28.103]                 {
[18:06:28.103]                   {
[18:06:28.103]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.103]                     NULL
[18:06:28.103]                   }
[18:06:28.103]                   options(future.plan = NULL)
[18:06:28.103]                   if (is.na(NA_character_)) 
[18:06:28.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.103]                     .init = FALSE)
[18:06:28.103]                 }
[18:06:28.103]             }
[18:06:28.103]         }
[18:06:28.103]     })
[18:06:28.103]     if (TRUE) {
[18:06:28.103]         base::sink(type = "output", split = FALSE)
[18:06:28.103]         if (TRUE) {
[18:06:28.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.103]         }
[18:06:28.103]         else {
[18:06:28.103]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.103]         }
[18:06:28.103]         base::close(...future.stdout)
[18:06:28.103]         ...future.stdout <- NULL
[18:06:28.103]     }
[18:06:28.103]     ...future.result$conditions <- ...future.conditions
[18:06:28.103]     ...future.result$finished <- base::Sys.time()
[18:06:28.103]     ...future.result
[18:06:28.103] }
[18:06:28.107] Poll #1 (0): usedNodes() = 2, workers = 2
[18:06:28.118] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.118] - Validating connection of MultisessionFuture
[18:06:28.119] - received message: FutureResult
[18:06:28.119] - Received FutureResult
[18:06:28.119] - Erased future from FutureRegistry
[18:06:28.119] result() for ClusterFuture ...
[18:06:28.120] - result already collected: FutureResult
[18:06:28.120] result() for ClusterFuture ... done
[18:06:28.120] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.120] result() for ClusterFuture ...
[18:06:28.120] - result already collected: FutureResult
[18:06:28.121] result() for ClusterFuture ... done
[18:06:28.121] result() for ClusterFuture ...
[18:06:28.121] - result already collected: FutureResult
[18:06:28.121] result() for ClusterFuture ... done
[18:06:28.123] MultisessionFuture started
[18:06:28.123] - Launch lazy future ... done
[18:06:28.124] run() for ‘MultisessionFuture’ ... done
[18:06:28.124] resolve() on list ...
[18:06:28.124]  recursive: 0
[18:06:28.124]  length: 3
[18:06:28.125]  elements: ‘a’, ‘b’, ‘’
[18:06:28.126] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.126] - Validating connection of MultisessionFuture
[18:06:28.126] - received message: FutureResult
[18:06:28.126] - Received FutureResult
[18:06:28.127] - Erased future from FutureRegistry
[18:06:28.127] result() for ClusterFuture ...
[18:06:28.127] - result already collected: FutureResult
[18:06:28.127] result() for ClusterFuture ... done
[18:06:28.127] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.128] Future #1
[18:06:28.128]  length: 2 (resolved future 1)
[18:06:28.139]  length: 1 (resolved future 3)
[18:06:28.172] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.172] - Validating connection of MultisessionFuture
[18:06:28.172] - received message: FutureResult
[18:06:28.173] - Received FutureResult
[18:06:28.173] - Erased future from FutureRegistry
[18:06:28.173] result() for ClusterFuture ...
[18:06:28.173] - result already collected: FutureResult
[18:06:28.173] result() for ClusterFuture ... done
[18:06:28.174] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.174] Future #2
[18:06:28.174]  length: 0 (resolved future 2)
[18:06:28.174] resolve() on list ... DONE
[18:06:28.174] getGlobalsAndPackages() ...
[18:06:28.175] Searching for globals...
[18:06:28.175] 
[18:06:28.175] Searching for globals ... DONE
[18:06:28.176] - globals: [0] <none>
[18:06:28.176] getGlobalsAndPackages() ... DONE
[18:06:28.176] getGlobalsAndPackages() ...
[18:06:28.177] Searching for globals...
[18:06:28.177] 
[18:06:28.177] Searching for globals ... DONE
[18:06:28.178] - globals: [0] <none>
[18:06:28.178] getGlobalsAndPackages() ... DONE
[18:06:28.178] run() for ‘Future’ ...
[18:06:28.178] - state: ‘created’
[18:06:28.179] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.202] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.203]   - Field: ‘node’
[18:06:28.203]   - Field: ‘label’
[18:06:28.203]   - Field: ‘local’
[18:06:28.203]   - Field: ‘owner’
[18:06:28.203]   - Field: ‘envir’
[18:06:28.204]   - Field: ‘workers’
[18:06:28.204]   - Field: ‘packages’
[18:06:28.204]   - Field: ‘gc’
[18:06:28.204]   - Field: ‘conditions’
[18:06:28.204]   - Field: ‘persistent’
[18:06:28.205]   - Field: ‘expr’
[18:06:28.205]   - Field: ‘uuid’
[18:06:28.205]   - Field: ‘seed’
[18:06:28.205]   - Field: ‘version’
[18:06:28.205]   - Field: ‘result’
[18:06:28.206]   - Field: ‘asynchronous’
[18:06:28.206]   - Field: ‘calls’
[18:06:28.206]   - Field: ‘globals’
[18:06:28.206]   - Field: ‘stdout’
[18:06:28.206]   - Field: ‘earlySignal’
[18:06:28.207]   - Field: ‘lazy’
[18:06:28.207]   - Field: ‘state’
[18:06:28.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.207] - Launch lazy future ...
[18:06:28.208] Packages needed by the future expression (n = 0): <none>
[18:06:28.208] Packages needed by future strategies (n = 0): <none>
[18:06:28.209] {
[18:06:28.209]     {
[18:06:28.209]         {
[18:06:28.209]             ...future.startTime <- base::Sys.time()
[18:06:28.209]             {
[18:06:28.209]                 {
[18:06:28.209]                   {
[18:06:28.209]                     {
[18:06:28.209]                       base::local({
[18:06:28.209]                         has_future <- base::requireNamespace("future", 
[18:06:28.209]                           quietly = TRUE)
[18:06:28.209]                         if (has_future) {
[18:06:28.209]                           ns <- base::getNamespace("future")
[18:06:28.209]                           version <- ns[[".package"]][["version"]]
[18:06:28.209]                           if (is.null(version)) 
[18:06:28.209]                             version <- utils::packageVersion("future")
[18:06:28.209]                         }
[18:06:28.209]                         else {
[18:06:28.209]                           version <- NULL
[18:06:28.209]                         }
[18:06:28.209]                         if (!has_future || version < "1.8.0") {
[18:06:28.209]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.209]                             "", base::R.version$version.string), 
[18:06:28.209]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.209]                               "release", "version")], collapse = " "), 
[18:06:28.209]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.209]                             info)
[18:06:28.209]                           info <- base::paste(info, collapse = "; ")
[18:06:28.209]                           if (!has_future) {
[18:06:28.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.209]                               info)
[18:06:28.209]                           }
[18:06:28.209]                           else {
[18:06:28.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.209]                               info, version)
[18:06:28.209]                           }
[18:06:28.209]                           base::stop(msg)
[18:06:28.209]                         }
[18:06:28.209]                       })
[18:06:28.209]                     }
[18:06:28.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.209]                     base::options(mc.cores = 1L)
[18:06:28.209]                   }
[18:06:28.209]                   ...future.strategy.old <- future::plan("list")
[18:06:28.209]                   options(future.plan = NULL)
[18:06:28.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.209]                 }
[18:06:28.209]                 ...future.workdir <- getwd()
[18:06:28.209]             }
[18:06:28.209]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.209]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.209]         }
[18:06:28.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.209]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.209]             base::names(...future.oldOptions))
[18:06:28.209]     }
[18:06:28.209]     if (FALSE) {
[18:06:28.209]     }
[18:06:28.209]     else {
[18:06:28.209]         if (TRUE) {
[18:06:28.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.209]                 open = "w")
[18:06:28.209]         }
[18:06:28.209]         else {
[18:06:28.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.209]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.209]         }
[18:06:28.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.209]             base::sink(type = "output", split = FALSE)
[18:06:28.209]             base::close(...future.stdout)
[18:06:28.209]         }, add = TRUE)
[18:06:28.209]     }
[18:06:28.209]     ...future.frame <- base::sys.nframe()
[18:06:28.209]     ...future.conditions <- base::list()
[18:06:28.209]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.209]     if (FALSE) {
[18:06:28.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.209]     }
[18:06:28.209]     ...future.result <- base::tryCatch({
[18:06:28.209]         base::withCallingHandlers({
[18:06:28.209]             ...future.value <- base::withVisible(base::local({
[18:06:28.209]                 ...future.makeSendCondition <- base::local({
[18:06:28.209]                   sendCondition <- NULL
[18:06:28.209]                   function(frame = 1L) {
[18:06:28.209]                     if (is.function(sendCondition)) 
[18:06:28.209]                       return(sendCondition)
[18:06:28.209]                     ns <- getNamespace("parallel")
[18:06:28.209]                     if (exists("sendData", mode = "function", 
[18:06:28.209]                       envir = ns)) {
[18:06:28.209]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.209]                         envir = ns)
[18:06:28.209]                       envir <- sys.frame(frame)
[18:06:28.209]                       master <- NULL
[18:06:28.209]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.209]                         !identical(envir, emptyenv())) {
[18:06:28.209]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.209]                           inherits = FALSE)) {
[18:06:28.209]                           master <- get("master", mode = "list", 
[18:06:28.209]                             envir = envir, inherits = FALSE)
[18:06:28.209]                           if (inherits(master, c("SOCKnode", 
[18:06:28.209]                             "SOCK0node"))) {
[18:06:28.209]                             sendCondition <<- function(cond) {
[18:06:28.209]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.209]                                 success = TRUE)
[18:06:28.209]                               parallel_sendData(master, data)
[18:06:28.209]                             }
[18:06:28.209]                             return(sendCondition)
[18:06:28.209]                           }
[18:06:28.209]                         }
[18:06:28.209]                         frame <- frame + 1L
[18:06:28.209]                         envir <- sys.frame(frame)
[18:06:28.209]                       }
[18:06:28.209]                     }
[18:06:28.209]                     sendCondition <<- function(cond) NULL
[18:06:28.209]                   }
[18:06:28.209]                 })
[18:06:28.209]                 withCallingHandlers({
[18:06:28.209]                   2
[18:06:28.209]                 }, immediateCondition = function(cond) {
[18:06:28.209]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.209]                   sendCondition(cond)
[18:06:28.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.209]                   {
[18:06:28.209]                     inherits <- base::inherits
[18:06:28.209]                     invokeRestart <- base::invokeRestart
[18:06:28.209]                     is.null <- base::is.null
[18:06:28.209]                     muffled <- FALSE
[18:06:28.209]                     if (inherits(cond, "message")) {
[18:06:28.209]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.209]                       if (muffled) 
[18:06:28.209]                         invokeRestart("muffleMessage")
[18:06:28.209]                     }
[18:06:28.209]                     else if (inherits(cond, "warning")) {
[18:06:28.209]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.209]                       if (muffled) 
[18:06:28.209]                         invokeRestart("muffleWarning")
[18:06:28.209]                     }
[18:06:28.209]                     else if (inherits(cond, "condition")) {
[18:06:28.209]                       if (!is.null(pattern)) {
[18:06:28.209]                         computeRestarts <- base::computeRestarts
[18:06:28.209]                         grepl <- base::grepl
[18:06:28.209]                         restarts <- computeRestarts(cond)
[18:06:28.209]                         for (restart in restarts) {
[18:06:28.209]                           name <- restart$name
[18:06:28.209]                           if (is.null(name)) 
[18:06:28.209]                             next
[18:06:28.209]                           if (!grepl(pattern, name)) 
[18:06:28.209]                             next
[18:06:28.209]                           invokeRestart(restart)
[18:06:28.209]                           muffled <- TRUE
[18:06:28.209]                           break
[18:06:28.209]                         }
[18:06:28.209]                       }
[18:06:28.209]                     }
[18:06:28.209]                     invisible(muffled)
[18:06:28.209]                   }
[18:06:28.209]                   muffleCondition(cond)
[18:06:28.209]                 })
[18:06:28.209]             }))
[18:06:28.209]             future::FutureResult(value = ...future.value$value, 
[18:06:28.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.209]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.209]                     ...future.globalenv.names))
[18:06:28.209]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.209]         }, condition = base::local({
[18:06:28.209]             c <- base::c
[18:06:28.209]             inherits <- base::inherits
[18:06:28.209]             invokeRestart <- base::invokeRestart
[18:06:28.209]             length <- base::length
[18:06:28.209]             list <- base::list
[18:06:28.209]             seq.int <- base::seq.int
[18:06:28.209]             signalCondition <- base::signalCondition
[18:06:28.209]             sys.calls <- base::sys.calls
[18:06:28.209]             `[[` <- base::`[[`
[18:06:28.209]             `+` <- base::`+`
[18:06:28.209]             `<<-` <- base::`<<-`
[18:06:28.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.209]                   3L)]
[18:06:28.209]             }
[18:06:28.209]             function(cond) {
[18:06:28.209]                 is_error <- inherits(cond, "error")
[18:06:28.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.209]                   NULL)
[18:06:28.209]                 if (is_error) {
[18:06:28.209]                   sessionInformation <- function() {
[18:06:28.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.209]                       search = base::search(), system = base::Sys.info())
[18:06:28.209]                   }
[18:06:28.209]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.209]                     cond$call), session = sessionInformation(), 
[18:06:28.209]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.209]                   signalCondition(cond)
[18:06:28.209]                 }
[18:06:28.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.209]                 "immediateCondition"))) {
[18:06:28.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.209]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.209]                   if (TRUE && !signal) {
[18:06:28.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.209]                     {
[18:06:28.209]                       inherits <- base::inherits
[18:06:28.209]                       invokeRestart <- base::invokeRestart
[18:06:28.209]                       is.null <- base::is.null
[18:06:28.209]                       muffled <- FALSE
[18:06:28.209]                       if (inherits(cond, "message")) {
[18:06:28.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.209]                         if (muffled) 
[18:06:28.209]                           invokeRestart("muffleMessage")
[18:06:28.209]                       }
[18:06:28.209]                       else if (inherits(cond, "warning")) {
[18:06:28.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.209]                         if (muffled) 
[18:06:28.209]                           invokeRestart("muffleWarning")
[18:06:28.209]                       }
[18:06:28.209]                       else if (inherits(cond, "condition")) {
[18:06:28.209]                         if (!is.null(pattern)) {
[18:06:28.209]                           computeRestarts <- base::computeRestarts
[18:06:28.209]                           grepl <- base::grepl
[18:06:28.209]                           restarts <- computeRestarts(cond)
[18:06:28.209]                           for (restart in restarts) {
[18:06:28.209]                             name <- restart$name
[18:06:28.209]                             if (is.null(name)) 
[18:06:28.209]                               next
[18:06:28.209]                             if (!grepl(pattern, name)) 
[18:06:28.209]                               next
[18:06:28.209]                             invokeRestart(restart)
[18:06:28.209]                             muffled <- TRUE
[18:06:28.209]                             break
[18:06:28.209]                           }
[18:06:28.209]                         }
[18:06:28.209]                       }
[18:06:28.209]                       invisible(muffled)
[18:06:28.209]                     }
[18:06:28.209]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.209]                   }
[18:06:28.209]                 }
[18:06:28.209]                 else {
[18:06:28.209]                   if (TRUE) {
[18:06:28.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.209]                     {
[18:06:28.209]                       inherits <- base::inherits
[18:06:28.209]                       invokeRestart <- base::invokeRestart
[18:06:28.209]                       is.null <- base::is.null
[18:06:28.209]                       muffled <- FALSE
[18:06:28.209]                       if (inherits(cond, "message")) {
[18:06:28.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.209]                         if (muffled) 
[18:06:28.209]                           invokeRestart("muffleMessage")
[18:06:28.209]                       }
[18:06:28.209]                       else if (inherits(cond, "warning")) {
[18:06:28.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.209]                         if (muffled) 
[18:06:28.209]                           invokeRestart("muffleWarning")
[18:06:28.209]                       }
[18:06:28.209]                       else if (inherits(cond, "condition")) {
[18:06:28.209]                         if (!is.null(pattern)) {
[18:06:28.209]                           computeRestarts <- base::computeRestarts
[18:06:28.209]                           grepl <- base::grepl
[18:06:28.209]                           restarts <- computeRestarts(cond)
[18:06:28.209]                           for (restart in restarts) {
[18:06:28.209]                             name <- restart$name
[18:06:28.209]                             if (is.null(name)) 
[18:06:28.209]                               next
[18:06:28.209]                             if (!grepl(pattern, name)) 
[18:06:28.209]                               next
[18:06:28.209]                             invokeRestart(restart)
[18:06:28.209]                             muffled <- TRUE
[18:06:28.209]                             break
[18:06:28.209]                           }
[18:06:28.209]                         }
[18:06:28.209]                       }
[18:06:28.209]                       invisible(muffled)
[18:06:28.209]                     }
[18:06:28.209]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.209]                   }
[18:06:28.209]                 }
[18:06:28.209]             }
[18:06:28.209]         }))
[18:06:28.209]     }, error = function(ex) {
[18:06:28.209]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.209]                 ...future.rng), started = ...future.startTime, 
[18:06:28.209]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.209]             version = "1.8"), class = "FutureResult")
[18:06:28.209]     }, finally = {
[18:06:28.209]         if (!identical(...future.workdir, getwd())) 
[18:06:28.209]             setwd(...future.workdir)
[18:06:28.209]         {
[18:06:28.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.209]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.209]             }
[18:06:28.209]             base::options(...future.oldOptions)
[18:06:28.209]             if (.Platform$OS.type == "windows") {
[18:06:28.209]                 old_names <- names(...future.oldEnvVars)
[18:06:28.209]                 envs <- base::Sys.getenv()
[18:06:28.209]                 names <- names(envs)
[18:06:28.209]                 common <- intersect(names, old_names)
[18:06:28.209]                 added <- setdiff(names, old_names)
[18:06:28.209]                 removed <- setdiff(old_names, names)
[18:06:28.209]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.209]                   envs[common]]
[18:06:28.209]                 NAMES <- toupper(changed)
[18:06:28.209]                 args <- list()
[18:06:28.209]                 for (kk in seq_along(NAMES)) {
[18:06:28.209]                   name <- changed[[kk]]
[18:06:28.209]                   NAME <- NAMES[[kk]]
[18:06:28.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.209]                     next
[18:06:28.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.209]                 }
[18:06:28.209]                 NAMES <- toupper(added)
[18:06:28.209]                 for (kk in seq_along(NAMES)) {
[18:06:28.209]                   name <- added[[kk]]
[18:06:28.209]                   NAME <- NAMES[[kk]]
[18:06:28.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.209]                     next
[18:06:28.209]                   args[[name]] <- ""
[18:06:28.209]                 }
[18:06:28.209]                 NAMES <- toupper(removed)
[18:06:28.209]                 for (kk in seq_along(NAMES)) {
[18:06:28.209]                   name <- removed[[kk]]
[18:06:28.209]                   NAME <- NAMES[[kk]]
[18:06:28.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.209]                     next
[18:06:28.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.209]                 }
[18:06:28.209]                 if (length(args) > 0) 
[18:06:28.209]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.209]             }
[18:06:28.209]             else {
[18:06:28.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.209]             }
[18:06:28.209]             {
[18:06:28.209]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.209]                   0L) {
[18:06:28.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.209]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.209]                   base::options(opts)
[18:06:28.209]                 }
[18:06:28.209]                 {
[18:06:28.209]                   {
[18:06:28.209]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.209]                     NULL
[18:06:28.209]                   }
[18:06:28.209]                   options(future.plan = NULL)
[18:06:28.209]                   if (is.na(NA_character_)) 
[18:06:28.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.209]                     .init = FALSE)
[18:06:28.209]                 }
[18:06:28.209]             }
[18:06:28.209]         }
[18:06:28.209]     })
[18:06:28.209]     if (TRUE) {
[18:06:28.209]         base::sink(type = "output", split = FALSE)
[18:06:28.209]         if (TRUE) {
[18:06:28.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.209]         }
[18:06:28.209]         else {
[18:06:28.209]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.209]         }
[18:06:28.209]         base::close(...future.stdout)
[18:06:28.209]         ...future.stdout <- NULL
[18:06:28.209]     }
[18:06:28.209]     ...future.result$conditions <- ...future.conditions
[18:06:28.209]     ...future.result$finished <- base::Sys.time()
[18:06:28.209]     ...future.result
[18:06:28.209] }
[18:06:28.215] MultisessionFuture started
[18:06:28.215] - Launch lazy future ... done
[18:06:28.215] run() for ‘MultisessionFuture’ ... done
[18:06:28.215] resolve() on list ...
[18:06:28.216]  recursive: 0
[18:06:28.216]  length: 3
[18:06:28.216]  elements: ‘a’, ‘b’, ‘’
[18:06:28.216] run() for ‘Future’ ...
[18:06:28.216] - state: ‘created’
[18:06:28.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.241] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.242]   - Field: ‘node’
[18:06:28.242]   - Field: ‘label’
[18:06:28.242]   - Field: ‘local’
[18:06:28.243]   - Field: ‘owner’
[18:06:28.243]   - Field: ‘envir’
[18:06:28.243]   - Field: ‘workers’
[18:06:28.243]   - Field: ‘packages’
[18:06:28.243]   - Field: ‘gc’
[18:06:28.244]   - Field: ‘conditions’
[18:06:28.244]   - Field: ‘persistent’
[18:06:28.244]   - Field: ‘expr’
[18:06:28.244]   - Field: ‘uuid’
[18:06:28.244]   - Field: ‘seed’
[18:06:28.245]   - Field: ‘version’
[18:06:28.245]   - Field: ‘result’
[18:06:28.245]   - Field: ‘asynchronous’
[18:06:28.245]   - Field: ‘calls’
[18:06:28.245]   - Field: ‘globals’
[18:06:28.246]   - Field: ‘stdout’
[18:06:28.246]   - Field: ‘earlySignal’
[18:06:28.246]   - Field: ‘lazy’
[18:06:28.246]   - Field: ‘state’
[18:06:28.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.247] - Launch lazy future ...
[18:06:28.247] Packages needed by the future expression (n = 0): <none>
[18:06:28.247] Packages needed by future strategies (n = 0): <none>
[18:06:28.248] {
[18:06:28.248]     {
[18:06:28.248]         {
[18:06:28.248]             ...future.startTime <- base::Sys.time()
[18:06:28.248]             {
[18:06:28.248]                 {
[18:06:28.248]                   {
[18:06:28.248]                     {
[18:06:28.248]                       base::local({
[18:06:28.248]                         has_future <- base::requireNamespace("future", 
[18:06:28.248]                           quietly = TRUE)
[18:06:28.248]                         if (has_future) {
[18:06:28.248]                           ns <- base::getNamespace("future")
[18:06:28.248]                           version <- ns[[".package"]][["version"]]
[18:06:28.248]                           if (is.null(version)) 
[18:06:28.248]                             version <- utils::packageVersion("future")
[18:06:28.248]                         }
[18:06:28.248]                         else {
[18:06:28.248]                           version <- NULL
[18:06:28.248]                         }
[18:06:28.248]                         if (!has_future || version < "1.8.0") {
[18:06:28.248]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.248]                             "", base::R.version$version.string), 
[18:06:28.248]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.248]                               "release", "version")], collapse = " "), 
[18:06:28.248]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.248]                             info)
[18:06:28.248]                           info <- base::paste(info, collapse = "; ")
[18:06:28.248]                           if (!has_future) {
[18:06:28.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.248]                               info)
[18:06:28.248]                           }
[18:06:28.248]                           else {
[18:06:28.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.248]                               info, version)
[18:06:28.248]                           }
[18:06:28.248]                           base::stop(msg)
[18:06:28.248]                         }
[18:06:28.248]                       })
[18:06:28.248]                     }
[18:06:28.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.248]                     base::options(mc.cores = 1L)
[18:06:28.248]                   }
[18:06:28.248]                   ...future.strategy.old <- future::plan("list")
[18:06:28.248]                   options(future.plan = NULL)
[18:06:28.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.248]                 }
[18:06:28.248]                 ...future.workdir <- getwd()
[18:06:28.248]             }
[18:06:28.248]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.248]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.248]         }
[18:06:28.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.248]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.248]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.248]             base::names(...future.oldOptions))
[18:06:28.248]     }
[18:06:28.248]     if (FALSE) {
[18:06:28.248]     }
[18:06:28.248]     else {
[18:06:28.248]         if (TRUE) {
[18:06:28.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.248]                 open = "w")
[18:06:28.248]         }
[18:06:28.248]         else {
[18:06:28.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.248]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.248]         }
[18:06:28.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.248]             base::sink(type = "output", split = FALSE)
[18:06:28.248]             base::close(...future.stdout)
[18:06:28.248]         }, add = TRUE)
[18:06:28.248]     }
[18:06:28.248]     ...future.frame <- base::sys.nframe()
[18:06:28.248]     ...future.conditions <- base::list()
[18:06:28.248]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.248]     if (FALSE) {
[18:06:28.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.248]     }
[18:06:28.248]     ...future.result <- base::tryCatch({
[18:06:28.248]         base::withCallingHandlers({
[18:06:28.248]             ...future.value <- base::withVisible(base::local({
[18:06:28.248]                 ...future.makeSendCondition <- base::local({
[18:06:28.248]                   sendCondition <- NULL
[18:06:28.248]                   function(frame = 1L) {
[18:06:28.248]                     if (is.function(sendCondition)) 
[18:06:28.248]                       return(sendCondition)
[18:06:28.248]                     ns <- getNamespace("parallel")
[18:06:28.248]                     if (exists("sendData", mode = "function", 
[18:06:28.248]                       envir = ns)) {
[18:06:28.248]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.248]                         envir = ns)
[18:06:28.248]                       envir <- sys.frame(frame)
[18:06:28.248]                       master <- NULL
[18:06:28.248]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.248]                         !identical(envir, emptyenv())) {
[18:06:28.248]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.248]                           inherits = FALSE)) {
[18:06:28.248]                           master <- get("master", mode = "list", 
[18:06:28.248]                             envir = envir, inherits = FALSE)
[18:06:28.248]                           if (inherits(master, c("SOCKnode", 
[18:06:28.248]                             "SOCK0node"))) {
[18:06:28.248]                             sendCondition <<- function(cond) {
[18:06:28.248]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.248]                                 success = TRUE)
[18:06:28.248]                               parallel_sendData(master, data)
[18:06:28.248]                             }
[18:06:28.248]                             return(sendCondition)
[18:06:28.248]                           }
[18:06:28.248]                         }
[18:06:28.248]                         frame <- frame + 1L
[18:06:28.248]                         envir <- sys.frame(frame)
[18:06:28.248]                       }
[18:06:28.248]                     }
[18:06:28.248]                     sendCondition <<- function(cond) NULL
[18:06:28.248]                   }
[18:06:28.248]                 })
[18:06:28.248]                 withCallingHandlers({
[18:06:28.248]                   1
[18:06:28.248]                 }, immediateCondition = function(cond) {
[18:06:28.248]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.248]                   sendCondition(cond)
[18:06:28.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.248]                   {
[18:06:28.248]                     inherits <- base::inherits
[18:06:28.248]                     invokeRestart <- base::invokeRestart
[18:06:28.248]                     is.null <- base::is.null
[18:06:28.248]                     muffled <- FALSE
[18:06:28.248]                     if (inherits(cond, "message")) {
[18:06:28.248]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.248]                       if (muffled) 
[18:06:28.248]                         invokeRestart("muffleMessage")
[18:06:28.248]                     }
[18:06:28.248]                     else if (inherits(cond, "warning")) {
[18:06:28.248]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.248]                       if (muffled) 
[18:06:28.248]                         invokeRestart("muffleWarning")
[18:06:28.248]                     }
[18:06:28.248]                     else if (inherits(cond, "condition")) {
[18:06:28.248]                       if (!is.null(pattern)) {
[18:06:28.248]                         computeRestarts <- base::computeRestarts
[18:06:28.248]                         grepl <- base::grepl
[18:06:28.248]                         restarts <- computeRestarts(cond)
[18:06:28.248]                         for (restart in restarts) {
[18:06:28.248]                           name <- restart$name
[18:06:28.248]                           if (is.null(name)) 
[18:06:28.248]                             next
[18:06:28.248]                           if (!grepl(pattern, name)) 
[18:06:28.248]                             next
[18:06:28.248]                           invokeRestart(restart)
[18:06:28.248]                           muffled <- TRUE
[18:06:28.248]                           break
[18:06:28.248]                         }
[18:06:28.248]                       }
[18:06:28.248]                     }
[18:06:28.248]                     invisible(muffled)
[18:06:28.248]                   }
[18:06:28.248]                   muffleCondition(cond)
[18:06:28.248]                 })
[18:06:28.248]             }))
[18:06:28.248]             future::FutureResult(value = ...future.value$value, 
[18:06:28.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.248]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.248]                     ...future.globalenv.names))
[18:06:28.248]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.248]         }, condition = base::local({
[18:06:28.248]             c <- base::c
[18:06:28.248]             inherits <- base::inherits
[18:06:28.248]             invokeRestart <- base::invokeRestart
[18:06:28.248]             length <- base::length
[18:06:28.248]             list <- base::list
[18:06:28.248]             seq.int <- base::seq.int
[18:06:28.248]             signalCondition <- base::signalCondition
[18:06:28.248]             sys.calls <- base::sys.calls
[18:06:28.248]             `[[` <- base::`[[`
[18:06:28.248]             `+` <- base::`+`
[18:06:28.248]             `<<-` <- base::`<<-`
[18:06:28.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.248]                   3L)]
[18:06:28.248]             }
[18:06:28.248]             function(cond) {
[18:06:28.248]                 is_error <- inherits(cond, "error")
[18:06:28.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.248]                   NULL)
[18:06:28.248]                 if (is_error) {
[18:06:28.248]                   sessionInformation <- function() {
[18:06:28.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.248]                       search = base::search(), system = base::Sys.info())
[18:06:28.248]                   }
[18:06:28.248]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.248]                     cond$call), session = sessionInformation(), 
[18:06:28.248]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.248]                   signalCondition(cond)
[18:06:28.248]                 }
[18:06:28.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.248]                 "immediateCondition"))) {
[18:06:28.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.248]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.248]                   if (TRUE && !signal) {
[18:06:28.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.248]                     {
[18:06:28.248]                       inherits <- base::inherits
[18:06:28.248]                       invokeRestart <- base::invokeRestart
[18:06:28.248]                       is.null <- base::is.null
[18:06:28.248]                       muffled <- FALSE
[18:06:28.248]                       if (inherits(cond, "message")) {
[18:06:28.248]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.248]                         if (muffled) 
[18:06:28.248]                           invokeRestart("muffleMessage")
[18:06:28.248]                       }
[18:06:28.248]                       else if (inherits(cond, "warning")) {
[18:06:28.248]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.248]                         if (muffled) 
[18:06:28.248]                           invokeRestart("muffleWarning")
[18:06:28.248]                       }
[18:06:28.248]                       else if (inherits(cond, "condition")) {
[18:06:28.248]                         if (!is.null(pattern)) {
[18:06:28.248]                           computeRestarts <- base::computeRestarts
[18:06:28.248]                           grepl <- base::grepl
[18:06:28.248]                           restarts <- computeRestarts(cond)
[18:06:28.248]                           for (restart in restarts) {
[18:06:28.248]                             name <- restart$name
[18:06:28.248]                             if (is.null(name)) 
[18:06:28.248]                               next
[18:06:28.248]                             if (!grepl(pattern, name)) 
[18:06:28.248]                               next
[18:06:28.248]                             invokeRestart(restart)
[18:06:28.248]                             muffled <- TRUE
[18:06:28.248]                             break
[18:06:28.248]                           }
[18:06:28.248]                         }
[18:06:28.248]                       }
[18:06:28.248]                       invisible(muffled)
[18:06:28.248]                     }
[18:06:28.248]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.248]                   }
[18:06:28.248]                 }
[18:06:28.248]                 else {
[18:06:28.248]                   if (TRUE) {
[18:06:28.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.248]                     {
[18:06:28.248]                       inherits <- base::inherits
[18:06:28.248]                       invokeRestart <- base::invokeRestart
[18:06:28.248]                       is.null <- base::is.null
[18:06:28.248]                       muffled <- FALSE
[18:06:28.248]                       if (inherits(cond, "message")) {
[18:06:28.248]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.248]                         if (muffled) 
[18:06:28.248]                           invokeRestart("muffleMessage")
[18:06:28.248]                       }
[18:06:28.248]                       else if (inherits(cond, "warning")) {
[18:06:28.248]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.248]                         if (muffled) 
[18:06:28.248]                           invokeRestart("muffleWarning")
[18:06:28.248]                       }
[18:06:28.248]                       else if (inherits(cond, "condition")) {
[18:06:28.248]                         if (!is.null(pattern)) {
[18:06:28.248]                           computeRestarts <- base::computeRestarts
[18:06:28.248]                           grepl <- base::grepl
[18:06:28.248]                           restarts <- computeRestarts(cond)
[18:06:28.248]                           for (restart in restarts) {
[18:06:28.248]                             name <- restart$name
[18:06:28.248]                             if (is.null(name)) 
[18:06:28.248]                               next
[18:06:28.248]                             if (!grepl(pattern, name)) 
[18:06:28.248]                               next
[18:06:28.248]                             invokeRestart(restart)
[18:06:28.248]                             muffled <- TRUE
[18:06:28.248]                             break
[18:06:28.248]                           }
[18:06:28.248]                         }
[18:06:28.248]                       }
[18:06:28.248]                       invisible(muffled)
[18:06:28.248]                     }
[18:06:28.248]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.248]                   }
[18:06:28.248]                 }
[18:06:28.248]             }
[18:06:28.248]         }))
[18:06:28.248]     }, error = function(ex) {
[18:06:28.248]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.248]                 ...future.rng), started = ...future.startTime, 
[18:06:28.248]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.248]             version = "1.8"), class = "FutureResult")
[18:06:28.248]     }, finally = {
[18:06:28.248]         if (!identical(...future.workdir, getwd())) 
[18:06:28.248]             setwd(...future.workdir)
[18:06:28.248]         {
[18:06:28.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.248]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.248]             }
[18:06:28.248]             base::options(...future.oldOptions)
[18:06:28.248]             if (.Platform$OS.type == "windows") {
[18:06:28.248]                 old_names <- names(...future.oldEnvVars)
[18:06:28.248]                 envs <- base::Sys.getenv()
[18:06:28.248]                 names <- names(envs)
[18:06:28.248]                 common <- intersect(names, old_names)
[18:06:28.248]                 added <- setdiff(names, old_names)
[18:06:28.248]                 removed <- setdiff(old_names, names)
[18:06:28.248]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.248]                   envs[common]]
[18:06:28.248]                 NAMES <- toupper(changed)
[18:06:28.248]                 args <- list()
[18:06:28.248]                 for (kk in seq_along(NAMES)) {
[18:06:28.248]                   name <- changed[[kk]]
[18:06:28.248]                   NAME <- NAMES[[kk]]
[18:06:28.248]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.248]                     next
[18:06:28.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.248]                 }
[18:06:28.248]                 NAMES <- toupper(added)
[18:06:28.248]                 for (kk in seq_along(NAMES)) {
[18:06:28.248]                   name <- added[[kk]]
[18:06:28.248]                   NAME <- NAMES[[kk]]
[18:06:28.248]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.248]                     next
[18:06:28.248]                   args[[name]] <- ""
[18:06:28.248]                 }
[18:06:28.248]                 NAMES <- toupper(removed)
[18:06:28.248]                 for (kk in seq_along(NAMES)) {
[18:06:28.248]                   name <- removed[[kk]]
[18:06:28.248]                   NAME <- NAMES[[kk]]
[18:06:28.248]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.248]                     next
[18:06:28.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.248]                 }
[18:06:28.248]                 if (length(args) > 0) 
[18:06:28.248]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.248]             }
[18:06:28.248]             else {
[18:06:28.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.248]             }
[18:06:28.248]             {
[18:06:28.248]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.248]                   0L) {
[18:06:28.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.248]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.248]                   base::options(opts)
[18:06:28.248]                 }
[18:06:28.248]                 {
[18:06:28.248]                   {
[18:06:28.248]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.248]                     NULL
[18:06:28.248]                   }
[18:06:28.248]                   options(future.plan = NULL)
[18:06:28.248]                   if (is.na(NA_character_)) 
[18:06:28.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.248]                     .init = FALSE)
[18:06:28.248]                 }
[18:06:28.248]             }
[18:06:28.248]         }
[18:06:28.248]     })
[18:06:28.248]     if (TRUE) {
[18:06:28.248]         base::sink(type = "output", split = FALSE)
[18:06:28.248]         if (TRUE) {
[18:06:28.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.248]         }
[18:06:28.248]         else {
[18:06:28.248]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.248]         }
[18:06:28.248]         base::close(...future.stdout)
[18:06:28.248]         ...future.stdout <- NULL
[18:06:28.248]     }
[18:06:28.248]     ...future.result$conditions <- ...future.conditions
[18:06:28.248]     ...future.result$finished <- base::Sys.time()
[18:06:28.248]     ...future.result
[18:06:28.248] }
[18:06:28.255] MultisessionFuture started
[18:06:28.255] - Launch lazy future ... done
[18:06:28.255] run() for ‘MultisessionFuture’ ... done
[18:06:28.267] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.268] - Validating connection of MultisessionFuture
[18:06:28.268] - received message: FutureResult
[18:06:28.268] - Received FutureResult
[18:06:28.268] - Erased future from FutureRegistry
[18:06:28.269] result() for ClusterFuture ...
[18:06:28.269] - result already collected: FutureResult
[18:06:28.269] result() for ClusterFuture ... done
[18:06:28.269] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.269] Future #2
[18:06:28.270]  length: 2 (resolved future 2)
[18:06:28.270]  length: 1 (resolved future 3)
[18:06:28.302] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.303] - Validating connection of MultisessionFuture
[18:06:28.303] - received message: FutureResult
[18:06:28.303] - Received FutureResult
[18:06:28.303] - Erased future from FutureRegistry
[18:06:28.304] result() for ClusterFuture ...
[18:06:28.304] - result already collected: FutureResult
[18:06:28.304] result() for ClusterFuture ... done
[18:06:28.304] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.305] Future #1
[18:06:28.305]  length: 0 (resolved future 1)
[18:06:28.305] resolve() on list ... DONE
[18:06:28.305] getGlobalsAndPackages() ...
[18:06:28.306] Searching for globals...
[18:06:28.306] 
[18:06:28.307] Searching for globals ... DONE
[18:06:28.307] - globals: [0] <none>
[18:06:28.307] getGlobalsAndPackages() ... DONE
[18:06:28.308] getGlobalsAndPackages() ...
[18:06:28.308] Searching for globals...
[18:06:28.309] 
[18:06:28.309] Searching for globals ... DONE
[18:06:28.309] - globals: [0] <none>
[18:06:28.309] getGlobalsAndPackages() ... DONE
[18:06:28.310] resolve() on list ...
[18:06:28.310]  recursive: 0
[18:06:28.310]  length: 3
[18:06:28.310]  elements: ‘a’, ‘b’, ‘’
[18:06:28.311] run() for ‘Future’ ...
[18:06:28.311] - state: ‘created’
[18:06:28.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.338] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.339]   - Field: ‘node’
[18:06:28.339]   - Field: ‘label’
[18:06:28.339]   - Field: ‘local’
[18:06:28.339]   - Field: ‘owner’
[18:06:28.339]   - Field: ‘envir’
[18:06:28.340]   - Field: ‘workers’
[18:06:28.340]   - Field: ‘packages’
[18:06:28.340]   - Field: ‘gc’
[18:06:28.340]   - Field: ‘conditions’
[18:06:28.341]   - Field: ‘persistent’
[18:06:28.341]   - Field: ‘expr’
[18:06:28.341]   - Field: ‘uuid’
[18:06:28.341]   - Field: ‘seed’
[18:06:28.341]   - Field: ‘version’
[18:06:28.342]   - Field: ‘result’
[18:06:28.344]   - Field: ‘asynchronous’
[18:06:28.344]   - Field: ‘calls’
[18:06:28.345]   - Field: ‘globals’
[18:06:28.345]   - Field: ‘stdout’
[18:06:28.345]   - Field: ‘earlySignal’
[18:06:28.345]   - Field: ‘lazy’
[18:06:28.346]   - Field: ‘state’
[18:06:28.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.347] - Launch lazy future ...
[18:06:28.348] Packages needed by the future expression (n = 0): <none>
[18:06:28.348] Packages needed by future strategies (n = 0): <none>
[18:06:28.349] {
[18:06:28.349]     {
[18:06:28.349]         {
[18:06:28.349]             ...future.startTime <- base::Sys.time()
[18:06:28.349]             {
[18:06:28.349]                 {
[18:06:28.349]                   {
[18:06:28.349]                     {
[18:06:28.349]                       base::local({
[18:06:28.349]                         has_future <- base::requireNamespace("future", 
[18:06:28.349]                           quietly = TRUE)
[18:06:28.349]                         if (has_future) {
[18:06:28.349]                           ns <- base::getNamespace("future")
[18:06:28.349]                           version <- ns[[".package"]][["version"]]
[18:06:28.349]                           if (is.null(version)) 
[18:06:28.349]                             version <- utils::packageVersion("future")
[18:06:28.349]                         }
[18:06:28.349]                         else {
[18:06:28.349]                           version <- NULL
[18:06:28.349]                         }
[18:06:28.349]                         if (!has_future || version < "1.8.0") {
[18:06:28.349]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.349]                             "", base::R.version$version.string), 
[18:06:28.349]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.349]                               "release", "version")], collapse = " "), 
[18:06:28.349]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.349]                             info)
[18:06:28.349]                           info <- base::paste(info, collapse = "; ")
[18:06:28.349]                           if (!has_future) {
[18:06:28.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.349]                               info)
[18:06:28.349]                           }
[18:06:28.349]                           else {
[18:06:28.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.349]                               info, version)
[18:06:28.349]                           }
[18:06:28.349]                           base::stop(msg)
[18:06:28.349]                         }
[18:06:28.349]                       })
[18:06:28.349]                     }
[18:06:28.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.349]                     base::options(mc.cores = 1L)
[18:06:28.349]                   }
[18:06:28.349]                   ...future.strategy.old <- future::plan("list")
[18:06:28.349]                   options(future.plan = NULL)
[18:06:28.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.349]                 }
[18:06:28.349]                 ...future.workdir <- getwd()
[18:06:28.349]             }
[18:06:28.349]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.349]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.349]         }
[18:06:28.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.349]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.349]             base::names(...future.oldOptions))
[18:06:28.349]     }
[18:06:28.349]     if (FALSE) {
[18:06:28.349]     }
[18:06:28.349]     else {
[18:06:28.349]         if (TRUE) {
[18:06:28.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.349]                 open = "w")
[18:06:28.349]         }
[18:06:28.349]         else {
[18:06:28.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.349]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.349]         }
[18:06:28.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.349]             base::sink(type = "output", split = FALSE)
[18:06:28.349]             base::close(...future.stdout)
[18:06:28.349]         }, add = TRUE)
[18:06:28.349]     }
[18:06:28.349]     ...future.frame <- base::sys.nframe()
[18:06:28.349]     ...future.conditions <- base::list()
[18:06:28.349]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.349]     if (FALSE) {
[18:06:28.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.349]     }
[18:06:28.349]     ...future.result <- base::tryCatch({
[18:06:28.349]         base::withCallingHandlers({
[18:06:28.349]             ...future.value <- base::withVisible(base::local({
[18:06:28.349]                 ...future.makeSendCondition <- base::local({
[18:06:28.349]                   sendCondition <- NULL
[18:06:28.349]                   function(frame = 1L) {
[18:06:28.349]                     if (is.function(sendCondition)) 
[18:06:28.349]                       return(sendCondition)
[18:06:28.349]                     ns <- getNamespace("parallel")
[18:06:28.349]                     if (exists("sendData", mode = "function", 
[18:06:28.349]                       envir = ns)) {
[18:06:28.349]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.349]                         envir = ns)
[18:06:28.349]                       envir <- sys.frame(frame)
[18:06:28.349]                       master <- NULL
[18:06:28.349]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.349]                         !identical(envir, emptyenv())) {
[18:06:28.349]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.349]                           inherits = FALSE)) {
[18:06:28.349]                           master <- get("master", mode = "list", 
[18:06:28.349]                             envir = envir, inherits = FALSE)
[18:06:28.349]                           if (inherits(master, c("SOCKnode", 
[18:06:28.349]                             "SOCK0node"))) {
[18:06:28.349]                             sendCondition <<- function(cond) {
[18:06:28.349]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.349]                                 success = TRUE)
[18:06:28.349]                               parallel_sendData(master, data)
[18:06:28.349]                             }
[18:06:28.349]                             return(sendCondition)
[18:06:28.349]                           }
[18:06:28.349]                         }
[18:06:28.349]                         frame <- frame + 1L
[18:06:28.349]                         envir <- sys.frame(frame)
[18:06:28.349]                       }
[18:06:28.349]                     }
[18:06:28.349]                     sendCondition <<- function(cond) NULL
[18:06:28.349]                   }
[18:06:28.349]                 })
[18:06:28.349]                 withCallingHandlers({
[18:06:28.349]                   1
[18:06:28.349]                 }, immediateCondition = function(cond) {
[18:06:28.349]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.349]                   sendCondition(cond)
[18:06:28.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.349]                   {
[18:06:28.349]                     inherits <- base::inherits
[18:06:28.349]                     invokeRestart <- base::invokeRestart
[18:06:28.349]                     is.null <- base::is.null
[18:06:28.349]                     muffled <- FALSE
[18:06:28.349]                     if (inherits(cond, "message")) {
[18:06:28.349]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.349]                       if (muffled) 
[18:06:28.349]                         invokeRestart("muffleMessage")
[18:06:28.349]                     }
[18:06:28.349]                     else if (inherits(cond, "warning")) {
[18:06:28.349]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.349]                       if (muffled) 
[18:06:28.349]                         invokeRestart("muffleWarning")
[18:06:28.349]                     }
[18:06:28.349]                     else if (inherits(cond, "condition")) {
[18:06:28.349]                       if (!is.null(pattern)) {
[18:06:28.349]                         computeRestarts <- base::computeRestarts
[18:06:28.349]                         grepl <- base::grepl
[18:06:28.349]                         restarts <- computeRestarts(cond)
[18:06:28.349]                         for (restart in restarts) {
[18:06:28.349]                           name <- restart$name
[18:06:28.349]                           if (is.null(name)) 
[18:06:28.349]                             next
[18:06:28.349]                           if (!grepl(pattern, name)) 
[18:06:28.349]                             next
[18:06:28.349]                           invokeRestart(restart)
[18:06:28.349]                           muffled <- TRUE
[18:06:28.349]                           break
[18:06:28.349]                         }
[18:06:28.349]                       }
[18:06:28.349]                     }
[18:06:28.349]                     invisible(muffled)
[18:06:28.349]                   }
[18:06:28.349]                   muffleCondition(cond)
[18:06:28.349]                 })
[18:06:28.349]             }))
[18:06:28.349]             future::FutureResult(value = ...future.value$value, 
[18:06:28.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.349]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.349]                     ...future.globalenv.names))
[18:06:28.349]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.349]         }, condition = base::local({
[18:06:28.349]             c <- base::c
[18:06:28.349]             inherits <- base::inherits
[18:06:28.349]             invokeRestart <- base::invokeRestart
[18:06:28.349]             length <- base::length
[18:06:28.349]             list <- base::list
[18:06:28.349]             seq.int <- base::seq.int
[18:06:28.349]             signalCondition <- base::signalCondition
[18:06:28.349]             sys.calls <- base::sys.calls
[18:06:28.349]             `[[` <- base::`[[`
[18:06:28.349]             `+` <- base::`+`
[18:06:28.349]             `<<-` <- base::`<<-`
[18:06:28.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.349]                   3L)]
[18:06:28.349]             }
[18:06:28.349]             function(cond) {
[18:06:28.349]                 is_error <- inherits(cond, "error")
[18:06:28.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.349]                   NULL)
[18:06:28.349]                 if (is_error) {
[18:06:28.349]                   sessionInformation <- function() {
[18:06:28.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.349]                       search = base::search(), system = base::Sys.info())
[18:06:28.349]                   }
[18:06:28.349]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.349]                     cond$call), session = sessionInformation(), 
[18:06:28.349]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.349]                   signalCondition(cond)
[18:06:28.349]                 }
[18:06:28.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.349]                 "immediateCondition"))) {
[18:06:28.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.349]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.349]                   if (TRUE && !signal) {
[18:06:28.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.349]                     {
[18:06:28.349]                       inherits <- base::inherits
[18:06:28.349]                       invokeRestart <- base::invokeRestart
[18:06:28.349]                       is.null <- base::is.null
[18:06:28.349]                       muffled <- FALSE
[18:06:28.349]                       if (inherits(cond, "message")) {
[18:06:28.349]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.349]                         if (muffled) 
[18:06:28.349]                           invokeRestart("muffleMessage")
[18:06:28.349]                       }
[18:06:28.349]                       else if (inherits(cond, "warning")) {
[18:06:28.349]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.349]                         if (muffled) 
[18:06:28.349]                           invokeRestart("muffleWarning")
[18:06:28.349]                       }
[18:06:28.349]                       else if (inherits(cond, "condition")) {
[18:06:28.349]                         if (!is.null(pattern)) {
[18:06:28.349]                           computeRestarts <- base::computeRestarts
[18:06:28.349]                           grepl <- base::grepl
[18:06:28.349]                           restarts <- computeRestarts(cond)
[18:06:28.349]                           for (restart in restarts) {
[18:06:28.349]                             name <- restart$name
[18:06:28.349]                             if (is.null(name)) 
[18:06:28.349]                               next
[18:06:28.349]                             if (!grepl(pattern, name)) 
[18:06:28.349]                               next
[18:06:28.349]                             invokeRestart(restart)
[18:06:28.349]                             muffled <- TRUE
[18:06:28.349]                             break
[18:06:28.349]                           }
[18:06:28.349]                         }
[18:06:28.349]                       }
[18:06:28.349]                       invisible(muffled)
[18:06:28.349]                     }
[18:06:28.349]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.349]                   }
[18:06:28.349]                 }
[18:06:28.349]                 else {
[18:06:28.349]                   if (TRUE) {
[18:06:28.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.349]                     {
[18:06:28.349]                       inherits <- base::inherits
[18:06:28.349]                       invokeRestart <- base::invokeRestart
[18:06:28.349]                       is.null <- base::is.null
[18:06:28.349]                       muffled <- FALSE
[18:06:28.349]                       if (inherits(cond, "message")) {
[18:06:28.349]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.349]                         if (muffled) 
[18:06:28.349]                           invokeRestart("muffleMessage")
[18:06:28.349]                       }
[18:06:28.349]                       else if (inherits(cond, "warning")) {
[18:06:28.349]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.349]                         if (muffled) 
[18:06:28.349]                           invokeRestart("muffleWarning")
[18:06:28.349]                       }
[18:06:28.349]                       else if (inherits(cond, "condition")) {
[18:06:28.349]                         if (!is.null(pattern)) {
[18:06:28.349]                           computeRestarts <- base::computeRestarts
[18:06:28.349]                           grepl <- base::grepl
[18:06:28.349]                           restarts <- computeRestarts(cond)
[18:06:28.349]                           for (restart in restarts) {
[18:06:28.349]                             name <- restart$name
[18:06:28.349]                             if (is.null(name)) 
[18:06:28.349]                               next
[18:06:28.349]                             if (!grepl(pattern, name)) 
[18:06:28.349]                               next
[18:06:28.349]                             invokeRestart(restart)
[18:06:28.349]                             muffled <- TRUE
[18:06:28.349]                             break
[18:06:28.349]                           }
[18:06:28.349]                         }
[18:06:28.349]                       }
[18:06:28.349]                       invisible(muffled)
[18:06:28.349]                     }
[18:06:28.349]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.349]                   }
[18:06:28.349]                 }
[18:06:28.349]             }
[18:06:28.349]         }))
[18:06:28.349]     }, error = function(ex) {
[18:06:28.349]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.349]                 ...future.rng), started = ...future.startTime, 
[18:06:28.349]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.349]             version = "1.8"), class = "FutureResult")
[18:06:28.349]     }, finally = {
[18:06:28.349]         if (!identical(...future.workdir, getwd())) 
[18:06:28.349]             setwd(...future.workdir)
[18:06:28.349]         {
[18:06:28.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.349]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.349]             }
[18:06:28.349]             base::options(...future.oldOptions)
[18:06:28.349]             if (.Platform$OS.type == "windows") {
[18:06:28.349]                 old_names <- names(...future.oldEnvVars)
[18:06:28.349]                 envs <- base::Sys.getenv()
[18:06:28.349]                 names <- names(envs)
[18:06:28.349]                 common <- intersect(names, old_names)
[18:06:28.349]                 added <- setdiff(names, old_names)
[18:06:28.349]                 removed <- setdiff(old_names, names)
[18:06:28.349]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.349]                   envs[common]]
[18:06:28.349]                 NAMES <- toupper(changed)
[18:06:28.349]                 args <- list()
[18:06:28.349]                 for (kk in seq_along(NAMES)) {
[18:06:28.349]                   name <- changed[[kk]]
[18:06:28.349]                   NAME <- NAMES[[kk]]
[18:06:28.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.349]                     next
[18:06:28.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.349]                 }
[18:06:28.349]                 NAMES <- toupper(added)
[18:06:28.349]                 for (kk in seq_along(NAMES)) {
[18:06:28.349]                   name <- added[[kk]]
[18:06:28.349]                   NAME <- NAMES[[kk]]
[18:06:28.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.349]                     next
[18:06:28.349]                   args[[name]] <- ""
[18:06:28.349]                 }
[18:06:28.349]                 NAMES <- toupper(removed)
[18:06:28.349]                 for (kk in seq_along(NAMES)) {
[18:06:28.349]                   name <- removed[[kk]]
[18:06:28.349]                   NAME <- NAMES[[kk]]
[18:06:28.349]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.349]                     next
[18:06:28.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.349]                 }
[18:06:28.349]                 if (length(args) > 0) 
[18:06:28.349]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.349]             }
[18:06:28.349]             else {
[18:06:28.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.349]             }
[18:06:28.349]             {
[18:06:28.349]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.349]                   0L) {
[18:06:28.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.349]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.349]                   base::options(opts)
[18:06:28.349]                 }
[18:06:28.349]                 {
[18:06:28.349]                   {
[18:06:28.349]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.349]                     NULL
[18:06:28.349]                   }
[18:06:28.349]                   options(future.plan = NULL)
[18:06:28.349]                   if (is.na(NA_character_)) 
[18:06:28.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.349]                     .init = FALSE)
[18:06:28.349]                 }
[18:06:28.349]             }
[18:06:28.349]         }
[18:06:28.349]     })
[18:06:28.349]     if (TRUE) {
[18:06:28.349]         base::sink(type = "output", split = FALSE)
[18:06:28.349]         if (TRUE) {
[18:06:28.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.349]         }
[18:06:28.349]         else {
[18:06:28.349]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.349]         }
[18:06:28.349]         base::close(...future.stdout)
[18:06:28.349]         ...future.stdout <- NULL
[18:06:28.349]     }
[18:06:28.349]     ...future.result$conditions <- ...future.conditions
[18:06:28.349]     ...future.result$finished <- base::Sys.time()
[18:06:28.349]     ...future.result
[18:06:28.349] }
[18:06:28.356] MultisessionFuture started
[18:06:28.356] - Launch lazy future ... done
[18:06:28.356] run() for ‘MultisessionFuture’ ... done
[18:06:28.368] run() for ‘Future’ ...
[18:06:28.368] - state: ‘created’
[18:06:28.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.402]   - Field: ‘node’
[18:06:28.402]   - Field: ‘label’
[18:06:28.402]   - Field: ‘local’
[18:06:28.403]   - Field: ‘owner’
[18:06:28.403]   - Field: ‘envir’
[18:06:28.403]   - Field: ‘workers’
[18:06:28.403]   - Field: ‘packages’
[18:06:28.403]   - Field: ‘gc’
[18:06:28.404]   - Field: ‘conditions’
[18:06:28.404]   - Field: ‘persistent’
[18:06:28.404]   - Field: ‘expr’
[18:06:28.404]   - Field: ‘uuid’
[18:06:28.404]   - Field: ‘seed’
[18:06:28.405]   - Field: ‘version’
[18:06:28.405]   - Field: ‘result’
[18:06:28.405]   - Field: ‘asynchronous’
[18:06:28.405]   - Field: ‘calls’
[18:06:28.405]   - Field: ‘globals’
[18:06:28.406]   - Field: ‘stdout’
[18:06:28.406]   - Field: ‘earlySignal’
[18:06:28.406]   - Field: ‘lazy’
[18:06:28.406]   - Field: ‘state’
[18:06:28.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.407] - Launch lazy future ...
[18:06:28.407] Packages needed by the future expression (n = 0): <none>
[18:06:28.407] Packages needed by future strategies (n = 0): <none>
[18:06:28.408] {
[18:06:28.408]     {
[18:06:28.408]         {
[18:06:28.408]             ...future.startTime <- base::Sys.time()
[18:06:28.408]             {
[18:06:28.408]                 {
[18:06:28.408]                   {
[18:06:28.408]                     {
[18:06:28.408]                       base::local({
[18:06:28.408]                         has_future <- base::requireNamespace("future", 
[18:06:28.408]                           quietly = TRUE)
[18:06:28.408]                         if (has_future) {
[18:06:28.408]                           ns <- base::getNamespace("future")
[18:06:28.408]                           version <- ns[[".package"]][["version"]]
[18:06:28.408]                           if (is.null(version)) 
[18:06:28.408]                             version <- utils::packageVersion("future")
[18:06:28.408]                         }
[18:06:28.408]                         else {
[18:06:28.408]                           version <- NULL
[18:06:28.408]                         }
[18:06:28.408]                         if (!has_future || version < "1.8.0") {
[18:06:28.408]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.408]                             "", base::R.version$version.string), 
[18:06:28.408]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.408]                               "release", "version")], collapse = " "), 
[18:06:28.408]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.408]                             info)
[18:06:28.408]                           info <- base::paste(info, collapse = "; ")
[18:06:28.408]                           if (!has_future) {
[18:06:28.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.408]                               info)
[18:06:28.408]                           }
[18:06:28.408]                           else {
[18:06:28.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.408]                               info, version)
[18:06:28.408]                           }
[18:06:28.408]                           base::stop(msg)
[18:06:28.408]                         }
[18:06:28.408]                       })
[18:06:28.408]                     }
[18:06:28.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.408]                     base::options(mc.cores = 1L)
[18:06:28.408]                   }
[18:06:28.408]                   ...future.strategy.old <- future::plan("list")
[18:06:28.408]                   options(future.plan = NULL)
[18:06:28.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.408]                 }
[18:06:28.408]                 ...future.workdir <- getwd()
[18:06:28.408]             }
[18:06:28.408]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.408]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.408]         }
[18:06:28.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.408]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.408]             base::names(...future.oldOptions))
[18:06:28.408]     }
[18:06:28.408]     if (FALSE) {
[18:06:28.408]     }
[18:06:28.408]     else {
[18:06:28.408]         if (TRUE) {
[18:06:28.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.408]                 open = "w")
[18:06:28.408]         }
[18:06:28.408]         else {
[18:06:28.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.408]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.408]         }
[18:06:28.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.408]             base::sink(type = "output", split = FALSE)
[18:06:28.408]             base::close(...future.stdout)
[18:06:28.408]         }, add = TRUE)
[18:06:28.408]     }
[18:06:28.408]     ...future.frame <- base::sys.nframe()
[18:06:28.408]     ...future.conditions <- base::list()
[18:06:28.408]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.408]     if (FALSE) {
[18:06:28.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.408]     }
[18:06:28.408]     ...future.result <- base::tryCatch({
[18:06:28.408]         base::withCallingHandlers({
[18:06:28.408]             ...future.value <- base::withVisible(base::local({
[18:06:28.408]                 ...future.makeSendCondition <- base::local({
[18:06:28.408]                   sendCondition <- NULL
[18:06:28.408]                   function(frame = 1L) {
[18:06:28.408]                     if (is.function(sendCondition)) 
[18:06:28.408]                       return(sendCondition)
[18:06:28.408]                     ns <- getNamespace("parallel")
[18:06:28.408]                     if (exists("sendData", mode = "function", 
[18:06:28.408]                       envir = ns)) {
[18:06:28.408]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.408]                         envir = ns)
[18:06:28.408]                       envir <- sys.frame(frame)
[18:06:28.408]                       master <- NULL
[18:06:28.408]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.408]                         !identical(envir, emptyenv())) {
[18:06:28.408]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.408]                           inherits = FALSE)) {
[18:06:28.408]                           master <- get("master", mode = "list", 
[18:06:28.408]                             envir = envir, inherits = FALSE)
[18:06:28.408]                           if (inherits(master, c("SOCKnode", 
[18:06:28.408]                             "SOCK0node"))) {
[18:06:28.408]                             sendCondition <<- function(cond) {
[18:06:28.408]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.408]                                 success = TRUE)
[18:06:28.408]                               parallel_sendData(master, data)
[18:06:28.408]                             }
[18:06:28.408]                             return(sendCondition)
[18:06:28.408]                           }
[18:06:28.408]                         }
[18:06:28.408]                         frame <- frame + 1L
[18:06:28.408]                         envir <- sys.frame(frame)
[18:06:28.408]                       }
[18:06:28.408]                     }
[18:06:28.408]                     sendCondition <<- function(cond) NULL
[18:06:28.408]                   }
[18:06:28.408]                 })
[18:06:28.408]                 withCallingHandlers({
[18:06:28.408]                   2
[18:06:28.408]                 }, immediateCondition = function(cond) {
[18:06:28.408]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.408]                   sendCondition(cond)
[18:06:28.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.408]                   {
[18:06:28.408]                     inherits <- base::inherits
[18:06:28.408]                     invokeRestart <- base::invokeRestart
[18:06:28.408]                     is.null <- base::is.null
[18:06:28.408]                     muffled <- FALSE
[18:06:28.408]                     if (inherits(cond, "message")) {
[18:06:28.408]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.408]                       if (muffled) 
[18:06:28.408]                         invokeRestart("muffleMessage")
[18:06:28.408]                     }
[18:06:28.408]                     else if (inherits(cond, "warning")) {
[18:06:28.408]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.408]                       if (muffled) 
[18:06:28.408]                         invokeRestart("muffleWarning")
[18:06:28.408]                     }
[18:06:28.408]                     else if (inherits(cond, "condition")) {
[18:06:28.408]                       if (!is.null(pattern)) {
[18:06:28.408]                         computeRestarts <- base::computeRestarts
[18:06:28.408]                         grepl <- base::grepl
[18:06:28.408]                         restarts <- computeRestarts(cond)
[18:06:28.408]                         for (restart in restarts) {
[18:06:28.408]                           name <- restart$name
[18:06:28.408]                           if (is.null(name)) 
[18:06:28.408]                             next
[18:06:28.408]                           if (!grepl(pattern, name)) 
[18:06:28.408]                             next
[18:06:28.408]                           invokeRestart(restart)
[18:06:28.408]                           muffled <- TRUE
[18:06:28.408]                           break
[18:06:28.408]                         }
[18:06:28.408]                       }
[18:06:28.408]                     }
[18:06:28.408]                     invisible(muffled)
[18:06:28.408]                   }
[18:06:28.408]                   muffleCondition(cond)
[18:06:28.408]                 })
[18:06:28.408]             }))
[18:06:28.408]             future::FutureResult(value = ...future.value$value, 
[18:06:28.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.408]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.408]                     ...future.globalenv.names))
[18:06:28.408]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.408]         }, condition = base::local({
[18:06:28.408]             c <- base::c
[18:06:28.408]             inherits <- base::inherits
[18:06:28.408]             invokeRestart <- base::invokeRestart
[18:06:28.408]             length <- base::length
[18:06:28.408]             list <- base::list
[18:06:28.408]             seq.int <- base::seq.int
[18:06:28.408]             signalCondition <- base::signalCondition
[18:06:28.408]             sys.calls <- base::sys.calls
[18:06:28.408]             `[[` <- base::`[[`
[18:06:28.408]             `+` <- base::`+`
[18:06:28.408]             `<<-` <- base::`<<-`
[18:06:28.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.408]                   3L)]
[18:06:28.408]             }
[18:06:28.408]             function(cond) {
[18:06:28.408]                 is_error <- inherits(cond, "error")
[18:06:28.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.408]                   NULL)
[18:06:28.408]                 if (is_error) {
[18:06:28.408]                   sessionInformation <- function() {
[18:06:28.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.408]                       search = base::search(), system = base::Sys.info())
[18:06:28.408]                   }
[18:06:28.408]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.408]                     cond$call), session = sessionInformation(), 
[18:06:28.408]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.408]                   signalCondition(cond)
[18:06:28.408]                 }
[18:06:28.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.408]                 "immediateCondition"))) {
[18:06:28.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.408]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.408]                   if (TRUE && !signal) {
[18:06:28.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.408]                     {
[18:06:28.408]                       inherits <- base::inherits
[18:06:28.408]                       invokeRestart <- base::invokeRestart
[18:06:28.408]                       is.null <- base::is.null
[18:06:28.408]                       muffled <- FALSE
[18:06:28.408]                       if (inherits(cond, "message")) {
[18:06:28.408]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.408]                         if (muffled) 
[18:06:28.408]                           invokeRestart("muffleMessage")
[18:06:28.408]                       }
[18:06:28.408]                       else if (inherits(cond, "warning")) {
[18:06:28.408]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.408]                         if (muffled) 
[18:06:28.408]                           invokeRestart("muffleWarning")
[18:06:28.408]                       }
[18:06:28.408]                       else if (inherits(cond, "condition")) {
[18:06:28.408]                         if (!is.null(pattern)) {
[18:06:28.408]                           computeRestarts <- base::computeRestarts
[18:06:28.408]                           grepl <- base::grepl
[18:06:28.408]                           restarts <- computeRestarts(cond)
[18:06:28.408]                           for (restart in restarts) {
[18:06:28.408]                             name <- restart$name
[18:06:28.408]                             if (is.null(name)) 
[18:06:28.408]                               next
[18:06:28.408]                             if (!grepl(pattern, name)) 
[18:06:28.408]                               next
[18:06:28.408]                             invokeRestart(restart)
[18:06:28.408]                             muffled <- TRUE
[18:06:28.408]                             break
[18:06:28.408]                           }
[18:06:28.408]                         }
[18:06:28.408]                       }
[18:06:28.408]                       invisible(muffled)
[18:06:28.408]                     }
[18:06:28.408]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.408]                   }
[18:06:28.408]                 }
[18:06:28.408]                 else {
[18:06:28.408]                   if (TRUE) {
[18:06:28.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.408]                     {
[18:06:28.408]                       inherits <- base::inherits
[18:06:28.408]                       invokeRestart <- base::invokeRestart
[18:06:28.408]                       is.null <- base::is.null
[18:06:28.408]                       muffled <- FALSE
[18:06:28.408]                       if (inherits(cond, "message")) {
[18:06:28.408]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.408]                         if (muffled) 
[18:06:28.408]                           invokeRestart("muffleMessage")
[18:06:28.408]                       }
[18:06:28.408]                       else if (inherits(cond, "warning")) {
[18:06:28.408]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.408]                         if (muffled) 
[18:06:28.408]                           invokeRestart("muffleWarning")
[18:06:28.408]                       }
[18:06:28.408]                       else if (inherits(cond, "condition")) {
[18:06:28.408]                         if (!is.null(pattern)) {
[18:06:28.408]                           computeRestarts <- base::computeRestarts
[18:06:28.408]                           grepl <- base::grepl
[18:06:28.408]                           restarts <- computeRestarts(cond)
[18:06:28.408]                           for (restart in restarts) {
[18:06:28.408]                             name <- restart$name
[18:06:28.408]                             if (is.null(name)) 
[18:06:28.408]                               next
[18:06:28.408]                             if (!grepl(pattern, name)) 
[18:06:28.408]                               next
[18:06:28.408]                             invokeRestart(restart)
[18:06:28.408]                             muffled <- TRUE
[18:06:28.408]                             break
[18:06:28.408]                           }
[18:06:28.408]                         }
[18:06:28.408]                       }
[18:06:28.408]                       invisible(muffled)
[18:06:28.408]                     }
[18:06:28.408]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.408]                   }
[18:06:28.408]                 }
[18:06:28.408]             }
[18:06:28.408]         }))
[18:06:28.408]     }, error = function(ex) {
[18:06:28.408]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.408]                 ...future.rng), started = ...future.startTime, 
[18:06:28.408]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.408]             version = "1.8"), class = "FutureResult")
[18:06:28.408]     }, finally = {
[18:06:28.408]         if (!identical(...future.workdir, getwd())) 
[18:06:28.408]             setwd(...future.workdir)
[18:06:28.408]         {
[18:06:28.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.408]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.408]             }
[18:06:28.408]             base::options(...future.oldOptions)
[18:06:28.408]             if (.Platform$OS.type == "windows") {
[18:06:28.408]                 old_names <- names(...future.oldEnvVars)
[18:06:28.408]                 envs <- base::Sys.getenv()
[18:06:28.408]                 names <- names(envs)
[18:06:28.408]                 common <- intersect(names, old_names)
[18:06:28.408]                 added <- setdiff(names, old_names)
[18:06:28.408]                 removed <- setdiff(old_names, names)
[18:06:28.408]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.408]                   envs[common]]
[18:06:28.408]                 NAMES <- toupper(changed)
[18:06:28.408]                 args <- list()
[18:06:28.408]                 for (kk in seq_along(NAMES)) {
[18:06:28.408]                   name <- changed[[kk]]
[18:06:28.408]                   NAME <- NAMES[[kk]]
[18:06:28.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.408]                     next
[18:06:28.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.408]                 }
[18:06:28.408]                 NAMES <- toupper(added)
[18:06:28.408]                 for (kk in seq_along(NAMES)) {
[18:06:28.408]                   name <- added[[kk]]
[18:06:28.408]                   NAME <- NAMES[[kk]]
[18:06:28.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.408]                     next
[18:06:28.408]                   args[[name]] <- ""
[18:06:28.408]                 }
[18:06:28.408]                 NAMES <- toupper(removed)
[18:06:28.408]                 for (kk in seq_along(NAMES)) {
[18:06:28.408]                   name <- removed[[kk]]
[18:06:28.408]                   NAME <- NAMES[[kk]]
[18:06:28.408]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.408]                     next
[18:06:28.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.408]                 }
[18:06:28.408]                 if (length(args) > 0) 
[18:06:28.408]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.408]             }
[18:06:28.408]             else {
[18:06:28.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.408]             }
[18:06:28.408]             {
[18:06:28.408]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.408]                   0L) {
[18:06:28.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.408]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.408]                   base::options(opts)
[18:06:28.408]                 }
[18:06:28.408]                 {
[18:06:28.408]                   {
[18:06:28.408]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.408]                     NULL
[18:06:28.408]                   }
[18:06:28.408]                   options(future.plan = NULL)
[18:06:28.408]                   if (is.na(NA_character_)) 
[18:06:28.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.408]                     .init = FALSE)
[18:06:28.408]                 }
[18:06:28.408]             }
[18:06:28.408]         }
[18:06:28.408]     })
[18:06:28.408]     if (TRUE) {
[18:06:28.408]         base::sink(type = "output", split = FALSE)
[18:06:28.408]         if (TRUE) {
[18:06:28.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.408]         }
[18:06:28.408]         else {
[18:06:28.408]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.408]         }
[18:06:28.408]         base::close(...future.stdout)
[18:06:28.408]         ...future.stdout <- NULL
[18:06:28.408]     }
[18:06:28.408]     ...future.result$conditions <- ...future.conditions
[18:06:28.408]     ...future.result$finished <- base::Sys.time()
[18:06:28.408]     ...future.result
[18:06:28.408] }
[18:06:28.414] MultisessionFuture started
[18:06:28.415] - Launch lazy future ... done
[18:06:28.415] run() for ‘MultisessionFuture’ ... done
[18:06:28.426]  length: 2 (resolved future 3)
[18:06:28.437] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.437] - Validating connection of MultisessionFuture
[18:06:28.438] - received message: FutureResult
[18:06:28.438] - Received FutureResult
[18:06:28.438] - Erased future from FutureRegistry
[18:06:28.438] result() for ClusterFuture ...
[18:06:28.438] - result already collected: FutureResult
[18:06:28.439] result() for ClusterFuture ... done
[18:06:28.439] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.439] Future #1
[18:06:28.439]  length: 1 (resolved future 1)
[18:06:28.461] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.461] - Validating connection of MultisessionFuture
[18:06:28.462] - received message: FutureResult
[18:06:28.462] - Received FutureResult
[18:06:28.462] - Erased future from FutureRegistry
[18:06:28.462] result() for ClusterFuture ...
[18:06:28.463] - result already collected: FutureResult
[18:06:28.463] result() for ClusterFuture ... done
[18:06:28.463] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.463] Future #2
[18:06:28.463]  length: 0 (resolved future 2)
[18:06:28.464] resolve() on list ... DONE
[18:06:28.464] getGlobalsAndPackages() ...
[18:06:28.464] Searching for globals...
[18:06:28.465] 
[18:06:28.465] Searching for globals ... DONE
[18:06:28.465] - globals: [0] <none>
[18:06:28.465] getGlobalsAndPackages() ... DONE
[18:06:28.466] run() for ‘Future’ ...
[18:06:28.466] - state: ‘created’
[18:06:28.466] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.489] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.489]   - Field: ‘node’
[18:06:28.489]   - Field: ‘label’
[18:06:28.490]   - Field: ‘local’
[18:06:28.490]   - Field: ‘owner’
[18:06:28.490]   - Field: ‘envir’
[18:06:28.490]   - Field: ‘workers’
[18:06:28.490]   - Field: ‘packages’
[18:06:28.491]   - Field: ‘gc’
[18:06:28.491]   - Field: ‘conditions’
[18:06:28.491]   - Field: ‘persistent’
[18:06:28.491]   - Field: ‘expr’
[18:06:28.491]   - Field: ‘uuid’
[18:06:28.492]   - Field: ‘seed’
[18:06:28.492]   - Field: ‘version’
[18:06:28.492]   - Field: ‘result’
[18:06:28.492]   - Field: ‘asynchronous’
[18:06:28.492]   - Field: ‘calls’
[18:06:28.493]   - Field: ‘globals’
[18:06:28.493]   - Field: ‘stdout’
[18:06:28.493]   - Field: ‘earlySignal’
[18:06:28.493]   - Field: ‘lazy’
[18:06:28.493]   - Field: ‘state’
[18:06:28.493] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.494] - Launch lazy future ...
[18:06:28.494] Packages needed by the future expression (n = 0): <none>
[18:06:28.494] Packages needed by future strategies (n = 0): <none>
[18:06:28.495] {
[18:06:28.495]     {
[18:06:28.495]         {
[18:06:28.495]             ...future.startTime <- base::Sys.time()
[18:06:28.495]             {
[18:06:28.495]                 {
[18:06:28.495]                   {
[18:06:28.495]                     {
[18:06:28.495]                       base::local({
[18:06:28.495]                         has_future <- base::requireNamespace("future", 
[18:06:28.495]                           quietly = TRUE)
[18:06:28.495]                         if (has_future) {
[18:06:28.495]                           ns <- base::getNamespace("future")
[18:06:28.495]                           version <- ns[[".package"]][["version"]]
[18:06:28.495]                           if (is.null(version)) 
[18:06:28.495]                             version <- utils::packageVersion("future")
[18:06:28.495]                         }
[18:06:28.495]                         else {
[18:06:28.495]                           version <- NULL
[18:06:28.495]                         }
[18:06:28.495]                         if (!has_future || version < "1.8.0") {
[18:06:28.495]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.495]                             "", base::R.version$version.string), 
[18:06:28.495]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.495]                               "release", "version")], collapse = " "), 
[18:06:28.495]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.495]                             info)
[18:06:28.495]                           info <- base::paste(info, collapse = "; ")
[18:06:28.495]                           if (!has_future) {
[18:06:28.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.495]                               info)
[18:06:28.495]                           }
[18:06:28.495]                           else {
[18:06:28.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.495]                               info, version)
[18:06:28.495]                           }
[18:06:28.495]                           base::stop(msg)
[18:06:28.495]                         }
[18:06:28.495]                       })
[18:06:28.495]                     }
[18:06:28.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.495]                     base::options(mc.cores = 1L)
[18:06:28.495]                   }
[18:06:28.495]                   ...future.strategy.old <- future::plan("list")
[18:06:28.495]                   options(future.plan = NULL)
[18:06:28.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.495]                 }
[18:06:28.495]                 ...future.workdir <- getwd()
[18:06:28.495]             }
[18:06:28.495]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.495]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.495]         }
[18:06:28.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.495]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.495]             base::names(...future.oldOptions))
[18:06:28.495]     }
[18:06:28.495]     if (FALSE) {
[18:06:28.495]     }
[18:06:28.495]     else {
[18:06:28.495]         if (TRUE) {
[18:06:28.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.495]                 open = "w")
[18:06:28.495]         }
[18:06:28.495]         else {
[18:06:28.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.495]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.495]         }
[18:06:28.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.495]             base::sink(type = "output", split = FALSE)
[18:06:28.495]             base::close(...future.stdout)
[18:06:28.495]         }, add = TRUE)
[18:06:28.495]     }
[18:06:28.495]     ...future.frame <- base::sys.nframe()
[18:06:28.495]     ...future.conditions <- base::list()
[18:06:28.495]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.495]     if (FALSE) {
[18:06:28.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.495]     }
[18:06:28.495]     ...future.result <- base::tryCatch({
[18:06:28.495]         base::withCallingHandlers({
[18:06:28.495]             ...future.value <- base::withVisible(base::local({
[18:06:28.495]                 ...future.makeSendCondition <- base::local({
[18:06:28.495]                   sendCondition <- NULL
[18:06:28.495]                   function(frame = 1L) {
[18:06:28.495]                     if (is.function(sendCondition)) 
[18:06:28.495]                       return(sendCondition)
[18:06:28.495]                     ns <- getNamespace("parallel")
[18:06:28.495]                     if (exists("sendData", mode = "function", 
[18:06:28.495]                       envir = ns)) {
[18:06:28.495]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.495]                         envir = ns)
[18:06:28.495]                       envir <- sys.frame(frame)
[18:06:28.495]                       master <- NULL
[18:06:28.495]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.495]                         !identical(envir, emptyenv())) {
[18:06:28.495]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.495]                           inherits = FALSE)) {
[18:06:28.495]                           master <- get("master", mode = "list", 
[18:06:28.495]                             envir = envir, inherits = FALSE)
[18:06:28.495]                           if (inherits(master, c("SOCKnode", 
[18:06:28.495]                             "SOCK0node"))) {
[18:06:28.495]                             sendCondition <<- function(cond) {
[18:06:28.495]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.495]                                 success = TRUE)
[18:06:28.495]                               parallel_sendData(master, data)
[18:06:28.495]                             }
[18:06:28.495]                             return(sendCondition)
[18:06:28.495]                           }
[18:06:28.495]                         }
[18:06:28.495]                         frame <- frame + 1L
[18:06:28.495]                         envir <- sys.frame(frame)
[18:06:28.495]                       }
[18:06:28.495]                     }
[18:06:28.495]                     sendCondition <<- function(cond) NULL
[18:06:28.495]                   }
[18:06:28.495]                 })
[18:06:28.495]                 withCallingHandlers({
[18:06:28.495]                   1
[18:06:28.495]                 }, immediateCondition = function(cond) {
[18:06:28.495]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.495]                   sendCondition(cond)
[18:06:28.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.495]                   {
[18:06:28.495]                     inherits <- base::inherits
[18:06:28.495]                     invokeRestart <- base::invokeRestart
[18:06:28.495]                     is.null <- base::is.null
[18:06:28.495]                     muffled <- FALSE
[18:06:28.495]                     if (inherits(cond, "message")) {
[18:06:28.495]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.495]                       if (muffled) 
[18:06:28.495]                         invokeRestart("muffleMessage")
[18:06:28.495]                     }
[18:06:28.495]                     else if (inherits(cond, "warning")) {
[18:06:28.495]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.495]                       if (muffled) 
[18:06:28.495]                         invokeRestart("muffleWarning")
[18:06:28.495]                     }
[18:06:28.495]                     else if (inherits(cond, "condition")) {
[18:06:28.495]                       if (!is.null(pattern)) {
[18:06:28.495]                         computeRestarts <- base::computeRestarts
[18:06:28.495]                         grepl <- base::grepl
[18:06:28.495]                         restarts <- computeRestarts(cond)
[18:06:28.495]                         for (restart in restarts) {
[18:06:28.495]                           name <- restart$name
[18:06:28.495]                           if (is.null(name)) 
[18:06:28.495]                             next
[18:06:28.495]                           if (!grepl(pattern, name)) 
[18:06:28.495]                             next
[18:06:28.495]                           invokeRestart(restart)
[18:06:28.495]                           muffled <- TRUE
[18:06:28.495]                           break
[18:06:28.495]                         }
[18:06:28.495]                       }
[18:06:28.495]                     }
[18:06:28.495]                     invisible(muffled)
[18:06:28.495]                   }
[18:06:28.495]                   muffleCondition(cond)
[18:06:28.495]                 })
[18:06:28.495]             }))
[18:06:28.495]             future::FutureResult(value = ...future.value$value, 
[18:06:28.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.495]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.495]                     ...future.globalenv.names))
[18:06:28.495]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.495]         }, condition = base::local({
[18:06:28.495]             c <- base::c
[18:06:28.495]             inherits <- base::inherits
[18:06:28.495]             invokeRestart <- base::invokeRestart
[18:06:28.495]             length <- base::length
[18:06:28.495]             list <- base::list
[18:06:28.495]             seq.int <- base::seq.int
[18:06:28.495]             signalCondition <- base::signalCondition
[18:06:28.495]             sys.calls <- base::sys.calls
[18:06:28.495]             `[[` <- base::`[[`
[18:06:28.495]             `+` <- base::`+`
[18:06:28.495]             `<<-` <- base::`<<-`
[18:06:28.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.495]                   3L)]
[18:06:28.495]             }
[18:06:28.495]             function(cond) {
[18:06:28.495]                 is_error <- inherits(cond, "error")
[18:06:28.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.495]                   NULL)
[18:06:28.495]                 if (is_error) {
[18:06:28.495]                   sessionInformation <- function() {
[18:06:28.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.495]                       search = base::search(), system = base::Sys.info())
[18:06:28.495]                   }
[18:06:28.495]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.495]                     cond$call), session = sessionInformation(), 
[18:06:28.495]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.495]                   signalCondition(cond)
[18:06:28.495]                 }
[18:06:28.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.495]                 "immediateCondition"))) {
[18:06:28.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.495]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.495]                   if (TRUE && !signal) {
[18:06:28.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.495]                     {
[18:06:28.495]                       inherits <- base::inherits
[18:06:28.495]                       invokeRestart <- base::invokeRestart
[18:06:28.495]                       is.null <- base::is.null
[18:06:28.495]                       muffled <- FALSE
[18:06:28.495]                       if (inherits(cond, "message")) {
[18:06:28.495]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.495]                         if (muffled) 
[18:06:28.495]                           invokeRestart("muffleMessage")
[18:06:28.495]                       }
[18:06:28.495]                       else if (inherits(cond, "warning")) {
[18:06:28.495]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.495]                         if (muffled) 
[18:06:28.495]                           invokeRestart("muffleWarning")
[18:06:28.495]                       }
[18:06:28.495]                       else if (inherits(cond, "condition")) {
[18:06:28.495]                         if (!is.null(pattern)) {
[18:06:28.495]                           computeRestarts <- base::computeRestarts
[18:06:28.495]                           grepl <- base::grepl
[18:06:28.495]                           restarts <- computeRestarts(cond)
[18:06:28.495]                           for (restart in restarts) {
[18:06:28.495]                             name <- restart$name
[18:06:28.495]                             if (is.null(name)) 
[18:06:28.495]                               next
[18:06:28.495]                             if (!grepl(pattern, name)) 
[18:06:28.495]                               next
[18:06:28.495]                             invokeRestart(restart)
[18:06:28.495]                             muffled <- TRUE
[18:06:28.495]                             break
[18:06:28.495]                           }
[18:06:28.495]                         }
[18:06:28.495]                       }
[18:06:28.495]                       invisible(muffled)
[18:06:28.495]                     }
[18:06:28.495]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.495]                   }
[18:06:28.495]                 }
[18:06:28.495]                 else {
[18:06:28.495]                   if (TRUE) {
[18:06:28.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.495]                     {
[18:06:28.495]                       inherits <- base::inherits
[18:06:28.495]                       invokeRestart <- base::invokeRestart
[18:06:28.495]                       is.null <- base::is.null
[18:06:28.495]                       muffled <- FALSE
[18:06:28.495]                       if (inherits(cond, "message")) {
[18:06:28.495]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.495]                         if (muffled) 
[18:06:28.495]                           invokeRestart("muffleMessage")
[18:06:28.495]                       }
[18:06:28.495]                       else if (inherits(cond, "warning")) {
[18:06:28.495]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.495]                         if (muffled) 
[18:06:28.495]                           invokeRestart("muffleWarning")
[18:06:28.495]                       }
[18:06:28.495]                       else if (inherits(cond, "condition")) {
[18:06:28.495]                         if (!is.null(pattern)) {
[18:06:28.495]                           computeRestarts <- base::computeRestarts
[18:06:28.495]                           grepl <- base::grepl
[18:06:28.495]                           restarts <- computeRestarts(cond)
[18:06:28.495]                           for (restart in restarts) {
[18:06:28.495]                             name <- restart$name
[18:06:28.495]                             if (is.null(name)) 
[18:06:28.495]                               next
[18:06:28.495]                             if (!grepl(pattern, name)) 
[18:06:28.495]                               next
[18:06:28.495]                             invokeRestart(restart)
[18:06:28.495]                             muffled <- TRUE
[18:06:28.495]                             break
[18:06:28.495]                           }
[18:06:28.495]                         }
[18:06:28.495]                       }
[18:06:28.495]                       invisible(muffled)
[18:06:28.495]                     }
[18:06:28.495]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.495]                   }
[18:06:28.495]                 }
[18:06:28.495]             }
[18:06:28.495]         }))
[18:06:28.495]     }, error = function(ex) {
[18:06:28.495]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.495]                 ...future.rng), started = ...future.startTime, 
[18:06:28.495]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.495]             version = "1.8"), class = "FutureResult")
[18:06:28.495]     }, finally = {
[18:06:28.495]         if (!identical(...future.workdir, getwd())) 
[18:06:28.495]             setwd(...future.workdir)
[18:06:28.495]         {
[18:06:28.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.495]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.495]             }
[18:06:28.495]             base::options(...future.oldOptions)
[18:06:28.495]             if (.Platform$OS.type == "windows") {
[18:06:28.495]                 old_names <- names(...future.oldEnvVars)
[18:06:28.495]                 envs <- base::Sys.getenv()
[18:06:28.495]                 names <- names(envs)
[18:06:28.495]                 common <- intersect(names, old_names)
[18:06:28.495]                 added <- setdiff(names, old_names)
[18:06:28.495]                 removed <- setdiff(old_names, names)
[18:06:28.495]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.495]                   envs[common]]
[18:06:28.495]                 NAMES <- toupper(changed)
[18:06:28.495]                 args <- list()
[18:06:28.495]                 for (kk in seq_along(NAMES)) {
[18:06:28.495]                   name <- changed[[kk]]
[18:06:28.495]                   NAME <- NAMES[[kk]]
[18:06:28.495]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.495]                     next
[18:06:28.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.495]                 }
[18:06:28.495]                 NAMES <- toupper(added)
[18:06:28.495]                 for (kk in seq_along(NAMES)) {
[18:06:28.495]                   name <- added[[kk]]
[18:06:28.495]                   NAME <- NAMES[[kk]]
[18:06:28.495]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.495]                     next
[18:06:28.495]                   args[[name]] <- ""
[18:06:28.495]                 }
[18:06:28.495]                 NAMES <- toupper(removed)
[18:06:28.495]                 for (kk in seq_along(NAMES)) {
[18:06:28.495]                   name <- removed[[kk]]
[18:06:28.495]                   NAME <- NAMES[[kk]]
[18:06:28.495]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.495]                     next
[18:06:28.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.495]                 }
[18:06:28.495]                 if (length(args) > 0) 
[18:06:28.495]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.495]             }
[18:06:28.495]             else {
[18:06:28.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.495]             }
[18:06:28.495]             {
[18:06:28.495]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.495]                   0L) {
[18:06:28.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.495]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.495]                   base::options(opts)
[18:06:28.495]                 }
[18:06:28.495]                 {
[18:06:28.495]                   {
[18:06:28.495]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.495]                     NULL
[18:06:28.495]                   }
[18:06:28.495]                   options(future.plan = NULL)
[18:06:28.495]                   if (is.na(NA_character_)) 
[18:06:28.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.495]                     .init = FALSE)
[18:06:28.495]                 }
[18:06:28.495]             }
[18:06:28.495]         }
[18:06:28.495]     })
[18:06:28.495]     if (TRUE) {
[18:06:28.495]         base::sink(type = "output", split = FALSE)
[18:06:28.495]         if (TRUE) {
[18:06:28.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.495]         }
[18:06:28.495]         else {
[18:06:28.495]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.495]         }
[18:06:28.495]         base::close(...future.stdout)
[18:06:28.495]         ...future.stdout <- NULL
[18:06:28.495]     }
[18:06:28.495]     ...future.result$conditions <- ...future.conditions
[18:06:28.495]     ...future.result$finished <- base::Sys.time()
[18:06:28.495]     ...future.result
[18:06:28.495] }
[18:06:28.501] MultisessionFuture started
[18:06:28.501] - Launch lazy future ... done
[18:06:28.501] run() for ‘MultisessionFuture’ ... done
[18:06:28.502] getGlobalsAndPackages() ...
[18:06:28.502] Searching for globals...
[18:06:28.504] - globals found: [2] ‘{’, ‘Sys.sleep’
[18:06:28.504] Searching for globals ... DONE
[18:06:28.504] Resolving globals: FALSE
[18:06:28.505] 
[18:06:28.505] 
[18:06:28.505] getGlobalsAndPackages() ... DONE
[18:06:28.506] run() for ‘Future’ ...
[18:06:28.506] - state: ‘created’
[18:06:28.506] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:28.529] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:28.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:28.529]   - Field: ‘node’
[18:06:28.529]   - Field: ‘label’
[18:06:28.530]   - Field: ‘local’
[18:06:28.530]   - Field: ‘owner’
[18:06:28.530]   - Field: ‘envir’
[18:06:28.530]   - Field: ‘workers’
[18:06:28.530]   - Field: ‘packages’
[18:06:28.531]   - Field: ‘gc’
[18:06:28.531]   - Field: ‘conditions’
[18:06:28.531]   - Field: ‘persistent’
[18:06:28.531]   - Field: ‘expr’
[18:06:28.531]   - Field: ‘uuid’
[18:06:28.532]   - Field: ‘seed’
[18:06:28.532]   - Field: ‘version’
[18:06:28.532]   - Field: ‘result’
[18:06:28.532]   - Field: ‘asynchronous’
[18:06:28.532]   - Field: ‘calls’
[18:06:28.533]   - Field: ‘globals’
[18:06:28.533]   - Field: ‘stdout’
[18:06:28.533]   - Field: ‘earlySignal’
[18:06:28.533]   - Field: ‘lazy’
[18:06:28.533]   - Field: ‘state’
[18:06:28.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:28.534] - Launch lazy future ...
[18:06:28.534] Packages needed by the future expression (n = 0): <none>
[18:06:28.534] Packages needed by future strategies (n = 0): <none>
[18:06:28.535] {
[18:06:28.535]     {
[18:06:28.535]         {
[18:06:28.535]             ...future.startTime <- base::Sys.time()
[18:06:28.535]             {
[18:06:28.535]                 {
[18:06:28.535]                   {
[18:06:28.535]                     {
[18:06:28.535]                       base::local({
[18:06:28.535]                         has_future <- base::requireNamespace("future", 
[18:06:28.535]                           quietly = TRUE)
[18:06:28.535]                         if (has_future) {
[18:06:28.535]                           ns <- base::getNamespace("future")
[18:06:28.535]                           version <- ns[[".package"]][["version"]]
[18:06:28.535]                           if (is.null(version)) 
[18:06:28.535]                             version <- utils::packageVersion("future")
[18:06:28.535]                         }
[18:06:28.535]                         else {
[18:06:28.535]                           version <- NULL
[18:06:28.535]                         }
[18:06:28.535]                         if (!has_future || version < "1.8.0") {
[18:06:28.535]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:28.535]                             "", base::R.version$version.string), 
[18:06:28.535]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:28.535]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:28.535]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:28.535]                               "release", "version")], collapse = " "), 
[18:06:28.535]                             hostname = base::Sys.info()[["nodename"]])
[18:06:28.535]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:28.535]                             info)
[18:06:28.535]                           info <- base::paste(info, collapse = "; ")
[18:06:28.535]                           if (!has_future) {
[18:06:28.535]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:28.535]                               info)
[18:06:28.535]                           }
[18:06:28.535]                           else {
[18:06:28.535]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:28.535]                               info, version)
[18:06:28.535]                           }
[18:06:28.535]                           base::stop(msg)
[18:06:28.535]                         }
[18:06:28.535]                       })
[18:06:28.535]                     }
[18:06:28.535]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:28.535]                     base::options(mc.cores = 1L)
[18:06:28.535]                   }
[18:06:28.535]                   ...future.strategy.old <- future::plan("list")
[18:06:28.535]                   options(future.plan = NULL)
[18:06:28.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:28.535]                 }
[18:06:28.535]                 ...future.workdir <- getwd()
[18:06:28.535]             }
[18:06:28.535]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:28.535]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:28.535]         }
[18:06:28.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:28.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:28.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:28.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:28.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:28.535]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:28.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:28.535]             base::names(...future.oldOptions))
[18:06:28.535]     }
[18:06:28.535]     if (FALSE) {
[18:06:28.535]     }
[18:06:28.535]     else {
[18:06:28.535]         if (TRUE) {
[18:06:28.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:28.535]                 open = "w")
[18:06:28.535]         }
[18:06:28.535]         else {
[18:06:28.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:28.535]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:28.535]         }
[18:06:28.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:28.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:28.535]             base::sink(type = "output", split = FALSE)
[18:06:28.535]             base::close(...future.stdout)
[18:06:28.535]         }, add = TRUE)
[18:06:28.535]     }
[18:06:28.535]     ...future.frame <- base::sys.nframe()
[18:06:28.535]     ...future.conditions <- base::list()
[18:06:28.535]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:28.535]     if (FALSE) {
[18:06:28.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:28.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:28.535]     }
[18:06:28.535]     ...future.result <- base::tryCatch({
[18:06:28.535]         base::withCallingHandlers({
[18:06:28.535]             ...future.value <- base::withVisible(base::local({
[18:06:28.535]                 ...future.makeSendCondition <- base::local({
[18:06:28.535]                   sendCondition <- NULL
[18:06:28.535]                   function(frame = 1L) {
[18:06:28.535]                     if (is.function(sendCondition)) 
[18:06:28.535]                       return(sendCondition)
[18:06:28.535]                     ns <- getNamespace("parallel")
[18:06:28.535]                     if (exists("sendData", mode = "function", 
[18:06:28.535]                       envir = ns)) {
[18:06:28.535]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:28.535]                         envir = ns)
[18:06:28.535]                       envir <- sys.frame(frame)
[18:06:28.535]                       master <- NULL
[18:06:28.535]                       while (!identical(envir, .GlobalEnv) && 
[18:06:28.535]                         !identical(envir, emptyenv())) {
[18:06:28.535]                         if (exists("master", mode = "list", envir = envir, 
[18:06:28.535]                           inherits = FALSE)) {
[18:06:28.535]                           master <- get("master", mode = "list", 
[18:06:28.535]                             envir = envir, inherits = FALSE)
[18:06:28.535]                           if (inherits(master, c("SOCKnode", 
[18:06:28.535]                             "SOCK0node"))) {
[18:06:28.535]                             sendCondition <<- function(cond) {
[18:06:28.535]                               data <- list(type = "VALUE", value = cond, 
[18:06:28.535]                                 success = TRUE)
[18:06:28.535]                               parallel_sendData(master, data)
[18:06:28.535]                             }
[18:06:28.535]                             return(sendCondition)
[18:06:28.535]                           }
[18:06:28.535]                         }
[18:06:28.535]                         frame <- frame + 1L
[18:06:28.535]                         envir <- sys.frame(frame)
[18:06:28.535]                       }
[18:06:28.535]                     }
[18:06:28.535]                     sendCondition <<- function(cond) NULL
[18:06:28.535]                   }
[18:06:28.535]                 })
[18:06:28.535]                 withCallingHandlers({
[18:06:28.535]                   {
[18:06:28.535]                     Sys.sleep(0.5)
[18:06:28.535]                     2
[18:06:28.535]                   }
[18:06:28.535]                 }, immediateCondition = function(cond) {
[18:06:28.535]                   sendCondition <- ...future.makeSendCondition()
[18:06:28.535]                   sendCondition(cond)
[18:06:28.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.535]                   {
[18:06:28.535]                     inherits <- base::inherits
[18:06:28.535]                     invokeRestart <- base::invokeRestart
[18:06:28.535]                     is.null <- base::is.null
[18:06:28.535]                     muffled <- FALSE
[18:06:28.535]                     if (inherits(cond, "message")) {
[18:06:28.535]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:28.535]                       if (muffled) 
[18:06:28.535]                         invokeRestart("muffleMessage")
[18:06:28.535]                     }
[18:06:28.535]                     else if (inherits(cond, "warning")) {
[18:06:28.535]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:28.535]                       if (muffled) 
[18:06:28.535]                         invokeRestart("muffleWarning")
[18:06:28.535]                     }
[18:06:28.535]                     else if (inherits(cond, "condition")) {
[18:06:28.535]                       if (!is.null(pattern)) {
[18:06:28.535]                         computeRestarts <- base::computeRestarts
[18:06:28.535]                         grepl <- base::grepl
[18:06:28.535]                         restarts <- computeRestarts(cond)
[18:06:28.535]                         for (restart in restarts) {
[18:06:28.535]                           name <- restart$name
[18:06:28.535]                           if (is.null(name)) 
[18:06:28.535]                             next
[18:06:28.535]                           if (!grepl(pattern, name)) 
[18:06:28.535]                             next
[18:06:28.535]                           invokeRestart(restart)
[18:06:28.535]                           muffled <- TRUE
[18:06:28.535]                           break
[18:06:28.535]                         }
[18:06:28.535]                       }
[18:06:28.535]                     }
[18:06:28.535]                     invisible(muffled)
[18:06:28.535]                   }
[18:06:28.535]                   muffleCondition(cond)
[18:06:28.535]                 })
[18:06:28.535]             }))
[18:06:28.535]             future::FutureResult(value = ...future.value$value, 
[18:06:28.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.535]                   ...future.rng), globalenv = if (FALSE) 
[18:06:28.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:28.535]                     ...future.globalenv.names))
[18:06:28.535]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:28.535]         }, condition = base::local({
[18:06:28.535]             c <- base::c
[18:06:28.535]             inherits <- base::inherits
[18:06:28.535]             invokeRestart <- base::invokeRestart
[18:06:28.535]             length <- base::length
[18:06:28.535]             list <- base::list
[18:06:28.535]             seq.int <- base::seq.int
[18:06:28.535]             signalCondition <- base::signalCondition
[18:06:28.535]             sys.calls <- base::sys.calls
[18:06:28.535]             `[[` <- base::`[[`
[18:06:28.535]             `+` <- base::`+`
[18:06:28.535]             `<<-` <- base::`<<-`
[18:06:28.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:28.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:28.535]                   3L)]
[18:06:28.535]             }
[18:06:28.535]             function(cond) {
[18:06:28.535]                 is_error <- inherits(cond, "error")
[18:06:28.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:28.535]                   NULL)
[18:06:28.535]                 if (is_error) {
[18:06:28.535]                   sessionInformation <- function() {
[18:06:28.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:28.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:28.535]                       search = base::search(), system = base::Sys.info())
[18:06:28.535]                   }
[18:06:28.535]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:28.535]                     cond$call), session = sessionInformation(), 
[18:06:28.535]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:28.535]                   signalCondition(cond)
[18:06:28.535]                 }
[18:06:28.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:28.535]                 "immediateCondition"))) {
[18:06:28.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:28.535]                   ...future.conditions[[length(...future.conditions) + 
[18:06:28.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:28.535]                   if (TRUE && !signal) {
[18:06:28.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.535]                     {
[18:06:28.535]                       inherits <- base::inherits
[18:06:28.535]                       invokeRestart <- base::invokeRestart
[18:06:28.535]                       is.null <- base::is.null
[18:06:28.535]                       muffled <- FALSE
[18:06:28.535]                       if (inherits(cond, "message")) {
[18:06:28.535]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.535]                         if (muffled) 
[18:06:28.535]                           invokeRestart("muffleMessage")
[18:06:28.535]                       }
[18:06:28.535]                       else if (inherits(cond, "warning")) {
[18:06:28.535]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.535]                         if (muffled) 
[18:06:28.535]                           invokeRestart("muffleWarning")
[18:06:28.535]                       }
[18:06:28.535]                       else if (inherits(cond, "condition")) {
[18:06:28.535]                         if (!is.null(pattern)) {
[18:06:28.535]                           computeRestarts <- base::computeRestarts
[18:06:28.535]                           grepl <- base::grepl
[18:06:28.535]                           restarts <- computeRestarts(cond)
[18:06:28.535]                           for (restart in restarts) {
[18:06:28.535]                             name <- restart$name
[18:06:28.535]                             if (is.null(name)) 
[18:06:28.535]                               next
[18:06:28.535]                             if (!grepl(pattern, name)) 
[18:06:28.535]                               next
[18:06:28.535]                             invokeRestart(restart)
[18:06:28.535]                             muffled <- TRUE
[18:06:28.535]                             break
[18:06:28.535]                           }
[18:06:28.535]                         }
[18:06:28.535]                       }
[18:06:28.535]                       invisible(muffled)
[18:06:28.535]                     }
[18:06:28.535]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.535]                   }
[18:06:28.535]                 }
[18:06:28.535]                 else {
[18:06:28.535]                   if (TRUE) {
[18:06:28.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:28.535]                     {
[18:06:28.535]                       inherits <- base::inherits
[18:06:28.535]                       invokeRestart <- base::invokeRestart
[18:06:28.535]                       is.null <- base::is.null
[18:06:28.535]                       muffled <- FALSE
[18:06:28.535]                       if (inherits(cond, "message")) {
[18:06:28.535]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:28.535]                         if (muffled) 
[18:06:28.535]                           invokeRestart("muffleMessage")
[18:06:28.535]                       }
[18:06:28.535]                       else if (inherits(cond, "warning")) {
[18:06:28.535]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:28.535]                         if (muffled) 
[18:06:28.535]                           invokeRestart("muffleWarning")
[18:06:28.535]                       }
[18:06:28.535]                       else if (inherits(cond, "condition")) {
[18:06:28.535]                         if (!is.null(pattern)) {
[18:06:28.535]                           computeRestarts <- base::computeRestarts
[18:06:28.535]                           grepl <- base::grepl
[18:06:28.535]                           restarts <- computeRestarts(cond)
[18:06:28.535]                           for (restart in restarts) {
[18:06:28.535]                             name <- restart$name
[18:06:28.535]                             if (is.null(name)) 
[18:06:28.535]                               next
[18:06:28.535]                             if (!grepl(pattern, name)) 
[18:06:28.535]                               next
[18:06:28.535]                             invokeRestart(restart)
[18:06:28.535]                             muffled <- TRUE
[18:06:28.535]                             break
[18:06:28.535]                           }
[18:06:28.535]                         }
[18:06:28.535]                       }
[18:06:28.535]                       invisible(muffled)
[18:06:28.535]                     }
[18:06:28.535]                     muffleCondition(cond, pattern = "^muffle")
[18:06:28.535]                   }
[18:06:28.535]                 }
[18:06:28.535]             }
[18:06:28.535]         }))
[18:06:28.535]     }, error = function(ex) {
[18:06:28.535]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:28.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:28.535]                 ...future.rng), started = ...future.startTime, 
[18:06:28.535]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:28.535]             version = "1.8"), class = "FutureResult")
[18:06:28.535]     }, finally = {
[18:06:28.535]         if (!identical(...future.workdir, getwd())) 
[18:06:28.535]             setwd(...future.workdir)
[18:06:28.535]         {
[18:06:28.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:28.535]                 ...future.oldOptions$nwarnings <- NULL
[18:06:28.535]             }
[18:06:28.535]             base::options(...future.oldOptions)
[18:06:28.535]             if (.Platform$OS.type == "windows") {
[18:06:28.535]                 old_names <- names(...future.oldEnvVars)
[18:06:28.535]                 envs <- base::Sys.getenv()
[18:06:28.535]                 names <- names(envs)
[18:06:28.535]                 common <- intersect(names, old_names)
[18:06:28.535]                 added <- setdiff(names, old_names)
[18:06:28.535]                 removed <- setdiff(old_names, names)
[18:06:28.535]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:28.535]                   envs[common]]
[18:06:28.535]                 NAMES <- toupper(changed)
[18:06:28.535]                 args <- list()
[18:06:28.535]                 for (kk in seq_along(NAMES)) {
[18:06:28.535]                   name <- changed[[kk]]
[18:06:28.535]                   NAME <- NAMES[[kk]]
[18:06:28.535]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.535]                     next
[18:06:28.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.535]                 }
[18:06:28.535]                 NAMES <- toupper(added)
[18:06:28.535]                 for (kk in seq_along(NAMES)) {
[18:06:28.535]                   name <- added[[kk]]
[18:06:28.535]                   NAME <- NAMES[[kk]]
[18:06:28.535]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.535]                     next
[18:06:28.535]                   args[[name]] <- ""
[18:06:28.535]                 }
[18:06:28.535]                 NAMES <- toupper(removed)
[18:06:28.535]                 for (kk in seq_along(NAMES)) {
[18:06:28.535]                   name <- removed[[kk]]
[18:06:28.535]                   NAME <- NAMES[[kk]]
[18:06:28.535]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:28.535]                     next
[18:06:28.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:28.535]                 }
[18:06:28.535]                 if (length(args) > 0) 
[18:06:28.535]                   base::do.call(base::Sys.setenv, args = args)
[18:06:28.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:28.535]             }
[18:06:28.535]             else {
[18:06:28.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:28.535]             }
[18:06:28.535]             {
[18:06:28.535]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:28.535]                   0L) {
[18:06:28.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:28.535]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:28.535]                   base::options(opts)
[18:06:28.535]                 }
[18:06:28.535]                 {
[18:06:28.535]                   {
[18:06:28.535]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:28.535]                     NULL
[18:06:28.535]                   }
[18:06:28.535]                   options(future.plan = NULL)
[18:06:28.535]                   if (is.na(NA_character_)) 
[18:06:28.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:28.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:28.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:28.535]                     .init = FALSE)
[18:06:28.535]                 }
[18:06:28.535]             }
[18:06:28.535]         }
[18:06:28.535]     })
[18:06:28.535]     if (TRUE) {
[18:06:28.535]         base::sink(type = "output", split = FALSE)
[18:06:28.535]         if (TRUE) {
[18:06:28.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:28.535]         }
[18:06:28.535]         else {
[18:06:28.535]             ...future.result["stdout"] <- base::list(NULL)
[18:06:28.535]         }
[18:06:28.535]         base::close(...future.stdout)
[18:06:28.535]         ...future.stdout <- NULL
[18:06:28.535]     }
[18:06:28.535]     ...future.result$conditions <- ...future.conditions
[18:06:28.535]     ...future.result$finished <- base::Sys.time()
[18:06:28.535]     ...future.result
[18:06:28.535] }
[18:06:28.541] MultisessionFuture started
[18:06:28.541] - Launch lazy future ... done
[18:06:28.542] run() for ‘MultisessionFuture’ ... done
[18:06:28.542] resolve() on list ...
[18:06:28.542]  recursive: 0
[18:06:28.543]  length: 1
[18:06:28.543] 
[18:06:28.544] receiveMessageFromWorker() for ClusterFuture ...
[18:06:28.545] - Validating connection of MultisessionFuture
[18:06:28.545] - received message: FutureResult
[18:06:28.545] - Received FutureResult
[18:06:28.545] - Erased future from FutureRegistry
[18:06:28.546] result() for ClusterFuture ...
[18:06:28.546] - result already collected: FutureResult
[18:06:28.546] result() for ClusterFuture ... done
[18:06:28.546] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:28.546] Future #1
[18:06:28.547]  length: 0 (resolved future 1)
[18:06:28.547] resolve() on list ... DONE
[18:06:28.547] resolve() on list ...
[18:06:28.547]  recursive: 0
[18:06:28.548]  length: 1
[18:06:28.548] 
[18:06:29.086] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.087] - Validating connection of MultisessionFuture
[18:06:29.087] - received message: FutureResult
[18:06:29.088] - Received FutureResult
[18:06:29.088] - Erased future from FutureRegistry
[18:06:29.088] result() for ClusterFuture ...
[18:06:29.089] - result already collected: FutureResult
[18:06:29.089] result() for ClusterFuture ... done
[18:06:29.089] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.090] Future #1
[18:06:29.090]  length: 0 (resolved future 1)
[18:06:29.090] resolve() on list ... DONE
[18:06:29.091] resolve() on list ...
[18:06:29.091]  recursive: 0
[18:06:29.092]  length: 1
[18:06:29.092] 
[18:06:29.092]  length: 0 (resolved future 1)
[18:06:29.092] resolve() on list ... DONE
[18:06:29.093] resolve() on list ...
[18:06:29.093]  recursive: 0
[18:06:29.094]  length: 4
[18:06:29.094] 
[18:06:29.094] Future #1
[18:06:29.095]  length: 3 (resolved future 1)
[18:06:29.095] Future #2
[18:06:29.095]  length: 2 (resolved future 2)
[18:06:29.096]  length: 1 (resolved future 3)
[18:06:29.096]  length: 0 (resolved future 4)
[18:06:29.096] resolve() on list ... DONE
[18:06:29.097] resolve() on list ...
[18:06:29.097]  recursive: 0
[18:06:29.098]  length: 4
[18:06:29.098] 
[18:06:29.098] Future #1
[18:06:29.099]  length: 3 (resolved future 1)
[18:06:29.099] Future #2
[18:06:29.099]  length: 2 (resolved future 2)
[18:06:29.100]  length: 1 (resolved future 3)
[18:06:29.100]  length: 0 (resolved future 4)
[18:06:29.100] resolve() on list ... DONE
[18:06:29.101] resolve() on list ...
[18:06:29.101]  recursive: 0
[18:06:29.102]  length: 1
[18:06:29.102] 
[18:06:29.102]  length: 0 (resolved future 1)
[18:06:29.103] resolve() on list ... DONE
[18:06:29.103] getGlobalsAndPackages() ...
[18:06:29.103] Searching for globals...
[18:06:29.106] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:29.107] Searching for globals ... DONE
[18:06:29.107] Resolving globals: FALSE
[18:06:29.108] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:29.109] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:29.110] - globals: [1] ‘kk’
[18:06:29.110] 
[18:06:29.111] getGlobalsAndPackages() ... DONE
[18:06:29.111] run() for ‘Future’ ...
[18:06:29.112] - state: ‘created’
[18:06:29.112] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.151] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.152]   - Field: ‘node’
[18:06:29.153]   - Field: ‘label’
[18:06:29.153]   - Field: ‘local’
[18:06:29.153]   - Field: ‘owner’
[18:06:29.154]   - Field: ‘envir’
[18:06:29.154]   - Field: ‘workers’
[18:06:29.154]   - Field: ‘packages’
[18:06:29.154]   - Field: ‘gc’
[18:06:29.155]   - Field: ‘conditions’
[18:06:29.155]   - Field: ‘persistent’
[18:06:29.155]   - Field: ‘expr’
[18:06:29.156]   - Field: ‘uuid’
[18:06:29.156]   - Field: ‘seed’
[18:06:29.156]   - Field: ‘version’
[18:06:29.157]   - Field: ‘result’
[18:06:29.157]   - Field: ‘asynchronous’
[18:06:29.157]   - Field: ‘calls’
[18:06:29.157]   - Field: ‘globals’
[18:06:29.158]   - Field: ‘stdout’
[18:06:29.158]   - Field: ‘earlySignal’
[18:06:29.158]   - Field: ‘lazy’
[18:06:29.158]   - Field: ‘state’
[18:06:29.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.159] - Launch lazy future ...
[18:06:29.160] Packages needed by the future expression (n = 0): <none>
[18:06:29.160] Packages needed by future strategies (n = 0): <none>
[18:06:29.161] {
[18:06:29.161]     {
[18:06:29.161]         {
[18:06:29.161]             ...future.startTime <- base::Sys.time()
[18:06:29.161]             {
[18:06:29.161]                 {
[18:06:29.161]                   {
[18:06:29.161]                     {
[18:06:29.161]                       base::local({
[18:06:29.161]                         has_future <- base::requireNamespace("future", 
[18:06:29.161]                           quietly = TRUE)
[18:06:29.161]                         if (has_future) {
[18:06:29.161]                           ns <- base::getNamespace("future")
[18:06:29.161]                           version <- ns[[".package"]][["version"]]
[18:06:29.161]                           if (is.null(version)) 
[18:06:29.161]                             version <- utils::packageVersion("future")
[18:06:29.161]                         }
[18:06:29.161]                         else {
[18:06:29.161]                           version <- NULL
[18:06:29.161]                         }
[18:06:29.161]                         if (!has_future || version < "1.8.0") {
[18:06:29.161]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.161]                             "", base::R.version$version.string), 
[18:06:29.161]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.161]                               "release", "version")], collapse = " "), 
[18:06:29.161]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.161]                             info)
[18:06:29.161]                           info <- base::paste(info, collapse = "; ")
[18:06:29.161]                           if (!has_future) {
[18:06:29.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.161]                               info)
[18:06:29.161]                           }
[18:06:29.161]                           else {
[18:06:29.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.161]                               info, version)
[18:06:29.161]                           }
[18:06:29.161]                           base::stop(msg)
[18:06:29.161]                         }
[18:06:29.161]                       })
[18:06:29.161]                     }
[18:06:29.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.161]                     base::options(mc.cores = 1L)
[18:06:29.161]                   }
[18:06:29.161]                   ...future.strategy.old <- future::plan("list")
[18:06:29.161]                   options(future.plan = NULL)
[18:06:29.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.161]                 }
[18:06:29.161]                 ...future.workdir <- getwd()
[18:06:29.161]             }
[18:06:29.161]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.161]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.161]         }
[18:06:29.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.161]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.161]             base::names(...future.oldOptions))
[18:06:29.161]     }
[18:06:29.161]     if (FALSE) {
[18:06:29.161]     }
[18:06:29.161]     else {
[18:06:29.161]         if (TRUE) {
[18:06:29.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.161]                 open = "w")
[18:06:29.161]         }
[18:06:29.161]         else {
[18:06:29.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.161]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.161]         }
[18:06:29.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.161]             base::sink(type = "output", split = FALSE)
[18:06:29.161]             base::close(...future.stdout)
[18:06:29.161]         }, add = TRUE)
[18:06:29.161]     }
[18:06:29.161]     ...future.frame <- base::sys.nframe()
[18:06:29.161]     ...future.conditions <- base::list()
[18:06:29.161]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.161]     if (FALSE) {
[18:06:29.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.161]     }
[18:06:29.161]     ...future.result <- base::tryCatch({
[18:06:29.161]         base::withCallingHandlers({
[18:06:29.161]             ...future.value <- base::withVisible(base::local({
[18:06:29.161]                 ...future.makeSendCondition <- base::local({
[18:06:29.161]                   sendCondition <- NULL
[18:06:29.161]                   function(frame = 1L) {
[18:06:29.161]                     if (is.function(sendCondition)) 
[18:06:29.161]                       return(sendCondition)
[18:06:29.161]                     ns <- getNamespace("parallel")
[18:06:29.161]                     if (exists("sendData", mode = "function", 
[18:06:29.161]                       envir = ns)) {
[18:06:29.161]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.161]                         envir = ns)
[18:06:29.161]                       envir <- sys.frame(frame)
[18:06:29.161]                       master <- NULL
[18:06:29.161]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.161]                         !identical(envir, emptyenv())) {
[18:06:29.161]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.161]                           inherits = FALSE)) {
[18:06:29.161]                           master <- get("master", mode = "list", 
[18:06:29.161]                             envir = envir, inherits = FALSE)
[18:06:29.161]                           if (inherits(master, c("SOCKnode", 
[18:06:29.161]                             "SOCK0node"))) {
[18:06:29.161]                             sendCondition <<- function(cond) {
[18:06:29.161]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.161]                                 success = TRUE)
[18:06:29.161]                               parallel_sendData(master, data)
[18:06:29.161]                             }
[18:06:29.161]                             return(sendCondition)
[18:06:29.161]                           }
[18:06:29.161]                         }
[18:06:29.161]                         frame <- frame + 1L
[18:06:29.161]                         envir <- sys.frame(frame)
[18:06:29.161]                       }
[18:06:29.161]                     }
[18:06:29.161]                     sendCondition <<- function(cond) NULL
[18:06:29.161]                   }
[18:06:29.161]                 })
[18:06:29.161]                 withCallingHandlers({
[18:06:29.161]                   {
[18:06:29.161]                     Sys.sleep(0.1)
[18:06:29.161]                     kk
[18:06:29.161]                   }
[18:06:29.161]                 }, immediateCondition = function(cond) {
[18:06:29.161]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.161]                   sendCondition(cond)
[18:06:29.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.161]                   {
[18:06:29.161]                     inherits <- base::inherits
[18:06:29.161]                     invokeRestart <- base::invokeRestart
[18:06:29.161]                     is.null <- base::is.null
[18:06:29.161]                     muffled <- FALSE
[18:06:29.161]                     if (inherits(cond, "message")) {
[18:06:29.161]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.161]                       if (muffled) 
[18:06:29.161]                         invokeRestart("muffleMessage")
[18:06:29.161]                     }
[18:06:29.161]                     else if (inherits(cond, "warning")) {
[18:06:29.161]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.161]                       if (muffled) 
[18:06:29.161]                         invokeRestart("muffleWarning")
[18:06:29.161]                     }
[18:06:29.161]                     else if (inherits(cond, "condition")) {
[18:06:29.161]                       if (!is.null(pattern)) {
[18:06:29.161]                         computeRestarts <- base::computeRestarts
[18:06:29.161]                         grepl <- base::grepl
[18:06:29.161]                         restarts <- computeRestarts(cond)
[18:06:29.161]                         for (restart in restarts) {
[18:06:29.161]                           name <- restart$name
[18:06:29.161]                           if (is.null(name)) 
[18:06:29.161]                             next
[18:06:29.161]                           if (!grepl(pattern, name)) 
[18:06:29.161]                             next
[18:06:29.161]                           invokeRestart(restart)
[18:06:29.161]                           muffled <- TRUE
[18:06:29.161]                           break
[18:06:29.161]                         }
[18:06:29.161]                       }
[18:06:29.161]                     }
[18:06:29.161]                     invisible(muffled)
[18:06:29.161]                   }
[18:06:29.161]                   muffleCondition(cond)
[18:06:29.161]                 })
[18:06:29.161]             }))
[18:06:29.161]             future::FutureResult(value = ...future.value$value, 
[18:06:29.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.161]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.161]                     ...future.globalenv.names))
[18:06:29.161]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.161]         }, condition = base::local({
[18:06:29.161]             c <- base::c
[18:06:29.161]             inherits <- base::inherits
[18:06:29.161]             invokeRestart <- base::invokeRestart
[18:06:29.161]             length <- base::length
[18:06:29.161]             list <- base::list
[18:06:29.161]             seq.int <- base::seq.int
[18:06:29.161]             signalCondition <- base::signalCondition
[18:06:29.161]             sys.calls <- base::sys.calls
[18:06:29.161]             `[[` <- base::`[[`
[18:06:29.161]             `+` <- base::`+`
[18:06:29.161]             `<<-` <- base::`<<-`
[18:06:29.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.161]                   3L)]
[18:06:29.161]             }
[18:06:29.161]             function(cond) {
[18:06:29.161]                 is_error <- inherits(cond, "error")
[18:06:29.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.161]                   NULL)
[18:06:29.161]                 if (is_error) {
[18:06:29.161]                   sessionInformation <- function() {
[18:06:29.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.161]                       search = base::search(), system = base::Sys.info())
[18:06:29.161]                   }
[18:06:29.161]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.161]                     cond$call), session = sessionInformation(), 
[18:06:29.161]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.161]                   signalCondition(cond)
[18:06:29.161]                 }
[18:06:29.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.161]                 "immediateCondition"))) {
[18:06:29.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.161]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.161]                   if (TRUE && !signal) {
[18:06:29.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.161]                     {
[18:06:29.161]                       inherits <- base::inherits
[18:06:29.161]                       invokeRestart <- base::invokeRestart
[18:06:29.161]                       is.null <- base::is.null
[18:06:29.161]                       muffled <- FALSE
[18:06:29.161]                       if (inherits(cond, "message")) {
[18:06:29.161]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.161]                         if (muffled) 
[18:06:29.161]                           invokeRestart("muffleMessage")
[18:06:29.161]                       }
[18:06:29.161]                       else if (inherits(cond, "warning")) {
[18:06:29.161]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.161]                         if (muffled) 
[18:06:29.161]                           invokeRestart("muffleWarning")
[18:06:29.161]                       }
[18:06:29.161]                       else if (inherits(cond, "condition")) {
[18:06:29.161]                         if (!is.null(pattern)) {
[18:06:29.161]                           computeRestarts <- base::computeRestarts
[18:06:29.161]                           grepl <- base::grepl
[18:06:29.161]                           restarts <- computeRestarts(cond)
[18:06:29.161]                           for (restart in restarts) {
[18:06:29.161]                             name <- restart$name
[18:06:29.161]                             if (is.null(name)) 
[18:06:29.161]                               next
[18:06:29.161]                             if (!grepl(pattern, name)) 
[18:06:29.161]                               next
[18:06:29.161]                             invokeRestart(restart)
[18:06:29.161]                             muffled <- TRUE
[18:06:29.161]                             break
[18:06:29.161]                           }
[18:06:29.161]                         }
[18:06:29.161]                       }
[18:06:29.161]                       invisible(muffled)
[18:06:29.161]                     }
[18:06:29.161]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.161]                   }
[18:06:29.161]                 }
[18:06:29.161]                 else {
[18:06:29.161]                   if (TRUE) {
[18:06:29.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.161]                     {
[18:06:29.161]                       inherits <- base::inherits
[18:06:29.161]                       invokeRestart <- base::invokeRestart
[18:06:29.161]                       is.null <- base::is.null
[18:06:29.161]                       muffled <- FALSE
[18:06:29.161]                       if (inherits(cond, "message")) {
[18:06:29.161]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.161]                         if (muffled) 
[18:06:29.161]                           invokeRestart("muffleMessage")
[18:06:29.161]                       }
[18:06:29.161]                       else if (inherits(cond, "warning")) {
[18:06:29.161]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.161]                         if (muffled) 
[18:06:29.161]                           invokeRestart("muffleWarning")
[18:06:29.161]                       }
[18:06:29.161]                       else if (inherits(cond, "condition")) {
[18:06:29.161]                         if (!is.null(pattern)) {
[18:06:29.161]                           computeRestarts <- base::computeRestarts
[18:06:29.161]                           grepl <- base::grepl
[18:06:29.161]                           restarts <- computeRestarts(cond)
[18:06:29.161]                           for (restart in restarts) {
[18:06:29.161]                             name <- restart$name
[18:06:29.161]                             if (is.null(name)) 
[18:06:29.161]                               next
[18:06:29.161]                             if (!grepl(pattern, name)) 
[18:06:29.161]                               next
[18:06:29.161]                             invokeRestart(restart)
[18:06:29.161]                             muffled <- TRUE
[18:06:29.161]                             break
[18:06:29.161]                           }
[18:06:29.161]                         }
[18:06:29.161]                       }
[18:06:29.161]                       invisible(muffled)
[18:06:29.161]                     }
[18:06:29.161]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.161]                   }
[18:06:29.161]                 }
[18:06:29.161]             }
[18:06:29.161]         }))
[18:06:29.161]     }, error = function(ex) {
[18:06:29.161]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.161]                 ...future.rng), started = ...future.startTime, 
[18:06:29.161]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.161]             version = "1.8"), class = "FutureResult")
[18:06:29.161]     }, finally = {
[18:06:29.161]         if (!identical(...future.workdir, getwd())) 
[18:06:29.161]             setwd(...future.workdir)
[18:06:29.161]         {
[18:06:29.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.161]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.161]             }
[18:06:29.161]             base::options(...future.oldOptions)
[18:06:29.161]             if (.Platform$OS.type == "windows") {
[18:06:29.161]                 old_names <- names(...future.oldEnvVars)
[18:06:29.161]                 envs <- base::Sys.getenv()
[18:06:29.161]                 names <- names(envs)
[18:06:29.161]                 common <- intersect(names, old_names)
[18:06:29.161]                 added <- setdiff(names, old_names)
[18:06:29.161]                 removed <- setdiff(old_names, names)
[18:06:29.161]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.161]                   envs[common]]
[18:06:29.161]                 NAMES <- toupper(changed)
[18:06:29.161]                 args <- list()
[18:06:29.161]                 for (kk in seq_along(NAMES)) {
[18:06:29.161]                   name <- changed[[kk]]
[18:06:29.161]                   NAME <- NAMES[[kk]]
[18:06:29.161]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.161]                     next
[18:06:29.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.161]                 }
[18:06:29.161]                 NAMES <- toupper(added)
[18:06:29.161]                 for (kk in seq_along(NAMES)) {
[18:06:29.161]                   name <- added[[kk]]
[18:06:29.161]                   NAME <- NAMES[[kk]]
[18:06:29.161]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.161]                     next
[18:06:29.161]                   args[[name]] <- ""
[18:06:29.161]                 }
[18:06:29.161]                 NAMES <- toupper(removed)
[18:06:29.161]                 for (kk in seq_along(NAMES)) {
[18:06:29.161]                   name <- removed[[kk]]
[18:06:29.161]                   NAME <- NAMES[[kk]]
[18:06:29.161]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.161]                     next
[18:06:29.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.161]                 }
[18:06:29.161]                 if (length(args) > 0) 
[18:06:29.161]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.161]             }
[18:06:29.161]             else {
[18:06:29.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.161]             }
[18:06:29.161]             {
[18:06:29.161]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.161]                   0L) {
[18:06:29.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.161]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.161]                   base::options(opts)
[18:06:29.161]                 }
[18:06:29.161]                 {
[18:06:29.161]                   {
[18:06:29.161]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.161]                     NULL
[18:06:29.161]                   }
[18:06:29.161]                   options(future.plan = NULL)
[18:06:29.161]                   if (is.na(NA_character_)) 
[18:06:29.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.161]                     .init = FALSE)
[18:06:29.161]                 }
[18:06:29.161]             }
[18:06:29.161]         }
[18:06:29.161]     })
[18:06:29.161]     if (TRUE) {
[18:06:29.161]         base::sink(type = "output", split = FALSE)
[18:06:29.161]         if (TRUE) {
[18:06:29.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.161]         }
[18:06:29.161]         else {
[18:06:29.161]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.161]         }
[18:06:29.161]         base::close(...future.stdout)
[18:06:29.161]         ...future.stdout <- NULL
[18:06:29.161]     }
[18:06:29.161]     ...future.result$conditions <- ...future.conditions
[18:06:29.161]     ...future.result$finished <- base::Sys.time()
[18:06:29.161]     ...future.result
[18:06:29.161] }
[18:06:29.168] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:06:29.168] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[18:06:29.169] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[18:06:29.169] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:06:29.170] MultisessionFuture started
[18:06:29.171] - Launch lazy future ... done
[18:06:29.172] run() for ‘MultisessionFuture’ ... done
[18:06:29.172] getGlobalsAndPackages() ...
[18:06:29.172] Searching for globals...
[18:06:29.174] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:29.175] Searching for globals ... DONE
[18:06:29.175] Resolving globals: FALSE
[18:06:29.176] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:29.177] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:29.177] - globals: [1] ‘kk’
[18:06:29.177] 
[18:06:29.177] getGlobalsAndPackages() ... DONE
[18:06:29.178] run() for ‘Future’ ...
[18:06:29.178] - state: ‘created’
[18:06:29.178] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.202] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.202]   - Field: ‘node’
[18:06:29.203]   - Field: ‘label’
[18:06:29.203]   - Field: ‘local’
[18:06:29.203]   - Field: ‘owner’
[18:06:29.203]   - Field: ‘envir’
[18:06:29.203]   - Field: ‘workers’
[18:06:29.204]   - Field: ‘packages’
[18:06:29.204]   - Field: ‘gc’
[18:06:29.204]   - Field: ‘conditions’
[18:06:29.204]   - Field: ‘persistent’
[18:06:29.204]   - Field: ‘expr’
[18:06:29.205]   - Field: ‘uuid’
[18:06:29.205]   - Field: ‘seed’
[18:06:29.205]   - Field: ‘version’
[18:06:29.205]   - Field: ‘result’
[18:06:29.205]   - Field: ‘asynchronous’
[18:06:29.206]   - Field: ‘calls’
[18:06:29.206]   - Field: ‘globals’
[18:06:29.206]   - Field: ‘stdout’
[18:06:29.206]   - Field: ‘earlySignal’
[18:06:29.206]   - Field: ‘lazy’
[18:06:29.207]   - Field: ‘state’
[18:06:29.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.207] - Launch lazy future ...
[18:06:29.207] Packages needed by the future expression (n = 0): <none>
[18:06:29.208] Packages needed by future strategies (n = 0): <none>
[18:06:29.209] {
[18:06:29.209]     {
[18:06:29.209]         {
[18:06:29.209]             ...future.startTime <- base::Sys.time()
[18:06:29.209]             {
[18:06:29.209]                 {
[18:06:29.209]                   {
[18:06:29.209]                     {
[18:06:29.209]                       base::local({
[18:06:29.209]                         has_future <- base::requireNamespace("future", 
[18:06:29.209]                           quietly = TRUE)
[18:06:29.209]                         if (has_future) {
[18:06:29.209]                           ns <- base::getNamespace("future")
[18:06:29.209]                           version <- ns[[".package"]][["version"]]
[18:06:29.209]                           if (is.null(version)) 
[18:06:29.209]                             version <- utils::packageVersion("future")
[18:06:29.209]                         }
[18:06:29.209]                         else {
[18:06:29.209]                           version <- NULL
[18:06:29.209]                         }
[18:06:29.209]                         if (!has_future || version < "1.8.0") {
[18:06:29.209]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.209]                             "", base::R.version$version.string), 
[18:06:29.209]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.209]                               "release", "version")], collapse = " "), 
[18:06:29.209]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.209]                             info)
[18:06:29.209]                           info <- base::paste(info, collapse = "; ")
[18:06:29.209]                           if (!has_future) {
[18:06:29.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.209]                               info)
[18:06:29.209]                           }
[18:06:29.209]                           else {
[18:06:29.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.209]                               info, version)
[18:06:29.209]                           }
[18:06:29.209]                           base::stop(msg)
[18:06:29.209]                         }
[18:06:29.209]                       })
[18:06:29.209]                     }
[18:06:29.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.209]                     base::options(mc.cores = 1L)
[18:06:29.209]                   }
[18:06:29.209]                   ...future.strategy.old <- future::plan("list")
[18:06:29.209]                   options(future.plan = NULL)
[18:06:29.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.209]                 }
[18:06:29.209]                 ...future.workdir <- getwd()
[18:06:29.209]             }
[18:06:29.209]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.209]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.209]         }
[18:06:29.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.209]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.209]             base::names(...future.oldOptions))
[18:06:29.209]     }
[18:06:29.209]     if (FALSE) {
[18:06:29.209]     }
[18:06:29.209]     else {
[18:06:29.209]         if (TRUE) {
[18:06:29.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.209]                 open = "w")
[18:06:29.209]         }
[18:06:29.209]         else {
[18:06:29.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.209]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.209]         }
[18:06:29.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.209]             base::sink(type = "output", split = FALSE)
[18:06:29.209]             base::close(...future.stdout)
[18:06:29.209]         }, add = TRUE)
[18:06:29.209]     }
[18:06:29.209]     ...future.frame <- base::sys.nframe()
[18:06:29.209]     ...future.conditions <- base::list()
[18:06:29.209]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.209]     if (FALSE) {
[18:06:29.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.209]     }
[18:06:29.209]     ...future.result <- base::tryCatch({
[18:06:29.209]         base::withCallingHandlers({
[18:06:29.209]             ...future.value <- base::withVisible(base::local({
[18:06:29.209]                 ...future.makeSendCondition <- base::local({
[18:06:29.209]                   sendCondition <- NULL
[18:06:29.209]                   function(frame = 1L) {
[18:06:29.209]                     if (is.function(sendCondition)) 
[18:06:29.209]                       return(sendCondition)
[18:06:29.209]                     ns <- getNamespace("parallel")
[18:06:29.209]                     if (exists("sendData", mode = "function", 
[18:06:29.209]                       envir = ns)) {
[18:06:29.209]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.209]                         envir = ns)
[18:06:29.209]                       envir <- sys.frame(frame)
[18:06:29.209]                       master <- NULL
[18:06:29.209]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.209]                         !identical(envir, emptyenv())) {
[18:06:29.209]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.209]                           inherits = FALSE)) {
[18:06:29.209]                           master <- get("master", mode = "list", 
[18:06:29.209]                             envir = envir, inherits = FALSE)
[18:06:29.209]                           if (inherits(master, c("SOCKnode", 
[18:06:29.209]                             "SOCK0node"))) {
[18:06:29.209]                             sendCondition <<- function(cond) {
[18:06:29.209]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.209]                                 success = TRUE)
[18:06:29.209]                               parallel_sendData(master, data)
[18:06:29.209]                             }
[18:06:29.209]                             return(sendCondition)
[18:06:29.209]                           }
[18:06:29.209]                         }
[18:06:29.209]                         frame <- frame + 1L
[18:06:29.209]                         envir <- sys.frame(frame)
[18:06:29.209]                       }
[18:06:29.209]                     }
[18:06:29.209]                     sendCondition <<- function(cond) NULL
[18:06:29.209]                   }
[18:06:29.209]                 })
[18:06:29.209]                 withCallingHandlers({
[18:06:29.209]                   {
[18:06:29.209]                     Sys.sleep(0.1)
[18:06:29.209]                     kk
[18:06:29.209]                   }
[18:06:29.209]                 }, immediateCondition = function(cond) {
[18:06:29.209]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.209]                   sendCondition(cond)
[18:06:29.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.209]                   {
[18:06:29.209]                     inherits <- base::inherits
[18:06:29.209]                     invokeRestart <- base::invokeRestart
[18:06:29.209]                     is.null <- base::is.null
[18:06:29.209]                     muffled <- FALSE
[18:06:29.209]                     if (inherits(cond, "message")) {
[18:06:29.209]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.209]                       if (muffled) 
[18:06:29.209]                         invokeRestart("muffleMessage")
[18:06:29.209]                     }
[18:06:29.209]                     else if (inherits(cond, "warning")) {
[18:06:29.209]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.209]                       if (muffled) 
[18:06:29.209]                         invokeRestart("muffleWarning")
[18:06:29.209]                     }
[18:06:29.209]                     else if (inherits(cond, "condition")) {
[18:06:29.209]                       if (!is.null(pattern)) {
[18:06:29.209]                         computeRestarts <- base::computeRestarts
[18:06:29.209]                         grepl <- base::grepl
[18:06:29.209]                         restarts <- computeRestarts(cond)
[18:06:29.209]                         for (restart in restarts) {
[18:06:29.209]                           name <- restart$name
[18:06:29.209]                           if (is.null(name)) 
[18:06:29.209]                             next
[18:06:29.209]                           if (!grepl(pattern, name)) 
[18:06:29.209]                             next
[18:06:29.209]                           invokeRestart(restart)
[18:06:29.209]                           muffled <- TRUE
[18:06:29.209]                           break
[18:06:29.209]                         }
[18:06:29.209]                       }
[18:06:29.209]                     }
[18:06:29.209]                     invisible(muffled)
[18:06:29.209]                   }
[18:06:29.209]                   muffleCondition(cond)
[18:06:29.209]                 })
[18:06:29.209]             }))
[18:06:29.209]             future::FutureResult(value = ...future.value$value, 
[18:06:29.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.209]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.209]                     ...future.globalenv.names))
[18:06:29.209]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.209]         }, condition = base::local({
[18:06:29.209]             c <- base::c
[18:06:29.209]             inherits <- base::inherits
[18:06:29.209]             invokeRestart <- base::invokeRestart
[18:06:29.209]             length <- base::length
[18:06:29.209]             list <- base::list
[18:06:29.209]             seq.int <- base::seq.int
[18:06:29.209]             signalCondition <- base::signalCondition
[18:06:29.209]             sys.calls <- base::sys.calls
[18:06:29.209]             `[[` <- base::`[[`
[18:06:29.209]             `+` <- base::`+`
[18:06:29.209]             `<<-` <- base::`<<-`
[18:06:29.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.209]                   3L)]
[18:06:29.209]             }
[18:06:29.209]             function(cond) {
[18:06:29.209]                 is_error <- inherits(cond, "error")
[18:06:29.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.209]                   NULL)
[18:06:29.209]                 if (is_error) {
[18:06:29.209]                   sessionInformation <- function() {
[18:06:29.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.209]                       search = base::search(), system = base::Sys.info())
[18:06:29.209]                   }
[18:06:29.209]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.209]                     cond$call), session = sessionInformation(), 
[18:06:29.209]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.209]                   signalCondition(cond)
[18:06:29.209]                 }
[18:06:29.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.209]                 "immediateCondition"))) {
[18:06:29.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.209]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.209]                   if (TRUE && !signal) {
[18:06:29.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.209]                     {
[18:06:29.209]                       inherits <- base::inherits
[18:06:29.209]                       invokeRestart <- base::invokeRestart
[18:06:29.209]                       is.null <- base::is.null
[18:06:29.209]                       muffled <- FALSE
[18:06:29.209]                       if (inherits(cond, "message")) {
[18:06:29.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.209]                         if (muffled) 
[18:06:29.209]                           invokeRestart("muffleMessage")
[18:06:29.209]                       }
[18:06:29.209]                       else if (inherits(cond, "warning")) {
[18:06:29.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.209]                         if (muffled) 
[18:06:29.209]                           invokeRestart("muffleWarning")
[18:06:29.209]                       }
[18:06:29.209]                       else if (inherits(cond, "condition")) {
[18:06:29.209]                         if (!is.null(pattern)) {
[18:06:29.209]                           computeRestarts <- base::computeRestarts
[18:06:29.209]                           grepl <- base::grepl
[18:06:29.209]                           restarts <- computeRestarts(cond)
[18:06:29.209]                           for (restart in restarts) {
[18:06:29.209]                             name <- restart$name
[18:06:29.209]                             if (is.null(name)) 
[18:06:29.209]                               next
[18:06:29.209]                             if (!grepl(pattern, name)) 
[18:06:29.209]                               next
[18:06:29.209]                             invokeRestart(restart)
[18:06:29.209]                             muffled <- TRUE
[18:06:29.209]                             break
[18:06:29.209]                           }
[18:06:29.209]                         }
[18:06:29.209]                       }
[18:06:29.209]                       invisible(muffled)
[18:06:29.209]                     }
[18:06:29.209]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.209]                   }
[18:06:29.209]                 }
[18:06:29.209]                 else {
[18:06:29.209]                   if (TRUE) {
[18:06:29.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.209]                     {
[18:06:29.209]                       inherits <- base::inherits
[18:06:29.209]                       invokeRestart <- base::invokeRestart
[18:06:29.209]                       is.null <- base::is.null
[18:06:29.209]                       muffled <- FALSE
[18:06:29.209]                       if (inherits(cond, "message")) {
[18:06:29.209]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.209]                         if (muffled) 
[18:06:29.209]                           invokeRestart("muffleMessage")
[18:06:29.209]                       }
[18:06:29.209]                       else if (inherits(cond, "warning")) {
[18:06:29.209]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.209]                         if (muffled) 
[18:06:29.209]                           invokeRestart("muffleWarning")
[18:06:29.209]                       }
[18:06:29.209]                       else if (inherits(cond, "condition")) {
[18:06:29.209]                         if (!is.null(pattern)) {
[18:06:29.209]                           computeRestarts <- base::computeRestarts
[18:06:29.209]                           grepl <- base::grepl
[18:06:29.209]                           restarts <- computeRestarts(cond)
[18:06:29.209]                           for (restart in restarts) {
[18:06:29.209]                             name <- restart$name
[18:06:29.209]                             if (is.null(name)) 
[18:06:29.209]                               next
[18:06:29.209]                             if (!grepl(pattern, name)) 
[18:06:29.209]                               next
[18:06:29.209]                             invokeRestart(restart)
[18:06:29.209]                             muffled <- TRUE
[18:06:29.209]                             break
[18:06:29.209]                           }
[18:06:29.209]                         }
[18:06:29.209]                       }
[18:06:29.209]                       invisible(muffled)
[18:06:29.209]                     }
[18:06:29.209]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.209]                   }
[18:06:29.209]                 }
[18:06:29.209]             }
[18:06:29.209]         }))
[18:06:29.209]     }, error = function(ex) {
[18:06:29.209]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.209]                 ...future.rng), started = ...future.startTime, 
[18:06:29.209]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.209]             version = "1.8"), class = "FutureResult")
[18:06:29.209]     }, finally = {
[18:06:29.209]         if (!identical(...future.workdir, getwd())) 
[18:06:29.209]             setwd(...future.workdir)
[18:06:29.209]         {
[18:06:29.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.209]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.209]             }
[18:06:29.209]             base::options(...future.oldOptions)
[18:06:29.209]             if (.Platform$OS.type == "windows") {
[18:06:29.209]                 old_names <- names(...future.oldEnvVars)
[18:06:29.209]                 envs <- base::Sys.getenv()
[18:06:29.209]                 names <- names(envs)
[18:06:29.209]                 common <- intersect(names, old_names)
[18:06:29.209]                 added <- setdiff(names, old_names)
[18:06:29.209]                 removed <- setdiff(old_names, names)
[18:06:29.209]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.209]                   envs[common]]
[18:06:29.209]                 NAMES <- toupper(changed)
[18:06:29.209]                 args <- list()
[18:06:29.209]                 for (kk in seq_along(NAMES)) {
[18:06:29.209]                   name <- changed[[kk]]
[18:06:29.209]                   NAME <- NAMES[[kk]]
[18:06:29.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.209]                     next
[18:06:29.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.209]                 }
[18:06:29.209]                 NAMES <- toupper(added)
[18:06:29.209]                 for (kk in seq_along(NAMES)) {
[18:06:29.209]                   name <- added[[kk]]
[18:06:29.209]                   NAME <- NAMES[[kk]]
[18:06:29.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.209]                     next
[18:06:29.209]                   args[[name]] <- ""
[18:06:29.209]                 }
[18:06:29.209]                 NAMES <- toupper(removed)
[18:06:29.209]                 for (kk in seq_along(NAMES)) {
[18:06:29.209]                   name <- removed[[kk]]
[18:06:29.209]                   NAME <- NAMES[[kk]]
[18:06:29.209]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.209]                     next
[18:06:29.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.209]                 }
[18:06:29.209]                 if (length(args) > 0) 
[18:06:29.209]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.209]             }
[18:06:29.209]             else {
[18:06:29.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.209]             }
[18:06:29.209]             {
[18:06:29.209]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.209]                   0L) {
[18:06:29.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.209]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.209]                   base::options(opts)
[18:06:29.209]                 }
[18:06:29.209]                 {
[18:06:29.209]                   {
[18:06:29.209]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.209]                     NULL
[18:06:29.209]                   }
[18:06:29.209]                   options(future.plan = NULL)
[18:06:29.209]                   if (is.na(NA_character_)) 
[18:06:29.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.209]                     .init = FALSE)
[18:06:29.209]                 }
[18:06:29.209]             }
[18:06:29.209]         }
[18:06:29.209]     })
[18:06:29.209]     if (TRUE) {
[18:06:29.209]         base::sink(type = "output", split = FALSE)
[18:06:29.209]         if (TRUE) {
[18:06:29.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.209]         }
[18:06:29.209]         else {
[18:06:29.209]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.209]         }
[18:06:29.209]         base::close(...future.stdout)
[18:06:29.209]         ...future.stdout <- NULL
[18:06:29.209]     }
[18:06:29.209]     ...future.result$conditions <- ...future.conditions
[18:06:29.209]     ...future.result$finished <- base::Sys.time()
[18:06:29.209]     ...future.result
[18:06:29.209] }
[18:06:29.214] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:06:29.214] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[18:06:29.215] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[18:06:29.215] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:06:29.216] MultisessionFuture started
[18:06:29.217] - Launch lazy future ... done
[18:06:29.217] run() for ‘MultisessionFuture’ ... done
[18:06:29.217] getGlobalsAndPackages() ...
[18:06:29.217] Searching for globals...
[18:06:29.219] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:29.220] Searching for globals ... DONE
[18:06:29.220] Resolving globals: FALSE
[18:06:29.220] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:29.221] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:29.221] - globals: [1] ‘kk’
[18:06:29.222] 
[18:06:29.222] getGlobalsAndPackages() ... DONE
[18:06:29.222] run() for ‘Future’ ...
[18:06:29.222] - state: ‘created’
[18:06:29.223] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.247] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.248]   - Field: ‘node’
[18:06:29.248]   - Field: ‘label’
[18:06:29.248]   - Field: ‘local’
[18:06:29.248]   - Field: ‘owner’
[18:06:29.248]   - Field: ‘envir’
[18:06:29.249]   - Field: ‘workers’
[18:06:29.249]   - Field: ‘packages’
[18:06:29.249]   - Field: ‘gc’
[18:06:29.249]   - Field: ‘conditions’
[18:06:29.249]   - Field: ‘persistent’
[18:06:29.250]   - Field: ‘expr’
[18:06:29.250]   - Field: ‘uuid’
[18:06:29.250]   - Field: ‘seed’
[18:06:29.250]   - Field: ‘version’
[18:06:29.250]   - Field: ‘result’
[18:06:29.251]   - Field: ‘asynchronous’
[18:06:29.251]   - Field: ‘calls’
[18:06:29.255]   - Field: ‘globals’
[18:06:29.255]   - Field: ‘stdout’
[18:06:29.255]   - Field: ‘earlySignal’
[18:06:29.256]   - Field: ‘lazy’
[18:06:29.256]   - Field: ‘state’
[18:06:29.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.256] - Launch lazy future ...
[18:06:29.257] Packages needed by the future expression (n = 0): <none>
[18:06:29.257] Packages needed by future strategies (n = 0): <none>
[18:06:29.258] {
[18:06:29.258]     {
[18:06:29.258]         {
[18:06:29.258]             ...future.startTime <- base::Sys.time()
[18:06:29.258]             {
[18:06:29.258]                 {
[18:06:29.258]                   {
[18:06:29.258]                     {
[18:06:29.258]                       base::local({
[18:06:29.258]                         has_future <- base::requireNamespace("future", 
[18:06:29.258]                           quietly = TRUE)
[18:06:29.258]                         if (has_future) {
[18:06:29.258]                           ns <- base::getNamespace("future")
[18:06:29.258]                           version <- ns[[".package"]][["version"]]
[18:06:29.258]                           if (is.null(version)) 
[18:06:29.258]                             version <- utils::packageVersion("future")
[18:06:29.258]                         }
[18:06:29.258]                         else {
[18:06:29.258]                           version <- NULL
[18:06:29.258]                         }
[18:06:29.258]                         if (!has_future || version < "1.8.0") {
[18:06:29.258]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.258]                             "", base::R.version$version.string), 
[18:06:29.258]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.258]                               "release", "version")], collapse = " "), 
[18:06:29.258]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.258]                             info)
[18:06:29.258]                           info <- base::paste(info, collapse = "; ")
[18:06:29.258]                           if (!has_future) {
[18:06:29.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.258]                               info)
[18:06:29.258]                           }
[18:06:29.258]                           else {
[18:06:29.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.258]                               info, version)
[18:06:29.258]                           }
[18:06:29.258]                           base::stop(msg)
[18:06:29.258]                         }
[18:06:29.258]                       })
[18:06:29.258]                     }
[18:06:29.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.258]                     base::options(mc.cores = 1L)
[18:06:29.258]                   }
[18:06:29.258]                   ...future.strategy.old <- future::plan("list")
[18:06:29.258]                   options(future.plan = NULL)
[18:06:29.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.258]                 }
[18:06:29.258]                 ...future.workdir <- getwd()
[18:06:29.258]             }
[18:06:29.258]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.258]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.258]         }
[18:06:29.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.258]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.258]             base::names(...future.oldOptions))
[18:06:29.258]     }
[18:06:29.258]     if (FALSE) {
[18:06:29.258]     }
[18:06:29.258]     else {
[18:06:29.258]         if (TRUE) {
[18:06:29.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.258]                 open = "w")
[18:06:29.258]         }
[18:06:29.258]         else {
[18:06:29.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.258]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.258]         }
[18:06:29.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.258]             base::sink(type = "output", split = FALSE)
[18:06:29.258]             base::close(...future.stdout)
[18:06:29.258]         }, add = TRUE)
[18:06:29.258]     }
[18:06:29.258]     ...future.frame <- base::sys.nframe()
[18:06:29.258]     ...future.conditions <- base::list()
[18:06:29.258]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.258]     if (FALSE) {
[18:06:29.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.258]     }
[18:06:29.258]     ...future.result <- base::tryCatch({
[18:06:29.258]         base::withCallingHandlers({
[18:06:29.258]             ...future.value <- base::withVisible(base::local({
[18:06:29.258]                 ...future.makeSendCondition <- base::local({
[18:06:29.258]                   sendCondition <- NULL
[18:06:29.258]                   function(frame = 1L) {
[18:06:29.258]                     if (is.function(sendCondition)) 
[18:06:29.258]                       return(sendCondition)
[18:06:29.258]                     ns <- getNamespace("parallel")
[18:06:29.258]                     if (exists("sendData", mode = "function", 
[18:06:29.258]                       envir = ns)) {
[18:06:29.258]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.258]                         envir = ns)
[18:06:29.258]                       envir <- sys.frame(frame)
[18:06:29.258]                       master <- NULL
[18:06:29.258]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.258]                         !identical(envir, emptyenv())) {
[18:06:29.258]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.258]                           inherits = FALSE)) {
[18:06:29.258]                           master <- get("master", mode = "list", 
[18:06:29.258]                             envir = envir, inherits = FALSE)
[18:06:29.258]                           if (inherits(master, c("SOCKnode", 
[18:06:29.258]                             "SOCK0node"))) {
[18:06:29.258]                             sendCondition <<- function(cond) {
[18:06:29.258]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.258]                                 success = TRUE)
[18:06:29.258]                               parallel_sendData(master, data)
[18:06:29.258]                             }
[18:06:29.258]                             return(sendCondition)
[18:06:29.258]                           }
[18:06:29.258]                         }
[18:06:29.258]                         frame <- frame + 1L
[18:06:29.258]                         envir <- sys.frame(frame)
[18:06:29.258]                       }
[18:06:29.258]                     }
[18:06:29.258]                     sendCondition <<- function(cond) NULL
[18:06:29.258]                   }
[18:06:29.258]                 })
[18:06:29.258]                 withCallingHandlers({
[18:06:29.258]                   {
[18:06:29.258]                     Sys.sleep(0.1)
[18:06:29.258]                     kk
[18:06:29.258]                   }
[18:06:29.258]                 }, immediateCondition = function(cond) {
[18:06:29.258]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.258]                   sendCondition(cond)
[18:06:29.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.258]                   {
[18:06:29.258]                     inherits <- base::inherits
[18:06:29.258]                     invokeRestart <- base::invokeRestart
[18:06:29.258]                     is.null <- base::is.null
[18:06:29.258]                     muffled <- FALSE
[18:06:29.258]                     if (inherits(cond, "message")) {
[18:06:29.258]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.258]                       if (muffled) 
[18:06:29.258]                         invokeRestart("muffleMessage")
[18:06:29.258]                     }
[18:06:29.258]                     else if (inherits(cond, "warning")) {
[18:06:29.258]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.258]                       if (muffled) 
[18:06:29.258]                         invokeRestart("muffleWarning")
[18:06:29.258]                     }
[18:06:29.258]                     else if (inherits(cond, "condition")) {
[18:06:29.258]                       if (!is.null(pattern)) {
[18:06:29.258]                         computeRestarts <- base::computeRestarts
[18:06:29.258]                         grepl <- base::grepl
[18:06:29.258]                         restarts <- computeRestarts(cond)
[18:06:29.258]                         for (restart in restarts) {
[18:06:29.258]                           name <- restart$name
[18:06:29.258]                           if (is.null(name)) 
[18:06:29.258]                             next
[18:06:29.258]                           if (!grepl(pattern, name)) 
[18:06:29.258]                             next
[18:06:29.258]                           invokeRestart(restart)
[18:06:29.258]                           muffled <- TRUE
[18:06:29.258]                           break
[18:06:29.258]                         }
[18:06:29.258]                       }
[18:06:29.258]                     }
[18:06:29.258]                     invisible(muffled)
[18:06:29.258]                   }
[18:06:29.258]                   muffleCondition(cond)
[18:06:29.258]                 })
[18:06:29.258]             }))
[18:06:29.258]             future::FutureResult(value = ...future.value$value, 
[18:06:29.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.258]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.258]                     ...future.globalenv.names))
[18:06:29.258]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.258]         }, condition = base::local({
[18:06:29.258]             c <- base::c
[18:06:29.258]             inherits <- base::inherits
[18:06:29.258]             invokeRestart <- base::invokeRestart
[18:06:29.258]             length <- base::length
[18:06:29.258]             list <- base::list
[18:06:29.258]             seq.int <- base::seq.int
[18:06:29.258]             signalCondition <- base::signalCondition
[18:06:29.258]             sys.calls <- base::sys.calls
[18:06:29.258]             `[[` <- base::`[[`
[18:06:29.258]             `+` <- base::`+`
[18:06:29.258]             `<<-` <- base::`<<-`
[18:06:29.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.258]                   3L)]
[18:06:29.258]             }
[18:06:29.258]             function(cond) {
[18:06:29.258]                 is_error <- inherits(cond, "error")
[18:06:29.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.258]                   NULL)
[18:06:29.258]                 if (is_error) {
[18:06:29.258]                   sessionInformation <- function() {
[18:06:29.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.258]                       search = base::search(), system = base::Sys.info())
[18:06:29.258]                   }
[18:06:29.258]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.258]                     cond$call), session = sessionInformation(), 
[18:06:29.258]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.258]                   signalCondition(cond)
[18:06:29.258]                 }
[18:06:29.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.258]                 "immediateCondition"))) {
[18:06:29.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.258]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.258]                   if (TRUE && !signal) {
[18:06:29.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.258]                     {
[18:06:29.258]                       inherits <- base::inherits
[18:06:29.258]                       invokeRestart <- base::invokeRestart
[18:06:29.258]                       is.null <- base::is.null
[18:06:29.258]                       muffled <- FALSE
[18:06:29.258]                       if (inherits(cond, "message")) {
[18:06:29.258]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.258]                         if (muffled) 
[18:06:29.258]                           invokeRestart("muffleMessage")
[18:06:29.258]                       }
[18:06:29.258]                       else if (inherits(cond, "warning")) {
[18:06:29.258]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.258]                         if (muffled) 
[18:06:29.258]                           invokeRestart("muffleWarning")
[18:06:29.258]                       }
[18:06:29.258]                       else if (inherits(cond, "condition")) {
[18:06:29.258]                         if (!is.null(pattern)) {
[18:06:29.258]                           computeRestarts <- base::computeRestarts
[18:06:29.258]                           grepl <- base::grepl
[18:06:29.258]                           restarts <- computeRestarts(cond)
[18:06:29.258]                           for (restart in restarts) {
[18:06:29.258]                             name <- restart$name
[18:06:29.258]                             if (is.null(name)) 
[18:06:29.258]                               next
[18:06:29.258]                             if (!grepl(pattern, name)) 
[18:06:29.258]                               next
[18:06:29.258]                             invokeRestart(restart)
[18:06:29.258]                             muffled <- TRUE
[18:06:29.258]                             break
[18:06:29.258]                           }
[18:06:29.258]                         }
[18:06:29.258]                       }
[18:06:29.258]                       invisible(muffled)
[18:06:29.258]                     }
[18:06:29.258]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.258]                   }
[18:06:29.258]                 }
[18:06:29.258]                 else {
[18:06:29.258]                   if (TRUE) {
[18:06:29.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.258]                     {
[18:06:29.258]                       inherits <- base::inherits
[18:06:29.258]                       invokeRestart <- base::invokeRestart
[18:06:29.258]                       is.null <- base::is.null
[18:06:29.258]                       muffled <- FALSE
[18:06:29.258]                       if (inherits(cond, "message")) {
[18:06:29.258]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.258]                         if (muffled) 
[18:06:29.258]                           invokeRestart("muffleMessage")
[18:06:29.258]                       }
[18:06:29.258]                       else if (inherits(cond, "warning")) {
[18:06:29.258]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.258]                         if (muffled) 
[18:06:29.258]                           invokeRestart("muffleWarning")
[18:06:29.258]                       }
[18:06:29.258]                       else if (inherits(cond, "condition")) {
[18:06:29.258]                         if (!is.null(pattern)) {
[18:06:29.258]                           computeRestarts <- base::computeRestarts
[18:06:29.258]                           grepl <- base::grepl
[18:06:29.258]                           restarts <- computeRestarts(cond)
[18:06:29.258]                           for (restart in restarts) {
[18:06:29.258]                             name <- restart$name
[18:06:29.258]                             if (is.null(name)) 
[18:06:29.258]                               next
[18:06:29.258]                             if (!grepl(pattern, name)) 
[18:06:29.258]                               next
[18:06:29.258]                             invokeRestart(restart)
[18:06:29.258]                             muffled <- TRUE
[18:06:29.258]                             break
[18:06:29.258]                           }
[18:06:29.258]                         }
[18:06:29.258]                       }
[18:06:29.258]                       invisible(muffled)
[18:06:29.258]                     }
[18:06:29.258]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.258]                   }
[18:06:29.258]                 }
[18:06:29.258]             }
[18:06:29.258]         }))
[18:06:29.258]     }, error = function(ex) {
[18:06:29.258]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.258]                 ...future.rng), started = ...future.startTime, 
[18:06:29.258]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.258]             version = "1.8"), class = "FutureResult")
[18:06:29.258]     }, finally = {
[18:06:29.258]         if (!identical(...future.workdir, getwd())) 
[18:06:29.258]             setwd(...future.workdir)
[18:06:29.258]         {
[18:06:29.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.258]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.258]             }
[18:06:29.258]             base::options(...future.oldOptions)
[18:06:29.258]             if (.Platform$OS.type == "windows") {
[18:06:29.258]                 old_names <- names(...future.oldEnvVars)
[18:06:29.258]                 envs <- base::Sys.getenv()
[18:06:29.258]                 names <- names(envs)
[18:06:29.258]                 common <- intersect(names, old_names)
[18:06:29.258]                 added <- setdiff(names, old_names)
[18:06:29.258]                 removed <- setdiff(old_names, names)
[18:06:29.258]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.258]                   envs[common]]
[18:06:29.258]                 NAMES <- toupper(changed)
[18:06:29.258]                 args <- list()
[18:06:29.258]                 for (kk in seq_along(NAMES)) {
[18:06:29.258]                   name <- changed[[kk]]
[18:06:29.258]                   NAME <- NAMES[[kk]]
[18:06:29.258]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.258]                     next
[18:06:29.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.258]                 }
[18:06:29.258]                 NAMES <- toupper(added)
[18:06:29.258]                 for (kk in seq_along(NAMES)) {
[18:06:29.258]                   name <- added[[kk]]
[18:06:29.258]                   NAME <- NAMES[[kk]]
[18:06:29.258]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.258]                     next
[18:06:29.258]                   args[[name]] <- ""
[18:06:29.258]                 }
[18:06:29.258]                 NAMES <- toupper(removed)
[18:06:29.258]                 for (kk in seq_along(NAMES)) {
[18:06:29.258]                   name <- removed[[kk]]
[18:06:29.258]                   NAME <- NAMES[[kk]]
[18:06:29.258]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.258]                     next
[18:06:29.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.258]                 }
[18:06:29.258]                 if (length(args) > 0) 
[18:06:29.258]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.258]             }
[18:06:29.258]             else {
[18:06:29.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.258]             }
[18:06:29.258]             {
[18:06:29.258]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.258]                   0L) {
[18:06:29.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.258]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.258]                   base::options(opts)
[18:06:29.258]                 }
[18:06:29.258]                 {
[18:06:29.258]                   {
[18:06:29.258]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.258]                     NULL
[18:06:29.258]                   }
[18:06:29.258]                   options(future.plan = NULL)
[18:06:29.258]                   if (is.na(NA_character_)) 
[18:06:29.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.258]                     .init = FALSE)
[18:06:29.258]                 }
[18:06:29.258]             }
[18:06:29.258]         }
[18:06:29.258]     })
[18:06:29.258]     if (TRUE) {
[18:06:29.258]         base::sink(type = "output", split = FALSE)
[18:06:29.258]         if (TRUE) {
[18:06:29.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.258]         }
[18:06:29.258]         else {
[18:06:29.258]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.258]         }
[18:06:29.258]         base::close(...future.stdout)
[18:06:29.258]         ...future.stdout <- NULL
[18:06:29.258]     }
[18:06:29.258]     ...future.result$conditions <- ...future.conditions
[18:06:29.258]     ...future.result$finished <- base::Sys.time()
[18:06:29.258]     ...future.result
[18:06:29.258] }
[18:06:29.262] Poll #1 (0): usedNodes() = 2, workers = 2
[18:06:29.295] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[18:06:29.316] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.317] - Validating connection of MultisessionFuture
[18:06:29.317] - received message: FutureResult
[18:06:29.318] - Received FutureResult
[18:06:29.318] - Erased future from FutureRegistry
[18:06:29.318] result() for ClusterFuture ...
[18:06:29.318] - result already collected: FutureResult
[18:06:29.319] result() for ClusterFuture ... done
[18:06:29.319] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.319] result() for ClusterFuture ...
[18:06:29.319] - result already collected: FutureResult
[18:06:29.320] result() for ClusterFuture ... done
[18:06:29.320] result() for ClusterFuture ...
[18:06:29.320] - result already collected: FutureResult
[18:06:29.320] result() for ClusterFuture ... done
[18:06:29.322] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:06:29.322] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[18:06:29.323] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[18:06:29.324] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:06:29.325] MultisessionFuture started
[18:06:29.326] - Launch lazy future ... done
[18:06:29.326] run() for ‘MultisessionFuture’ ... done
[18:06:29.326] resolve() on list ...
[18:06:29.327]  recursive: 0
[18:06:29.327]  length: 3
[18:06:29.327] 
[18:06:29.328] Future #1
[18:06:29.328]  length: 2 (resolved future 1)
[18:06:29.362] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.363] - Validating connection of MultisessionFuture
[18:06:29.363] - received message: FutureResult
[18:06:29.364] - Received FutureResult
[18:06:29.364] - Erased future from FutureRegistry
[18:06:29.364] result() for ClusterFuture ...
[18:06:29.365] - result already collected: FutureResult
[18:06:29.365] result() for ClusterFuture ... done
[18:06:29.365] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.365] Future #2
[18:06:29.366]  length: 1 (resolved future 2)
[18:06:29.475] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.475] - Validating connection of MultisessionFuture
[18:06:29.476] - received message: FutureResult
[18:06:29.476] - Received FutureResult
[18:06:29.476] - Erased future from FutureRegistry
[18:06:29.476] result() for ClusterFuture ...
[18:06:29.476] - result already collected: FutureResult
[18:06:29.477] result() for ClusterFuture ... done
[18:06:29.477] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.477] Future #3
[18:06:29.477]  length: 0 (resolved future 3)
[18:06:29.477] resolve() on list ... DONE
[18:06:29.478] getGlobalsAndPackages() ...
[18:06:29.478] Searching for globals...
[18:06:29.480] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:29.480] Searching for globals ... DONE
[18:06:29.480] Resolving globals: FALSE
[18:06:29.481] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:29.482] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:29.482] - globals: [1] ‘kk’
[18:06:29.482] 
[18:06:29.482] getGlobalsAndPackages() ... DONE
[18:06:29.483] getGlobalsAndPackages() ...
[18:06:29.483] Searching for globals...
[18:06:29.485] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:29.485] Searching for globals ... DONE
[18:06:29.485] Resolving globals: FALSE
[18:06:29.486] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:29.487] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:29.487] - globals: [1] ‘kk’
[18:06:29.487] 
[18:06:29.487] getGlobalsAndPackages() ... DONE
[18:06:29.488] getGlobalsAndPackages() ...
[18:06:29.488] Searching for globals...
[18:06:29.490] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[18:06:29.490] Searching for globals ... DONE
[18:06:29.490] Resolving globals: FALSE
[18:06:29.491] The total size of the 1 globals is 56 bytes (56 bytes)
[18:06:29.492] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[18:06:29.492] - globals: [1] ‘kk’
[18:06:29.492] 
[18:06:29.492] getGlobalsAndPackages() ... DONE
[18:06:29.493] resolve() on list ...
[18:06:29.493]  recursive: 0
[18:06:29.493]  length: 3
[18:06:29.493] 
[18:06:29.493] run() for ‘Future’ ...
[18:06:29.494] - state: ‘created’
[18:06:29.494] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.517] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.517]   - Field: ‘node’
[18:06:29.517]   - Field: ‘label’
[18:06:29.518]   - Field: ‘local’
[18:06:29.518]   - Field: ‘owner’
[18:06:29.518]   - Field: ‘envir’
[18:06:29.518]   - Field: ‘workers’
[18:06:29.518]   - Field: ‘packages’
[18:06:29.519]   - Field: ‘gc’
[18:06:29.519]   - Field: ‘conditions’
[18:06:29.519]   - Field: ‘persistent’
[18:06:29.519]   - Field: ‘expr’
[18:06:29.519]   - Field: ‘uuid’
[18:06:29.520]   - Field: ‘seed’
[18:06:29.520]   - Field: ‘version’
[18:06:29.520]   - Field: ‘result’
[18:06:29.520]   - Field: ‘asynchronous’
[18:06:29.520]   - Field: ‘calls’
[18:06:29.521]   - Field: ‘globals’
[18:06:29.521]   - Field: ‘stdout’
[18:06:29.521]   - Field: ‘earlySignal’
[18:06:29.521]   - Field: ‘lazy’
[18:06:29.521]   - Field: ‘state’
[18:06:29.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.522] - Launch lazy future ...
[18:06:29.522] Packages needed by the future expression (n = 0): <none>
[18:06:29.523] Packages needed by future strategies (n = 0): <none>
[18:06:29.523] {
[18:06:29.523]     {
[18:06:29.523]         {
[18:06:29.523]             ...future.startTime <- base::Sys.time()
[18:06:29.523]             {
[18:06:29.523]                 {
[18:06:29.523]                   {
[18:06:29.523]                     {
[18:06:29.523]                       base::local({
[18:06:29.523]                         has_future <- base::requireNamespace("future", 
[18:06:29.523]                           quietly = TRUE)
[18:06:29.523]                         if (has_future) {
[18:06:29.523]                           ns <- base::getNamespace("future")
[18:06:29.523]                           version <- ns[[".package"]][["version"]]
[18:06:29.523]                           if (is.null(version)) 
[18:06:29.523]                             version <- utils::packageVersion("future")
[18:06:29.523]                         }
[18:06:29.523]                         else {
[18:06:29.523]                           version <- NULL
[18:06:29.523]                         }
[18:06:29.523]                         if (!has_future || version < "1.8.0") {
[18:06:29.523]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.523]                             "", base::R.version$version.string), 
[18:06:29.523]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.523]                               "release", "version")], collapse = " "), 
[18:06:29.523]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.523]                             info)
[18:06:29.523]                           info <- base::paste(info, collapse = "; ")
[18:06:29.523]                           if (!has_future) {
[18:06:29.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.523]                               info)
[18:06:29.523]                           }
[18:06:29.523]                           else {
[18:06:29.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.523]                               info, version)
[18:06:29.523]                           }
[18:06:29.523]                           base::stop(msg)
[18:06:29.523]                         }
[18:06:29.523]                       })
[18:06:29.523]                     }
[18:06:29.523]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.523]                     base::options(mc.cores = 1L)
[18:06:29.523]                   }
[18:06:29.523]                   ...future.strategy.old <- future::plan("list")
[18:06:29.523]                   options(future.plan = NULL)
[18:06:29.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.523]                 }
[18:06:29.523]                 ...future.workdir <- getwd()
[18:06:29.523]             }
[18:06:29.523]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.523]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.523]         }
[18:06:29.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.523]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.523]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.523]             base::names(...future.oldOptions))
[18:06:29.523]     }
[18:06:29.523]     if (FALSE) {
[18:06:29.523]     }
[18:06:29.523]     else {
[18:06:29.523]         if (TRUE) {
[18:06:29.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.523]                 open = "w")
[18:06:29.523]         }
[18:06:29.523]         else {
[18:06:29.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.523]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.523]         }
[18:06:29.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.523]             base::sink(type = "output", split = FALSE)
[18:06:29.523]             base::close(...future.stdout)
[18:06:29.523]         }, add = TRUE)
[18:06:29.523]     }
[18:06:29.523]     ...future.frame <- base::sys.nframe()
[18:06:29.523]     ...future.conditions <- base::list()
[18:06:29.523]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.523]     if (FALSE) {
[18:06:29.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.523]     }
[18:06:29.523]     ...future.result <- base::tryCatch({
[18:06:29.523]         base::withCallingHandlers({
[18:06:29.523]             ...future.value <- base::withVisible(base::local({
[18:06:29.523]                 ...future.makeSendCondition <- base::local({
[18:06:29.523]                   sendCondition <- NULL
[18:06:29.523]                   function(frame = 1L) {
[18:06:29.523]                     if (is.function(sendCondition)) 
[18:06:29.523]                       return(sendCondition)
[18:06:29.523]                     ns <- getNamespace("parallel")
[18:06:29.523]                     if (exists("sendData", mode = "function", 
[18:06:29.523]                       envir = ns)) {
[18:06:29.523]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.523]                         envir = ns)
[18:06:29.523]                       envir <- sys.frame(frame)
[18:06:29.523]                       master <- NULL
[18:06:29.523]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.523]                         !identical(envir, emptyenv())) {
[18:06:29.523]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.523]                           inherits = FALSE)) {
[18:06:29.523]                           master <- get("master", mode = "list", 
[18:06:29.523]                             envir = envir, inherits = FALSE)
[18:06:29.523]                           if (inherits(master, c("SOCKnode", 
[18:06:29.523]                             "SOCK0node"))) {
[18:06:29.523]                             sendCondition <<- function(cond) {
[18:06:29.523]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.523]                                 success = TRUE)
[18:06:29.523]                               parallel_sendData(master, data)
[18:06:29.523]                             }
[18:06:29.523]                             return(sendCondition)
[18:06:29.523]                           }
[18:06:29.523]                         }
[18:06:29.523]                         frame <- frame + 1L
[18:06:29.523]                         envir <- sys.frame(frame)
[18:06:29.523]                       }
[18:06:29.523]                     }
[18:06:29.523]                     sendCondition <<- function(cond) NULL
[18:06:29.523]                   }
[18:06:29.523]                 })
[18:06:29.523]                 withCallingHandlers({
[18:06:29.523]                   {
[18:06:29.523]                     Sys.sleep(0.1)
[18:06:29.523]                     kk
[18:06:29.523]                   }
[18:06:29.523]                 }, immediateCondition = function(cond) {
[18:06:29.523]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.523]                   sendCondition(cond)
[18:06:29.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.523]                   {
[18:06:29.523]                     inherits <- base::inherits
[18:06:29.523]                     invokeRestart <- base::invokeRestart
[18:06:29.523]                     is.null <- base::is.null
[18:06:29.523]                     muffled <- FALSE
[18:06:29.523]                     if (inherits(cond, "message")) {
[18:06:29.523]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.523]                       if (muffled) 
[18:06:29.523]                         invokeRestart("muffleMessage")
[18:06:29.523]                     }
[18:06:29.523]                     else if (inherits(cond, "warning")) {
[18:06:29.523]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.523]                       if (muffled) 
[18:06:29.523]                         invokeRestart("muffleWarning")
[18:06:29.523]                     }
[18:06:29.523]                     else if (inherits(cond, "condition")) {
[18:06:29.523]                       if (!is.null(pattern)) {
[18:06:29.523]                         computeRestarts <- base::computeRestarts
[18:06:29.523]                         grepl <- base::grepl
[18:06:29.523]                         restarts <- computeRestarts(cond)
[18:06:29.523]                         for (restart in restarts) {
[18:06:29.523]                           name <- restart$name
[18:06:29.523]                           if (is.null(name)) 
[18:06:29.523]                             next
[18:06:29.523]                           if (!grepl(pattern, name)) 
[18:06:29.523]                             next
[18:06:29.523]                           invokeRestart(restart)
[18:06:29.523]                           muffled <- TRUE
[18:06:29.523]                           break
[18:06:29.523]                         }
[18:06:29.523]                       }
[18:06:29.523]                     }
[18:06:29.523]                     invisible(muffled)
[18:06:29.523]                   }
[18:06:29.523]                   muffleCondition(cond)
[18:06:29.523]                 })
[18:06:29.523]             }))
[18:06:29.523]             future::FutureResult(value = ...future.value$value, 
[18:06:29.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.523]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.523]                     ...future.globalenv.names))
[18:06:29.523]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.523]         }, condition = base::local({
[18:06:29.523]             c <- base::c
[18:06:29.523]             inherits <- base::inherits
[18:06:29.523]             invokeRestart <- base::invokeRestart
[18:06:29.523]             length <- base::length
[18:06:29.523]             list <- base::list
[18:06:29.523]             seq.int <- base::seq.int
[18:06:29.523]             signalCondition <- base::signalCondition
[18:06:29.523]             sys.calls <- base::sys.calls
[18:06:29.523]             `[[` <- base::`[[`
[18:06:29.523]             `+` <- base::`+`
[18:06:29.523]             `<<-` <- base::`<<-`
[18:06:29.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.523]                   3L)]
[18:06:29.523]             }
[18:06:29.523]             function(cond) {
[18:06:29.523]                 is_error <- inherits(cond, "error")
[18:06:29.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.523]                   NULL)
[18:06:29.523]                 if (is_error) {
[18:06:29.523]                   sessionInformation <- function() {
[18:06:29.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.523]                       search = base::search(), system = base::Sys.info())
[18:06:29.523]                   }
[18:06:29.523]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.523]                     cond$call), session = sessionInformation(), 
[18:06:29.523]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.523]                   signalCondition(cond)
[18:06:29.523]                 }
[18:06:29.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.523]                 "immediateCondition"))) {
[18:06:29.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.523]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.523]                   if (TRUE && !signal) {
[18:06:29.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.523]                     {
[18:06:29.523]                       inherits <- base::inherits
[18:06:29.523]                       invokeRestart <- base::invokeRestart
[18:06:29.523]                       is.null <- base::is.null
[18:06:29.523]                       muffled <- FALSE
[18:06:29.523]                       if (inherits(cond, "message")) {
[18:06:29.523]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.523]                         if (muffled) 
[18:06:29.523]                           invokeRestart("muffleMessage")
[18:06:29.523]                       }
[18:06:29.523]                       else if (inherits(cond, "warning")) {
[18:06:29.523]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.523]                         if (muffled) 
[18:06:29.523]                           invokeRestart("muffleWarning")
[18:06:29.523]                       }
[18:06:29.523]                       else if (inherits(cond, "condition")) {
[18:06:29.523]                         if (!is.null(pattern)) {
[18:06:29.523]                           computeRestarts <- base::computeRestarts
[18:06:29.523]                           grepl <- base::grepl
[18:06:29.523]                           restarts <- computeRestarts(cond)
[18:06:29.523]                           for (restart in restarts) {
[18:06:29.523]                             name <- restart$name
[18:06:29.523]                             if (is.null(name)) 
[18:06:29.523]                               next
[18:06:29.523]                             if (!grepl(pattern, name)) 
[18:06:29.523]                               next
[18:06:29.523]                             invokeRestart(restart)
[18:06:29.523]                             muffled <- TRUE
[18:06:29.523]                             break
[18:06:29.523]                           }
[18:06:29.523]                         }
[18:06:29.523]                       }
[18:06:29.523]                       invisible(muffled)
[18:06:29.523]                     }
[18:06:29.523]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.523]                   }
[18:06:29.523]                 }
[18:06:29.523]                 else {
[18:06:29.523]                   if (TRUE) {
[18:06:29.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.523]                     {
[18:06:29.523]                       inherits <- base::inherits
[18:06:29.523]                       invokeRestart <- base::invokeRestart
[18:06:29.523]                       is.null <- base::is.null
[18:06:29.523]                       muffled <- FALSE
[18:06:29.523]                       if (inherits(cond, "message")) {
[18:06:29.523]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.523]                         if (muffled) 
[18:06:29.523]                           invokeRestart("muffleMessage")
[18:06:29.523]                       }
[18:06:29.523]                       else if (inherits(cond, "warning")) {
[18:06:29.523]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.523]                         if (muffled) 
[18:06:29.523]                           invokeRestart("muffleWarning")
[18:06:29.523]                       }
[18:06:29.523]                       else if (inherits(cond, "condition")) {
[18:06:29.523]                         if (!is.null(pattern)) {
[18:06:29.523]                           computeRestarts <- base::computeRestarts
[18:06:29.523]                           grepl <- base::grepl
[18:06:29.523]                           restarts <- computeRestarts(cond)
[18:06:29.523]                           for (restart in restarts) {
[18:06:29.523]                             name <- restart$name
[18:06:29.523]                             if (is.null(name)) 
[18:06:29.523]                               next
[18:06:29.523]                             if (!grepl(pattern, name)) 
[18:06:29.523]                               next
[18:06:29.523]                             invokeRestart(restart)
[18:06:29.523]                             muffled <- TRUE
[18:06:29.523]                             break
[18:06:29.523]                           }
[18:06:29.523]                         }
[18:06:29.523]                       }
[18:06:29.523]                       invisible(muffled)
[18:06:29.523]                     }
[18:06:29.523]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.523]                   }
[18:06:29.523]                 }
[18:06:29.523]             }
[18:06:29.523]         }))
[18:06:29.523]     }, error = function(ex) {
[18:06:29.523]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.523]                 ...future.rng), started = ...future.startTime, 
[18:06:29.523]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.523]             version = "1.8"), class = "FutureResult")
[18:06:29.523]     }, finally = {
[18:06:29.523]         if (!identical(...future.workdir, getwd())) 
[18:06:29.523]             setwd(...future.workdir)
[18:06:29.523]         {
[18:06:29.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.523]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.523]             }
[18:06:29.523]             base::options(...future.oldOptions)
[18:06:29.523]             if (.Platform$OS.type == "windows") {
[18:06:29.523]                 old_names <- names(...future.oldEnvVars)
[18:06:29.523]                 envs <- base::Sys.getenv()
[18:06:29.523]                 names <- names(envs)
[18:06:29.523]                 common <- intersect(names, old_names)
[18:06:29.523]                 added <- setdiff(names, old_names)
[18:06:29.523]                 removed <- setdiff(old_names, names)
[18:06:29.523]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.523]                   envs[common]]
[18:06:29.523]                 NAMES <- toupper(changed)
[18:06:29.523]                 args <- list()
[18:06:29.523]                 for (kk in seq_along(NAMES)) {
[18:06:29.523]                   name <- changed[[kk]]
[18:06:29.523]                   NAME <- NAMES[[kk]]
[18:06:29.523]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.523]                     next
[18:06:29.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.523]                 }
[18:06:29.523]                 NAMES <- toupper(added)
[18:06:29.523]                 for (kk in seq_along(NAMES)) {
[18:06:29.523]                   name <- added[[kk]]
[18:06:29.523]                   NAME <- NAMES[[kk]]
[18:06:29.523]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.523]                     next
[18:06:29.523]                   args[[name]] <- ""
[18:06:29.523]                 }
[18:06:29.523]                 NAMES <- toupper(removed)
[18:06:29.523]                 for (kk in seq_along(NAMES)) {
[18:06:29.523]                   name <- removed[[kk]]
[18:06:29.523]                   NAME <- NAMES[[kk]]
[18:06:29.523]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.523]                     next
[18:06:29.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.523]                 }
[18:06:29.523]                 if (length(args) > 0) 
[18:06:29.523]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.523]             }
[18:06:29.523]             else {
[18:06:29.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.523]             }
[18:06:29.523]             {
[18:06:29.523]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.523]                   0L) {
[18:06:29.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.523]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.523]                   base::options(opts)
[18:06:29.523]                 }
[18:06:29.523]                 {
[18:06:29.523]                   {
[18:06:29.523]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.523]                     NULL
[18:06:29.523]                   }
[18:06:29.523]                   options(future.plan = NULL)
[18:06:29.523]                   if (is.na(NA_character_)) 
[18:06:29.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.523]                     .init = FALSE)
[18:06:29.523]                 }
[18:06:29.523]             }
[18:06:29.523]         }
[18:06:29.523]     })
[18:06:29.523]     if (TRUE) {
[18:06:29.523]         base::sink(type = "output", split = FALSE)
[18:06:29.523]         if (TRUE) {
[18:06:29.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.523]         }
[18:06:29.523]         else {
[18:06:29.523]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.523]         }
[18:06:29.523]         base::close(...future.stdout)
[18:06:29.523]         ...future.stdout <- NULL
[18:06:29.523]     }
[18:06:29.523]     ...future.result$conditions <- ...future.conditions
[18:06:29.523]     ...future.result$finished <- base::Sys.time()
[18:06:29.523]     ...future.result
[18:06:29.523] }
[18:06:29.529] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:06:29.529] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[18:06:29.530] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[18:06:29.530] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:06:29.531] MultisessionFuture started
[18:06:29.531] - Launch lazy future ... done
[18:06:29.531] run() for ‘MultisessionFuture’ ... done
[18:06:29.543] run() for ‘Future’ ...
[18:06:29.543] - state: ‘created’
[18:06:29.543] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.571] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.571] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.571]   - Field: ‘node’
[18:06:29.572]   - Field: ‘label’
[18:06:29.572]   - Field: ‘local’
[18:06:29.572]   - Field: ‘owner’
[18:06:29.572]   - Field: ‘envir’
[18:06:29.572]   - Field: ‘workers’
[18:06:29.573]   - Field: ‘packages’
[18:06:29.573]   - Field: ‘gc’
[18:06:29.573]   - Field: ‘conditions’
[18:06:29.573]   - Field: ‘persistent’
[18:06:29.574]   - Field: ‘expr’
[18:06:29.574]   - Field: ‘uuid’
[18:06:29.574]   - Field: ‘seed’
[18:06:29.574]   - Field: ‘version’
[18:06:29.574]   - Field: ‘result’
[18:06:29.575]   - Field: ‘asynchronous’
[18:06:29.575]   - Field: ‘calls’
[18:06:29.575]   - Field: ‘globals’
[18:06:29.575]   - Field: ‘stdout’
[18:06:29.575]   - Field: ‘earlySignal’
[18:06:29.576]   - Field: ‘lazy’
[18:06:29.576]   - Field: ‘state’
[18:06:29.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.576] - Launch lazy future ...
[18:06:29.577] Packages needed by the future expression (n = 0): <none>
[18:06:29.577] Packages needed by future strategies (n = 0): <none>
[18:06:29.578] {
[18:06:29.578]     {
[18:06:29.578]         {
[18:06:29.578]             ...future.startTime <- base::Sys.time()
[18:06:29.578]             {
[18:06:29.578]                 {
[18:06:29.578]                   {
[18:06:29.578]                     {
[18:06:29.578]                       base::local({
[18:06:29.578]                         has_future <- base::requireNamespace("future", 
[18:06:29.578]                           quietly = TRUE)
[18:06:29.578]                         if (has_future) {
[18:06:29.578]                           ns <- base::getNamespace("future")
[18:06:29.578]                           version <- ns[[".package"]][["version"]]
[18:06:29.578]                           if (is.null(version)) 
[18:06:29.578]                             version <- utils::packageVersion("future")
[18:06:29.578]                         }
[18:06:29.578]                         else {
[18:06:29.578]                           version <- NULL
[18:06:29.578]                         }
[18:06:29.578]                         if (!has_future || version < "1.8.0") {
[18:06:29.578]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.578]                             "", base::R.version$version.string), 
[18:06:29.578]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.578]                               "release", "version")], collapse = " "), 
[18:06:29.578]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.578]                             info)
[18:06:29.578]                           info <- base::paste(info, collapse = "; ")
[18:06:29.578]                           if (!has_future) {
[18:06:29.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.578]                               info)
[18:06:29.578]                           }
[18:06:29.578]                           else {
[18:06:29.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.578]                               info, version)
[18:06:29.578]                           }
[18:06:29.578]                           base::stop(msg)
[18:06:29.578]                         }
[18:06:29.578]                       })
[18:06:29.578]                     }
[18:06:29.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.578]                     base::options(mc.cores = 1L)
[18:06:29.578]                   }
[18:06:29.578]                   ...future.strategy.old <- future::plan("list")
[18:06:29.578]                   options(future.plan = NULL)
[18:06:29.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.578]                 }
[18:06:29.578]                 ...future.workdir <- getwd()
[18:06:29.578]             }
[18:06:29.578]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.578]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.578]         }
[18:06:29.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.578]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.578]             base::names(...future.oldOptions))
[18:06:29.578]     }
[18:06:29.578]     if (FALSE) {
[18:06:29.578]     }
[18:06:29.578]     else {
[18:06:29.578]         if (TRUE) {
[18:06:29.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.578]                 open = "w")
[18:06:29.578]         }
[18:06:29.578]         else {
[18:06:29.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.578]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.578]         }
[18:06:29.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.578]             base::sink(type = "output", split = FALSE)
[18:06:29.578]             base::close(...future.stdout)
[18:06:29.578]         }, add = TRUE)
[18:06:29.578]     }
[18:06:29.578]     ...future.frame <- base::sys.nframe()
[18:06:29.578]     ...future.conditions <- base::list()
[18:06:29.578]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.578]     if (FALSE) {
[18:06:29.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.578]     }
[18:06:29.578]     ...future.result <- base::tryCatch({
[18:06:29.578]         base::withCallingHandlers({
[18:06:29.578]             ...future.value <- base::withVisible(base::local({
[18:06:29.578]                 ...future.makeSendCondition <- base::local({
[18:06:29.578]                   sendCondition <- NULL
[18:06:29.578]                   function(frame = 1L) {
[18:06:29.578]                     if (is.function(sendCondition)) 
[18:06:29.578]                       return(sendCondition)
[18:06:29.578]                     ns <- getNamespace("parallel")
[18:06:29.578]                     if (exists("sendData", mode = "function", 
[18:06:29.578]                       envir = ns)) {
[18:06:29.578]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.578]                         envir = ns)
[18:06:29.578]                       envir <- sys.frame(frame)
[18:06:29.578]                       master <- NULL
[18:06:29.578]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.578]                         !identical(envir, emptyenv())) {
[18:06:29.578]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.578]                           inherits = FALSE)) {
[18:06:29.578]                           master <- get("master", mode = "list", 
[18:06:29.578]                             envir = envir, inherits = FALSE)
[18:06:29.578]                           if (inherits(master, c("SOCKnode", 
[18:06:29.578]                             "SOCK0node"))) {
[18:06:29.578]                             sendCondition <<- function(cond) {
[18:06:29.578]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.578]                                 success = TRUE)
[18:06:29.578]                               parallel_sendData(master, data)
[18:06:29.578]                             }
[18:06:29.578]                             return(sendCondition)
[18:06:29.578]                           }
[18:06:29.578]                         }
[18:06:29.578]                         frame <- frame + 1L
[18:06:29.578]                         envir <- sys.frame(frame)
[18:06:29.578]                       }
[18:06:29.578]                     }
[18:06:29.578]                     sendCondition <<- function(cond) NULL
[18:06:29.578]                   }
[18:06:29.578]                 })
[18:06:29.578]                 withCallingHandlers({
[18:06:29.578]                   {
[18:06:29.578]                     Sys.sleep(0.1)
[18:06:29.578]                     kk
[18:06:29.578]                   }
[18:06:29.578]                 }, immediateCondition = function(cond) {
[18:06:29.578]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.578]                   sendCondition(cond)
[18:06:29.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.578]                   {
[18:06:29.578]                     inherits <- base::inherits
[18:06:29.578]                     invokeRestart <- base::invokeRestart
[18:06:29.578]                     is.null <- base::is.null
[18:06:29.578]                     muffled <- FALSE
[18:06:29.578]                     if (inherits(cond, "message")) {
[18:06:29.578]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.578]                       if (muffled) 
[18:06:29.578]                         invokeRestart("muffleMessage")
[18:06:29.578]                     }
[18:06:29.578]                     else if (inherits(cond, "warning")) {
[18:06:29.578]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.578]                       if (muffled) 
[18:06:29.578]                         invokeRestart("muffleWarning")
[18:06:29.578]                     }
[18:06:29.578]                     else if (inherits(cond, "condition")) {
[18:06:29.578]                       if (!is.null(pattern)) {
[18:06:29.578]                         computeRestarts <- base::computeRestarts
[18:06:29.578]                         grepl <- base::grepl
[18:06:29.578]                         restarts <- computeRestarts(cond)
[18:06:29.578]                         for (restart in restarts) {
[18:06:29.578]                           name <- restart$name
[18:06:29.578]                           if (is.null(name)) 
[18:06:29.578]                             next
[18:06:29.578]                           if (!grepl(pattern, name)) 
[18:06:29.578]                             next
[18:06:29.578]                           invokeRestart(restart)
[18:06:29.578]                           muffled <- TRUE
[18:06:29.578]                           break
[18:06:29.578]                         }
[18:06:29.578]                       }
[18:06:29.578]                     }
[18:06:29.578]                     invisible(muffled)
[18:06:29.578]                   }
[18:06:29.578]                   muffleCondition(cond)
[18:06:29.578]                 })
[18:06:29.578]             }))
[18:06:29.578]             future::FutureResult(value = ...future.value$value, 
[18:06:29.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.578]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.578]                     ...future.globalenv.names))
[18:06:29.578]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.578]         }, condition = base::local({
[18:06:29.578]             c <- base::c
[18:06:29.578]             inherits <- base::inherits
[18:06:29.578]             invokeRestart <- base::invokeRestart
[18:06:29.578]             length <- base::length
[18:06:29.578]             list <- base::list
[18:06:29.578]             seq.int <- base::seq.int
[18:06:29.578]             signalCondition <- base::signalCondition
[18:06:29.578]             sys.calls <- base::sys.calls
[18:06:29.578]             `[[` <- base::`[[`
[18:06:29.578]             `+` <- base::`+`
[18:06:29.578]             `<<-` <- base::`<<-`
[18:06:29.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.578]                   3L)]
[18:06:29.578]             }
[18:06:29.578]             function(cond) {
[18:06:29.578]                 is_error <- inherits(cond, "error")
[18:06:29.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.578]                   NULL)
[18:06:29.578]                 if (is_error) {
[18:06:29.578]                   sessionInformation <- function() {
[18:06:29.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.578]                       search = base::search(), system = base::Sys.info())
[18:06:29.578]                   }
[18:06:29.578]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.578]                     cond$call), session = sessionInformation(), 
[18:06:29.578]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.578]                   signalCondition(cond)
[18:06:29.578]                 }
[18:06:29.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.578]                 "immediateCondition"))) {
[18:06:29.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.578]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.578]                   if (TRUE && !signal) {
[18:06:29.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.578]                     {
[18:06:29.578]                       inherits <- base::inherits
[18:06:29.578]                       invokeRestart <- base::invokeRestart
[18:06:29.578]                       is.null <- base::is.null
[18:06:29.578]                       muffled <- FALSE
[18:06:29.578]                       if (inherits(cond, "message")) {
[18:06:29.578]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.578]                         if (muffled) 
[18:06:29.578]                           invokeRestart("muffleMessage")
[18:06:29.578]                       }
[18:06:29.578]                       else if (inherits(cond, "warning")) {
[18:06:29.578]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.578]                         if (muffled) 
[18:06:29.578]                           invokeRestart("muffleWarning")
[18:06:29.578]                       }
[18:06:29.578]                       else if (inherits(cond, "condition")) {
[18:06:29.578]                         if (!is.null(pattern)) {
[18:06:29.578]                           computeRestarts <- base::computeRestarts
[18:06:29.578]                           grepl <- base::grepl
[18:06:29.578]                           restarts <- computeRestarts(cond)
[18:06:29.578]                           for (restart in restarts) {
[18:06:29.578]                             name <- restart$name
[18:06:29.578]                             if (is.null(name)) 
[18:06:29.578]                               next
[18:06:29.578]                             if (!grepl(pattern, name)) 
[18:06:29.578]                               next
[18:06:29.578]                             invokeRestart(restart)
[18:06:29.578]                             muffled <- TRUE
[18:06:29.578]                             break
[18:06:29.578]                           }
[18:06:29.578]                         }
[18:06:29.578]                       }
[18:06:29.578]                       invisible(muffled)
[18:06:29.578]                     }
[18:06:29.578]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.578]                   }
[18:06:29.578]                 }
[18:06:29.578]                 else {
[18:06:29.578]                   if (TRUE) {
[18:06:29.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.578]                     {
[18:06:29.578]                       inherits <- base::inherits
[18:06:29.578]                       invokeRestart <- base::invokeRestart
[18:06:29.578]                       is.null <- base::is.null
[18:06:29.578]                       muffled <- FALSE
[18:06:29.578]                       if (inherits(cond, "message")) {
[18:06:29.578]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.578]                         if (muffled) 
[18:06:29.578]                           invokeRestart("muffleMessage")
[18:06:29.578]                       }
[18:06:29.578]                       else if (inherits(cond, "warning")) {
[18:06:29.578]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.578]                         if (muffled) 
[18:06:29.578]                           invokeRestart("muffleWarning")
[18:06:29.578]                       }
[18:06:29.578]                       else if (inherits(cond, "condition")) {
[18:06:29.578]                         if (!is.null(pattern)) {
[18:06:29.578]                           computeRestarts <- base::computeRestarts
[18:06:29.578]                           grepl <- base::grepl
[18:06:29.578]                           restarts <- computeRestarts(cond)
[18:06:29.578]                           for (restart in restarts) {
[18:06:29.578]                             name <- restart$name
[18:06:29.578]                             if (is.null(name)) 
[18:06:29.578]                               next
[18:06:29.578]                             if (!grepl(pattern, name)) 
[18:06:29.578]                               next
[18:06:29.578]                             invokeRestart(restart)
[18:06:29.578]                             muffled <- TRUE
[18:06:29.578]                             break
[18:06:29.578]                           }
[18:06:29.578]                         }
[18:06:29.578]                       }
[18:06:29.578]                       invisible(muffled)
[18:06:29.578]                     }
[18:06:29.578]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.578]                   }
[18:06:29.578]                 }
[18:06:29.578]             }
[18:06:29.578]         }))
[18:06:29.578]     }, error = function(ex) {
[18:06:29.578]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.578]                 ...future.rng), started = ...future.startTime, 
[18:06:29.578]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.578]             version = "1.8"), class = "FutureResult")
[18:06:29.578]     }, finally = {
[18:06:29.578]         if (!identical(...future.workdir, getwd())) 
[18:06:29.578]             setwd(...future.workdir)
[18:06:29.578]         {
[18:06:29.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.578]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.578]             }
[18:06:29.578]             base::options(...future.oldOptions)
[18:06:29.578]             if (.Platform$OS.type == "windows") {
[18:06:29.578]                 old_names <- names(...future.oldEnvVars)
[18:06:29.578]                 envs <- base::Sys.getenv()
[18:06:29.578]                 names <- names(envs)
[18:06:29.578]                 common <- intersect(names, old_names)
[18:06:29.578]                 added <- setdiff(names, old_names)
[18:06:29.578]                 removed <- setdiff(old_names, names)
[18:06:29.578]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.578]                   envs[common]]
[18:06:29.578]                 NAMES <- toupper(changed)
[18:06:29.578]                 args <- list()
[18:06:29.578]                 for (kk in seq_along(NAMES)) {
[18:06:29.578]                   name <- changed[[kk]]
[18:06:29.578]                   NAME <- NAMES[[kk]]
[18:06:29.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.578]                     next
[18:06:29.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.578]                 }
[18:06:29.578]                 NAMES <- toupper(added)
[18:06:29.578]                 for (kk in seq_along(NAMES)) {
[18:06:29.578]                   name <- added[[kk]]
[18:06:29.578]                   NAME <- NAMES[[kk]]
[18:06:29.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.578]                     next
[18:06:29.578]                   args[[name]] <- ""
[18:06:29.578]                 }
[18:06:29.578]                 NAMES <- toupper(removed)
[18:06:29.578]                 for (kk in seq_along(NAMES)) {
[18:06:29.578]                   name <- removed[[kk]]
[18:06:29.578]                   NAME <- NAMES[[kk]]
[18:06:29.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.578]                     next
[18:06:29.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.578]                 }
[18:06:29.578]                 if (length(args) > 0) 
[18:06:29.578]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.578]             }
[18:06:29.578]             else {
[18:06:29.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.578]             }
[18:06:29.578]             {
[18:06:29.578]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.578]                   0L) {
[18:06:29.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.578]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.578]                   base::options(opts)
[18:06:29.578]                 }
[18:06:29.578]                 {
[18:06:29.578]                   {
[18:06:29.578]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.578]                     NULL
[18:06:29.578]                   }
[18:06:29.578]                   options(future.plan = NULL)
[18:06:29.578]                   if (is.na(NA_character_)) 
[18:06:29.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.578]                     .init = FALSE)
[18:06:29.578]                 }
[18:06:29.578]             }
[18:06:29.578]         }
[18:06:29.578]     })
[18:06:29.578]     if (TRUE) {
[18:06:29.578]         base::sink(type = "output", split = FALSE)
[18:06:29.578]         if (TRUE) {
[18:06:29.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.578]         }
[18:06:29.578]         else {
[18:06:29.578]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.578]         }
[18:06:29.578]         base::close(...future.stdout)
[18:06:29.578]         ...future.stdout <- NULL
[18:06:29.578]     }
[18:06:29.578]     ...future.result$conditions <- ...future.conditions
[18:06:29.578]     ...future.result$finished <- base::Sys.time()
[18:06:29.578]     ...future.result
[18:06:29.578] }
[18:06:29.583] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[18:06:29.583] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[18:06:29.584] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[18:06:29.584] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[18:06:29.585] MultisessionFuture started
[18:06:29.585] - Launch lazy future ... done
[18:06:29.586] run() for ‘MultisessionFuture’ ... done
[18:06:29.597] run() for ‘Future’ ...
[18:06:29.597] - state: ‘created’
[18:06:29.597] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.622] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.623]   - Field: ‘node’
[18:06:29.623]   - Field: ‘label’
[18:06:29.623]   - Field: ‘local’
[18:06:29.623]   - Field: ‘owner’
[18:06:29.623]   - Field: ‘envir’
[18:06:29.624]   - Field: ‘workers’
[18:06:29.624]   - Field: ‘packages’
[18:06:29.624]   - Field: ‘gc’
[18:06:29.624]   - Field: ‘conditions’
[18:06:29.625]   - Field: ‘persistent’
[18:06:29.625]   - Field: ‘expr’
[18:06:29.625]   - Field: ‘uuid’
[18:06:29.625]   - Field: ‘seed’
[18:06:29.625]   - Field: ‘version’
[18:06:29.626]   - Field: ‘result’
[18:06:29.626]   - Field: ‘asynchronous’
[18:06:29.626]   - Field: ‘calls’
[18:06:29.626]   - Field: ‘globals’
[18:06:29.626]   - Field: ‘stdout’
[18:06:29.627]   - Field: ‘earlySignal’
[18:06:29.627]   - Field: ‘lazy’
[18:06:29.627]   - Field: ‘state’
[18:06:29.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.628] - Launch lazy future ...
[18:06:29.628] Packages needed by the future expression (n = 0): <none>
[18:06:29.628] Packages needed by future strategies (n = 0): <none>
[18:06:29.629] {
[18:06:29.629]     {
[18:06:29.629]         {
[18:06:29.629]             ...future.startTime <- base::Sys.time()
[18:06:29.629]             {
[18:06:29.629]                 {
[18:06:29.629]                   {
[18:06:29.629]                     {
[18:06:29.629]                       base::local({
[18:06:29.629]                         has_future <- base::requireNamespace("future", 
[18:06:29.629]                           quietly = TRUE)
[18:06:29.629]                         if (has_future) {
[18:06:29.629]                           ns <- base::getNamespace("future")
[18:06:29.629]                           version <- ns[[".package"]][["version"]]
[18:06:29.629]                           if (is.null(version)) 
[18:06:29.629]                             version <- utils::packageVersion("future")
[18:06:29.629]                         }
[18:06:29.629]                         else {
[18:06:29.629]                           version <- NULL
[18:06:29.629]                         }
[18:06:29.629]                         if (!has_future || version < "1.8.0") {
[18:06:29.629]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.629]                             "", base::R.version$version.string), 
[18:06:29.629]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.629]                               "release", "version")], collapse = " "), 
[18:06:29.629]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.629]                             info)
[18:06:29.629]                           info <- base::paste(info, collapse = "; ")
[18:06:29.629]                           if (!has_future) {
[18:06:29.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.629]                               info)
[18:06:29.629]                           }
[18:06:29.629]                           else {
[18:06:29.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.629]                               info, version)
[18:06:29.629]                           }
[18:06:29.629]                           base::stop(msg)
[18:06:29.629]                         }
[18:06:29.629]                       })
[18:06:29.629]                     }
[18:06:29.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.629]                     base::options(mc.cores = 1L)
[18:06:29.629]                   }
[18:06:29.629]                   ...future.strategy.old <- future::plan("list")
[18:06:29.629]                   options(future.plan = NULL)
[18:06:29.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.629]                 }
[18:06:29.629]                 ...future.workdir <- getwd()
[18:06:29.629]             }
[18:06:29.629]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.629]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.629]         }
[18:06:29.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.629]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.629]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.629]             base::names(...future.oldOptions))
[18:06:29.629]     }
[18:06:29.629]     if (FALSE) {
[18:06:29.629]     }
[18:06:29.629]     else {
[18:06:29.629]         if (TRUE) {
[18:06:29.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.629]                 open = "w")
[18:06:29.629]         }
[18:06:29.629]         else {
[18:06:29.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.629]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.629]         }
[18:06:29.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.629]             base::sink(type = "output", split = FALSE)
[18:06:29.629]             base::close(...future.stdout)
[18:06:29.629]         }, add = TRUE)
[18:06:29.629]     }
[18:06:29.629]     ...future.frame <- base::sys.nframe()
[18:06:29.629]     ...future.conditions <- base::list()
[18:06:29.629]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.629]     if (FALSE) {
[18:06:29.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.629]     }
[18:06:29.629]     ...future.result <- base::tryCatch({
[18:06:29.629]         base::withCallingHandlers({
[18:06:29.629]             ...future.value <- base::withVisible(base::local({
[18:06:29.629]                 ...future.makeSendCondition <- base::local({
[18:06:29.629]                   sendCondition <- NULL
[18:06:29.629]                   function(frame = 1L) {
[18:06:29.629]                     if (is.function(sendCondition)) 
[18:06:29.629]                       return(sendCondition)
[18:06:29.629]                     ns <- getNamespace("parallel")
[18:06:29.629]                     if (exists("sendData", mode = "function", 
[18:06:29.629]                       envir = ns)) {
[18:06:29.629]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.629]                         envir = ns)
[18:06:29.629]                       envir <- sys.frame(frame)
[18:06:29.629]                       master <- NULL
[18:06:29.629]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.629]                         !identical(envir, emptyenv())) {
[18:06:29.629]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.629]                           inherits = FALSE)) {
[18:06:29.629]                           master <- get("master", mode = "list", 
[18:06:29.629]                             envir = envir, inherits = FALSE)
[18:06:29.629]                           if (inherits(master, c("SOCKnode", 
[18:06:29.629]                             "SOCK0node"))) {
[18:06:29.629]                             sendCondition <<- function(cond) {
[18:06:29.629]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.629]                                 success = TRUE)
[18:06:29.629]                               parallel_sendData(master, data)
[18:06:29.629]                             }
[18:06:29.629]                             return(sendCondition)
[18:06:29.629]                           }
[18:06:29.629]                         }
[18:06:29.629]                         frame <- frame + 1L
[18:06:29.629]                         envir <- sys.frame(frame)
[18:06:29.629]                       }
[18:06:29.629]                     }
[18:06:29.629]                     sendCondition <<- function(cond) NULL
[18:06:29.629]                   }
[18:06:29.629]                 })
[18:06:29.629]                 withCallingHandlers({
[18:06:29.629]                   {
[18:06:29.629]                     Sys.sleep(0.1)
[18:06:29.629]                     kk
[18:06:29.629]                   }
[18:06:29.629]                 }, immediateCondition = function(cond) {
[18:06:29.629]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.629]                   sendCondition(cond)
[18:06:29.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.629]                   {
[18:06:29.629]                     inherits <- base::inherits
[18:06:29.629]                     invokeRestart <- base::invokeRestart
[18:06:29.629]                     is.null <- base::is.null
[18:06:29.629]                     muffled <- FALSE
[18:06:29.629]                     if (inherits(cond, "message")) {
[18:06:29.629]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.629]                       if (muffled) 
[18:06:29.629]                         invokeRestart("muffleMessage")
[18:06:29.629]                     }
[18:06:29.629]                     else if (inherits(cond, "warning")) {
[18:06:29.629]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.629]                       if (muffled) 
[18:06:29.629]                         invokeRestart("muffleWarning")
[18:06:29.629]                     }
[18:06:29.629]                     else if (inherits(cond, "condition")) {
[18:06:29.629]                       if (!is.null(pattern)) {
[18:06:29.629]                         computeRestarts <- base::computeRestarts
[18:06:29.629]                         grepl <- base::grepl
[18:06:29.629]                         restarts <- computeRestarts(cond)
[18:06:29.629]                         for (restart in restarts) {
[18:06:29.629]                           name <- restart$name
[18:06:29.629]                           if (is.null(name)) 
[18:06:29.629]                             next
[18:06:29.629]                           if (!grepl(pattern, name)) 
[18:06:29.629]                             next
[18:06:29.629]                           invokeRestart(restart)
[18:06:29.629]                           muffled <- TRUE
[18:06:29.629]                           break
[18:06:29.629]                         }
[18:06:29.629]                       }
[18:06:29.629]                     }
[18:06:29.629]                     invisible(muffled)
[18:06:29.629]                   }
[18:06:29.629]                   muffleCondition(cond)
[18:06:29.629]                 })
[18:06:29.629]             }))
[18:06:29.629]             future::FutureResult(value = ...future.value$value, 
[18:06:29.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.629]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.629]                     ...future.globalenv.names))
[18:06:29.629]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.629]         }, condition = base::local({
[18:06:29.629]             c <- base::c
[18:06:29.629]             inherits <- base::inherits
[18:06:29.629]             invokeRestart <- base::invokeRestart
[18:06:29.629]             length <- base::length
[18:06:29.629]             list <- base::list
[18:06:29.629]             seq.int <- base::seq.int
[18:06:29.629]             signalCondition <- base::signalCondition
[18:06:29.629]             sys.calls <- base::sys.calls
[18:06:29.629]             `[[` <- base::`[[`
[18:06:29.629]             `+` <- base::`+`
[18:06:29.629]             `<<-` <- base::`<<-`
[18:06:29.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.629]                   3L)]
[18:06:29.629]             }
[18:06:29.629]             function(cond) {
[18:06:29.629]                 is_error <- inherits(cond, "error")
[18:06:29.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.629]                   NULL)
[18:06:29.629]                 if (is_error) {
[18:06:29.629]                   sessionInformation <- function() {
[18:06:29.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.629]                       search = base::search(), system = base::Sys.info())
[18:06:29.629]                   }
[18:06:29.629]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.629]                     cond$call), session = sessionInformation(), 
[18:06:29.629]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.629]                   signalCondition(cond)
[18:06:29.629]                 }
[18:06:29.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.629]                 "immediateCondition"))) {
[18:06:29.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.629]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.629]                   if (TRUE && !signal) {
[18:06:29.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.629]                     {
[18:06:29.629]                       inherits <- base::inherits
[18:06:29.629]                       invokeRestart <- base::invokeRestart
[18:06:29.629]                       is.null <- base::is.null
[18:06:29.629]                       muffled <- FALSE
[18:06:29.629]                       if (inherits(cond, "message")) {
[18:06:29.629]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.629]                         if (muffled) 
[18:06:29.629]                           invokeRestart("muffleMessage")
[18:06:29.629]                       }
[18:06:29.629]                       else if (inherits(cond, "warning")) {
[18:06:29.629]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.629]                         if (muffled) 
[18:06:29.629]                           invokeRestart("muffleWarning")
[18:06:29.629]                       }
[18:06:29.629]                       else if (inherits(cond, "condition")) {
[18:06:29.629]                         if (!is.null(pattern)) {
[18:06:29.629]                           computeRestarts <- base::computeRestarts
[18:06:29.629]                           grepl <- base::grepl
[18:06:29.629]                           restarts <- computeRestarts(cond)
[18:06:29.629]                           for (restart in restarts) {
[18:06:29.629]                             name <- restart$name
[18:06:29.629]                             if (is.null(name)) 
[18:06:29.629]                               next
[18:06:29.629]                             if (!grepl(pattern, name)) 
[18:06:29.629]                               next
[18:06:29.629]                             invokeRestart(restart)
[18:06:29.629]                             muffled <- TRUE
[18:06:29.629]                             break
[18:06:29.629]                           }
[18:06:29.629]                         }
[18:06:29.629]                       }
[18:06:29.629]                       invisible(muffled)
[18:06:29.629]                     }
[18:06:29.629]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.629]                   }
[18:06:29.629]                 }
[18:06:29.629]                 else {
[18:06:29.629]                   if (TRUE) {
[18:06:29.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.629]                     {
[18:06:29.629]                       inherits <- base::inherits
[18:06:29.629]                       invokeRestart <- base::invokeRestart
[18:06:29.629]                       is.null <- base::is.null
[18:06:29.629]                       muffled <- FALSE
[18:06:29.629]                       if (inherits(cond, "message")) {
[18:06:29.629]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.629]                         if (muffled) 
[18:06:29.629]                           invokeRestart("muffleMessage")
[18:06:29.629]                       }
[18:06:29.629]                       else if (inherits(cond, "warning")) {
[18:06:29.629]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.629]                         if (muffled) 
[18:06:29.629]                           invokeRestart("muffleWarning")
[18:06:29.629]                       }
[18:06:29.629]                       else if (inherits(cond, "condition")) {
[18:06:29.629]                         if (!is.null(pattern)) {
[18:06:29.629]                           computeRestarts <- base::computeRestarts
[18:06:29.629]                           grepl <- base::grepl
[18:06:29.629]                           restarts <- computeRestarts(cond)
[18:06:29.629]                           for (restart in restarts) {
[18:06:29.629]                             name <- restart$name
[18:06:29.629]                             if (is.null(name)) 
[18:06:29.629]                               next
[18:06:29.629]                             if (!grepl(pattern, name)) 
[18:06:29.629]                               next
[18:06:29.629]                             invokeRestart(restart)
[18:06:29.629]                             muffled <- TRUE
[18:06:29.629]                             break
[18:06:29.629]                           }
[18:06:29.629]                         }
[18:06:29.629]                       }
[18:06:29.629]                       invisible(muffled)
[18:06:29.629]                     }
[18:06:29.629]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.629]                   }
[18:06:29.629]                 }
[18:06:29.629]             }
[18:06:29.629]         }))
[18:06:29.629]     }, error = function(ex) {
[18:06:29.629]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.629]                 ...future.rng), started = ...future.startTime, 
[18:06:29.629]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.629]             version = "1.8"), class = "FutureResult")
[18:06:29.629]     }, finally = {
[18:06:29.629]         if (!identical(...future.workdir, getwd())) 
[18:06:29.629]             setwd(...future.workdir)
[18:06:29.629]         {
[18:06:29.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.629]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.629]             }
[18:06:29.629]             base::options(...future.oldOptions)
[18:06:29.629]             if (.Platform$OS.type == "windows") {
[18:06:29.629]                 old_names <- names(...future.oldEnvVars)
[18:06:29.629]                 envs <- base::Sys.getenv()
[18:06:29.629]                 names <- names(envs)
[18:06:29.629]                 common <- intersect(names, old_names)
[18:06:29.629]                 added <- setdiff(names, old_names)
[18:06:29.629]                 removed <- setdiff(old_names, names)
[18:06:29.629]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.629]                   envs[common]]
[18:06:29.629]                 NAMES <- toupper(changed)
[18:06:29.629]                 args <- list()
[18:06:29.629]                 for (kk in seq_along(NAMES)) {
[18:06:29.629]                   name <- changed[[kk]]
[18:06:29.629]                   NAME <- NAMES[[kk]]
[18:06:29.629]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.629]                     next
[18:06:29.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.629]                 }
[18:06:29.629]                 NAMES <- toupper(added)
[18:06:29.629]                 for (kk in seq_along(NAMES)) {
[18:06:29.629]                   name <- added[[kk]]
[18:06:29.629]                   NAME <- NAMES[[kk]]
[18:06:29.629]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.629]                     next
[18:06:29.629]                   args[[name]] <- ""
[18:06:29.629]                 }
[18:06:29.629]                 NAMES <- toupper(removed)
[18:06:29.629]                 for (kk in seq_along(NAMES)) {
[18:06:29.629]                   name <- removed[[kk]]
[18:06:29.629]                   NAME <- NAMES[[kk]]
[18:06:29.629]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.629]                     next
[18:06:29.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.629]                 }
[18:06:29.629]                 if (length(args) > 0) 
[18:06:29.629]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.629]             }
[18:06:29.629]             else {
[18:06:29.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.629]             }
[18:06:29.629]             {
[18:06:29.629]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.629]                   0L) {
[18:06:29.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.629]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.629]                   base::options(opts)
[18:06:29.629]                 }
[18:06:29.629]                 {
[18:06:29.629]                   {
[18:06:29.629]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.629]                     NULL
[18:06:29.629]                   }
[18:06:29.629]                   options(future.plan = NULL)
[18:06:29.629]                   if (is.na(NA_character_)) 
[18:06:29.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.629]                     .init = FALSE)
[18:06:29.629]                 }
[18:06:29.629]             }
[18:06:29.629]         }
[18:06:29.629]     })
[18:06:29.629]     if (TRUE) {
[18:06:29.629]         base::sink(type = "output", split = FALSE)
[18:06:29.629]         if (TRUE) {
[18:06:29.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.629]         }
[18:06:29.629]         else {
[18:06:29.629]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.629]         }
[18:06:29.629]         base::close(...future.stdout)
[18:06:29.629]         ...future.stdout <- NULL
[18:06:29.629]     }
[18:06:29.629]     ...future.result$conditions <- ...future.conditions
[18:06:29.629]     ...future.result$finished <- base::Sys.time()
[18:06:29.629]     ...future.result
[18:06:29.629] }
[18:06:29.633] Poll #1 (0): usedNodes() = 2, workers = 2
[18:06:29.666] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[18:06:29.678] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.678] - Validating connection of MultisessionFuture
[18:06:29.679] - received message: FutureResult
[18:06:29.679] - Received FutureResult
[18:06:29.679] - Erased future from FutureRegistry
[18:06:29.679] result() for ClusterFuture ...
[18:06:29.680] - result already collected: FutureResult
[18:06:29.680] result() for ClusterFuture ... done
[18:06:29.680] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.680] result() for ClusterFuture ...
[18:06:29.680] - result already collected: FutureResult
[18:06:29.681] result() for ClusterFuture ... done
[18:06:29.681] result() for ClusterFuture ...
[18:06:29.681] - result already collected: FutureResult
[18:06:29.681] result() for ClusterFuture ... done
[18:06:29.683] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[18:06:29.683] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[18:06:29.684] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[18:06:29.684] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[18:06:29.685] MultisessionFuture started
[18:06:29.686] - Launch lazy future ... done
[18:06:29.686] run() for ‘MultisessionFuture’ ... done
[18:06:29.708] Future #1
[18:06:29.709]  length: 2 (resolved future 1)
[18:06:29.742] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.743] - Validating connection of MultisessionFuture
[18:06:29.743] - received message: FutureResult
[18:06:29.744] - Received FutureResult
[18:06:29.744] - Erased future from FutureRegistry
[18:06:29.744] result() for ClusterFuture ...
[18:06:29.744] - result already collected: FutureResult
[18:06:29.745] result() for ClusterFuture ... done
[18:06:29.745] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.745] Future #2
[18:06:29.745]  length: 1 (resolved future 2)
[18:06:29.832] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.832] - Validating connection of MultisessionFuture
[18:06:29.833] - received message: FutureResult
[18:06:29.833] - Received FutureResult
[18:06:29.834] - Erased future from FutureRegistry
[18:06:29.834] result() for ClusterFuture ...
[18:06:29.834] - result already collected: FutureResult
[18:06:29.835] result() for ClusterFuture ... done
[18:06:29.835] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.835] Future #3
[18:06:29.836]  length: 0 (resolved future 3)
[18:06:29.836] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[18:06:29.838] resolve() on environment ...
[18:06:29.838]  recursive: 0
[18:06:29.839]  elements: [2] ‘a’, ‘b’
[18:06:29.840]  length: 1 (resolved future 1)
[18:06:29.840]  length: 0 (resolved future 2)
[18:06:29.840] resolve() on environment ... DONE
[18:06:29.842] getGlobalsAndPackages() ...
[18:06:29.842] Searching for globals...
[18:06:29.843] 
[18:06:29.843] Searching for globals ... DONE
[18:06:29.844] - globals: [0] <none>
[18:06:29.844] getGlobalsAndPackages() ... DONE
[18:06:29.845] run() for ‘Future’ ...
[18:06:29.845] - state: ‘created’
[18:06:29.845] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.886]   - Field: ‘node’
[18:06:29.886]   - Field: ‘label’
[18:06:29.886]   - Field: ‘local’
[18:06:29.887]   - Field: ‘owner’
[18:06:29.887]   - Field: ‘envir’
[18:06:29.887]   - Field: ‘workers’
[18:06:29.888]   - Field: ‘packages’
[18:06:29.888]   - Field: ‘gc’
[18:06:29.888]   - Field: ‘conditions’
[18:06:29.888]   - Field: ‘persistent’
[18:06:29.889]   - Field: ‘expr’
[18:06:29.889]   - Field: ‘uuid’
[18:06:29.889]   - Field: ‘seed’
[18:06:29.890]   - Field: ‘version’
[18:06:29.890]   - Field: ‘result’
[18:06:29.890]   - Field: ‘asynchronous’
[18:06:29.891]   - Field: ‘calls’
[18:06:29.891]   - Field: ‘globals’
[18:06:29.891]   - Field: ‘stdout’
[18:06:29.891]   - Field: ‘earlySignal’
[18:06:29.892]   - Field: ‘lazy’
[18:06:29.892]   - Field: ‘state’
[18:06:29.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.893] - Launch lazy future ...
[18:06:29.893] Packages needed by the future expression (n = 0): <none>
[18:06:29.894] Packages needed by future strategies (n = 0): <none>
[18:06:29.895] {
[18:06:29.895]     {
[18:06:29.895]         {
[18:06:29.895]             ...future.startTime <- base::Sys.time()
[18:06:29.895]             {
[18:06:29.895]                 {
[18:06:29.895]                   {
[18:06:29.895]                     {
[18:06:29.895]                       base::local({
[18:06:29.895]                         has_future <- base::requireNamespace("future", 
[18:06:29.895]                           quietly = TRUE)
[18:06:29.895]                         if (has_future) {
[18:06:29.895]                           ns <- base::getNamespace("future")
[18:06:29.895]                           version <- ns[[".package"]][["version"]]
[18:06:29.895]                           if (is.null(version)) 
[18:06:29.895]                             version <- utils::packageVersion("future")
[18:06:29.895]                         }
[18:06:29.895]                         else {
[18:06:29.895]                           version <- NULL
[18:06:29.895]                         }
[18:06:29.895]                         if (!has_future || version < "1.8.0") {
[18:06:29.895]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.895]                             "", base::R.version$version.string), 
[18:06:29.895]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.895]                               "release", "version")], collapse = " "), 
[18:06:29.895]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.895]                             info)
[18:06:29.895]                           info <- base::paste(info, collapse = "; ")
[18:06:29.895]                           if (!has_future) {
[18:06:29.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.895]                               info)
[18:06:29.895]                           }
[18:06:29.895]                           else {
[18:06:29.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.895]                               info, version)
[18:06:29.895]                           }
[18:06:29.895]                           base::stop(msg)
[18:06:29.895]                         }
[18:06:29.895]                       })
[18:06:29.895]                     }
[18:06:29.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.895]                     base::options(mc.cores = 1L)
[18:06:29.895]                   }
[18:06:29.895]                   ...future.strategy.old <- future::plan("list")
[18:06:29.895]                   options(future.plan = NULL)
[18:06:29.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.895]                 }
[18:06:29.895]                 ...future.workdir <- getwd()
[18:06:29.895]             }
[18:06:29.895]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.895]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.895]         }
[18:06:29.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.895]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.895]             base::names(...future.oldOptions))
[18:06:29.895]     }
[18:06:29.895]     if (FALSE) {
[18:06:29.895]     }
[18:06:29.895]     else {
[18:06:29.895]         if (TRUE) {
[18:06:29.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.895]                 open = "w")
[18:06:29.895]         }
[18:06:29.895]         else {
[18:06:29.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.895]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.895]         }
[18:06:29.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.895]             base::sink(type = "output", split = FALSE)
[18:06:29.895]             base::close(...future.stdout)
[18:06:29.895]         }, add = TRUE)
[18:06:29.895]     }
[18:06:29.895]     ...future.frame <- base::sys.nframe()
[18:06:29.895]     ...future.conditions <- base::list()
[18:06:29.895]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.895]     if (FALSE) {
[18:06:29.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.895]     }
[18:06:29.895]     ...future.result <- base::tryCatch({
[18:06:29.895]         base::withCallingHandlers({
[18:06:29.895]             ...future.value <- base::withVisible(base::local({
[18:06:29.895]                 ...future.makeSendCondition <- base::local({
[18:06:29.895]                   sendCondition <- NULL
[18:06:29.895]                   function(frame = 1L) {
[18:06:29.895]                     if (is.function(sendCondition)) 
[18:06:29.895]                       return(sendCondition)
[18:06:29.895]                     ns <- getNamespace("parallel")
[18:06:29.895]                     if (exists("sendData", mode = "function", 
[18:06:29.895]                       envir = ns)) {
[18:06:29.895]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.895]                         envir = ns)
[18:06:29.895]                       envir <- sys.frame(frame)
[18:06:29.895]                       master <- NULL
[18:06:29.895]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.895]                         !identical(envir, emptyenv())) {
[18:06:29.895]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.895]                           inherits = FALSE)) {
[18:06:29.895]                           master <- get("master", mode = "list", 
[18:06:29.895]                             envir = envir, inherits = FALSE)
[18:06:29.895]                           if (inherits(master, c("SOCKnode", 
[18:06:29.895]                             "SOCK0node"))) {
[18:06:29.895]                             sendCondition <<- function(cond) {
[18:06:29.895]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.895]                                 success = TRUE)
[18:06:29.895]                               parallel_sendData(master, data)
[18:06:29.895]                             }
[18:06:29.895]                             return(sendCondition)
[18:06:29.895]                           }
[18:06:29.895]                         }
[18:06:29.895]                         frame <- frame + 1L
[18:06:29.895]                         envir <- sys.frame(frame)
[18:06:29.895]                       }
[18:06:29.895]                     }
[18:06:29.895]                     sendCondition <<- function(cond) NULL
[18:06:29.895]                   }
[18:06:29.895]                 })
[18:06:29.895]                 withCallingHandlers({
[18:06:29.895]                   1
[18:06:29.895]                 }, immediateCondition = function(cond) {
[18:06:29.895]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.895]                   sendCondition(cond)
[18:06:29.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.895]                   {
[18:06:29.895]                     inherits <- base::inherits
[18:06:29.895]                     invokeRestart <- base::invokeRestart
[18:06:29.895]                     is.null <- base::is.null
[18:06:29.895]                     muffled <- FALSE
[18:06:29.895]                     if (inherits(cond, "message")) {
[18:06:29.895]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.895]                       if (muffled) 
[18:06:29.895]                         invokeRestart("muffleMessage")
[18:06:29.895]                     }
[18:06:29.895]                     else if (inherits(cond, "warning")) {
[18:06:29.895]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.895]                       if (muffled) 
[18:06:29.895]                         invokeRestart("muffleWarning")
[18:06:29.895]                     }
[18:06:29.895]                     else if (inherits(cond, "condition")) {
[18:06:29.895]                       if (!is.null(pattern)) {
[18:06:29.895]                         computeRestarts <- base::computeRestarts
[18:06:29.895]                         grepl <- base::grepl
[18:06:29.895]                         restarts <- computeRestarts(cond)
[18:06:29.895]                         for (restart in restarts) {
[18:06:29.895]                           name <- restart$name
[18:06:29.895]                           if (is.null(name)) 
[18:06:29.895]                             next
[18:06:29.895]                           if (!grepl(pattern, name)) 
[18:06:29.895]                             next
[18:06:29.895]                           invokeRestart(restart)
[18:06:29.895]                           muffled <- TRUE
[18:06:29.895]                           break
[18:06:29.895]                         }
[18:06:29.895]                       }
[18:06:29.895]                     }
[18:06:29.895]                     invisible(muffled)
[18:06:29.895]                   }
[18:06:29.895]                   muffleCondition(cond)
[18:06:29.895]                 })
[18:06:29.895]             }))
[18:06:29.895]             future::FutureResult(value = ...future.value$value, 
[18:06:29.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.895]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.895]                     ...future.globalenv.names))
[18:06:29.895]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.895]         }, condition = base::local({
[18:06:29.895]             c <- base::c
[18:06:29.895]             inherits <- base::inherits
[18:06:29.895]             invokeRestart <- base::invokeRestart
[18:06:29.895]             length <- base::length
[18:06:29.895]             list <- base::list
[18:06:29.895]             seq.int <- base::seq.int
[18:06:29.895]             signalCondition <- base::signalCondition
[18:06:29.895]             sys.calls <- base::sys.calls
[18:06:29.895]             `[[` <- base::`[[`
[18:06:29.895]             `+` <- base::`+`
[18:06:29.895]             `<<-` <- base::`<<-`
[18:06:29.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.895]                   3L)]
[18:06:29.895]             }
[18:06:29.895]             function(cond) {
[18:06:29.895]                 is_error <- inherits(cond, "error")
[18:06:29.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.895]                   NULL)
[18:06:29.895]                 if (is_error) {
[18:06:29.895]                   sessionInformation <- function() {
[18:06:29.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.895]                       search = base::search(), system = base::Sys.info())
[18:06:29.895]                   }
[18:06:29.895]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.895]                     cond$call), session = sessionInformation(), 
[18:06:29.895]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.895]                   signalCondition(cond)
[18:06:29.895]                 }
[18:06:29.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.895]                 "immediateCondition"))) {
[18:06:29.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.895]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.895]                   if (TRUE && !signal) {
[18:06:29.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.895]                     {
[18:06:29.895]                       inherits <- base::inherits
[18:06:29.895]                       invokeRestart <- base::invokeRestart
[18:06:29.895]                       is.null <- base::is.null
[18:06:29.895]                       muffled <- FALSE
[18:06:29.895]                       if (inherits(cond, "message")) {
[18:06:29.895]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.895]                         if (muffled) 
[18:06:29.895]                           invokeRestart("muffleMessage")
[18:06:29.895]                       }
[18:06:29.895]                       else if (inherits(cond, "warning")) {
[18:06:29.895]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.895]                         if (muffled) 
[18:06:29.895]                           invokeRestart("muffleWarning")
[18:06:29.895]                       }
[18:06:29.895]                       else if (inherits(cond, "condition")) {
[18:06:29.895]                         if (!is.null(pattern)) {
[18:06:29.895]                           computeRestarts <- base::computeRestarts
[18:06:29.895]                           grepl <- base::grepl
[18:06:29.895]                           restarts <- computeRestarts(cond)
[18:06:29.895]                           for (restart in restarts) {
[18:06:29.895]                             name <- restart$name
[18:06:29.895]                             if (is.null(name)) 
[18:06:29.895]                               next
[18:06:29.895]                             if (!grepl(pattern, name)) 
[18:06:29.895]                               next
[18:06:29.895]                             invokeRestart(restart)
[18:06:29.895]                             muffled <- TRUE
[18:06:29.895]                             break
[18:06:29.895]                           }
[18:06:29.895]                         }
[18:06:29.895]                       }
[18:06:29.895]                       invisible(muffled)
[18:06:29.895]                     }
[18:06:29.895]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.895]                   }
[18:06:29.895]                 }
[18:06:29.895]                 else {
[18:06:29.895]                   if (TRUE) {
[18:06:29.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.895]                     {
[18:06:29.895]                       inherits <- base::inherits
[18:06:29.895]                       invokeRestart <- base::invokeRestart
[18:06:29.895]                       is.null <- base::is.null
[18:06:29.895]                       muffled <- FALSE
[18:06:29.895]                       if (inherits(cond, "message")) {
[18:06:29.895]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.895]                         if (muffled) 
[18:06:29.895]                           invokeRestart("muffleMessage")
[18:06:29.895]                       }
[18:06:29.895]                       else if (inherits(cond, "warning")) {
[18:06:29.895]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.895]                         if (muffled) 
[18:06:29.895]                           invokeRestart("muffleWarning")
[18:06:29.895]                       }
[18:06:29.895]                       else if (inherits(cond, "condition")) {
[18:06:29.895]                         if (!is.null(pattern)) {
[18:06:29.895]                           computeRestarts <- base::computeRestarts
[18:06:29.895]                           grepl <- base::grepl
[18:06:29.895]                           restarts <- computeRestarts(cond)
[18:06:29.895]                           for (restart in restarts) {
[18:06:29.895]                             name <- restart$name
[18:06:29.895]                             if (is.null(name)) 
[18:06:29.895]                               next
[18:06:29.895]                             if (!grepl(pattern, name)) 
[18:06:29.895]                               next
[18:06:29.895]                             invokeRestart(restart)
[18:06:29.895]                             muffled <- TRUE
[18:06:29.895]                             break
[18:06:29.895]                           }
[18:06:29.895]                         }
[18:06:29.895]                       }
[18:06:29.895]                       invisible(muffled)
[18:06:29.895]                     }
[18:06:29.895]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.895]                   }
[18:06:29.895]                 }
[18:06:29.895]             }
[18:06:29.895]         }))
[18:06:29.895]     }, error = function(ex) {
[18:06:29.895]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.895]                 ...future.rng), started = ...future.startTime, 
[18:06:29.895]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.895]             version = "1.8"), class = "FutureResult")
[18:06:29.895]     }, finally = {
[18:06:29.895]         if (!identical(...future.workdir, getwd())) 
[18:06:29.895]             setwd(...future.workdir)
[18:06:29.895]         {
[18:06:29.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.895]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.895]             }
[18:06:29.895]             base::options(...future.oldOptions)
[18:06:29.895]             if (.Platform$OS.type == "windows") {
[18:06:29.895]                 old_names <- names(...future.oldEnvVars)
[18:06:29.895]                 envs <- base::Sys.getenv()
[18:06:29.895]                 names <- names(envs)
[18:06:29.895]                 common <- intersect(names, old_names)
[18:06:29.895]                 added <- setdiff(names, old_names)
[18:06:29.895]                 removed <- setdiff(old_names, names)
[18:06:29.895]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.895]                   envs[common]]
[18:06:29.895]                 NAMES <- toupper(changed)
[18:06:29.895]                 args <- list()
[18:06:29.895]                 for (kk in seq_along(NAMES)) {
[18:06:29.895]                   name <- changed[[kk]]
[18:06:29.895]                   NAME <- NAMES[[kk]]
[18:06:29.895]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.895]                     next
[18:06:29.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.895]                 }
[18:06:29.895]                 NAMES <- toupper(added)
[18:06:29.895]                 for (kk in seq_along(NAMES)) {
[18:06:29.895]                   name <- added[[kk]]
[18:06:29.895]                   NAME <- NAMES[[kk]]
[18:06:29.895]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.895]                     next
[18:06:29.895]                   args[[name]] <- ""
[18:06:29.895]                 }
[18:06:29.895]                 NAMES <- toupper(removed)
[18:06:29.895]                 for (kk in seq_along(NAMES)) {
[18:06:29.895]                   name <- removed[[kk]]
[18:06:29.895]                   NAME <- NAMES[[kk]]
[18:06:29.895]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.895]                     next
[18:06:29.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.895]                 }
[18:06:29.895]                 if (length(args) > 0) 
[18:06:29.895]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.895]             }
[18:06:29.895]             else {
[18:06:29.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.895]             }
[18:06:29.895]             {
[18:06:29.895]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.895]                   0L) {
[18:06:29.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.895]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.895]                   base::options(opts)
[18:06:29.895]                 }
[18:06:29.895]                 {
[18:06:29.895]                   {
[18:06:29.895]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.895]                     NULL
[18:06:29.895]                   }
[18:06:29.895]                   options(future.plan = NULL)
[18:06:29.895]                   if (is.na(NA_character_)) 
[18:06:29.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.895]                     .init = FALSE)
[18:06:29.895]                 }
[18:06:29.895]             }
[18:06:29.895]         }
[18:06:29.895]     })
[18:06:29.895]     if (TRUE) {
[18:06:29.895]         base::sink(type = "output", split = FALSE)
[18:06:29.895]         if (TRUE) {
[18:06:29.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.895]         }
[18:06:29.895]         else {
[18:06:29.895]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.895]         }
[18:06:29.895]         base::close(...future.stdout)
[18:06:29.895]         ...future.stdout <- NULL
[18:06:29.895]     }
[18:06:29.895]     ...future.result$conditions <- ...future.conditions
[18:06:29.895]     ...future.result$finished <- base::Sys.time()
[18:06:29.895]     ...future.result
[18:06:29.895] }
[18:06:29.902] MultisessionFuture started
[18:06:29.903] - Launch lazy future ... done
[18:06:29.903] run() for ‘MultisessionFuture’ ... done
[18:06:29.903] getGlobalsAndPackages() ...
[18:06:29.904] Searching for globals...
[18:06:29.904] 
[18:06:29.905] Searching for globals ... DONE
[18:06:29.905] - globals: [0] <none>
[18:06:29.905] getGlobalsAndPackages() ... DONE
[18:06:29.906] run() for ‘Future’ ...
[18:06:29.906] - state: ‘created’
[18:06:29.906] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:29.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:29.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:29.934]   - Field: ‘node’
[18:06:29.934]   - Field: ‘label’
[18:06:29.934]   - Field: ‘local’
[18:06:29.934]   - Field: ‘owner’
[18:06:29.934]   - Field: ‘envir’
[18:06:29.935]   - Field: ‘workers’
[18:06:29.935]   - Field: ‘packages’
[18:06:29.935]   - Field: ‘gc’
[18:06:29.935]   - Field: ‘conditions’
[18:06:29.935]   - Field: ‘persistent’
[18:06:29.936]   - Field: ‘expr’
[18:06:29.936]   - Field: ‘uuid’
[18:06:29.936]   - Field: ‘seed’
[18:06:29.936]   - Field: ‘version’
[18:06:29.937]   - Field: ‘result’
[18:06:29.937]   - Field: ‘asynchronous’
[18:06:29.937]   - Field: ‘calls’
[18:06:29.937]   - Field: ‘globals’
[18:06:29.937]   - Field: ‘stdout’
[18:06:29.938]   - Field: ‘earlySignal’
[18:06:29.938]   - Field: ‘lazy’
[18:06:29.938]   - Field: ‘state’
[18:06:29.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:29.938] - Launch lazy future ...
[18:06:29.939] Packages needed by the future expression (n = 0): <none>
[18:06:29.939] Packages needed by future strategies (n = 0): <none>
[18:06:29.940] {
[18:06:29.940]     {
[18:06:29.940]         {
[18:06:29.940]             ...future.startTime <- base::Sys.time()
[18:06:29.940]             {
[18:06:29.940]                 {
[18:06:29.940]                   {
[18:06:29.940]                     {
[18:06:29.940]                       base::local({
[18:06:29.940]                         has_future <- base::requireNamespace("future", 
[18:06:29.940]                           quietly = TRUE)
[18:06:29.940]                         if (has_future) {
[18:06:29.940]                           ns <- base::getNamespace("future")
[18:06:29.940]                           version <- ns[[".package"]][["version"]]
[18:06:29.940]                           if (is.null(version)) 
[18:06:29.940]                             version <- utils::packageVersion("future")
[18:06:29.940]                         }
[18:06:29.940]                         else {
[18:06:29.940]                           version <- NULL
[18:06:29.940]                         }
[18:06:29.940]                         if (!has_future || version < "1.8.0") {
[18:06:29.940]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:29.940]                             "", base::R.version$version.string), 
[18:06:29.940]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:29.940]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:29.940]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:29.940]                               "release", "version")], collapse = " "), 
[18:06:29.940]                             hostname = base::Sys.info()[["nodename"]])
[18:06:29.940]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:29.940]                             info)
[18:06:29.940]                           info <- base::paste(info, collapse = "; ")
[18:06:29.940]                           if (!has_future) {
[18:06:29.940]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:29.940]                               info)
[18:06:29.940]                           }
[18:06:29.940]                           else {
[18:06:29.940]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:29.940]                               info, version)
[18:06:29.940]                           }
[18:06:29.940]                           base::stop(msg)
[18:06:29.940]                         }
[18:06:29.940]                       })
[18:06:29.940]                     }
[18:06:29.940]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:29.940]                     base::options(mc.cores = 1L)
[18:06:29.940]                   }
[18:06:29.940]                   ...future.strategy.old <- future::plan("list")
[18:06:29.940]                   options(future.plan = NULL)
[18:06:29.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:29.940]                 }
[18:06:29.940]                 ...future.workdir <- getwd()
[18:06:29.940]             }
[18:06:29.940]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:29.940]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:29.940]         }
[18:06:29.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:29.940]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:29.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:29.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:29.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:29.940]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:29.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:29.940]             base::names(...future.oldOptions))
[18:06:29.940]     }
[18:06:29.940]     if (FALSE) {
[18:06:29.940]     }
[18:06:29.940]     else {
[18:06:29.940]         if (TRUE) {
[18:06:29.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:29.940]                 open = "w")
[18:06:29.940]         }
[18:06:29.940]         else {
[18:06:29.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:29.940]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:29.940]         }
[18:06:29.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:29.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:29.940]             base::sink(type = "output", split = FALSE)
[18:06:29.940]             base::close(...future.stdout)
[18:06:29.940]         }, add = TRUE)
[18:06:29.940]     }
[18:06:29.940]     ...future.frame <- base::sys.nframe()
[18:06:29.940]     ...future.conditions <- base::list()
[18:06:29.940]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:29.940]     if (FALSE) {
[18:06:29.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:29.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:29.940]     }
[18:06:29.940]     ...future.result <- base::tryCatch({
[18:06:29.940]         base::withCallingHandlers({
[18:06:29.940]             ...future.value <- base::withVisible(base::local({
[18:06:29.940]                 ...future.makeSendCondition <- base::local({
[18:06:29.940]                   sendCondition <- NULL
[18:06:29.940]                   function(frame = 1L) {
[18:06:29.940]                     if (is.function(sendCondition)) 
[18:06:29.940]                       return(sendCondition)
[18:06:29.940]                     ns <- getNamespace("parallel")
[18:06:29.940]                     if (exists("sendData", mode = "function", 
[18:06:29.940]                       envir = ns)) {
[18:06:29.940]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:29.940]                         envir = ns)
[18:06:29.940]                       envir <- sys.frame(frame)
[18:06:29.940]                       master <- NULL
[18:06:29.940]                       while (!identical(envir, .GlobalEnv) && 
[18:06:29.940]                         !identical(envir, emptyenv())) {
[18:06:29.940]                         if (exists("master", mode = "list", envir = envir, 
[18:06:29.940]                           inherits = FALSE)) {
[18:06:29.940]                           master <- get("master", mode = "list", 
[18:06:29.940]                             envir = envir, inherits = FALSE)
[18:06:29.940]                           if (inherits(master, c("SOCKnode", 
[18:06:29.940]                             "SOCK0node"))) {
[18:06:29.940]                             sendCondition <<- function(cond) {
[18:06:29.940]                               data <- list(type = "VALUE", value = cond, 
[18:06:29.940]                                 success = TRUE)
[18:06:29.940]                               parallel_sendData(master, data)
[18:06:29.940]                             }
[18:06:29.940]                             return(sendCondition)
[18:06:29.940]                           }
[18:06:29.940]                         }
[18:06:29.940]                         frame <- frame + 1L
[18:06:29.940]                         envir <- sys.frame(frame)
[18:06:29.940]                       }
[18:06:29.940]                     }
[18:06:29.940]                     sendCondition <<- function(cond) NULL
[18:06:29.940]                   }
[18:06:29.940]                 })
[18:06:29.940]                 withCallingHandlers({
[18:06:29.940]                   2
[18:06:29.940]                 }, immediateCondition = function(cond) {
[18:06:29.940]                   sendCondition <- ...future.makeSendCondition()
[18:06:29.940]                   sendCondition(cond)
[18:06:29.940]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.940]                   {
[18:06:29.940]                     inherits <- base::inherits
[18:06:29.940]                     invokeRestart <- base::invokeRestart
[18:06:29.940]                     is.null <- base::is.null
[18:06:29.940]                     muffled <- FALSE
[18:06:29.940]                     if (inherits(cond, "message")) {
[18:06:29.940]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:29.940]                       if (muffled) 
[18:06:29.940]                         invokeRestart("muffleMessage")
[18:06:29.940]                     }
[18:06:29.940]                     else if (inherits(cond, "warning")) {
[18:06:29.940]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:29.940]                       if (muffled) 
[18:06:29.940]                         invokeRestart("muffleWarning")
[18:06:29.940]                     }
[18:06:29.940]                     else if (inherits(cond, "condition")) {
[18:06:29.940]                       if (!is.null(pattern)) {
[18:06:29.940]                         computeRestarts <- base::computeRestarts
[18:06:29.940]                         grepl <- base::grepl
[18:06:29.940]                         restarts <- computeRestarts(cond)
[18:06:29.940]                         for (restart in restarts) {
[18:06:29.940]                           name <- restart$name
[18:06:29.940]                           if (is.null(name)) 
[18:06:29.940]                             next
[18:06:29.940]                           if (!grepl(pattern, name)) 
[18:06:29.940]                             next
[18:06:29.940]                           invokeRestart(restart)
[18:06:29.940]                           muffled <- TRUE
[18:06:29.940]                           break
[18:06:29.940]                         }
[18:06:29.940]                       }
[18:06:29.940]                     }
[18:06:29.940]                     invisible(muffled)
[18:06:29.940]                   }
[18:06:29.940]                   muffleCondition(cond)
[18:06:29.940]                 })
[18:06:29.940]             }))
[18:06:29.940]             future::FutureResult(value = ...future.value$value, 
[18:06:29.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.940]                   ...future.rng), globalenv = if (FALSE) 
[18:06:29.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:29.940]                     ...future.globalenv.names))
[18:06:29.940]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:29.940]         }, condition = base::local({
[18:06:29.940]             c <- base::c
[18:06:29.940]             inherits <- base::inherits
[18:06:29.940]             invokeRestart <- base::invokeRestart
[18:06:29.940]             length <- base::length
[18:06:29.940]             list <- base::list
[18:06:29.940]             seq.int <- base::seq.int
[18:06:29.940]             signalCondition <- base::signalCondition
[18:06:29.940]             sys.calls <- base::sys.calls
[18:06:29.940]             `[[` <- base::`[[`
[18:06:29.940]             `+` <- base::`+`
[18:06:29.940]             `<<-` <- base::`<<-`
[18:06:29.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:29.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:29.940]                   3L)]
[18:06:29.940]             }
[18:06:29.940]             function(cond) {
[18:06:29.940]                 is_error <- inherits(cond, "error")
[18:06:29.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:29.940]                   NULL)
[18:06:29.940]                 if (is_error) {
[18:06:29.940]                   sessionInformation <- function() {
[18:06:29.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:29.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:29.940]                       search = base::search(), system = base::Sys.info())
[18:06:29.940]                   }
[18:06:29.940]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:29.940]                     cond$call), session = sessionInformation(), 
[18:06:29.940]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:29.940]                   signalCondition(cond)
[18:06:29.940]                 }
[18:06:29.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:29.940]                 "immediateCondition"))) {
[18:06:29.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:29.940]                   ...future.conditions[[length(...future.conditions) + 
[18:06:29.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:29.940]                   if (TRUE && !signal) {
[18:06:29.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.940]                     {
[18:06:29.940]                       inherits <- base::inherits
[18:06:29.940]                       invokeRestart <- base::invokeRestart
[18:06:29.940]                       is.null <- base::is.null
[18:06:29.940]                       muffled <- FALSE
[18:06:29.940]                       if (inherits(cond, "message")) {
[18:06:29.940]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.940]                         if (muffled) 
[18:06:29.940]                           invokeRestart("muffleMessage")
[18:06:29.940]                       }
[18:06:29.940]                       else if (inherits(cond, "warning")) {
[18:06:29.940]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.940]                         if (muffled) 
[18:06:29.940]                           invokeRestart("muffleWarning")
[18:06:29.940]                       }
[18:06:29.940]                       else if (inherits(cond, "condition")) {
[18:06:29.940]                         if (!is.null(pattern)) {
[18:06:29.940]                           computeRestarts <- base::computeRestarts
[18:06:29.940]                           grepl <- base::grepl
[18:06:29.940]                           restarts <- computeRestarts(cond)
[18:06:29.940]                           for (restart in restarts) {
[18:06:29.940]                             name <- restart$name
[18:06:29.940]                             if (is.null(name)) 
[18:06:29.940]                               next
[18:06:29.940]                             if (!grepl(pattern, name)) 
[18:06:29.940]                               next
[18:06:29.940]                             invokeRestart(restart)
[18:06:29.940]                             muffled <- TRUE
[18:06:29.940]                             break
[18:06:29.940]                           }
[18:06:29.940]                         }
[18:06:29.940]                       }
[18:06:29.940]                       invisible(muffled)
[18:06:29.940]                     }
[18:06:29.940]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.940]                   }
[18:06:29.940]                 }
[18:06:29.940]                 else {
[18:06:29.940]                   if (TRUE) {
[18:06:29.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:29.940]                     {
[18:06:29.940]                       inherits <- base::inherits
[18:06:29.940]                       invokeRestart <- base::invokeRestart
[18:06:29.940]                       is.null <- base::is.null
[18:06:29.940]                       muffled <- FALSE
[18:06:29.940]                       if (inherits(cond, "message")) {
[18:06:29.940]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:29.940]                         if (muffled) 
[18:06:29.940]                           invokeRestart("muffleMessage")
[18:06:29.940]                       }
[18:06:29.940]                       else if (inherits(cond, "warning")) {
[18:06:29.940]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:29.940]                         if (muffled) 
[18:06:29.940]                           invokeRestart("muffleWarning")
[18:06:29.940]                       }
[18:06:29.940]                       else if (inherits(cond, "condition")) {
[18:06:29.940]                         if (!is.null(pattern)) {
[18:06:29.940]                           computeRestarts <- base::computeRestarts
[18:06:29.940]                           grepl <- base::grepl
[18:06:29.940]                           restarts <- computeRestarts(cond)
[18:06:29.940]                           for (restart in restarts) {
[18:06:29.940]                             name <- restart$name
[18:06:29.940]                             if (is.null(name)) 
[18:06:29.940]                               next
[18:06:29.940]                             if (!grepl(pattern, name)) 
[18:06:29.940]                               next
[18:06:29.940]                             invokeRestart(restart)
[18:06:29.940]                             muffled <- TRUE
[18:06:29.940]                             break
[18:06:29.940]                           }
[18:06:29.940]                         }
[18:06:29.940]                       }
[18:06:29.940]                       invisible(muffled)
[18:06:29.940]                     }
[18:06:29.940]                     muffleCondition(cond, pattern = "^muffle")
[18:06:29.940]                   }
[18:06:29.940]                 }
[18:06:29.940]             }
[18:06:29.940]         }))
[18:06:29.940]     }, error = function(ex) {
[18:06:29.940]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:29.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:29.940]                 ...future.rng), started = ...future.startTime, 
[18:06:29.940]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:29.940]             version = "1.8"), class = "FutureResult")
[18:06:29.940]     }, finally = {
[18:06:29.940]         if (!identical(...future.workdir, getwd())) 
[18:06:29.940]             setwd(...future.workdir)
[18:06:29.940]         {
[18:06:29.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:29.940]                 ...future.oldOptions$nwarnings <- NULL
[18:06:29.940]             }
[18:06:29.940]             base::options(...future.oldOptions)
[18:06:29.940]             if (.Platform$OS.type == "windows") {
[18:06:29.940]                 old_names <- names(...future.oldEnvVars)
[18:06:29.940]                 envs <- base::Sys.getenv()
[18:06:29.940]                 names <- names(envs)
[18:06:29.940]                 common <- intersect(names, old_names)
[18:06:29.940]                 added <- setdiff(names, old_names)
[18:06:29.940]                 removed <- setdiff(old_names, names)
[18:06:29.940]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:29.940]                   envs[common]]
[18:06:29.940]                 NAMES <- toupper(changed)
[18:06:29.940]                 args <- list()
[18:06:29.940]                 for (kk in seq_along(NAMES)) {
[18:06:29.940]                   name <- changed[[kk]]
[18:06:29.940]                   NAME <- NAMES[[kk]]
[18:06:29.940]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.940]                     next
[18:06:29.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.940]                 }
[18:06:29.940]                 NAMES <- toupper(added)
[18:06:29.940]                 for (kk in seq_along(NAMES)) {
[18:06:29.940]                   name <- added[[kk]]
[18:06:29.940]                   NAME <- NAMES[[kk]]
[18:06:29.940]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.940]                     next
[18:06:29.940]                   args[[name]] <- ""
[18:06:29.940]                 }
[18:06:29.940]                 NAMES <- toupper(removed)
[18:06:29.940]                 for (kk in seq_along(NAMES)) {
[18:06:29.940]                   name <- removed[[kk]]
[18:06:29.940]                   NAME <- NAMES[[kk]]
[18:06:29.940]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:29.940]                     next
[18:06:29.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:29.940]                 }
[18:06:29.940]                 if (length(args) > 0) 
[18:06:29.940]                   base::do.call(base::Sys.setenv, args = args)
[18:06:29.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:29.940]             }
[18:06:29.940]             else {
[18:06:29.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:29.940]             }
[18:06:29.940]             {
[18:06:29.940]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:29.940]                   0L) {
[18:06:29.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:29.940]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:29.940]                   base::options(opts)
[18:06:29.940]                 }
[18:06:29.940]                 {
[18:06:29.940]                   {
[18:06:29.940]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:29.940]                     NULL
[18:06:29.940]                   }
[18:06:29.940]                   options(future.plan = NULL)
[18:06:29.940]                   if (is.na(NA_character_)) 
[18:06:29.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:29.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:29.940]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:29.940]                     .init = FALSE)
[18:06:29.940]                 }
[18:06:29.940]             }
[18:06:29.940]         }
[18:06:29.940]     })
[18:06:29.940]     if (TRUE) {
[18:06:29.940]         base::sink(type = "output", split = FALSE)
[18:06:29.940]         if (TRUE) {
[18:06:29.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:29.940]         }
[18:06:29.940]         else {
[18:06:29.940]             ...future.result["stdout"] <- base::list(NULL)
[18:06:29.940]         }
[18:06:29.940]         base::close(...future.stdout)
[18:06:29.940]         ...future.stdout <- NULL
[18:06:29.940]     }
[18:06:29.940]     ...future.result$conditions <- ...future.conditions
[18:06:29.940]     ...future.result$finished <- base::Sys.time()
[18:06:29.940]     ...future.result
[18:06:29.940] }
[18:06:29.946] MultisessionFuture started
[18:06:29.947] - Launch lazy future ... done
[18:06:29.947] run() for ‘MultisessionFuture’ ... done
[18:06:29.952] resolve() on environment ...
[18:06:29.952]  recursive: 0
[18:06:29.953]  elements: [3] ‘a’, ‘b’, ‘c’
[18:06:29.954] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.954] - Validating connection of MultisessionFuture
[18:06:29.955] - received message: FutureResult
[18:06:29.955] - Received FutureResult
[18:06:29.955] - Erased future from FutureRegistry
[18:06:29.955] result() for ClusterFuture ...
[18:06:29.956] - result already collected: FutureResult
[18:06:29.956] result() for ClusterFuture ... done
[18:06:29.956] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.956] Future #1
[18:06:29.956]  length: 2 (resolved future 1)
[18:06:29.968]  length: 1 (resolved future 3)
[18:06:29.990] receiveMessageFromWorker() for ClusterFuture ...
[18:06:29.990] - Validating connection of MultisessionFuture
[18:06:29.991] - received message: FutureResult
[18:06:29.991] - Received FutureResult
[18:06:29.991] - Erased future from FutureRegistry
[18:06:29.991] result() for ClusterFuture ...
[18:06:29.992] - result already collected: FutureResult
[18:06:29.992] result() for ClusterFuture ... done
[18:06:29.992] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:29.992] Future #2
[18:06:29.992]  length: 0 (resolved future 2)
[18:06:29.993] resolve() on environment ... DONE
[18:06:29.994] getGlobalsAndPackages() ...
[18:06:29.994] Searching for globals...
[18:06:29.997] - globals found: [1] ‘{’
[18:06:29.997] Searching for globals ... DONE
[18:06:29.998] Resolving globals: FALSE
[18:06:29.998] 
[18:06:29.998] 
[18:06:29.999] getGlobalsAndPackages() ... DONE
[18:06:29.999] run() for ‘Future’ ...
[18:06:29.999] - state: ‘created’
[18:06:30.000] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.023]   - Field: ‘node’
[18:06:30.023]   - Field: ‘label’
[18:06:30.023]   - Field: ‘local’
[18:06:30.023]   - Field: ‘owner’
[18:06:30.024]   - Field: ‘envir’
[18:06:30.024]   - Field: ‘workers’
[18:06:30.024]   - Field: ‘packages’
[18:06:30.024]   - Field: ‘gc’
[18:06:30.024]   - Field: ‘conditions’
[18:06:30.025]   - Field: ‘persistent’
[18:06:30.025]   - Field: ‘expr’
[18:06:30.025]   - Field: ‘uuid’
[18:06:30.025]   - Field: ‘seed’
[18:06:30.025]   - Field: ‘version’
[18:06:30.025]   - Field: ‘result’
[18:06:30.026]   - Field: ‘asynchronous’
[18:06:30.026]   - Field: ‘calls’
[18:06:30.026]   - Field: ‘globals’
[18:06:30.026]   - Field: ‘stdout’
[18:06:30.026]   - Field: ‘earlySignal’
[18:06:30.027]   - Field: ‘lazy’
[18:06:30.027]   - Field: ‘state’
[18:06:30.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.027] - Launch lazy future ...
[18:06:30.028] Packages needed by the future expression (n = 0): <none>
[18:06:30.028] Packages needed by future strategies (n = 0): <none>
[18:06:30.029] {
[18:06:30.029]     {
[18:06:30.029]         {
[18:06:30.029]             ...future.startTime <- base::Sys.time()
[18:06:30.029]             {
[18:06:30.029]                 {
[18:06:30.029]                   {
[18:06:30.029]                     {
[18:06:30.029]                       base::local({
[18:06:30.029]                         has_future <- base::requireNamespace("future", 
[18:06:30.029]                           quietly = TRUE)
[18:06:30.029]                         if (has_future) {
[18:06:30.029]                           ns <- base::getNamespace("future")
[18:06:30.029]                           version <- ns[[".package"]][["version"]]
[18:06:30.029]                           if (is.null(version)) 
[18:06:30.029]                             version <- utils::packageVersion("future")
[18:06:30.029]                         }
[18:06:30.029]                         else {
[18:06:30.029]                           version <- NULL
[18:06:30.029]                         }
[18:06:30.029]                         if (!has_future || version < "1.8.0") {
[18:06:30.029]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.029]                             "", base::R.version$version.string), 
[18:06:30.029]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.029]                               "release", "version")], collapse = " "), 
[18:06:30.029]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.029]                             info)
[18:06:30.029]                           info <- base::paste(info, collapse = "; ")
[18:06:30.029]                           if (!has_future) {
[18:06:30.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.029]                               info)
[18:06:30.029]                           }
[18:06:30.029]                           else {
[18:06:30.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.029]                               info, version)
[18:06:30.029]                           }
[18:06:30.029]                           base::stop(msg)
[18:06:30.029]                         }
[18:06:30.029]                       })
[18:06:30.029]                     }
[18:06:30.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.029]                     base::options(mc.cores = 1L)
[18:06:30.029]                   }
[18:06:30.029]                   ...future.strategy.old <- future::plan("list")
[18:06:30.029]                   options(future.plan = NULL)
[18:06:30.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.029]                 }
[18:06:30.029]                 ...future.workdir <- getwd()
[18:06:30.029]             }
[18:06:30.029]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.029]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.029]         }
[18:06:30.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.029]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.029]             base::names(...future.oldOptions))
[18:06:30.029]     }
[18:06:30.029]     if (FALSE) {
[18:06:30.029]     }
[18:06:30.029]     else {
[18:06:30.029]         if (TRUE) {
[18:06:30.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.029]                 open = "w")
[18:06:30.029]         }
[18:06:30.029]         else {
[18:06:30.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.029]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.029]         }
[18:06:30.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.029]             base::sink(type = "output", split = FALSE)
[18:06:30.029]             base::close(...future.stdout)
[18:06:30.029]         }, add = TRUE)
[18:06:30.029]     }
[18:06:30.029]     ...future.frame <- base::sys.nframe()
[18:06:30.029]     ...future.conditions <- base::list()
[18:06:30.029]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.029]     if (FALSE) {
[18:06:30.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.029]     }
[18:06:30.029]     ...future.result <- base::tryCatch({
[18:06:30.029]         base::withCallingHandlers({
[18:06:30.029]             ...future.value <- base::withVisible(base::local({
[18:06:30.029]                 ...future.makeSendCondition <- base::local({
[18:06:30.029]                   sendCondition <- NULL
[18:06:30.029]                   function(frame = 1L) {
[18:06:30.029]                     if (is.function(sendCondition)) 
[18:06:30.029]                       return(sendCondition)
[18:06:30.029]                     ns <- getNamespace("parallel")
[18:06:30.029]                     if (exists("sendData", mode = "function", 
[18:06:30.029]                       envir = ns)) {
[18:06:30.029]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.029]                         envir = ns)
[18:06:30.029]                       envir <- sys.frame(frame)
[18:06:30.029]                       master <- NULL
[18:06:30.029]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.029]                         !identical(envir, emptyenv())) {
[18:06:30.029]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.029]                           inherits = FALSE)) {
[18:06:30.029]                           master <- get("master", mode = "list", 
[18:06:30.029]                             envir = envir, inherits = FALSE)
[18:06:30.029]                           if (inherits(master, c("SOCKnode", 
[18:06:30.029]                             "SOCK0node"))) {
[18:06:30.029]                             sendCondition <<- function(cond) {
[18:06:30.029]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.029]                                 success = TRUE)
[18:06:30.029]                               parallel_sendData(master, data)
[18:06:30.029]                             }
[18:06:30.029]                             return(sendCondition)
[18:06:30.029]                           }
[18:06:30.029]                         }
[18:06:30.029]                         frame <- frame + 1L
[18:06:30.029]                         envir <- sys.frame(frame)
[18:06:30.029]                       }
[18:06:30.029]                     }
[18:06:30.029]                     sendCondition <<- function(cond) NULL
[18:06:30.029]                   }
[18:06:30.029]                 })
[18:06:30.029]                 withCallingHandlers({
[18:06:30.029]                   {
[18:06:30.029]                     1
[18:06:30.029]                   }
[18:06:30.029]                 }, immediateCondition = function(cond) {
[18:06:30.029]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.029]                   sendCondition(cond)
[18:06:30.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.029]                   {
[18:06:30.029]                     inherits <- base::inherits
[18:06:30.029]                     invokeRestart <- base::invokeRestart
[18:06:30.029]                     is.null <- base::is.null
[18:06:30.029]                     muffled <- FALSE
[18:06:30.029]                     if (inherits(cond, "message")) {
[18:06:30.029]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.029]                       if (muffled) 
[18:06:30.029]                         invokeRestart("muffleMessage")
[18:06:30.029]                     }
[18:06:30.029]                     else if (inherits(cond, "warning")) {
[18:06:30.029]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.029]                       if (muffled) 
[18:06:30.029]                         invokeRestart("muffleWarning")
[18:06:30.029]                     }
[18:06:30.029]                     else if (inherits(cond, "condition")) {
[18:06:30.029]                       if (!is.null(pattern)) {
[18:06:30.029]                         computeRestarts <- base::computeRestarts
[18:06:30.029]                         grepl <- base::grepl
[18:06:30.029]                         restarts <- computeRestarts(cond)
[18:06:30.029]                         for (restart in restarts) {
[18:06:30.029]                           name <- restart$name
[18:06:30.029]                           if (is.null(name)) 
[18:06:30.029]                             next
[18:06:30.029]                           if (!grepl(pattern, name)) 
[18:06:30.029]                             next
[18:06:30.029]                           invokeRestart(restart)
[18:06:30.029]                           muffled <- TRUE
[18:06:30.029]                           break
[18:06:30.029]                         }
[18:06:30.029]                       }
[18:06:30.029]                     }
[18:06:30.029]                     invisible(muffled)
[18:06:30.029]                   }
[18:06:30.029]                   muffleCondition(cond)
[18:06:30.029]                 })
[18:06:30.029]             }))
[18:06:30.029]             future::FutureResult(value = ...future.value$value, 
[18:06:30.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.029]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.029]                     ...future.globalenv.names))
[18:06:30.029]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.029]         }, condition = base::local({
[18:06:30.029]             c <- base::c
[18:06:30.029]             inherits <- base::inherits
[18:06:30.029]             invokeRestart <- base::invokeRestart
[18:06:30.029]             length <- base::length
[18:06:30.029]             list <- base::list
[18:06:30.029]             seq.int <- base::seq.int
[18:06:30.029]             signalCondition <- base::signalCondition
[18:06:30.029]             sys.calls <- base::sys.calls
[18:06:30.029]             `[[` <- base::`[[`
[18:06:30.029]             `+` <- base::`+`
[18:06:30.029]             `<<-` <- base::`<<-`
[18:06:30.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.029]                   3L)]
[18:06:30.029]             }
[18:06:30.029]             function(cond) {
[18:06:30.029]                 is_error <- inherits(cond, "error")
[18:06:30.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.029]                   NULL)
[18:06:30.029]                 if (is_error) {
[18:06:30.029]                   sessionInformation <- function() {
[18:06:30.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.029]                       search = base::search(), system = base::Sys.info())
[18:06:30.029]                   }
[18:06:30.029]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.029]                     cond$call), session = sessionInformation(), 
[18:06:30.029]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.029]                   signalCondition(cond)
[18:06:30.029]                 }
[18:06:30.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.029]                 "immediateCondition"))) {
[18:06:30.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.029]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.029]                   if (TRUE && !signal) {
[18:06:30.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.029]                     {
[18:06:30.029]                       inherits <- base::inherits
[18:06:30.029]                       invokeRestart <- base::invokeRestart
[18:06:30.029]                       is.null <- base::is.null
[18:06:30.029]                       muffled <- FALSE
[18:06:30.029]                       if (inherits(cond, "message")) {
[18:06:30.029]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.029]                         if (muffled) 
[18:06:30.029]                           invokeRestart("muffleMessage")
[18:06:30.029]                       }
[18:06:30.029]                       else if (inherits(cond, "warning")) {
[18:06:30.029]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.029]                         if (muffled) 
[18:06:30.029]                           invokeRestart("muffleWarning")
[18:06:30.029]                       }
[18:06:30.029]                       else if (inherits(cond, "condition")) {
[18:06:30.029]                         if (!is.null(pattern)) {
[18:06:30.029]                           computeRestarts <- base::computeRestarts
[18:06:30.029]                           grepl <- base::grepl
[18:06:30.029]                           restarts <- computeRestarts(cond)
[18:06:30.029]                           for (restart in restarts) {
[18:06:30.029]                             name <- restart$name
[18:06:30.029]                             if (is.null(name)) 
[18:06:30.029]                               next
[18:06:30.029]                             if (!grepl(pattern, name)) 
[18:06:30.029]                               next
[18:06:30.029]                             invokeRestart(restart)
[18:06:30.029]                             muffled <- TRUE
[18:06:30.029]                             break
[18:06:30.029]                           }
[18:06:30.029]                         }
[18:06:30.029]                       }
[18:06:30.029]                       invisible(muffled)
[18:06:30.029]                     }
[18:06:30.029]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.029]                   }
[18:06:30.029]                 }
[18:06:30.029]                 else {
[18:06:30.029]                   if (TRUE) {
[18:06:30.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.029]                     {
[18:06:30.029]                       inherits <- base::inherits
[18:06:30.029]                       invokeRestart <- base::invokeRestart
[18:06:30.029]                       is.null <- base::is.null
[18:06:30.029]                       muffled <- FALSE
[18:06:30.029]                       if (inherits(cond, "message")) {
[18:06:30.029]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.029]                         if (muffled) 
[18:06:30.029]                           invokeRestart("muffleMessage")
[18:06:30.029]                       }
[18:06:30.029]                       else if (inherits(cond, "warning")) {
[18:06:30.029]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.029]                         if (muffled) 
[18:06:30.029]                           invokeRestart("muffleWarning")
[18:06:30.029]                       }
[18:06:30.029]                       else if (inherits(cond, "condition")) {
[18:06:30.029]                         if (!is.null(pattern)) {
[18:06:30.029]                           computeRestarts <- base::computeRestarts
[18:06:30.029]                           grepl <- base::grepl
[18:06:30.029]                           restarts <- computeRestarts(cond)
[18:06:30.029]                           for (restart in restarts) {
[18:06:30.029]                             name <- restart$name
[18:06:30.029]                             if (is.null(name)) 
[18:06:30.029]                               next
[18:06:30.029]                             if (!grepl(pattern, name)) 
[18:06:30.029]                               next
[18:06:30.029]                             invokeRestart(restart)
[18:06:30.029]                             muffled <- TRUE
[18:06:30.029]                             break
[18:06:30.029]                           }
[18:06:30.029]                         }
[18:06:30.029]                       }
[18:06:30.029]                       invisible(muffled)
[18:06:30.029]                     }
[18:06:30.029]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.029]                   }
[18:06:30.029]                 }
[18:06:30.029]             }
[18:06:30.029]         }))
[18:06:30.029]     }, error = function(ex) {
[18:06:30.029]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.029]                 ...future.rng), started = ...future.startTime, 
[18:06:30.029]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.029]             version = "1.8"), class = "FutureResult")
[18:06:30.029]     }, finally = {
[18:06:30.029]         if (!identical(...future.workdir, getwd())) 
[18:06:30.029]             setwd(...future.workdir)
[18:06:30.029]         {
[18:06:30.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.029]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.029]             }
[18:06:30.029]             base::options(...future.oldOptions)
[18:06:30.029]             if (.Platform$OS.type == "windows") {
[18:06:30.029]                 old_names <- names(...future.oldEnvVars)
[18:06:30.029]                 envs <- base::Sys.getenv()
[18:06:30.029]                 names <- names(envs)
[18:06:30.029]                 common <- intersect(names, old_names)
[18:06:30.029]                 added <- setdiff(names, old_names)
[18:06:30.029]                 removed <- setdiff(old_names, names)
[18:06:30.029]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.029]                   envs[common]]
[18:06:30.029]                 NAMES <- toupper(changed)
[18:06:30.029]                 args <- list()
[18:06:30.029]                 for (kk in seq_along(NAMES)) {
[18:06:30.029]                   name <- changed[[kk]]
[18:06:30.029]                   NAME <- NAMES[[kk]]
[18:06:30.029]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.029]                     next
[18:06:30.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.029]                 }
[18:06:30.029]                 NAMES <- toupper(added)
[18:06:30.029]                 for (kk in seq_along(NAMES)) {
[18:06:30.029]                   name <- added[[kk]]
[18:06:30.029]                   NAME <- NAMES[[kk]]
[18:06:30.029]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.029]                     next
[18:06:30.029]                   args[[name]] <- ""
[18:06:30.029]                 }
[18:06:30.029]                 NAMES <- toupper(removed)
[18:06:30.029]                 for (kk in seq_along(NAMES)) {
[18:06:30.029]                   name <- removed[[kk]]
[18:06:30.029]                   NAME <- NAMES[[kk]]
[18:06:30.029]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.029]                     next
[18:06:30.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.029]                 }
[18:06:30.029]                 if (length(args) > 0) 
[18:06:30.029]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.029]             }
[18:06:30.029]             else {
[18:06:30.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.029]             }
[18:06:30.029]             {
[18:06:30.029]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.029]                   0L) {
[18:06:30.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.029]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.029]                   base::options(opts)
[18:06:30.029]                 }
[18:06:30.029]                 {
[18:06:30.029]                   {
[18:06:30.029]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.029]                     NULL
[18:06:30.029]                   }
[18:06:30.029]                   options(future.plan = NULL)
[18:06:30.029]                   if (is.na(NA_character_)) 
[18:06:30.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.029]                     .init = FALSE)
[18:06:30.029]                 }
[18:06:30.029]             }
[18:06:30.029]         }
[18:06:30.029]     })
[18:06:30.029]     if (TRUE) {
[18:06:30.029]         base::sink(type = "output", split = FALSE)
[18:06:30.029]         if (TRUE) {
[18:06:30.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.029]         }
[18:06:30.029]         else {
[18:06:30.029]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.029]         }
[18:06:30.029]         base::close(...future.stdout)
[18:06:30.029]         ...future.stdout <- NULL
[18:06:30.029]     }
[18:06:30.029]     ...future.result$conditions <- ...future.conditions
[18:06:30.029]     ...future.result$finished <- base::Sys.time()
[18:06:30.029]     ...future.result
[18:06:30.029] }
[18:06:30.035] MultisessionFuture started
[18:06:30.035] - Launch lazy future ... done
[18:06:30.035] run() for ‘MultisessionFuture’ ... done
[18:06:30.036] getGlobalsAndPackages() ...
[18:06:30.036] Searching for globals...
[18:06:30.037] - globals found: [1] ‘{’
[18:06:30.037] Searching for globals ... DONE
[18:06:30.038] Resolving globals: FALSE
[18:06:30.038] 
[18:06:30.038] 
[18:06:30.038] getGlobalsAndPackages() ... DONE
[18:06:30.039] run() for ‘Future’ ...
[18:06:30.039] - state: ‘created’
[18:06:30.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.062] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.063]   - Field: ‘node’
[18:06:30.063]   - Field: ‘label’
[18:06:30.063]   - Field: ‘local’
[18:06:30.063]   - Field: ‘owner’
[18:06:30.064]   - Field: ‘envir’
[18:06:30.064]   - Field: ‘workers’
[18:06:30.064]   - Field: ‘packages’
[18:06:30.064]   - Field: ‘gc’
[18:06:30.064]   - Field: ‘conditions’
[18:06:30.065]   - Field: ‘persistent’
[18:06:30.065]   - Field: ‘expr’
[18:06:30.065]   - Field: ‘uuid’
[18:06:30.065]   - Field: ‘seed’
[18:06:30.065]   - Field: ‘version’
[18:06:30.066]   - Field: ‘result’
[18:06:30.066]   - Field: ‘asynchronous’
[18:06:30.066]   - Field: ‘calls’
[18:06:30.066]   - Field: ‘globals’
[18:06:30.066]   - Field: ‘stdout’
[18:06:30.067]   - Field: ‘earlySignal’
[18:06:30.067]   - Field: ‘lazy’
[18:06:30.067]   - Field: ‘state’
[18:06:30.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.067] - Launch lazy future ...
[18:06:30.068] Packages needed by the future expression (n = 0): <none>
[18:06:30.068] Packages needed by future strategies (n = 0): <none>
[18:06:30.069] {
[18:06:30.069]     {
[18:06:30.069]         {
[18:06:30.069]             ...future.startTime <- base::Sys.time()
[18:06:30.069]             {
[18:06:30.069]                 {
[18:06:30.069]                   {
[18:06:30.069]                     {
[18:06:30.069]                       base::local({
[18:06:30.069]                         has_future <- base::requireNamespace("future", 
[18:06:30.069]                           quietly = TRUE)
[18:06:30.069]                         if (has_future) {
[18:06:30.069]                           ns <- base::getNamespace("future")
[18:06:30.069]                           version <- ns[[".package"]][["version"]]
[18:06:30.069]                           if (is.null(version)) 
[18:06:30.069]                             version <- utils::packageVersion("future")
[18:06:30.069]                         }
[18:06:30.069]                         else {
[18:06:30.069]                           version <- NULL
[18:06:30.069]                         }
[18:06:30.069]                         if (!has_future || version < "1.8.0") {
[18:06:30.069]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.069]                             "", base::R.version$version.string), 
[18:06:30.069]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.069]                               "release", "version")], collapse = " "), 
[18:06:30.069]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.069]                             info)
[18:06:30.069]                           info <- base::paste(info, collapse = "; ")
[18:06:30.069]                           if (!has_future) {
[18:06:30.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.069]                               info)
[18:06:30.069]                           }
[18:06:30.069]                           else {
[18:06:30.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.069]                               info, version)
[18:06:30.069]                           }
[18:06:30.069]                           base::stop(msg)
[18:06:30.069]                         }
[18:06:30.069]                       })
[18:06:30.069]                     }
[18:06:30.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.069]                     base::options(mc.cores = 1L)
[18:06:30.069]                   }
[18:06:30.069]                   ...future.strategy.old <- future::plan("list")
[18:06:30.069]                   options(future.plan = NULL)
[18:06:30.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.069]                 }
[18:06:30.069]                 ...future.workdir <- getwd()
[18:06:30.069]             }
[18:06:30.069]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.069]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.069]         }
[18:06:30.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.069]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.069]             base::names(...future.oldOptions))
[18:06:30.069]     }
[18:06:30.069]     if (FALSE) {
[18:06:30.069]     }
[18:06:30.069]     else {
[18:06:30.069]         if (TRUE) {
[18:06:30.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.069]                 open = "w")
[18:06:30.069]         }
[18:06:30.069]         else {
[18:06:30.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.069]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.069]         }
[18:06:30.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.069]             base::sink(type = "output", split = FALSE)
[18:06:30.069]             base::close(...future.stdout)
[18:06:30.069]         }, add = TRUE)
[18:06:30.069]     }
[18:06:30.069]     ...future.frame <- base::sys.nframe()
[18:06:30.069]     ...future.conditions <- base::list()
[18:06:30.069]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.069]     if (FALSE) {
[18:06:30.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.069]     }
[18:06:30.069]     ...future.result <- base::tryCatch({
[18:06:30.069]         base::withCallingHandlers({
[18:06:30.069]             ...future.value <- base::withVisible(base::local({
[18:06:30.069]                 ...future.makeSendCondition <- base::local({
[18:06:30.069]                   sendCondition <- NULL
[18:06:30.069]                   function(frame = 1L) {
[18:06:30.069]                     if (is.function(sendCondition)) 
[18:06:30.069]                       return(sendCondition)
[18:06:30.069]                     ns <- getNamespace("parallel")
[18:06:30.069]                     if (exists("sendData", mode = "function", 
[18:06:30.069]                       envir = ns)) {
[18:06:30.069]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.069]                         envir = ns)
[18:06:30.069]                       envir <- sys.frame(frame)
[18:06:30.069]                       master <- NULL
[18:06:30.069]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.069]                         !identical(envir, emptyenv())) {
[18:06:30.069]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.069]                           inherits = FALSE)) {
[18:06:30.069]                           master <- get("master", mode = "list", 
[18:06:30.069]                             envir = envir, inherits = FALSE)
[18:06:30.069]                           if (inherits(master, c("SOCKnode", 
[18:06:30.069]                             "SOCK0node"))) {
[18:06:30.069]                             sendCondition <<- function(cond) {
[18:06:30.069]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.069]                                 success = TRUE)
[18:06:30.069]                               parallel_sendData(master, data)
[18:06:30.069]                             }
[18:06:30.069]                             return(sendCondition)
[18:06:30.069]                           }
[18:06:30.069]                         }
[18:06:30.069]                         frame <- frame + 1L
[18:06:30.069]                         envir <- sys.frame(frame)
[18:06:30.069]                       }
[18:06:30.069]                     }
[18:06:30.069]                     sendCondition <<- function(cond) NULL
[18:06:30.069]                   }
[18:06:30.069]                 })
[18:06:30.069]                 withCallingHandlers({
[18:06:30.069]                   {
[18:06:30.069]                     2
[18:06:30.069]                   }
[18:06:30.069]                 }, immediateCondition = function(cond) {
[18:06:30.069]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.069]                   sendCondition(cond)
[18:06:30.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.069]                   {
[18:06:30.069]                     inherits <- base::inherits
[18:06:30.069]                     invokeRestart <- base::invokeRestart
[18:06:30.069]                     is.null <- base::is.null
[18:06:30.069]                     muffled <- FALSE
[18:06:30.069]                     if (inherits(cond, "message")) {
[18:06:30.069]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.069]                       if (muffled) 
[18:06:30.069]                         invokeRestart("muffleMessage")
[18:06:30.069]                     }
[18:06:30.069]                     else if (inherits(cond, "warning")) {
[18:06:30.069]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.069]                       if (muffled) 
[18:06:30.069]                         invokeRestart("muffleWarning")
[18:06:30.069]                     }
[18:06:30.069]                     else if (inherits(cond, "condition")) {
[18:06:30.069]                       if (!is.null(pattern)) {
[18:06:30.069]                         computeRestarts <- base::computeRestarts
[18:06:30.069]                         grepl <- base::grepl
[18:06:30.069]                         restarts <- computeRestarts(cond)
[18:06:30.069]                         for (restart in restarts) {
[18:06:30.069]                           name <- restart$name
[18:06:30.069]                           if (is.null(name)) 
[18:06:30.069]                             next
[18:06:30.069]                           if (!grepl(pattern, name)) 
[18:06:30.069]                             next
[18:06:30.069]                           invokeRestart(restart)
[18:06:30.069]                           muffled <- TRUE
[18:06:30.069]                           break
[18:06:30.069]                         }
[18:06:30.069]                       }
[18:06:30.069]                     }
[18:06:30.069]                     invisible(muffled)
[18:06:30.069]                   }
[18:06:30.069]                   muffleCondition(cond)
[18:06:30.069]                 })
[18:06:30.069]             }))
[18:06:30.069]             future::FutureResult(value = ...future.value$value, 
[18:06:30.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.069]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.069]                     ...future.globalenv.names))
[18:06:30.069]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.069]         }, condition = base::local({
[18:06:30.069]             c <- base::c
[18:06:30.069]             inherits <- base::inherits
[18:06:30.069]             invokeRestart <- base::invokeRestart
[18:06:30.069]             length <- base::length
[18:06:30.069]             list <- base::list
[18:06:30.069]             seq.int <- base::seq.int
[18:06:30.069]             signalCondition <- base::signalCondition
[18:06:30.069]             sys.calls <- base::sys.calls
[18:06:30.069]             `[[` <- base::`[[`
[18:06:30.069]             `+` <- base::`+`
[18:06:30.069]             `<<-` <- base::`<<-`
[18:06:30.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.069]                   3L)]
[18:06:30.069]             }
[18:06:30.069]             function(cond) {
[18:06:30.069]                 is_error <- inherits(cond, "error")
[18:06:30.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.069]                   NULL)
[18:06:30.069]                 if (is_error) {
[18:06:30.069]                   sessionInformation <- function() {
[18:06:30.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.069]                       search = base::search(), system = base::Sys.info())
[18:06:30.069]                   }
[18:06:30.069]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.069]                     cond$call), session = sessionInformation(), 
[18:06:30.069]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.069]                   signalCondition(cond)
[18:06:30.069]                 }
[18:06:30.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.069]                 "immediateCondition"))) {
[18:06:30.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.069]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.069]                   if (TRUE && !signal) {
[18:06:30.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.069]                     {
[18:06:30.069]                       inherits <- base::inherits
[18:06:30.069]                       invokeRestart <- base::invokeRestart
[18:06:30.069]                       is.null <- base::is.null
[18:06:30.069]                       muffled <- FALSE
[18:06:30.069]                       if (inherits(cond, "message")) {
[18:06:30.069]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.069]                         if (muffled) 
[18:06:30.069]                           invokeRestart("muffleMessage")
[18:06:30.069]                       }
[18:06:30.069]                       else if (inherits(cond, "warning")) {
[18:06:30.069]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.069]                         if (muffled) 
[18:06:30.069]                           invokeRestart("muffleWarning")
[18:06:30.069]                       }
[18:06:30.069]                       else if (inherits(cond, "condition")) {
[18:06:30.069]                         if (!is.null(pattern)) {
[18:06:30.069]                           computeRestarts <- base::computeRestarts
[18:06:30.069]                           grepl <- base::grepl
[18:06:30.069]                           restarts <- computeRestarts(cond)
[18:06:30.069]                           for (restart in restarts) {
[18:06:30.069]                             name <- restart$name
[18:06:30.069]                             if (is.null(name)) 
[18:06:30.069]                               next
[18:06:30.069]                             if (!grepl(pattern, name)) 
[18:06:30.069]                               next
[18:06:30.069]                             invokeRestart(restart)
[18:06:30.069]                             muffled <- TRUE
[18:06:30.069]                             break
[18:06:30.069]                           }
[18:06:30.069]                         }
[18:06:30.069]                       }
[18:06:30.069]                       invisible(muffled)
[18:06:30.069]                     }
[18:06:30.069]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.069]                   }
[18:06:30.069]                 }
[18:06:30.069]                 else {
[18:06:30.069]                   if (TRUE) {
[18:06:30.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.069]                     {
[18:06:30.069]                       inherits <- base::inherits
[18:06:30.069]                       invokeRestart <- base::invokeRestart
[18:06:30.069]                       is.null <- base::is.null
[18:06:30.069]                       muffled <- FALSE
[18:06:30.069]                       if (inherits(cond, "message")) {
[18:06:30.069]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.069]                         if (muffled) 
[18:06:30.069]                           invokeRestart("muffleMessage")
[18:06:30.069]                       }
[18:06:30.069]                       else if (inherits(cond, "warning")) {
[18:06:30.069]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.069]                         if (muffled) 
[18:06:30.069]                           invokeRestart("muffleWarning")
[18:06:30.069]                       }
[18:06:30.069]                       else if (inherits(cond, "condition")) {
[18:06:30.069]                         if (!is.null(pattern)) {
[18:06:30.069]                           computeRestarts <- base::computeRestarts
[18:06:30.069]                           grepl <- base::grepl
[18:06:30.069]                           restarts <- computeRestarts(cond)
[18:06:30.069]                           for (restart in restarts) {
[18:06:30.069]                             name <- restart$name
[18:06:30.069]                             if (is.null(name)) 
[18:06:30.069]                               next
[18:06:30.069]                             if (!grepl(pattern, name)) 
[18:06:30.069]                               next
[18:06:30.069]                             invokeRestart(restart)
[18:06:30.069]                             muffled <- TRUE
[18:06:30.069]                             break
[18:06:30.069]                           }
[18:06:30.069]                         }
[18:06:30.069]                       }
[18:06:30.069]                       invisible(muffled)
[18:06:30.069]                     }
[18:06:30.069]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.069]                   }
[18:06:30.069]                 }
[18:06:30.069]             }
[18:06:30.069]         }))
[18:06:30.069]     }, error = function(ex) {
[18:06:30.069]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.069]                 ...future.rng), started = ...future.startTime, 
[18:06:30.069]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.069]             version = "1.8"), class = "FutureResult")
[18:06:30.069]     }, finally = {
[18:06:30.069]         if (!identical(...future.workdir, getwd())) 
[18:06:30.069]             setwd(...future.workdir)
[18:06:30.069]         {
[18:06:30.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.069]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.069]             }
[18:06:30.069]             base::options(...future.oldOptions)
[18:06:30.069]             if (.Platform$OS.type == "windows") {
[18:06:30.069]                 old_names <- names(...future.oldEnvVars)
[18:06:30.069]                 envs <- base::Sys.getenv()
[18:06:30.069]                 names <- names(envs)
[18:06:30.069]                 common <- intersect(names, old_names)
[18:06:30.069]                 added <- setdiff(names, old_names)
[18:06:30.069]                 removed <- setdiff(old_names, names)
[18:06:30.069]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.069]                   envs[common]]
[18:06:30.069]                 NAMES <- toupper(changed)
[18:06:30.069]                 args <- list()
[18:06:30.069]                 for (kk in seq_along(NAMES)) {
[18:06:30.069]                   name <- changed[[kk]]
[18:06:30.069]                   NAME <- NAMES[[kk]]
[18:06:30.069]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.069]                     next
[18:06:30.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.069]                 }
[18:06:30.069]                 NAMES <- toupper(added)
[18:06:30.069]                 for (kk in seq_along(NAMES)) {
[18:06:30.069]                   name <- added[[kk]]
[18:06:30.069]                   NAME <- NAMES[[kk]]
[18:06:30.069]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.069]                     next
[18:06:30.069]                   args[[name]] <- ""
[18:06:30.069]                 }
[18:06:30.069]                 NAMES <- toupper(removed)
[18:06:30.069]                 for (kk in seq_along(NAMES)) {
[18:06:30.069]                   name <- removed[[kk]]
[18:06:30.069]                   NAME <- NAMES[[kk]]
[18:06:30.069]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.069]                     next
[18:06:30.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.069]                 }
[18:06:30.069]                 if (length(args) > 0) 
[18:06:30.069]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.069]             }
[18:06:30.069]             else {
[18:06:30.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.069]             }
[18:06:30.069]             {
[18:06:30.069]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.069]                   0L) {
[18:06:30.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.069]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.069]                   base::options(opts)
[18:06:30.069]                 }
[18:06:30.069]                 {
[18:06:30.069]                   {
[18:06:30.069]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.069]                     NULL
[18:06:30.069]                   }
[18:06:30.069]                   options(future.plan = NULL)
[18:06:30.069]                   if (is.na(NA_character_)) 
[18:06:30.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.069]                     .init = FALSE)
[18:06:30.069]                 }
[18:06:30.069]             }
[18:06:30.069]         }
[18:06:30.069]     })
[18:06:30.069]     if (TRUE) {
[18:06:30.069]         base::sink(type = "output", split = FALSE)
[18:06:30.069]         if (TRUE) {
[18:06:30.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.069]         }
[18:06:30.069]         else {
[18:06:30.069]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.069]         }
[18:06:30.069]         base::close(...future.stdout)
[18:06:30.069]         ...future.stdout <- NULL
[18:06:30.069]     }
[18:06:30.069]     ...future.result$conditions <- ...future.conditions
[18:06:30.069]     ...future.result$finished <- base::Sys.time()
[18:06:30.069]     ...future.result
[18:06:30.069] }
[18:06:30.075] MultisessionFuture started
[18:06:30.075] - Launch lazy future ... done
[18:06:30.075] run() for ‘MultisessionFuture’ ... done
[18:06:30.076] resolve() on environment ...
[18:06:30.076]  recursive: 0
[18:06:30.077]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[18:06:30.078] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.079] - Validating connection of MultisessionFuture
[18:06:30.079] - received message: FutureResult
[18:06:30.079] - Received FutureResult
[18:06:30.080] - Erased future from FutureRegistry
[18:06:30.080] result() for ClusterFuture ...
[18:06:30.080] - result already collected: FutureResult
[18:06:30.080] result() for ClusterFuture ... done
[18:06:30.080] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.080] Future #1
[18:06:30.081]  length: 2 (resolved future 1)
[18:06:30.092]  length: 1 (resolved future 3)
[18:06:30.124] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.124] - Validating connection of MultisessionFuture
[18:06:30.125] - received message: FutureResult
[18:06:30.125] - Received FutureResult
[18:06:30.125] - Erased future from FutureRegistry
[18:06:30.126] result() for ClusterFuture ...
[18:06:30.126] - result already collected: FutureResult
[18:06:30.126] result() for ClusterFuture ... done
[18:06:30.126] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.126] Future #2
[18:06:30.127]  length: 0 (resolved future 2)
[18:06:30.127] resolve() on environment ... DONE
[18:06:30.128] getGlobalsAndPackages() ...
[18:06:30.128] Searching for globals...
[18:06:30.129] - globals found: [1] ‘{’
[18:06:30.130] Searching for globals ... DONE
[18:06:30.130] Resolving globals: FALSE
[18:06:30.131] 
[18:06:30.131] 
[18:06:30.131] getGlobalsAndPackages() ... DONE
[18:06:30.132] run() for ‘Future’ ...
[18:06:30.132] - state: ‘created’
[18:06:30.132] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.161]   - Field: ‘node’
[18:06:30.161]   - Field: ‘label’
[18:06:30.161]   - Field: ‘local’
[18:06:30.162]   - Field: ‘owner’
[18:06:30.162]   - Field: ‘envir’
[18:06:30.162]   - Field: ‘workers’
[18:06:30.162]   - Field: ‘packages’
[18:06:30.163]   - Field: ‘gc’
[18:06:30.163]   - Field: ‘conditions’
[18:06:30.163]   - Field: ‘persistent’
[18:06:30.163]   - Field: ‘expr’
[18:06:30.164]   - Field: ‘uuid’
[18:06:30.164]   - Field: ‘seed’
[18:06:30.164]   - Field: ‘version’
[18:06:30.164]   - Field: ‘result’
[18:06:30.164]   - Field: ‘asynchronous’
[18:06:30.165]   - Field: ‘calls’
[18:06:30.165]   - Field: ‘globals’
[18:06:30.165]   - Field: ‘stdout’
[18:06:30.165]   - Field: ‘earlySignal’
[18:06:30.166]   - Field: ‘lazy’
[18:06:30.166]   - Field: ‘state’
[18:06:30.166] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.166] - Launch lazy future ...
[18:06:30.167] Packages needed by the future expression (n = 0): <none>
[18:06:30.167] Packages needed by future strategies (n = 0): <none>
[18:06:30.168] {
[18:06:30.168]     {
[18:06:30.168]         {
[18:06:30.168]             ...future.startTime <- base::Sys.time()
[18:06:30.168]             {
[18:06:30.168]                 {
[18:06:30.168]                   {
[18:06:30.168]                     {
[18:06:30.168]                       base::local({
[18:06:30.168]                         has_future <- base::requireNamespace("future", 
[18:06:30.168]                           quietly = TRUE)
[18:06:30.168]                         if (has_future) {
[18:06:30.168]                           ns <- base::getNamespace("future")
[18:06:30.168]                           version <- ns[[".package"]][["version"]]
[18:06:30.168]                           if (is.null(version)) 
[18:06:30.168]                             version <- utils::packageVersion("future")
[18:06:30.168]                         }
[18:06:30.168]                         else {
[18:06:30.168]                           version <- NULL
[18:06:30.168]                         }
[18:06:30.168]                         if (!has_future || version < "1.8.0") {
[18:06:30.168]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.168]                             "", base::R.version$version.string), 
[18:06:30.168]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.168]                               "release", "version")], collapse = " "), 
[18:06:30.168]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.168]                             info)
[18:06:30.168]                           info <- base::paste(info, collapse = "; ")
[18:06:30.168]                           if (!has_future) {
[18:06:30.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.168]                               info)
[18:06:30.168]                           }
[18:06:30.168]                           else {
[18:06:30.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.168]                               info, version)
[18:06:30.168]                           }
[18:06:30.168]                           base::stop(msg)
[18:06:30.168]                         }
[18:06:30.168]                       })
[18:06:30.168]                     }
[18:06:30.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.168]                     base::options(mc.cores = 1L)
[18:06:30.168]                   }
[18:06:30.168]                   ...future.strategy.old <- future::plan("list")
[18:06:30.168]                   options(future.plan = NULL)
[18:06:30.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.168]                 }
[18:06:30.168]                 ...future.workdir <- getwd()
[18:06:30.168]             }
[18:06:30.168]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.168]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.168]         }
[18:06:30.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.168]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.168]             base::names(...future.oldOptions))
[18:06:30.168]     }
[18:06:30.168]     if (FALSE) {
[18:06:30.168]     }
[18:06:30.168]     else {
[18:06:30.168]         if (TRUE) {
[18:06:30.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.168]                 open = "w")
[18:06:30.168]         }
[18:06:30.168]         else {
[18:06:30.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.168]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.168]         }
[18:06:30.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.168]             base::sink(type = "output", split = FALSE)
[18:06:30.168]             base::close(...future.stdout)
[18:06:30.168]         }, add = TRUE)
[18:06:30.168]     }
[18:06:30.168]     ...future.frame <- base::sys.nframe()
[18:06:30.168]     ...future.conditions <- base::list()
[18:06:30.168]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.168]     if (FALSE) {
[18:06:30.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.168]     }
[18:06:30.168]     ...future.result <- base::tryCatch({
[18:06:30.168]         base::withCallingHandlers({
[18:06:30.168]             ...future.value <- base::withVisible(base::local({
[18:06:30.168]                 ...future.makeSendCondition <- base::local({
[18:06:30.168]                   sendCondition <- NULL
[18:06:30.168]                   function(frame = 1L) {
[18:06:30.168]                     if (is.function(sendCondition)) 
[18:06:30.168]                       return(sendCondition)
[18:06:30.168]                     ns <- getNamespace("parallel")
[18:06:30.168]                     if (exists("sendData", mode = "function", 
[18:06:30.168]                       envir = ns)) {
[18:06:30.168]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.168]                         envir = ns)
[18:06:30.168]                       envir <- sys.frame(frame)
[18:06:30.168]                       master <- NULL
[18:06:30.168]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.168]                         !identical(envir, emptyenv())) {
[18:06:30.168]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.168]                           inherits = FALSE)) {
[18:06:30.168]                           master <- get("master", mode = "list", 
[18:06:30.168]                             envir = envir, inherits = FALSE)
[18:06:30.168]                           if (inherits(master, c("SOCKnode", 
[18:06:30.168]                             "SOCK0node"))) {
[18:06:30.168]                             sendCondition <<- function(cond) {
[18:06:30.168]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.168]                                 success = TRUE)
[18:06:30.168]                               parallel_sendData(master, data)
[18:06:30.168]                             }
[18:06:30.168]                             return(sendCondition)
[18:06:30.168]                           }
[18:06:30.168]                         }
[18:06:30.168]                         frame <- frame + 1L
[18:06:30.168]                         envir <- sys.frame(frame)
[18:06:30.168]                       }
[18:06:30.168]                     }
[18:06:30.168]                     sendCondition <<- function(cond) NULL
[18:06:30.168]                   }
[18:06:30.168]                 })
[18:06:30.168]                 withCallingHandlers({
[18:06:30.168]                   {
[18:06:30.168]                     1
[18:06:30.168]                   }
[18:06:30.168]                 }, immediateCondition = function(cond) {
[18:06:30.168]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.168]                   sendCondition(cond)
[18:06:30.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.168]                   {
[18:06:30.168]                     inherits <- base::inherits
[18:06:30.168]                     invokeRestart <- base::invokeRestart
[18:06:30.168]                     is.null <- base::is.null
[18:06:30.168]                     muffled <- FALSE
[18:06:30.168]                     if (inherits(cond, "message")) {
[18:06:30.168]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.168]                       if (muffled) 
[18:06:30.168]                         invokeRestart("muffleMessage")
[18:06:30.168]                     }
[18:06:30.168]                     else if (inherits(cond, "warning")) {
[18:06:30.168]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.168]                       if (muffled) 
[18:06:30.168]                         invokeRestart("muffleWarning")
[18:06:30.168]                     }
[18:06:30.168]                     else if (inherits(cond, "condition")) {
[18:06:30.168]                       if (!is.null(pattern)) {
[18:06:30.168]                         computeRestarts <- base::computeRestarts
[18:06:30.168]                         grepl <- base::grepl
[18:06:30.168]                         restarts <- computeRestarts(cond)
[18:06:30.168]                         for (restart in restarts) {
[18:06:30.168]                           name <- restart$name
[18:06:30.168]                           if (is.null(name)) 
[18:06:30.168]                             next
[18:06:30.168]                           if (!grepl(pattern, name)) 
[18:06:30.168]                             next
[18:06:30.168]                           invokeRestart(restart)
[18:06:30.168]                           muffled <- TRUE
[18:06:30.168]                           break
[18:06:30.168]                         }
[18:06:30.168]                       }
[18:06:30.168]                     }
[18:06:30.168]                     invisible(muffled)
[18:06:30.168]                   }
[18:06:30.168]                   muffleCondition(cond)
[18:06:30.168]                 })
[18:06:30.168]             }))
[18:06:30.168]             future::FutureResult(value = ...future.value$value, 
[18:06:30.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.168]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.168]                     ...future.globalenv.names))
[18:06:30.168]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.168]         }, condition = base::local({
[18:06:30.168]             c <- base::c
[18:06:30.168]             inherits <- base::inherits
[18:06:30.168]             invokeRestart <- base::invokeRestart
[18:06:30.168]             length <- base::length
[18:06:30.168]             list <- base::list
[18:06:30.168]             seq.int <- base::seq.int
[18:06:30.168]             signalCondition <- base::signalCondition
[18:06:30.168]             sys.calls <- base::sys.calls
[18:06:30.168]             `[[` <- base::`[[`
[18:06:30.168]             `+` <- base::`+`
[18:06:30.168]             `<<-` <- base::`<<-`
[18:06:30.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.168]                   3L)]
[18:06:30.168]             }
[18:06:30.168]             function(cond) {
[18:06:30.168]                 is_error <- inherits(cond, "error")
[18:06:30.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.168]                   NULL)
[18:06:30.168]                 if (is_error) {
[18:06:30.168]                   sessionInformation <- function() {
[18:06:30.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.168]                       search = base::search(), system = base::Sys.info())
[18:06:30.168]                   }
[18:06:30.168]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.168]                     cond$call), session = sessionInformation(), 
[18:06:30.168]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.168]                   signalCondition(cond)
[18:06:30.168]                 }
[18:06:30.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.168]                 "immediateCondition"))) {
[18:06:30.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.168]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.168]                   if (TRUE && !signal) {
[18:06:30.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.168]                     {
[18:06:30.168]                       inherits <- base::inherits
[18:06:30.168]                       invokeRestart <- base::invokeRestart
[18:06:30.168]                       is.null <- base::is.null
[18:06:30.168]                       muffled <- FALSE
[18:06:30.168]                       if (inherits(cond, "message")) {
[18:06:30.168]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.168]                         if (muffled) 
[18:06:30.168]                           invokeRestart("muffleMessage")
[18:06:30.168]                       }
[18:06:30.168]                       else if (inherits(cond, "warning")) {
[18:06:30.168]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.168]                         if (muffled) 
[18:06:30.168]                           invokeRestart("muffleWarning")
[18:06:30.168]                       }
[18:06:30.168]                       else if (inherits(cond, "condition")) {
[18:06:30.168]                         if (!is.null(pattern)) {
[18:06:30.168]                           computeRestarts <- base::computeRestarts
[18:06:30.168]                           grepl <- base::grepl
[18:06:30.168]                           restarts <- computeRestarts(cond)
[18:06:30.168]                           for (restart in restarts) {
[18:06:30.168]                             name <- restart$name
[18:06:30.168]                             if (is.null(name)) 
[18:06:30.168]                               next
[18:06:30.168]                             if (!grepl(pattern, name)) 
[18:06:30.168]                               next
[18:06:30.168]                             invokeRestart(restart)
[18:06:30.168]                             muffled <- TRUE
[18:06:30.168]                             break
[18:06:30.168]                           }
[18:06:30.168]                         }
[18:06:30.168]                       }
[18:06:30.168]                       invisible(muffled)
[18:06:30.168]                     }
[18:06:30.168]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.168]                   }
[18:06:30.168]                 }
[18:06:30.168]                 else {
[18:06:30.168]                   if (TRUE) {
[18:06:30.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.168]                     {
[18:06:30.168]                       inherits <- base::inherits
[18:06:30.168]                       invokeRestart <- base::invokeRestart
[18:06:30.168]                       is.null <- base::is.null
[18:06:30.168]                       muffled <- FALSE
[18:06:30.168]                       if (inherits(cond, "message")) {
[18:06:30.168]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.168]                         if (muffled) 
[18:06:30.168]                           invokeRestart("muffleMessage")
[18:06:30.168]                       }
[18:06:30.168]                       else if (inherits(cond, "warning")) {
[18:06:30.168]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.168]                         if (muffled) 
[18:06:30.168]                           invokeRestart("muffleWarning")
[18:06:30.168]                       }
[18:06:30.168]                       else if (inherits(cond, "condition")) {
[18:06:30.168]                         if (!is.null(pattern)) {
[18:06:30.168]                           computeRestarts <- base::computeRestarts
[18:06:30.168]                           grepl <- base::grepl
[18:06:30.168]                           restarts <- computeRestarts(cond)
[18:06:30.168]                           for (restart in restarts) {
[18:06:30.168]                             name <- restart$name
[18:06:30.168]                             if (is.null(name)) 
[18:06:30.168]                               next
[18:06:30.168]                             if (!grepl(pattern, name)) 
[18:06:30.168]                               next
[18:06:30.168]                             invokeRestart(restart)
[18:06:30.168]                             muffled <- TRUE
[18:06:30.168]                             break
[18:06:30.168]                           }
[18:06:30.168]                         }
[18:06:30.168]                       }
[18:06:30.168]                       invisible(muffled)
[18:06:30.168]                     }
[18:06:30.168]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.168]                   }
[18:06:30.168]                 }
[18:06:30.168]             }
[18:06:30.168]         }))
[18:06:30.168]     }, error = function(ex) {
[18:06:30.168]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.168]                 ...future.rng), started = ...future.startTime, 
[18:06:30.168]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.168]             version = "1.8"), class = "FutureResult")
[18:06:30.168]     }, finally = {
[18:06:30.168]         if (!identical(...future.workdir, getwd())) 
[18:06:30.168]             setwd(...future.workdir)
[18:06:30.168]         {
[18:06:30.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.168]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.168]             }
[18:06:30.168]             base::options(...future.oldOptions)
[18:06:30.168]             if (.Platform$OS.type == "windows") {
[18:06:30.168]                 old_names <- names(...future.oldEnvVars)
[18:06:30.168]                 envs <- base::Sys.getenv()
[18:06:30.168]                 names <- names(envs)
[18:06:30.168]                 common <- intersect(names, old_names)
[18:06:30.168]                 added <- setdiff(names, old_names)
[18:06:30.168]                 removed <- setdiff(old_names, names)
[18:06:30.168]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.168]                   envs[common]]
[18:06:30.168]                 NAMES <- toupper(changed)
[18:06:30.168]                 args <- list()
[18:06:30.168]                 for (kk in seq_along(NAMES)) {
[18:06:30.168]                   name <- changed[[kk]]
[18:06:30.168]                   NAME <- NAMES[[kk]]
[18:06:30.168]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.168]                     next
[18:06:30.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.168]                 }
[18:06:30.168]                 NAMES <- toupper(added)
[18:06:30.168]                 for (kk in seq_along(NAMES)) {
[18:06:30.168]                   name <- added[[kk]]
[18:06:30.168]                   NAME <- NAMES[[kk]]
[18:06:30.168]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.168]                     next
[18:06:30.168]                   args[[name]] <- ""
[18:06:30.168]                 }
[18:06:30.168]                 NAMES <- toupper(removed)
[18:06:30.168]                 for (kk in seq_along(NAMES)) {
[18:06:30.168]                   name <- removed[[kk]]
[18:06:30.168]                   NAME <- NAMES[[kk]]
[18:06:30.168]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.168]                     next
[18:06:30.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.168]                 }
[18:06:30.168]                 if (length(args) > 0) 
[18:06:30.168]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.168]             }
[18:06:30.168]             else {
[18:06:30.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.168]             }
[18:06:30.168]             {
[18:06:30.168]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.168]                   0L) {
[18:06:30.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.168]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.168]                   base::options(opts)
[18:06:30.168]                 }
[18:06:30.168]                 {
[18:06:30.168]                   {
[18:06:30.168]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.168]                     NULL
[18:06:30.168]                   }
[18:06:30.168]                   options(future.plan = NULL)
[18:06:30.168]                   if (is.na(NA_character_)) 
[18:06:30.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.168]                     .init = FALSE)
[18:06:30.168]                 }
[18:06:30.168]             }
[18:06:30.168]         }
[18:06:30.168]     })
[18:06:30.168]     if (TRUE) {
[18:06:30.168]         base::sink(type = "output", split = FALSE)
[18:06:30.168]         if (TRUE) {
[18:06:30.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.168]         }
[18:06:30.168]         else {
[18:06:30.168]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.168]         }
[18:06:30.168]         base::close(...future.stdout)
[18:06:30.168]         ...future.stdout <- NULL
[18:06:30.168]     }
[18:06:30.168]     ...future.result$conditions <- ...future.conditions
[18:06:30.168]     ...future.result$finished <- base::Sys.time()
[18:06:30.168]     ...future.result
[18:06:30.168] }
[18:06:30.175] MultisessionFuture started
[18:06:30.175] - Launch lazy future ... done
[18:06:30.175] run() for ‘MultisessionFuture’ ... done
[18:06:30.177] getGlobalsAndPackages() ...
[18:06:30.177] Searching for globals...
[18:06:30.178] - globals found: [1] ‘{’
[18:06:30.178] Searching for globals ... DONE
[18:06:30.179] Resolving globals: FALSE
[18:06:30.179] 
[18:06:30.180] 
[18:06:30.180] getGlobalsAndPackages() ... DONE
[18:06:30.180] run() for ‘Future’ ...
[18:06:30.181] - state: ‘created’
[18:06:30.181] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.207]   - Field: ‘node’
[18:06:30.207]   - Field: ‘label’
[18:06:30.207]   - Field: ‘local’
[18:06:30.207]   - Field: ‘owner’
[18:06:30.208]   - Field: ‘envir’
[18:06:30.208]   - Field: ‘workers’
[18:06:30.208]   - Field: ‘packages’
[18:06:30.208]   - Field: ‘gc’
[18:06:30.208]   - Field: ‘conditions’
[18:06:30.209]   - Field: ‘persistent’
[18:06:30.209]   - Field: ‘expr’
[18:06:30.209]   - Field: ‘uuid’
[18:06:30.209]   - Field: ‘seed’
[18:06:30.209]   - Field: ‘version’
[18:06:30.210]   - Field: ‘result’
[18:06:30.210]   - Field: ‘asynchronous’
[18:06:30.210]   - Field: ‘calls’
[18:06:30.210]   - Field: ‘globals’
[18:06:30.210]   - Field: ‘stdout’
[18:06:30.211]   - Field: ‘earlySignal’
[18:06:30.211]   - Field: ‘lazy’
[18:06:30.211]   - Field: ‘state’
[18:06:30.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.212] - Launch lazy future ...
[18:06:30.212] Packages needed by the future expression (n = 0): <none>
[18:06:30.212] Packages needed by future strategies (n = 0): <none>
[18:06:30.213] {
[18:06:30.213]     {
[18:06:30.213]         {
[18:06:30.213]             ...future.startTime <- base::Sys.time()
[18:06:30.213]             {
[18:06:30.213]                 {
[18:06:30.213]                   {
[18:06:30.213]                     {
[18:06:30.213]                       base::local({
[18:06:30.213]                         has_future <- base::requireNamespace("future", 
[18:06:30.213]                           quietly = TRUE)
[18:06:30.213]                         if (has_future) {
[18:06:30.213]                           ns <- base::getNamespace("future")
[18:06:30.213]                           version <- ns[[".package"]][["version"]]
[18:06:30.213]                           if (is.null(version)) 
[18:06:30.213]                             version <- utils::packageVersion("future")
[18:06:30.213]                         }
[18:06:30.213]                         else {
[18:06:30.213]                           version <- NULL
[18:06:30.213]                         }
[18:06:30.213]                         if (!has_future || version < "1.8.0") {
[18:06:30.213]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.213]                             "", base::R.version$version.string), 
[18:06:30.213]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.213]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.213]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.213]                               "release", "version")], collapse = " "), 
[18:06:30.213]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.213]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.213]                             info)
[18:06:30.213]                           info <- base::paste(info, collapse = "; ")
[18:06:30.213]                           if (!has_future) {
[18:06:30.213]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.213]                               info)
[18:06:30.213]                           }
[18:06:30.213]                           else {
[18:06:30.213]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.213]                               info, version)
[18:06:30.213]                           }
[18:06:30.213]                           base::stop(msg)
[18:06:30.213]                         }
[18:06:30.213]                       })
[18:06:30.213]                     }
[18:06:30.213]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.213]                     base::options(mc.cores = 1L)
[18:06:30.213]                   }
[18:06:30.213]                   ...future.strategy.old <- future::plan("list")
[18:06:30.213]                   options(future.plan = NULL)
[18:06:30.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.213]                 }
[18:06:30.213]                 ...future.workdir <- getwd()
[18:06:30.213]             }
[18:06:30.213]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.213]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.213]         }
[18:06:30.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.213]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.213]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.213]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.213]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.213]             base::names(...future.oldOptions))
[18:06:30.213]     }
[18:06:30.213]     if (FALSE) {
[18:06:30.213]     }
[18:06:30.213]     else {
[18:06:30.213]         if (TRUE) {
[18:06:30.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.213]                 open = "w")
[18:06:30.213]         }
[18:06:30.213]         else {
[18:06:30.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.213]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.213]         }
[18:06:30.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.213]             base::sink(type = "output", split = FALSE)
[18:06:30.213]             base::close(...future.stdout)
[18:06:30.213]         }, add = TRUE)
[18:06:30.213]     }
[18:06:30.213]     ...future.frame <- base::sys.nframe()
[18:06:30.213]     ...future.conditions <- base::list()
[18:06:30.213]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.213]     if (FALSE) {
[18:06:30.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.213]     }
[18:06:30.213]     ...future.result <- base::tryCatch({
[18:06:30.213]         base::withCallingHandlers({
[18:06:30.213]             ...future.value <- base::withVisible(base::local({
[18:06:30.213]                 ...future.makeSendCondition <- base::local({
[18:06:30.213]                   sendCondition <- NULL
[18:06:30.213]                   function(frame = 1L) {
[18:06:30.213]                     if (is.function(sendCondition)) 
[18:06:30.213]                       return(sendCondition)
[18:06:30.213]                     ns <- getNamespace("parallel")
[18:06:30.213]                     if (exists("sendData", mode = "function", 
[18:06:30.213]                       envir = ns)) {
[18:06:30.213]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.213]                         envir = ns)
[18:06:30.213]                       envir <- sys.frame(frame)
[18:06:30.213]                       master <- NULL
[18:06:30.213]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.213]                         !identical(envir, emptyenv())) {
[18:06:30.213]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.213]                           inherits = FALSE)) {
[18:06:30.213]                           master <- get("master", mode = "list", 
[18:06:30.213]                             envir = envir, inherits = FALSE)
[18:06:30.213]                           if (inherits(master, c("SOCKnode", 
[18:06:30.213]                             "SOCK0node"))) {
[18:06:30.213]                             sendCondition <<- function(cond) {
[18:06:30.213]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.213]                                 success = TRUE)
[18:06:30.213]                               parallel_sendData(master, data)
[18:06:30.213]                             }
[18:06:30.213]                             return(sendCondition)
[18:06:30.213]                           }
[18:06:30.213]                         }
[18:06:30.213]                         frame <- frame + 1L
[18:06:30.213]                         envir <- sys.frame(frame)
[18:06:30.213]                       }
[18:06:30.213]                     }
[18:06:30.213]                     sendCondition <<- function(cond) NULL
[18:06:30.213]                   }
[18:06:30.213]                 })
[18:06:30.213]                 withCallingHandlers({
[18:06:30.213]                   {
[18:06:30.213]                     2
[18:06:30.213]                   }
[18:06:30.213]                 }, immediateCondition = function(cond) {
[18:06:30.213]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.213]                   sendCondition(cond)
[18:06:30.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.213]                   {
[18:06:30.213]                     inherits <- base::inherits
[18:06:30.213]                     invokeRestart <- base::invokeRestart
[18:06:30.213]                     is.null <- base::is.null
[18:06:30.213]                     muffled <- FALSE
[18:06:30.213]                     if (inherits(cond, "message")) {
[18:06:30.213]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.213]                       if (muffled) 
[18:06:30.213]                         invokeRestart("muffleMessage")
[18:06:30.213]                     }
[18:06:30.213]                     else if (inherits(cond, "warning")) {
[18:06:30.213]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.213]                       if (muffled) 
[18:06:30.213]                         invokeRestart("muffleWarning")
[18:06:30.213]                     }
[18:06:30.213]                     else if (inherits(cond, "condition")) {
[18:06:30.213]                       if (!is.null(pattern)) {
[18:06:30.213]                         computeRestarts <- base::computeRestarts
[18:06:30.213]                         grepl <- base::grepl
[18:06:30.213]                         restarts <- computeRestarts(cond)
[18:06:30.213]                         for (restart in restarts) {
[18:06:30.213]                           name <- restart$name
[18:06:30.213]                           if (is.null(name)) 
[18:06:30.213]                             next
[18:06:30.213]                           if (!grepl(pattern, name)) 
[18:06:30.213]                             next
[18:06:30.213]                           invokeRestart(restart)
[18:06:30.213]                           muffled <- TRUE
[18:06:30.213]                           break
[18:06:30.213]                         }
[18:06:30.213]                       }
[18:06:30.213]                     }
[18:06:30.213]                     invisible(muffled)
[18:06:30.213]                   }
[18:06:30.213]                   muffleCondition(cond)
[18:06:30.213]                 })
[18:06:30.213]             }))
[18:06:30.213]             future::FutureResult(value = ...future.value$value, 
[18:06:30.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.213]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.213]                     ...future.globalenv.names))
[18:06:30.213]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.213]         }, condition = base::local({
[18:06:30.213]             c <- base::c
[18:06:30.213]             inherits <- base::inherits
[18:06:30.213]             invokeRestart <- base::invokeRestart
[18:06:30.213]             length <- base::length
[18:06:30.213]             list <- base::list
[18:06:30.213]             seq.int <- base::seq.int
[18:06:30.213]             signalCondition <- base::signalCondition
[18:06:30.213]             sys.calls <- base::sys.calls
[18:06:30.213]             `[[` <- base::`[[`
[18:06:30.213]             `+` <- base::`+`
[18:06:30.213]             `<<-` <- base::`<<-`
[18:06:30.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.213]                   3L)]
[18:06:30.213]             }
[18:06:30.213]             function(cond) {
[18:06:30.213]                 is_error <- inherits(cond, "error")
[18:06:30.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.213]                   NULL)
[18:06:30.213]                 if (is_error) {
[18:06:30.213]                   sessionInformation <- function() {
[18:06:30.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.213]                       search = base::search(), system = base::Sys.info())
[18:06:30.213]                   }
[18:06:30.213]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.213]                     cond$call), session = sessionInformation(), 
[18:06:30.213]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.213]                   signalCondition(cond)
[18:06:30.213]                 }
[18:06:30.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.213]                 "immediateCondition"))) {
[18:06:30.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.213]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.213]                   if (TRUE && !signal) {
[18:06:30.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.213]                     {
[18:06:30.213]                       inherits <- base::inherits
[18:06:30.213]                       invokeRestart <- base::invokeRestart
[18:06:30.213]                       is.null <- base::is.null
[18:06:30.213]                       muffled <- FALSE
[18:06:30.213]                       if (inherits(cond, "message")) {
[18:06:30.213]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.213]                         if (muffled) 
[18:06:30.213]                           invokeRestart("muffleMessage")
[18:06:30.213]                       }
[18:06:30.213]                       else if (inherits(cond, "warning")) {
[18:06:30.213]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.213]                         if (muffled) 
[18:06:30.213]                           invokeRestart("muffleWarning")
[18:06:30.213]                       }
[18:06:30.213]                       else if (inherits(cond, "condition")) {
[18:06:30.213]                         if (!is.null(pattern)) {
[18:06:30.213]                           computeRestarts <- base::computeRestarts
[18:06:30.213]                           grepl <- base::grepl
[18:06:30.213]                           restarts <- computeRestarts(cond)
[18:06:30.213]                           for (restart in restarts) {
[18:06:30.213]                             name <- restart$name
[18:06:30.213]                             if (is.null(name)) 
[18:06:30.213]                               next
[18:06:30.213]                             if (!grepl(pattern, name)) 
[18:06:30.213]                               next
[18:06:30.213]                             invokeRestart(restart)
[18:06:30.213]                             muffled <- TRUE
[18:06:30.213]                             break
[18:06:30.213]                           }
[18:06:30.213]                         }
[18:06:30.213]                       }
[18:06:30.213]                       invisible(muffled)
[18:06:30.213]                     }
[18:06:30.213]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.213]                   }
[18:06:30.213]                 }
[18:06:30.213]                 else {
[18:06:30.213]                   if (TRUE) {
[18:06:30.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.213]                     {
[18:06:30.213]                       inherits <- base::inherits
[18:06:30.213]                       invokeRestart <- base::invokeRestart
[18:06:30.213]                       is.null <- base::is.null
[18:06:30.213]                       muffled <- FALSE
[18:06:30.213]                       if (inherits(cond, "message")) {
[18:06:30.213]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.213]                         if (muffled) 
[18:06:30.213]                           invokeRestart("muffleMessage")
[18:06:30.213]                       }
[18:06:30.213]                       else if (inherits(cond, "warning")) {
[18:06:30.213]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.213]                         if (muffled) 
[18:06:30.213]                           invokeRestart("muffleWarning")
[18:06:30.213]                       }
[18:06:30.213]                       else if (inherits(cond, "condition")) {
[18:06:30.213]                         if (!is.null(pattern)) {
[18:06:30.213]                           computeRestarts <- base::computeRestarts
[18:06:30.213]                           grepl <- base::grepl
[18:06:30.213]                           restarts <- computeRestarts(cond)
[18:06:30.213]                           for (restart in restarts) {
[18:06:30.213]                             name <- restart$name
[18:06:30.213]                             if (is.null(name)) 
[18:06:30.213]                               next
[18:06:30.213]                             if (!grepl(pattern, name)) 
[18:06:30.213]                               next
[18:06:30.213]                             invokeRestart(restart)
[18:06:30.213]                             muffled <- TRUE
[18:06:30.213]                             break
[18:06:30.213]                           }
[18:06:30.213]                         }
[18:06:30.213]                       }
[18:06:30.213]                       invisible(muffled)
[18:06:30.213]                     }
[18:06:30.213]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.213]                   }
[18:06:30.213]                 }
[18:06:30.213]             }
[18:06:30.213]         }))
[18:06:30.213]     }, error = function(ex) {
[18:06:30.213]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.213]                 ...future.rng), started = ...future.startTime, 
[18:06:30.213]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.213]             version = "1.8"), class = "FutureResult")
[18:06:30.213]     }, finally = {
[18:06:30.213]         if (!identical(...future.workdir, getwd())) 
[18:06:30.213]             setwd(...future.workdir)
[18:06:30.213]         {
[18:06:30.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.213]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.213]             }
[18:06:30.213]             base::options(...future.oldOptions)
[18:06:30.213]             if (.Platform$OS.type == "windows") {
[18:06:30.213]                 old_names <- names(...future.oldEnvVars)
[18:06:30.213]                 envs <- base::Sys.getenv()
[18:06:30.213]                 names <- names(envs)
[18:06:30.213]                 common <- intersect(names, old_names)
[18:06:30.213]                 added <- setdiff(names, old_names)
[18:06:30.213]                 removed <- setdiff(old_names, names)
[18:06:30.213]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.213]                   envs[common]]
[18:06:30.213]                 NAMES <- toupper(changed)
[18:06:30.213]                 args <- list()
[18:06:30.213]                 for (kk in seq_along(NAMES)) {
[18:06:30.213]                   name <- changed[[kk]]
[18:06:30.213]                   NAME <- NAMES[[kk]]
[18:06:30.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.213]                     next
[18:06:30.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.213]                 }
[18:06:30.213]                 NAMES <- toupper(added)
[18:06:30.213]                 for (kk in seq_along(NAMES)) {
[18:06:30.213]                   name <- added[[kk]]
[18:06:30.213]                   NAME <- NAMES[[kk]]
[18:06:30.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.213]                     next
[18:06:30.213]                   args[[name]] <- ""
[18:06:30.213]                 }
[18:06:30.213]                 NAMES <- toupper(removed)
[18:06:30.213]                 for (kk in seq_along(NAMES)) {
[18:06:30.213]                   name <- removed[[kk]]
[18:06:30.213]                   NAME <- NAMES[[kk]]
[18:06:30.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.213]                     next
[18:06:30.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.213]                 }
[18:06:30.213]                 if (length(args) > 0) 
[18:06:30.213]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.213]             }
[18:06:30.213]             else {
[18:06:30.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.213]             }
[18:06:30.213]             {
[18:06:30.213]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.213]                   0L) {
[18:06:30.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.213]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.213]                   base::options(opts)
[18:06:30.213]                 }
[18:06:30.213]                 {
[18:06:30.213]                   {
[18:06:30.213]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.213]                     NULL
[18:06:30.213]                   }
[18:06:30.213]                   options(future.plan = NULL)
[18:06:30.213]                   if (is.na(NA_character_)) 
[18:06:30.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.213]                     .init = FALSE)
[18:06:30.213]                 }
[18:06:30.213]             }
[18:06:30.213]         }
[18:06:30.213]     })
[18:06:30.213]     if (TRUE) {
[18:06:30.213]         base::sink(type = "output", split = FALSE)
[18:06:30.213]         if (TRUE) {
[18:06:30.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.213]         }
[18:06:30.213]         else {
[18:06:30.213]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.213]         }
[18:06:30.213]         base::close(...future.stdout)
[18:06:30.213]         ...future.stdout <- NULL
[18:06:30.213]     }
[18:06:30.213]     ...future.result$conditions <- ...future.conditions
[18:06:30.213]     ...future.result$finished <- base::Sys.time()
[18:06:30.213]     ...future.result
[18:06:30.213] }
[18:06:30.222] MultisessionFuture started
[18:06:30.222] - Launch lazy future ... done
[18:06:30.223] run() for ‘MultisessionFuture’ ... done
[18:06:30.225] resolve() on environment ...
[18:06:30.225]  recursive: 0
[18:06:30.226]  elements: [3] ‘a’
[18:06:30.227] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.227] - Validating connection of MultisessionFuture
[18:06:30.228] - received message: FutureResult
[18:06:30.228] - Received FutureResult
[18:06:30.228] - Erased future from FutureRegistry
[18:06:30.228] result() for ClusterFuture ...
[18:06:30.229] - result already collected: FutureResult
[18:06:30.229] result() for ClusterFuture ... done
[18:06:30.229] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.229] Future #1
[18:06:30.229]  length: 2 (resolved future 1)
[18:06:30.240]  length: 1 (resolved future 3)
[18:06:30.273] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.273] - Validating connection of MultisessionFuture
[18:06:30.273] - received message: FutureResult
[18:06:30.274] - Received FutureResult
[18:06:30.274] - Erased future from FutureRegistry
[18:06:30.274] result() for ClusterFuture ...
[18:06:30.274] - result already collected: FutureResult
[18:06:30.274] result() for ClusterFuture ... done
[18:06:30.275] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.275] Future #2
[18:06:30.275]  length: 0 (resolved future 2)
[18:06:30.275] resolve() on environment ... DONE
[18:06:30.276] resolve() on environment ...
[18:06:30.276]  recursive: 0
[18:06:30.277]  elements: [3] ‘b’
[18:06:30.278] Future #1
[18:06:30.278]  length: 2 (resolved future 1)
[18:06:30.278] Future #2
[18:06:30.278]  length: 1 (resolved future 2)
[18:06:30.279]  length: 0 (resolved future 3)
[18:06:30.279] resolve() on environment ... DONE
[18:06:30.280] resolve() on environment ...
[18:06:30.280]  recursive: 0
[18:06:30.281]  elements: [3] ‘c’
[18:06:30.281] Future #1
[18:06:30.281]  length: 2 (resolved future 1)
[18:06:30.282] Future #2
[18:06:30.282]  length: 1 (resolved future 2)
[18:06:30.282]  length: 0 (resolved future 3)
[18:06:30.282] resolve() on environment ... DONE
[18:06:30.283] resolve() on environment ...
[18:06:30.283]  recursive: 0
[18:06:30.284]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[18:06:30.285] Future #1
[18:06:30.285] result() for ClusterFuture ...
[18:06:30.285] - result already collected: FutureResult
[18:06:30.285] result() for ClusterFuture ... done
[18:06:30.285] result() for ClusterFuture ...
[18:06:30.286] - result already collected: FutureResult
[18:06:30.286] result() for ClusterFuture ... done
[18:06:30.286]  length: 2 (resolved future 1)
[18:06:30.286] Future #2
[18:06:30.286] result() for ClusterFuture ...
[18:06:30.287] - result already collected: FutureResult
[18:06:30.287] result() for ClusterFuture ... done
[18:06:30.287] result() for ClusterFuture ...
[18:06:30.287] - result already collected: FutureResult
[18:06:30.287] result() for ClusterFuture ... done
[18:06:30.288]  length: 1 (resolved future 2)
[18:06:30.288]  length: 0 (resolved future 3)
[18:06:30.288] resolve() on environment ... DONE
[18:06:30.289] resolve() on environment ...
[18:06:30.290]  recursive: 99
[18:06:30.291]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[18:06:30.291] Future #1
[18:06:30.291] result() for ClusterFuture ...
[18:06:30.291] - result already collected: FutureResult
[18:06:30.291] result() for ClusterFuture ... done
[18:06:30.292] result() for ClusterFuture ...
[18:06:30.292] - result already collected: FutureResult
[18:06:30.292] result() for ClusterFuture ... done
[18:06:30.292] A MultisessionFuture was resolved
[18:06:30.292]  length: 2 (resolved future 1)
[18:06:30.293] Future #2
[18:06:30.293] result() for ClusterFuture ...
[18:06:30.293] - result already collected: FutureResult
[18:06:30.293] result() for ClusterFuture ... done
[18:06:30.293] result() for ClusterFuture ...
[18:06:30.294] - result already collected: FutureResult
[18:06:30.294] result() for ClusterFuture ... done
[18:06:30.294] A MultisessionFuture was resolved
[18:06:30.294]  length: 1 (resolved future 2)
[18:06:30.294]  length: 0 (resolved future 3)
[18:06:30.295] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[18:06:30.296] resolve() on list environment ...
[18:06:30.296]  recursive: 0
[18:06:30.297]  length: 2
[18:06:30.297]  elements: ‘a’, ‘b’
[18:06:30.298]  length: 1 (resolved future 1)
[18:06:30.298]  length: 0 (resolved future 2)
[18:06:30.298] resolve() on list environment ... DONE
[18:06:30.298] getGlobalsAndPackages() ...
[18:06:30.299] Searching for globals...
[18:06:30.299] 
[18:06:30.299] Searching for globals ... DONE
[18:06:30.300] - globals: [0] <none>
[18:06:30.300] getGlobalsAndPackages() ... DONE
[18:06:30.300] run() for ‘Future’ ...
[18:06:30.300] - state: ‘created’
[18:06:30.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.326]   - Field: ‘node’
[18:06:30.326]   - Field: ‘label’
[18:06:30.326]   - Field: ‘local’
[18:06:30.326]   - Field: ‘owner’
[18:06:30.327]   - Field: ‘envir’
[18:06:30.327]   - Field: ‘workers’
[18:06:30.327]   - Field: ‘packages’
[18:06:30.327]   - Field: ‘gc’
[18:06:30.327]   - Field: ‘conditions’
[18:06:30.328]   - Field: ‘persistent’
[18:06:30.328]   - Field: ‘expr’
[18:06:30.328]   - Field: ‘uuid’
[18:06:30.328]   - Field: ‘seed’
[18:06:30.328]   - Field: ‘version’
[18:06:30.329]   - Field: ‘result’
[18:06:30.329]   - Field: ‘asynchronous’
[18:06:30.329]   - Field: ‘calls’
[18:06:30.329]   - Field: ‘globals’
[18:06:30.329]   - Field: ‘stdout’
[18:06:30.330]   - Field: ‘earlySignal’
[18:06:30.330]   - Field: ‘lazy’
[18:06:30.330]   - Field: ‘state’
[18:06:30.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.330] - Launch lazy future ...
[18:06:30.331] Packages needed by the future expression (n = 0): <none>
[18:06:30.331] Packages needed by future strategies (n = 0): <none>
[18:06:30.335] {
[18:06:30.335]     {
[18:06:30.335]         {
[18:06:30.335]             ...future.startTime <- base::Sys.time()
[18:06:30.335]             {
[18:06:30.335]                 {
[18:06:30.335]                   {
[18:06:30.335]                     {
[18:06:30.335]                       base::local({
[18:06:30.335]                         has_future <- base::requireNamespace("future", 
[18:06:30.335]                           quietly = TRUE)
[18:06:30.335]                         if (has_future) {
[18:06:30.335]                           ns <- base::getNamespace("future")
[18:06:30.335]                           version <- ns[[".package"]][["version"]]
[18:06:30.335]                           if (is.null(version)) 
[18:06:30.335]                             version <- utils::packageVersion("future")
[18:06:30.335]                         }
[18:06:30.335]                         else {
[18:06:30.335]                           version <- NULL
[18:06:30.335]                         }
[18:06:30.335]                         if (!has_future || version < "1.8.0") {
[18:06:30.335]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.335]                             "", base::R.version$version.string), 
[18:06:30.335]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.335]                               "release", "version")], collapse = " "), 
[18:06:30.335]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.335]                             info)
[18:06:30.335]                           info <- base::paste(info, collapse = "; ")
[18:06:30.335]                           if (!has_future) {
[18:06:30.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.335]                               info)
[18:06:30.335]                           }
[18:06:30.335]                           else {
[18:06:30.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.335]                               info, version)
[18:06:30.335]                           }
[18:06:30.335]                           base::stop(msg)
[18:06:30.335]                         }
[18:06:30.335]                       })
[18:06:30.335]                     }
[18:06:30.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.335]                     base::options(mc.cores = 1L)
[18:06:30.335]                   }
[18:06:30.335]                   ...future.strategy.old <- future::plan("list")
[18:06:30.335]                   options(future.plan = NULL)
[18:06:30.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.335]                 }
[18:06:30.335]                 ...future.workdir <- getwd()
[18:06:30.335]             }
[18:06:30.335]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.335]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.335]         }
[18:06:30.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.335]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.335]             base::names(...future.oldOptions))
[18:06:30.335]     }
[18:06:30.335]     if (FALSE) {
[18:06:30.335]     }
[18:06:30.335]     else {
[18:06:30.335]         if (TRUE) {
[18:06:30.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.335]                 open = "w")
[18:06:30.335]         }
[18:06:30.335]         else {
[18:06:30.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.335]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.335]         }
[18:06:30.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.335]             base::sink(type = "output", split = FALSE)
[18:06:30.335]             base::close(...future.stdout)
[18:06:30.335]         }, add = TRUE)
[18:06:30.335]     }
[18:06:30.335]     ...future.frame <- base::sys.nframe()
[18:06:30.335]     ...future.conditions <- base::list()
[18:06:30.335]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.335]     if (FALSE) {
[18:06:30.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.335]     }
[18:06:30.335]     ...future.result <- base::tryCatch({
[18:06:30.335]         base::withCallingHandlers({
[18:06:30.335]             ...future.value <- base::withVisible(base::local({
[18:06:30.335]                 ...future.makeSendCondition <- base::local({
[18:06:30.335]                   sendCondition <- NULL
[18:06:30.335]                   function(frame = 1L) {
[18:06:30.335]                     if (is.function(sendCondition)) 
[18:06:30.335]                       return(sendCondition)
[18:06:30.335]                     ns <- getNamespace("parallel")
[18:06:30.335]                     if (exists("sendData", mode = "function", 
[18:06:30.335]                       envir = ns)) {
[18:06:30.335]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.335]                         envir = ns)
[18:06:30.335]                       envir <- sys.frame(frame)
[18:06:30.335]                       master <- NULL
[18:06:30.335]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.335]                         !identical(envir, emptyenv())) {
[18:06:30.335]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.335]                           inherits = FALSE)) {
[18:06:30.335]                           master <- get("master", mode = "list", 
[18:06:30.335]                             envir = envir, inherits = FALSE)
[18:06:30.335]                           if (inherits(master, c("SOCKnode", 
[18:06:30.335]                             "SOCK0node"))) {
[18:06:30.335]                             sendCondition <<- function(cond) {
[18:06:30.335]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.335]                                 success = TRUE)
[18:06:30.335]                               parallel_sendData(master, data)
[18:06:30.335]                             }
[18:06:30.335]                             return(sendCondition)
[18:06:30.335]                           }
[18:06:30.335]                         }
[18:06:30.335]                         frame <- frame + 1L
[18:06:30.335]                         envir <- sys.frame(frame)
[18:06:30.335]                       }
[18:06:30.335]                     }
[18:06:30.335]                     sendCondition <<- function(cond) NULL
[18:06:30.335]                   }
[18:06:30.335]                 })
[18:06:30.335]                 withCallingHandlers({
[18:06:30.335]                   1
[18:06:30.335]                 }, immediateCondition = function(cond) {
[18:06:30.335]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.335]                   sendCondition(cond)
[18:06:30.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.335]                   {
[18:06:30.335]                     inherits <- base::inherits
[18:06:30.335]                     invokeRestart <- base::invokeRestart
[18:06:30.335]                     is.null <- base::is.null
[18:06:30.335]                     muffled <- FALSE
[18:06:30.335]                     if (inherits(cond, "message")) {
[18:06:30.335]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.335]                       if (muffled) 
[18:06:30.335]                         invokeRestart("muffleMessage")
[18:06:30.335]                     }
[18:06:30.335]                     else if (inherits(cond, "warning")) {
[18:06:30.335]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.335]                       if (muffled) 
[18:06:30.335]                         invokeRestart("muffleWarning")
[18:06:30.335]                     }
[18:06:30.335]                     else if (inherits(cond, "condition")) {
[18:06:30.335]                       if (!is.null(pattern)) {
[18:06:30.335]                         computeRestarts <- base::computeRestarts
[18:06:30.335]                         grepl <- base::grepl
[18:06:30.335]                         restarts <- computeRestarts(cond)
[18:06:30.335]                         for (restart in restarts) {
[18:06:30.335]                           name <- restart$name
[18:06:30.335]                           if (is.null(name)) 
[18:06:30.335]                             next
[18:06:30.335]                           if (!grepl(pattern, name)) 
[18:06:30.335]                             next
[18:06:30.335]                           invokeRestart(restart)
[18:06:30.335]                           muffled <- TRUE
[18:06:30.335]                           break
[18:06:30.335]                         }
[18:06:30.335]                       }
[18:06:30.335]                     }
[18:06:30.335]                     invisible(muffled)
[18:06:30.335]                   }
[18:06:30.335]                   muffleCondition(cond)
[18:06:30.335]                 })
[18:06:30.335]             }))
[18:06:30.335]             future::FutureResult(value = ...future.value$value, 
[18:06:30.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.335]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.335]                     ...future.globalenv.names))
[18:06:30.335]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.335]         }, condition = base::local({
[18:06:30.335]             c <- base::c
[18:06:30.335]             inherits <- base::inherits
[18:06:30.335]             invokeRestart <- base::invokeRestart
[18:06:30.335]             length <- base::length
[18:06:30.335]             list <- base::list
[18:06:30.335]             seq.int <- base::seq.int
[18:06:30.335]             signalCondition <- base::signalCondition
[18:06:30.335]             sys.calls <- base::sys.calls
[18:06:30.335]             `[[` <- base::`[[`
[18:06:30.335]             `+` <- base::`+`
[18:06:30.335]             `<<-` <- base::`<<-`
[18:06:30.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.335]                   3L)]
[18:06:30.335]             }
[18:06:30.335]             function(cond) {
[18:06:30.335]                 is_error <- inherits(cond, "error")
[18:06:30.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.335]                   NULL)
[18:06:30.335]                 if (is_error) {
[18:06:30.335]                   sessionInformation <- function() {
[18:06:30.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.335]                       search = base::search(), system = base::Sys.info())
[18:06:30.335]                   }
[18:06:30.335]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.335]                     cond$call), session = sessionInformation(), 
[18:06:30.335]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.335]                   signalCondition(cond)
[18:06:30.335]                 }
[18:06:30.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.335]                 "immediateCondition"))) {
[18:06:30.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.335]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.335]                   if (TRUE && !signal) {
[18:06:30.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.335]                     {
[18:06:30.335]                       inherits <- base::inherits
[18:06:30.335]                       invokeRestart <- base::invokeRestart
[18:06:30.335]                       is.null <- base::is.null
[18:06:30.335]                       muffled <- FALSE
[18:06:30.335]                       if (inherits(cond, "message")) {
[18:06:30.335]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.335]                         if (muffled) 
[18:06:30.335]                           invokeRestart("muffleMessage")
[18:06:30.335]                       }
[18:06:30.335]                       else if (inherits(cond, "warning")) {
[18:06:30.335]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.335]                         if (muffled) 
[18:06:30.335]                           invokeRestart("muffleWarning")
[18:06:30.335]                       }
[18:06:30.335]                       else if (inherits(cond, "condition")) {
[18:06:30.335]                         if (!is.null(pattern)) {
[18:06:30.335]                           computeRestarts <- base::computeRestarts
[18:06:30.335]                           grepl <- base::grepl
[18:06:30.335]                           restarts <- computeRestarts(cond)
[18:06:30.335]                           for (restart in restarts) {
[18:06:30.335]                             name <- restart$name
[18:06:30.335]                             if (is.null(name)) 
[18:06:30.335]                               next
[18:06:30.335]                             if (!grepl(pattern, name)) 
[18:06:30.335]                               next
[18:06:30.335]                             invokeRestart(restart)
[18:06:30.335]                             muffled <- TRUE
[18:06:30.335]                             break
[18:06:30.335]                           }
[18:06:30.335]                         }
[18:06:30.335]                       }
[18:06:30.335]                       invisible(muffled)
[18:06:30.335]                     }
[18:06:30.335]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.335]                   }
[18:06:30.335]                 }
[18:06:30.335]                 else {
[18:06:30.335]                   if (TRUE) {
[18:06:30.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.335]                     {
[18:06:30.335]                       inherits <- base::inherits
[18:06:30.335]                       invokeRestart <- base::invokeRestart
[18:06:30.335]                       is.null <- base::is.null
[18:06:30.335]                       muffled <- FALSE
[18:06:30.335]                       if (inherits(cond, "message")) {
[18:06:30.335]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.335]                         if (muffled) 
[18:06:30.335]                           invokeRestart("muffleMessage")
[18:06:30.335]                       }
[18:06:30.335]                       else if (inherits(cond, "warning")) {
[18:06:30.335]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.335]                         if (muffled) 
[18:06:30.335]                           invokeRestart("muffleWarning")
[18:06:30.335]                       }
[18:06:30.335]                       else if (inherits(cond, "condition")) {
[18:06:30.335]                         if (!is.null(pattern)) {
[18:06:30.335]                           computeRestarts <- base::computeRestarts
[18:06:30.335]                           grepl <- base::grepl
[18:06:30.335]                           restarts <- computeRestarts(cond)
[18:06:30.335]                           for (restart in restarts) {
[18:06:30.335]                             name <- restart$name
[18:06:30.335]                             if (is.null(name)) 
[18:06:30.335]                               next
[18:06:30.335]                             if (!grepl(pattern, name)) 
[18:06:30.335]                               next
[18:06:30.335]                             invokeRestart(restart)
[18:06:30.335]                             muffled <- TRUE
[18:06:30.335]                             break
[18:06:30.335]                           }
[18:06:30.335]                         }
[18:06:30.335]                       }
[18:06:30.335]                       invisible(muffled)
[18:06:30.335]                     }
[18:06:30.335]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.335]                   }
[18:06:30.335]                 }
[18:06:30.335]             }
[18:06:30.335]         }))
[18:06:30.335]     }, error = function(ex) {
[18:06:30.335]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.335]                 ...future.rng), started = ...future.startTime, 
[18:06:30.335]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.335]             version = "1.8"), class = "FutureResult")
[18:06:30.335]     }, finally = {
[18:06:30.335]         if (!identical(...future.workdir, getwd())) 
[18:06:30.335]             setwd(...future.workdir)
[18:06:30.335]         {
[18:06:30.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.335]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.335]             }
[18:06:30.335]             base::options(...future.oldOptions)
[18:06:30.335]             if (.Platform$OS.type == "windows") {
[18:06:30.335]                 old_names <- names(...future.oldEnvVars)
[18:06:30.335]                 envs <- base::Sys.getenv()
[18:06:30.335]                 names <- names(envs)
[18:06:30.335]                 common <- intersect(names, old_names)
[18:06:30.335]                 added <- setdiff(names, old_names)
[18:06:30.335]                 removed <- setdiff(old_names, names)
[18:06:30.335]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.335]                   envs[common]]
[18:06:30.335]                 NAMES <- toupper(changed)
[18:06:30.335]                 args <- list()
[18:06:30.335]                 for (kk in seq_along(NAMES)) {
[18:06:30.335]                   name <- changed[[kk]]
[18:06:30.335]                   NAME <- NAMES[[kk]]
[18:06:30.335]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.335]                     next
[18:06:30.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.335]                 }
[18:06:30.335]                 NAMES <- toupper(added)
[18:06:30.335]                 for (kk in seq_along(NAMES)) {
[18:06:30.335]                   name <- added[[kk]]
[18:06:30.335]                   NAME <- NAMES[[kk]]
[18:06:30.335]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.335]                     next
[18:06:30.335]                   args[[name]] <- ""
[18:06:30.335]                 }
[18:06:30.335]                 NAMES <- toupper(removed)
[18:06:30.335]                 for (kk in seq_along(NAMES)) {
[18:06:30.335]                   name <- removed[[kk]]
[18:06:30.335]                   NAME <- NAMES[[kk]]
[18:06:30.335]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.335]                     next
[18:06:30.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.335]                 }
[18:06:30.335]                 if (length(args) > 0) 
[18:06:30.335]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.335]             }
[18:06:30.335]             else {
[18:06:30.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.335]             }
[18:06:30.335]             {
[18:06:30.335]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.335]                   0L) {
[18:06:30.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.335]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.335]                   base::options(opts)
[18:06:30.335]                 }
[18:06:30.335]                 {
[18:06:30.335]                   {
[18:06:30.335]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.335]                     NULL
[18:06:30.335]                   }
[18:06:30.335]                   options(future.plan = NULL)
[18:06:30.335]                   if (is.na(NA_character_)) 
[18:06:30.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.335]                     .init = FALSE)
[18:06:30.335]                 }
[18:06:30.335]             }
[18:06:30.335]         }
[18:06:30.335]     })
[18:06:30.335]     if (TRUE) {
[18:06:30.335]         base::sink(type = "output", split = FALSE)
[18:06:30.335]         if (TRUE) {
[18:06:30.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.335]         }
[18:06:30.335]         else {
[18:06:30.335]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.335]         }
[18:06:30.335]         base::close(...future.stdout)
[18:06:30.335]         ...future.stdout <- NULL
[18:06:30.335]     }
[18:06:30.335]     ...future.result$conditions <- ...future.conditions
[18:06:30.335]     ...future.result$finished <- base::Sys.time()
[18:06:30.335]     ...future.result
[18:06:30.335] }
[18:06:30.342] MultisessionFuture started
[18:06:30.342] - Launch lazy future ... done
[18:06:30.343] run() for ‘MultisessionFuture’ ... done
[18:06:30.343] getGlobalsAndPackages() ...
[18:06:30.343] Searching for globals...
[18:06:30.344] 
[18:06:30.344] Searching for globals ... DONE
[18:06:30.345] - globals: [0] <none>
[18:06:30.345] getGlobalsAndPackages() ... DONE
[18:06:30.345] run() for ‘Future’ ...
[18:06:30.345] - state: ‘created’
[18:06:30.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.369] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.370]   - Field: ‘node’
[18:06:30.370]   - Field: ‘label’
[18:06:30.370]   - Field: ‘local’
[18:06:30.370]   - Field: ‘owner’
[18:06:30.371]   - Field: ‘envir’
[18:06:30.371]   - Field: ‘workers’
[18:06:30.371]   - Field: ‘packages’
[18:06:30.371]   - Field: ‘gc’
[18:06:30.371]   - Field: ‘conditions’
[18:06:30.372]   - Field: ‘persistent’
[18:06:30.372]   - Field: ‘expr’
[18:06:30.372]   - Field: ‘uuid’
[18:06:30.372]   - Field: ‘seed’
[18:06:30.372]   - Field: ‘version’
[18:06:30.373]   - Field: ‘result’
[18:06:30.373]   - Field: ‘asynchronous’
[18:06:30.373]   - Field: ‘calls’
[18:06:30.373]   - Field: ‘globals’
[18:06:30.373]   - Field: ‘stdout’
[18:06:30.374]   - Field: ‘earlySignal’
[18:06:30.374]   - Field: ‘lazy’
[18:06:30.374]   - Field: ‘state’
[18:06:30.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.374] - Launch lazy future ...
[18:06:30.375] Packages needed by the future expression (n = 0): <none>
[18:06:30.375] Packages needed by future strategies (n = 0): <none>
[18:06:30.376] {
[18:06:30.376]     {
[18:06:30.376]         {
[18:06:30.376]             ...future.startTime <- base::Sys.time()
[18:06:30.376]             {
[18:06:30.376]                 {
[18:06:30.376]                   {
[18:06:30.376]                     {
[18:06:30.376]                       base::local({
[18:06:30.376]                         has_future <- base::requireNamespace("future", 
[18:06:30.376]                           quietly = TRUE)
[18:06:30.376]                         if (has_future) {
[18:06:30.376]                           ns <- base::getNamespace("future")
[18:06:30.376]                           version <- ns[[".package"]][["version"]]
[18:06:30.376]                           if (is.null(version)) 
[18:06:30.376]                             version <- utils::packageVersion("future")
[18:06:30.376]                         }
[18:06:30.376]                         else {
[18:06:30.376]                           version <- NULL
[18:06:30.376]                         }
[18:06:30.376]                         if (!has_future || version < "1.8.0") {
[18:06:30.376]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.376]                             "", base::R.version$version.string), 
[18:06:30.376]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.376]                               "release", "version")], collapse = " "), 
[18:06:30.376]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.376]                             info)
[18:06:30.376]                           info <- base::paste(info, collapse = "; ")
[18:06:30.376]                           if (!has_future) {
[18:06:30.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.376]                               info)
[18:06:30.376]                           }
[18:06:30.376]                           else {
[18:06:30.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.376]                               info, version)
[18:06:30.376]                           }
[18:06:30.376]                           base::stop(msg)
[18:06:30.376]                         }
[18:06:30.376]                       })
[18:06:30.376]                     }
[18:06:30.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.376]                     base::options(mc.cores = 1L)
[18:06:30.376]                   }
[18:06:30.376]                   ...future.strategy.old <- future::plan("list")
[18:06:30.376]                   options(future.plan = NULL)
[18:06:30.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.376]                 }
[18:06:30.376]                 ...future.workdir <- getwd()
[18:06:30.376]             }
[18:06:30.376]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.376]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.376]         }
[18:06:30.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.376]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.376]             base::names(...future.oldOptions))
[18:06:30.376]     }
[18:06:30.376]     if (FALSE) {
[18:06:30.376]     }
[18:06:30.376]     else {
[18:06:30.376]         if (TRUE) {
[18:06:30.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.376]                 open = "w")
[18:06:30.376]         }
[18:06:30.376]         else {
[18:06:30.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.376]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.376]         }
[18:06:30.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.376]             base::sink(type = "output", split = FALSE)
[18:06:30.376]             base::close(...future.stdout)
[18:06:30.376]         }, add = TRUE)
[18:06:30.376]     }
[18:06:30.376]     ...future.frame <- base::sys.nframe()
[18:06:30.376]     ...future.conditions <- base::list()
[18:06:30.376]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.376]     if (FALSE) {
[18:06:30.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.376]     }
[18:06:30.376]     ...future.result <- base::tryCatch({
[18:06:30.376]         base::withCallingHandlers({
[18:06:30.376]             ...future.value <- base::withVisible(base::local({
[18:06:30.376]                 ...future.makeSendCondition <- base::local({
[18:06:30.376]                   sendCondition <- NULL
[18:06:30.376]                   function(frame = 1L) {
[18:06:30.376]                     if (is.function(sendCondition)) 
[18:06:30.376]                       return(sendCondition)
[18:06:30.376]                     ns <- getNamespace("parallel")
[18:06:30.376]                     if (exists("sendData", mode = "function", 
[18:06:30.376]                       envir = ns)) {
[18:06:30.376]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.376]                         envir = ns)
[18:06:30.376]                       envir <- sys.frame(frame)
[18:06:30.376]                       master <- NULL
[18:06:30.376]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.376]                         !identical(envir, emptyenv())) {
[18:06:30.376]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.376]                           inherits = FALSE)) {
[18:06:30.376]                           master <- get("master", mode = "list", 
[18:06:30.376]                             envir = envir, inherits = FALSE)
[18:06:30.376]                           if (inherits(master, c("SOCKnode", 
[18:06:30.376]                             "SOCK0node"))) {
[18:06:30.376]                             sendCondition <<- function(cond) {
[18:06:30.376]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.376]                                 success = TRUE)
[18:06:30.376]                               parallel_sendData(master, data)
[18:06:30.376]                             }
[18:06:30.376]                             return(sendCondition)
[18:06:30.376]                           }
[18:06:30.376]                         }
[18:06:30.376]                         frame <- frame + 1L
[18:06:30.376]                         envir <- sys.frame(frame)
[18:06:30.376]                       }
[18:06:30.376]                     }
[18:06:30.376]                     sendCondition <<- function(cond) NULL
[18:06:30.376]                   }
[18:06:30.376]                 })
[18:06:30.376]                 withCallingHandlers({
[18:06:30.376]                   2
[18:06:30.376]                 }, immediateCondition = function(cond) {
[18:06:30.376]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.376]                   sendCondition(cond)
[18:06:30.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.376]                   {
[18:06:30.376]                     inherits <- base::inherits
[18:06:30.376]                     invokeRestart <- base::invokeRestart
[18:06:30.376]                     is.null <- base::is.null
[18:06:30.376]                     muffled <- FALSE
[18:06:30.376]                     if (inherits(cond, "message")) {
[18:06:30.376]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.376]                       if (muffled) 
[18:06:30.376]                         invokeRestart("muffleMessage")
[18:06:30.376]                     }
[18:06:30.376]                     else if (inherits(cond, "warning")) {
[18:06:30.376]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.376]                       if (muffled) 
[18:06:30.376]                         invokeRestart("muffleWarning")
[18:06:30.376]                     }
[18:06:30.376]                     else if (inherits(cond, "condition")) {
[18:06:30.376]                       if (!is.null(pattern)) {
[18:06:30.376]                         computeRestarts <- base::computeRestarts
[18:06:30.376]                         grepl <- base::grepl
[18:06:30.376]                         restarts <- computeRestarts(cond)
[18:06:30.376]                         for (restart in restarts) {
[18:06:30.376]                           name <- restart$name
[18:06:30.376]                           if (is.null(name)) 
[18:06:30.376]                             next
[18:06:30.376]                           if (!grepl(pattern, name)) 
[18:06:30.376]                             next
[18:06:30.376]                           invokeRestart(restart)
[18:06:30.376]                           muffled <- TRUE
[18:06:30.376]                           break
[18:06:30.376]                         }
[18:06:30.376]                       }
[18:06:30.376]                     }
[18:06:30.376]                     invisible(muffled)
[18:06:30.376]                   }
[18:06:30.376]                   muffleCondition(cond)
[18:06:30.376]                 })
[18:06:30.376]             }))
[18:06:30.376]             future::FutureResult(value = ...future.value$value, 
[18:06:30.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.376]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.376]                     ...future.globalenv.names))
[18:06:30.376]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.376]         }, condition = base::local({
[18:06:30.376]             c <- base::c
[18:06:30.376]             inherits <- base::inherits
[18:06:30.376]             invokeRestart <- base::invokeRestart
[18:06:30.376]             length <- base::length
[18:06:30.376]             list <- base::list
[18:06:30.376]             seq.int <- base::seq.int
[18:06:30.376]             signalCondition <- base::signalCondition
[18:06:30.376]             sys.calls <- base::sys.calls
[18:06:30.376]             `[[` <- base::`[[`
[18:06:30.376]             `+` <- base::`+`
[18:06:30.376]             `<<-` <- base::`<<-`
[18:06:30.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.376]                   3L)]
[18:06:30.376]             }
[18:06:30.376]             function(cond) {
[18:06:30.376]                 is_error <- inherits(cond, "error")
[18:06:30.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.376]                   NULL)
[18:06:30.376]                 if (is_error) {
[18:06:30.376]                   sessionInformation <- function() {
[18:06:30.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.376]                       search = base::search(), system = base::Sys.info())
[18:06:30.376]                   }
[18:06:30.376]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.376]                     cond$call), session = sessionInformation(), 
[18:06:30.376]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.376]                   signalCondition(cond)
[18:06:30.376]                 }
[18:06:30.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.376]                 "immediateCondition"))) {
[18:06:30.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.376]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.376]                   if (TRUE && !signal) {
[18:06:30.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.376]                     {
[18:06:30.376]                       inherits <- base::inherits
[18:06:30.376]                       invokeRestart <- base::invokeRestart
[18:06:30.376]                       is.null <- base::is.null
[18:06:30.376]                       muffled <- FALSE
[18:06:30.376]                       if (inherits(cond, "message")) {
[18:06:30.376]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.376]                         if (muffled) 
[18:06:30.376]                           invokeRestart("muffleMessage")
[18:06:30.376]                       }
[18:06:30.376]                       else if (inherits(cond, "warning")) {
[18:06:30.376]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.376]                         if (muffled) 
[18:06:30.376]                           invokeRestart("muffleWarning")
[18:06:30.376]                       }
[18:06:30.376]                       else if (inherits(cond, "condition")) {
[18:06:30.376]                         if (!is.null(pattern)) {
[18:06:30.376]                           computeRestarts <- base::computeRestarts
[18:06:30.376]                           grepl <- base::grepl
[18:06:30.376]                           restarts <- computeRestarts(cond)
[18:06:30.376]                           for (restart in restarts) {
[18:06:30.376]                             name <- restart$name
[18:06:30.376]                             if (is.null(name)) 
[18:06:30.376]                               next
[18:06:30.376]                             if (!grepl(pattern, name)) 
[18:06:30.376]                               next
[18:06:30.376]                             invokeRestart(restart)
[18:06:30.376]                             muffled <- TRUE
[18:06:30.376]                             break
[18:06:30.376]                           }
[18:06:30.376]                         }
[18:06:30.376]                       }
[18:06:30.376]                       invisible(muffled)
[18:06:30.376]                     }
[18:06:30.376]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.376]                   }
[18:06:30.376]                 }
[18:06:30.376]                 else {
[18:06:30.376]                   if (TRUE) {
[18:06:30.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.376]                     {
[18:06:30.376]                       inherits <- base::inherits
[18:06:30.376]                       invokeRestart <- base::invokeRestart
[18:06:30.376]                       is.null <- base::is.null
[18:06:30.376]                       muffled <- FALSE
[18:06:30.376]                       if (inherits(cond, "message")) {
[18:06:30.376]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.376]                         if (muffled) 
[18:06:30.376]                           invokeRestart("muffleMessage")
[18:06:30.376]                       }
[18:06:30.376]                       else if (inherits(cond, "warning")) {
[18:06:30.376]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.376]                         if (muffled) 
[18:06:30.376]                           invokeRestart("muffleWarning")
[18:06:30.376]                       }
[18:06:30.376]                       else if (inherits(cond, "condition")) {
[18:06:30.376]                         if (!is.null(pattern)) {
[18:06:30.376]                           computeRestarts <- base::computeRestarts
[18:06:30.376]                           grepl <- base::grepl
[18:06:30.376]                           restarts <- computeRestarts(cond)
[18:06:30.376]                           for (restart in restarts) {
[18:06:30.376]                             name <- restart$name
[18:06:30.376]                             if (is.null(name)) 
[18:06:30.376]                               next
[18:06:30.376]                             if (!grepl(pattern, name)) 
[18:06:30.376]                               next
[18:06:30.376]                             invokeRestart(restart)
[18:06:30.376]                             muffled <- TRUE
[18:06:30.376]                             break
[18:06:30.376]                           }
[18:06:30.376]                         }
[18:06:30.376]                       }
[18:06:30.376]                       invisible(muffled)
[18:06:30.376]                     }
[18:06:30.376]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.376]                   }
[18:06:30.376]                 }
[18:06:30.376]             }
[18:06:30.376]         }))
[18:06:30.376]     }, error = function(ex) {
[18:06:30.376]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.376]                 ...future.rng), started = ...future.startTime, 
[18:06:30.376]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.376]             version = "1.8"), class = "FutureResult")
[18:06:30.376]     }, finally = {
[18:06:30.376]         if (!identical(...future.workdir, getwd())) 
[18:06:30.376]             setwd(...future.workdir)
[18:06:30.376]         {
[18:06:30.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.376]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.376]             }
[18:06:30.376]             base::options(...future.oldOptions)
[18:06:30.376]             if (.Platform$OS.type == "windows") {
[18:06:30.376]                 old_names <- names(...future.oldEnvVars)
[18:06:30.376]                 envs <- base::Sys.getenv()
[18:06:30.376]                 names <- names(envs)
[18:06:30.376]                 common <- intersect(names, old_names)
[18:06:30.376]                 added <- setdiff(names, old_names)
[18:06:30.376]                 removed <- setdiff(old_names, names)
[18:06:30.376]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.376]                   envs[common]]
[18:06:30.376]                 NAMES <- toupper(changed)
[18:06:30.376]                 args <- list()
[18:06:30.376]                 for (kk in seq_along(NAMES)) {
[18:06:30.376]                   name <- changed[[kk]]
[18:06:30.376]                   NAME <- NAMES[[kk]]
[18:06:30.376]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.376]                     next
[18:06:30.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.376]                 }
[18:06:30.376]                 NAMES <- toupper(added)
[18:06:30.376]                 for (kk in seq_along(NAMES)) {
[18:06:30.376]                   name <- added[[kk]]
[18:06:30.376]                   NAME <- NAMES[[kk]]
[18:06:30.376]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.376]                     next
[18:06:30.376]                   args[[name]] <- ""
[18:06:30.376]                 }
[18:06:30.376]                 NAMES <- toupper(removed)
[18:06:30.376]                 for (kk in seq_along(NAMES)) {
[18:06:30.376]                   name <- removed[[kk]]
[18:06:30.376]                   NAME <- NAMES[[kk]]
[18:06:30.376]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.376]                     next
[18:06:30.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.376]                 }
[18:06:30.376]                 if (length(args) > 0) 
[18:06:30.376]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.376]             }
[18:06:30.376]             else {
[18:06:30.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.376]             }
[18:06:30.376]             {
[18:06:30.376]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.376]                   0L) {
[18:06:30.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.376]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.376]                   base::options(opts)
[18:06:30.376]                 }
[18:06:30.376]                 {
[18:06:30.376]                   {
[18:06:30.376]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.376]                     NULL
[18:06:30.376]                   }
[18:06:30.376]                   options(future.plan = NULL)
[18:06:30.376]                   if (is.na(NA_character_)) 
[18:06:30.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.376]                     .init = FALSE)
[18:06:30.376]                 }
[18:06:30.376]             }
[18:06:30.376]         }
[18:06:30.376]     })
[18:06:30.376]     if (TRUE) {
[18:06:30.376]         base::sink(type = "output", split = FALSE)
[18:06:30.376]         if (TRUE) {
[18:06:30.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.376]         }
[18:06:30.376]         else {
[18:06:30.376]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.376]         }
[18:06:30.376]         base::close(...future.stdout)
[18:06:30.376]         ...future.stdout <- NULL
[18:06:30.376]     }
[18:06:30.376]     ...future.result$conditions <- ...future.conditions
[18:06:30.376]     ...future.result$finished <- base::Sys.time()
[18:06:30.376]     ...future.result
[18:06:30.376] }
[18:06:30.382] MultisessionFuture started
[18:06:30.383] - Launch lazy future ... done
[18:06:30.383] run() for ‘MultisessionFuture’ ... done
[18:06:30.384] resolve() on list environment ...
[18:06:30.384]  recursive: 0
[18:06:30.385]  length: 3
[18:06:30.386]  elements: ‘a’, ‘b’, ‘c’
[18:06:30.387] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.387] - Validating connection of MultisessionFuture
[18:06:30.387] - received message: FutureResult
[18:06:30.387] - Received FutureResult
[18:06:30.388] - Erased future from FutureRegistry
[18:06:30.388] result() for ClusterFuture ...
[18:06:30.388] - result already collected: FutureResult
[18:06:30.388] result() for ClusterFuture ... done
[18:06:30.388] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.389] Future #1
[18:06:30.389]  length: 2 (resolved future 1)
[18:06:30.400]  length: 1 (resolved future 3)
[18:06:30.432] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.432] - Validating connection of MultisessionFuture
[18:06:30.433] - received message: FutureResult
[18:06:30.433] - Received FutureResult
[18:06:30.433] - Erased future from FutureRegistry
[18:06:30.433] result() for ClusterFuture ...
[18:06:30.434] - result already collected: FutureResult
[18:06:30.434] result() for ClusterFuture ... done
[18:06:30.434] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.434] Future #2
[18:06:30.434]  length: 0 (resolved future 2)
[18:06:30.435] resolve() on list environment ... DONE
[18:06:30.436] getGlobalsAndPackages() ...
[18:06:30.436] Searching for globals...
[18:06:30.437] - globals found: [1] ‘{’
[18:06:30.438] Searching for globals ... DONE
[18:06:30.438] Resolving globals: FALSE
[18:06:30.439] 
[18:06:30.439] 
[18:06:30.439] getGlobalsAndPackages() ... DONE
[18:06:30.439] run() for ‘Future’ ...
[18:06:30.440] - state: ‘created’
[18:06:30.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.464] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.465]   - Field: ‘node’
[18:06:30.465]   - Field: ‘label’
[18:06:30.465]   - Field: ‘local’
[18:06:30.465]   - Field: ‘owner’
[18:06:30.465]   - Field: ‘envir’
[18:06:30.466]   - Field: ‘workers’
[18:06:30.466]   - Field: ‘packages’
[18:06:30.466]   - Field: ‘gc’
[18:06:30.466]   - Field: ‘conditions’
[18:06:30.466]   - Field: ‘persistent’
[18:06:30.467]   - Field: ‘expr’
[18:06:30.467]   - Field: ‘uuid’
[18:06:30.467]   - Field: ‘seed’
[18:06:30.467]   - Field: ‘version’
[18:06:30.467]   - Field: ‘result’
[18:06:30.468]   - Field: ‘asynchronous’
[18:06:30.468]   - Field: ‘calls’
[18:06:30.468]   - Field: ‘globals’
[18:06:30.468]   - Field: ‘stdout’
[18:06:30.468]   - Field: ‘earlySignal’
[18:06:30.469]   - Field: ‘lazy’
[18:06:30.469]   - Field: ‘state’
[18:06:30.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.469] - Launch lazy future ...
[18:06:30.470] Packages needed by the future expression (n = 0): <none>
[18:06:30.470] Packages needed by future strategies (n = 0): <none>
[18:06:30.471] {
[18:06:30.471]     {
[18:06:30.471]         {
[18:06:30.471]             ...future.startTime <- base::Sys.time()
[18:06:30.471]             {
[18:06:30.471]                 {
[18:06:30.471]                   {
[18:06:30.471]                     {
[18:06:30.471]                       base::local({
[18:06:30.471]                         has_future <- base::requireNamespace("future", 
[18:06:30.471]                           quietly = TRUE)
[18:06:30.471]                         if (has_future) {
[18:06:30.471]                           ns <- base::getNamespace("future")
[18:06:30.471]                           version <- ns[[".package"]][["version"]]
[18:06:30.471]                           if (is.null(version)) 
[18:06:30.471]                             version <- utils::packageVersion("future")
[18:06:30.471]                         }
[18:06:30.471]                         else {
[18:06:30.471]                           version <- NULL
[18:06:30.471]                         }
[18:06:30.471]                         if (!has_future || version < "1.8.0") {
[18:06:30.471]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.471]                             "", base::R.version$version.string), 
[18:06:30.471]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.471]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.471]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.471]                               "release", "version")], collapse = " "), 
[18:06:30.471]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.471]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.471]                             info)
[18:06:30.471]                           info <- base::paste(info, collapse = "; ")
[18:06:30.471]                           if (!has_future) {
[18:06:30.471]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.471]                               info)
[18:06:30.471]                           }
[18:06:30.471]                           else {
[18:06:30.471]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.471]                               info, version)
[18:06:30.471]                           }
[18:06:30.471]                           base::stop(msg)
[18:06:30.471]                         }
[18:06:30.471]                       })
[18:06:30.471]                     }
[18:06:30.471]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.471]                     base::options(mc.cores = 1L)
[18:06:30.471]                   }
[18:06:30.471]                   ...future.strategy.old <- future::plan("list")
[18:06:30.471]                   options(future.plan = NULL)
[18:06:30.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.471]                 }
[18:06:30.471]                 ...future.workdir <- getwd()
[18:06:30.471]             }
[18:06:30.471]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.471]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.471]         }
[18:06:30.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.471]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.471]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.471]             base::names(...future.oldOptions))
[18:06:30.471]     }
[18:06:30.471]     if (FALSE) {
[18:06:30.471]     }
[18:06:30.471]     else {
[18:06:30.471]         if (TRUE) {
[18:06:30.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.471]                 open = "w")
[18:06:30.471]         }
[18:06:30.471]         else {
[18:06:30.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.471]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.471]         }
[18:06:30.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.471]             base::sink(type = "output", split = FALSE)
[18:06:30.471]             base::close(...future.stdout)
[18:06:30.471]         }, add = TRUE)
[18:06:30.471]     }
[18:06:30.471]     ...future.frame <- base::sys.nframe()
[18:06:30.471]     ...future.conditions <- base::list()
[18:06:30.471]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.471]     if (FALSE) {
[18:06:30.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.471]     }
[18:06:30.471]     ...future.result <- base::tryCatch({
[18:06:30.471]         base::withCallingHandlers({
[18:06:30.471]             ...future.value <- base::withVisible(base::local({
[18:06:30.471]                 ...future.makeSendCondition <- base::local({
[18:06:30.471]                   sendCondition <- NULL
[18:06:30.471]                   function(frame = 1L) {
[18:06:30.471]                     if (is.function(sendCondition)) 
[18:06:30.471]                       return(sendCondition)
[18:06:30.471]                     ns <- getNamespace("parallel")
[18:06:30.471]                     if (exists("sendData", mode = "function", 
[18:06:30.471]                       envir = ns)) {
[18:06:30.471]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.471]                         envir = ns)
[18:06:30.471]                       envir <- sys.frame(frame)
[18:06:30.471]                       master <- NULL
[18:06:30.471]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.471]                         !identical(envir, emptyenv())) {
[18:06:30.471]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.471]                           inherits = FALSE)) {
[18:06:30.471]                           master <- get("master", mode = "list", 
[18:06:30.471]                             envir = envir, inherits = FALSE)
[18:06:30.471]                           if (inherits(master, c("SOCKnode", 
[18:06:30.471]                             "SOCK0node"))) {
[18:06:30.471]                             sendCondition <<- function(cond) {
[18:06:30.471]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.471]                                 success = TRUE)
[18:06:30.471]                               parallel_sendData(master, data)
[18:06:30.471]                             }
[18:06:30.471]                             return(sendCondition)
[18:06:30.471]                           }
[18:06:30.471]                         }
[18:06:30.471]                         frame <- frame + 1L
[18:06:30.471]                         envir <- sys.frame(frame)
[18:06:30.471]                       }
[18:06:30.471]                     }
[18:06:30.471]                     sendCondition <<- function(cond) NULL
[18:06:30.471]                   }
[18:06:30.471]                 })
[18:06:30.471]                 withCallingHandlers({
[18:06:30.471]                   {
[18:06:30.471]                     1
[18:06:30.471]                   }
[18:06:30.471]                 }, immediateCondition = function(cond) {
[18:06:30.471]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.471]                   sendCondition(cond)
[18:06:30.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.471]                   {
[18:06:30.471]                     inherits <- base::inherits
[18:06:30.471]                     invokeRestart <- base::invokeRestart
[18:06:30.471]                     is.null <- base::is.null
[18:06:30.471]                     muffled <- FALSE
[18:06:30.471]                     if (inherits(cond, "message")) {
[18:06:30.471]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.471]                       if (muffled) 
[18:06:30.471]                         invokeRestart("muffleMessage")
[18:06:30.471]                     }
[18:06:30.471]                     else if (inherits(cond, "warning")) {
[18:06:30.471]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.471]                       if (muffled) 
[18:06:30.471]                         invokeRestart("muffleWarning")
[18:06:30.471]                     }
[18:06:30.471]                     else if (inherits(cond, "condition")) {
[18:06:30.471]                       if (!is.null(pattern)) {
[18:06:30.471]                         computeRestarts <- base::computeRestarts
[18:06:30.471]                         grepl <- base::grepl
[18:06:30.471]                         restarts <- computeRestarts(cond)
[18:06:30.471]                         for (restart in restarts) {
[18:06:30.471]                           name <- restart$name
[18:06:30.471]                           if (is.null(name)) 
[18:06:30.471]                             next
[18:06:30.471]                           if (!grepl(pattern, name)) 
[18:06:30.471]                             next
[18:06:30.471]                           invokeRestart(restart)
[18:06:30.471]                           muffled <- TRUE
[18:06:30.471]                           break
[18:06:30.471]                         }
[18:06:30.471]                       }
[18:06:30.471]                     }
[18:06:30.471]                     invisible(muffled)
[18:06:30.471]                   }
[18:06:30.471]                   muffleCondition(cond)
[18:06:30.471]                 })
[18:06:30.471]             }))
[18:06:30.471]             future::FutureResult(value = ...future.value$value, 
[18:06:30.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.471]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.471]                     ...future.globalenv.names))
[18:06:30.471]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.471]         }, condition = base::local({
[18:06:30.471]             c <- base::c
[18:06:30.471]             inherits <- base::inherits
[18:06:30.471]             invokeRestart <- base::invokeRestart
[18:06:30.471]             length <- base::length
[18:06:30.471]             list <- base::list
[18:06:30.471]             seq.int <- base::seq.int
[18:06:30.471]             signalCondition <- base::signalCondition
[18:06:30.471]             sys.calls <- base::sys.calls
[18:06:30.471]             `[[` <- base::`[[`
[18:06:30.471]             `+` <- base::`+`
[18:06:30.471]             `<<-` <- base::`<<-`
[18:06:30.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.471]                   3L)]
[18:06:30.471]             }
[18:06:30.471]             function(cond) {
[18:06:30.471]                 is_error <- inherits(cond, "error")
[18:06:30.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.471]                   NULL)
[18:06:30.471]                 if (is_error) {
[18:06:30.471]                   sessionInformation <- function() {
[18:06:30.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.471]                       search = base::search(), system = base::Sys.info())
[18:06:30.471]                   }
[18:06:30.471]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.471]                     cond$call), session = sessionInformation(), 
[18:06:30.471]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.471]                   signalCondition(cond)
[18:06:30.471]                 }
[18:06:30.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.471]                 "immediateCondition"))) {
[18:06:30.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.471]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.471]                   if (TRUE && !signal) {
[18:06:30.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.471]                     {
[18:06:30.471]                       inherits <- base::inherits
[18:06:30.471]                       invokeRestart <- base::invokeRestart
[18:06:30.471]                       is.null <- base::is.null
[18:06:30.471]                       muffled <- FALSE
[18:06:30.471]                       if (inherits(cond, "message")) {
[18:06:30.471]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.471]                         if (muffled) 
[18:06:30.471]                           invokeRestart("muffleMessage")
[18:06:30.471]                       }
[18:06:30.471]                       else if (inherits(cond, "warning")) {
[18:06:30.471]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.471]                         if (muffled) 
[18:06:30.471]                           invokeRestart("muffleWarning")
[18:06:30.471]                       }
[18:06:30.471]                       else if (inherits(cond, "condition")) {
[18:06:30.471]                         if (!is.null(pattern)) {
[18:06:30.471]                           computeRestarts <- base::computeRestarts
[18:06:30.471]                           grepl <- base::grepl
[18:06:30.471]                           restarts <- computeRestarts(cond)
[18:06:30.471]                           for (restart in restarts) {
[18:06:30.471]                             name <- restart$name
[18:06:30.471]                             if (is.null(name)) 
[18:06:30.471]                               next
[18:06:30.471]                             if (!grepl(pattern, name)) 
[18:06:30.471]                               next
[18:06:30.471]                             invokeRestart(restart)
[18:06:30.471]                             muffled <- TRUE
[18:06:30.471]                             break
[18:06:30.471]                           }
[18:06:30.471]                         }
[18:06:30.471]                       }
[18:06:30.471]                       invisible(muffled)
[18:06:30.471]                     }
[18:06:30.471]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.471]                   }
[18:06:30.471]                 }
[18:06:30.471]                 else {
[18:06:30.471]                   if (TRUE) {
[18:06:30.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.471]                     {
[18:06:30.471]                       inherits <- base::inherits
[18:06:30.471]                       invokeRestart <- base::invokeRestart
[18:06:30.471]                       is.null <- base::is.null
[18:06:30.471]                       muffled <- FALSE
[18:06:30.471]                       if (inherits(cond, "message")) {
[18:06:30.471]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.471]                         if (muffled) 
[18:06:30.471]                           invokeRestart("muffleMessage")
[18:06:30.471]                       }
[18:06:30.471]                       else if (inherits(cond, "warning")) {
[18:06:30.471]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.471]                         if (muffled) 
[18:06:30.471]                           invokeRestart("muffleWarning")
[18:06:30.471]                       }
[18:06:30.471]                       else if (inherits(cond, "condition")) {
[18:06:30.471]                         if (!is.null(pattern)) {
[18:06:30.471]                           computeRestarts <- base::computeRestarts
[18:06:30.471]                           grepl <- base::grepl
[18:06:30.471]                           restarts <- computeRestarts(cond)
[18:06:30.471]                           for (restart in restarts) {
[18:06:30.471]                             name <- restart$name
[18:06:30.471]                             if (is.null(name)) 
[18:06:30.471]                               next
[18:06:30.471]                             if (!grepl(pattern, name)) 
[18:06:30.471]                               next
[18:06:30.471]                             invokeRestart(restart)
[18:06:30.471]                             muffled <- TRUE
[18:06:30.471]                             break
[18:06:30.471]                           }
[18:06:30.471]                         }
[18:06:30.471]                       }
[18:06:30.471]                       invisible(muffled)
[18:06:30.471]                     }
[18:06:30.471]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.471]                   }
[18:06:30.471]                 }
[18:06:30.471]             }
[18:06:30.471]         }))
[18:06:30.471]     }, error = function(ex) {
[18:06:30.471]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.471]                 ...future.rng), started = ...future.startTime, 
[18:06:30.471]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.471]             version = "1.8"), class = "FutureResult")
[18:06:30.471]     }, finally = {
[18:06:30.471]         if (!identical(...future.workdir, getwd())) 
[18:06:30.471]             setwd(...future.workdir)
[18:06:30.471]         {
[18:06:30.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.471]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.471]             }
[18:06:30.471]             base::options(...future.oldOptions)
[18:06:30.471]             if (.Platform$OS.type == "windows") {
[18:06:30.471]                 old_names <- names(...future.oldEnvVars)
[18:06:30.471]                 envs <- base::Sys.getenv()
[18:06:30.471]                 names <- names(envs)
[18:06:30.471]                 common <- intersect(names, old_names)
[18:06:30.471]                 added <- setdiff(names, old_names)
[18:06:30.471]                 removed <- setdiff(old_names, names)
[18:06:30.471]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.471]                   envs[common]]
[18:06:30.471]                 NAMES <- toupper(changed)
[18:06:30.471]                 args <- list()
[18:06:30.471]                 for (kk in seq_along(NAMES)) {
[18:06:30.471]                   name <- changed[[kk]]
[18:06:30.471]                   NAME <- NAMES[[kk]]
[18:06:30.471]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.471]                     next
[18:06:30.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.471]                 }
[18:06:30.471]                 NAMES <- toupper(added)
[18:06:30.471]                 for (kk in seq_along(NAMES)) {
[18:06:30.471]                   name <- added[[kk]]
[18:06:30.471]                   NAME <- NAMES[[kk]]
[18:06:30.471]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.471]                     next
[18:06:30.471]                   args[[name]] <- ""
[18:06:30.471]                 }
[18:06:30.471]                 NAMES <- toupper(removed)
[18:06:30.471]                 for (kk in seq_along(NAMES)) {
[18:06:30.471]                   name <- removed[[kk]]
[18:06:30.471]                   NAME <- NAMES[[kk]]
[18:06:30.471]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.471]                     next
[18:06:30.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.471]                 }
[18:06:30.471]                 if (length(args) > 0) 
[18:06:30.471]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.471]             }
[18:06:30.471]             else {
[18:06:30.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.471]             }
[18:06:30.471]             {
[18:06:30.471]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.471]                   0L) {
[18:06:30.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.471]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.471]                   base::options(opts)
[18:06:30.471]                 }
[18:06:30.471]                 {
[18:06:30.471]                   {
[18:06:30.471]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.471]                     NULL
[18:06:30.471]                   }
[18:06:30.471]                   options(future.plan = NULL)
[18:06:30.471]                   if (is.na(NA_character_)) 
[18:06:30.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.471]                     .init = FALSE)
[18:06:30.471]                 }
[18:06:30.471]             }
[18:06:30.471]         }
[18:06:30.471]     })
[18:06:30.471]     if (TRUE) {
[18:06:30.471]         base::sink(type = "output", split = FALSE)
[18:06:30.471]         if (TRUE) {
[18:06:30.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.471]         }
[18:06:30.471]         else {
[18:06:30.471]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.471]         }
[18:06:30.471]         base::close(...future.stdout)
[18:06:30.471]         ...future.stdout <- NULL
[18:06:30.471]     }
[18:06:30.471]     ...future.result$conditions <- ...future.conditions
[18:06:30.471]     ...future.result$finished <- base::Sys.time()
[18:06:30.471]     ...future.result
[18:06:30.471] }
[18:06:30.477] MultisessionFuture started
[18:06:30.477] - Launch lazy future ... done
[18:06:30.478] run() for ‘MultisessionFuture’ ... done
[18:06:30.478] getGlobalsAndPackages() ...
[18:06:30.479] Searching for globals...
[18:06:30.480] - globals found: [1] ‘{’
[18:06:30.480] Searching for globals ... DONE
[18:06:30.480] Resolving globals: FALSE
[18:06:30.481] 
[18:06:30.481] 
[18:06:30.481] getGlobalsAndPackages() ... DONE
[18:06:30.482] run() for ‘Future’ ...
[18:06:30.482] - state: ‘created’
[18:06:30.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.507] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.508]   - Field: ‘node’
[18:06:30.508]   - Field: ‘label’
[18:06:30.509]   - Field: ‘local’
[18:06:30.509]   - Field: ‘owner’
[18:06:30.509]   - Field: ‘envir’
[18:06:30.509]   - Field: ‘workers’
[18:06:30.509]   - Field: ‘packages’
[18:06:30.510]   - Field: ‘gc’
[18:06:30.510]   - Field: ‘conditions’
[18:06:30.510]   - Field: ‘persistent’
[18:06:30.510]   - Field: ‘expr’
[18:06:30.510]   - Field: ‘uuid’
[18:06:30.511]   - Field: ‘seed’
[18:06:30.511]   - Field: ‘version’
[18:06:30.511]   - Field: ‘result’
[18:06:30.511]   - Field: ‘asynchronous’
[18:06:30.511]   - Field: ‘calls’
[18:06:30.512]   - Field: ‘globals’
[18:06:30.512]   - Field: ‘stdout’
[18:06:30.512]   - Field: ‘earlySignal’
[18:06:30.512]   - Field: ‘lazy’
[18:06:30.512]   - Field: ‘state’
[18:06:30.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.513] - Launch lazy future ...
[18:06:30.513] Packages needed by the future expression (n = 0): <none>
[18:06:30.514] Packages needed by future strategies (n = 0): <none>
[18:06:30.515] {
[18:06:30.515]     {
[18:06:30.515]         {
[18:06:30.515]             ...future.startTime <- base::Sys.time()
[18:06:30.515]             {
[18:06:30.515]                 {
[18:06:30.515]                   {
[18:06:30.515]                     {
[18:06:30.515]                       base::local({
[18:06:30.515]                         has_future <- base::requireNamespace("future", 
[18:06:30.515]                           quietly = TRUE)
[18:06:30.515]                         if (has_future) {
[18:06:30.515]                           ns <- base::getNamespace("future")
[18:06:30.515]                           version <- ns[[".package"]][["version"]]
[18:06:30.515]                           if (is.null(version)) 
[18:06:30.515]                             version <- utils::packageVersion("future")
[18:06:30.515]                         }
[18:06:30.515]                         else {
[18:06:30.515]                           version <- NULL
[18:06:30.515]                         }
[18:06:30.515]                         if (!has_future || version < "1.8.0") {
[18:06:30.515]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.515]                             "", base::R.version$version.string), 
[18:06:30.515]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.515]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.515]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.515]                               "release", "version")], collapse = " "), 
[18:06:30.515]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.515]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.515]                             info)
[18:06:30.515]                           info <- base::paste(info, collapse = "; ")
[18:06:30.515]                           if (!has_future) {
[18:06:30.515]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.515]                               info)
[18:06:30.515]                           }
[18:06:30.515]                           else {
[18:06:30.515]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.515]                               info, version)
[18:06:30.515]                           }
[18:06:30.515]                           base::stop(msg)
[18:06:30.515]                         }
[18:06:30.515]                       })
[18:06:30.515]                     }
[18:06:30.515]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.515]                     base::options(mc.cores = 1L)
[18:06:30.515]                   }
[18:06:30.515]                   ...future.strategy.old <- future::plan("list")
[18:06:30.515]                   options(future.plan = NULL)
[18:06:30.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.515]                 }
[18:06:30.515]                 ...future.workdir <- getwd()
[18:06:30.515]             }
[18:06:30.515]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.515]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.515]         }
[18:06:30.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.515]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.515]             base::names(...future.oldOptions))
[18:06:30.515]     }
[18:06:30.515]     if (FALSE) {
[18:06:30.515]     }
[18:06:30.515]     else {
[18:06:30.515]         if (TRUE) {
[18:06:30.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.515]                 open = "w")
[18:06:30.515]         }
[18:06:30.515]         else {
[18:06:30.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.515]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.515]         }
[18:06:30.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.515]             base::sink(type = "output", split = FALSE)
[18:06:30.515]             base::close(...future.stdout)
[18:06:30.515]         }, add = TRUE)
[18:06:30.515]     }
[18:06:30.515]     ...future.frame <- base::sys.nframe()
[18:06:30.515]     ...future.conditions <- base::list()
[18:06:30.515]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.515]     if (FALSE) {
[18:06:30.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.515]     }
[18:06:30.515]     ...future.result <- base::tryCatch({
[18:06:30.515]         base::withCallingHandlers({
[18:06:30.515]             ...future.value <- base::withVisible(base::local({
[18:06:30.515]                 ...future.makeSendCondition <- base::local({
[18:06:30.515]                   sendCondition <- NULL
[18:06:30.515]                   function(frame = 1L) {
[18:06:30.515]                     if (is.function(sendCondition)) 
[18:06:30.515]                       return(sendCondition)
[18:06:30.515]                     ns <- getNamespace("parallel")
[18:06:30.515]                     if (exists("sendData", mode = "function", 
[18:06:30.515]                       envir = ns)) {
[18:06:30.515]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.515]                         envir = ns)
[18:06:30.515]                       envir <- sys.frame(frame)
[18:06:30.515]                       master <- NULL
[18:06:30.515]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.515]                         !identical(envir, emptyenv())) {
[18:06:30.515]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.515]                           inherits = FALSE)) {
[18:06:30.515]                           master <- get("master", mode = "list", 
[18:06:30.515]                             envir = envir, inherits = FALSE)
[18:06:30.515]                           if (inherits(master, c("SOCKnode", 
[18:06:30.515]                             "SOCK0node"))) {
[18:06:30.515]                             sendCondition <<- function(cond) {
[18:06:30.515]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.515]                                 success = TRUE)
[18:06:30.515]                               parallel_sendData(master, data)
[18:06:30.515]                             }
[18:06:30.515]                             return(sendCondition)
[18:06:30.515]                           }
[18:06:30.515]                         }
[18:06:30.515]                         frame <- frame + 1L
[18:06:30.515]                         envir <- sys.frame(frame)
[18:06:30.515]                       }
[18:06:30.515]                     }
[18:06:30.515]                     sendCondition <<- function(cond) NULL
[18:06:30.515]                   }
[18:06:30.515]                 })
[18:06:30.515]                 withCallingHandlers({
[18:06:30.515]                   {
[18:06:30.515]                     2
[18:06:30.515]                   }
[18:06:30.515]                 }, immediateCondition = function(cond) {
[18:06:30.515]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.515]                   sendCondition(cond)
[18:06:30.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.515]                   {
[18:06:30.515]                     inherits <- base::inherits
[18:06:30.515]                     invokeRestart <- base::invokeRestart
[18:06:30.515]                     is.null <- base::is.null
[18:06:30.515]                     muffled <- FALSE
[18:06:30.515]                     if (inherits(cond, "message")) {
[18:06:30.515]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.515]                       if (muffled) 
[18:06:30.515]                         invokeRestart("muffleMessage")
[18:06:30.515]                     }
[18:06:30.515]                     else if (inherits(cond, "warning")) {
[18:06:30.515]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.515]                       if (muffled) 
[18:06:30.515]                         invokeRestart("muffleWarning")
[18:06:30.515]                     }
[18:06:30.515]                     else if (inherits(cond, "condition")) {
[18:06:30.515]                       if (!is.null(pattern)) {
[18:06:30.515]                         computeRestarts <- base::computeRestarts
[18:06:30.515]                         grepl <- base::grepl
[18:06:30.515]                         restarts <- computeRestarts(cond)
[18:06:30.515]                         for (restart in restarts) {
[18:06:30.515]                           name <- restart$name
[18:06:30.515]                           if (is.null(name)) 
[18:06:30.515]                             next
[18:06:30.515]                           if (!grepl(pattern, name)) 
[18:06:30.515]                             next
[18:06:30.515]                           invokeRestart(restart)
[18:06:30.515]                           muffled <- TRUE
[18:06:30.515]                           break
[18:06:30.515]                         }
[18:06:30.515]                       }
[18:06:30.515]                     }
[18:06:30.515]                     invisible(muffled)
[18:06:30.515]                   }
[18:06:30.515]                   muffleCondition(cond)
[18:06:30.515]                 })
[18:06:30.515]             }))
[18:06:30.515]             future::FutureResult(value = ...future.value$value, 
[18:06:30.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.515]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.515]                     ...future.globalenv.names))
[18:06:30.515]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.515]         }, condition = base::local({
[18:06:30.515]             c <- base::c
[18:06:30.515]             inherits <- base::inherits
[18:06:30.515]             invokeRestart <- base::invokeRestart
[18:06:30.515]             length <- base::length
[18:06:30.515]             list <- base::list
[18:06:30.515]             seq.int <- base::seq.int
[18:06:30.515]             signalCondition <- base::signalCondition
[18:06:30.515]             sys.calls <- base::sys.calls
[18:06:30.515]             `[[` <- base::`[[`
[18:06:30.515]             `+` <- base::`+`
[18:06:30.515]             `<<-` <- base::`<<-`
[18:06:30.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.515]                   3L)]
[18:06:30.515]             }
[18:06:30.515]             function(cond) {
[18:06:30.515]                 is_error <- inherits(cond, "error")
[18:06:30.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.515]                   NULL)
[18:06:30.515]                 if (is_error) {
[18:06:30.515]                   sessionInformation <- function() {
[18:06:30.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.515]                       search = base::search(), system = base::Sys.info())
[18:06:30.515]                   }
[18:06:30.515]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.515]                     cond$call), session = sessionInformation(), 
[18:06:30.515]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.515]                   signalCondition(cond)
[18:06:30.515]                 }
[18:06:30.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.515]                 "immediateCondition"))) {
[18:06:30.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.515]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.515]                   if (TRUE && !signal) {
[18:06:30.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.515]                     {
[18:06:30.515]                       inherits <- base::inherits
[18:06:30.515]                       invokeRestart <- base::invokeRestart
[18:06:30.515]                       is.null <- base::is.null
[18:06:30.515]                       muffled <- FALSE
[18:06:30.515]                       if (inherits(cond, "message")) {
[18:06:30.515]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.515]                         if (muffled) 
[18:06:30.515]                           invokeRestart("muffleMessage")
[18:06:30.515]                       }
[18:06:30.515]                       else if (inherits(cond, "warning")) {
[18:06:30.515]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.515]                         if (muffled) 
[18:06:30.515]                           invokeRestart("muffleWarning")
[18:06:30.515]                       }
[18:06:30.515]                       else if (inherits(cond, "condition")) {
[18:06:30.515]                         if (!is.null(pattern)) {
[18:06:30.515]                           computeRestarts <- base::computeRestarts
[18:06:30.515]                           grepl <- base::grepl
[18:06:30.515]                           restarts <- computeRestarts(cond)
[18:06:30.515]                           for (restart in restarts) {
[18:06:30.515]                             name <- restart$name
[18:06:30.515]                             if (is.null(name)) 
[18:06:30.515]                               next
[18:06:30.515]                             if (!grepl(pattern, name)) 
[18:06:30.515]                               next
[18:06:30.515]                             invokeRestart(restart)
[18:06:30.515]                             muffled <- TRUE
[18:06:30.515]                             break
[18:06:30.515]                           }
[18:06:30.515]                         }
[18:06:30.515]                       }
[18:06:30.515]                       invisible(muffled)
[18:06:30.515]                     }
[18:06:30.515]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.515]                   }
[18:06:30.515]                 }
[18:06:30.515]                 else {
[18:06:30.515]                   if (TRUE) {
[18:06:30.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.515]                     {
[18:06:30.515]                       inherits <- base::inherits
[18:06:30.515]                       invokeRestart <- base::invokeRestart
[18:06:30.515]                       is.null <- base::is.null
[18:06:30.515]                       muffled <- FALSE
[18:06:30.515]                       if (inherits(cond, "message")) {
[18:06:30.515]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.515]                         if (muffled) 
[18:06:30.515]                           invokeRestart("muffleMessage")
[18:06:30.515]                       }
[18:06:30.515]                       else if (inherits(cond, "warning")) {
[18:06:30.515]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.515]                         if (muffled) 
[18:06:30.515]                           invokeRestart("muffleWarning")
[18:06:30.515]                       }
[18:06:30.515]                       else if (inherits(cond, "condition")) {
[18:06:30.515]                         if (!is.null(pattern)) {
[18:06:30.515]                           computeRestarts <- base::computeRestarts
[18:06:30.515]                           grepl <- base::grepl
[18:06:30.515]                           restarts <- computeRestarts(cond)
[18:06:30.515]                           for (restart in restarts) {
[18:06:30.515]                             name <- restart$name
[18:06:30.515]                             if (is.null(name)) 
[18:06:30.515]                               next
[18:06:30.515]                             if (!grepl(pattern, name)) 
[18:06:30.515]                               next
[18:06:30.515]                             invokeRestart(restart)
[18:06:30.515]                             muffled <- TRUE
[18:06:30.515]                             break
[18:06:30.515]                           }
[18:06:30.515]                         }
[18:06:30.515]                       }
[18:06:30.515]                       invisible(muffled)
[18:06:30.515]                     }
[18:06:30.515]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.515]                   }
[18:06:30.515]                 }
[18:06:30.515]             }
[18:06:30.515]         }))
[18:06:30.515]     }, error = function(ex) {
[18:06:30.515]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.515]                 ...future.rng), started = ...future.startTime, 
[18:06:30.515]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.515]             version = "1.8"), class = "FutureResult")
[18:06:30.515]     }, finally = {
[18:06:30.515]         if (!identical(...future.workdir, getwd())) 
[18:06:30.515]             setwd(...future.workdir)
[18:06:30.515]         {
[18:06:30.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.515]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.515]             }
[18:06:30.515]             base::options(...future.oldOptions)
[18:06:30.515]             if (.Platform$OS.type == "windows") {
[18:06:30.515]                 old_names <- names(...future.oldEnvVars)
[18:06:30.515]                 envs <- base::Sys.getenv()
[18:06:30.515]                 names <- names(envs)
[18:06:30.515]                 common <- intersect(names, old_names)
[18:06:30.515]                 added <- setdiff(names, old_names)
[18:06:30.515]                 removed <- setdiff(old_names, names)
[18:06:30.515]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.515]                   envs[common]]
[18:06:30.515]                 NAMES <- toupper(changed)
[18:06:30.515]                 args <- list()
[18:06:30.515]                 for (kk in seq_along(NAMES)) {
[18:06:30.515]                   name <- changed[[kk]]
[18:06:30.515]                   NAME <- NAMES[[kk]]
[18:06:30.515]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.515]                     next
[18:06:30.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.515]                 }
[18:06:30.515]                 NAMES <- toupper(added)
[18:06:30.515]                 for (kk in seq_along(NAMES)) {
[18:06:30.515]                   name <- added[[kk]]
[18:06:30.515]                   NAME <- NAMES[[kk]]
[18:06:30.515]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.515]                     next
[18:06:30.515]                   args[[name]] <- ""
[18:06:30.515]                 }
[18:06:30.515]                 NAMES <- toupper(removed)
[18:06:30.515]                 for (kk in seq_along(NAMES)) {
[18:06:30.515]                   name <- removed[[kk]]
[18:06:30.515]                   NAME <- NAMES[[kk]]
[18:06:30.515]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.515]                     next
[18:06:30.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.515]                 }
[18:06:30.515]                 if (length(args) > 0) 
[18:06:30.515]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.515]             }
[18:06:30.515]             else {
[18:06:30.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.515]             }
[18:06:30.515]             {
[18:06:30.515]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.515]                   0L) {
[18:06:30.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.515]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.515]                   base::options(opts)
[18:06:30.515]                 }
[18:06:30.515]                 {
[18:06:30.515]                   {
[18:06:30.515]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.515]                     NULL
[18:06:30.515]                   }
[18:06:30.515]                   options(future.plan = NULL)
[18:06:30.515]                   if (is.na(NA_character_)) 
[18:06:30.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.515]                     .init = FALSE)
[18:06:30.515]                 }
[18:06:30.515]             }
[18:06:30.515]         }
[18:06:30.515]     })
[18:06:30.515]     if (TRUE) {
[18:06:30.515]         base::sink(type = "output", split = FALSE)
[18:06:30.515]         if (TRUE) {
[18:06:30.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.515]         }
[18:06:30.515]         else {
[18:06:30.515]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.515]         }
[18:06:30.515]         base::close(...future.stdout)
[18:06:30.515]         ...future.stdout <- NULL
[18:06:30.515]     }
[18:06:30.515]     ...future.result$conditions <- ...future.conditions
[18:06:30.515]     ...future.result$finished <- base::Sys.time()
[18:06:30.515]     ...future.result
[18:06:30.515] }
[18:06:30.521] MultisessionFuture started
[18:06:30.521] - Launch lazy future ... done
[18:06:30.521] run() for ‘MultisessionFuture’ ... done
[18:06:30.522] resolve() on list environment ...
[18:06:30.522]  recursive: 0
[18:06:30.523]  length: 3
[18:06:30.524]  elements: ‘a’, ‘b’, ‘c’
[18:06:30.525] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.525] - Validating connection of MultisessionFuture
[18:06:30.525] - received message: FutureResult
[18:06:30.526] - Received FutureResult
[18:06:30.526] - Erased future from FutureRegistry
[18:06:30.526] result() for ClusterFuture ...
[18:06:30.526] - result already collected: FutureResult
[18:06:30.526] result() for ClusterFuture ... done
[18:06:30.526] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.527] Future #1
[18:06:30.527]  length: 2 (resolved future 1)
[18:06:30.538]  length: 1 (resolved future 3)
[18:06:30.570] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.570] - Validating connection of MultisessionFuture
[18:06:30.571] - received message: FutureResult
[18:06:30.571] - Received FutureResult
[18:06:30.571] - Erased future from FutureRegistry
[18:06:30.572] result() for ClusterFuture ...
[18:06:30.572] - result already collected: FutureResult
[18:06:30.572] result() for ClusterFuture ... done
[18:06:30.572] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.572] Future #2
[18:06:30.573]  length: 0 (resolved future 2)
[18:06:30.573] resolve() on list environment ... DONE
[18:06:30.574] getGlobalsAndPackages() ...
[18:06:30.574] Searching for globals...
[18:06:30.575] - globals found: [1] ‘{’
[18:06:30.575] Searching for globals ... DONE
[18:06:30.576] Resolving globals: FALSE
[18:06:30.576] 
[18:06:30.576] 
[18:06:30.577] getGlobalsAndPackages() ... DONE
[18:06:30.577] run() for ‘Future’ ...
[18:06:30.577] - state: ‘created’
[18:06:30.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.602] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.602]   - Field: ‘node’
[18:06:30.603]   - Field: ‘label’
[18:06:30.603]   - Field: ‘local’
[18:06:30.603]   - Field: ‘owner’
[18:06:30.603]   - Field: ‘envir’
[18:06:30.604]   - Field: ‘workers’
[18:06:30.604]   - Field: ‘packages’
[18:06:30.604]   - Field: ‘gc’
[18:06:30.604]   - Field: ‘conditions’
[18:06:30.604]   - Field: ‘persistent’
[18:06:30.605]   - Field: ‘expr’
[18:06:30.605]   - Field: ‘uuid’
[18:06:30.605]   - Field: ‘seed’
[18:06:30.605]   - Field: ‘version’
[18:06:30.605]   - Field: ‘result’
[18:06:30.605]   - Field: ‘asynchronous’
[18:06:30.606]   - Field: ‘calls’
[18:06:30.606]   - Field: ‘globals’
[18:06:30.606]   - Field: ‘stdout’
[18:06:30.606]   - Field: ‘earlySignal’
[18:06:30.606]   - Field: ‘lazy’
[18:06:30.607]   - Field: ‘state’
[18:06:30.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.607] - Launch lazy future ...
[18:06:30.608] Packages needed by the future expression (n = 0): <none>
[18:06:30.608] Packages needed by future strategies (n = 0): <none>
[18:06:30.609] {
[18:06:30.609]     {
[18:06:30.609]         {
[18:06:30.609]             ...future.startTime <- base::Sys.time()
[18:06:30.609]             {
[18:06:30.609]                 {
[18:06:30.609]                   {
[18:06:30.609]                     {
[18:06:30.609]                       base::local({
[18:06:30.609]                         has_future <- base::requireNamespace("future", 
[18:06:30.609]                           quietly = TRUE)
[18:06:30.609]                         if (has_future) {
[18:06:30.609]                           ns <- base::getNamespace("future")
[18:06:30.609]                           version <- ns[[".package"]][["version"]]
[18:06:30.609]                           if (is.null(version)) 
[18:06:30.609]                             version <- utils::packageVersion("future")
[18:06:30.609]                         }
[18:06:30.609]                         else {
[18:06:30.609]                           version <- NULL
[18:06:30.609]                         }
[18:06:30.609]                         if (!has_future || version < "1.8.0") {
[18:06:30.609]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.609]                             "", base::R.version$version.string), 
[18:06:30.609]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.609]                               "release", "version")], collapse = " "), 
[18:06:30.609]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.609]                             info)
[18:06:30.609]                           info <- base::paste(info, collapse = "; ")
[18:06:30.609]                           if (!has_future) {
[18:06:30.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.609]                               info)
[18:06:30.609]                           }
[18:06:30.609]                           else {
[18:06:30.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.609]                               info, version)
[18:06:30.609]                           }
[18:06:30.609]                           base::stop(msg)
[18:06:30.609]                         }
[18:06:30.609]                       })
[18:06:30.609]                     }
[18:06:30.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.609]                     base::options(mc.cores = 1L)
[18:06:30.609]                   }
[18:06:30.609]                   ...future.strategy.old <- future::plan("list")
[18:06:30.609]                   options(future.plan = NULL)
[18:06:30.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.609]                 }
[18:06:30.609]                 ...future.workdir <- getwd()
[18:06:30.609]             }
[18:06:30.609]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.609]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.609]         }
[18:06:30.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.609]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.609]             base::names(...future.oldOptions))
[18:06:30.609]     }
[18:06:30.609]     if (FALSE) {
[18:06:30.609]     }
[18:06:30.609]     else {
[18:06:30.609]         if (TRUE) {
[18:06:30.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.609]                 open = "w")
[18:06:30.609]         }
[18:06:30.609]         else {
[18:06:30.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.609]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.609]         }
[18:06:30.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.609]             base::sink(type = "output", split = FALSE)
[18:06:30.609]             base::close(...future.stdout)
[18:06:30.609]         }, add = TRUE)
[18:06:30.609]     }
[18:06:30.609]     ...future.frame <- base::sys.nframe()
[18:06:30.609]     ...future.conditions <- base::list()
[18:06:30.609]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.609]     if (FALSE) {
[18:06:30.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.609]     }
[18:06:30.609]     ...future.result <- base::tryCatch({
[18:06:30.609]         base::withCallingHandlers({
[18:06:30.609]             ...future.value <- base::withVisible(base::local({
[18:06:30.609]                 ...future.makeSendCondition <- base::local({
[18:06:30.609]                   sendCondition <- NULL
[18:06:30.609]                   function(frame = 1L) {
[18:06:30.609]                     if (is.function(sendCondition)) 
[18:06:30.609]                       return(sendCondition)
[18:06:30.609]                     ns <- getNamespace("parallel")
[18:06:30.609]                     if (exists("sendData", mode = "function", 
[18:06:30.609]                       envir = ns)) {
[18:06:30.609]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.609]                         envir = ns)
[18:06:30.609]                       envir <- sys.frame(frame)
[18:06:30.609]                       master <- NULL
[18:06:30.609]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.609]                         !identical(envir, emptyenv())) {
[18:06:30.609]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.609]                           inherits = FALSE)) {
[18:06:30.609]                           master <- get("master", mode = "list", 
[18:06:30.609]                             envir = envir, inherits = FALSE)
[18:06:30.609]                           if (inherits(master, c("SOCKnode", 
[18:06:30.609]                             "SOCK0node"))) {
[18:06:30.609]                             sendCondition <<- function(cond) {
[18:06:30.609]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.609]                                 success = TRUE)
[18:06:30.609]                               parallel_sendData(master, data)
[18:06:30.609]                             }
[18:06:30.609]                             return(sendCondition)
[18:06:30.609]                           }
[18:06:30.609]                         }
[18:06:30.609]                         frame <- frame + 1L
[18:06:30.609]                         envir <- sys.frame(frame)
[18:06:30.609]                       }
[18:06:30.609]                     }
[18:06:30.609]                     sendCondition <<- function(cond) NULL
[18:06:30.609]                   }
[18:06:30.609]                 })
[18:06:30.609]                 withCallingHandlers({
[18:06:30.609]                   {
[18:06:30.609]                     1
[18:06:30.609]                   }
[18:06:30.609]                 }, immediateCondition = function(cond) {
[18:06:30.609]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.609]                   sendCondition(cond)
[18:06:30.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.609]                   {
[18:06:30.609]                     inherits <- base::inherits
[18:06:30.609]                     invokeRestart <- base::invokeRestart
[18:06:30.609]                     is.null <- base::is.null
[18:06:30.609]                     muffled <- FALSE
[18:06:30.609]                     if (inherits(cond, "message")) {
[18:06:30.609]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.609]                       if (muffled) 
[18:06:30.609]                         invokeRestart("muffleMessage")
[18:06:30.609]                     }
[18:06:30.609]                     else if (inherits(cond, "warning")) {
[18:06:30.609]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.609]                       if (muffled) 
[18:06:30.609]                         invokeRestart("muffleWarning")
[18:06:30.609]                     }
[18:06:30.609]                     else if (inherits(cond, "condition")) {
[18:06:30.609]                       if (!is.null(pattern)) {
[18:06:30.609]                         computeRestarts <- base::computeRestarts
[18:06:30.609]                         grepl <- base::grepl
[18:06:30.609]                         restarts <- computeRestarts(cond)
[18:06:30.609]                         for (restart in restarts) {
[18:06:30.609]                           name <- restart$name
[18:06:30.609]                           if (is.null(name)) 
[18:06:30.609]                             next
[18:06:30.609]                           if (!grepl(pattern, name)) 
[18:06:30.609]                             next
[18:06:30.609]                           invokeRestart(restart)
[18:06:30.609]                           muffled <- TRUE
[18:06:30.609]                           break
[18:06:30.609]                         }
[18:06:30.609]                       }
[18:06:30.609]                     }
[18:06:30.609]                     invisible(muffled)
[18:06:30.609]                   }
[18:06:30.609]                   muffleCondition(cond)
[18:06:30.609]                 })
[18:06:30.609]             }))
[18:06:30.609]             future::FutureResult(value = ...future.value$value, 
[18:06:30.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.609]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.609]                     ...future.globalenv.names))
[18:06:30.609]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.609]         }, condition = base::local({
[18:06:30.609]             c <- base::c
[18:06:30.609]             inherits <- base::inherits
[18:06:30.609]             invokeRestart <- base::invokeRestart
[18:06:30.609]             length <- base::length
[18:06:30.609]             list <- base::list
[18:06:30.609]             seq.int <- base::seq.int
[18:06:30.609]             signalCondition <- base::signalCondition
[18:06:30.609]             sys.calls <- base::sys.calls
[18:06:30.609]             `[[` <- base::`[[`
[18:06:30.609]             `+` <- base::`+`
[18:06:30.609]             `<<-` <- base::`<<-`
[18:06:30.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.609]                   3L)]
[18:06:30.609]             }
[18:06:30.609]             function(cond) {
[18:06:30.609]                 is_error <- inherits(cond, "error")
[18:06:30.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.609]                   NULL)
[18:06:30.609]                 if (is_error) {
[18:06:30.609]                   sessionInformation <- function() {
[18:06:30.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.609]                       search = base::search(), system = base::Sys.info())
[18:06:30.609]                   }
[18:06:30.609]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.609]                     cond$call), session = sessionInformation(), 
[18:06:30.609]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.609]                   signalCondition(cond)
[18:06:30.609]                 }
[18:06:30.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.609]                 "immediateCondition"))) {
[18:06:30.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.609]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.609]                   if (TRUE && !signal) {
[18:06:30.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.609]                     {
[18:06:30.609]                       inherits <- base::inherits
[18:06:30.609]                       invokeRestart <- base::invokeRestart
[18:06:30.609]                       is.null <- base::is.null
[18:06:30.609]                       muffled <- FALSE
[18:06:30.609]                       if (inherits(cond, "message")) {
[18:06:30.609]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.609]                         if (muffled) 
[18:06:30.609]                           invokeRestart("muffleMessage")
[18:06:30.609]                       }
[18:06:30.609]                       else if (inherits(cond, "warning")) {
[18:06:30.609]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.609]                         if (muffled) 
[18:06:30.609]                           invokeRestart("muffleWarning")
[18:06:30.609]                       }
[18:06:30.609]                       else if (inherits(cond, "condition")) {
[18:06:30.609]                         if (!is.null(pattern)) {
[18:06:30.609]                           computeRestarts <- base::computeRestarts
[18:06:30.609]                           grepl <- base::grepl
[18:06:30.609]                           restarts <- computeRestarts(cond)
[18:06:30.609]                           for (restart in restarts) {
[18:06:30.609]                             name <- restart$name
[18:06:30.609]                             if (is.null(name)) 
[18:06:30.609]                               next
[18:06:30.609]                             if (!grepl(pattern, name)) 
[18:06:30.609]                               next
[18:06:30.609]                             invokeRestart(restart)
[18:06:30.609]                             muffled <- TRUE
[18:06:30.609]                             break
[18:06:30.609]                           }
[18:06:30.609]                         }
[18:06:30.609]                       }
[18:06:30.609]                       invisible(muffled)
[18:06:30.609]                     }
[18:06:30.609]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.609]                   }
[18:06:30.609]                 }
[18:06:30.609]                 else {
[18:06:30.609]                   if (TRUE) {
[18:06:30.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.609]                     {
[18:06:30.609]                       inherits <- base::inherits
[18:06:30.609]                       invokeRestart <- base::invokeRestart
[18:06:30.609]                       is.null <- base::is.null
[18:06:30.609]                       muffled <- FALSE
[18:06:30.609]                       if (inherits(cond, "message")) {
[18:06:30.609]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.609]                         if (muffled) 
[18:06:30.609]                           invokeRestart("muffleMessage")
[18:06:30.609]                       }
[18:06:30.609]                       else if (inherits(cond, "warning")) {
[18:06:30.609]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.609]                         if (muffled) 
[18:06:30.609]                           invokeRestart("muffleWarning")
[18:06:30.609]                       }
[18:06:30.609]                       else if (inherits(cond, "condition")) {
[18:06:30.609]                         if (!is.null(pattern)) {
[18:06:30.609]                           computeRestarts <- base::computeRestarts
[18:06:30.609]                           grepl <- base::grepl
[18:06:30.609]                           restarts <- computeRestarts(cond)
[18:06:30.609]                           for (restart in restarts) {
[18:06:30.609]                             name <- restart$name
[18:06:30.609]                             if (is.null(name)) 
[18:06:30.609]                               next
[18:06:30.609]                             if (!grepl(pattern, name)) 
[18:06:30.609]                               next
[18:06:30.609]                             invokeRestart(restart)
[18:06:30.609]                             muffled <- TRUE
[18:06:30.609]                             break
[18:06:30.609]                           }
[18:06:30.609]                         }
[18:06:30.609]                       }
[18:06:30.609]                       invisible(muffled)
[18:06:30.609]                     }
[18:06:30.609]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.609]                   }
[18:06:30.609]                 }
[18:06:30.609]             }
[18:06:30.609]         }))
[18:06:30.609]     }, error = function(ex) {
[18:06:30.609]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.609]                 ...future.rng), started = ...future.startTime, 
[18:06:30.609]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.609]             version = "1.8"), class = "FutureResult")
[18:06:30.609]     }, finally = {
[18:06:30.609]         if (!identical(...future.workdir, getwd())) 
[18:06:30.609]             setwd(...future.workdir)
[18:06:30.609]         {
[18:06:30.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.609]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.609]             }
[18:06:30.609]             base::options(...future.oldOptions)
[18:06:30.609]             if (.Platform$OS.type == "windows") {
[18:06:30.609]                 old_names <- names(...future.oldEnvVars)
[18:06:30.609]                 envs <- base::Sys.getenv()
[18:06:30.609]                 names <- names(envs)
[18:06:30.609]                 common <- intersect(names, old_names)
[18:06:30.609]                 added <- setdiff(names, old_names)
[18:06:30.609]                 removed <- setdiff(old_names, names)
[18:06:30.609]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.609]                   envs[common]]
[18:06:30.609]                 NAMES <- toupper(changed)
[18:06:30.609]                 args <- list()
[18:06:30.609]                 for (kk in seq_along(NAMES)) {
[18:06:30.609]                   name <- changed[[kk]]
[18:06:30.609]                   NAME <- NAMES[[kk]]
[18:06:30.609]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.609]                     next
[18:06:30.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.609]                 }
[18:06:30.609]                 NAMES <- toupper(added)
[18:06:30.609]                 for (kk in seq_along(NAMES)) {
[18:06:30.609]                   name <- added[[kk]]
[18:06:30.609]                   NAME <- NAMES[[kk]]
[18:06:30.609]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.609]                     next
[18:06:30.609]                   args[[name]] <- ""
[18:06:30.609]                 }
[18:06:30.609]                 NAMES <- toupper(removed)
[18:06:30.609]                 for (kk in seq_along(NAMES)) {
[18:06:30.609]                   name <- removed[[kk]]
[18:06:30.609]                   NAME <- NAMES[[kk]]
[18:06:30.609]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.609]                     next
[18:06:30.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.609]                 }
[18:06:30.609]                 if (length(args) > 0) 
[18:06:30.609]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.609]             }
[18:06:30.609]             else {
[18:06:30.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.609]             }
[18:06:30.609]             {
[18:06:30.609]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.609]                   0L) {
[18:06:30.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.609]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.609]                   base::options(opts)
[18:06:30.609]                 }
[18:06:30.609]                 {
[18:06:30.609]                   {
[18:06:30.609]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.609]                     NULL
[18:06:30.609]                   }
[18:06:30.609]                   options(future.plan = NULL)
[18:06:30.609]                   if (is.na(NA_character_)) 
[18:06:30.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.609]                     .init = FALSE)
[18:06:30.609]                 }
[18:06:30.609]             }
[18:06:30.609]         }
[18:06:30.609]     })
[18:06:30.609]     if (TRUE) {
[18:06:30.609]         base::sink(type = "output", split = FALSE)
[18:06:30.609]         if (TRUE) {
[18:06:30.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.609]         }
[18:06:30.609]         else {
[18:06:30.609]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.609]         }
[18:06:30.609]         base::close(...future.stdout)
[18:06:30.609]         ...future.stdout <- NULL
[18:06:30.609]     }
[18:06:30.609]     ...future.result$conditions <- ...future.conditions
[18:06:30.609]     ...future.result$finished <- base::Sys.time()
[18:06:30.609]     ...future.result
[18:06:30.609] }
[18:06:30.614] MultisessionFuture started
[18:06:30.615] - Launch lazy future ... done
[18:06:30.615] run() for ‘MultisessionFuture’ ... done
[18:06:30.616] getGlobalsAndPackages() ...
[18:06:30.616] Searching for globals...
[18:06:30.618] - globals found: [2] ‘{’, ‘Sys.sleep’
[18:06:30.618] Searching for globals ... DONE
[18:06:30.618] Resolving globals: FALSE
[18:06:30.619] 
[18:06:30.619] 
[18:06:30.619] getGlobalsAndPackages() ... DONE
[18:06:30.619] run() for ‘Future’ ...
[18:06:30.620] - state: ‘created’
[18:06:30.620] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.644] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.645]   - Field: ‘node’
[18:06:30.645]   - Field: ‘label’
[18:06:30.645]   - Field: ‘local’
[18:06:30.646]   - Field: ‘owner’
[18:06:30.646]   - Field: ‘envir’
[18:06:30.646]   - Field: ‘workers’
[18:06:30.646]   - Field: ‘packages’
[18:06:30.646]   - Field: ‘gc’
[18:06:30.647]   - Field: ‘conditions’
[18:06:30.647]   - Field: ‘persistent’
[18:06:30.647]   - Field: ‘expr’
[18:06:30.647]   - Field: ‘uuid’
[18:06:30.647]   - Field: ‘seed’
[18:06:30.648]   - Field: ‘version’
[18:06:30.648]   - Field: ‘result’
[18:06:30.648]   - Field: ‘asynchronous’
[18:06:30.648]   - Field: ‘calls’
[18:06:30.648]   - Field: ‘globals’
[18:06:30.649]   - Field: ‘stdout’
[18:06:30.649]   - Field: ‘earlySignal’
[18:06:30.649]   - Field: ‘lazy’
[18:06:30.649]   - Field: ‘state’
[18:06:30.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.650] - Launch lazy future ...
[18:06:30.650] Packages needed by the future expression (n = 0): <none>
[18:06:30.650] Packages needed by future strategies (n = 0): <none>
[18:06:30.651] {
[18:06:30.651]     {
[18:06:30.651]         {
[18:06:30.651]             ...future.startTime <- base::Sys.time()
[18:06:30.651]             {
[18:06:30.651]                 {
[18:06:30.651]                   {
[18:06:30.651]                     {
[18:06:30.651]                       base::local({
[18:06:30.651]                         has_future <- base::requireNamespace("future", 
[18:06:30.651]                           quietly = TRUE)
[18:06:30.651]                         if (has_future) {
[18:06:30.651]                           ns <- base::getNamespace("future")
[18:06:30.651]                           version <- ns[[".package"]][["version"]]
[18:06:30.651]                           if (is.null(version)) 
[18:06:30.651]                             version <- utils::packageVersion("future")
[18:06:30.651]                         }
[18:06:30.651]                         else {
[18:06:30.651]                           version <- NULL
[18:06:30.651]                         }
[18:06:30.651]                         if (!has_future || version < "1.8.0") {
[18:06:30.651]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.651]                             "", base::R.version$version.string), 
[18:06:30.651]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.651]                               "release", "version")], collapse = " "), 
[18:06:30.651]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.651]                             info)
[18:06:30.651]                           info <- base::paste(info, collapse = "; ")
[18:06:30.651]                           if (!has_future) {
[18:06:30.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.651]                               info)
[18:06:30.651]                           }
[18:06:30.651]                           else {
[18:06:30.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.651]                               info, version)
[18:06:30.651]                           }
[18:06:30.651]                           base::stop(msg)
[18:06:30.651]                         }
[18:06:30.651]                       })
[18:06:30.651]                     }
[18:06:30.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.651]                     base::options(mc.cores = 1L)
[18:06:30.651]                   }
[18:06:30.651]                   ...future.strategy.old <- future::plan("list")
[18:06:30.651]                   options(future.plan = NULL)
[18:06:30.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.651]                 }
[18:06:30.651]                 ...future.workdir <- getwd()
[18:06:30.651]             }
[18:06:30.651]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.651]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.651]         }
[18:06:30.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.651]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.651]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.651]             base::names(...future.oldOptions))
[18:06:30.651]     }
[18:06:30.651]     if (FALSE) {
[18:06:30.651]     }
[18:06:30.651]     else {
[18:06:30.651]         if (TRUE) {
[18:06:30.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.651]                 open = "w")
[18:06:30.651]         }
[18:06:30.651]         else {
[18:06:30.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.651]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.651]         }
[18:06:30.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.651]             base::sink(type = "output", split = FALSE)
[18:06:30.651]             base::close(...future.stdout)
[18:06:30.651]         }, add = TRUE)
[18:06:30.651]     }
[18:06:30.651]     ...future.frame <- base::sys.nframe()
[18:06:30.651]     ...future.conditions <- base::list()
[18:06:30.651]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.651]     if (FALSE) {
[18:06:30.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.651]     }
[18:06:30.651]     ...future.result <- base::tryCatch({
[18:06:30.651]         base::withCallingHandlers({
[18:06:30.651]             ...future.value <- base::withVisible(base::local({
[18:06:30.651]                 ...future.makeSendCondition <- base::local({
[18:06:30.651]                   sendCondition <- NULL
[18:06:30.651]                   function(frame = 1L) {
[18:06:30.651]                     if (is.function(sendCondition)) 
[18:06:30.651]                       return(sendCondition)
[18:06:30.651]                     ns <- getNamespace("parallel")
[18:06:30.651]                     if (exists("sendData", mode = "function", 
[18:06:30.651]                       envir = ns)) {
[18:06:30.651]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.651]                         envir = ns)
[18:06:30.651]                       envir <- sys.frame(frame)
[18:06:30.651]                       master <- NULL
[18:06:30.651]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.651]                         !identical(envir, emptyenv())) {
[18:06:30.651]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.651]                           inherits = FALSE)) {
[18:06:30.651]                           master <- get("master", mode = "list", 
[18:06:30.651]                             envir = envir, inherits = FALSE)
[18:06:30.651]                           if (inherits(master, c("SOCKnode", 
[18:06:30.651]                             "SOCK0node"))) {
[18:06:30.651]                             sendCondition <<- function(cond) {
[18:06:30.651]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.651]                                 success = TRUE)
[18:06:30.651]                               parallel_sendData(master, data)
[18:06:30.651]                             }
[18:06:30.651]                             return(sendCondition)
[18:06:30.651]                           }
[18:06:30.651]                         }
[18:06:30.651]                         frame <- frame + 1L
[18:06:30.651]                         envir <- sys.frame(frame)
[18:06:30.651]                       }
[18:06:30.651]                     }
[18:06:30.651]                     sendCondition <<- function(cond) NULL
[18:06:30.651]                   }
[18:06:30.651]                 })
[18:06:30.651]                 withCallingHandlers({
[18:06:30.651]                   {
[18:06:30.651]                     Sys.sleep(0.5)
[18:06:30.651]                     2
[18:06:30.651]                   }
[18:06:30.651]                 }, immediateCondition = function(cond) {
[18:06:30.651]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.651]                   sendCondition(cond)
[18:06:30.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.651]                   {
[18:06:30.651]                     inherits <- base::inherits
[18:06:30.651]                     invokeRestart <- base::invokeRestart
[18:06:30.651]                     is.null <- base::is.null
[18:06:30.651]                     muffled <- FALSE
[18:06:30.651]                     if (inherits(cond, "message")) {
[18:06:30.651]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.651]                       if (muffled) 
[18:06:30.651]                         invokeRestart("muffleMessage")
[18:06:30.651]                     }
[18:06:30.651]                     else if (inherits(cond, "warning")) {
[18:06:30.651]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.651]                       if (muffled) 
[18:06:30.651]                         invokeRestart("muffleWarning")
[18:06:30.651]                     }
[18:06:30.651]                     else if (inherits(cond, "condition")) {
[18:06:30.651]                       if (!is.null(pattern)) {
[18:06:30.651]                         computeRestarts <- base::computeRestarts
[18:06:30.651]                         grepl <- base::grepl
[18:06:30.651]                         restarts <- computeRestarts(cond)
[18:06:30.651]                         for (restart in restarts) {
[18:06:30.651]                           name <- restart$name
[18:06:30.651]                           if (is.null(name)) 
[18:06:30.651]                             next
[18:06:30.651]                           if (!grepl(pattern, name)) 
[18:06:30.651]                             next
[18:06:30.651]                           invokeRestart(restart)
[18:06:30.651]                           muffled <- TRUE
[18:06:30.651]                           break
[18:06:30.651]                         }
[18:06:30.651]                       }
[18:06:30.651]                     }
[18:06:30.651]                     invisible(muffled)
[18:06:30.651]                   }
[18:06:30.651]                   muffleCondition(cond)
[18:06:30.651]                 })
[18:06:30.651]             }))
[18:06:30.651]             future::FutureResult(value = ...future.value$value, 
[18:06:30.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.651]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.651]                     ...future.globalenv.names))
[18:06:30.651]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.651]         }, condition = base::local({
[18:06:30.651]             c <- base::c
[18:06:30.651]             inherits <- base::inherits
[18:06:30.651]             invokeRestart <- base::invokeRestart
[18:06:30.651]             length <- base::length
[18:06:30.651]             list <- base::list
[18:06:30.651]             seq.int <- base::seq.int
[18:06:30.651]             signalCondition <- base::signalCondition
[18:06:30.651]             sys.calls <- base::sys.calls
[18:06:30.651]             `[[` <- base::`[[`
[18:06:30.651]             `+` <- base::`+`
[18:06:30.651]             `<<-` <- base::`<<-`
[18:06:30.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.651]                   3L)]
[18:06:30.651]             }
[18:06:30.651]             function(cond) {
[18:06:30.651]                 is_error <- inherits(cond, "error")
[18:06:30.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.651]                   NULL)
[18:06:30.651]                 if (is_error) {
[18:06:30.651]                   sessionInformation <- function() {
[18:06:30.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.651]                       search = base::search(), system = base::Sys.info())
[18:06:30.651]                   }
[18:06:30.651]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.651]                     cond$call), session = sessionInformation(), 
[18:06:30.651]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.651]                   signalCondition(cond)
[18:06:30.651]                 }
[18:06:30.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.651]                 "immediateCondition"))) {
[18:06:30.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.651]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.651]                   if (TRUE && !signal) {
[18:06:30.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.651]                     {
[18:06:30.651]                       inherits <- base::inherits
[18:06:30.651]                       invokeRestart <- base::invokeRestart
[18:06:30.651]                       is.null <- base::is.null
[18:06:30.651]                       muffled <- FALSE
[18:06:30.651]                       if (inherits(cond, "message")) {
[18:06:30.651]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.651]                         if (muffled) 
[18:06:30.651]                           invokeRestart("muffleMessage")
[18:06:30.651]                       }
[18:06:30.651]                       else if (inherits(cond, "warning")) {
[18:06:30.651]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.651]                         if (muffled) 
[18:06:30.651]                           invokeRestart("muffleWarning")
[18:06:30.651]                       }
[18:06:30.651]                       else if (inherits(cond, "condition")) {
[18:06:30.651]                         if (!is.null(pattern)) {
[18:06:30.651]                           computeRestarts <- base::computeRestarts
[18:06:30.651]                           grepl <- base::grepl
[18:06:30.651]                           restarts <- computeRestarts(cond)
[18:06:30.651]                           for (restart in restarts) {
[18:06:30.651]                             name <- restart$name
[18:06:30.651]                             if (is.null(name)) 
[18:06:30.651]                               next
[18:06:30.651]                             if (!grepl(pattern, name)) 
[18:06:30.651]                               next
[18:06:30.651]                             invokeRestart(restart)
[18:06:30.651]                             muffled <- TRUE
[18:06:30.651]                             break
[18:06:30.651]                           }
[18:06:30.651]                         }
[18:06:30.651]                       }
[18:06:30.651]                       invisible(muffled)
[18:06:30.651]                     }
[18:06:30.651]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.651]                   }
[18:06:30.651]                 }
[18:06:30.651]                 else {
[18:06:30.651]                   if (TRUE) {
[18:06:30.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.651]                     {
[18:06:30.651]                       inherits <- base::inherits
[18:06:30.651]                       invokeRestart <- base::invokeRestart
[18:06:30.651]                       is.null <- base::is.null
[18:06:30.651]                       muffled <- FALSE
[18:06:30.651]                       if (inherits(cond, "message")) {
[18:06:30.651]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.651]                         if (muffled) 
[18:06:30.651]                           invokeRestart("muffleMessage")
[18:06:30.651]                       }
[18:06:30.651]                       else if (inherits(cond, "warning")) {
[18:06:30.651]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.651]                         if (muffled) 
[18:06:30.651]                           invokeRestart("muffleWarning")
[18:06:30.651]                       }
[18:06:30.651]                       else if (inherits(cond, "condition")) {
[18:06:30.651]                         if (!is.null(pattern)) {
[18:06:30.651]                           computeRestarts <- base::computeRestarts
[18:06:30.651]                           grepl <- base::grepl
[18:06:30.651]                           restarts <- computeRestarts(cond)
[18:06:30.651]                           for (restart in restarts) {
[18:06:30.651]                             name <- restart$name
[18:06:30.651]                             if (is.null(name)) 
[18:06:30.651]                               next
[18:06:30.651]                             if (!grepl(pattern, name)) 
[18:06:30.651]                               next
[18:06:30.651]                             invokeRestart(restart)
[18:06:30.651]                             muffled <- TRUE
[18:06:30.651]                             break
[18:06:30.651]                           }
[18:06:30.651]                         }
[18:06:30.651]                       }
[18:06:30.651]                       invisible(muffled)
[18:06:30.651]                     }
[18:06:30.651]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.651]                   }
[18:06:30.651]                 }
[18:06:30.651]             }
[18:06:30.651]         }))
[18:06:30.651]     }, error = function(ex) {
[18:06:30.651]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.651]                 ...future.rng), started = ...future.startTime, 
[18:06:30.651]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.651]             version = "1.8"), class = "FutureResult")
[18:06:30.651]     }, finally = {
[18:06:30.651]         if (!identical(...future.workdir, getwd())) 
[18:06:30.651]             setwd(...future.workdir)
[18:06:30.651]         {
[18:06:30.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.651]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.651]             }
[18:06:30.651]             base::options(...future.oldOptions)
[18:06:30.651]             if (.Platform$OS.type == "windows") {
[18:06:30.651]                 old_names <- names(...future.oldEnvVars)
[18:06:30.651]                 envs <- base::Sys.getenv()
[18:06:30.651]                 names <- names(envs)
[18:06:30.651]                 common <- intersect(names, old_names)
[18:06:30.651]                 added <- setdiff(names, old_names)
[18:06:30.651]                 removed <- setdiff(old_names, names)
[18:06:30.651]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.651]                   envs[common]]
[18:06:30.651]                 NAMES <- toupper(changed)
[18:06:30.651]                 args <- list()
[18:06:30.651]                 for (kk in seq_along(NAMES)) {
[18:06:30.651]                   name <- changed[[kk]]
[18:06:30.651]                   NAME <- NAMES[[kk]]
[18:06:30.651]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.651]                     next
[18:06:30.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.651]                 }
[18:06:30.651]                 NAMES <- toupper(added)
[18:06:30.651]                 for (kk in seq_along(NAMES)) {
[18:06:30.651]                   name <- added[[kk]]
[18:06:30.651]                   NAME <- NAMES[[kk]]
[18:06:30.651]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.651]                     next
[18:06:30.651]                   args[[name]] <- ""
[18:06:30.651]                 }
[18:06:30.651]                 NAMES <- toupper(removed)
[18:06:30.651]                 for (kk in seq_along(NAMES)) {
[18:06:30.651]                   name <- removed[[kk]]
[18:06:30.651]                   NAME <- NAMES[[kk]]
[18:06:30.651]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.651]                     next
[18:06:30.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.651]                 }
[18:06:30.651]                 if (length(args) > 0) 
[18:06:30.651]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.651]             }
[18:06:30.651]             else {
[18:06:30.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.651]             }
[18:06:30.651]             {
[18:06:30.651]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.651]                   0L) {
[18:06:30.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.651]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.651]                   base::options(opts)
[18:06:30.651]                 }
[18:06:30.651]                 {
[18:06:30.651]                   {
[18:06:30.651]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.651]                     NULL
[18:06:30.651]                   }
[18:06:30.651]                   options(future.plan = NULL)
[18:06:30.651]                   if (is.na(NA_character_)) 
[18:06:30.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.651]                     .init = FALSE)
[18:06:30.651]                 }
[18:06:30.651]             }
[18:06:30.651]         }
[18:06:30.651]     })
[18:06:30.651]     if (TRUE) {
[18:06:30.651]         base::sink(type = "output", split = FALSE)
[18:06:30.651]         if (TRUE) {
[18:06:30.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.651]         }
[18:06:30.651]         else {
[18:06:30.651]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.651]         }
[18:06:30.651]         base::close(...future.stdout)
[18:06:30.651]         ...future.stdout <- NULL
[18:06:30.651]     }
[18:06:30.651]     ...future.result$conditions <- ...future.conditions
[18:06:30.651]     ...future.result$finished <- base::Sys.time()
[18:06:30.651]     ...future.result
[18:06:30.651] }
[18:06:30.657] MultisessionFuture started
[18:06:30.657] - Launch lazy future ... done
[18:06:30.657] run() for ‘MultisessionFuture’ ... done
[18:06:30.658] getGlobalsAndPackages() ...
[18:06:30.658] Searching for globals...
[18:06:30.660] - globals found: [1] ‘{’
[18:06:30.660] Searching for globals ... DONE
[18:06:30.660] Resolving globals: FALSE
[18:06:30.661] 
[18:06:30.661] 
[18:06:30.661] getGlobalsAndPackages() ... DONE
[18:06:30.661] run() for ‘Future’ ...
[18:06:30.662] - state: ‘created’
[18:06:30.662] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:06:30.687] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:06:30.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:06:30.687]   - Field: ‘node’
[18:06:30.688]   - Field: ‘label’
[18:06:30.688]   - Field: ‘local’
[18:06:30.688]   - Field: ‘owner’
[18:06:30.688]   - Field: ‘envir’
[18:06:30.688]   - Field: ‘workers’
[18:06:30.689]   - Field: ‘packages’
[18:06:30.689]   - Field: ‘gc’
[18:06:30.689]   - Field: ‘conditions’
[18:06:30.689]   - Field: ‘persistent’
[18:06:30.689]   - Field: ‘expr’
[18:06:30.690]   - Field: ‘uuid’
[18:06:30.690]   - Field: ‘seed’
[18:06:30.690]   - Field: ‘version’
[18:06:30.690]   - Field: ‘result’
[18:06:30.690]   - Field: ‘asynchronous’
[18:06:30.691]   - Field: ‘calls’
[18:06:30.691]   - Field: ‘globals’
[18:06:30.691]   - Field: ‘stdout’
[18:06:30.691]   - Field: ‘earlySignal’
[18:06:30.691]   - Field: ‘lazy’
[18:06:30.692]   - Field: ‘state’
[18:06:30.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:06:30.692] - Launch lazy future ...
[18:06:30.692] Packages needed by the future expression (n = 0): <none>
[18:06:30.693] Packages needed by future strategies (n = 0): <none>
[18:06:30.694] {
[18:06:30.694]     {
[18:06:30.694]         {
[18:06:30.694]             ...future.startTime <- base::Sys.time()
[18:06:30.694]             {
[18:06:30.694]                 {
[18:06:30.694]                   {
[18:06:30.694]                     {
[18:06:30.694]                       base::local({
[18:06:30.694]                         has_future <- base::requireNamespace("future", 
[18:06:30.694]                           quietly = TRUE)
[18:06:30.694]                         if (has_future) {
[18:06:30.694]                           ns <- base::getNamespace("future")
[18:06:30.694]                           version <- ns[[".package"]][["version"]]
[18:06:30.694]                           if (is.null(version)) 
[18:06:30.694]                             version <- utils::packageVersion("future")
[18:06:30.694]                         }
[18:06:30.694]                         else {
[18:06:30.694]                           version <- NULL
[18:06:30.694]                         }
[18:06:30.694]                         if (!has_future || version < "1.8.0") {
[18:06:30.694]                           info <- base::c(r_version = base::gsub("R version ", 
[18:06:30.694]                             "", base::R.version$version.string), 
[18:06:30.694]                             platform = base::sprintf("%s (%s-bit)", 
[18:06:30.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:06:30.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:06:30.694]                               "release", "version")], collapse = " "), 
[18:06:30.694]                             hostname = base::Sys.info()[["nodename"]])
[18:06:30.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:06:30.694]                             info)
[18:06:30.694]                           info <- base::paste(info, collapse = "; ")
[18:06:30.694]                           if (!has_future) {
[18:06:30.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:06:30.694]                               info)
[18:06:30.694]                           }
[18:06:30.694]                           else {
[18:06:30.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:06:30.694]                               info, version)
[18:06:30.694]                           }
[18:06:30.694]                           base::stop(msg)
[18:06:30.694]                         }
[18:06:30.694]                       })
[18:06:30.694]                     }
[18:06:30.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:06:30.694]                     base::options(mc.cores = 1L)
[18:06:30.694]                   }
[18:06:30.694]                   ...future.strategy.old <- future::plan("list")
[18:06:30.694]                   options(future.plan = NULL)
[18:06:30.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:06:30.694]                 }
[18:06:30.694]                 ...future.workdir <- getwd()
[18:06:30.694]             }
[18:06:30.694]             ...future.oldOptions <- base::as.list(base::.Options)
[18:06:30.694]             ...future.oldEnvVars <- base::Sys.getenv()
[18:06:30.694]         }
[18:06:30.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:06:30.694]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:06:30.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:06:30.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:06:30.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:06:30.694]             future.stdout.windows.reencode = NULL, width = 80L)
[18:06:30.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:06:30.694]             base::names(...future.oldOptions))
[18:06:30.694]     }
[18:06:30.694]     if (FALSE) {
[18:06:30.694]     }
[18:06:30.694]     else {
[18:06:30.694]         if (TRUE) {
[18:06:30.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:06:30.694]                 open = "w")
[18:06:30.694]         }
[18:06:30.694]         else {
[18:06:30.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:06:30.694]                 windows = "NUL", "/dev/null"), open = "w")
[18:06:30.694]         }
[18:06:30.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:06:30.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:06:30.694]             base::sink(type = "output", split = FALSE)
[18:06:30.694]             base::close(...future.stdout)
[18:06:30.694]         }, add = TRUE)
[18:06:30.694]     }
[18:06:30.694]     ...future.frame <- base::sys.nframe()
[18:06:30.694]     ...future.conditions <- base::list()
[18:06:30.694]     ...future.rng <- base::globalenv()$.Random.seed
[18:06:30.694]     if (FALSE) {
[18:06:30.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:06:30.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:06:30.694]     }
[18:06:30.694]     ...future.result <- base::tryCatch({
[18:06:30.694]         base::withCallingHandlers({
[18:06:30.694]             ...future.value <- base::withVisible(base::local({
[18:06:30.694]                 ...future.makeSendCondition <- base::local({
[18:06:30.694]                   sendCondition <- NULL
[18:06:30.694]                   function(frame = 1L) {
[18:06:30.694]                     if (is.function(sendCondition)) 
[18:06:30.694]                       return(sendCondition)
[18:06:30.694]                     ns <- getNamespace("parallel")
[18:06:30.694]                     if (exists("sendData", mode = "function", 
[18:06:30.694]                       envir = ns)) {
[18:06:30.694]                       parallel_sendData <- get("sendData", mode = "function", 
[18:06:30.694]                         envir = ns)
[18:06:30.694]                       envir <- sys.frame(frame)
[18:06:30.694]                       master <- NULL
[18:06:30.694]                       while (!identical(envir, .GlobalEnv) && 
[18:06:30.694]                         !identical(envir, emptyenv())) {
[18:06:30.694]                         if (exists("master", mode = "list", envir = envir, 
[18:06:30.694]                           inherits = FALSE)) {
[18:06:30.694]                           master <- get("master", mode = "list", 
[18:06:30.694]                             envir = envir, inherits = FALSE)
[18:06:30.694]                           if (inherits(master, c("SOCKnode", 
[18:06:30.694]                             "SOCK0node"))) {
[18:06:30.694]                             sendCondition <<- function(cond) {
[18:06:30.694]                               data <- list(type = "VALUE", value = cond, 
[18:06:30.694]                                 success = TRUE)
[18:06:30.694]                               parallel_sendData(master, data)
[18:06:30.694]                             }
[18:06:30.694]                             return(sendCondition)
[18:06:30.694]                           }
[18:06:30.694]                         }
[18:06:30.694]                         frame <- frame + 1L
[18:06:30.694]                         envir <- sys.frame(frame)
[18:06:30.694]                       }
[18:06:30.694]                     }
[18:06:30.694]                     sendCondition <<- function(cond) NULL
[18:06:30.694]                   }
[18:06:30.694]                 })
[18:06:30.694]                 withCallingHandlers({
[18:06:30.694]                   {
[18:06:30.694]                     3
[18:06:30.694]                   }
[18:06:30.694]                 }, immediateCondition = function(cond) {
[18:06:30.694]                   sendCondition <- ...future.makeSendCondition()
[18:06:30.694]                   sendCondition(cond)
[18:06:30.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.694]                   {
[18:06:30.694]                     inherits <- base::inherits
[18:06:30.694]                     invokeRestart <- base::invokeRestart
[18:06:30.694]                     is.null <- base::is.null
[18:06:30.694]                     muffled <- FALSE
[18:06:30.694]                     if (inherits(cond, "message")) {
[18:06:30.694]                       muffled <- grepl(pattern, "muffleMessage")
[18:06:30.694]                       if (muffled) 
[18:06:30.694]                         invokeRestart("muffleMessage")
[18:06:30.694]                     }
[18:06:30.694]                     else if (inherits(cond, "warning")) {
[18:06:30.694]                       muffled <- grepl(pattern, "muffleWarning")
[18:06:30.694]                       if (muffled) 
[18:06:30.694]                         invokeRestart("muffleWarning")
[18:06:30.694]                     }
[18:06:30.694]                     else if (inherits(cond, "condition")) {
[18:06:30.694]                       if (!is.null(pattern)) {
[18:06:30.694]                         computeRestarts <- base::computeRestarts
[18:06:30.694]                         grepl <- base::grepl
[18:06:30.694]                         restarts <- computeRestarts(cond)
[18:06:30.694]                         for (restart in restarts) {
[18:06:30.694]                           name <- restart$name
[18:06:30.694]                           if (is.null(name)) 
[18:06:30.694]                             next
[18:06:30.694]                           if (!grepl(pattern, name)) 
[18:06:30.694]                             next
[18:06:30.694]                           invokeRestart(restart)
[18:06:30.694]                           muffled <- TRUE
[18:06:30.694]                           break
[18:06:30.694]                         }
[18:06:30.694]                       }
[18:06:30.694]                     }
[18:06:30.694]                     invisible(muffled)
[18:06:30.694]                   }
[18:06:30.694]                   muffleCondition(cond)
[18:06:30.694]                 })
[18:06:30.694]             }))
[18:06:30.694]             future::FutureResult(value = ...future.value$value, 
[18:06:30.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.694]                   ...future.rng), globalenv = if (FALSE) 
[18:06:30.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:06:30.694]                     ...future.globalenv.names))
[18:06:30.694]                 else NULL, started = ...future.startTime, version = "1.8")
[18:06:30.694]         }, condition = base::local({
[18:06:30.694]             c <- base::c
[18:06:30.694]             inherits <- base::inherits
[18:06:30.694]             invokeRestart <- base::invokeRestart
[18:06:30.694]             length <- base::length
[18:06:30.694]             list <- base::list
[18:06:30.694]             seq.int <- base::seq.int
[18:06:30.694]             signalCondition <- base::signalCondition
[18:06:30.694]             sys.calls <- base::sys.calls
[18:06:30.694]             `[[` <- base::`[[`
[18:06:30.694]             `+` <- base::`+`
[18:06:30.694]             `<<-` <- base::`<<-`
[18:06:30.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:06:30.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:06:30.694]                   3L)]
[18:06:30.694]             }
[18:06:30.694]             function(cond) {
[18:06:30.694]                 is_error <- inherits(cond, "error")
[18:06:30.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:06:30.694]                   NULL)
[18:06:30.694]                 if (is_error) {
[18:06:30.694]                   sessionInformation <- function() {
[18:06:30.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:06:30.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:06:30.694]                       search = base::search(), system = base::Sys.info())
[18:06:30.694]                   }
[18:06:30.694]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:06:30.694]                     cond$call), session = sessionInformation(), 
[18:06:30.694]                     timestamp = base::Sys.time(), signaled = 0L)
[18:06:30.694]                   signalCondition(cond)
[18:06:30.694]                 }
[18:06:30.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:06:30.694]                 "immediateCondition"))) {
[18:06:30.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:06:30.694]                   ...future.conditions[[length(...future.conditions) + 
[18:06:30.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:06:30.694]                   if (TRUE && !signal) {
[18:06:30.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.694]                     {
[18:06:30.694]                       inherits <- base::inherits
[18:06:30.694]                       invokeRestart <- base::invokeRestart
[18:06:30.694]                       is.null <- base::is.null
[18:06:30.694]                       muffled <- FALSE
[18:06:30.694]                       if (inherits(cond, "message")) {
[18:06:30.694]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.694]                         if (muffled) 
[18:06:30.694]                           invokeRestart("muffleMessage")
[18:06:30.694]                       }
[18:06:30.694]                       else if (inherits(cond, "warning")) {
[18:06:30.694]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.694]                         if (muffled) 
[18:06:30.694]                           invokeRestart("muffleWarning")
[18:06:30.694]                       }
[18:06:30.694]                       else if (inherits(cond, "condition")) {
[18:06:30.694]                         if (!is.null(pattern)) {
[18:06:30.694]                           computeRestarts <- base::computeRestarts
[18:06:30.694]                           grepl <- base::grepl
[18:06:30.694]                           restarts <- computeRestarts(cond)
[18:06:30.694]                           for (restart in restarts) {
[18:06:30.694]                             name <- restart$name
[18:06:30.694]                             if (is.null(name)) 
[18:06:30.694]                               next
[18:06:30.694]                             if (!grepl(pattern, name)) 
[18:06:30.694]                               next
[18:06:30.694]                             invokeRestart(restart)
[18:06:30.694]                             muffled <- TRUE
[18:06:30.694]                             break
[18:06:30.694]                           }
[18:06:30.694]                         }
[18:06:30.694]                       }
[18:06:30.694]                       invisible(muffled)
[18:06:30.694]                     }
[18:06:30.694]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.694]                   }
[18:06:30.694]                 }
[18:06:30.694]                 else {
[18:06:30.694]                   if (TRUE) {
[18:06:30.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:06:30.694]                     {
[18:06:30.694]                       inherits <- base::inherits
[18:06:30.694]                       invokeRestart <- base::invokeRestart
[18:06:30.694]                       is.null <- base::is.null
[18:06:30.694]                       muffled <- FALSE
[18:06:30.694]                       if (inherits(cond, "message")) {
[18:06:30.694]                         muffled <- grepl(pattern, "muffleMessage")
[18:06:30.694]                         if (muffled) 
[18:06:30.694]                           invokeRestart("muffleMessage")
[18:06:30.694]                       }
[18:06:30.694]                       else if (inherits(cond, "warning")) {
[18:06:30.694]                         muffled <- grepl(pattern, "muffleWarning")
[18:06:30.694]                         if (muffled) 
[18:06:30.694]                           invokeRestart("muffleWarning")
[18:06:30.694]                       }
[18:06:30.694]                       else if (inherits(cond, "condition")) {
[18:06:30.694]                         if (!is.null(pattern)) {
[18:06:30.694]                           computeRestarts <- base::computeRestarts
[18:06:30.694]                           grepl <- base::grepl
[18:06:30.694]                           restarts <- computeRestarts(cond)
[18:06:30.694]                           for (restart in restarts) {
[18:06:30.694]                             name <- restart$name
[18:06:30.694]                             if (is.null(name)) 
[18:06:30.694]                               next
[18:06:30.694]                             if (!grepl(pattern, name)) 
[18:06:30.694]                               next
[18:06:30.694]                             invokeRestart(restart)
[18:06:30.694]                             muffled <- TRUE
[18:06:30.694]                             break
[18:06:30.694]                           }
[18:06:30.694]                         }
[18:06:30.694]                       }
[18:06:30.694]                       invisible(muffled)
[18:06:30.694]                     }
[18:06:30.694]                     muffleCondition(cond, pattern = "^muffle")
[18:06:30.694]                   }
[18:06:30.694]                 }
[18:06:30.694]             }
[18:06:30.694]         }))
[18:06:30.694]     }, error = function(ex) {
[18:06:30.694]         base::structure(base::list(value = NULL, visible = NULL, 
[18:06:30.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:06:30.694]                 ...future.rng), started = ...future.startTime, 
[18:06:30.694]             finished = Sys.time(), session_uuid = NA_character_, 
[18:06:30.694]             version = "1.8"), class = "FutureResult")
[18:06:30.694]     }, finally = {
[18:06:30.694]         if (!identical(...future.workdir, getwd())) 
[18:06:30.694]             setwd(...future.workdir)
[18:06:30.694]         {
[18:06:30.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:06:30.694]                 ...future.oldOptions$nwarnings <- NULL
[18:06:30.694]             }
[18:06:30.694]             base::options(...future.oldOptions)
[18:06:30.694]             if (.Platform$OS.type == "windows") {
[18:06:30.694]                 old_names <- names(...future.oldEnvVars)
[18:06:30.694]                 envs <- base::Sys.getenv()
[18:06:30.694]                 names <- names(envs)
[18:06:30.694]                 common <- intersect(names, old_names)
[18:06:30.694]                 added <- setdiff(names, old_names)
[18:06:30.694]                 removed <- setdiff(old_names, names)
[18:06:30.694]                 changed <- common[...future.oldEnvVars[common] != 
[18:06:30.694]                   envs[common]]
[18:06:30.694]                 NAMES <- toupper(changed)
[18:06:30.694]                 args <- list()
[18:06:30.694]                 for (kk in seq_along(NAMES)) {
[18:06:30.694]                   name <- changed[[kk]]
[18:06:30.694]                   NAME <- NAMES[[kk]]
[18:06:30.694]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.694]                     next
[18:06:30.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.694]                 }
[18:06:30.694]                 NAMES <- toupper(added)
[18:06:30.694]                 for (kk in seq_along(NAMES)) {
[18:06:30.694]                   name <- added[[kk]]
[18:06:30.694]                   NAME <- NAMES[[kk]]
[18:06:30.694]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.694]                     next
[18:06:30.694]                   args[[name]] <- ""
[18:06:30.694]                 }
[18:06:30.694]                 NAMES <- toupper(removed)
[18:06:30.694]                 for (kk in seq_along(NAMES)) {
[18:06:30.694]                   name <- removed[[kk]]
[18:06:30.694]                   NAME <- NAMES[[kk]]
[18:06:30.694]                   if (name != NAME && is.element(NAME, old_names)) 
[18:06:30.694]                     next
[18:06:30.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:06:30.694]                 }
[18:06:30.694]                 if (length(args) > 0) 
[18:06:30.694]                   base::do.call(base::Sys.setenv, args = args)
[18:06:30.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:06:30.694]             }
[18:06:30.694]             else {
[18:06:30.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:06:30.694]             }
[18:06:30.694]             {
[18:06:30.694]                 if (base::length(...future.futureOptionsAdded) > 
[18:06:30.694]                   0L) {
[18:06:30.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:06:30.694]                   base::names(opts) <- ...future.futureOptionsAdded
[18:06:30.694]                   base::options(opts)
[18:06:30.694]                 }
[18:06:30.694]                 {
[18:06:30.694]                   {
[18:06:30.694]                     base::options(mc.cores = ...future.mc.cores.old)
[18:06:30.694]                     NULL
[18:06:30.694]                   }
[18:06:30.694]                   options(future.plan = NULL)
[18:06:30.694]                   if (is.na(NA_character_)) 
[18:06:30.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:06:30.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:06:30.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:06:30.694]                     .init = FALSE)
[18:06:30.694]                 }
[18:06:30.694]             }
[18:06:30.694]         }
[18:06:30.694]     })
[18:06:30.694]     if (TRUE) {
[18:06:30.694]         base::sink(type = "output", split = FALSE)
[18:06:30.694]         if (TRUE) {
[18:06:30.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:06:30.694]         }
[18:06:30.694]         else {
[18:06:30.694]             ...future.result["stdout"] <- base::list(NULL)
[18:06:30.694]         }
[18:06:30.694]         base::close(...future.stdout)
[18:06:30.694]         ...future.stdout <- NULL
[18:06:30.694]     }
[18:06:30.694]     ...future.result$conditions <- ...future.conditions
[18:06:30.694]     ...future.result$finished <- base::Sys.time()
[18:06:30.694]     ...future.result
[18:06:30.694] }
[18:06:30.698] Poll #1 (0): usedNodes() = 2, workers = 2
[18:06:30.709] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.710] - Validating connection of MultisessionFuture
[18:06:30.710] - received message: FutureResult
[18:06:30.710] - Received FutureResult
[18:06:30.711] - Erased future from FutureRegistry
[18:06:30.711] result() for ClusterFuture ...
[18:06:30.711] - result already collected: FutureResult
[18:06:30.711] result() for ClusterFuture ... done
[18:06:30.711] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.712] result() for ClusterFuture ...
[18:06:30.712] - result already collected: FutureResult
[18:06:30.712] result() for ClusterFuture ... done
[18:06:30.712] result() for ClusterFuture ...
[18:06:30.713] - result already collected: FutureResult
[18:06:30.713] result() for ClusterFuture ... done
[18:06:30.715] MultisessionFuture started
[18:06:30.715] - Launch lazy future ... done
[18:06:30.716] run() for ‘MultisessionFuture’ ... done
[18:06:30.722] resolve() on list environment ...
[18:06:30.722]  recursive: 0
[18:06:30.724]  length: 4
[18:06:30.724]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:30.724] Future #1
[18:06:30.725]  length: 3 (resolved future 1)
[18:06:30.747]  length: 2 (resolved future 4)
[18:06:30.770] receiveMessageFromWorker() for ClusterFuture ...
[18:06:30.770] - Validating connection of MultisessionFuture
[18:06:30.770] - received message: FutureResult
[18:06:30.771] - Received FutureResult
[18:06:30.771] - Erased future from FutureRegistry
[18:06:30.772] result() for ClusterFuture ...
[18:06:30.772] - result already collected: FutureResult
[18:06:30.772] result() for ClusterFuture ... done
[18:06:30.772] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:30.772] Future #3
[18:06:30.773]  length: 1 (resolved future 3)
[18:06:31.212] receiveMessageFromWorker() for ClusterFuture ...
[18:06:31.213] - Validating connection of MultisessionFuture
[18:06:31.213] - received message: FutureResult
[18:06:31.214] - Received FutureResult
[18:06:31.214] - Erased future from FutureRegistry
[18:06:31.215] result() for ClusterFuture ...
[18:06:31.215] - result already collected: FutureResult
[18:06:31.215] result() for ClusterFuture ... done
[18:06:31.215] receiveMessageFromWorker() for ClusterFuture ... done
[18:06:31.216] Future #2
[18:06:31.216]  length: 0 (resolved future 2)
[18:06:31.216] resolve() on list environment ... DONE
[18:06:31.217] resolve() on list environment ...
[18:06:31.218]  recursive: 0
[18:06:31.220]  length: 4
[18:06:31.220]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:31.221] Future #1
[18:06:31.221]  length: 3 (resolved future 1)
[18:06:31.221] Future #2
[18:06:31.222]  length: 2 (resolved future 2)
[18:06:31.222] Future #3
[18:06:31.223]  length: 1 (resolved future 3)
[18:06:31.223]  length: 0 (resolved future 4)
[18:06:31.223] resolve() on list environment ... DONE
[18:06:31.225] resolve() on list environment ...
[18:06:31.225]  recursive: 0
[18:06:31.227]  length: 4
[18:06:31.228]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:31.228] Future #1
[18:06:31.229]  length: 3 (resolved future 1)
[18:06:31.229] Future #2
[18:06:31.229]  length: 2 (resolved future 2)
[18:06:31.230] Future #3
[18:06:31.230]  length: 1 (resolved future 3)
[18:06:31.231]  length: 0 (resolved future 4)
[18:06:31.231] resolve() on list environment ... DONE
[18:06:31.233] resolve() on list environment ...
[18:06:31.233]  recursive: 0
[18:06:31.235]  length: 4
[18:06:31.235]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:31.236] Future #1
[18:06:31.236]  length: 3 (resolved future 1)
[18:06:31.237] Future #2
[18:06:31.237]  length: 2 (resolved future 2)
[18:06:31.237] Future #3
[18:06:31.238]  length: 1 (resolved future 3)
[18:06:31.238]  length: 0 (resolved future 4)
[18:06:31.238] resolve() on list environment ... DONE
[18:06:31.240] resolve() on list environment ...
[18:06:31.240]  recursive: 0
[18:06:31.242]  length: 4
[18:06:31.243]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:31.243] Future #1
[18:06:31.244] result() for ClusterFuture ...
[18:06:31.244] - result already collected: FutureResult
[18:06:31.244] result() for ClusterFuture ... done
[18:06:31.245] result() for ClusterFuture ...
[18:06:31.245] - result already collected: FutureResult
[18:06:31.245] result() for ClusterFuture ... done
[18:06:31.246]  length: 3 (resolved future 1)
[18:06:31.246] Future #2
[18:06:31.246] result() for ClusterFuture ...
[18:06:31.247] - result already collected: FutureResult
[18:06:31.247] result() for ClusterFuture ... done
[18:06:31.247] result() for ClusterFuture ...
[18:06:31.247] - result already collected: FutureResult
[18:06:31.248] result() for ClusterFuture ... done
[18:06:31.248]  length: 2 (resolved future 2)
[18:06:31.249] Future #3
[18:06:31.249] result() for ClusterFuture ...
[18:06:31.249] - result already collected: FutureResult
[18:06:31.249] result() for ClusterFuture ... done
[18:06:31.250] result() for ClusterFuture ...
[18:06:31.250] - result already collected: FutureResult
[18:06:31.250] result() for ClusterFuture ... done
[18:06:31.251]  length: 1 (resolved future 3)
[18:06:31.251]  length: 0 (resolved future 4)
[18:06:31.252] resolve() on list environment ... DONE
[18:06:31.253] resolve() on list environment ...
[18:06:31.254]  recursive: 99
[18:06:31.256]  length: 4
[18:06:31.256]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[18:06:31.257] Future #1
[18:06:31.257] result() for ClusterFuture ...
[18:06:31.257] - result already collected: FutureResult
[18:06:31.258] result() for ClusterFuture ... done
[18:06:31.258] result() for ClusterFuture ...
[18:06:31.259] - result already collected: FutureResult
[18:06:31.259] result() for ClusterFuture ... done
[18:06:31.260] A MultisessionFuture was resolved
[18:06:31.260]  length: 3 (resolved future 1)
[18:06:31.260] Future #2
[18:06:31.261] result() for ClusterFuture ...
[18:06:31.261] - result already collected: FutureResult
[18:06:31.261] result() for ClusterFuture ... done
[18:06:31.262] result() for ClusterFuture ...
[18:06:31.262] - result already collected: FutureResult
[18:06:31.262] result() for ClusterFuture ... done
[18:06:31.263] A MultisessionFuture was resolved
[18:06:31.263]  length: 2 (resolved future 2)
[18:06:31.263] Future #3
[18:06:31.264] result() for ClusterFuture ...
[18:06:31.264] - result already collected: FutureResult
[18:06:31.264] result() for ClusterFuture ... done
[18:06:31.264] result() for ClusterFuture ...
[18:06:31.265] - result already collected: FutureResult
[18:06:31.265] result() for ClusterFuture ... done
[18:06:31.265] A MultisessionFuture was resolved
[18:06:31.266]  length: 1 (resolved future 3)
[18:06:31.266]  length: 0 (resolved future 4)
[18:06:31.266] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[18:06:31.275] resolve() on list ...
[18:06:31.275]  recursive: 0
[18:06:31.276]  length: 3
[18:06:31.276] 
[18:06:31.276]  length: 2 (resolved future 1)
[18:06:31.276]  length: 1 (resolved future 2)
[18:06:31.277]  length: 0 (resolved future 3)
[18:06:31.277] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[18:06:31.279] plan(): Setting new future strategy stack:
[18:06:31.279] List of future strategies:
[18:06:31.279] 1. FutureStrategy:
[18:06:31.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:06:31.279]    - tweaked: FALSE
[18:06:31.279]    - call: future::plan(oplan)
[18:06:31.281] plan(): nbrOfWorkers() = 1
> 
