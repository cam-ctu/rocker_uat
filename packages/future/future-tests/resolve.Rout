
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:47:51.344] plan(): Setting new future strategy stack:
[17:47:51.344] List of future strategies:
[17:47:51.344] 1. sequential:
[17:47:51.344]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.344]    - tweaked: FALSE
[17:47:51.344]    - call: future::plan("sequential")
[17:47:51.355] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[17:47:51.539] plan(): Setting new future strategy stack:
[17:47:51.540] List of future strategies:
[17:47:51.540] 1. sequential:
[17:47:51.540]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.540]    - tweaked: FALSE
[17:47:51.540]    - call: plan(strategy)
[17:47:51.550] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[17:47:51.550] resolve() on list ...
[17:47:51.550]  recursive: 0
[17:47:51.551]  length: 2
[17:47:51.551]  elements: ‘a’, ‘b’
[17:47:51.552]  length: 1 (resolved future 1)
[17:47:51.552]  length: 0 (resolved future 2)
[17:47:51.552] resolve() on list ... DONE
[17:47:51.553] getGlobalsAndPackages() ...
[17:47:51.553] Searching for globals...
[17:47:51.555] 
[17:47:51.555] Searching for globals ... DONE
[17:47:51.555] - globals: [0] <none>
[17:47:51.555] getGlobalsAndPackages() ... DONE
[17:47:51.556] run() for ‘Future’ ...
[17:47:51.556] - state: ‘created’
[17:47:51.556] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.557] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.557]   - Field: ‘label’
[17:47:51.557]   - Field: ‘local’
[17:47:51.557]   - Field: ‘owner’
[17:47:51.557]   - Field: ‘envir’
[17:47:51.557]   - Field: ‘packages’
[17:47:51.557]   - Field: ‘gc’
[17:47:51.557]   - Field: ‘conditions’
[17:47:51.557]   - Field: ‘expr’
[17:47:51.558]   - Field: ‘uuid’
[17:47:51.558]   - Field: ‘seed’
[17:47:51.558]   - Field: ‘version’
[17:47:51.558]   - Field: ‘result’
[17:47:51.558]   - Field: ‘asynchronous’
[17:47:51.558]   - Field: ‘calls’
[17:47:51.558]   - Field: ‘globals’
[17:47:51.558]   - Field: ‘stdout’
[17:47:51.558]   - Field: ‘earlySignal’
[17:47:51.558]   - Field: ‘lazy’
[17:47:51.558]   - Field: ‘state’
[17:47:51.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.559] - Launch lazy future ...
[17:47:51.559] Packages needed by the future expression (n = 0): <none>
[17:47:51.559] Packages needed by future strategies (n = 0): <none>
[17:47:51.560] {
[17:47:51.560]     {
[17:47:51.560]         {
[17:47:51.560]             ...future.startTime <- base::Sys.time()
[17:47:51.560]             {
[17:47:51.560]                 {
[17:47:51.560]                   {
[17:47:51.560]                     base::local({
[17:47:51.560]                       has_future <- base::requireNamespace("future", 
[17:47:51.560]                         quietly = TRUE)
[17:47:51.560]                       if (has_future) {
[17:47:51.560]                         ns <- base::getNamespace("future")
[17:47:51.560]                         version <- ns[[".package"]][["version"]]
[17:47:51.560]                         if (is.null(version)) 
[17:47:51.560]                           version <- utils::packageVersion("future")
[17:47:51.560]                       }
[17:47:51.560]                       else {
[17:47:51.560]                         version <- NULL
[17:47:51.560]                       }
[17:47:51.560]                       if (!has_future || version < "1.8.0") {
[17:47:51.560]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.560]                           "", base::R.version$version.string), 
[17:47:51.560]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.560]                             "release", "version")], collapse = " "), 
[17:47:51.560]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.560]                           info)
[17:47:51.560]                         info <- base::paste(info, collapse = "; ")
[17:47:51.560]                         if (!has_future) {
[17:47:51.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.560]                             info)
[17:47:51.560]                         }
[17:47:51.560]                         else {
[17:47:51.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.560]                             info, version)
[17:47:51.560]                         }
[17:47:51.560]                         base::stop(msg)
[17:47:51.560]                       }
[17:47:51.560]                     })
[17:47:51.560]                   }
[17:47:51.560]                   ...future.strategy.old <- future::plan("list")
[17:47:51.560]                   options(future.plan = NULL)
[17:47:51.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.560]                 }
[17:47:51.560]                 ...future.workdir <- getwd()
[17:47:51.560]             }
[17:47:51.560]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.560]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.560]         }
[17:47:51.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.560]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.560]             base::names(...future.oldOptions))
[17:47:51.560]     }
[17:47:51.560]     if (FALSE) {
[17:47:51.560]     }
[17:47:51.560]     else {
[17:47:51.560]         if (TRUE) {
[17:47:51.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.560]                 open = "w")
[17:47:51.560]         }
[17:47:51.560]         else {
[17:47:51.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.560]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.560]         }
[17:47:51.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.560]             base::sink(type = "output", split = FALSE)
[17:47:51.560]             base::close(...future.stdout)
[17:47:51.560]         }, add = TRUE)
[17:47:51.560]     }
[17:47:51.560]     ...future.frame <- base::sys.nframe()
[17:47:51.560]     ...future.conditions <- base::list()
[17:47:51.560]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.560]     if (FALSE) {
[17:47:51.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.560]     }
[17:47:51.560]     ...future.result <- base::tryCatch({
[17:47:51.560]         base::withCallingHandlers({
[17:47:51.560]             ...future.value <- base::withVisible(base::local(1))
[17:47:51.560]             future::FutureResult(value = ...future.value$value, 
[17:47:51.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.560]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.560]                     ...future.globalenv.names))
[17:47:51.560]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.560]         }, condition = base::local({
[17:47:51.560]             c <- base::c
[17:47:51.560]             inherits <- base::inherits
[17:47:51.560]             invokeRestart <- base::invokeRestart
[17:47:51.560]             length <- base::length
[17:47:51.560]             list <- base::list
[17:47:51.560]             seq.int <- base::seq.int
[17:47:51.560]             signalCondition <- base::signalCondition
[17:47:51.560]             sys.calls <- base::sys.calls
[17:47:51.560]             `[[` <- base::`[[`
[17:47:51.560]             `+` <- base::`+`
[17:47:51.560]             `<<-` <- base::`<<-`
[17:47:51.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.560]                   3L)]
[17:47:51.560]             }
[17:47:51.560]             function(cond) {
[17:47:51.560]                 is_error <- inherits(cond, "error")
[17:47:51.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.560]                   NULL)
[17:47:51.560]                 if (is_error) {
[17:47:51.560]                   sessionInformation <- function() {
[17:47:51.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.560]                       search = base::search(), system = base::Sys.info())
[17:47:51.560]                   }
[17:47:51.560]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.560]                     cond$call), session = sessionInformation(), 
[17:47:51.560]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.560]                   signalCondition(cond)
[17:47:51.560]                 }
[17:47:51.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.560]                 "immediateCondition"))) {
[17:47:51.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.560]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.560]                   if (TRUE && !signal) {
[17:47:51.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.560]                     {
[17:47:51.560]                       inherits <- base::inherits
[17:47:51.560]                       invokeRestart <- base::invokeRestart
[17:47:51.560]                       is.null <- base::is.null
[17:47:51.560]                       muffled <- FALSE
[17:47:51.560]                       if (inherits(cond, "message")) {
[17:47:51.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.560]                         if (muffled) 
[17:47:51.560]                           invokeRestart("muffleMessage")
[17:47:51.560]                       }
[17:47:51.560]                       else if (inherits(cond, "warning")) {
[17:47:51.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.560]                         if (muffled) 
[17:47:51.560]                           invokeRestart("muffleWarning")
[17:47:51.560]                       }
[17:47:51.560]                       else if (inherits(cond, "condition")) {
[17:47:51.560]                         if (!is.null(pattern)) {
[17:47:51.560]                           computeRestarts <- base::computeRestarts
[17:47:51.560]                           grepl <- base::grepl
[17:47:51.560]                           restarts <- computeRestarts(cond)
[17:47:51.560]                           for (restart in restarts) {
[17:47:51.560]                             name <- restart$name
[17:47:51.560]                             if (is.null(name)) 
[17:47:51.560]                               next
[17:47:51.560]                             if (!grepl(pattern, name)) 
[17:47:51.560]                               next
[17:47:51.560]                             invokeRestart(restart)
[17:47:51.560]                             muffled <- TRUE
[17:47:51.560]                             break
[17:47:51.560]                           }
[17:47:51.560]                         }
[17:47:51.560]                       }
[17:47:51.560]                       invisible(muffled)
[17:47:51.560]                     }
[17:47:51.560]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.560]                   }
[17:47:51.560]                 }
[17:47:51.560]                 else {
[17:47:51.560]                   if (TRUE) {
[17:47:51.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.560]                     {
[17:47:51.560]                       inherits <- base::inherits
[17:47:51.560]                       invokeRestart <- base::invokeRestart
[17:47:51.560]                       is.null <- base::is.null
[17:47:51.560]                       muffled <- FALSE
[17:47:51.560]                       if (inherits(cond, "message")) {
[17:47:51.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.560]                         if (muffled) 
[17:47:51.560]                           invokeRestart("muffleMessage")
[17:47:51.560]                       }
[17:47:51.560]                       else if (inherits(cond, "warning")) {
[17:47:51.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.560]                         if (muffled) 
[17:47:51.560]                           invokeRestart("muffleWarning")
[17:47:51.560]                       }
[17:47:51.560]                       else if (inherits(cond, "condition")) {
[17:47:51.560]                         if (!is.null(pattern)) {
[17:47:51.560]                           computeRestarts <- base::computeRestarts
[17:47:51.560]                           grepl <- base::grepl
[17:47:51.560]                           restarts <- computeRestarts(cond)
[17:47:51.560]                           for (restart in restarts) {
[17:47:51.560]                             name <- restart$name
[17:47:51.560]                             if (is.null(name)) 
[17:47:51.560]                               next
[17:47:51.560]                             if (!grepl(pattern, name)) 
[17:47:51.560]                               next
[17:47:51.560]                             invokeRestart(restart)
[17:47:51.560]                             muffled <- TRUE
[17:47:51.560]                             break
[17:47:51.560]                           }
[17:47:51.560]                         }
[17:47:51.560]                       }
[17:47:51.560]                       invisible(muffled)
[17:47:51.560]                     }
[17:47:51.560]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.560]                   }
[17:47:51.560]                 }
[17:47:51.560]             }
[17:47:51.560]         }))
[17:47:51.560]     }, error = function(ex) {
[17:47:51.560]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.560]                 ...future.rng), started = ...future.startTime, 
[17:47:51.560]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.560]             version = "1.8"), class = "FutureResult")
[17:47:51.560]     }, finally = {
[17:47:51.560]         if (!identical(...future.workdir, getwd())) 
[17:47:51.560]             setwd(...future.workdir)
[17:47:51.560]         {
[17:47:51.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.560]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.560]             }
[17:47:51.560]             base::options(...future.oldOptions)
[17:47:51.560]             if (.Platform$OS.type == "windows") {
[17:47:51.560]                 old_names <- names(...future.oldEnvVars)
[17:47:51.560]                 envs <- base::Sys.getenv()
[17:47:51.560]                 names <- names(envs)
[17:47:51.560]                 common <- intersect(names, old_names)
[17:47:51.560]                 added <- setdiff(names, old_names)
[17:47:51.560]                 removed <- setdiff(old_names, names)
[17:47:51.560]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.560]                   envs[common]]
[17:47:51.560]                 NAMES <- toupper(changed)
[17:47:51.560]                 args <- list()
[17:47:51.560]                 for (kk in seq_along(NAMES)) {
[17:47:51.560]                   name <- changed[[kk]]
[17:47:51.560]                   NAME <- NAMES[[kk]]
[17:47:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.560]                     next
[17:47:51.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.560]                 }
[17:47:51.560]                 NAMES <- toupper(added)
[17:47:51.560]                 for (kk in seq_along(NAMES)) {
[17:47:51.560]                   name <- added[[kk]]
[17:47:51.560]                   NAME <- NAMES[[kk]]
[17:47:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.560]                     next
[17:47:51.560]                   args[[name]] <- ""
[17:47:51.560]                 }
[17:47:51.560]                 NAMES <- toupper(removed)
[17:47:51.560]                 for (kk in seq_along(NAMES)) {
[17:47:51.560]                   name <- removed[[kk]]
[17:47:51.560]                   NAME <- NAMES[[kk]]
[17:47:51.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.560]                     next
[17:47:51.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.560]                 }
[17:47:51.560]                 if (length(args) > 0) 
[17:47:51.560]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.560]             }
[17:47:51.560]             else {
[17:47:51.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.560]             }
[17:47:51.560]             {
[17:47:51.560]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.560]                   0L) {
[17:47:51.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.560]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.560]                   base::options(opts)
[17:47:51.560]                 }
[17:47:51.560]                 {
[17:47:51.560]                   {
[17:47:51.560]                     NULL
[17:47:51.560]                     RNGkind("Mersenne-Twister")
[17:47:51.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.560]                       inherits = FALSE)
[17:47:51.560]                   }
[17:47:51.560]                   options(future.plan = NULL)
[17:47:51.560]                   if (is.na(NA_character_)) 
[17:47:51.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.560]                     .init = FALSE)
[17:47:51.560]                 }
[17:47:51.560]             }
[17:47:51.560]         }
[17:47:51.560]     })
[17:47:51.560]     if (TRUE) {
[17:47:51.560]         base::sink(type = "output", split = FALSE)
[17:47:51.560]         if (TRUE) {
[17:47:51.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.560]         }
[17:47:51.560]         else {
[17:47:51.560]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.560]         }
[17:47:51.560]         base::close(...future.stdout)
[17:47:51.560]         ...future.stdout <- NULL
[17:47:51.560]     }
[17:47:51.560]     ...future.result$conditions <- ...future.conditions
[17:47:51.560]     ...future.result$finished <- base::Sys.time()
[17:47:51.560]     ...future.result
[17:47:51.560] }
[17:47:51.562] plan(): Setting new future strategy stack:
[17:47:51.562] List of future strategies:
[17:47:51.562] 1. sequential:
[17:47:51.562]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.562]    - tweaked: FALSE
[17:47:51.562]    - call: NULL
[17:47:51.563] plan(): nbrOfWorkers() = 1
[17:47:51.564] plan(): Setting new future strategy stack:
[17:47:51.564] List of future strategies:
[17:47:51.564] 1. sequential:
[17:47:51.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.564]    - tweaked: FALSE
[17:47:51.564]    - call: plan(strategy)
[17:47:51.564] plan(): nbrOfWorkers() = 1
[17:47:51.564] SequentialFuture started (and completed)
[17:47:51.565] - Launch lazy future ... done
[17:47:51.565] run() for ‘SequentialFuture’ ... done
[17:47:51.565] getGlobalsAndPackages() ...
[17:47:51.565] Searching for globals...
[17:47:51.565] 
[17:47:51.565] Searching for globals ... DONE
[17:47:51.566] - globals: [0] <none>
[17:47:51.566] getGlobalsAndPackages() ... DONE
[17:47:51.566] run() for ‘Future’ ...
[17:47:51.566] - state: ‘created’
[17:47:51.566] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.566] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.566] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.566]   - Field: ‘label’
[17:47:51.567]   - Field: ‘local’
[17:47:51.567]   - Field: ‘owner’
[17:47:51.567]   - Field: ‘envir’
[17:47:51.567]   - Field: ‘packages’
[17:47:51.567]   - Field: ‘gc’
[17:47:51.567]   - Field: ‘conditions’
[17:47:51.567]   - Field: ‘expr’
[17:47:51.567]   - Field: ‘uuid’
[17:47:51.567]   - Field: ‘seed’
[17:47:51.567]   - Field: ‘version’
[17:47:51.567]   - Field: ‘result’
[17:47:51.568]   - Field: ‘asynchronous’
[17:47:51.568]   - Field: ‘calls’
[17:47:51.568]   - Field: ‘globals’
[17:47:51.568]   - Field: ‘stdout’
[17:47:51.568]   - Field: ‘earlySignal’
[17:47:51.568]   - Field: ‘lazy’
[17:47:51.568]   - Field: ‘state’
[17:47:51.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.568] - Launch lazy future ...
[17:47:51.568] Packages needed by the future expression (n = 0): <none>
[17:47:51.568] Packages needed by future strategies (n = 0): <none>
[17:47:51.569] {
[17:47:51.569]     {
[17:47:51.569]         {
[17:47:51.569]             ...future.startTime <- base::Sys.time()
[17:47:51.569]             {
[17:47:51.569]                 {
[17:47:51.569]                   {
[17:47:51.569]                     base::local({
[17:47:51.569]                       has_future <- base::requireNamespace("future", 
[17:47:51.569]                         quietly = TRUE)
[17:47:51.569]                       if (has_future) {
[17:47:51.569]                         ns <- base::getNamespace("future")
[17:47:51.569]                         version <- ns[[".package"]][["version"]]
[17:47:51.569]                         if (is.null(version)) 
[17:47:51.569]                           version <- utils::packageVersion("future")
[17:47:51.569]                       }
[17:47:51.569]                       else {
[17:47:51.569]                         version <- NULL
[17:47:51.569]                       }
[17:47:51.569]                       if (!has_future || version < "1.8.0") {
[17:47:51.569]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.569]                           "", base::R.version$version.string), 
[17:47:51.569]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.569]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.569]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.569]                             "release", "version")], collapse = " "), 
[17:47:51.569]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.569]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.569]                           info)
[17:47:51.569]                         info <- base::paste(info, collapse = "; ")
[17:47:51.569]                         if (!has_future) {
[17:47:51.569]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.569]                             info)
[17:47:51.569]                         }
[17:47:51.569]                         else {
[17:47:51.569]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.569]                             info, version)
[17:47:51.569]                         }
[17:47:51.569]                         base::stop(msg)
[17:47:51.569]                       }
[17:47:51.569]                     })
[17:47:51.569]                   }
[17:47:51.569]                   ...future.strategy.old <- future::plan("list")
[17:47:51.569]                   options(future.plan = NULL)
[17:47:51.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.569]                 }
[17:47:51.569]                 ...future.workdir <- getwd()
[17:47:51.569]             }
[17:47:51.569]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.569]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.569]         }
[17:47:51.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.569]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.569]             base::names(...future.oldOptions))
[17:47:51.569]     }
[17:47:51.569]     if (FALSE) {
[17:47:51.569]     }
[17:47:51.569]     else {
[17:47:51.569]         if (TRUE) {
[17:47:51.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.569]                 open = "w")
[17:47:51.569]         }
[17:47:51.569]         else {
[17:47:51.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.569]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.569]         }
[17:47:51.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.569]             base::sink(type = "output", split = FALSE)
[17:47:51.569]             base::close(...future.stdout)
[17:47:51.569]         }, add = TRUE)
[17:47:51.569]     }
[17:47:51.569]     ...future.frame <- base::sys.nframe()
[17:47:51.569]     ...future.conditions <- base::list()
[17:47:51.569]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.569]     if (FALSE) {
[17:47:51.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.569]     }
[17:47:51.569]     ...future.result <- base::tryCatch({
[17:47:51.569]         base::withCallingHandlers({
[17:47:51.569]             ...future.value <- base::withVisible(base::local(2))
[17:47:51.569]             future::FutureResult(value = ...future.value$value, 
[17:47:51.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.569]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.569]                     ...future.globalenv.names))
[17:47:51.569]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.569]         }, condition = base::local({
[17:47:51.569]             c <- base::c
[17:47:51.569]             inherits <- base::inherits
[17:47:51.569]             invokeRestart <- base::invokeRestart
[17:47:51.569]             length <- base::length
[17:47:51.569]             list <- base::list
[17:47:51.569]             seq.int <- base::seq.int
[17:47:51.569]             signalCondition <- base::signalCondition
[17:47:51.569]             sys.calls <- base::sys.calls
[17:47:51.569]             `[[` <- base::`[[`
[17:47:51.569]             `+` <- base::`+`
[17:47:51.569]             `<<-` <- base::`<<-`
[17:47:51.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.569]                   3L)]
[17:47:51.569]             }
[17:47:51.569]             function(cond) {
[17:47:51.569]                 is_error <- inherits(cond, "error")
[17:47:51.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.569]                   NULL)
[17:47:51.569]                 if (is_error) {
[17:47:51.569]                   sessionInformation <- function() {
[17:47:51.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.569]                       search = base::search(), system = base::Sys.info())
[17:47:51.569]                   }
[17:47:51.569]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.569]                     cond$call), session = sessionInformation(), 
[17:47:51.569]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.569]                   signalCondition(cond)
[17:47:51.569]                 }
[17:47:51.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.569]                 "immediateCondition"))) {
[17:47:51.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.569]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.569]                   if (TRUE && !signal) {
[17:47:51.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.569]                     {
[17:47:51.569]                       inherits <- base::inherits
[17:47:51.569]                       invokeRestart <- base::invokeRestart
[17:47:51.569]                       is.null <- base::is.null
[17:47:51.569]                       muffled <- FALSE
[17:47:51.569]                       if (inherits(cond, "message")) {
[17:47:51.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.569]                         if (muffled) 
[17:47:51.569]                           invokeRestart("muffleMessage")
[17:47:51.569]                       }
[17:47:51.569]                       else if (inherits(cond, "warning")) {
[17:47:51.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.569]                         if (muffled) 
[17:47:51.569]                           invokeRestart("muffleWarning")
[17:47:51.569]                       }
[17:47:51.569]                       else if (inherits(cond, "condition")) {
[17:47:51.569]                         if (!is.null(pattern)) {
[17:47:51.569]                           computeRestarts <- base::computeRestarts
[17:47:51.569]                           grepl <- base::grepl
[17:47:51.569]                           restarts <- computeRestarts(cond)
[17:47:51.569]                           for (restart in restarts) {
[17:47:51.569]                             name <- restart$name
[17:47:51.569]                             if (is.null(name)) 
[17:47:51.569]                               next
[17:47:51.569]                             if (!grepl(pattern, name)) 
[17:47:51.569]                               next
[17:47:51.569]                             invokeRestart(restart)
[17:47:51.569]                             muffled <- TRUE
[17:47:51.569]                             break
[17:47:51.569]                           }
[17:47:51.569]                         }
[17:47:51.569]                       }
[17:47:51.569]                       invisible(muffled)
[17:47:51.569]                     }
[17:47:51.569]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.569]                   }
[17:47:51.569]                 }
[17:47:51.569]                 else {
[17:47:51.569]                   if (TRUE) {
[17:47:51.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.569]                     {
[17:47:51.569]                       inherits <- base::inherits
[17:47:51.569]                       invokeRestart <- base::invokeRestart
[17:47:51.569]                       is.null <- base::is.null
[17:47:51.569]                       muffled <- FALSE
[17:47:51.569]                       if (inherits(cond, "message")) {
[17:47:51.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.569]                         if (muffled) 
[17:47:51.569]                           invokeRestart("muffleMessage")
[17:47:51.569]                       }
[17:47:51.569]                       else if (inherits(cond, "warning")) {
[17:47:51.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.569]                         if (muffled) 
[17:47:51.569]                           invokeRestart("muffleWarning")
[17:47:51.569]                       }
[17:47:51.569]                       else if (inherits(cond, "condition")) {
[17:47:51.569]                         if (!is.null(pattern)) {
[17:47:51.569]                           computeRestarts <- base::computeRestarts
[17:47:51.569]                           grepl <- base::grepl
[17:47:51.569]                           restarts <- computeRestarts(cond)
[17:47:51.569]                           for (restart in restarts) {
[17:47:51.569]                             name <- restart$name
[17:47:51.569]                             if (is.null(name)) 
[17:47:51.569]                               next
[17:47:51.569]                             if (!grepl(pattern, name)) 
[17:47:51.569]                               next
[17:47:51.569]                             invokeRestart(restart)
[17:47:51.569]                             muffled <- TRUE
[17:47:51.569]                             break
[17:47:51.569]                           }
[17:47:51.569]                         }
[17:47:51.569]                       }
[17:47:51.569]                       invisible(muffled)
[17:47:51.569]                     }
[17:47:51.569]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.569]                   }
[17:47:51.569]                 }
[17:47:51.569]             }
[17:47:51.569]         }))
[17:47:51.569]     }, error = function(ex) {
[17:47:51.569]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.569]                 ...future.rng), started = ...future.startTime, 
[17:47:51.569]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.569]             version = "1.8"), class = "FutureResult")
[17:47:51.569]     }, finally = {
[17:47:51.569]         if (!identical(...future.workdir, getwd())) 
[17:47:51.569]             setwd(...future.workdir)
[17:47:51.569]         {
[17:47:51.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.569]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.569]             }
[17:47:51.569]             base::options(...future.oldOptions)
[17:47:51.569]             if (.Platform$OS.type == "windows") {
[17:47:51.569]                 old_names <- names(...future.oldEnvVars)
[17:47:51.569]                 envs <- base::Sys.getenv()
[17:47:51.569]                 names <- names(envs)
[17:47:51.569]                 common <- intersect(names, old_names)
[17:47:51.569]                 added <- setdiff(names, old_names)
[17:47:51.569]                 removed <- setdiff(old_names, names)
[17:47:51.569]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.569]                   envs[common]]
[17:47:51.569]                 NAMES <- toupper(changed)
[17:47:51.569]                 args <- list()
[17:47:51.569]                 for (kk in seq_along(NAMES)) {
[17:47:51.569]                   name <- changed[[kk]]
[17:47:51.569]                   NAME <- NAMES[[kk]]
[17:47:51.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.569]                     next
[17:47:51.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.569]                 }
[17:47:51.569]                 NAMES <- toupper(added)
[17:47:51.569]                 for (kk in seq_along(NAMES)) {
[17:47:51.569]                   name <- added[[kk]]
[17:47:51.569]                   NAME <- NAMES[[kk]]
[17:47:51.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.569]                     next
[17:47:51.569]                   args[[name]] <- ""
[17:47:51.569]                 }
[17:47:51.569]                 NAMES <- toupper(removed)
[17:47:51.569]                 for (kk in seq_along(NAMES)) {
[17:47:51.569]                   name <- removed[[kk]]
[17:47:51.569]                   NAME <- NAMES[[kk]]
[17:47:51.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.569]                     next
[17:47:51.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.569]                 }
[17:47:51.569]                 if (length(args) > 0) 
[17:47:51.569]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.569]             }
[17:47:51.569]             else {
[17:47:51.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.569]             }
[17:47:51.569]             {
[17:47:51.569]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.569]                   0L) {
[17:47:51.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.569]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.569]                   base::options(opts)
[17:47:51.569]                 }
[17:47:51.569]                 {
[17:47:51.569]                   {
[17:47:51.569]                     NULL
[17:47:51.569]                     RNGkind("Mersenne-Twister")
[17:47:51.569]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.569]                       inherits = FALSE)
[17:47:51.569]                   }
[17:47:51.569]                   options(future.plan = NULL)
[17:47:51.569]                   if (is.na(NA_character_)) 
[17:47:51.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.569]                     .init = FALSE)
[17:47:51.569]                 }
[17:47:51.569]             }
[17:47:51.569]         }
[17:47:51.569]     })
[17:47:51.569]     if (TRUE) {
[17:47:51.569]         base::sink(type = "output", split = FALSE)
[17:47:51.569]         if (TRUE) {
[17:47:51.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.569]         }
[17:47:51.569]         else {
[17:47:51.569]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.569]         }
[17:47:51.569]         base::close(...future.stdout)
[17:47:51.569]         ...future.stdout <- NULL
[17:47:51.569]     }
[17:47:51.569]     ...future.result$conditions <- ...future.conditions
[17:47:51.569]     ...future.result$finished <- base::Sys.time()
[17:47:51.569]     ...future.result
[17:47:51.569] }
[17:47:51.571] plan(): Setting new future strategy stack:
[17:47:51.571] List of future strategies:
[17:47:51.571] 1. sequential:
[17:47:51.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.571]    - tweaked: FALSE
[17:47:51.571]    - call: NULL
[17:47:51.571] plan(): nbrOfWorkers() = 1
[17:47:51.572] plan(): Setting new future strategy stack:
[17:47:51.572] List of future strategies:
[17:47:51.572] 1. sequential:
[17:47:51.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.572]    - tweaked: FALSE
[17:47:51.572]    - call: plan(strategy)
[17:47:51.572] plan(): nbrOfWorkers() = 1
[17:47:51.572] SequentialFuture started (and completed)
[17:47:51.573] - Launch lazy future ... done
[17:47:51.573] run() for ‘SequentialFuture’ ... done
[17:47:51.573] resolve() on list ...
[17:47:51.573]  recursive: 0
[17:47:51.573]  length: 3
[17:47:51.573]  elements: ‘a’, ‘b’, ‘’
[17:47:51.573] resolved() for ‘SequentialFuture’ ...
[17:47:51.573] - state: ‘finished’
[17:47:51.573] - run: TRUE
[17:47:51.573] - result: ‘FutureResult’
[17:47:51.574] resolved() for ‘SequentialFuture’ ... done
[17:47:51.574] Future #1
[17:47:51.574]  length: 2 (resolved future 1)
[17:47:51.574] resolved() for ‘SequentialFuture’ ...
[17:47:51.574] - state: ‘finished’
[17:47:51.574] - run: TRUE
[17:47:51.574] - result: ‘FutureResult’
[17:47:51.574] resolved() for ‘SequentialFuture’ ... done
[17:47:51.574] Future #2
[17:47:51.574]  length: 1 (resolved future 2)
[17:47:51.575]  length: 0 (resolved future 3)
[17:47:51.575] resolve() on list ... DONE
[17:47:51.575] resolved() for ‘SequentialFuture’ ...
[17:47:51.575] - state: ‘finished’
[17:47:51.575] - run: TRUE
[17:47:51.575] - result: ‘FutureResult’
[17:47:51.575] resolved() for ‘SequentialFuture’ ... done
[17:47:51.575] resolved() for ‘SequentialFuture’ ...
[17:47:51.575] - state: ‘finished’
[17:47:51.575] - run: TRUE
[17:47:51.576] - result: ‘FutureResult’
[17:47:51.576] resolved() for ‘SequentialFuture’ ... done
[17:47:51.576] getGlobalsAndPackages() ...
[17:47:51.576] Searching for globals...
[17:47:51.576] 
[17:47:51.576] Searching for globals ... DONE
[17:47:51.576] - globals: [0] <none>
[17:47:51.576] getGlobalsAndPackages() ... DONE
[17:47:51.577] getGlobalsAndPackages() ...
[17:47:51.577] Searching for globals...
[17:47:51.577] 
[17:47:51.577] Searching for globals ... DONE
[17:47:51.577] - globals: [0] <none>
[17:47:51.577] getGlobalsAndPackages() ... DONE
[17:47:51.577] run() for ‘Future’ ...
[17:47:51.577] - state: ‘created’
[17:47:51.578] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.578] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.578]   - Field: ‘label’
[17:47:51.578]   - Field: ‘local’
[17:47:51.578]   - Field: ‘owner’
[17:47:51.578]   - Field: ‘envir’
[17:47:51.578]   - Field: ‘packages’
[17:47:51.578]   - Field: ‘gc’
[17:47:51.579]   - Field: ‘conditions’
[17:47:51.579]   - Field: ‘expr’
[17:47:51.579]   - Field: ‘uuid’
[17:47:51.579]   - Field: ‘seed’
[17:47:51.579]   - Field: ‘version’
[17:47:51.579]   - Field: ‘result’
[17:47:51.579]   - Field: ‘asynchronous’
[17:47:51.579]   - Field: ‘calls’
[17:47:51.579]   - Field: ‘globals’
[17:47:51.579]   - Field: ‘stdout’
[17:47:51.579]   - Field: ‘earlySignal’
[17:47:51.580]   - Field: ‘lazy’
[17:47:51.580]   - Field: ‘state’
[17:47:51.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.580] - Launch lazy future ...
[17:47:51.580] Packages needed by the future expression (n = 0): <none>
[17:47:51.580] Packages needed by future strategies (n = 0): <none>
[17:47:51.580] {
[17:47:51.580]     {
[17:47:51.580]         {
[17:47:51.580]             ...future.startTime <- base::Sys.time()
[17:47:51.580]             {
[17:47:51.580]                 {
[17:47:51.580]                   {
[17:47:51.580]                     base::local({
[17:47:51.580]                       has_future <- base::requireNamespace("future", 
[17:47:51.580]                         quietly = TRUE)
[17:47:51.580]                       if (has_future) {
[17:47:51.580]                         ns <- base::getNamespace("future")
[17:47:51.580]                         version <- ns[[".package"]][["version"]]
[17:47:51.580]                         if (is.null(version)) 
[17:47:51.580]                           version <- utils::packageVersion("future")
[17:47:51.580]                       }
[17:47:51.580]                       else {
[17:47:51.580]                         version <- NULL
[17:47:51.580]                       }
[17:47:51.580]                       if (!has_future || version < "1.8.0") {
[17:47:51.580]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.580]                           "", base::R.version$version.string), 
[17:47:51.580]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.580]                             "release", "version")], collapse = " "), 
[17:47:51.580]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.580]                           info)
[17:47:51.580]                         info <- base::paste(info, collapse = "; ")
[17:47:51.580]                         if (!has_future) {
[17:47:51.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.580]                             info)
[17:47:51.580]                         }
[17:47:51.580]                         else {
[17:47:51.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.580]                             info, version)
[17:47:51.580]                         }
[17:47:51.580]                         base::stop(msg)
[17:47:51.580]                       }
[17:47:51.580]                     })
[17:47:51.580]                   }
[17:47:51.580]                   ...future.strategy.old <- future::plan("list")
[17:47:51.580]                   options(future.plan = NULL)
[17:47:51.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.580]                 }
[17:47:51.580]                 ...future.workdir <- getwd()
[17:47:51.580]             }
[17:47:51.580]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.580]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.580]         }
[17:47:51.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.580]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.580]             base::names(...future.oldOptions))
[17:47:51.580]     }
[17:47:51.580]     if (FALSE) {
[17:47:51.580]     }
[17:47:51.580]     else {
[17:47:51.580]         if (TRUE) {
[17:47:51.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.580]                 open = "w")
[17:47:51.580]         }
[17:47:51.580]         else {
[17:47:51.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.580]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.580]         }
[17:47:51.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.580]             base::sink(type = "output", split = FALSE)
[17:47:51.580]             base::close(...future.stdout)
[17:47:51.580]         }, add = TRUE)
[17:47:51.580]     }
[17:47:51.580]     ...future.frame <- base::sys.nframe()
[17:47:51.580]     ...future.conditions <- base::list()
[17:47:51.580]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.580]     if (FALSE) {
[17:47:51.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.580]     }
[17:47:51.580]     ...future.result <- base::tryCatch({
[17:47:51.580]         base::withCallingHandlers({
[17:47:51.580]             ...future.value <- base::withVisible(base::local(2))
[17:47:51.580]             future::FutureResult(value = ...future.value$value, 
[17:47:51.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.580]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.580]                     ...future.globalenv.names))
[17:47:51.580]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.580]         }, condition = base::local({
[17:47:51.580]             c <- base::c
[17:47:51.580]             inherits <- base::inherits
[17:47:51.580]             invokeRestart <- base::invokeRestart
[17:47:51.580]             length <- base::length
[17:47:51.580]             list <- base::list
[17:47:51.580]             seq.int <- base::seq.int
[17:47:51.580]             signalCondition <- base::signalCondition
[17:47:51.580]             sys.calls <- base::sys.calls
[17:47:51.580]             `[[` <- base::`[[`
[17:47:51.580]             `+` <- base::`+`
[17:47:51.580]             `<<-` <- base::`<<-`
[17:47:51.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.580]                   3L)]
[17:47:51.580]             }
[17:47:51.580]             function(cond) {
[17:47:51.580]                 is_error <- inherits(cond, "error")
[17:47:51.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.580]                   NULL)
[17:47:51.580]                 if (is_error) {
[17:47:51.580]                   sessionInformation <- function() {
[17:47:51.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.580]                       search = base::search(), system = base::Sys.info())
[17:47:51.580]                   }
[17:47:51.580]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.580]                     cond$call), session = sessionInformation(), 
[17:47:51.580]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.580]                   signalCondition(cond)
[17:47:51.580]                 }
[17:47:51.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.580]                 "immediateCondition"))) {
[17:47:51.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.580]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.580]                   if (TRUE && !signal) {
[17:47:51.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.580]                     {
[17:47:51.580]                       inherits <- base::inherits
[17:47:51.580]                       invokeRestart <- base::invokeRestart
[17:47:51.580]                       is.null <- base::is.null
[17:47:51.580]                       muffled <- FALSE
[17:47:51.580]                       if (inherits(cond, "message")) {
[17:47:51.580]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.580]                         if (muffled) 
[17:47:51.580]                           invokeRestart("muffleMessage")
[17:47:51.580]                       }
[17:47:51.580]                       else if (inherits(cond, "warning")) {
[17:47:51.580]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.580]                         if (muffled) 
[17:47:51.580]                           invokeRestart("muffleWarning")
[17:47:51.580]                       }
[17:47:51.580]                       else if (inherits(cond, "condition")) {
[17:47:51.580]                         if (!is.null(pattern)) {
[17:47:51.580]                           computeRestarts <- base::computeRestarts
[17:47:51.580]                           grepl <- base::grepl
[17:47:51.580]                           restarts <- computeRestarts(cond)
[17:47:51.580]                           for (restart in restarts) {
[17:47:51.580]                             name <- restart$name
[17:47:51.580]                             if (is.null(name)) 
[17:47:51.580]                               next
[17:47:51.580]                             if (!grepl(pattern, name)) 
[17:47:51.580]                               next
[17:47:51.580]                             invokeRestart(restart)
[17:47:51.580]                             muffled <- TRUE
[17:47:51.580]                             break
[17:47:51.580]                           }
[17:47:51.580]                         }
[17:47:51.580]                       }
[17:47:51.580]                       invisible(muffled)
[17:47:51.580]                     }
[17:47:51.580]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.580]                   }
[17:47:51.580]                 }
[17:47:51.580]                 else {
[17:47:51.580]                   if (TRUE) {
[17:47:51.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.580]                     {
[17:47:51.580]                       inherits <- base::inherits
[17:47:51.580]                       invokeRestart <- base::invokeRestart
[17:47:51.580]                       is.null <- base::is.null
[17:47:51.580]                       muffled <- FALSE
[17:47:51.580]                       if (inherits(cond, "message")) {
[17:47:51.580]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.580]                         if (muffled) 
[17:47:51.580]                           invokeRestart("muffleMessage")
[17:47:51.580]                       }
[17:47:51.580]                       else if (inherits(cond, "warning")) {
[17:47:51.580]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.580]                         if (muffled) 
[17:47:51.580]                           invokeRestart("muffleWarning")
[17:47:51.580]                       }
[17:47:51.580]                       else if (inherits(cond, "condition")) {
[17:47:51.580]                         if (!is.null(pattern)) {
[17:47:51.580]                           computeRestarts <- base::computeRestarts
[17:47:51.580]                           grepl <- base::grepl
[17:47:51.580]                           restarts <- computeRestarts(cond)
[17:47:51.580]                           for (restart in restarts) {
[17:47:51.580]                             name <- restart$name
[17:47:51.580]                             if (is.null(name)) 
[17:47:51.580]                               next
[17:47:51.580]                             if (!grepl(pattern, name)) 
[17:47:51.580]                               next
[17:47:51.580]                             invokeRestart(restart)
[17:47:51.580]                             muffled <- TRUE
[17:47:51.580]                             break
[17:47:51.580]                           }
[17:47:51.580]                         }
[17:47:51.580]                       }
[17:47:51.580]                       invisible(muffled)
[17:47:51.580]                     }
[17:47:51.580]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.580]                   }
[17:47:51.580]                 }
[17:47:51.580]             }
[17:47:51.580]         }))
[17:47:51.580]     }, error = function(ex) {
[17:47:51.580]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.580]                 ...future.rng), started = ...future.startTime, 
[17:47:51.580]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.580]             version = "1.8"), class = "FutureResult")
[17:47:51.580]     }, finally = {
[17:47:51.580]         if (!identical(...future.workdir, getwd())) 
[17:47:51.580]             setwd(...future.workdir)
[17:47:51.580]         {
[17:47:51.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.580]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.580]             }
[17:47:51.580]             base::options(...future.oldOptions)
[17:47:51.580]             if (.Platform$OS.type == "windows") {
[17:47:51.580]                 old_names <- names(...future.oldEnvVars)
[17:47:51.580]                 envs <- base::Sys.getenv()
[17:47:51.580]                 names <- names(envs)
[17:47:51.580]                 common <- intersect(names, old_names)
[17:47:51.580]                 added <- setdiff(names, old_names)
[17:47:51.580]                 removed <- setdiff(old_names, names)
[17:47:51.580]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.580]                   envs[common]]
[17:47:51.580]                 NAMES <- toupper(changed)
[17:47:51.580]                 args <- list()
[17:47:51.580]                 for (kk in seq_along(NAMES)) {
[17:47:51.580]                   name <- changed[[kk]]
[17:47:51.580]                   NAME <- NAMES[[kk]]
[17:47:51.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.580]                     next
[17:47:51.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.580]                 }
[17:47:51.580]                 NAMES <- toupper(added)
[17:47:51.580]                 for (kk in seq_along(NAMES)) {
[17:47:51.580]                   name <- added[[kk]]
[17:47:51.580]                   NAME <- NAMES[[kk]]
[17:47:51.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.580]                     next
[17:47:51.580]                   args[[name]] <- ""
[17:47:51.580]                 }
[17:47:51.580]                 NAMES <- toupper(removed)
[17:47:51.580]                 for (kk in seq_along(NAMES)) {
[17:47:51.580]                   name <- removed[[kk]]
[17:47:51.580]                   NAME <- NAMES[[kk]]
[17:47:51.580]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.580]                     next
[17:47:51.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.580]                 }
[17:47:51.580]                 if (length(args) > 0) 
[17:47:51.580]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.580]             }
[17:47:51.580]             else {
[17:47:51.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.580]             }
[17:47:51.580]             {
[17:47:51.580]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.580]                   0L) {
[17:47:51.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.580]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.580]                   base::options(opts)
[17:47:51.580]                 }
[17:47:51.580]                 {
[17:47:51.580]                   {
[17:47:51.580]                     NULL
[17:47:51.580]                     RNGkind("Mersenne-Twister")
[17:47:51.580]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.580]                       inherits = FALSE)
[17:47:51.580]                   }
[17:47:51.580]                   options(future.plan = NULL)
[17:47:51.580]                   if (is.na(NA_character_)) 
[17:47:51.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.580]                     .init = FALSE)
[17:47:51.580]                 }
[17:47:51.580]             }
[17:47:51.580]         }
[17:47:51.580]     })
[17:47:51.580]     if (TRUE) {
[17:47:51.580]         base::sink(type = "output", split = FALSE)
[17:47:51.580]         if (TRUE) {
[17:47:51.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.580]         }
[17:47:51.580]         else {
[17:47:51.580]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.580]         }
[17:47:51.580]         base::close(...future.stdout)
[17:47:51.580]         ...future.stdout <- NULL
[17:47:51.580]     }
[17:47:51.580]     ...future.result$conditions <- ...future.conditions
[17:47:51.580]     ...future.result$finished <- base::Sys.time()
[17:47:51.580]     ...future.result
[17:47:51.580] }
[17:47:51.582] plan(): Setting new future strategy stack:
[17:47:51.582] List of future strategies:
[17:47:51.582] 1. sequential:
[17:47:51.582]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.582]    - tweaked: FALSE
[17:47:51.582]    - call: NULL
[17:47:51.583] plan(): nbrOfWorkers() = 1
[17:47:51.583] plan(): Setting new future strategy stack:
[17:47:51.583] List of future strategies:
[17:47:51.583] 1. sequential:
[17:47:51.583]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.583]    - tweaked: FALSE
[17:47:51.583]    - call: plan(strategy)
[17:47:51.584] plan(): nbrOfWorkers() = 1
[17:47:51.584] SequentialFuture started (and completed)
[17:47:51.584] - Launch lazy future ... done
[17:47:51.584] run() for ‘SequentialFuture’ ... done
[17:47:51.584] resolve() on list ...
[17:47:51.584]  recursive: 0
[17:47:51.584]  length: 3
[17:47:51.585]  elements: ‘a’, ‘b’, ‘’
[17:47:51.585] run() for ‘Future’ ...
[17:47:51.585] - state: ‘created’
[17:47:51.585] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.585] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.585]   - Field: ‘label’
[17:47:51.585]   - Field: ‘local’
[17:47:51.586]   - Field: ‘owner’
[17:47:51.586]   - Field: ‘envir’
[17:47:51.586]   - Field: ‘packages’
[17:47:51.586]   - Field: ‘gc’
[17:47:51.586]   - Field: ‘conditions’
[17:47:51.586]   - Field: ‘expr’
[17:47:51.586]   - Field: ‘uuid’
[17:47:51.586]   - Field: ‘seed’
[17:47:51.586]   - Field: ‘version’
[17:47:51.586]   - Field: ‘result’
[17:47:51.586]   - Field: ‘asynchronous’
[17:47:51.587]   - Field: ‘calls’
[17:47:51.587]   - Field: ‘globals’
[17:47:51.587]   - Field: ‘stdout’
[17:47:51.587]   - Field: ‘earlySignal’
[17:47:51.587]   - Field: ‘lazy’
[17:47:51.587]   - Field: ‘state’
[17:47:51.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.587] - Launch lazy future ...
[17:47:51.587] Packages needed by the future expression (n = 0): <none>
[17:47:51.587] Packages needed by future strategies (n = 0): <none>
[17:47:51.588] {
[17:47:51.588]     {
[17:47:51.588]         {
[17:47:51.588]             ...future.startTime <- base::Sys.time()
[17:47:51.588]             {
[17:47:51.588]                 {
[17:47:51.588]                   {
[17:47:51.588]                     base::local({
[17:47:51.588]                       has_future <- base::requireNamespace("future", 
[17:47:51.588]                         quietly = TRUE)
[17:47:51.588]                       if (has_future) {
[17:47:51.588]                         ns <- base::getNamespace("future")
[17:47:51.588]                         version <- ns[[".package"]][["version"]]
[17:47:51.588]                         if (is.null(version)) 
[17:47:51.588]                           version <- utils::packageVersion("future")
[17:47:51.588]                       }
[17:47:51.588]                       else {
[17:47:51.588]                         version <- NULL
[17:47:51.588]                       }
[17:47:51.588]                       if (!has_future || version < "1.8.0") {
[17:47:51.588]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.588]                           "", base::R.version$version.string), 
[17:47:51.588]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.588]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.588]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.588]                             "release", "version")], collapse = " "), 
[17:47:51.588]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.588]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.588]                           info)
[17:47:51.588]                         info <- base::paste(info, collapse = "; ")
[17:47:51.588]                         if (!has_future) {
[17:47:51.588]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.588]                             info)
[17:47:51.588]                         }
[17:47:51.588]                         else {
[17:47:51.588]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.588]                             info, version)
[17:47:51.588]                         }
[17:47:51.588]                         base::stop(msg)
[17:47:51.588]                       }
[17:47:51.588]                     })
[17:47:51.588]                   }
[17:47:51.588]                   ...future.strategy.old <- future::plan("list")
[17:47:51.588]                   options(future.plan = NULL)
[17:47:51.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.588]                 }
[17:47:51.588]                 ...future.workdir <- getwd()
[17:47:51.588]             }
[17:47:51.588]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.588]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.588]         }
[17:47:51.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.588]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.588]             base::names(...future.oldOptions))
[17:47:51.588]     }
[17:47:51.588]     if (FALSE) {
[17:47:51.588]     }
[17:47:51.588]     else {
[17:47:51.588]         if (TRUE) {
[17:47:51.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.588]                 open = "w")
[17:47:51.588]         }
[17:47:51.588]         else {
[17:47:51.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.588]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.588]         }
[17:47:51.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.588]             base::sink(type = "output", split = FALSE)
[17:47:51.588]             base::close(...future.stdout)
[17:47:51.588]         }, add = TRUE)
[17:47:51.588]     }
[17:47:51.588]     ...future.frame <- base::sys.nframe()
[17:47:51.588]     ...future.conditions <- base::list()
[17:47:51.588]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.588]     if (FALSE) {
[17:47:51.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.588]     }
[17:47:51.588]     ...future.result <- base::tryCatch({
[17:47:51.588]         base::withCallingHandlers({
[17:47:51.588]             ...future.value <- base::withVisible(base::local(1))
[17:47:51.588]             future::FutureResult(value = ...future.value$value, 
[17:47:51.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.588]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.588]                     ...future.globalenv.names))
[17:47:51.588]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.588]         }, condition = base::local({
[17:47:51.588]             c <- base::c
[17:47:51.588]             inherits <- base::inherits
[17:47:51.588]             invokeRestart <- base::invokeRestart
[17:47:51.588]             length <- base::length
[17:47:51.588]             list <- base::list
[17:47:51.588]             seq.int <- base::seq.int
[17:47:51.588]             signalCondition <- base::signalCondition
[17:47:51.588]             sys.calls <- base::sys.calls
[17:47:51.588]             `[[` <- base::`[[`
[17:47:51.588]             `+` <- base::`+`
[17:47:51.588]             `<<-` <- base::`<<-`
[17:47:51.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.588]                   3L)]
[17:47:51.588]             }
[17:47:51.588]             function(cond) {
[17:47:51.588]                 is_error <- inherits(cond, "error")
[17:47:51.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.588]                   NULL)
[17:47:51.588]                 if (is_error) {
[17:47:51.588]                   sessionInformation <- function() {
[17:47:51.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.588]                       search = base::search(), system = base::Sys.info())
[17:47:51.588]                   }
[17:47:51.588]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.588]                     cond$call), session = sessionInformation(), 
[17:47:51.588]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.588]                   signalCondition(cond)
[17:47:51.588]                 }
[17:47:51.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.588]                 "immediateCondition"))) {
[17:47:51.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.588]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.588]                   if (TRUE && !signal) {
[17:47:51.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.588]                     {
[17:47:51.588]                       inherits <- base::inherits
[17:47:51.588]                       invokeRestart <- base::invokeRestart
[17:47:51.588]                       is.null <- base::is.null
[17:47:51.588]                       muffled <- FALSE
[17:47:51.588]                       if (inherits(cond, "message")) {
[17:47:51.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.588]                         if (muffled) 
[17:47:51.588]                           invokeRestart("muffleMessage")
[17:47:51.588]                       }
[17:47:51.588]                       else if (inherits(cond, "warning")) {
[17:47:51.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.588]                         if (muffled) 
[17:47:51.588]                           invokeRestart("muffleWarning")
[17:47:51.588]                       }
[17:47:51.588]                       else if (inherits(cond, "condition")) {
[17:47:51.588]                         if (!is.null(pattern)) {
[17:47:51.588]                           computeRestarts <- base::computeRestarts
[17:47:51.588]                           grepl <- base::grepl
[17:47:51.588]                           restarts <- computeRestarts(cond)
[17:47:51.588]                           for (restart in restarts) {
[17:47:51.588]                             name <- restart$name
[17:47:51.588]                             if (is.null(name)) 
[17:47:51.588]                               next
[17:47:51.588]                             if (!grepl(pattern, name)) 
[17:47:51.588]                               next
[17:47:51.588]                             invokeRestart(restart)
[17:47:51.588]                             muffled <- TRUE
[17:47:51.588]                             break
[17:47:51.588]                           }
[17:47:51.588]                         }
[17:47:51.588]                       }
[17:47:51.588]                       invisible(muffled)
[17:47:51.588]                     }
[17:47:51.588]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.588]                   }
[17:47:51.588]                 }
[17:47:51.588]                 else {
[17:47:51.588]                   if (TRUE) {
[17:47:51.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.588]                     {
[17:47:51.588]                       inherits <- base::inherits
[17:47:51.588]                       invokeRestart <- base::invokeRestart
[17:47:51.588]                       is.null <- base::is.null
[17:47:51.588]                       muffled <- FALSE
[17:47:51.588]                       if (inherits(cond, "message")) {
[17:47:51.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.588]                         if (muffled) 
[17:47:51.588]                           invokeRestart("muffleMessage")
[17:47:51.588]                       }
[17:47:51.588]                       else if (inherits(cond, "warning")) {
[17:47:51.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.588]                         if (muffled) 
[17:47:51.588]                           invokeRestart("muffleWarning")
[17:47:51.588]                       }
[17:47:51.588]                       else if (inherits(cond, "condition")) {
[17:47:51.588]                         if (!is.null(pattern)) {
[17:47:51.588]                           computeRestarts <- base::computeRestarts
[17:47:51.588]                           grepl <- base::grepl
[17:47:51.588]                           restarts <- computeRestarts(cond)
[17:47:51.588]                           for (restart in restarts) {
[17:47:51.588]                             name <- restart$name
[17:47:51.588]                             if (is.null(name)) 
[17:47:51.588]                               next
[17:47:51.588]                             if (!grepl(pattern, name)) 
[17:47:51.588]                               next
[17:47:51.588]                             invokeRestart(restart)
[17:47:51.588]                             muffled <- TRUE
[17:47:51.588]                             break
[17:47:51.588]                           }
[17:47:51.588]                         }
[17:47:51.588]                       }
[17:47:51.588]                       invisible(muffled)
[17:47:51.588]                     }
[17:47:51.588]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.588]                   }
[17:47:51.588]                 }
[17:47:51.588]             }
[17:47:51.588]         }))
[17:47:51.588]     }, error = function(ex) {
[17:47:51.588]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.588]                 ...future.rng), started = ...future.startTime, 
[17:47:51.588]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.588]             version = "1.8"), class = "FutureResult")
[17:47:51.588]     }, finally = {
[17:47:51.588]         if (!identical(...future.workdir, getwd())) 
[17:47:51.588]             setwd(...future.workdir)
[17:47:51.588]         {
[17:47:51.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.588]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.588]             }
[17:47:51.588]             base::options(...future.oldOptions)
[17:47:51.588]             if (.Platform$OS.type == "windows") {
[17:47:51.588]                 old_names <- names(...future.oldEnvVars)
[17:47:51.588]                 envs <- base::Sys.getenv()
[17:47:51.588]                 names <- names(envs)
[17:47:51.588]                 common <- intersect(names, old_names)
[17:47:51.588]                 added <- setdiff(names, old_names)
[17:47:51.588]                 removed <- setdiff(old_names, names)
[17:47:51.588]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.588]                   envs[common]]
[17:47:51.588]                 NAMES <- toupper(changed)
[17:47:51.588]                 args <- list()
[17:47:51.588]                 for (kk in seq_along(NAMES)) {
[17:47:51.588]                   name <- changed[[kk]]
[17:47:51.588]                   NAME <- NAMES[[kk]]
[17:47:51.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.588]                     next
[17:47:51.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.588]                 }
[17:47:51.588]                 NAMES <- toupper(added)
[17:47:51.588]                 for (kk in seq_along(NAMES)) {
[17:47:51.588]                   name <- added[[kk]]
[17:47:51.588]                   NAME <- NAMES[[kk]]
[17:47:51.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.588]                     next
[17:47:51.588]                   args[[name]] <- ""
[17:47:51.588]                 }
[17:47:51.588]                 NAMES <- toupper(removed)
[17:47:51.588]                 for (kk in seq_along(NAMES)) {
[17:47:51.588]                   name <- removed[[kk]]
[17:47:51.588]                   NAME <- NAMES[[kk]]
[17:47:51.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.588]                     next
[17:47:51.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.588]                 }
[17:47:51.588]                 if (length(args) > 0) 
[17:47:51.588]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.588]             }
[17:47:51.588]             else {
[17:47:51.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.588]             }
[17:47:51.588]             {
[17:47:51.588]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.588]                   0L) {
[17:47:51.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.588]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.588]                   base::options(opts)
[17:47:51.588]                 }
[17:47:51.588]                 {
[17:47:51.588]                   {
[17:47:51.588]                     NULL
[17:47:51.588]                     RNGkind("Mersenne-Twister")
[17:47:51.588]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.588]                       inherits = FALSE)
[17:47:51.588]                   }
[17:47:51.588]                   options(future.plan = NULL)
[17:47:51.588]                   if (is.na(NA_character_)) 
[17:47:51.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.588]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.588]                     .init = FALSE)
[17:47:51.588]                 }
[17:47:51.588]             }
[17:47:51.588]         }
[17:47:51.588]     })
[17:47:51.588]     if (TRUE) {
[17:47:51.588]         base::sink(type = "output", split = FALSE)
[17:47:51.588]         if (TRUE) {
[17:47:51.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.588]         }
[17:47:51.588]         else {
[17:47:51.588]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.588]         }
[17:47:51.588]         base::close(...future.stdout)
[17:47:51.588]         ...future.stdout <- NULL
[17:47:51.588]     }
[17:47:51.588]     ...future.result$conditions <- ...future.conditions
[17:47:51.588]     ...future.result$finished <- base::Sys.time()
[17:47:51.588]     ...future.result
[17:47:51.588] }
[17:47:51.589] plan(): Setting new future strategy stack:
[17:47:51.590] List of future strategies:
[17:47:51.590] 1. sequential:
[17:47:51.590]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.590]    - tweaked: FALSE
[17:47:51.590]    - call: NULL
[17:47:51.592] plan(): nbrOfWorkers() = 1
[17:47:51.592] plan(): Setting new future strategy stack:
[17:47:51.593] List of future strategies:
[17:47:51.593] 1. sequential:
[17:47:51.593]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.593]    - tweaked: FALSE
[17:47:51.593]    - call: plan(strategy)
[17:47:51.593] plan(): nbrOfWorkers() = 1
[17:47:51.593] SequentialFuture started (and completed)
[17:47:51.593] - Launch lazy future ... done
[17:47:51.593] run() for ‘SequentialFuture’ ... done
[17:47:51.594] resolved() for ‘SequentialFuture’ ...
[17:47:51.594] - state: ‘finished’
[17:47:51.594] - run: TRUE
[17:47:51.594] - result: ‘FutureResult’
[17:47:51.594] resolved() for ‘SequentialFuture’ ... done
[17:47:51.594] Future #1
[17:47:51.594]  length: 2 (resolved future 1)
[17:47:51.594] resolved() for ‘SequentialFuture’ ...
[17:47:51.594] - state: ‘finished’
[17:47:51.594] - run: TRUE
[17:47:51.594] - result: ‘FutureResult’
[17:47:51.595] resolved() for ‘SequentialFuture’ ... done
[17:47:51.595] Future #2
[17:47:51.595]  length: 1 (resolved future 2)
[17:47:51.595]  length: 0 (resolved future 3)
[17:47:51.595] resolve() on list ... DONE
[17:47:51.595] resolved() for ‘SequentialFuture’ ...
[17:47:51.595] - state: ‘finished’
[17:47:51.595] - run: TRUE
[17:47:51.595] - result: ‘FutureResult’
[17:47:51.595] resolved() for ‘SequentialFuture’ ... done
[17:47:51.595] resolved() for ‘SequentialFuture’ ...
[17:47:51.596] - state: ‘finished’
[17:47:51.596] - run: TRUE
[17:47:51.596] - result: ‘FutureResult’
[17:47:51.596] resolved() for ‘SequentialFuture’ ... done
[17:47:51.596] getGlobalsAndPackages() ...
[17:47:51.596] Searching for globals...
[17:47:51.596] 
[17:47:51.596] Searching for globals ... DONE
[17:47:51.596] - globals: [0] <none>
[17:47:51.597] getGlobalsAndPackages() ... DONE
[17:47:51.597] getGlobalsAndPackages() ...
[17:47:51.597] Searching for globals...
[17:47:51.597] 
[17:47:51.597] Searching for globals ... DONE
[17:47:51.597] - globals: [0] <none>
[17:47:51.597] getGlobalsAndPackages() ... DONE
[17:47:51.598] resolve() on list ...
[17:47:51.598]  recursive: 0
[17:47:51.598]  length: 3
[17:47:51.598]  elements: ‘a’, ‘b’, ‘’
[17:47:51.598] run() for ‘Future’ ...
[17:47:51.598] - state: ‘created’
[17:47:51.598] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.599]   - Field: ‘label’
[17:47:51.599]   - Field: ‘local’
[17:47:51.599]   - Field: ‘owner’
[17:47:51.599]   - Field: ‘envir’
[17:47:51.599]   - Field: ‘packages’
[17:47:51.599]   - Field: ‘gc’
[17:47:51.599]   - Field: ‘conditions’
[17:47:51.599]   - Field: ‘expr’
[17:47:51.599]   - Field: ‘uuid’
[17:47:51.599]   - Field: ‘seed’
[17:47:51.599]   - Field: ‘version’
[17:47:51.600]   - Field: ‘result’
[17:47:51.600]   - Field: ‘asynchronous’
[17:47:51.600]   - Field: ‘calls’
[17:47:51.600]   - Field: ‘globals’
[17:47:51.600]   - Field: ‘stdout’
[17:47:51.600]   - Field: ‘earlySignal’
[17:47:51.600]   - Field: ‘lazy’
[17:47:51.600]   - Field: ‘state’
[17:47:51.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.600] - Launch lazy future ...
[17:47:51.600] Packages needed by the future expression (n = 0): <none>
[17:47:51.601] Packages needed by future strategies (n = 0): <none>
[17:47:51.601] {
[17:47:51.601]     {
[17:47:51.601]         {
[17:47:51.601]             ...future.startTime <- base::Sys.time()
[17:47:51.601]             {
[17:47:51.601]                 {
[17:47:51.601]                   {
[17:47:51.601]                     base::local({
[17:47:51.601]                       has_future <- base::requireNamespace("future", 
[17:47:51.601]                         quietly = TRUE)
[17:47:51.601]                       if (has_future) {
[17:47:51.601]                         ns <- base::getNamespace("future")
[17:47:51.601]                         version <- ns[[".package"]][["version"]]
[17:47:51.601]                         if (is.null(version)) 
[17:47:51.601]                           version <- utils::packageVersion("future")
[17:47:51.601]                       }
[17:47:51.601]                       else {
[17:47:51.601]                         version <- NULL
[17:47:51.601]                       }
[17:47:51.601]                       if (!has_future || version < "1.8.0") {
[17:47:51.601]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.601]                           "", base::R.version$version.string), 
[17:47:51.601]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.601]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.601]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.601]                             "release", "version")], collapse = " "), 
[17:47:51.601]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.601]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.601]                           info)
[17:47:51.601]                         info <- base::paste(info, collapse = "; ")
[17:47:51.601]                         if (!has_future) {
[17:47:51.601]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.601]                             info)
[17:47:51.601]                         }
[17:47:51.601]                         else {
[17:47:51.601]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.601]                             info, version)
[17:47:51.601]                         }
[17:47:51.601]                         base::stop(msg)
[17:47:51.601]                       }
[17:47:51.601]                     })
[17:47:51.601]                   }
[17:47:51.601]                   ...future.strategy.old <- future::plan("list")
[17:47:51.601]                   options(future.plan = NULL)
[17:47:51.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.601]                 }
[17:47:51.601]                 ...future.workdir <- getwd()
[17:47:51.601]             }
[17:47:51.601]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.601]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.601]         }
[17:47:51.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.601]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.601]             base::names(...future.oldOptions))
[17:47:51.601]     }
[17:47:51.601]     if (FALSE) {
[17:47:51.601]     }
[17:47:51.601]     else {
[17:47:51.601]         if (TRUE) {
[17:47:51.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.601]                 open = "w")
[17:47:51.601]         }
[17:47:51.601]         else {
[17:47:51.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.601]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.601]         }
[17:47:51.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.601]             base::sink(type = "output", split = FALSE)
[17:47:51.601]             base::close(...future.stdout)
[17:47:51.601]         }, add = TRUE)
[17:47:51.601]     }
[17:47:51.601]     ...future.frame <- base::sys.nframe()
[17:47:51.601]     ...future.conditions <- base::list()
[17:47:51.601]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.601]     if (FALSE) {
[17:47:51.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.601]     }
[17:47:51.601]     ...future.result <- base::tryCatch({
[17:47:51.601]         base::withCallingHandlers({
[17:47:51.601]             ...future.value <- base::withVisible(base::local(1))
[17:47:51.601]             future::FutureResult(value = ...future.value$value, 
[17:47:51.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.601]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.601]                     ...future.globalenv.names))
[17:47:51.601]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.601]         }, condition = base::local({
[17:47:51.601]             c <- base::c
[17:47:51.601]             inherits <- base::inherits
[17:47:51.601]             invokeRestart <- base::invokeRestart
[17:47:51.601]             length <- base::length
[17:47:51.601]             list <- base::list
[17:47:51.601]             seq.int <- base::seq.int
[17:47:51.601]             signalCondition <- base::signalCondition
[17:47:51.601]             sys.calls <- base::sys.calls
[17:47:51.601]             `[[` <- base::`[[`
[17:47:51.601]             `+` <- base::`+`
[17:47:51.601]             `<<-` <- base::`<<-`
[17:47:51.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.601]                   3L)]
[17:47:51.601]             }
[17:47:51.601]             function(cond) {
[17:47:51.601]                 is_error <- inherits(cond, "error")
[17:47:51.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.601]                   NULL)
[17:47:51.601]                 if (is_error) {
[17:47:51.601]                   sessionInformation <- function() {
[17:47:51.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.601]                       search = base::search(), system = base::Sys.info())
[17:47:51.601]                   }
[17:47:51.601]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.601]                     cond$call), session = sessionInformation(), 
[17:47:51.601]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.601]                   signalCondition(cond)
[17:47:51.601]                 }
[17:47:51.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.601]                 "immediateCondition"))) {
[17:47:51.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.601]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.601]                   if (TRUE && !signal) {
[17:47:51.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.601]                     {
[17:47:51.601]                       inherits <- base::inherits
[17:47:51.601]                       invokeRestart <- base::invokeRestart
[17:47:51.601]                       is.null <- base::is.null
[17:47:51.601]                       muffled <- FALSE
[17:47:51.601]                       if (inherits(cond, "message")) {
[17:47:51.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.601]                         if (muffled) 
[17:47:51.601]                           invokeRestart("muffleMessage")
[17:47:51.601]                       }
[17:47:51.601]                       else if (inherits(cond, "warning")) {
[17:47:51.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.601]                         if (muffled) 
[17:47:51.601]                           invokeRestart("muffleWarning")
[17:47:51.601]                       }
[17:47:51.601]                       else if (inherits(cond, "condition")) {
[17:47:51.601]                         if (!is.null(pattern)) {
[17:47:51.601]                           computeRestarts <- base::computeRestarts
[17:47:51.601]                           grepl <- base::grepl
[17:47:51.601]                           restarts <- computeRestarts(cond)
[17:47:51.601]                           for (restart in restarts) {
[17:47:51.601]                             name <- restart$name
[17:47:51.601]                             if (is.null(name)) 
[17:47:51.601]                               next
[17:47:51.601]                             if (!grepl(pattern, name)) 
[17:47:51.601]                               next
[17:47:51.601]                             invokeRestart(restart)
[17:47:51.601]                             muffled <- TRUE
[17:47:51.601]                             break
[17:47:51.601]                           }
[17:47:51.601]                         }
[17:47:51.601]                       }
[17:47:51.601]                       invisible(muffled)
[17:47:51.601]                     }
[17:47:51.601]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.601]                   }
[17:47:51.601]                 }
[17:47:51.601]                 else {
[17:47:51.601]                   if (TRUE) {
[17:47:51.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.601]                     {
[17:47:51.601]                       inherits <- base::inherits
[17:47:51.601]                       invokeRestart <- base::invokeRestart
[17:47:51.601]                       is.null <- base::is.null
[17:47:51.601]                       muffled <- FALSE
[17:47:51.601]                       if (inherits(cond, "message")) {
[17:47:51.601]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.601]                         if (muffled) 
[17:47:51.601]                           invokeRestart("muffleMessage")
[17:47:51.601]                       }
[17:47:51.601]                       else if (inherits(cond, "warning")) {
[17:47:51.601]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.601]                         if (muffled) 
[17:47:51.601]                           invokeRestart("muffleWarning")
[17:47:51.601]                       }
[17:47:51.601]                       else if (inherits(cond, "condition")) {
[17:47:51.601]                         if (!is.null(pattern)) {
[17:47:51.601]                           computeRestarts <- base::computeRestarts
[17:47:51.601]                           grepl <- base::grepl
[17:47:51.601]                           restarts <- computeRestarts(cond)
[17:47:51.601]                           for (restart in restarts) {
[17:47:51.601]                             name <- restart$name
[17:47:51.601]                             if (is.null(name)) 
[17:47:51.601]                               next
[17:47:51.601]                             if (!grepl(pattern, name)) 
[17:47:51.601]                               next
[17:47:51.601]                             invokeRestart(restart)
[17:47:51.601]                             muffled <- TRUE
[17:47:51.601]                             break
[17:47:51.601]                           }
[17:47:51.601]                         }
[17:47:51.601]                       }
[17:47:51.601]                       invisible(muffled)
[17:47:51.601]                     }
[17:47:51.601]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.601]                   }
[17:47:51.601]                 }
[17:47:51.601]             }
[17:47:51.601]         }))
[17:47:51.601]     }, error = function(ex) {
[17:47:51.601]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.601]                 ...future.rng), started = ...future.startTime, 
[17:47:51.601]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.601]             version = "1.8"), class = "FutureResult")
[17:47:51.601]     }, finally = {
[17:47:51.601]         if (!identical(...future.workdir, getwd())) 
[17:47:51.601]             setwd(...future.workdir)
[17:47:51.601]         {
[17:47:51.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.601]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.601]             }
[17:47:51.601]             base::options(...future.oldOptions)
[17:47:51.601]             if (.Platform$OS.type == "windows") {
[17:47:51.601]                 old_names <- names(...future.oldEnvVars)
[17:47:51.601]                 envs <- base::Sys.getenv()
[17:47:51.601]                 names <- names(envs)
[17:47:51.601]                 common <- intersect(names, old_names)
[17:47:51.601]                 added <- setdiff(names, old_names)
[17:47:51.601]                 removed <- setdiff(old_names, names)
[17:47:51.601]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.601]                   envs[common]]
[17:47:51.601]                 NAMES <- toupper(changed)
[17:47:51.601]                 args <- list()
[17:47:51.601]                 for (kk in seq_along(NAMES)) {
[17:47:51.601]                   name <- changed[[kk]]
[17:47:51.601]                   NAME <- NAMES[[kk]]
[17:47:51.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.601]                     next
[17:47:51.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.601]                 }
[17:47:51.601]                 NAMES <- toupper(added)
[17:47:51.601]                 for (kk in seq_along(NAMES)) {
[17:47:51.601]                   name <- added[[kk]]
[17:47:51.601]                   NAME <- NAMES[[kk]]
[17:47:51.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.601]                     next
[17:47:51.601]                   args[[name]] <- ""
[17:47:51.601]                 }
[17:47:51.601]                 NAMES <- toupper(removed)
[17:47:51.601]                 for (kk in seq_along(NAMES)) {
[17:47:51.601]                   name <- removed[[kk]]
[17:47:51.601]                   NAME <- NAMES[[kk]]
[17:47:51.601]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.601]                     next
[17:47:51.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.601]                 }
[17:47:51.601]                 if (length(args) > 0) 
[17:47:51.601]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.601]             }
[17:47:51.601]             else {
[17:47:51.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.601]             }
[17:47:51.601]             {
[17:47:51.601]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.601]                   0L) {
[17:47:51.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.601]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.601]                   base::options(opts)
[17:47:51.601]                 }
[17:47:51.601]                 {
[17:47:51.601]                   {
[17:47:51.601]                     NULL
[17:47:51.601]                     RNGkind("Mersenne-Twister")
[17:47:51.601]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.601]                       inherits = FALSE)
[17:47:51.601]                   }
[17:47:51.601]                   options(future.plan = NULL)
[17:47:51.601]                   if (is.na(NA_character_)) 
[17:47:51.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.601]                     .init = FALSE)
[17:47:51.601]                 }
[17:47:51.601]             }
[17:47:51.601]         }
[17:47:51.601]     })
[17:47:51.601]     if (TRUE) {
[17:47:51.601]         base::sink(type = "output", split = FALSE)
[17:47:51.601]         if (TRUE) {
[17:47:51.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.601]         }
[17:47:51.601]         else {
[17:47:51.601]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.601]         }
[17:47:51.601]         base::close(...future.stdout)
[17:47:51.601]         ...future.stdout <- NULL
[17:47:51.601]     }
[17:47:51.601]     ...future.result$conditions <- ...future.conditions
[17:47:51.601]     ...future.result$finished <- base::Sys.time()
[17:47:51.601]     ...future.result
[17:47:51.601] }
[17:47:51.603] plan(): Setting new future strategy stack:
[17:47:51.603] List of future strategies:
[17:47:51.603] 1. sequential:
[17:47:51.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.603]    - tweaked: FALSE
[17:47:51.603]    - call: NULL
[17:47:51.603] plan(): nbrOfWorkers() = 1
[17:47:51.604] plan(): Setting new future strategy stack:
[17:47:51.604] List of future strategies:
[17:47:51.604] 1. sequential:
[17:47:51.604]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.604]    - tweaked: FALSE
[17:47:51.604]    - call: plan(strategy)
[17:47:51.604] plan(): nbrOfWorkers() = 1
[17:47:51.604] SequentialFuture started (and completed)
[17:47:51.605] - Launch lazy future ... done
[17:47:51.605] run() for ‘SequentialFuture’ ... done
[17:47:51.605] resolved() for ‘SequentialFuture’ ...
[17:47:51.605] - state: ‘finished’
[17:47:51.605] - run: TRUE
[17:47:51.605] - result: ‘FutureResult’
[17:47:51.605] resolved() for ‘SequentialFuture’ ... done
[17:47:51.605] Future #1
[17:47:51.605]  length: 2 (resolved future 1)
[17:47:51.605] run() for ‘Future’ ...
[17:47:51.605] - state: ‘created’
[17:47:51.606] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.606] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.606]   - Field: ‘label’
[17:47:51.606]   - Field: ‘local’
[17:47:51.606]   - Field: ‘owner’
[17:47:51.606]   - Field: ‘envir’
[17:47:51.606]   - Field: ‘packages’
[17:47:51.606]   - Field: ‘gc’
[17:47:51.607]   - Field: ‘conditions’
[17:47:51.607]   - Field: ‘expr’
[17:47:51.607]   - Field: ‘uuid’
[17:47:51.607]   - Field: ‘seed’
[17:47:51.607]   - Field: ‘version’
[17:47:51.607]   - Field: ‘result’
[17:47:51.607]   - Field: ‘asynchronous’
[17:47:51.607]   - Field: ‘calls’
[17:47:51.607]   - Field: ‘globals’
[17:47:51.607]   - Field: ‘stdout’
[17:47:51.607]   - Field: ‘earlySignal’
[17:47:51.608]   - Field: ‘lazy’
[17:47:51.608]   - Field: ‘state’
[17:47:51.608] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.608] - Launch lazy future ...
[17:47:51.608] Packages needed by the future expression (n = 0): <none>
[17:47:51.608] Packages needed by future strategies (n = 0): <none>
[17:47:51.608] {
[17:47:51.608]     {
[17:47:51.608]         {
[17:47:51.608]             ...future.startTime <- base::Sys.time()
[17:47:51.608]             {
[17:47:51.608]                 {
[17:47:51.608]                   {
[17:47:51.608]                     base::local({
[17:47:51.608]                       has_future <- base::requireNamespace("future", 
[17:47:51.608]                         quietly = TRUE)
[17:47:51.608]                       if (has_future) {
[17:47:51.608]                         ns <- base::getNamespace("future")
[17:47:51.608]                         version <- ns[[".package"]][["version"]]
[17:47:51.608]                         if (is.null(version)) 
[17:47:51.608]                           version <- utils::packageVersion("future")
[17:47:51.608]                       }
[17:47:51.608]                       else {
[17:47:51.608]                         version <- NULL
[17:47:51.608]                       }
[17:47:51.608]                       if (!has_future || version < "1.8.0") {
[17:47:51.608]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.608]                           "", base::R.version$version.string), 
[17:47:51.608]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.608]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.608]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.608]                             "release", "version")], collapse = " "), 
[17:47:51.608]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.608]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.608]                           info)
[17:47:51.608]                         info <- base::paste(info, collapse = "; ")
[17:47:51.608]                         if (!has_future) {
[17:47:51.608]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.608]                             info)
[17:47:51.608]                         }
[17:47:51.608]                         else {
[17:47:51.608]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.608]                             info, version)
[17:47:51.608]                         }
[17:47:51.608]                         base::stop(msg)
[17:47:51.608]                       }
[17:47:51.608]                     })
[17:47:51.608]                   }
[17:47:51.608]                   ...future.strategy.old <- future::plan("list")
[17:47:51.608]                   options(future.plan = NULL)
[17:47:51.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.608]                 }
[17:47:51.608]                 ...future.workdir <- getwd()
[17:47:51.608]             }
[17:47:51.608]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.608]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.608]         }
[17:47:51.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.608]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.608]             base::names(...future.oldOptions))
[17:47:51.608]     }
[17:47:51.608]     if (FALSE) {
[17:47:51.608]     }
[17:47:51.608]     else {
[17:47:51.608]         if (TRUE) {
[17:47:51.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.608]                 open = "w")
[17:47:51.608]         }
[17:47:51.608]         else {
[17:47:51.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.608]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.608]         }
[17:47:51.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.608]             base::sink(type = "output", split = FALSE)
[17:47:51.608]             base::close(...future.stdout)
[17:47:51.608]         }, add = TRUE)
[17:47:51.608]     }
[17:47:51.608]     ...future.frame <- base::sys.nframe()
[17:47:51.608]     ...future.conditions <- base::list()
[17:47:51.608]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.608]     if (FALSE) {
[17:47:51.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.608]     }
[17:47:51.608]     ...future.result <- base::tryCatch({
[17:47:51.608]         base::withCallingHandlers({
[17:47:51.608]             ...future.value <- base::withVisible(base::local(2))
[17:47:51.608]             future::FutureResult(value = ...future.value$value, 
[17:47:51.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.608]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.608]                     ...future.globalenv.names))
[17:47:51.608]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.608]         }, condition = base::local({
[17:47:51.608]             c <- base::c
[17:47:51.608]             inherits <- base::inherits
[17:47:51.608]             invokeRestart <- base::invokeRestart
[17:47:51.608]             length <- base::length
[17:47:51.608]             list <- base::list
[17:47:51.608]             seq.int <- base::seq.int
[17:47:51.608]             signalCondition <- base::signalCondition
[17:47:51.608]             sys.calls <- base::sys.calls
[17:47:51.608]             `[[` <- base::`[[`
[17:47:51.608]             `+` <- base::`+`
[17:47:51.608]             `<<-` <- base::`<<-`
[17:47:51.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.608]                   3L)]
[17:47:51.608]             }
[17:47:51.608]             function(cond) {
[17:47:51.608]                 is_error <- inherits(cond, "error")
[17:47:51.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.608]                   NULL)
[17:47:51.608]                 if (is_error) {
[17:47:51.608]                   sessionInformation <- function() {
[17:47:51.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.608]                       search = base::search(), system = base::Sys.info())
[17:47:51.608]                   }
[17:47:51.608]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.608]                     cond$call), session = sessionInformation(), 
[17:47:51.608]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.608]                   signalCondition(cond)
[17:47:51.608]                 }
[17:47:51.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.608]                 "immediateCondition"))) {
[17:47:51.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.608]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.608]                   if (TRUE && !signal) {
[17:47:51.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.608]                     {
[17:47:51.608]                       inherits <- base::inherits
[17:47:51.608]                       invokeRestart <- base::invokeRestart
[17:47:51.608]                       is.null <- base::is.null
[17:47:51.608]                       muffled <- FALSE
[17:47:51.608]                       if (inherits(cond, "message")) {
[17:47:51.608]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.608]                         if (muffled) 
[17:47:51.608]                           invokeRestart("muffleMessage")
[17:47:51.608]                       }
[17:47:51.608]                       else if (inherits(cond, "warning")) {
[17:47:51.608]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.608]                         if (muffled) 
[17:47:51.608]                           invokeRestart("muffleWarning")
[17:47:51.608]                       }
[17:47:51.608]                       else if (inherits(cond, "condition")) {
[17:47:51.608]                         if (!is.null(pattern)) {
[17:47:51.608]                           computeRestarts <- base::computeRestarts
[17:47:51.608]                           grepl <- base::grepl
[17:47:51.608]                           restarts <- computeRestarts(cond)
[17:47:51.608]                           for (restart in restarts) {
[17:47:51.608]                             name <- restart$name
[17:47:51.608]                             if (is.null(name)) 
[17:47:51.608]                               next
[17:47:51.608]                             if (!grepl(pattern, name)) 
[17:47:51.608]                               next
[17:47:51.608]                             invokeRestart(restart)
[17:47:51.608]                             muffled <- TRUE
[17:47:51.608]                             break
[17:47:51.608]                           }
[17:47:51.608]                         }
[17:47:51.608]                       }
[17:47:51.608]                       invisible(muffled)
[17:47:51.608]                     }
[17:47:51.608]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.608]                   }
[17:47:51.608]                 }
[17:47:51.608]                 else {
[17:47:51.608]                   if (TRUE) {
[17:47:51.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.608]                     {
[17:47:51.608]                       inherits <- base::inherits
[17:47:51.608]                       invokeRestart <- base::invokeRestart
[17:47:51.608]                       is.null <- base::is.null
[17:47:51.608]                       muffled <- FALSE
[17:47:51.608]                       if (inherits(cond, "message")) {
[17:47:51.608]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.608]                         if (muffled) 
[17:47:51.608]                           invokeRestart("muffleMessage")
[17:47:51.608]                       }
[17:47:51.608]                       else if (inherits(cond, "warning")) {
[17:47:51.608]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.608]                         if (muffled) 
[17:47:51.608]                           invokeRestart("muffleWarning")
[17:47:51.608]                       }
[17:47:51.608]                       else if (inherits(cond, "condition")) {
[17:47:51.608]                         if (!is.null(pattern)) {
[17:47:51.608]                           computeRestarts <- base::computeRestarts
[17:47:51.608]                           grepl <- base::grepl
[17:47:51.608]                           restarts <- computeRestarts(cond)
[17:47:51.608]                           for (restart in restarts) {
[17:47:51.608]                             name <- restart$name
[17:47:51.608]                             if (is.null(name)) 
[17:47:51.608]                               next
[17:47:51.608]                             if (!grepl(pattern, name)) 
[17:47:51.608]                               next
[17:47:51.608]                             invokeRestart(restart)
[17:47:51.608]                             muffled <- TRUE
[17:47:51.608]                             break
[17:47:51.608]                           }
[17:47:51.608]                         }
[17:47:51.608]                       }
[17:47:51.608]                       invisible(muffled)
[17:47:51.608]                     }
[17:47:51.608]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.608]                   }
[17:47:51.608]                 }
[17:47:51.608]             }
[17:47:51.608]         }))
[17:47:51.608]     }, error = function(ex) {
[17:47:51.608]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.608]                 ...future.rng), started = ...future.startTime, 
[17:47:51.608]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.608]             version = "1.8"), class = "FutureResult")
[17:47:51.608]     }, finally = {
[17:47:51.608]         if (!identical(...future.workdir, getwd())) 
[17:47:51.608]             setwd(...future.workdir)
[17:47:51.608]         {
[17:47:51.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.608]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.608]             }
[17:47:51.608]             base::options(...future.oldOptions)
[17:47:51.608]             if (.Platform$OS.type == "windows") {
[17:47:51.608]                 old_names <- names(...future.oldEnvVars)
[17:47:51.608]                 envs <- base::Sys.getenv()
[17:47:51.608]                 names <- names(envs)
[17:47:51.608]                 common <- intersect(names, old_names)
[17:47:51.608]                 added <- setdiff(names, old_names)
[17:47:51.608]                 removed <- setdiff(old_names, names)
[17:47:51.608]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.608]                   envs[common]]
[17:47:51.608]                 NAMES <- toupper(changed)
[17:47:51.608]                 args <- list()
[17:47:51.608]                 for (kk in seq_along(NAMES)) {
[17:47:51.608]                   name <- changed[[kk]]
[17:47:51.608]                   NAME <- NAMES[[kk]]
[17:47:51.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.608]                     next
[17:47:51.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.608]                 }
[17:47:51.608]                 NAMES <- toupper(added)
[17:47:51.608]                 for (kk in seq_along(NAMES)) {
[17:47:51.608]                   name <- added[[kk]]
[17:47:51.608]                   NAME <- NAMES[[kk]]
[17:47:51.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.608]                     next
[17:47:51.608]                   args[[name]] <- ""
[17:47:51.608]                 }
[17:47:51.608]                 NAMES <- toupper(removed)
[17:47:51.608]                 for (kk in seq_along(NAMES)) {
[17:47:51.608]                   name <- removed[[kk]]
[17:47:51.608]                   NAME <- NAMES[[kk]]
[17:47:51.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.608]                     next
[17:47:51.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.608]                 }
[17:47:51.608]                 if (length(args) > 0) 
[17:47:51.608]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.608]             }
[17:47:51.608]             else {
[17:47:51.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.608]             }
[17:47:51.608]             {
[17:47:51.608]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.608]                   0L) {
[17:47:51.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.608]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.608]                   base::options(opts)
[17:47:51.608]                 }
[17:47:51.608]                 {
[17:47:51.608]                   {
[17:47:51.608]                     NULL
[17:47:51.608]                     RNGkind("Mersenne-Twister")
[17:47:51.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.608]                       inherits = FALSE)
[17:47:51.608]                   }
[17:47:51.608]                   options(future.plan = NULL)
[17:47:51.608]                   if (is.na(NA_character_)) 
[17:47:51.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.608]                     .init = FALSE)
[17:47:51.608]                 }
[17:47:51.608]             }
[17:47:51.608]         }
[17:47:51.608]     })
[17:47:51.608]     if (TRUE) {
[17:47:51.608]         base::sink(type = "output", split = FALSE)
[17:47:51.608]         if (TRUE) {
[17:47:51.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.608]         }
[17:47:51.608]         else {
[17:47:51.608]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.608]         }
[17:47:51.608]         base::close(...future.stdout)
[17:47:51.608]         ...future.stdout <- NULL
[17:47:51.608]     }
[17:47:51.608]     ...future.result$conditions <- ...future.conditions
[17:47:51.608]     ...future.result$finished <- base::Sys.time()
[17:47:51.608]     ...future.result
[17:47:51.608] }
[17:47:51.610] plan(): Setting new future strategy stack:
[17:47:51.610] List of future strategies:
[17:47:51.610] 1. sequential:
[17:47:51.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.610]    - tweaked: FALSE
[17:47:51.610]    - call: NULL
[17:47:51.611] plan(): nbrOfWorkers() = 1
[17:47:51.611] plan(): Setting new future strategy stack:
[17:47:51.611] List of future strategies:
[17:47:51.611] 1. sequential:
[17:47:51.611]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.611]    - tweaked: FALSE
[17:47:51.611]    - call: plan(strategy)
[17:47:51.612] plan(): nbrOfWorkers() = 1
[17:47:51.612] SequentialFuture started (and completed)
[17:47:51.612] - Launch lazy future ... done
[17:47:51.612] run() for ‘SequentialFuture’ ... done
[17:47:51.612] resolved() for ‘SequentialFuture’ ...
[17:47:51.612] - state: ‘finished’
[17:47:51.612] - run: TRUE
[17:47:51.613] - result: ‘FutureResult’
[17:47:51.613] resolved() for ‘SequentialFuture’ ... done
[17:47:51.613] Future #2
[17:47:51.613]  length: 1 (resolved future 2)
[17:47:51.613]  length: 0 (resolved future 3)
[17:47:51.613] resolve() on list ... DONE
[17:47:51.613] resolved() for ‘SequentialFuture’ ...
[17:47:51.613] - state: ‘finished’
[17:47:51.613] - run: TRUE
[17:47:51.613] - result: ‘FutureResult’
[17:47:51.613] resolved() for ‘SequentialFuture’ ... done
[17:47:51.614] resolved() for ‘SequentialFuture’ ...
[17:47:51.614] - state: ‘finished’
[17:47:51.614] - run: TRUE
[17:47:51.614] - result: ‘FutureResult’
[17:47:51.614] resolved() for ‘SequentialFuture’ ... done
[17:47:51.614] getGlobalsAndPackages() ...
[17:47:51.614] Searching for globals...
[17:47:51.614] 
[17:47:51.614] Searching for globals ... DONE
[17:47:51.614] - globals: [0] <none>
[17:47:51.615] getGlobalsAndPackages() ... DONE
[17:47:51.615] run() for ‘Future’ ...
[17:47:51.615] - state: ‘created’
[17:47:51.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.615] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.615]   - Field: ‘label’
[17:47:51.616]   - Field: ‘local’
[17:47:51.616]   - Field: ‘owner’
[17:47:51.616]   - Field: ‘envir’
[17:47:51.616]   - Field: ‘packages’
[17:47:51.616]   - Field: ‘gc’
[17:47:51.616]   - Field: ‘conditions’
[17:47:51.616]   - Field: ‘expr’
[17:47:51.616]   - Field: ‘uuid’
[17:47:51.616]   - Field: ‘seed’
[17:47:51.616]   - Field: ‘version’
[17:47:51.616]   - Field: ‘result’
[17:47:51.617]   - Field: ‘asynchronous’
[17:47:51.617]   - Field: ‘calls’
[17:47:51.617]   - Field: ‘globals’
[17:47:51.617]   - Field: ‘stdout’
[17:47:51.617]   - Field: ‘earlySignal’
[17:47:51.617]   - Field: ‘lazy’
[17:47:51.617]   - Field: ‘state’
[17:47:51.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.617] - Launch lazy future ...
[17:47:51.617] Packages needed by the future expression (n = 0): <none>
[17:47:51.617] Packages needed by future strategies (n = 0): <none>
[17:47:51.618] {
[17:47:51.618]     {
[17:47:51.618]         {
[17:47:51.618]             ...future.startTime <- base::Sys.time()
[17:47:51.618]             {
[17:47:51.618]                 {
[17:47:51.618]                   {
[17:47:51.618]                     base::local({
[17:47:51.618]                       has_future <- base::requireNamespace("future", 
[17:47:51.618]                         quietly = TRUE)
[17:47:51.618]                       if (has_future) {
[17:47:51.618]                         ns <- base::getNamespace("future")
[17:47:51.618]                         version <- ns[[".package"]][["version"]]
[17:47:51.618]                         if (is.null(version)) 
[17:47:51.618]                           version <- utils::packageVersion("future")
[17:47:51.618]                       }
[17:47:51.618]                       else {
[17:47:51.618]                         version <- NULL
[17:47:51.618]                       }
[17:47:51.618]                       if (!has_future || version < "1.8.0") {
[17:47:51.618]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.618]                           "", base::R.version$version.string), 
[17:47:51.618]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.618]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.618]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.618]                             "release", "version")], collapse = " "), 
[17:47:51.618]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.618]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.618]                           info)
[17:47:51.618]                         info <- base::paste(info, collapse = "; ")
[17:47:51.618]                         if (!has_future) {
[17:47:51.618]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.618]                             info)
[17:47:51.618]                         }
[17:47:51.618]                         else {
[17:47:51.618]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.618]                             info, version)
[17:47:51.618]                         }
[17:47:51.618]                         base::stop(msg)
[17:47:51.618]                       }
[17:47:51.618]                     })
[17:47:51.618]                   }
[17:47:51.618]                   ...future.strategy.old <- future::plan("list")
[17:47:51.618]                   options(future.plan = NULL)
[17:47:51.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.618]                 }
[17:47:51.618]                 ...future.workdir <- getwd()
[17:47:51.618]             }
[17:47:51.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.618]         }
[17:47:51.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.618]             base::names(...future.oldOptions))
[17:47:51.618]     }
[17:47:51.618]     if (FALSE) {
[17:47:51.618]     }
[17:47:51.618]     else {
[17:47:51.618]         if (TRUE) {
[17:47:51.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.618]                 open = "w")
[17:47:51.618]         }
[17:47:51.618]         else {
[17:47:51.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.618]         }
[17:47:51.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.618]             base::sink(type = "output", split = FALSE)
[17:47:51.618]             base::close(...future.stdout)
[17:47:51.618]         }, add = TRUE)
[17:47:51.618]     }
[17:47:51.618]     ...future.frame <- base::sys.nframe()
[17:47:51.618]     ...future.conditions <- base::list()
[17:47:51.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.618]     if (FALSE) {
[17:47:51.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.618]     }
[17:47:51.618]     ...future.result <- base::tryCatch({
[17:47:51.618]         base::withCallingHandlers({
[17:47:51.618]             ...future.value <- base::withVisible(base::local(1))
[17:47:51.618]             future::FutureResult(value = ...future.value$value, 
[17:47:51.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.618]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.618]                     ...future.globalenv.names))
[17:47:51.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.618]         }, condition = base::local({
[17:47:51.618]             c <- base::c
[17:47:51.618]             inherits <- base::inherits
[17:47:51.618]             invokeRestart <- base::invokeRestart
[17:47:51.618]             length <- base::length
[17:47:51.618]             list <- base::list
[17:47:51.618]             seq.int <- base::seq.int
[17:47:51.618]             signalCondition <- base::signalCondition
[17:47:51.618]             sys.calls <- base::sys.calls
[17:47:51.618]             `[[` <- base::`[[`
[17:47:51.618]             `+` <- base::`+`
[17:47:51.618]             `<<-` <- base::`<<-`
[17:47:51.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.618]                   3L)]
[17:47:51.618]             }
[17:47:51.618]             function(cond) {
[17:47:51.618]                 is_error <- inherits(cond, "error")
[17:47:51.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.618]                   NULL)
[17:47:51.618]                 if (is_error) {
[17:47:51.618]                   sessionInformation <- function() {
[17:47:51.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.618]                       search = base::search(), system = base::Sys.info())
[17:47:51.618]                   }
[17:47:51.618]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.618]                     cond$call), session = sessionInformation(), 
[17:47:51.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.618]                   signalCondition(cond)
[17:47:51.618]                 }
[17:47:51.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.618]                 "immediateCondition"))) {
[17:47:51.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.618]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.618]                   if (TRUE && !signal) {
[17:47:51.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.618]                     {
[17:47:51.618]                       inherits <- base::inherits
[17:47:51.618]                       invokeRestart <- base::invokeRestart
[17:47:51.618]                       is.null <- base::is.null
[17:47:51.618]                       muffled <- FALSE
[17:47:51.618]                       if (inherits(cond, "message")) {
[17:47:51.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.618]                         if (muffled) 
[17:47:51.618]                           invokeRestart("muffleMessage")
[17:47:51.618]                       }
[17:47:51.618]                       else if (inherits(cond, "warning")) {
[17:47:51.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.618]                         if (muffled) 
[17:47:51.618]                           invokeRestart("muffleWarning")
[17:47:51.618]                       }
[17:47:51.618]                       else if (inherits(cond, "condition")) {
[17:47:51.618]                         if (!is.null(pattern)) {
[17:47:51.618]                           computeRestarts <- base::computeRestarts
[17:47:51.618]                           grepl <- base::grepl
[17:47:51.618]                           restarts <- computeRestarts(cond)
[17:47:51.618]                           for (restart in restarts) {
[17:47:51.618]                             name <- restart$name
[17:47:51.618]                             if (is.null(name)) 
[17:47:51.618]                               next
[17:47:51.618]                             if (!grepl(pattern, name)) 
[17:47:51.618]                               next
[17:47:51.618]                             invokeRestart(restart)
[17:47:51.618]                             muffled <- TRUE
[17:47:51.618]                             break
[17:47:51.618]                           }
[17:47:51.618]                         }
[17:47:51.618]                       }
[17:47:51.618]                       invisible(muffled)
[17:47:51.618]                     }
[17:47:51.618]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.618]                   }
[17:47:51.618]                 }
[17:47:51.618]                 else {
[17:47:51.618]                   if (TRUE) {
[17:47:51.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.618]                     {
[17:47:51.618]                       inherits <- base::inherits
[17:47:51.618]                       invokeRestart <- base::invokeRestart
[17:47:51.618]                       is.null <- base::is.null
[17:47:51.618]                       muffled <- FALSE
[17:47:51.618]                       if (inherits(cond, "message")) {
[17:47:51.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.618]                         if (muffled) 
[17:47:51.618]                           invokeRestart("muffleMessage")
[17:47:51.618]                       }
[17:47:51.618]                       else if (inherits(cond, "warning")) {
[17:47:51.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.618]                         if (muffled) 
[17:47:51.618]                           invokeRestart("muffleWarning")
[17:47:51.618]                       }
[17:47:51.618]                       else if (inherits(cond, "condition")) {
[17:47:51.618]                         if (!is.null(pattern)) {
[17:47:51.618]                           computeRestarts <- base::computeRestarts
[17:47:51.618]                           grepl <- base::grepl
[17:47:51.618]                           restarts <- computeRestarts(cond)
[17:47:51.618]                           for (restart in restarts) {
[17:47:51.618]                             name <- restart$name
[17:47:51.618]                             if (is.null(name)) 
[17:47:51.618]                               next
[17:47:51.618]                             if (!grepl(pattern, name)) 
[17:47:51.618]                               next
[17:47:51.618]                             invokeRestart(restart)
[17:47:51.618]                             muffled <- TRUE
[17:47:51.618]                             break
[17:47:51.618]                           }
[17:47:51.618]                         }
[17:47:51.618]                       }
[17:47:51.618]                       invisible(muffled)
[17:47:51.618]                     }
[17:47:51.618]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.618]                   }
[17:47:51.618]                 }
[17:47:51.618]             }
[17:47:51.618]         }))
[17:47:51.618]     }, error = function(ex) {
[17:47:51.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.618]                 ...future.rng), started = ...future.startTime, 
[17:47:51.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.618]             version = "1.8"), class = "FutureResult")
[17:47:51.618]     }, finally = {
[17:47:51.618]         if (!identical(...future.workdir, getwd())) 
[17:47:51.618]             setwd(...future.workdir)
[17:47:51.618]         {
[17:47:51.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.618]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.618]             }
[17:47:51.618]             base::options(...future.oldOptions)
[17:47:51.618]             if (.Platform$OS.type == "windows") {
[17:47:51.618]                 old_names <- names(...future.oldEnvVars)
[17:47:51.618]                 envs <- base::Sys.getenv()
[17:47:51.618]                 names <- names(envs)
[17:47:51.618]                 common <- intersect(names, old_names)
[17:47:51.618]                 added <- setdiff(names, old_names)
[17:47:51.618]                 removed <- setdiff(old_names, names)
[17:47:51.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.618]                   envs[common]]
[17:47:51.618]                 NAMES <- toupper(changed)
[17:47:51.618]                 args <- list()
[17:47:51.618]                 for (kk in seq_along(NAMES)) {
[17:47:51.618]                   name <- changed[[kk]]
[17:47:51.618]                   NAME <- NAMES[[kk]]
[17:47:51.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.618]                     next
[17:47:51.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.618]                 }
[17:47:51.618]                 NAMES <- toupper(added)
[17:47:51.618]                 for (kk in seq_along(NAMES)) {
[17:47:51.618]                   name <- added[[kk]]
[17:47:51.618]                   NAME <- NAMES[[kk]]
[17:47:51.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.618]                     next
[17:47:51.618]                   args[[name]] <- ""
[17:47:51.618]                 }
[17:47:51.618]                 NAMES <- toupper(removed)
[17:47:51.618]                 for (kk in seq_along(NAMES)) {
[17:47:51.618]                   name <- removed[[kk]]
[17:47:51.618]                   NAME <- NAMES[[kk]]
[17:47:51.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.618]                     next
[17:47:51.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.618]                 }
[17:47:51.618]                 if (length(args) > 0) 
[17:47:51.618]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.618]             }
[17:47:51.618]             else {
[17:47:51.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.618]             }
[17:47:51.618]             {
[17:47:51.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.618]                   0L) {
[17:47:51.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.618]                   base::options(opts)
[17:47:51.618]                 }
[17:47:51.618]                 {
[17:47:51.618]                   {
[17:47:51.618]                     NULL
[17:47:51.618]                     RNGkind("Mersenne-Twister")
[17:47:51.618]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.618]                       inherits = FALSE)
[17:47:51.618]                   }
[17:47:51.618]                   options(future.plan = NULL)
[17:47:51.618]                   if (is.na(NA_character_)) 
[17:47:51.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.618]                     .init = FALSE)
[17:47:51.618]                 }
[17:47:51.618]             }
[17:47:51.618]         }
[17:47:51.618]     })
[17:47:51.618]     if (TRUE) {
[17:47:51.618]         base::sink(type = "output", split = FALSE)
[17:47:51.618]         if (TRUE) {
[17:47:51.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.618]         }
[17:47:51.618]         else {
[17:47:51.618]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.618]         }
[17:47:51.618]         base::close(...future.stdout)
[17:47:51.618]         ...future.stdout <- NULL
[17:47:51.618]     }
[17:47:51.618]     ...future.result$conditions <- ...future.conditions
[17:47:51.618]     ...future.result$finished <- base::Sys.time()
[17:47:51.618]     ...future.result
[17:47:51.618] }
[17:47:51.620] plan(): Setting new future strategy stack:
[17:47:51.620] List of future strategies:
[17:47:51.620] 1. sequential:
[17:47:51.620]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.620]    - tweaked: FALSE
[17:47:51.620]    - call: NULL
[17:47:51.620] plan(): nbrOfWorkers() = 1
[17:47:51.621] plan(): Setting new future strategy stack:
[17:47:51.621] List of future strategies:
[17:47:51.621] 1. sequential:
[17:47:51.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.621]    - tweaked: FALSE
[17:47:51.621]    - call: plan(strategy)
[17:47:51.621] plan(): nbrOfWorkers() = 1
[17:47:51.621] SequentialFuture started (and completed)
[17:47:51.621] - Launch lazy future ... done
[17:47:51.622] run() for ‘SequentialFuture’ ... done
[17:47:51.622] getGlobalsAndPackages() ...
[17:47:51.622] Searching for globals...
[17:47:51.627] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:47:51.628] Searching for globals ... DONE
[17:47:51.628] Resolving globals: FALSE
[17:47:51.628] 
[17:47:51.628] 
[17:47:51.628] getGlobalsAndPackages() ... DONE
[17:47:51.629] run() for ‘Future’ ...
[17:47:51.629] - state: ‘created’
[17:47:51.629] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:51.629] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:51.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:51.629]   - Field: ‘label’
[17:47:51.629]   - Field: ‘local’
[17:47:51.629]   - Field: ‘owner’
[17:47:51.630]   - Field: ‘envir’
[17:47:51.630]   - Field: ‘packages’
[17:47:51.630]   - Field: ‘gc’
[17:47:51.630]   - Field: ‘conditions’
[17:47:51.630]   - Field: ‘expr’
[17:47:51.630]   - Field: ‘uuid’
[17:47:51.630]   - Field: ‘seed’
[17:47:51.630]   - Field: ‘version’
[17:47:51.630]   - Field: ‘result’
[17:47:51.630]   - Field: ‘asynchronous’
[17:47:51.630]   - Field: ‘calls’
[17:47:51.630]   - Field: ‘globals’
[17:47:51.631]   - Field: ‘stdout’
[17:47:51.631]   - Field: ‘earlySignal’
[17:47:51.631]   - Field: ‘lazy’
[17:47:51.631]   - Field: ‘state’
[17:47:51.631] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:51.631] - Launch lazy future ...
[17:47:51.631] Packages needed by the future expression (n = 0): <none>
[17:47:51.631] Packages needed by future strategies (n = 0): <none>
[17:47:51.632] {
[17:47:51.632]     {
[17:47:51.632]         {
[17:47:51.632]             ...future.startTime <- base::Sys.time()
[17:47:51.632]             {
[17:47:51.632]                 {
[17:47:51.632]                   {
[17:47:51.632]                     base::local({
[17:47:51.632]                       has_future <- base::requireNamespace("future", 
[17:47:51.632]                         quietly = TRUE)
[17:47:51.632]                       if (has_future) {
[17:47:51.632]                         ns <- base::getNamespace("future")
[17:47:51.632]                         version <- ns[[".package"]][["version"]]
[17:47:51.632]                         if (is.null(version)) 
[17:47:51.632]                           version <- utils::packageVersion("future")
[17:47:51.632]                       }
[17:47:51.632]                       else {
[17:47:51.632]                         version <- NULL
[17:47:51.632]                       }
[17:47:51.632]                       if (!has_future || version < "1.8.0") {
[17:47:51.632]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:51.632]                           "", base::R.version$version.string), 
[17:47:51.632]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:51.632]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:51.632]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:51.632]                             "release", "version")], collapse = " "), 
[17:47:51.632]                           hostname = base::Sys.info()[["nodename"]])
[17:47:51.632]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:51.632]                           info)
[17:47:51.632]                         info <- base::paste(info, collapse = "; ")
[17:47:51.632]                         if (!has_future) {
[17:47:51.632]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:51.632]                             info)
[17:47:51.632]                         }
[17:47:51.632]                         else {
[17:47:51.632]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:51.632]                             info, version)
[17:47:51.632]                         }
[17:47:51.632]                         base::stop(msg)
[17:47:51.632]                       }
[17:47:51.632]                     })
[17:47:51.632]                   }
[17:47:51.632]                   ...future.strategy.old <- future::plan("list")
[17:47:51.632]                   options(future.plan = NULL)
[17:47:51.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:51.632]                 }
[17:47:51.632]                 ...future.workdir <- getwd()
[17:47:51.632]             }
[17:47:51.632]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:51.632]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:51.632]         }
[17:47:51.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:51.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:51.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:51.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:51.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:51.632]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:51.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:51.632]             base::names(...future.oldOptions))
[17:47:51.632]     }
[17:47:51.632]     if (FALSE) {
[17:47:51.632]     }
[17:47:51.632]     else {
[17:47:51.632]         if (TRUE) {
[17:47:51.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:51.632]                 open = "w")
[17:47:51.632]         }
[17:47:51.632]         else {
[17:47:51.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:51.632]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:51.632]         }
[17:47:51.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:51.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:51.632]             base::sink(type = "output", split = FALSE)
[17:47:51.632]             base::close(...future.stdout)
[17:47:51.632]         }, add = TRUE)
[17:47:51.632]     }
[17:47:51.632]     ...future.frame <- base::sys.nframe()
[17:47:51.632]     ...future.conditions <- base::list()
[17:47:51.632]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:51.632]     if (FALSE) {
[17:47:51.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:51.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:51.632]     }
[17:47:51.632]     ...future.result <- base::tryCatch({
[17:47:51.632]         base::withCallingHandlers({
[17:47:51.632]             ...future.value <- base::withVisible(base::local({
[17:47:51.632]                 Sys.sleep(0.5)
[17:47:51.632]                 2
[17:47:51.632]             }))
[17:47:51.632]             future::FutureResult(value = ...future.value$value, 
[17:47:51.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.632]                   ...future.rng), globalenv = if (FALSE) 
[17:47:51.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:51.632]                     ...future.globalenv.names))
[17:47:51.632]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:51.632]         }, condition = base::local({
[17:47:51.632]             c <- base::c
[17:47:51.632]             inherits <- base::inherits
[17:47:51.632]             invokeRestart <- base::invokeRestart
[17:47:51.632]             length <- base::length
[17:47:51.632]             list <- base::list
[17:47:51.632]             seq.int <- base::seq.int
[17:47:51.632]             signalCondition <- base::signalCondition
[17:47:51.632]             sys.calls <- base::sys.calls
[17:47:51.632]             `[[` <- base::`[[`
[17:47:51.632]             `+` <- base::`+`
[17:47:51.632]             `<<-` <- base::`<<-`
[17:47:51.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:51.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:51.632]                   3L)]
[17:47:51.632]             }
[17:47:51.632]             function(cond) {
[17:47:51.632]                 is_error <- inherits(cond, "error")
[17:47:51.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:51.632]                   NULL)
[17:47:51.632]                 if (is_error) {
[17:47:51.632]                   sessionInformation <- function() {
[17:47:51.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:51.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:51.632]                       search = base::search(), system = base::Sys.info())
[17:47:51.632]                   }
[17:47:51.632]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:51.632]                     cond$call), session = sessionInformation(), 
[17:47:51.632]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:51.632]                   signalCondition(cond)
[17:47:51.632]                 }
[17:47:51.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:51.632]                 "immediateCondition"))) {
[17:47:51.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:51.632]                   ...future.conditions[[length(...future.conditions) + 
[17:47:51.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:51.632]                   if (TRUE && !signal) {
[17:47:51.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.632]                     {
[17:47:51.632]                       inherits <- base::inherits
[17:47:51.632]                       invokeRestart <- base::invokeRestart
[17:47:51.632]                       is.null <- base::is.null
[17:47:51.632]                       muffled <- FALSE
[17:47:51.632]                       if (inherits(cond, "message")) {
[17:47:51.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.632]                         if (muffled) 
[17:47:51.632]                           invokeRestart("muffleMessage")
[17:47:51.632]                       }
[17:47:51.632]                       else if (inherits(cond, "warning")) {
[17:47:51.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.632]                         if (muffled) 
[17:47:51.632]                           invokeRestart("muffleWarning")
[17:47:51.632]                       }
[17:47:51.632]                       else if (inherits(cond, "condition")) {
[17:47:51.632]                         if (!is.null(pattern)) {
[17:47:51.632]                           computeRestarts <- base::computeRestarts
[17:47:51.632]                           grepl <- base::grepl
[17:47:51.632]                           restarts <- computeRestarts(cond)
[17:47:51.632]                           for (restart in restarts) {
[17:47:51.632]                             name <- restart$name
[17:47:51.632]                             if (is.null(name)) 
[17:47:51.632]                               next
[17:47:51.632]                             if (!grepl(pattern, name)) 
[17:47:51.632]                               next
[17:47:51.632]                             invokeRestart(restart)
[17:47:51.632]                             muffled <- TRUE
[17:47:51.632]                             break
[17:47:51.632]                           }
[17:47:51.632]                         }
[17:47:51.632]                       }
[17:47:51.632]                       invisible(muffled)
[17:47:51.632]                     }
[17:47:51.632]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.632]                   }
[17:47:51.632]                 }
[17:47:51.632]                 else {
[17:47:51.632]                   if (TRUE) {
[17:47:51.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:51.632]                     {
[17:47:51.632]                       inherits <- base::inherits
[17:47:51.632]                       invokeRestart <- base::invokeRestart
[17:47:51.632]                       is.null <- base::is.null
[17:47:51.632]                       muffled <- FALSE
[17:47:51.632]                       if (inherits(cond, "message")) {
[17:47:51.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:51.632]                         if (muffled) 
[17:47:51.632]                           invokeRestart("muffleMessage")
[17:47:51.632]                       }
[17:47:51.632]                       else if (inherits(cond, "warning")) {
[17:47:51.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:51.632]                         if (muffled) 
[17:47:51.632]                           invokeRestart("muffleWarning")
[17:47:51.632]                       }
[17:47:51.632]                       else if (inherits(cond, "condition")) {
[17:47:51.632]                         if (!is.null(pattern)) {
[17:47:51.632]                           computeRestarts <- base::computeRestarts
[17:47:51.632]                           grepl <- base::grepl
[17:47:51.632]                           restarts <- computeRestarts(cond)
[17:47:51.632]                           for (restart in restarts) {
[17:47:51.632]                             name <- restart$name
[17:47:51.632]                             if (is.null(name)) 
[17:47:51.632]                               next
[17:47:51.632]                             if (!grepl(pattern, name)) 
[17:47:51.632]                               next
[17:47:51.632]                             invokeRestart(restart)
[17:47:51.632]                             muffled <- TRUE
[17:47:51.632]                             break
[17:47:51.632]                           }
[17:47:51.632]                         }
[17:47:51.632]                       }
[17:47:51.632]                       invisible(muffled)
[17:47:51.632]                     }
[17:47:51.632]                     muffleCondition(cond, pattern = "^muffle")
[17:47:51.632]                   }
[17:47:51.632]                 }
[17:47:51.632]             }
[17:47:51.632]         }))
[17:47:51.632]     }, error = function(ex) {
[17:47:51.632]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:51.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:51.632]                 ...future.rng), started = ...future.startTime, 
[17:47:51.632]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:51.632]             version = "1.8"), class = "FutureResult")
[17:47:51.632]     }, finally = {
[17:47:51.632]         if (!identical(...future.workdir, getwd())) 
[17:47:51.632]             setwd(...future.workdir)
[17:47:51.632]         {
[17:47:51.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:51.632]                 ...future.oldOptions$nwarnings <- NULL
[17:47:51.632]             }
[17:47:51.632]             base::options(...future.oldOptions)
[17:47:51.632]             if (.Platform$OS.type == "windows") {
[17:47:51.632]                 old_names <- names(...future.oldEnvVars)
[17:47:51.632]                 envs <- base::Sys.getenv()
[17:47:51.632]                 names <- names(envs)
[17:47:51.632]                 common <- intersect(names, old_names)
[17:47:51.632]                 added <- setdiff(names, old_names)
[17:47:51.632]                 removed <- setdiff(old_names, names)
[17:47:51.632]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:51.632]                   envs[common]]
[17:47:51.632]                 NAMES <- toupper(changed)
[17:47:51.632]                 args <- list()
[17:47:51.632]                 for (kk in seq_along(NAMES)) {
[17:47:51.632]                   name <- changed[[kk]]
[17:47:51.632]                   NAME <- NAMES[[kk]]
[17:47:51.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.632]                     next
[17:47:51.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.632]                 }
[17:47:51.632]                 NAMES <- toupper(added)
[17:47:51.632]                 for (kk in seq_along(NAMES)) {
[17:47:51.632]                   name <- added[[kk]]
[17:47:51.632]                   NAME <- NAMES[[kk]]
[17:47:51.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.632]                     next
[17:47:51.632]                   args[[name]] <- ""
[17:47:51.632]                 }
[17:47:51.632]                 NAMES <- toupper(removed)
[17:47:51.632]                 for (kk in seq_along(NAMES)) {
[17:47:51.632]                   name <- removed[[kk]]
[17:47:51.632]                   NAME <- NAMES[[kk]]
[17:47:51.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:51.632]                     next
[17:47:51.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:51.632]                 }
[17:47:51.632]                 if (length(args) > 0) 
[17:47:51.632]                   base::do.call(base::Sys.setenv, args = args)
[17:47:51.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:51.632]             }
[17:47:51.632]             else {
[17:47:51.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:51.632]             }
[17:47:51.632]             {
[17:47:51.632]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:51.632]                   0L) {
[17:47:51.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:51.632]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:51.632]                   base::options(opts)
[17:47:51.632]                 }
[17:47:51.632]                 {
[17:47:51.632]                   {
[17:47:51.632]                     NULL
[17:47:51.632]                     RNGkind("Mersenne-Twister")
[17:47:51.632]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:51.632]                       inherits = FALSE)
[17:47:51.632]                   }
[17:47:51.632]                   options(future.plan = NULL)
[17:47:51.632]                   if (is.na(NA_character_)) 
[17:47:51.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:51.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:51.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:51.632]                     .init = FALSE)
[17:47:51.632]                 }
[17:47:51.632]             }
[17:47:51.632]         }
[17:47:51.632]     })
[17:47:51.632]     if (TRUE) {
[17:47:51.632]         base::sink(type = "output", split = FALSE)
[17:47:51.632]         if (TRUE) {
[17:47:51.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:51.632]         }
[17:47:51.632]         else {
[17:47:51.632]             ...future.result["stdout"] <- base::list(NULL)
[17:47:51.632]         }
[17:47:51.632]         base::close(...future.stdout)
[17:47:51.632]         ...future.stdout <- NULL
[17:47:51.632]     }
[17:47:51.632]     ...future.result$conditions <- ...future.conditions
[17:47:51.632]     ...future.result$finished <- base::Sys.time()
[17:47:51.632]     ...future.result
[17:47:51.632] }
[17:47:51.633] plan(): Setting new future strategy stack:
[17:47:51.633] List of future strategies:
[17:47:51.633] 1. sequential:
[17:47:51.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:51.633]    - tweaked: FALSE
[17:47:51.633]    - call: NULL
[17:47:51.634] plan(): nbrOfWorkers() = 1
[17:47:52.135] plan(): Setting new future strategy stack:
[17:47:52.136] List of future strategies:
[17:47:52.136] 1. sequential:
[17:47:52.136]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.136]    - tweaked: FALSE
[17:47:52.136]    - call: plan(strategy)
[17:47:52.136] plan(): nbrOfWorkers() = 1
[17:47:52.136] SequentialFuture started (and completed)
[17:47:52.137] - Launch lazy future ... done
[17:47:52.137] run() for ‘SequentialFuture’ ... done
[17:47:52.137] resolve() on list ...
[17:47:52.137]  recursive: 0
[17:47:52.137]  length: 1
[17:47:52.137] 
[17:47:52.138] resolved() for ‘SequentialFuture’ ...
[17:47:52.138] - state: ‘finished’
[17:47:52.138] - run: TRUE
[17:47:52.138] - result: ‘FutureResult’
[17:47:52.138] resolved() for ‘SequentialFuture’ ... done
[17:47:52.138] Future #1
[17:47:52.138]  length: 0 (resolved future 1)
[17:47:52.138] resolve() on list ... DONE
[17:47:52.138] resolved() for ‘SequentialFuture’ ...
[17:47:52.138] - state: ‘finished’
[17:47:52.139] - run: TRUE
[17:47:52.139] - result: ‘FutureResult’
[17:47:52.139] resolved() for ‘SequentialFuture’ ... done
[17:47:52.139] resolve() on list ...
[17:47:52.139]  recursive: 0
[17:47:52.139]  length: 1
[17:47:52.139] 
[17:47:52.139] resolved() for ‘SequentialFuture’ ...
[17:47:52.139] - state: ‘finished’
[17:47:52.139] - run: TRUE
[17:47:52.140] - result: ‘FutureResult’
[17:47:52.140] resolved() for ‘SequentialFuture’ ... done
[17:47:52.140] Future #1
[17:47:52.140]  length: 0 (resolved future 1)
[17:47:52.140] resolve() on list ... DONE
[17:47:52.140] resolved() for ‘SequentialFuture’ ...
[17:47:52.140] - state: ‘finished’
[17:47:52.140] - run: TRUE
[17:47:52.140] - result: ‘FutureResult’
[17:47:52.140] resolved() for ‘SequentialFuture’ ... done
[17:47:52.141] resolve() on list ...
[17:47:52.141]  recursive: 0
[17:47:52.141]  length: 1
[17:47:52.141] 
[17:47:52.141]  length: 0 (resolved future 1)
[17:47:52.141] resolve() on list ... DONE
[17:47:52.141] resolve() on list ...
[17:47:52.141]  recursive: 0
[17:47:52.141]  length: 4
[17:47:52.141] 
[17:47:52.142] resolved() for ‘SequentialFuture’ ...
[17:47:52.142] - state: ‘finished’
[17:47:52.142] - run: TRUE
[17:47:52.142] - result: ‘FutureResult’
[17:47:52.142] resolved() for ‘SequentialFuture’ ... done
[17:47:52.142] Future #1
[17:47:52.142]  length: 3 (resolved future 1)
[17:47:52.142] resolved() for ‘SequentialFuture’ ...
[17:47:52.142] - state: ‘finished’
[17:47:52.142] - run: TRUE
[17:47:52.142] - result: ‘FutureResult’
[17:47:52.142] resolved() for ‘SequentialFuture’ ... done
[17:47:52.143] Future #2
[17:47:52.143]  length: 2 (resolved future 2)
[17:47:52.143]  length: 1 (resolved future 3)
[17:47:52.143]  length: 0 (resolved future 4)
[17:47:52.143] resolve() on list ... DONE
[17:47:52.143] resolve() on list ...
[17:47:52.143]  recursive: 0
[17:47:52.143]  length: 4
[17:47:52.143] 
[17:47:52.143] resolved() for ‘SequentialFuture’ ...
[17:47:52.144] - state: ‘finished’
[17:47:52.144] - run: TRUE
[17:47:52.144] - result: ‘FutureResult’
[17:47:52.144] resolved() for ‘SequentialFuture’ ... done
[17:47:52.144] Future #1
[17:47:52.144]  length: 3 (resolved future 1)
[17:47:52.144] resolved() for ‘SequentialFuture’ ...
[17:47:52.144] - state: ‘finished’
[17:47:52.144] - run: TRUE
[17:47:52.144] - result: ‘FutureResult’
[17:47:52.144] resolved() for ‘SequentialFuture’ ... done
[17:47:52.145] Future #2
[17:47:52.145]  length: 2 (resolved future 2)
[17:47:52.145]  length: 1 (resolved future 3)
[17:47:52.145]  length: 0 (resolved future 4)
[17:47:52.145] resolve() on list ... DONE
[17:47:52.145] resolve() on list ...
[17:47:52.145]  recursive: 0
[17:47:52.145]  length: 1
[17:47:52.146] 
[17:47:52.146]  length: 0 (resolved future 1)
[17:47:52.146] resolve() on list ... DONE
[17:47:52.146] getGlobalsAndPackages() ...
[17:47:52.146] Searching for globals...
[17:47:52.147] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:52.147] Searching for globals ... DONE
[17:47:52.147] Resolving globals: FALSE
[17:47:52.148] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:52.148] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:52.148] - globals: [1] ‘kk’
[17:47:52.149] 
[17:47:52.149] getGlobalsAndPackages() ... DONE
[17:47:52.149] run() for ‘Future’ ...
[17:47:52.149] - state: ‘created’
[17:47:52.149] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.149] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.149] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.150]   - Field: ‘label’
[17:47:52.150]   - Field: ‘local’
[17:47:52.150]   - Field: ‘owner’
[17:47:52.150]   - Field: ‘envir’
[17:47:52.150]   - Field: ‘packages’
[17:47:52.150]   - Field: ‘gc’
[17:47:52.150]   - Field: ‘conditions’
[17:47:52.150]   - Field: ‘expr’
[17:47:52.150]   - Field: ‘uuid’
[17:47:52.150]   - Field: ‘seed’
[17:47:52.150]   - Field: ‘version’
[17:47:52.151]   - Field: ‘result’
[17:47:52.151]   - Field: ‘asynchronous’
[17:47:52.151]   - Field: ‘calls’
[17:47:52.151]   - Field: ‘globals’
[17:47:52.151]   - Field: ‘stdout’
[17:47:52.151]   - Field: ‘earlySignal’
[17:47:52.151]   - Field: ‘lazy’
[17:47:52.151]   - Field: ‘state’
[17:47:52.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.151] - Launch lazy future ...
[17:47:52.152] Packages needed by the future expression (n = 0): <none>
[17:47:52.152] Packages needed by future strategies (n = 0): <none>
[17:47:52.152] {
[17:47:52.152]     {
[17:47:52.152]         {
[17:47:52.152]             ...future.startTime <- base::Sys.time()
[17:47:52.152]             {
[17:47:52.152]                 {
[17:47:52.152]                   {
[17:47:52.152]                     base::local({
[17:47:52.152]                       has_future <- base::requireNamespace("future", 
[17:47:52.152]                         quietly = TRUE)
[17:47:52.152]                       if (has_future) {
[17:47:52.152]                         ns <- base::getNamespace("future")
[17:47:52.152]                         version <- ns[[".package"]][["version"]]
[17:47:52.152]                         if (is.null(version)) 
[17:47:52.152]                           version <- utils::packageVersion("future")
[17:47:52.152]                       }
[17:47:52.152]                       else {
[17:47:52.152]                         version <- NULL
[17:47:52.152]                       }
[17:47:52.152]                       if (!has_future || version < "1.8.0") {
[17:47:52.152]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.152]                           "", base::R.version$version.string), 
[17:47:52.152]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.152]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.152]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.152]                             "release", "version")], collapse = " "), 
[17:47:52.152]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.152]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.152]                           info)
[17:47:52.152]                         info <- base::paste(info, collapse = "; ")
[17:47:52.152]                         if (!has_future) {
[17:47:52.152]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.152]                             info)
[17:47:52.152]                         }
[17:47:52.152]                         else {
[17:47:52.152]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.152]                             info, version)
[17:47:52.152]                         }
[17:47:52.152]                         base::stop(msg)
[17:47:52.152]                       }
[17:47:52.152]                     })
[17:47:52.152]                   }
[17:47:52.152]                   ...future.strategy.old <- future::plan("list")
[17:47:52.152]                   options(future.plan = NULL)
[17:47:52.152]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.152]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.152]                 }
[17:47:52.152]                 ...future.workdir <- getwd()
[17:47:52.152]             }
[17:47:52.152]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.152]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.152]         }
[17:47:52.152]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.152]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.152]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.152]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.152]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.152]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.152]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.152]             base::names(...future.oldOptions))
[17:47:52.152]     }
[17:47:52.152]     if (FALSE) {
[17:47:52.152]     }
[17:47:52.152]     else {
[17:47:52.152]         if (TRUE) {
[17:47:52.152]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.152]                 open = "w")
[17:47:52.152]         }
[17:47:52.152]         else {
[17:47:52.152]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.152]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.152]         }
[17:47:52.152]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.152]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.152]             base::sink(type = "output", split = FALSE)
[17:47:52.152]             base::close(...future.stdout)
[17:47:52.152]         }, add = TRUE)
[17:47:52.152]     }
[17:47:52.152]     ...future.frame <- base::sys.nframe()
[17:47:52.152]     ...future.conditions <- base::list()
[17:47:52.152]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.152]     if (FALSE) {
[17:47:52.152]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.152]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.152]     }
[17:47:52.152]     ...future.result <- base::tryCatch({
[17:47:52.152]         base::withCallingHandlers({
[17:47:52.152]             ...future.value <- base::withVisible(base::local({
[17:47:52.152]                 Sys.sleep(0.1)
[17:47:52.152]                 kk
[17:47:52.152]             }))
[17:47:52.152]             future::FutureResult(value = ...future.value$value, 
[17:47:52.152]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.152]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.152]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.152]                     ...future.globalenv.names))
[17:47:52.152]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.152]         }, condition = base::local({
[17:47:52.152]             c <- base::c
[17:47:52.152]             inherits <- base::inherits
[17:47:52.152]             invokeRestart <- base::invokeRestart
[17:47:52.152]             length <- base::length
[17:47:52.152]             list <- base::list
[17:47:52.152]             seq.int <- base::seq.int
[17:47:52.152]             signalCondition <- base::signalCondition
[17:47:52.152]             sys.calls <- base::sys.calls
[17:47:52.152]             `[[` <- base::`[[`
[17:47:52.152]             `+` <- base::`+`
[17:47:52.152]             `<<-` <- base::`<<-`
[17:47:52.152]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.152]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.152]                   3L)]
[17:47:52.152]             }
[17:47:52.152]             function(cond) {
[17:47:52.152]                 is_error <- inherits(cond, "error")
[17:47:52.152]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.152]                   NULL)
[17:47:52.152]                 if (is_error) {
[17:47:52.152]                   sessionInformation <- function() {
[17:47:52.152]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.152]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.152]                       search = base::search(), system = base::Sys.info())
[17:47:52.152]                   }
[17:47:52.152]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.152]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.152]                     cond$call), session = sessionInformation(), 
[17:47:52.152]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.152]                   signalCondition(cond)
[17:47:52.152]                 }
[17:47:52.152]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.152]                 "immediateCondition"))) {
[17:47:52.152]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.152]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.152]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.152]                   if (TRUE && !signal) {
[17:47:52.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.152]                     {
[17:47:52.152]                       inherits <- base::inherits
[17:47:52.152]                       invokeRestart <- base::invokeRestart
[17:47:52.152]                       is.null <- base::is.null
[17:47:52.152]                       muffled <- FALSE
[17:47:52.152]                       if (inherits(cond, "message")) {
[17:47:52.152]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.152]                         if (muffled) 
[17:47:52.152]                           invokeRestart("muffleMessage")
[17:47:52.152]                       }
[17:47:52.152]                       else if (inherits(cond, "warning")) {
[17:47:52.152]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.152]                         if (muffled) 
[17:47:52.152]                           invokeRestart("muffleWarning")
[17:47:52.152]                       }
[17:47:52.152]                       else if (inherits(cond, "condition")) {
[17:47:52.152]                         if (!is.null(pattern)) {
[17:47:52.152]                           computeRestarts <- base::computeRestarts
[17:47:52.152]                           grepl <- base::grepl
[17:47:52.152]                           restarts <- computeRestarts(cond)
[17:47:52.152]                           for (restart in restarts) {
[17:47:52.152]                             name <- restart$name
[17:47:52.152]                             if (is.null(name)) 
[17:47:52.152]                               next
[17:47:52.152]                             if (!grepl(pattern, name)) 
[17:47:52.152]                               next
[17:47:52.152]                             invokeRestart(restart)
[17:47:52.152]                             muffled <- TRUE
[17:47:52.152]                             break
[17:47:52.152]                           }
[17:47:52.152]                         }
[17:47:52.152]                       }
[17:47:52.152]                       invisible(muffled)
[17:47:52.152]                     }
[17:47:52.152]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.152]                   }
[17:47:52.152]                 }
[17:47:52.152]                 else {
[17:47:52.152]                   if (TRUE) {
[17:47:52.152]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.152]                     {
[17:47:52.152]                       inherits <- base::inherits
[17:47:52.152]                       invokeRestart <- base::invokeRestart
[17:47:52.152]                       is.null <- base::is.null
[17:47:52.152]                       muffled <- FALSE
[17:47:52.152]                       if (inherits(cond, "message")) {
[17:47:52.152]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.152]                         if (muffled) 
[17:47:52.152]                           invokeRestart("muffleMessage")
[17:47:52.152]                       }
[17:47:52.152]                       else if (inherits(cond, "warning")) {
[17:47:52.152]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.152]                         if (muffled) 
[17:47:52.152]                           invokeRestart("muffleWarning")
[17:47:52.152]                       }
[17:47:52.152]                       else if (inherits(cond, "condition")) {
[17:47:52.152]                         if (!is.null(pattern)) {
[17:47:52.152]                           computeRestarts <- base::computeRestarts
[17:47:52.152]                           grepl <- base::grepl
[17:47:52.152]                           restarts <- computeRestarts(cond)
[17:47:52.152]                           for (restart in restarts) {
[17:47:52.152]                             name <- restart$name
[17:47:52.152]                             if (is.null(name)) 
[17:47:52.152]                               next
[17:47:52.152]                             if (!grepl(pattern, name)) 
[17:47:52.152]                               next
[17:47:52.152]                             invokeRestart(restart)
[17:47:52.152]                             muffled <- TRUE
[17:47:52.152]                             break
[17:47:52.152]                           }
[17:47:52.152]                         }
[17:47:52.152]                       }
[17:47:52.152]                       invisible(muffled)
[17:47:52.152]                     }
[17:47:52.152]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.152]                   }
[17:47:52.152]                 }
[17:47:52.152]             }
[17:47:52.152]         }))
[17:47:52.152]     }, error = function(ex) {
[17:47:52.152]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.152]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.152]                 ...future.rng), started = ...future.startTime, 
[17:47:52.152]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.152]             version = "1.8"), class = "FutureResult")
[17:47:52.152]     }, finally = {
[17:47:52.152]         if (!identical(...future.workdir, getwd())) 
[17:47:52.152]             setwd(...future.workdir)
[17:47:52.152]         {
[17:47:52.152]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.152]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.152]             }
[17:47:52.152]             base::options(...future.oldOptions)
[17:47:52.152]             if (.Platform$OS.type == "windows") {
[17:47:52.152]                 old_names <- names(...future.oldEnvVars)
[17:47:52.152]                 envs <- base::Sys.getenv()
[17:47:52.152]                 names <- names(envs)
[17:47:52.152]                 common <- intersect(names, old_names)
[17:47:52.152]                 added <- setdiff(names, old_names)
[17:47:52.152]                 removed <- setdiff(old_names, names)
[17:47:52.152]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.152]                   envs[common]]
[17:47:52.152]                 NAMES <- toupper(changed)
[17:47:52.152]                 args <- list()
[17:47:52.152]                 for (kk in seq_along(NAMES)) {
[17:47:52.152]                   name <- changed[[kk]]
[17:47:52.152]                   NAME <- NAMES[[kk]]
[17:47:52.152]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.152]                     next
[17:47:52.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.152]                 }
[17:47:52.152]                 NAMES <- toupper(added)
[17:47:52.152]                 for (kk in seq_along(NAMES)) {
[17:47:52.152]                   name <- added[[kk]]
[17:47:52.152]                   NAME <- NAMES[[kk]]
[17:47:52.152]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.152]                     next
[17:47:52.152]                   args[[name]] <- ""
[17:47:52.152]                 }
[17:47:52.152]                 NAMES <- toupper(removed)
[17:47:52.152]                 for (kk in seq_along(NAMES)) {
[17:47:52.152]                   name <- removed[[kk]]
[17:47:52.152]                   NAME <- NAMES[[kk]]
[17:47:52.152]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.152]                     next
[17:47:52.152]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.152]                 }
[17:47:52.152]                 if (length(args) > 0) 
[17:47:52.152]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.152]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.152]             }
[17:47:52.152]             else {
[17:47:52.152]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.152]             }
[17:47:52.152]             {
[17:47:52.152]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.152]                   0L) {
[17:47:52.152]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.152]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.152]                   base::options(opts)
[17:47:52.152]                 }
[17:47:52.152]                 {
[17:47:52.152]                   {
[17:47:52.152]                     NULL
[17:47:52.152]                     RNGkind("Mersenne-Twister")
[17:47:52.152]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.152]                       inherits = FALSE)
[17:47:52.152]                   }
[17:47:52.152]                   options(future.plan = NULL)
[17:47:52.152]                   if (is.na(NA_character_)) 
[17:47:52.152]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.152]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.152]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.152]                     .init = FALSE)
[17:47:52.152]                 }
[17:47:52.152]             }
[17:47:52.152]         }
[17:47:52.152]     })
[17:47:52.152]     if (TRUE) {
[17:47:52.152]         base::sink(type = "output", split = FALSE)
[17:47:52.152]         if (TRUE) {
[17:47:52.152]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.152]         }
[17:47:52.152]         else {
[17:47:52.152]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.152]         }
[17:47:52.152]         base::close(...future.stdout)
[17:47:52.152]         ...future.stdout <- NULL
[17:47:52.152]     }
[17:47:52.152]     ...future.result$conditions <- ...future.conditions
[17:47:52.152]     ...future.result$finished <- base::Sys.time()
[17:47:52.152]     ...future.result
[17:47:52.152] }
[17:47:52.154] assign_globals() ...
[17:47:52.154] List of 1
[17:47:52.154]  $ kk: int 1
[17:47:52.154]  - attr(*, "where")=List of 1
[17:47:52.154]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:52.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:52.154]  - attr(*, "resolved")= logi FALSE
[17:47:52.154]  - attr(*, "total_size")= num 56
[17:47:52.154]  - attr(*, "already-done")= logi TRUE
[17:47:52.160] - copied ‘kk’ to environment
[17:47:52.161] assign_globals() ... done
[17:47:52.161] plan(): Setting new future strategy stack:
[17:47:52.161] List of future strategies:
[17:47:52.161] 1. sequential:
[17:47:52.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.161]    - tweaked: FALSE
[17:47:52.161]    - call: NULL
[17:47:52.161] plan(): nbrOfWorkers() = 1
[17:47:52.262] plan(): Setting new future strategy stack:
[17:47:52.262] List of future strategies:
[17:47:52.262] 1. sequential:
[17:47:52.262]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.262]    - tweaked: FALSE
[17:47:52.262]    - call: plan(strategy)
[17:47:52.263] plan(): nbrOfWorkers() = 1
[17:47:52.263] SequentialFuture started (and completed)
[17:47:52.263] - Launch lazy future ... done
[17:47:52.263] run() for ‘SequentialFuture’ ... done
[17:47:52.264] getGlobalsAndPackages() ...
[17:47:52.264] Searching for globals...
[17:47:52.265] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:52.265] Searching for globals ... DONE
[17:47:52.265] Resolving globals: FALSE
[17:47:52.265] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:52.266] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:52.266] - globals: [1] ‘kk’
[17:47:52.266] 
[17:47:52.266] getGlobalsAndPackages() ... DONE
[17:47:52.266] run() for ‘Future’ ...
[17:47:52.266] - state: ‘created’
[17:47:52.266] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.267] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.267]   - Field: ‘label’
[17:47:52.267]   - Field: ‘local’
[17:47:52.267]   - Field: ‘owner’
[17:47:52.267]   - Field: ‘envir’
[17:47:52.267]   - Field: ‘packages’
[17:47:52.267]   - Field: ‘gc’
[17:47:52.267]   - Field: ‘conditions’
[17:47:52.267]   - Field: ‘expr’
[17:47:52.268]   - Field: ‘uuid’
[17:47:52.268]   - Field: ‘seed’
[17:47:52.268]   - Field: ‘version’
[17:47:52.268]   - Field: ‘result’
[17:47:52.268]   - Field: ‘asynchronous’
[17:47:52.268]   - Field: ‘calls’
[17:47:52.268]   - Field: ‘globals’
[17:47:52.268]   - Field: ‘stdout’
[17:47:52.268]   - Field: ‘earlySignal’
[17:47:52.268]   - Field: ‘lazy’
[17:47:52.268]   - Field: ‘state’
[17:47:52.269] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.269] - Launch lazy future ...
[17:47:52.269] Packages needed by the future expression (n = 0): <none>
[17:47:52.269] Packages needed by future strategies (n = 0): <none>
[17:47:52.269] {
[17:47:52.269]     {
[17:47:52.269]         {
[17:47:52.269]             ...future.startTime <- base::Sys.time()
[17:47:52.269]             {
[17:47:52.269]                 {
[17:47:52.269]                   {
[17:47:52.269]                     base::local({
[17:47:52.269]                       has_future <- base::requireNamespace("future", 
[17:47:52.269]                         quietly = TRUE)
[17:47:52.269]                       if (has_future) {
[17:47:52.269]                         ns <- base::getNamespace("future")
[17:47:52.269]                         version <- ns[[".package"]][["version"]]
[17:47:52.269]                         if (is.null(version)) 
[17:47:52.269]                           version <- utils::packageVersion("future")
[17:47:52.269]                       }
[17:47:52.269]                       else {
[17:47:52.269]                         version <- NULL
[17:47:52.269]                       }
[17:47:52.269]                       if (!has_future || version < "1.8.0") {
[17:47:52.269]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.269]                           "", base::R.version$version.string), 
[17:47:52.269]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.269]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.269]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.269]                             "release", "version")], collapse = " "), 
[17:47:52.269]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.269]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.269]                           info)
[17:47:52.269]                         info <- base::paste(info, collapse = "; ")
[17:47:52.269]                         if (!has_future) {
[17:47:52.269]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.269]                             info)
[17:47:52.269]                         }
[17:47:52.269]                         else {
[17:47:52.269]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.269]                             info, version)
[17:47:52.269]                         }
[17:47:52.269]                         base::stop(msg)
[17:47:52.269]                       }
[17:47:52.269]                     })
[17:47:52.269]                   }
[17:47:52.269]                   ...future.strategy.old <- future::plan("list")
[17:47:52.269]                   options(future.plan = NULL)
[17:47:52.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.269]                 }
[17:47:52.269]                 ...future.workdir <- getwd()
[17:47:52.269]             }
[17:47:52.269]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.269]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.269]         }
[17:47:52.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.269]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.269]             base::names(...future.oldOptions))
[17:47:52.269]     }
[17:47:52.269]     if (FALSE) {
[17:47:52.269]     }
[17:47:52.269]     else {
[17:47:52.269]         if (TRUE) {
[17:47:52.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.269]                 open = "w")
[17:47:52.269]         }
[17:47:52.269]         else {
[17:47:52.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.269]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.269]         }
[17:47:52.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.269]             base::sink(type = "output", split = FALSE)
[17:47:52.269]             base::close(...future.stdout)
[17:47:52.269]         }, add = TRUE)
[17:47:52.269]     }
[17:47:52.269]     ...future.frame <- base::sys.nframe()
[17:47:52.269]     ...future.conditions <- base::list()
[17:47:52.269]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.269]     if (FALSE) {
[17:47:52.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.269]     }
[17:47:52.269]     ...future.result <- base::tryCatch({
[17:47:52.269]         base::withCallingHandlers({
[17:47:52.269]             ...future.value <- base::withVisible(base::local({
[17:47:52.269]                 Sys.sleep(0.1)
[17:47:52.269]                 kk
[17:47:52.269]             }))
[17:47:52.269]             future::FutureResult(value = ...future.value$value, 
[17:47:52.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.269]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.269]                     ...future.globalenv.names))
[17:47:52.269]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.269]         }, condition = base::local({
[17:47:52.269]             c <- base::c
[17:47:52.269]             inherits <- base::inherits
[17:47:52.269]             invokeRestart <- base::invokeRestart
[17:47:52.269]             length <- base::length
[17:47:52.269]             list <- base::list
[17:47:52.269]             seq.int <- base::seq.int
[17:47:52.269]             signalCondition <- base::signalCondition
[17:47:52.269]             sys.calls <- base::sys.calls
[17:47:52.269]             `[[` <- base::`[[`
[17:47:52.269]             `+` <- base::`+`
[17:47:52.269]             `<<-` <- base::`<<-`
[17:47:52.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.269]                   3L)]
[17:47:52.269]             }
[17:47:52.269]             function(cond) {
[17:47:52.269]                 is_error <- inherits(cond, "error")
[17:47:52.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.269]                   NULL)
[17:47:52.269]                 if (is_error) {
[17:47:52.269]                   sessionInformation <- function() {
[17:47:52.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.269]                       search = base::search(), system = base::Sys.info())
[17:47:52.269]                   }
[17:47:52.269]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.269]                     cond$call), session = sessionInformation(), 
[17:47:52.269]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.269]                   signalCondition(cond)
[17:47:52.269]                 }
[17:47:52.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.269]                 "immediateCondition"))) {
[17:47:52.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.269]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.269]                   if (TRUE && !signal) {
[17:47:52.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.269]                     {
[17:47:52.269]                       inherits <- base::inherits
[17:47:52.269]                       invokeRestart <- base::invokeRestart
[17:47:52.269]                       is.null <- base::is.null
[17:47:52.269]                       muffled <- FALSE
[17:47:52.269]                       if (inherits(cond, "message")) {
[17:47:52.269]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.269]                         if (muffled) 
[17:47:52.269]                           invokeRestart("muffleMessage")
[17:47:52.269]                       }
[17:47:52.269]                       else if (inherits(cond, "warning")) {
[17:47:52.269]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.269]                         if (muffled) 
[17:47:52.269]                           invokeRestart("muffleWarning")
[17:47:52.269]                       }
[17:47:52.269]                       else if (inherits(cond, "condition")) {
[17:47:52.269]                         if (!is.null(pattern)) {
[17:47:52.269]                           computeRestarts <- base::computeRestarts
[17:47:52.269]                           grepl <- base::grepl
[17:47:52.269]                           restarts <- computeRestarts(cond)
[17:47:52.269]                           for (restart in restarts) {
[17:47:52.269]                             name <- restart$name
[17:47:52.269]                             if (is.null(name)) 
[17:47:52.269]                               next
[17:47:52.269]                             if (!grepl(pattern, name)) 
[17:47:52.269]                               next
[17:47:52.269]                             invokeRestart(restart)
[17:47:52.269]                             muffled <- TRUE
[17:47:52.269]                             break
[17:47:52.269]                           }
[17:47:52.269]                         }
[17:47:52.269]                       }
[17:47:52.269]                       invisible(muffled)
[17:47:52.269]                     }
[17:47:52.269]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.269]                   }
[17:47:52.269]                 }
[17:47:52.269]                 else {
[17:47:52.269]                   if (TRUE) {
[17:47:52.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.269]                     {
[17:47:52.269]                       inherits <- base::inherits
[17:47:52.269]                       invokeRestart <- base::invokeRestart
[17:47:52.269]                       is.null <- base::is.null
[17:47:52.269]                       muffled <- FALSE
[17:47:52.269]                       if (inherits(cond, "message")) {
[17:47:52.269]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.269]                         if (muffled) 
[17:47:52.269]                           invokeRestart("muffleMessage")
[17:47:52.269]                       }
[17:47:52.269]                       else if (inherits(cond, "warning")) {
[17:47:52.269]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.269]                         if (muffled) 
[17:47:52.269]                           invokeRestart("muffleWarning")
[17:47:52.269]                       }
[17:47:52.269]                       else if (inherits(cond, "condition")) {
[17:47:52.269]                         if (!is.null(pattern)) {
[17:47:52.269]                           computeRestarts <- base::computeRestarts
[17:47:52.269]                           grepl <- base::grepl
[17:47:52.269]                           restarts <- computeRestarts(cond)
[17:47:52.269]                           for (restart in restarts) {
[17:47:52.269]                             name <- restart$name
[17:47:52.269]                             if (is.null(name)) 
[17:47:52.269]                               next
[17:47:52.269]                             if (!grepl(pattern, name)) 
[17:47:52.269]                               next
[17:47:52.269]                             invokeRestart(restart)
[17:47:52.269]                             muffled <- TRUE
[17:47:52.269]                             break
[17:47:52.269]                           }
[17:47:52.269]                         }
[17:47:52.269]                       }
[17:47:52.269]                       invisible(muffled)
[17:47:52.269]                     }
[17:47:52.269]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.269]                   }
[17:47:52.269]                 }
[17:47:52.269]             }
[17:47:52.269]         }))
[17:47:52.269]     }, error = function(ex) {
[17:47:52.269]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.269]                 ...future.rng), started = ...future.startTime, 
[17:47:52.269]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.269]             version = "1.8"), class = "FutureResult")
[17:47:52.269]     }, finally = {
[17:47:52.269]         if (!identical(...future.workdir, getwd())) 
[17:47:52.269]             setwd(...future.workdir)
[17:47:52.269]         {
[17:47:52.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.269]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.269]             }
[17:47:52.269]             base::options(...future.oldOptions)
[17:47:52.269]             if (.Platform$OS.type == "windows") {
[17:47:52.269]                 old_names <- names(...future.oldEnvVars)
[17:47:52.269]                 envs <- base::Sys.getenv()
[17:47:52.269]                 names <- names(envs)
[17:47:52.269]                 common <- intersect(names, old_names)
[17:47:52.269]                 added <- setdiff(names, old_names)
[17:47:52.269]                 removed <- setdiff(old_names, names)
[17:47:52.269]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.269]                   envs[common]]
[17:47:52.269]                 NAMES <- toupper(changed)
[17:47:52.269]                 args <- list()
[17:47:52.269]                 for (kk in seq_along(NAMES)) {
[17:47:52.269]                   name <- changed[[kk]]
[17:47:52.269]                   NAME <- NAMES[[kk]]
[17:47:52.269]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.269]                     next
[17:47:52.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.269]                 }
[17:47:52.269]                 NAMES <- toupper(added)
[17:47:52.269]                 for (kk in seq_along(NAMES)) {
[17:47:52.269]                   name <- added[[kk]]
[17:47:52.269]                   NAME <- NAMES[[kk]]
[17:47:52.269]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.269]                     next
[17:47:52.269]                   args[[name]] <- ""
[17:47:52.269]                 }
[17:47:52.269]                 NAMES <- toupper(removed)
[17:47:52.269]                 for (kk in seq_along(NAMES)) {
[17:47:52.269]                   name <- removed[[kk]]
[17:47:52.269]                   NAME <- NAMES[[kk]]
[17:47:52.269]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.269]                     next
[17:47:52.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.269]                 }
[17:47:52.269]                 if (length(args) > 0) 
[17:47:52.269]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.269]             }
[17:47:52.269]             else {
[17:47:52.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.269]             }
[17:47:52.269]             {
[17:47:52.269]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.269]                   0L) {
[17:47:52.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.269]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.269]                   base::options(opts)
[17:47:52.269]                 }
[17:47:52.269]                 {
[17:47:52.269]                   {
[17:47:52.269]                     NULL
[17:47:52.269]                     RNGkind("Mersenne-Twister")
[17:47:52.269]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.269]                       inherits = FALSE)
[17:47:52.269]                   }
[17:47:52.269]                   options(future.plan = NULL)
[17:47:52.269]                   if (is.na(NA_character_)) 
[17:47:52.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.269]                     .init = FALSE)
[17:47:52.269]                 }
[17:47:52.269]             }
[17:47:52.269]         }
[17:47:52.269]     })
[17:47:52.269]     if (TRUE) {
[17:47:52.269]         base::sink(type = "output", split = FALSE)
[17:47:52.269]         if (TRUE) {
[17:47:52.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.269]         }
[17:47:52.269]         else {
[17:47:52.269]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.269]         }
[17:47:52.269]         base::close(...future.stdout)
[17:47:52.269]         ...future.stdout <- NULL
[17:47:52.269]     }
[17:47:52.269]     ...future.result$conditions <- ...future.conditions
[17:47:52.269]     ...future.result$finished <- base::Sys.time()
[17:47:52.269]     ...future.result
[17:47:52.269] }
[17:47:52.271] assign_globals() ...
[17:47:52.271] List of 1
[17:47:52.271]  $ kk: int 2
[17:47:52.271]  - attr(*, "where")=List of 1
[17:47:52.271]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:52.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:52.271]  - attr(*, "resolved")= logi FALSE
[17:47:52.271]  - attr(*, "total_size")= num 56
[17:47:52.271]  - attr(*, "already-done")= logi TRUE
[17:47:52.273] - copied ‘kk’ to environment
[17:47:52.273] assign_globals() ... done
[17:47:52.274] plan(): Setting new future strategy stack:
[17:47:52.274] List of future strategies:
[17:47:52.274] 1. sequential:
[17:47:52.274]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.274]    - tweaked: FALSE
[17:47:52.274]    - call: NULL
[17:47:52.274] plan(): nbrOfWorkers() = 1
[17:47:52.375] plan(): Setting new future strategy stack:
[17:47:52.375] List of future strategies:
[17:47:52.375] 1. sequential:
[17:47:52.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.375]    - tweaked: FALSE
[17:47:52.375]    - call: plan(strategy)
[17:47:52.376] plan(): nbrOfWorkers() = 1
[17:47:52.376] SequentialFuture started (and completed)
[17:47:52.376] - Launch lazy future ... done
[17:47:52.376] run() for ‘SequentialFuture’ ... done
[17:47:52.376] getGlobalsAndPackages() ...
[17:47:52.377] Searching for globals...
[17:47:52.377] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:52.378] Searching for globals ... DONE
[17:47:52.378] Resolving globals: FALSE
[17:47:52.378] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:52.378] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:52.378] - globals: [1] ‘kk’
[17:47:52.379] 
[17:47:52.379] getGlobalsAndPackages() ... DONE
[17:47:52.379] run() for ‘Future’ ...
[17:47:52.379] - state: ‘created’
[17:47:52.379] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.379] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.380]   - Field: ‘label’
[17:47:52.380]   - Field: ‘local’
[17:47:52.380]   - Field: ‘owner’
[17:47:52.380]   - Field: ‘envir’
[17:47:52.380]   - Field: ‘packages’
[17:47:52.380]   - Field: ‘gc’
[17:47:52.380]   - Field: ‘conditions’
[17:47:52.380]   - Field: ‘expr’
[17:47:52.380]   - Field: ‘uuid’
[17:47:52.380]   - Field: ‘seed’
[17:47:52.381]   - Field: ‘version’
[17:47:52.381]   - Field: ‘result’
[17:47:52.381]   - Field: ‘asynchronous’
[17:47:52.381]   - Field: ‘calls’
[17:47:52.381]   - Field: ‘globals’
[17:47:52.381]   - Field: ‘stdout’
[17:47:52.381]   - Field: ‘earlySignal’
[17:47:52.381]   - Field: ‘lazy’
[17:47:52.381]   - Field: ‘state’
[17:47:52.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.381] - Launch lazy future ...
[17:47:52.382] Packages needed by the future expression (n = 0): <none>
[17:47:52.382] Packages needed by future strategies (n = 0): <none>
[17:47:52.382] {
[17:47:52.382]     {
[17:47:52.382]         {
[17:47:52.382]             ...future.startTime <- base::Sys.time()
[17:47:52.382]             {
[17:47:52.382]                 {
[17:47:52.382]                   {
[17:47:52.382]                     base::local({
[17:47:52.382]                       has_future <- base::requireNamespace("future", 
[17:47:52.382]                         quietly = TRUE)
[17:47:52.382]                       if (has_future) {
[17:47:52.382]                         ns <- base::getNamespace("future")
[17:47:52.382]                         version <- ns[[".package"]][["version"]]
[17:47:52.382]                         if (is.null(version)) 
[17:47:52.382]                           version <- utils::packageVersion("future")
[17:47:52.382]                       }
[17:47:52.382]                       else {
[17:47:52.382]                         version <- NULL
[17:47:52.382]                       }
[17:47:52.382]                       if (!has_future || version < "1.8.0") {
[17:47:52.382]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.382]                           "", base::R.version$version.string), 
[17:47:52.382]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.382]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.382]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.382]                             "release", "version")], collapse = " "), 
[17:47:52.382]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.382]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.382]                           info)
[17:47:52.382]                         info <- base::paste(info, collapse = "; ")
[17:47:52.382]                         if (!has_future) {
[17:47:52.382]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.382]                             info)
[17:47:52.382]                         }
[17:47:52.382]                         else {
[17:47:52.382]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.382]                             info, version)
[17:47:52.382]                         }
[17:47:52.382]                         base::stop(msg)
[17:47:52.382]                       }
[17:47:52.382]                     })
[17:47:52.382]                   }
[17:47:52.382]                   ...future.strategy.old <- future::plan("list")
[17:47:52.382]                   options(future.plan = NULL)
[17:47:52.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.382]                 }
[17:47:52.382]                 ...future.workdir <- getwd()
[17:47:52.382]             }
[17:47:52.382]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.382]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.382]         }
[17:47:52.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.382]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.382]             base::names(...future.oldOptions))
[17:47:52.382]     }
[17:47:52.382]     if (FALSE) {
[17:47:52.382]     }
[17:47:52.382]     else {
[17:47:52.382]         if (TRUE) {
[17:47:52.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.382]                 open = "w")
[17:47:52.382]         }
[17:47:52.382]         else {
[17:47:52.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.382]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.382]         }
[17:47:52.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.382]             base::sink(type = "output", split = FALSE)
[17:47:52.382]             base::close(...future.stdout)
[17:47:52.382]         }, add = TRUE)
[17:47:52.382]     }
[17:47:52.382]     ...future.frame <- base::sys.nframe()
[17:47:52.382]     ...future.conditions <- base::list()
[17:47:52.382]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.382]     if (FALSE) {
[17:47:52.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.382]     }
[17:47:52.382]     ...future.result <- base::tryCatch({
[17:47:52.382]         base::withCallingHandlers({
[17:47:52.382]             ...future.value <- base::withVisible(base::local({
[17:47:52.382]                 Sys.sleep(0.1)
[17:47:52.382]                 kk
[17:47:52.382]             }))
[17:47:52.382]             future::FutureResult(value = ...future.value$value, 
[17:47:52.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.382]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.382]                     ...future.globalenv.names))
[17:47:52.382]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.382]         }, condition = base::local({
[17:47:52.382]             c <- base::c
[17:47:52.382]             inherits <- base::inherits
[17:47:52.382]             invokeRestart <- base::invokeRestart
[17:47:52.382]             length <- base::length
[17:47:52.382]             list <- base::list
[17:47:52.382]             seq.int <- base::seq.int
[17:47:52.382]             signalCondition <- base::signalCondition
[17:47:52.382]             sys.calls <- base::sys.calls
[17:47:52.382]             `[[` <- base::`[[`
[17:47:52.382]             `+` <- base::`+`
[17:47:52.382]             `<<-` <- base::`<<-`
[17:47:52.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.382]                   3L)]
[17:47:52.382]             }
[17:47:52.382]             function(cond) {
[17:47:52.382]                 is_error <- inherits(cond, "error")
[17:47:52.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.382]                   NULL)
[17:47:52.382]                 if (is_error) {
[17:47:52.382]                   sessionInformation <- function() {
[17:47:52.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.382]                       search = base::search(), system = base::Sys.info())
[17:47:52.382]                   }
[17:47:52.382]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.382]                     cond$call), session = sessionInformation(), 
[17:47:52.382]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.382]                   signalCondition(cond)
[17:47:52.382]                 }
[17:47:52.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.382]                 "immediateCondition"))) {
[17:47:52.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.382]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.382]                   if (TRUE && !signal) {
[17:47:52.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.382]                     {
[17:47:52.382]                       inherits <- base::inherits
[17:47:52.382]                       invokeRestart <- base::invokeRestart
[17:47:52.382]                       is.null <- base::is.null
[17:47:52.382]                       muffled <- FALSE
[17:47:52.382]                       if (inherits(cond, "message")) {
[17:47:52.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.382]                         if (muffled) 
[17:47:52.382]                           invokeRestart("muffleMessage")
[17:47:52.382]                       }
[17:47:52.382]                       else if (inherits(cond, "warning")) {
[17:47:52.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.382]                         if (muffled) 
[17:47:52.382]                           invokeRestart("muffleWarning")
[17:47:52.382]                       }
[17:47:52.382]                       else if (inherits(cond, "condition")) {
[17:47:52.382]                         if (!is.null(pattern)) {
[17:47:52.382]                           computeRestarts <- base::computeRestarts
[17:47:52.382]                           grepl <- base::grepl
[17:47:52.382]                           restarts <- computeRestarts(cond)
[17:47:52.382]                           for (restart in restarts) {
[17:47:52.382]                             name <- restart$name
[17:47:52.382]                             if (is.null(name)) 
[17:47:52.382]                               next
[17:47:52.382]                             if (!grepl(pattern, name)) 
[17:47:52.382]                               next
[17:47:52.382]                             invokeRestart(restart)
[17:47:52.382]                             muffled <- TRUE
[17:47:52.382]                             break
[17:47:52.382]                           }
[17:47:52.382]                         }
[17:47:52.382]                       }
[17:47:52.382]                       invisible(muffled)
[17:47:52.382]                     }
[17:47:52.382]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.382]                   }
[17:47:52.382]                 }
[17:47:52.382]                 else {
[17:47:52.382]                   if (TRUE) {
[17:47:52.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.382]                     {
[17:47:52.382]                       inherits <- base::inherits
[17:47:52.382]                       invokeRestart <- base::invokeRestart
[17:47:52.382]                       is.null <- base::is.null
[17:47:52.382]                       muffled <- FALSE
[17:47:52.382]                       if (inherits(cond, "message")) {
[17:47:52.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.382]                         if (muffled) 
[17:47:52.382]                           invokeRestart("muffleMessage")
[17:47:52.382]                       }
[17:47:52.382]                       else if (inherits(cond, "warning")) {
[17:47:52.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.382]                         if (muffled) 
[17:47:52.382]                           invokeRestart("muffleWarning")
[17:47:52.382]                       }
[17:47:52.382]                       else if (inherits(cond, "condition")) {
[17:47:52.382]                         if (!is.null(pattern)) {
[17:47:52.382]                           computeRestarts <- base::computeRestarts
[17:47:52.382]                           grepl <- base::grepl
[17:47:52.382]                           restarts <- computeRestarts(cond)
[17:47:52.382]                           for (restart in restarts) {
[17:47:52.382]                             name <- restart$name
[17:47:52.382]                             if (is.null(name)) 
[17:47:52.382]                               next
[17:47:52.382]                             if (!grepl(pattern, name)) 
[17:47:52.382]                               next
[17:47:52.382]                             invokeRestart(restart)
[17:47:52.382]                             muffled <- TRUE
[17:47:52.382]                             break
[17:47:52.382]                           }
[17:47:52.382]                         }
[17:47:52.382]                       }
[17:47:52.382]                       invisible(muffled)
[17:47:52.382]                     }
[17:47:52.382]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.382]                   }
[17:47:52.382]                 }
[17:47:52.382]             }
[17:47:52.382]         }))
[17:47:52.382]     }, error = function(ex) {
[17:47:52.382]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.382]                 ...future.rng), started = ...future.startTime, 
[17:47:52.382]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.382]             version = "1.8"), class = "FutureResult")
[17:47:52.382]     }, finally = {
[17:47:52.382]         if (!identical(...future.workdir, getwd())) 
[17:47:52.382]             setwd(...future.workdir)
[17:47:52.382]         {
[17:47:52.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.382]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.382]             }
[17:47:52.382]             base::options(...future.oldOptions)
[17:47:52.382]             if (.Platform$OS.type == "windows") {
[17:47:52.382]                 old_names <- names(...future.oldEnvVars)
[17:47:52.382]                 envs <- base::Sys.getenv()
[17:47:52.382]                 names <- names(envs)
[17:47:52.382]                 common <- intersect(names, old_names)
[17:47:52.382]                 added <- setdiff(names, old_names)
[17:47:52.382]                 removed <- setdiff(old_names, names)
[17:47:52.382]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.382]                   envs[common]]
[17:47:52.382]                 NAMES <- toupper(changed)
[17:47:52.382]                 args <- list()
[17:47:52.382]                 for (kk in seq_along(NAMES)) {
[17:47:52.382]                   name <- changed[[kk]]
[17:47:52.382]                   NAME <- NAMES[[kk]]
[17:47:52.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.382]                     next
[17:47:52.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.382]                 }
[17:47:52.382]                 NAMES <- toupper(added)
[17:47:52.382]                 for (kk in seq_along(NAMES)) {
[17:47:52.382]                   name <- added[[kk]]
[17:47:52.382]                   NAME <- NAMES[[kk]]
[17:47:52.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.382]                     next
[17:47:52.382]                   args[[name]] <- ""
[17:47:52.382]                 }
[17:47:52.382]                 NAMES <- toupper(removed)
[17:47:52.382]                 for (kk in seq_along(NAMES)) {
[17:47:52.382]                   name <- removed[[kk]]
[17:47:52.382]                   NAME <- NAMES[[kk]]
[17:47:52.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.382]                     next
[17:47:52.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.382]                 }
[17:47:52.382]                 if (length(args) > 0) 
[17:47:52.382]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.382]             }
[17:47:52.382]             else {
[17:47:52.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.382]             }
[17:47:52.382]             {
[17:47:52.382]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.382]                   0L) {
[17:47:52.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.382]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.382]                   base::options(opts)
[17:47:52.382]                 }
[17:47:52.382]                 {
[17:47:52.382]                   {
[17:47:52.382]                     NULL
[17:47:52.382]                     RNGkind("Mersenne-Twister")
[17:47:52.382]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.382]                       inherits = FALSE)
[17:47:52.382]                   }
[17:47:52.382]                   options(future.plan = NULL)
[17:47:52.382]                   if (is.na(NA_character_)) 
[17:47:52.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.382]                     .init = FALSE)
[17:47:52.382]                 }
[17:47:52.382]             }
[17:47:52.382]         }
[17:47:52.382]     })
[17:47:52.382]     if (TRUE) {
[17:47:52.382]         base::sink(type = "output", split = FALSE)
[17:47:52.382]         if (TRUE) {
[17:47:52.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.382]         }
[17:47:52.382]         else {
[17:47:52.382]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.382]         }
[17:47:52.382]         base::close(...future.stdout)
[17:47:52.382]         ...future.stdout <- NULL
[17:47:52.382]     }
[17:47:52.382]     ...future.result$conditions <- ...future.conditions
[17:47:52.382]     ...future.result$finished <- base::Sys.time()
[17:47:52.382]     ...future.result
[17:47:52.382] }
[17:47:52.384] assign_globals() ...
[17:47:52.384] List of 1
[17:47:52.384]  $ kk: int 3
[17:47:52.384]  - attr(*, "where")=List of 1
[17:47:52.384]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:52.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:52.384]  - attr(*, "resolved")= logi FALSE
[17:47:52.384]  - attr(*, "total_size")= num 56
[17:47:52.384]  - attr(*, "already-done")= logi TRUE
[17:47:52.386] - copied ‘kk’ to environment
[17:47:52.386] assign_globals() ... done
[17:47:52.386] plan(): Setting new future strategy stack:
[17:47:52.386] List of future strategies:
[17:47:52.386] 1. sequential:
[17:47:52.386]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.386]    - tweaked: FALSE
[17:47:52.386]    - call: NULL
[17:47:52.387] plan(): nbrOfWorkers() = 1
[17:47:52.490] plan(): Setting new future strategy stack:
[17:47:52.490] List of future strategies:
[17:47:52.490] 1. sequential:
[17:47:52.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.490]    - tweaked: FALSE
[17:47:52.490]    - call: plan(strategy)
[17:47:52.490] plan(): nbrOfWorkers() = 1
[17:47:52.491] SequentialFuture started (and completed)
[17:47:52.491] - Launch lazy future ... done
[17:47:52.491] run() for ‘SequentialFuture’ ... done
[17:47:52.491] resolve() on list ...
[17:47:52.491]  recursive: 0
[17:47:52.491]  length: 3
[17:47:52.491] 
[17:47:52.491] resolved() for ‘SequentialFuture’ ...
[17:47:52.491] - state: ‘finished’
[17:47:52.492] - run: TRUE
[17:47:52.492] - result: ‘FutureResult’
[17:47:52.492] resolved() for ‘SequentialFuture’ ... done
[17:47:52.492] Future #1
[17:47:52.492]  length: 2 (resolved future 1)
[17:47:52.492] resolved() for ‘SequentialFuture’ ...
[17:47:52.492] - state: ‘finished’
[17:47:52.492] - run: TRUE
[17:47:52.492] - result: ‘FutureResult’
[17:47:52.492] resolved() for ‘SequentialFuture’ ... done
[17:47:52.493] Future #2
[17:47:52.493]  length: 1 (resolved future 2)
[17:47:52.493] resolved() for ‘SequentialFuture’ ...
[17:47:52.493] - state: ‘finished’
[17:47:52.493] - run: TRUE
[17:47:52.493] - result: ‘FutureResult’
[17:47:52.493] resolved() for ‘SequentialFuture’ ... done
[17:47:52.493] Future #3
[17:47:52.493]  length: 0 (resolved future 3)
[17:47:52.493] resolve() on list ... DONE
[17:47:52.493] getGlobalsAndPackages() ...
[17:47:52.494] Searching for globals...
[17:47:52.494] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:52.495] Searching for globals ... DONE
[17:47:52.495] Resolving globals: FALSE
[17:47:52.495] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:52.495] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:52.496] - globals: [1] ‘kk’
[17:47:52.496] 
[17:47:52.496] getGlobalsAndPackages() ... DONE
[17:47:52.496] getGlobalsAndPackages() ...
[17:47:52.496] Searching for globals...
[17:47:52.497] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:52.497] Searching for globals ... DONE
[17:47:52.497] Resolving globals: FALSE
[17:47:52.497] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:52.498] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:52.498] - globals: [1] ‘kk’
[17:47:52.498] 
[17:47:52.498] getGlobalsAndPackages() ... DONE
[17:47:52.498] getGlobalsAndPackages() ...
[17:47:52.498] Searching for globals...
[17:47:52.499] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:52.499] Searching for globals ... DONE
[17:47:52.500] Resolving globals: FALSE
[17:47:52.500] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:52.500] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:52.500] - globals: [1] ‘kk’
[17:47:52.500] 
[17:47:52.500] getGlobalsAndPackages() ... DONE
[17:47:52.501] resolve() on list ...
[17:47:52.501]  recursive: 0
[17:47:52.501]  length: 3
[17:47:52.501] 
[17:47:52.501] run() for ‘Future’ ...
[17:47:52.501] - state: ‘created’
[17:47:52.501] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.502] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.502]   - Field: ‘label’
[17:47:52.502]   - Field: ‘local’
[17:47:52.502]   - Field: ‘owner’
[17:47:52.502]   - Field: ‘envir’
[17:47:52.502]   - Field: ‘packages’
[17:47:52.502]   - Field: ‘gc’
[17:47:52.502]   - Field: ‘conditions’
[17:47:52.502]   - Field: ‘expr’
[17:47:52.502]   - Field: ‘uuid’
[17:47:52.503]   - Field: ‘seed’
[17:47:52.503]   - Field: ‘version’
[17:47:52.503]   - Field: ‘result’
[17:47:52.503]   - Field: ‘asynchronous’
[17:47:52.503]   - Field: ‘calls’
[17:47:52.503]   - Field: ‘globals’
[17:47:52.503]   - Field: ‘stdout’
[17:47:52.503]   - Field: ‘earlySignal’
[17:47:52.503]   - Field: ‘lazy’
[17:47:52.503]   - Field: ‘state’
[17:47:52.503] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.504] - Launch lazy future ...
[17:47:52.504] Packages needed by the future expression (n = 0): <none>
[17:47:52.504] Packages needed by future strategies (n = 0): <none>
[17:47:52.504] {
[17:47:52.504]     {
[17:47:52.504]         {
[17:47:52.504]             ...future.startTime <- base::Sys.time()
[17:47:52.504]             {
[17:47:52.504]                 {
[17:47:52.504]                   {
[17:47:52.504]                     base::local({
[17:47:52.504]                       has_future <- base::requireNamespace("future", 
[17:47:52.504]                         quietly = TRUE)
[17:47:52.504]                       if (has_future) {
[17:47:52.504]                         ns <- base::getNamespace("future")
[17:47:52.504]                         version <- ns[[".package"]][["version"]]
[17:47:52.504]                         if (is.null(version)) 
[17:47:52.504]                           version <- utils::packageVersion("future")
[17:47:52.504]                       }
[17:47:52.504]                       else {
[17:47:52.504]                         version <- NULL
[17:47:52.504]                       }
[17:47:52.504]                       if (!has_future || version < "1.8.0") {
[17:47:52.504]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.504]                           "", base::R.version$version.string), 
[17:47:52.504]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.504]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.504]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.504]                             "release", "version")], collapse = " "), 
[17:47:52.504]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.504]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.504]                           info)
[17:47:52.504]                         info <- base::paste(info, collapse = "; ")
[17:47:52.504]                         if (!has_future) {
[17:47:52.504]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.504]                             info)
[17:47:52.504]                         }
[17:47:52.504]                         else {
[17:47:52.504]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.504]                             info, version)
[17:47:52.504]                         }
[17:47:52.504]                         base::stop(msg)
[17:47:52.504]                       }
[17:47:52.504]                     })
[17:47:52.504]                   }
[17:47:52.504]                   ...future.strategy.old <- future::plan("list")
[17:47:52.504]                   options(future.plan = NULL)
[17:47:52.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.504]                 }
[17:47:52.504]                 ...future.workdir <- getwd()
[17:47:52.504]             }
[17:47:52.504]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.504]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.504]         }
[17:47:52.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.504]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.504]             base::names(...future.oldOptions))
[17:47:52.504]     }
[17:47:52.504]     if (FALSE) {
[17:47:52.504]     }
[17:47:52.504]     else {
[17:47:52.504]         if (TRUE) {
[17:47:52.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.504]                 open = "w")
[17:47:52.504]         }
[17:47:52.504]         else {
[17:47:52.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.504]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.504]         }
[17:47:52.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.504]             base::sink(type = "output", split = FALSE)
[17:47:52.504]             base::close(...future.stdout)
[17:47:52.504]         }, add = TRUE)
[17:47:52.504]     }
[17:47:52.504]     ...future.frame <- base::sys.nframe()
[17:47:52.504]     ...future.conditions <- base::list()
[17:47:52.504]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.504]     if (FALSE) {
[17:47:52.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.504]     }
[17:47:52.504]     ...future.result <- base::tryCatch({
[17:47:52.504]         base::withCallingHandlers({
[17:47:52.504]             ...future.value <- base::withVisible(base::local({
[17:47:52.504]                 Sys.sleep(0.1)
[17:47:52.504]                 kk
[17:47:52.504]             }))
[17:47:52.504]             future::FutureResult(value = ...future.value$value, 
[17:47:52.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.504]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.504]                     ...future.globalenv.names))
[17:47:52.504]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.504]         }, condition = base::local({
[17:47:52.504]             c <- base::c
[17:47:52.504]             inherits <- base::inherits
[17:47:52.504]             invokeRestart <- base::invokeRestart
[17:47:52.504]             length <- base::length
[17:47:52.504]             list <- base::list
[17:47:52.504]             seq.int <- base::seq.int
[17:47:52.504]             signalCondition <- base::signalCondition
[17:47:52.504]             sys.calls <- base::sys.calls
[17:47:52.504]             `[[` <- base::`[[`
[17:47:52.504]             `+` <- base::`+`
[17:47:52.504]             `<<-` <- base::`<<-`
[17:47:52.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.504]                   3L)]
[17:47:52.504]             }
[17:47:52.504]             function(cond) {
[17:47:52.504]                 is_error <- inherits(cond, "error")
[17:47:52.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.504]                   NULL)
[17:47:52.504]                 if (is_error) {
[17:47:52.504]                   sessionInformation <- function() {
[17:47:52.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.504]                       search = base::search(), system = base::Sys.info())
[17:47:52.504]                   }
[17:47:52.504]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.504]                     cond$call), session = sessionInformation(), 
[17:47:52.504]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.504]                   signalCondition(cond)
[17:47:52.504]                 }
[17:47:52.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.504]                 "immediateCondition"))) {
[17:47:52.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.504]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.504]                   if (TRUE && !signal) {
[17:47:52.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.504]                     {
[17:47:52.504]                       inherits <- base::inherits
[17:47:52.504]                       invokeRestart <- base::invokeRestart
[17:47:52.504]                       is.null <- base::is.null
[17:47:52.504]                       muffled <- FALSE
[17:47:52.504]                       if (inherits(cond, "message")) {
[17:47:52.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.504]                         if (muffled) 
[17:47:52.504]                           invokeRestart("muffleMessage")
[17:47:52.504]                       }
[17:47:52.504]                       else if (inherits(cond, "warning")) {
[17:47:52.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.504]                         if (muffled) 
[17:47:52.504]                           invokeRestart("muffleWarning")
[17:47:52.504]                       }
[17:47:52.504]                       else if (inherits(cond, "condition")) {
[17:47:52.504]                         if (!is.null(pattern)) {
[17:47:52.504]                           computeRestarts <- base::computeRestarts
[17:47:52.504]                           grepl <- base::grepl
[17:47:52.504]                           restarts <- computeRestarts(cond)
[17:47:52.504]                           for (restart in restarts) {
[17:47:52.504]                             name <- restart$name
[17:47:52.504]                             if (is.null(name)) 
[17:47:52.504]                               next
[17:47:52.504]                             if (!grepl(pattern, name)) 
[17:47:52.504]                               next
[17:47:52.504]                             invokeRestart(restart)
[17:47:52.504]                             muffled <- TRUE
[17:47:52.504]                             break
[17:47:52.504]                           }
[17:47:52.504]                         }
[17:47:52.504]                       }
[17:47:52.504]                       invisible(muffled)
[17:47:52.504]                     }
[17:47:52.504]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.504]                   }
[17:47:52.504]                 }
[17:47:52.504]                 else {
[17:47:52.504]                   if (TRUE) {
[17:47:52.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.504]                     {
[17:47:52.504]                       inherits <- base::inherits
[17:47:52.504]                       invokeRestart <- base::invokeRestart
[17:47:52.504]                       is.null <- base::is.null
[17:47:52.504]                       muffled <- FALSE
[17:47:52.504]                       if (inherits(cond, "message")) {
[17:47:52.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.504]                         if (muffled) 
[17:47:52.504]                           invokeRestart("muffleMessage")
[17:47:52.504]                       }
[17:47:52.504]                       else if (inherits(cond, "warning")) {
[17:47:52.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.504]                         if (muffled) 
[17:47:52.504]                           invokeRestart("muffleWarning")
[17:47:52.504]                       }
[17:47:52.504]                       else if (inherits(cond, "condition")) {
[17:47:52.504]                         if (!is.null(pattern)) {
[17:47:52.504]                           computeRestarts <- base::computeRestarts
[17:47:52.504]                           grepl <- base::grepl
[17:47:52.504]                           restarts <- computeRestarts(cond)
[17:47:52.504]                           for (restart in restarts) {
[17:47:52.504]                             name <- restart$name
[17:47:52.504]                             if (is.null(name)) 
[17:47:52.504]                               next
[17:47:52.504]                             if (!grepl(pattern, name)) 
[17:47:52.504]                               next
[17:47:52.504]                             invokeRestart(restart)
[17:47:52.504]                             muffled <- TRUE
[17:47:52.504]                             break
[17:47:52.504]                           }
[17:47:52.504]                         }
[17:47:52.504]                       }
[17:47:52.504]                       invisible(muffled)
[17:47:52.504]                     }
[17:47:52.504]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.504]                   }
[17:47:52.504]                 }
[17:47:52.504]             }
[17:47:52.504]         }))
[17:47:52.504]     }, error = function(ex) {
[17:47:52.504]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.504]                 ...future.rng), started = ...future.startTime, 
[17:47:52.504]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.504]             version = "1.8"), class = "FutureResult")
[17:47:52.504]     }, finally = {
[17:47:52.504]         if (!identical(...future.workdir, getwd())) 
[17:47:52.504]             setwd(...future.workdir)
[17:47:52.504]         {
[17:47:52.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.504]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.504]             }
[17:47:52.504]             base::options(...future.oldOptions)
[17:47:52.504]             if (.Platform$OS.type == "windows") {
[17:47:52.504]                 old_names <- names(...future.oldEnvVars)
[17:47:52.504]                 envs <- base::Sys.getenv()
[17:47:52.504]                 names <- names(envs)
[17:47:52.504]                 common <- intersect(names, old_names)
[17:47:52.504]                 added <- setdiff(names, old_names)
[17:47:52.504]                 removed <- setdiff(old_names, names)
[17:47:52.504]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.504]                   envs[common]]
[17:47:52.504]                 NAMES <- toupper(changed)
[17:47:52.504]                 args <- list()
[17:47:52.504]                 for (kk in seq_along(NAMES)) {
[17:47:52.504]                   name <- changed[[kk]]
[17:47:52.504]                   NAME <- NAMES[[kk]]
[17:47:52.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.504]                     next
[17:47:52.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.504]                 }
[17:47:52.504]                 NAMES <- toupper(added)
[17:47:52.504]                 for (kk in seq_along(NAMES)) {
[17:47:52.504]                   name <- added[[kk]]
[17:47:52.504]                   NAME <- NAMES[[kk]]
[17:47:52.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.504]                     next
[17:47:52.504]                   args[[name]] <- ""
[17:47:52.504]                 }
[17:47:52.504]                 NAMES <- toupper(removed)
[17:47:52.504]                 for (kk in seq_along(NAMES)) {
[17:47:52.504]                   name <- removed[[kk]]
[17:47:52.504]                   NAME <- NAMES[[kk]]
[17:47:52.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.504]                     next
[17:47:52.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.504]                 }
[17:47:52.504]                 if (length(args) > 0) 
[17:47:52.504]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.504]             }
[17:47:52.504]             else {
[17:47:52.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.504]             }
[17:47:52.504]             {
[17:47:52.504]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.504]                   0L) {
[17:47:52.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.504]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.504]                   base::options(opts)
[17:47:52.504]                 }
[17:47:52.504]                 {
[17:47:52.504]                   {
[17:47:52.504]                     NULL
[17:47:52.504]                     RNGkind("Mersenne-Twister")
[17:47:52.504]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.504]                       inherits = FALSE)
[17:47:52.504]                   }
[17:47:52.504]                   options(future.plan = NULL)
[17:47:52.504]                   if (is.na(NA_character_)) 
[17:47:52.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.504]                     .init = FALSE)
[17:47:52.504]                 }
[17:47:52.504]             }
[17:47:52.504]         }
[17:47:52.504]     })
[17:47:52.504]     if (TRUE) {
[17:47:52.504]         base::sink(type = "output", split = FALSE)
[17:47:52.504]         if (TRUE) {
[17:47:52.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.504]         }
[17:47:52.504]         else {
[17:47:52.504]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.504]         }
[17:47:52.504]         base::close(...future.stdout)
[17:47:52.504]         ...future.stdout <- NULL
[17:47:52.504]     }
[17:47:52.504]     ...future.result$conditions <- ...future.conditions
[17:47:52.504]     ...future.result$finished <- base::Sys.time()
[17:47:52.504]     ...future.result
[17:47:52.504] }
[17:47:52.506] assign_globals() ...
[17:47:52.506] List of 1
[17:47:52.506]  $ kk: int 1
[17:47:52.506]  - attr(*, "where")=List of 1
[17:47:52.506]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:52.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:52.506]  - attr(*, "resolved")= logi FALSE
[17:47:52.506]  - attr(*, "total_size")= num 56
[17:47:52.506]  - attr(*, "already-done")= logi TRUE
[17:47:52.508] - copied ‘kk’ to environment
[17:47:52.508] assign_globals() ... done
[17:47:52.509] plan(): Setting new future strategy stack:
[17:47:52.509] List of future strategies:
[17:47:52.509] 1. sequential:
[17:47:52.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.509]    - tweaked: FALSE
[17:47:52.509]    - call: NULL
[17:47:52.509] plan(): nbrOfWorkers() = 1
[17:47:52.610] plan(): Setting new future strategy stack:
[17:47:52.610] List of future strategies:
[17:47:52.610] 1. sequential:
[17:47:52.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.610]    - tweaked: FALSE
[17:47:52.610]    - call: plan(strategy)
[17:47:52.611] plan(): nbrOfWorkers() = 1
[17:47:52.611] SequentialFuture started (and completed)
[17:47:52.611] - Launch lazy future ... done
[17:47:52.611] run() for ‘SequentialFuture’ ... done
[17:47:52.611] resolved() for ‘SequentialFuture’ ...
[17:47:52.612] - state: ‘finished’
[17:47:52.612] - run: TRUE
[17:47:52.612] - result: ‘FutureResult’
[17:47:52.612] resolved() for ‘SequentialFuture’ ... done
[17:47:52.612] Future #1
[17:47:52.612]  length: 2 (resolved future 1)
[17:47:52.612] run() for ‘Future’ ...
[17:47:52.612] - state: ‘created’
[17:47:52.612] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.613] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.613] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.613]   - Field: ‘label’
[17:47:52.613]   - Field: ‘local’
[17:47:52.613]   - Field: ‘owner’
[17:47:52.613]   - Field: ‘envir’
[17:47:52.613]   - Field: ‘packages’
[17:47:52.613]   - Field: ‘gc’
[17:47:52.613]   - Field: ‘conditions’
[17:47:52.613]   - Field: ‘expr’
[17:47:52.614]   - Field: ‘uuid’
[17:47:52.614]   - Field: ‘seed’
[17:47:52.614]   - Field: ‘version’
[17:47:52.614]   - Field: ‘result’
[17:47:52.614]   - Field: ‘asynchronous’
[17:47:52.614]   - Field: ‘calls’
[17:47:52.614]   - Field: ‘globals’
[17:47:52.614]   - Field: ‘stdout’
[17:47:52.614]   - Field: ‘earlySignal’
[17:47:52.614]   - Field: ‘lazy’
[17:47:52.614]   - Field: ‘state’
[17:47:52.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.615] - Launch lazy future ...
[17:47:52.615] Packages needed by the future expression (n = 0): <none>
[17:47:52.615] Packages needed by future strategies (n = 0): <none>
[17:47:52.615] {
[17:47:52.615]     {
[17:47:52.615]         {
[17:47:52.615]             ...future.startTime <- base::Sys.time()
[17:47:52.615]             {
[17:47:52.615]                 {
[17:47:52.615]                   {
[17:47:52.615]                     base::local({
[17:47:52.615]                       has_future <- base::requireNamespace("future", 
[17:47:52.615]                         quietly = TRUE)
[17:47:52.615]                       if (has_future) {
[17:47:52.615]                         ns <- base::getNamespace("future")
[17:47:52.615]                         version <- ns[[".package"]][["version"]]
[17:47:52.615]                         if (is.null(version)) 
[17:47:52.615]                           version <- utils::packageVersion("future")
[17:47:52.615]                       }
[17:47:52.615]                       else {
[17:47:52.615]                         version <- NULL
[17:47:52.615]                       }
[17:47:52.615]                       if (!has_future || version < "1.8.0") {
[17:47:52.615]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.615]                           "", base::R.version$version.string), 
[17:47:52.615]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.615]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.615]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.615]                             "release", "version")], collapse = " "), 
[17:47:52.615]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.615]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.615]                           info)
[17:47:52.615]                         info <- base::paste(info, collapse = "; ")
[17:47:52.615]                         if (!has_future) {
[17:47:52.615]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.615]                             info)
[17:47:52.615]                         }
[17:47:52.615]                         else {
[17:47:52.615]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.615]                             info, version)
[17:47:52.615]                         }
[17:47:52.615]                         base::stop(msg)
[17:47:52.615]                       }
[17:47:52.615]                     })
[17:47:52.615]                   }
[17:47:52.615]                   ...future.strategy.old <- future::plan("list")
[17:47:52.615]                   options(future.plan = NULL)
[17:47:52.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.615]                 }
[17:47:52.615]                 ...future.workdir <- getwd()
[17:47:52.615]             }
[17:47:52.615]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.615]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.615]         }
[17:47:52.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.615]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.615]             base::names(...future.oldOptions))
[17:47:52.615]     }
[17:47:52.615]     if (FALSE) {
[17:47:52.615]     }
[17:47:52.615]     else {
[17:47:52.615]         if (TRUE) {
[17:47:52.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.615]                 open = "w")
[17:47:52.615]         }
[17:47:52.615]         else {
[17:47:52.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.615]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.615]         }
[17:47:52.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.615]             base::sink(type = "output", split = FALSE)
[17:47:52.615]             base::close(...future.stdout)
[17:47:52.615]         }, add = TRUE)
[17:47:52.615]     }
[17:47:52.615]     ...future.frame <- base::sys.nframe()
[17:47:52.615]     ...future.conditions <- base::list()
[17:47:52.615]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.615]     if (FALSE) {
[17:47:52.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.615]     }
[17:47:52.615]     ...future.result <- base::tryCatch({
[17:47:52.615]         base::withCallingHandlers({
[17:47:52.615]             ...future.value <- base::withVisible(base::local({
[17:47:52.615]                 Sys.sleep(0.1)
[17:47:52.615]                 kk
[17:47:52.615]             }))
[17:47:52.615]             future::FutureResult(value = ...future.value$value, 
[17:47:52.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.615]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.615]                     ...future.globalenv.names))
[17:47:52.615]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.615]         }, condition = base::local({
[17:47:52.615]             c <- base::c
[17:47:52.615]             inherits <- base::inherits
[17:47:52.615]             invokeRestart <- base::invokeRestart
[17:47:52.615]             length <- base::length
[17:47:52.615]             list <- base::list
[17:47:52.615]             seq.int <- base::seq.int
[17:47:52.615]             signalCondition <- base::signalCondition
[17:47:52.615]             sys.calls <- base::sys.calls
[17:47:52.615]             `[[` <- base::`[[`
[17:47:52.615]             `+` <- base::`+`
[17:47:52.615]             `<<-` <- base::`<<-`
[17:47:52.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.615]                   3L)]
[17:47:52.615]             }
[17:47:52.615]             function(cond) {
[17:47:52.615]                 is_error <- inherits(cond, "error")
[17:47:52.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.615]                   NULL)
[17:47:52.615]                 if (is_error) {
[17:47:52.615]                   sessionInformation <- function() {
[17:47:52.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.615]                       search = base::search(), system = base::Sys.info())
[17:47:52.615]                   }
[17:47:52.615]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.615]                     cond$call), session = sessionInformation(), 
[17:47:52.615]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.615]                   signalCondition(cond)
[17:47:52.615]                 }
[17:47:52.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.615]                 "immediateCondition"))) {
[17:47:52.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.615]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.615]                   if (TRUE && !signal) {
[17:47:52.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.615]                     {
[17:47:52.615]                       inherits <- base::inherits
[17:47:52.615]                       invokeRestart <- base::invokeRestart
[17:47:52.615]                       is.null <- base::is.null
[17:47:52.615]                       muffled <- FALSE
[17:47:52.615]                       if (inherits(cond, "message")) {
[17:47:52.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.615]                         if (muffled) 
[17:47:52.615]                           invokeRestart("muffleMessage")
[17:47:52.615]                       }
[17:47:52.615]                       else if (inherits(cond, "warning")) {
[17:47:52.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.615]                         if (muffled) 
[17:47:52.615]                           invokeRestart("muffleWarning")
[17:47:52.615]                       }
[17:47:52.615]                       else if (inherits(cond, "condition")) {
[17:47:52.615]                         if (!is.null(pattern)) {
[17:47:52.615]                           computeRestarts <- base::computeRestarts
[17:47:52.615]                           grepl <- base::grepl
[17:47:52.615]                           restarts <- computeRestarts(cond)
[17:47:52.615]                           for (restart in restarts) {
[17:47:52.615]                             name <- restart$name
[17:47:52.615]                             if (is.null(name)) 
[17:47:52.615]                               next
[17:47:52.615]                             if (!grepl(pattern, name)) 
[17:47:52.615]                               next
[17:47:52.615]                             invokeRestart(restart)
[17:47:52.615]                             muffled <- TRUE
[17:47:52.615]                             break
[17:47:52.615]                           }
[17:47:52.615]                         }
[17:47:52.615]                       }
[17:47:52.615]                       invisible(muffled)
[17:47:52.615]                     }
[17:47:52.615]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.615]                   }
[17:47:52.615]                 }
[17:47:52.615]                 else {
[17:47:52.615]                   if (TRUE) {
[17:47:52.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.615]                     {
[17:47:52.615]                       inherits <- base::inherits
[17:47:52.615]                       invokeRestart <- base::invokeRestart
[17:47:52.615]                       is.null <- base::is.null
[17:47:52.615]                       muffled <- FALSE
[17:47:52.615]                       if (inherits(cond, "message")) {
[17:47:52.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.615]                         if (muffled) 
[17:47:52.615]                           invokeRestart("muffleMessage")
[17:47:52.615]                       }
[17:47:52.615]                       else if (inherits(cond, "warning")) {
[17:47:52.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.615]                         if (muffled) 
[17:47:52.615]                           invokeRestart("muffleWarning")
[17:47:52.615]                       }
[17:47:52.615]                       else if (inherits(cond, "condition")) {
[17:47:52.615]                         if (!is.null(pattern)) {
[17:47:52.615]                           computeRestarts <- base::computeRestarts
[17:47:52.615]                           grepl <- base::grepl
[17:47:52.615]                           restarts <- computeRestarts(cond)
[17:47:52.615]                           for (restart in restarts) {
[17:47:52.615]                             name <- restart$name
[17:47:52.615]                             if (is.null(name)) 
[17:47:52.615]                               next
[17:47:52.615]                             if (!grepl(pattern, name)) 
[17:47:52.615]                               next
[17:47:52.615]                             invokeRestart(restart)
[17:47:52.615]                             muffled <- TRUE
[17:47:52.615]                             break
[17:47:52.615]                           }
[17:47:52.615]                         }
[17:47:52.615]                       }
[17:47:52.615]                       invisible(muffled)
[17:47:52.615]                     }
[17:47:52.615]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.615]                   }
[17:47:52.615]                 }
[17:47:52.615]             }
[17:47:52.615]         }))
[17:47:52.615]     }, error = function(ex) {
[17:47:52.615]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.615]                 ...future.rng), started = ...future.startTime, 
[17:47:52.615]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.615]             version = "1.8"), class = "FutureResult")
[17:47:52.615]     }, finally = {
[17:47:52.615]         if (!identical(...future.workdir, getwd())) 
[17:47:52.615]             setwd(...future.workdir)
[17:47:52.615]         {
[17:47:52.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.615]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.615]             }
[17:47:52.615]             base::options(...future.oldOptions)
[17:47:52.615]             if (.Platform$OS.type == "windows") {
[17:47:52.615]                 old_names <- names(...future.oldEnvVars)
[17:47:52.615]                 envs <- base::Sys.getenv()
[17:47:52.615]                 names <- names(envs)
[17:47:52.615]                 common <- intersect(names, old_names)
[17:47:52.615]                 added <- setdiff(names, old_names)
[17:47:52.615]                 removed <- setdiff(old_names, names)
[17:47:52.615]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.615]                   envs[common]]
[17:47:52.615]                 NAMES <- toupper(changed)
[17:47:52.615]                 args <- list()
[17:47:52.615]                 for (kk in seq_along(NAMES)) {
[17:47:52.615]                   name <- changed[[kk]]
[17:47:52.615]                   NAME <- NAMES[[kk]]
[17:47:52.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.615]                     next
[17:47:52.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.615]                 }
[17:47:52.615]                 NAMES <- toupper(added)
[17:47:52.615]                 for (kk in seq_along(NAMES)) {
[17:47:52.615]                   name <- added[[kk]]
[17:47:52.615]                   NAME <- NAMES[[kk]]
[17:47:52.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.615]                     next
[17:47:52.615]                   args[[name]] <- ""
[17:47:52.615]                 }
[17:47:52.615]                 NAMES <- toupper(removed)
[17:47:52.615]                 for (kk in seq_along(NAMES)) {
[17:47:52.615]                   name <- removed[[kk]]
[17:47:52.615]                   NAME <- NAMES[[kk]]
[17:47:52.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.615]                     next
[17:47:52.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.615]                 }
[17:47:52.615]                 if (length(args) > 0) 
[17:47:52.615]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.615]             }
[17:47:52.615]             else {
[17:47:52.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.615]             }
[17:47:52.615]             {
[17:47:52.615]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.615]                   0L) {
[17:47:52.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.615]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.615]                   base::options(opts)
[17:47:52.615]                 }
[17:47:52.615]                 {
[17:47:52.615]                   {
[17:47:52.615]                     NULL
[17:47:52.615]                     RNGkind("Mersenne-Twister")
[17:47:52.615]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.615]                       inherits = FALSE)
[17:47:52.615]                   }
[17:47:52.615]                   options(future.plan = NULL)
[17:47:52.615]                   if (is.na(NA_character_)) 
[17:47:52.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.615]                     .init = FALSE)
[17:47:52.615]                 }
[17:47:52.615]             }
[17:47:52.615]         }
[17:47:52.615]     })
[17:47:52.615]     if (TRUE) {
[17:47:52.615]         base::sink(type = "output", split = FALSE)
[17:47:52.615]         if (TRUE) {
[17:47:52.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.615]         }
[17:47:52.615]         else {
[17:47:52.615]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.615]         }
[17:47:52.615]         base::close(...future.stdout)
[17:47:52.615]         ...future.stdout <- NULL
[17:47:52.615]     }
[17:47:52.615]     ...future.result$conditions <- ...future.conditions
[17:47:52.615]     ...future.result$finished <- base::Sys.time()
[17:47:52.615]     ...future.result
[17:47:52.615] }
[17:47:52.617] assign_globals() ...
[17:47:52.617] List of 1
[17:47:52.617]  $ kk: int 2
[17:47:52.617]  - attr(*, "where")=List of 1
[17:47:52.617]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:52.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:52.617]  - attr(*, "resolved")= logi FALSE
[17:47:52.617]  - attr(*, "total_size")= num 56
[17:47:52.617]  - attr(*, "already-done")= logi TRUE
[17:47:52.621] - copied ‘kk’ to environment
[17:47:52.621] assign_globals() ... done
[17:47:52.621] plan(): Setting new future strategy stack:
[17:47:52.621] List of future strategies:
[17:47:52.621] 1. sequential:
[17:47:52.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.621]    - tweaked: FALSE
[17:47:52.621]    - call: NULL
[17:47:52.622] plan(): nbrOfWorkers() = 1
[17:47:52.723] plan(): Setting new future strategy stack:
[17:47:52.723] List of future strategies:
[17:47:52.723] 1. sequential:
[17:47:52.723]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.723]    - tweaked: FALSE
[17:47:52.723]    - call: plan(strategy)
[17:47:52.723] plan(): nbrOfWorkers() = 1
[17:47:52.724] SequentialFuture started (and completed)
[17:47:52.724] - Launch lazy future ... done
[17:47:52.724] run() for ‘SequentialFuture’ ... done
[17:47:52.724] resolved() for ‘SequentialFuture’ ...
[17:47:52.724] - state: ‘finished’
[17:47:52.724] - run: TRUE
[17:47:52.724] - result: ‘FutureResult’
[17:47:52.724] resolved() for ‘SequentialFuture’ ... done
[17:47:52.724] Future #2
[17:47:52.725]  length: 1 (resolved future 2)
[17:47:52.725] run() for ‘Future’ ...
[17:47:52.725] - state: ‘created’
[17:47:52.725] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.725] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.725]   - Field: ‘label’
[17:47:52.726]   - Field: ‘local’
[17:47:52.726]   - Field: ‘owner’
[17:47:52.726]   - Field: ‘envir’
[17:47:52.726]   - Field: ‘packages’
[17:47:52.726]   - Field: ‘gc’
[17:47:52.726]   - Field: ‘conditions’
[17:47:52.726]   - Field: ‘expr’
[17:47:52.726]   - Field: ‘uuid’
[17:47:52.726]   - Field: ‘seed’
[17:47:52.726]   - Field: ‘version’
[17:47:52.726]   - Field: ‘result’
[17:47:52.727]   - Field: ‘asynchronous’
[17:47:52.727]   - Field: ‘calls’
[17:47:52.727]   - Field: ‘globals’
[17:47:52.727]   - Field: ‘stdout’
[17:47:52.727]   - Field: ‘earlySignal’
[17:47:52.727]   - Field: ‘lazy’
[17:47:52.727]   - Field: ‘state’
[17:47:52.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.727] - Launch lazy future ...
[17:47:52.727] Packages needed by the future expression (n = 0): <none>
[17:47:52.728] Packages needed by future strategies (n = 0): <none>
[17:47:52.728] {
[17:47:52.728]     {
[17:47:52.728]         {
[17:47:52.728]             ...future.startTime <- base::Sys.time()
[17:47:52.728]             {
[17:47:52.728]                 {
[17:47:52.728]                   {
[17:47:52.728]                     base::local({
[17:47:52.728]                       has_future <- base::requireNamespace("future", 
[17:47:52.728]                         quietly = TRUE)
[17:47:52.728]                       if (has_future) {
[17:47:52.728]                         ns <- base::getNamespace("future")
[17:47:52.728]                         version <- ns[[".package"]][["version"]]
[17:47:52.728]                         if (is.null(version)) 
[17:47:52.728]                           version <- utils::packageVersion("future")
[17:47:52.728]                       }
[17:47:52.728]                       else {
[17:47:52.728]                         version <- NULL
[17:47:52.728]                       }
[17:47:52.728]                       if (!has_future || version < "1.8.0") {
[17:47:52.728]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.728]                           "", base::R.version$version.string), 
[17:47:52.728]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.728]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.728]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.728]                             "release", "version")], collapse = " "), 
[17:47:52.728]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.728]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.728]                           info)
[17:47:52.728]                         info <- base::paste(info, collapse = "; ")
[17:47:52.728]                         if (!has_future) {
[17:47:52.728]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.728]                             info)
[17:47:52.728]                         }
[17:47:52.728]                         else {
[17:47:52.728]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.728]                             info, version)
[17:47:52.728]                         }
[17:47:52.728]                         base::stop(msg)
[17:47:52.728]                       }
[17:47:52.728]                     })
[17:47:52.728]                   }
[17:47:52.728]                   ...future.strategy.old <- future::plan("list")
[17:47:52.728]                   options(future.plan = NULL)
[17:47:52.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.728]                 }
[17:47:52.728]                 ...future.workdir <- getwd()
[17:47:52.728]             }
[17:47:52.728]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.728]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.728]         }
[17:47:52.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.728]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.728]             base::names(...future.oldOptions))
[17:47:52.728]     }
[17:47:52.728]     if (FALSE) {
[17:47:52.728]     }
[17:47:52.728]     else {
[17:47:52.728]         if (TRUE) {
[17:47:52.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.728]                 open = "w")
[17:47:52.728]         }
[17:47:52.728]         else {
[17:47:52.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.728]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.728]         }
[17:47:52.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.728]             base::sink(type = "output", split = FALSE)
[17:47:52.728]             base::close(...future.stdout)
[17:47:52.728]         }, add = TRUE)
[17:47:52.728]     }
[17:47:52.728]     ...future.frame <- base::sys.nframe()
[17:47:52.728]     ...future.conditions <- base::list()
[17:47:52.728]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.728]     if (FALSE) {
[17:47:52.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.728]     }
[17:47:52.728]     ...future.result <- base::tryCatch({
[17:47:52.728]         base::withCallingHandlers({
[17:47:52.728]             ...future.value <- base::withVisible(base::local({
[17:47:52.728]                 Sys.sleep(0.1)
[17:47:52.728]                 kk
[17:47:52.728]             }))
[17:47:52.728]             future::FutureResult(value = ...future.value$value, 
[17:47:52.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.728]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.728]                     ...future.globalenv.names))
[17:47:52.728]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.728]         }, condition = base::local({
[17:47:52.728]             c <- base::c
[17:47:52.728]             inherits <- base::inherits
[17:47:52.728]             invokeRestart <- base::invokeRestart
[17:47:52.728]             length <- base::length
[17:47:52.728]             list <- base::list
[17:47:52.728]             seq.int <- base::seq.int
[17:47:52.728]             signalCondition <- base::signalCondition
[17:47:52.728]             sys.calls <- base::sys.calls
[17:47:52.728]             `[[` <- base::`[[`
[17:47:52.728]             `+` <- base::`+`
[17:47:52.728]             `<<-` <- base::`<<-`
[17:47:52.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.728]                   3L)]
[17:47:52.728]             }
[17:47:52.728]             function(cond) {
[17:47:52.728]                 is_error <- inherits(cond, "error")
[17:47:52.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.728]                   NULL)
[17:47:52.728]                 if (is_error) {
[17:47:52.728]                   sessionInformation <- function() {
[17:47:52.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.728]                       search = base::search(), system = base::Sys.info())
[17:47:52.728]                   }
[17:47:52.728]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.728]                     cond$call), session = sessionInformation(), 
[17:47:52.728]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.728]                   signalCondition(cond)
[17:47:52.728]                 }
[17:47:52.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.728]                 "immediateCondition"))) {
[17:47:52.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.728]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.728]                   if (TRUE && !signal) {
[17:47:52.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.728]                     {
[17:47:52.728]                       inherits <- base::inherits
[17:47:52.728]                       invokeRestart <- base::invokeRestart
[17:47:52.728]                       is.null <- base::is.null
[17:47:52.728]                       muffled <- FALSE
[17:47:52.728]                       if (inherits(cond, "message")) {
[17:47:52.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.728]                         if (muffled) 
[17:47:52.728]                           invokeRestart("muffleMessage")
[17:47:52.728]                       }
[17:47:52.728]                       else if (inherits(cond, "warning")) {
[17:47:52.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.728]                         if (muffled) 
[17:47:52.728]                           invokeRestart("muffleWarning")
[17:47:52.728]                       }
[17:47:52.728]                       else if (inherits(cond, "condition")) {
[17:47:52.728]                         if (!is.null(pattern)) {
[17:47:52.728]                           computeRestarts <- base::computeRestarts
[17:47:52.728]                           grepl <- base::grepl
[17:47:52.728]                           restarts <- computeRestarts(cond)
[17:47:52.728]                           for (restart in restarts) {
[17:47:52.728]                             name <- restart$name
[17:47:52.728]                             if (is.null(name)) 
[17:47:52.728]                               next
[17:47:52.728]                             if (!grepl(pattern, name)) 
[17:47:52.728]                               next
[17:47:52.728]                             invokeRestart(restart)
[17:47:52.728]                             muffled <- TRUE
[17:47:52.728]                             break
[17:47:52.728]                           }
[17:47:52.728]                         }
[17:47:52.728]                       }
[17:47:52.728]                       invisible(muffled)
[17:47:52.728]                     }
[17:47:52.728]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.728]                   }
[17:47:52.728]                 }
[17:47:52.728]                 else {
[17:47:52.728]                   if (TRUE) {
[17:47:52.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.728]                     {
[17:47:52.728]                       inherits <- base::inherits
[17:47:52.728]                       invokeRestart <- base::invokeRestart
[17:47:52.728]                       is.null <- base::is.null
[17:47:52.728]                       muffled <- FALSE
[17:47:52.728]                       if (inherits(cond, "message")) {
[17:47:52.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.728]                         if (muffled) 
[17:47:52.728]                           invokeRestart("muffleMessage")
[17:47:52.728]                       }
[17:47:52.728]                       else if (inherits(cond, "warning")) {
[17:47:52.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.728]                         if (muffled) 
[17:47:52.728]                           invokeRestart("muffleWarning")
[17:47:52.728]                       }
[17:47:52.728]                       else if (inherits(cond, "condition")) {
[17:47:52.728]                         if (!is.null(pattern)) {
[17:47:52.728]                           computeRestarts <- base::computeRestarts
[17:47:52.728]                           grepl <- base::grepl
[17:47:52.728]                           restarts <- computeRestarts(cond)
[17:47:52.728]                           for (restart in restarts) {
[17:47:52.728]                             name <- restart$name
[17:47:52.728]                             if (is.null(name)) 
[17:47:52.728]                               next
[17:47:52.728]                             if (!grepl(pattern, name)) 
[17:47:52.728]                               next
[17:47:52.728]                             invokeRestart(restart)
[17:47:52.728]                             muffled <- TRUE
[17:47:52.728]                             break
[17:47:52.728]                           }
[17:47:52.728]                         }
[17:47:52.728]                       }
[17:47:52.728]                       invisible(muffled)
[17:47:52.728]                     }
[17:47:52.728]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.728]                   }
[17:47:52.728]                 }
[17:47:52.728]             }
[17:47:52.728]         }))
[17:47:52.728]     }, error = function(ex) {
[17:47:52.728]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.728]                 ...future.rng), started = ...future.startTime, 
[17:47:52.728]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.728]             version = "1.8"), class = "FutureResult")
[17:47:52.728]     }, finally = {
[17:47:52.728]         if (!identical(...future.workdir, getwd())) 
[17:47:52.728]             setwd(...future.workdir)
[17:47:52.728]         {
[17:47:52.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.728]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.728]             }
[17:47:52.728]             base::options(...future.oldOptions)
[17:47:52.728]             if (.Platform$OS.type == "windows") {
[17:47:52.728]                 old_names <- names(...future.oldEnvVars)
[17:47:52.728]                 envs <- base::Sys.getenv()
[17:47:52.728]                 names <- names(envs)
[17:47:52.728]                 common <- intersect(names, old_names)
[17:47:52.728]                 added <- setdiff(names, old_names)
[17:47:52.728]                 removed <- setdiff(old_names, names)
[17:47:52.728]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.728]                   envs[common]]
[17:47:52.728]                 NAMES <- toupper(changed)
[17:47:52.728]                 args <- list()
[17:47:52.728]                 for (kk in seq_along(NAMES)) {
[17:47:52.728]                   name <- changed[[kk]]
[17:47:52.728]                   NAME <- NAMES[[kk]]
[17:47:52.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.728]                     next
[17:47:52.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.728]                 }
[17:47:52.728]                 NAMES <- toupper(added)
[17:47:52.728]                 for (kk in seq_along(NAMES)) {
[17:47:52.728]                   name <- added[[kk]]
[17:47:52.728]                   NAME <- NAMES[[kk]]
[17:47:52.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.728]                     next
[17:47:52.728]                   args[[name]] <- ""
[17:47:52.728]                 }
[17:47:52.728]                 NAMES <- toupper(removed)
[17:47:52.728]                 for (kk in seq_along(NAMES)) {
[17:47:52.728]                   name <- removed[[kk]]
[17:47:52.728]                   NAME <- NAMES[[kk]]
[17:47:52.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.728]                     next
[17:47:52.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.728]                 }
[17:47:52.728]                 if (length(args) > 0) 
[17:47:52.728]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.728]             }
[17:47:52.728]             else {
[17:47:52.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.728]             }
[17:47:52.728]             {
[17:47:52.728]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.728]                   0L) {
[17:47:52.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.728]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.728]                   base::options(opts)
[17:47:52.728]                 }
[17:47:52.728]                 {
[17:47:52.728]                   {
[17:47:52.728]                     NULL
[17:47:52.728]                     RNGkind("Mersenne-Twister")
[17:47:52.728]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.728]                       inherits = FALSE)
[17:47:52.728]                   }
[17:47:52.728]                   options(future.plan = NULL)
[17:47:52.728]                   if (is.na(NA_character_)) 
[17:47:52.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.728]                     .init = FALSE)
[17:47:52.728]                 }
[17:47:52.728]             }
[17:47:52.728]         }
[17:47:52.728]     })
[17:47:52.728]     if (TRUE) {
[17:47:52.728]         base::sink(type = "output", split = FALSE)
[17:47:52.728]         if (TRUE) {
[17:47:52.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.728]         }
[17:47:52.728]         else {
[17:47:52.728]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.728]         }
[17:47:52.728]         base::close(...future.stdout)
[17:47:52.728]         ...future.stdout <- NULL
[17:47:52.728]     }
[17:47:52.728]     ...future.result$conditions <- ...future.conditions
[17:47:52.728]     ...future.result$finished <- base::Sys.time()
[17:47:52.728]     ...future.result
[17:47:52.728] }
[17:47:52.730] assign_globals() ...
[17:47:52.730] List of 1
[17:47:52.730]  $ kk: int 3
[17:47:52.730]  - attr(*, "where")=List of 1
[17:47:52.730]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:52.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:52.730]  - attr(*, "resolved")= logi FALSE
[17:47:52.730]  - attr(*, "total_size")= num 56
[17:47:52.730]  - attr(*, "already-done")= logi TRUE
[17:47:52.732] - copied ‘kk’ to environment
[17:47:52.732] assign_globals() ... done
[17:47:52.732] plan(): Setting new future strategy stack:
[17:47:52.733] List of future strategies:
[17:47:52.733] 1. sequential:
[17:47:52.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.733]    - tweaked: FALSE
[17:47:52.733]    - call: NULL
[17:47:52.733] plan(): nbrOfWorkers() = 1
[17:47:52.834] plan(): Setting new future strategy stack:
[17:47:52.834] List of future strategies:
[17:47:52.834] 1. sequential:
[17:47:52.834]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.834]    - tweaked: FALSE
[17:47:52.834]    - call: plan(strategy)
[17:47:52.835] plan(): nbrOfWorkers() = 1
[17:47:52.835] SequentialFuture started (and completed)
[17:47:52.835] - Launch lazy future ... done
[17:47:52.835] run() for ‘SequentialFuture’ ... done
[17:47:52.835] resolved() for ‘SequentialFuture’ ...
[17:47:52.835] - state: ‘finished’
[17:47:52.835] - run: TRUE
[17:47:52.836] - result: ‘FutureResult’
[17:47:52.836] resolved() for ‘SequentialFuture’ ... done
[17:47:52.836] Future #3
[17:47:52.836]  length: 0 (resolved future 3)
[17:47:52.836] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:47:52.837] resolve() on environment ...
[17:47:52.837]  recursive: 0
[17:47:52.838]  elements: [2] ‘a’, ‘b’
[17:47:52.838]  length: 1 (resolved future 1)
[17:47:52.838]  length: 0 (resolved future 2)
[17:47:52.838] resolve() on environment ... DONE
[17:47:52.839] getGlobalsAndPackages() ...
[17:47:52.839] Searching for globals...
[17:47:52.839] 
[17:47:52.839] Searching for globals ... DONE
[17:47:52.839] - globals: [0] <none>
[17:47:52.839] getGlobalsAndPackages() ... DONE
[17:47:52.840] run() for ‘Future’ ...
[17:47:52.840] - state: ‘created’
[17:47:52.840] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.840] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.840]   - Field: ‘label’
[17:47:52.840]   - Field: ‘local’
[17:47:52.840]   - Field: ‘owner’
[17:47:52.841]   - Field: ‘envir’
[17:47:52.841]   - Field: ‘packages’
[17:47:52.841]   - Field: ‘gc’
[17:47:52.841]   - Field: ‘conditions’
[17:47:52.841]   - Field: ‘expr’
[17:47:52.841]   - Field: ‘uuid’
[17:47:52.841]   - Field: ‘seed’
[17:47:52.841]   - Field: ‘version’
[17:47:52.841]   - Field: ‘result’
[17:47:52.841]   - Field: ‘asynchronous’
[17:47:52.841]   - Field: ‘calls’
[17:47:52.841]   - Field: ‘globals’
[17:47:52.842]   - Field: ‘stdout’
[17:47:52.842]   - Field: ‘earlySignal’
[17:47:52.842]   - Field: ‘lazy’
[17:47:52.842]   - Field: ‘state’
[17:47:52.842] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.842] - Launch lazy future ...
[17:47:52.842] Packages needed by the future expression (n = 0): <none>
[17:47:52.842] Packages needed by future strategies (n = 0): <none>
[17:47:52.843] {
[17:47:52.843]     {
[17:47:52.843]         {
[17:47:52.843]             ...future.startTime <- base::Sys.time()
[17:47:52.843]             {
[17:47:52.843]                 {
[17:47:52.843]                   {
[17:47:52.843]                     base::local({
[17:47:52.843]                       has_future <- base::requireNamespace("future", 
[17:47:52.843]                         quietly = TRUE)
[17:47:52.843]                       if (has_future) {
[17:47:52.843]                         ns <- base::getNamespace("future")
[17:47:52.843]                         version <- ns[[".package"]][["version"]]
[17:47:52.843]                         if (is.null(version)) 
[17:47:52.843]                           version <- utils::packageVersion("future")
[17:47:52.843]                       }
[17:47:52.843]                       else {
[17:47:52.843]                         version <- NULL
[17:47:52.843]                       }
[17:47:52.843]                       if (!has_future || version < "1.8.0") {
[17:47:52.843]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.843]                           "", base::R.version$version.string), 
[17:47:52.843]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.843]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.843]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.843]                             "release", "version")], collapse = " "), 
[17:47:52.843]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.843]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.843]                           info)
[17:47:52.843]                         info <- base::paste(info, collapse = "; ")
[17:47:52.843]                         if (!has_future) {
[17:47:52.843]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.843]                             info)
[17:47:52.843]                         }
[17:47:52.843]                         else {
[17:47:52.843]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.843]                             info, version)
[17:47:52.843]                         }
[17:47:52.843]                         base::stop(msg)
[17:47:52.843]                       }
[17:47:52.843]                     })
[17:47:52.843]                   }
[17:47:52.843]                   ...future.strategy.old <- future::plan("list")
[17:47:52.843]                   options(future.plan = NULL)
[17:47:52.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.843]                 }
[17:47:52.843]                 ...future.workdir <- getwd()
[17:47:52.843]             }
[17:47:52.843]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.843]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.843]         }
[17:47:52.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.843]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.843]             base::names(...future.oldOptions))
[17:47:52.843]     }
[17:47:52.843]     if (FALSE) {
[17:47:52.843]     }
[17:47:52.843]     else {
[17:47:52.843]         if (TRUE) {
[17:47:52.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.843]                 open = "w")
[17:47:52.843]         }
[17:47:52.843]         else {
[17:47:52.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.843]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.843]         }
[17:47:52.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.843]             base::sink(type = "output", split = FALSE)
[17:47:52.843]             base::close(...future.stdout)
[17:47:52.843]         }, add = TRUE)
[17:47:52.843]     }
[17:47:52.843]     ...future.frame <- base::sys.nframe()
[17:47:52.843]     ...future.conditions <- base::list()
[17:47:52.843]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.843]     if (FALSE) {
[17:47:52.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.843]     }
[17:47:52.843]     ...future.result <- base::tryCatch({
[17:47:52.843]         base::withCallingHandlers({
[17:47:52.843]             ...future.value <- base::withVisible(base::local(1))
[17:47:52.843]             future::FutureResult(value = ...future.value$value, 
[17:47:52.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.843]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.843]                     ...future.globalenv.names))
[17:47:52.843]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.843]         }, condition = base::local({
[17:47:52.843]             c <- base::c
[17:47:52.843]             inherits <- base::inherits
[17:47:52.843]             invokeRestart <- base::invokeRestart
[17:47:52.843]             length <- base::length
[17:47:52.843]             list <- base::list
[17:47:52.843]             seq.int <- base::seq.int
[17:47:52.843]             signalCondition <- base::signalCondition
[17:47:52.843]             sys.calls <- base::sys.calls
[17:47:52.843]             `[[` <- base::`[[`
[17:47:52.843]             `+` <- base::`+`
[17:47:52.843]             `<<-` <- base::`<<-`
[17:47:52.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.843]                   3L)]
[17:47:52.843]             }
[17:47:52.843]             function(cond) {
[17:47:52.843]                 is_error <- inherits(cond, "error")
[17:47:52.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.843]                   NULL)
[17:47:52.843]                 if (is_error) {
[17:47:52.843]                   sessionInformation <- function() {
[17:47:52.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.843]                       search = base::search(), system = base::Sys.info())
[17:47:52.843]                   }
[17:47:52.843]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.843]                     cond$call), session = sessionInformation(), 
[17:47:52.843]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.843]                   signalCondition(cond)
[17:47:52.843]                 }
[17:47:52.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.843]                 "immediateCondition"))) {
[17:47:52.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.843]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.843]                   if (TRUE && !signal) {
[17:47:52.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.843]                     {
[17:47:52.843]                       inherits <- base::inherits
[17:47:52.843]                       invokeRestart <- base::invokeRestart
[17:47:52.843]                       is.null <- base::is.null
[17:47:52.843]                       muffled <- FALSE
[17:47:52.843]                       if (inherits(cond, "message")) {
[17:47:52.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.843]                         if (muffled) 
[17:47:52.843]                           invokeRestart("muffleMessage")
[17:47:52.843]                       }
[17:47:52.843]                       else if (inherits(cond, "warning")) {
[17:47:52.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.843]                         if (muffled) 
[17:47:52.843]                           invokeRestart("muffleWarning")
[17:47:52.843]                       }
[17:47:52.843]                       else if (inherits(cond, "condition")) {
[17:47:52.843]                         if (!is.null(pattern)) {
[17:47:52.843]                           computeRestarts <- base::computeRestarts
[17:47:52.843]                           grepl <- base::grepl
[17:47:52.843]                           restarts <- computeRestarts(cond)
[17:47:52.843]                           for (restart in restarts) {
[17:47:52.843]                             name <- restart$name
[17:47:52.843]                             if (is.null(name)) 
[17:47:52.843]                               next
[17:47:52.843]                             if (!grepl(pattern, name)) 
[17:47:52.843]                               next
[17:47:52.843]                             invokeRestart(restart)
[17:47:52.843]                             muffled <- TRUE
[17:47:52.843]                             break
[17:47:52.843]                           }
[17:47:52.843]                         }
[17:47:52.843]                       }
[17:47:52.843]                       invisible(muffled)
[17:47:52.843]                     }
[17:47:52.843]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.843]                   }
[17:47:52.843]                 }
[17:47:52.843]                 else {
[17:47:52.843]                   if (TRUE) {
[17:47:52.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.843]                     {
[17:47:52.843]                       inherits <- base::inherits
[17:47:52.843]                       invokeRestart <- base::invokeRestart
[17:47:52.843]                       is.null <- base::is.null
[17:47:52.843]                       muffled <- FALSE
[17:47:52.843]                       if (inherits(cond, "message")) {
[17:47:52.843]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.843]                         if (muffled) 
[17:47:52.843]                           invokeRestart("muffleMessage")
[17:47:52.843]                       }
[17:47:52.843]                       else if (inherits(cond, "warning")) {
[17:47:52.843]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.843]                         if (muffled) 
[17:47:52.843]                           invokeRestart("muffleWarning")
[17:47:52.843]                       }
[17:47:52.843]                       else if (inherits(cond, "condition")) {
[17:47:52.843]                         if (!is.null(pattern)) {
[17:47:52.843]                           computeRestarts <- base::computeRestarts
[17:47:52.843]                           grepl <- base::grepl
[17:47:52.843]                           restarts <- computeRestarts(cond)
[17:47:52.843]                           for (restart in restarts) {
[17:47:52.843]                             name <- restart$name
[17:47:52.843]                             if (is.null(name)) 
[17:47:52.843]                               next
[17:47:52.843]                             if (!grepl(pattern, name)) 
[17:47:52.843]                               next
[17:47:52.843]                             invokeRestart(restart)
[17:47:52.843]                             muffled <- TRUE
[17:47:52.843]                             break
[17:47:52.843]                           }
[17:47:52.843]                         }
[17:47:52.843]                       }
[17:47:52.843]                       invisible(muffled)
[17:47:52.843]                     }
[17:47:52.843]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.843]                   }
[17:47:52.843]                 }
[17:47:52.843]             }
[17:47:52.843]         }))
[17:47:52.843]     }, error = function(ex) {
[17:47:52.843]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.843]                 ...future.rng), started = ...future.startTime, 
[17:47:52.843]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.843]             version = "1.8"), class = "FutureResult")
[17:47:52.843]     }, finally = {
[17:47:52.843]         if (!identical(...future.workdir, getwd())) 
[17:47:52.843]             setwd(...future.workdir)
[17:47:52.843]         {
[17:47:52.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.843]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.843]             }
[17:47:52.843]             base::options(...future.oldOptions)
[17:47:52.843]             if (.Platform$OS.type == "windows") {
[17:47:52.843]                 old_names <- names(...future.oldEnvVars)
[17:47:52.843]                 envs <- base::Sys.getenv()
[17:47:52.843]                 names <- names(envs)
[17:47:52.843]                 common <- intersect(names, old_names)
[17:47:52.843]                 added <- setdiff(names, old_names)
[17:47:52.843]                 removed <- setdiff(old_names, names)
[17:47:52.843]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.843]                   envs[common]]
[17:47:52.843]                 NAMES <- toupper(changed)
[17:47:52.843]                 args <- list()
[17:47:52.843]                 for (kk in seq_along(NAMES)) {
[17:47:52.843]                   name <- changed[[kk]]
[17:47:52.843]                   NAME <- NAMES[[kk]]
[17:47:52.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.843]                     next
[17:47:52.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.843]                 }
[17:47:52.843]                 NAMES <- toupper(added)
[17:47:52.843]                 for (kk in seq_along(NAMES)) {
[17:47:52.843]                   name <- added[[kk]]
[17:47:52.843]                   NAME <- NAMES[[kk]]
[17:47:52.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.843]                     next
[17:47:52.843]                   args[[name]] <- ""
[17:47:52.843]                 }
[17:47:52.843]                 NAMES <- toupper(removed)
[17:47:52.843]                 for (kk in seq_along(NAMES)) {
[17:47:52.843]                   name <- removed[[kk]]
[17:47:52.843]                   NAME <- NAMES[[kk]]
[17:47:52.843]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.843]                     next
[17:47:52.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.843]                 }
[17:47:52.843]                 if (length(args) > 0) 
[17:47:52.843]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.843]             }
[17:47:52.843]             else {
[17:47:52.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.843]             }
[17:47:52.843]             {
[17:47:52.843]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.843]                   0L) {
[17:47:52.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.843]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.843]                   base::options(opts)
[17:47:52.843]                 }
[17:47:52.843]                 {
[17:47:52.843]                   {
[17:47:52.843]                     NULL
[17:47:52.843]                     RNGkind("Mersenne-Twister")
[17:47:52.843]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.843]                       inherits = FALSE)
[17:47:52.843]                   }
[17:47:52.843]                   options(future.plan = NULL)
[17:47:52.843]                   if (is.na(NA_character_)) 
[17:47:52.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.843]                     .init = FALSE)
[17:47:52.843]                 }
[17:47:52.843]             }
[17:47:52.843]         }
[17:47:52.843]     })
[17:47:52.843]     if (TRUE) {
[17:47:52.843]         base::sink(type = "output", split = FALSE)
[17:47:52.843]         if (TRUE) {
[17:47:52.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.843]         }
[17:47:52.843]         else {
[17:47:52.843]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.843]         }
[17:47:52.843]         base::close(...future.stdout)
[17:47:52.843]         ...future.stdout <- NULL
[17:47:52.843]     }
[17:47:52.843]     ...future.result$conditions <- ...future.conditions
[17:47:52.843]     ...future.result$finished <- base::Sys.time()
[17:47:52.843]     ...future.result
[17:47:52.843] }
[17:47:52.845] plan(): Setting new future strategy stack:
[17:47:52.845] List of future strategies:
[17:47:52.845] 1. sequential:
[17:47:52.845]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.845]    - tweaked: FALSE
[17:47:52.845]    - call: NULL
[17:47:52.845] plan(): nbrOfWorkers() = 1
[17:47:52.846] plan(): Setting new future strategy stack:
[17:47:52.846] List of future strategies:
[17:47:52.846] 1. sequential:
[17:47:52.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.846]    - tweaked: FALSE
[17:47:52.846]    - call: plan(strategy)
[17:47:52.846] plan(): nbrOfWorkers() = 1
[17:47:52.846] SequentialFuture started (and completed)
[17:47:52.847] - Launch lazy future ... done
[17:47:52.847] run() for ‘SequentialFuture’ ... done
[17:47:52.847] getGlobalsAndPackages() ...
[17:47:52.847] Searching for globals...
[17:47:52.847] 
[17:47:52.847] Searching for globals ... DONE
[17:47:52.847] - globals: [0] <none>
[17:47:52.847] getGlobalsAndPackages() ... DONE
[17:47:52.848] run() for ‘Future’ ...
[17:47:52.848] - state: ‘created’
[17:47:52.848] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.848] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.848] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.848]   - Field: ‘label’
[17:47:52.848]   - Field: ‘local’
[17:47:52.850]   - Field: ‘owner’
[17:47:52.850]   - Field: ‘envir’
[17:47:52.850]   - Field: ‘packages’
[17:47:52.851]   - Field: ‘gc’
[17:47:52.851]   - Field: ‘conditions’
[17:47:52.851]   - Field: ‘expr’
[17:47:52.851]   - Field: ‘uuid’
[17:47:52.851]   - Field: ‘seed’
[17:47:52.851]   - Field: ‘version’
[17:47:52.851]   - Field: ‘result’
[17:47:52.851]   - Field: ‘asynchronous’
[17:47:52.851]   - Field: ‘calls’
[17:47:52.851]   - Field: ‘globals’
[17:47:52.852]   - Field: ‘stdout’
[17:47:52.852]   - Field: ‘earlySignal’
[17:47:52.852]   - Field: ‘lazy’
[17:47:52.852]   - Field: ‘state’
[17:47:52.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.852] - Launch lazy future ...
[17:47:52.852] Packages needed by the future expression (n = 0): <none>
[17:47:52.852] Packages needed by future strategies (n = 0): <none>
[17:47:52.853] {
[17:47:52.853]     {
[17:47:52.853]         {
[17:47:52.853]             ...future.startTime <- base::Sys.time()
[17:47:52.853]             {
[17:47:52.853]                 {
[17:47:52.853]                   {
[17:47:52.853]                     base::local({
[17:47:52.853]                       has_future <- base::requireNamespace("future", 
[17:47:52.853]                         quietly = TRUE)
[17:47:52.853]                       if (has_future) {
[17:47:52.853]                         ns <- base::getNamespace("future")
[17:47:52.853]                         version <- ns[[".package"]][["version"]]
[17:47:52.853]                         if (is.null(version)) 
[17:47:52.853]                           version <- utils::packageVersion("future")
[17:47:52.853]                       }
[17:47:52.853]                       else {
[17:47:52.853]                         version <- NULL
[17:47:52.853]                       }
[17:47:52.853]                       if (!has_future || version < "1.8.0") {
[17:47:52.853]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.853]                           "", base::R.version$version.string), 
[17:47:52.853]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.853]                             "release", "version")], collapse = " "), 
[17:47:52.853]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.853]                           info)
[17:47:52.853]                         info <- base::paste(info, collapse = "; ")
[17:47:52.853]                         if (!has_future) {
[17:47:52.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.853]                             info)
[17:47:52.853]                         }
[17:47:52.853]                         else {
[17:47:52.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.853]                             info, version)
[17:47:52.853]                         }
[17:47:52.853]                         base::stop(msg)
[17:47:52.853]                       }
[17:47:52.853]                     })
[17:47:52.853]                   }
[17:47:52.853]                   ...future.strategy.old <- future::plan("list")
[17:47:52.853]                   options(future.plan = NULL)
[17:47:52.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.853]                 }
[17:47:52.853]                 ...future.workdir <- getwd()
[17:47:52.853]             }
[17:47:52.853]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.853]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.853]         }
[17:47:52.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.853]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.853]             base::names(...future.oldOptions))
[17:47:52.853]     }
[17:47:52.853]     if (FALSE) {
[17:47:52.853]     }
[17:47:52.853]     else {
[17:47:52.853]         if (TRUE) {
[17:47:52.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.853]                 open = "w")
[17:47:52.853]         }
[17:47:52.853]         else {
[17:47:52.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.853]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.853]         }
[17:47:52.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.853]             base::sink(type = "output", split = FALSE)
[17:47:52.853]             base::close(...future.stdout)
[17:47:52.853]         }, add = TRUE)
[17:47:52.853]     }
[17:47:52.853]     ...future.frame <- base::sys.nframe()
[17:47:52.853]     ...future.conditions <- base::list()
[17:47:52.853]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.853]     if (FALSE) {
[17:47:52.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.853]     }
[17:47:52.853]     ...future.result <- base::tryCatch({
[17:47:52.853]         base::withCallingHandlers({
[17:47:52.853]             ...future.value <- base::withVisible(base::local(2))
[17:47:52.853]             future::FutureResult(value = ...future.value$value, 
[17:47:52.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.853]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.853]                     ...future.globalenv.names))
[17:47:52.853]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.853]         }, condition = base::local({
[17:47:52.853]             c <- base::c
[17:47:52.853]             inherits <- base::inherits
[17:47:52.853]             invokeRestart <- base::invokeRestart
[17:47:52.853]             length <- base::length
[17:47:52.853]             list <- base::list
[17:47:52.853]             seq.int <- base::seq.int
[17:47:52.853]             signalCondition <- base::signalCondition
[17:47:52.853]             sys.calls <- base::sys.calls
[17:47:52.853]             `[[` <- base::`[[`
[17:47:52.853]             `+` <- base::`+`
[17:47:52.853]             `<<-` <- base::`<<-`
[17:47:52.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.853]                   3L)]
[17:47:52.853]             }
[17:47:52.853]             function(cond) {
[17:47:52.853]                 is_error <- inherits(cond, "error")
[17:47:52.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.853]                   NULL)
[17:47:52.853]                 if (is_error) {
[17:47:52.853]                   sessionInformation <- function() {
[17:47:52.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.853]                       search = base::search(), system = base::Sys.info())
[17:47:52.853]                   }
[17:47:52.853]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.853]                     cond$call), session = sessionInformation(), 
[17:47:52.853]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.853]                   signalCondition(cond)
[17:47:52.853]                 }
[17:47:52.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.853]                 "immediateCondition"))) {
[17:47:52.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.853]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.853]                   if (TRUE && !signal) {
[17:47:52.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.853]                     {
[17:47:52.853]                       inherits <- base::inherits
[17:47:52.853]                       invokeRestart <- base::invokeRestart
[17:47:52.853]                       is.null <- base::is.null
[17:47:52.853]                       muffled <- FALSE
[17:47:52.853]                       if (inherits(cond, "message")) {
[17:47:52.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.853]                         if (muffled) 
[17:47:52.853]                           invokeRestart("muffleMessage")
[17:47:52.853]                       }
[17:47:52.853]                       else if (inherits(cond, "warning")) {
[17:47:52.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.853]                         if (muffled) 
[17:47:52.853]                           invokeRestart("muffleWarning")
[17:47:52.853]                       }
[17:47:52.853]                       else if (inherits(cond, "condition")) {
[17:47:52.853]                         if (!is.null(pattern)) {
[17:47:52.853]                           computeRestarts <- base::computeRestarts
[17:47:52.853]                           grepl <- base::grepl
[17:47:52.853]                           restarts <- computeRestarts(cond)
[17:47:52.853]                           for (restart in restarts) {
[17:47:52.853]                             name <- restart$name
[17:47:52.853]                             if (is.null(name)) 
[17:47:52.853]                               next
[17:47:52.853]                             if (!grepl(pattern, name)) 
[17:47:52.853]                               next
[17:47:52.853]                             invokeRestart(restart)
[17:47:52.853]                             muffled <- TRUE
[17:47:52.853]                             break
[17:47:52.853]                           }
[17:47:52.853]                         }
[17:47:52.853]                       }
[17:47:52.853]                       invisible(muffled)
[17:47:52.853]                     }
[17:47:52.853]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.853]                   }
[17:47:52.853]                 }
[17:47:52.853]                 else {
[17:47:52.853]                   if (TRUE) {
[17:47:52.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.853]                     {
[17:47:52.853]                       inherits <- base::inherits
[17:47:52.853]                       invokeRestart <- base::invokeRestart
[17:47:52.853]                       is.null <- base::is.null
[17:47:52.853]                       muffled <- FALSE
[17:47:52.853]                       if (inherits(cond, "message")) {
[17:47:52.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.853]                         if (muffled) 
[17:47:52.853]                           invokeRestart("muffleMessage")
[17:47:52.853]                       }
[17:47:52.853]                       else if (inherits(cond, "warning")) {
[17:47:52.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.853]                         if (muffled) 
[17:47:52.853]                           invokeRestart("muffleWarning")
[17:47:52.853]                       }
[17:47:52.853]                       else if (inherits(cond, "condition")) {
[17:47:52.853]                         if (!is.null(pattern)) {
[17:47:52.853]                           computeRestarts <- base::computeRestarts
[17:47:52.853]                           grepl <- base::grepl
[17:47:52.853]                           restarts <- computeRestarts(cond)
[17:47:52.853]                           for (restart in restarts) {
[17:47:52.853]                             name <- restart$name
[17:47:52.853]                             if (is.null(name)) 
[17:47:52.853]                               next
[17:47:52.853]                             if (!grepl(pattern, name)) 
[17:47:52.853]                               next
[17:47:52.853]                             invokeRestart(restart)
[17:47:52.853]                             muffled <- TRUE
[17:47:52.853]                             break
[17:47:52.853]                           }
[17:47:52.853]                         }
[17:47:52.853]                       }
[17:47:52.853]                       invisible(muffled)
[17:47:52.853]                     }
[17:47:52.853]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.853]                   }
[17:47:52.853]                 }
[17:47:52.853]             }
[17:47:52.853]         }))
[17:47:52.853]     }, error = function(ex) {
[17:47:52.853]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.853]                 ...future.rng), started = ...future.startTime, 
[17:47:52.853]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.853]             version = "1.8"), class = "FutureResult")
[17:47:52.853]     }, finally = {
[17:47:52.853]         if (!identical(...future.workdir, getwd())) 
[17:47:52.853]             setwd(...future.workdir)
[17:47:52.853]         {
[17:47:52.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.853]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.853]             }
[17:47:52.853]             base::options(...future.oldOptions)
[17:47:52.853]             if (.Platform$OS.type == "windows") {
[17:47:52.853]                 old_names <- names(...future.oldEnvVars)
[17:47:52.853]                 envs <- base::Sys.getenv()
[17:47:52.853]                 names <- names(envs)
[17:47:52.853]                 common <- intersect(names, old_names)
[17:47:52.853]                 added <- setdiff(names, old_names)
[17:47:52.853]                 removed <- setdiff(old_names, names)
[17:47:52.853]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.853]                   envs[common]]
[17:47:52.853]                 NAMES <- toupper(changed)
[17:47:52.853]                 args <- list()
[17:47:52.853]                 for (kk in seq_along(NAMES)) {
[17:47:52.853]                   name <- changed[[kk]]
[17:47:52.853]                   NAME <- NAMES[[kk]]
[17:47:52.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.853]                     next
[17:47:52.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.853]                 }
[17:47:52.853]                 NAMES <- toupper(added)
[17:47:52.853]                 for (kk in seq_along(NAMES)) {
[17:47:52.853]                   name <- added[[kk]]
[17:47:52.853]                   NAME <- NAMES[[kk]]
[17:47:52.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.853]                     next
[17:47:52.853]                   args[[name]] <- ""
[17:47:52.853]                 }
[17:47:52.853]                 NAMES <- toupper(removed)
[17:47:52.853]                 for (kk in seq_along(NAMES)) {
[17:47:52.853]                   name <- removed[[kk]]
[17:47:52.853]                   NAME <- NAMES[[kk]]
[17:47:52.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.853]                     next
[17:47:52.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.853]                 }
[17:47:52.853]                 if (length(args) > 0) 
[17:47:52.853]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.853]             }
[17:47:52.853]             else {
[17:47:52.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.853]             }
[17:47:52.853]             {
[17:47:52.853]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.853]                   0L) {
[17:47:52.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.853]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.853]                   base::options(opts)
[17:47:52.853]                 }
[17:47:52.853]                 {
[17:47:52.853]                   {
[17:47:52.853]                     NULL
[17:47:52.853]                     RNGkind("Mersenne-Twister")
[17:47:52.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.853]                       inherits = FALSE)
[17:47:52.853]                   }
[17:47:52.853]                   options(future.plan = NULL)
[17:47:52.853]                   if (is.na(NA_character_)) 
[17:47:52.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.853]                     .init = FALSE)
[17:47:52.853]                 }
[17:47:52.853]             }
[17:47:52.853]         }
[17:47:52.853]     })
[17:47:52.853]     if (TRUE) {
[17:47:52.853]         base::sink(type = "output", split = FALSE)
[17:47:52.853]         if (TRUE) {
[17:47:52.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.853]         }
[17:47:52.853]         else {
[17:47:52.853]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.853]         }
[17:47:52.853]         base::close(...future.stdout)
[17:47:52.853]         ...future.stdout <- NULL
[17:47:52.853]     }
[17:47:52.853]     ...future.result$conditions <- ...future.conditions
[17:47:52.853]     ...future.result$finished <- base::Sys.time()
[17:47:52.853]     ...future.result
[17:47:52.853] }
[17:47:52.854] plan(): Setting new future strategy stack:
[17:47:52.854] List of future strategies:
[17:47:52.854] 1. sequential:
[17:47:52.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.854]    - tweaked: FALSE
[17:47:52.854]    - call: NULL
[17:47:52.855] plan(): nbrOfWorkers() = 1
[17:47:52.856] plan(): Setting new future strategy stack:
[17:47:52.856] List of future strategies:
[17:47:52.856] 1. sequential:
[17:47:52.856]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.856]    - tweaked: FALSE
[17:47:52.856]    - call: plan(strategy)
[17:47:52.856] plan(): nbrOfWorkers() = 1
[17:47:52.856] SequentialFuture started (and completed)
[17:47:52.856] - Launch lazy future ... done
[17:47:52.856] run() for ‘SequentialFuture’ ... done
[17:47:52.857] resolve() on environment ...
[17:47:52.857]  recursive: 0
[17:47:52.857]  elements: [3] ‘a’, ‘b’, ‘c’
[17:47:52.858] resolved() for ‘SequentialFuture’ ...
[17:47:52.858] - state: ‘finished’
[17:47:52.858] - run: TRUE
[17:47:52.858] - result: ‘FutureResult’
[17:47:52.858] resolved() for ‘SequentialFuture’ ... done
[17:47:52.858] Future #1
[17:47:52.858]  length: 2 (resolved future 1)
[17:47:52.858] resolved() for ‘SequentialFuture’ ...
[17:47:52.858] - state: ‘finished’
[17:47:52.858] - run: TRUE
[17:47:52.859] - result: ‘FutureResult’
[17:47:52.859] resolved() for ‘SequentialFuture’ ... done
[17:47:52.859] Future #2
[17:47:52.859]  length: 1 (resolved future 2)
[17:47:52.859]  length: 0 (resolved future 3)
[17:47:52.859] resolve() on environment ... DONE
[17:47:52.859] resolved() for ‘SequentialFuture’ ...
[17:47:52.859] - state: ‘finished’
[17:47:52.859] - run: TRUE
[17:47:52.859] - result: ‘FutureResult’
[17:47:52.860] resolved() for ‘SequentialFuture’ ... done
[17:47:52.860] resolved() for ‘SequentialFuture’ ...
[17:47:52.860] - state: ‘finished’
[17:47:52.860] - run: TRUE
[17:47:52.860] - result: ‘FutureResult’
[17:47:52.860] resolved() for ‘SequentialFuture’ ... done
[17:47:52.861] getGlobalsAndPackages() ...
[17:47:52.861] Searching for globals...
[17:47:52.861] - globals found: [1] ‘{’
[17:47:52.862] Searching for globals ... DONE
[17:47:52.862] Resolving globals: FALSE
[17:47:52.862] 
[17:47:52.862] 
[17:47:52.862] getGlobalsAndPackages() ... DONE
[17:47:52.862] run() for ‘Future’ ...
[17:47:52.862] - state: ‘created’
[17:47:52.862] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.863] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.863] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.863]   - Field: ‘label’
[17:47:52.863]   - Field: ‘local’
[17:47:52.863]   - Field: ‘owner’
[17:47:52.863]   - Field: ‘envir’
[17:47:52.863]   - Field: ‘packages’
[17:47:52.863]   - Field: ‘gc’
[17:47:52.863]   - Field: ‘conditions’
[17:47:52.864]   - Field: ‘expr’
[17:47:52.864]   - Field: ‘uuid’
[17:47:52.864]   - Field: ‘seed’
[17:47:52.864]   - Field: ‘version’
[17:47:52.864]   - Field: ‘result’
[17:47:52.864]   - Field: ‘asynchronous’
[17:47:52.864]   - Field: ‘calls’
[17:47:52.864]   - Field: ‘globals’
[17:47:52.864]   - Field: ‘stdout’
[17:47:52.864]   - Field: ‘earlySignal’
[17:47:52.864]   - Field: ‘lazy’
[17:47:52.865]   - Field: ‘state’
[17:47:52.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.865] - Launch lazy future ...
[17:47:52.865] Packages needed by the future expression (n = 0): <none>
[17:47:52.865] Packages needed by future strategies (n = 0): <none>
[17:47:52.865] {
[17:47:52.865]     {
[17:47:52.865]         {
[17:47:52.865]             ...future.startTime <- base::Sys.time()
[17:47:52.865]             {
[17:47:52.865]                 {
[17:47:52.865]                   {
[17:47:52.865]                     base::local({
[17:47:52.865]                       has_future <- base::requireNamespace("future", 
[17:47:52.865]                         quietly = TRUE)
[17:47:52.865]                       if (has_future) {
[17:47:52.865]                         ns <- base::getNamespace("future")
[17:47:52.865]                         version <- ns[[".package"]][["version"]]
[17:47:52.865]                         if (is.null(version)) 
[17:47:52.865]                           version <- utils::packageVersion("future")
[17:47:52.865]                       }
[17:47:52.865]                       else {
[17:47:52.865]                         version <- NULL
[17:47:52.865]                       }
[17:47:52.865]                       if (!has_future || version < "1.8.0") {
[17:47:52.865]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.865]                           "", base::R.version$version.string), 
[17:47:52.865]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.865]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.865]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.865]                             "release", "version")], collapse = " "), 
[17:47:52.865]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.865]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.865]                           info)
[17:47:52.865]                         info <- base::paste(info, collapse = "; ")
[17:47:52.865]                         if (!has_future) {
[17:47:52.865]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.865]                             info)
[17:47:52.865]                         }
[17:47:52.865]                         else {
[17:47:52.865]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.865]                             info, version)
[17:47:52.865]                         }
[17:47:52.865]                         base::stop(msg)
[17:47:52.865]                       }
[17:47:52.865]                     })
[17:47:52.865]                   }
[17:47:52.865]                   ...future.strategy.old <- future::plan("list")
[17:47:52.865]                   options(future.plan = NULL)
[17:47:52.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.865]                 }
[17:47:52.865]                 ...future.workdir <- getwd()
[17:47:52.865]             }
[17:47:52.865]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.865]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.865]         }
[17:47:52.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.865]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.865]             base::names(...future.oldOptions))
[17:47:52.865]     }
[17:47:52.865]     if (FALSE) {
[17:47:52.865]     }
[17:47:52.865]     else {
[17:47:52.865]         if (TRUE) {
[17:47:52.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.865]                 open = "w")
[17:47:52.865]         }
[17:47:52.865]         else {
[17:47:52.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.865]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.865]         }
[17:47:52.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.865]             base::sink(type = "output", split = FALSE)
[17:47:52.865]             base::close(...future.stdout)
[17:47:52.865]         }, add = TRUE)
[17:47:52.865]     }
[17:47:52.865]     ...future.frame <- base::sys.nframe()
[17:47:52.865]     ...future.conditions <- base::list()
[17:47:52.865]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.865]     if (FALSE) {
[17:47:52.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.865]     }
[17:47:52.865]     ...future.result <- base::tryCatch({
[17:47:52.865]         base::withCallingHandlers({
[17:47:52.865]             ...future.value <- base::withVisible(base::local({
[17:47:52.865]                 1
[17:47:52.865]             }))
[17:47:52.865]             future::FutureResult(value = ...future.value$value, 
[17:47:52.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.865]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.865]                     ...future.globalenv.names))
[17:47:52.865]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.865]         }, condition = base::local({
[17:47:52.865]             c <- base::c
[17:47:52.865]             inherits <- base::inherits
[17:47:52.865]             invokeRestart <- base::invokeRestart
[17:47:52.865]             length <- base::length
[17:47:52.865]             list <- base::list
[17:47:52.865]             seq.int <- base::seq.int
[17:47:52.865]             signalCondition <- base::signalCondition
[17:47:52.865]             sys.calls <- base::sys.calls
[17:47:52.865]             `[[` <- base::`[[`
[17:47:52.865]             `+` <- base::`+`
[17:47:52.865]             `<<-` <- base::`<<-`
[17:47:52.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.865]                   3L)]
[17:47:52.865]             }
[17:47:52.865]             function(cond) {
[17:47:52.865]                 is_error <- inherits(cond, "error")
[17:47:52.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.865]                   NULL)
[17:47:52.865]                 if (is_error) {
[17:47:52.865]                   sessionInformation <- function() {
[17:47:52.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.865]                       search = base::search(), system = base::Sys.info())
[17:47:52.865]                   }
[17:47:52.865]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.865]                     cond$call), session = sessionInformation(), 
[17:47:52.865]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.865]                   signalCondition(cond)
[17:47:52.865]                 }
[17:47:52.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.865]                 "immediateCondition"))) {
[17:47:52.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.865]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.865]                   if (TRUE && !signal) {
[17:47:52.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.865]                     {
[17:47:52.865]                       inherits <- base::inherits
[17:47:52.865]                       invokeRestart <- base::invokeRestart
[17:47:52.865]                       is.null <- base::is.null
[17:47:52.865]                       muffled <- FALSE
[17:47:52.865]                       if (inherits(cond, "message")) {
[17:47:52.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.865]                         if (muffled) 
[17:47:52.865]                           invokeRestart("muffleMessage")
[17:47:52.865]                       }
[17:47:52.865]                       else if (inherits(cond, "warning")) {
[17:47:52.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.865]                         if (muffled) 
[17:47:52.865]                           invokeRestart("muffleWarning")
[17:47:52.865]                       }
[17:47:52.865]                       else if (inherits(cond, "condition")) {
[17:47:52.865]                         if (!is.null(pattern)) {
[17:47:52.865]                           computeRestarts <- base::computeRestarts
[17:47:52.865]                           grepl <- base::grepl
[17:47:52.865]                           restarts <- computeRestarts(cond)
[17:47:52.865]                           for (restart in restarts) {
[17:47:52.865]                             name <- restart$name
[17:47:52.865]                             if (is.null(name)) 
[17:47:52.865]                               next
[17:47:52.865]                             if (!grepl(pattern, name)) 
[17:47:52.865]                               next
[17:47:52.865]                             invokeRestart(restart)
[17:47:52.865]                             muffled <- TRUE
[17:47:52.865]                             break
[17:47:52.865]                           }
[17:47:52.865]                         }
[17:47:52.865]                       }
[17:47:52.865]                       invisible(muffled)
[17:47:52.865]                     }
[17:47:52.865]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.865]                   }
[17:47:52.865]                 }
[17:47:52.865]                 else {
[17:47:52.865]                   if (TRUE) {
[17:47:52.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.865]                     {
[17:47:52.865]                       inherits <- base::inherits
[17:47:52.865]                       invokeRestart <- base::invokeRestart
[17:47:52.865]                       is.null <- base::is.null
[17:47:52.865]                       muffled <- FALSE
[17:47:52.865]                       if (inherits(cond, "message")) {
[17:47:52.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.865]                         if (muffled) 
[17:47:52.865]                           invokeRestart("muffleMessage")
[17:47:52.865]                       }
[17:47:52.865]                       else if (inherits(cond, "warning")) {
[17:47:52.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.865]                         if (muffled) 
[17:47:52.865]                           invokeRestart("muffleWarning")
[17:47:52.865]                       }
[17:47:52.865]                       else if (inherits(cond, "condition")) {
[17:47:52.865]                         if (!is.null(pattern)) {
[17:47:52.865]                           computeRestarts <- base::computeRestarts
[17:47:52.865]                           grepl <- base::grepl
[17:47:52.865]                           restarts <- computeRestarts(cond)
[17:47:52.865]                           for (restart in restarts) {
[17:47:52.865]                             name <- restart$name
[17:47:52.865]                             if (is.null(name)) 
[17:47:52.865]                               next
[17:47:52.865]                             if (!grepl(pattern, name)) 
[17:47:52.865]                               next
[17:47:52.865]                             invokeRestart(restart)
[17:47:52.865]                             muffled <- TRUE
[17:47:52.865]                             break
[17:47:52.865]                           }
[17:47:52.865]                         }
[17:47:52.865]                       }
[17:47:52.865]                       invisible(muffled)
[17:47:52.865]                     }
[17:47:52.865]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.865]                   }
[17:47:52.865]                 }
[17:47:52.865]             }
[17:47:52.865]         }))
[17:47:52.865]     }, error = function(ex) {
[17:47:52.865]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.865]                 ...future.rng), started = ...future.startTime, 
[17:47:52.865]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.865]             version = "1.8"), class = "FutureResult")
[17:47:52.865]     }, finally = {
[17:47:52.865]         if (!identical(...future.workdir, getwd())) 
[17:47:52.865]             setwd(...future.workdir)
[17:47:52.865]         {
[17:47:52.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.865]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.865]             }
[17:47:52.865]             base::options(...future.oldOptions)
[17:47:52.865]             if (.Platform$OS.type == "windows") {
[17:47:52.865]                 old_names <- names(...future.oldEnvVars)
[17:47:52.865]                 envs <- base::Sys.getenv()
[17:47:52.865]                 names <- names(envs)
[17:47:52.865]                 common <- intersect(names, old_names)
[17:47:52.865]                 added <- setdiff(names, old_names)
[17:47:52.865]                 removed <- setdiff(old_names, names)
[17:47:52.865]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.865]                   envs[common]]
[17:47:52.865]                 NAMES <- toupper(changed)
[17:47:52.865]                 args <- list()
[17:47:52.865]                 for (kk in seq_along(NAMES)) {
[17:47:52.865]                   name <- changed[[kk]]
[17:47:52.865]                   NAME <- NAMES[[kk]]
[17:47:52.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.865]                     next
[17:47:52.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.865]                 }
[17:47:52.865]                 NAMES <- toupper(added)
[17:47:52.865]                 for (kk in seq_along(NAMES)) {
[17:47:52.865]                   name <- added[[kk]]
[17:47:52.865]                   NAME <- NAMES[[kk]]
[17:47:52.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.865]                     next
[17:47:52.865]                   args[[name]] <- ""
[17:47:52.865]                 }
[17:47:52.865]                 NAMES <- toupper(removed)
[17:47:52.865]                 for (kk in seq_along(NAMES)) {
[17:47:52.865]                   name <- removed[[kk]]
[17:47:52.865]                   NAME <- NAMES[[kk]]
[17:47:52.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.865]                     next
[17:47:52.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.865]                 }
[17:47:52.865]                 if (length(args) > 0) 
[17:47:52.865]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.865]             }
[17:47:52.865]             else {
[17:47:52.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.865]             }
[17:47:52.865]             {
[17:47:52.865]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.865]                   0L) {
[17:47:52.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.865]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.865]                   base::options(opts)
[17:47:52.865]                 }
[17:47:52.865]                 {
[17:47:52.865]                   {
[17:47:52.865]                     NULL
[17:47:52.865]                     RNGkind("Mersenne-Twister")
[17:47:52.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.865]                       inherits = FALSE)
[17:47:52.865]                   }
[17:47:52.865]                   options(future.plan = NULL)
[17:47:52.865]                   if (is.na(NA_character_)) 
[17:47:52.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.865]                     .init = FALSE)
[17:47:52.865]                 }
[17:47:52.865]             }
[17:47:52.865]         }
[17:47:52.865]     })
[17:47:52.865]     if (TRUE) {
[17:47:52.865]         base::sink(type = "output", split = FALSE)
[17:47:52.865]         if (TRUE) {
[17:47:52.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.865]         }
[17:47:52.865]         else {
[17:47:52.865]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.865]         }
[17:47:52.865]         base::close(...future.stdout)
[17:47:52.865]         ...future.stdout <- NULL
[17:47:52.865]     }
[17:47:52.865]     ...future.result$conditions <- ...future.conditions
[17:47:52.865]     ...future.result$finished <- base::Sys.time()
[17:47:52.865]     ...future.result
[17:47:52.865] }
[17:47:52.867] plan(): Setting new future strategy stack:
[17:47:52.867] List of future strategies:
[17:47:52.867] 1. sequential:
[17:47:52.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.867]    - tweaked: FALSE
[17:47:52.867]    - call: NULL
[17:47:52.868] plan(): nbrOfWorkers() = 1
[17:47:52.868] plan(): Setting new future strategy stack:
[17:47:52.868] List of future strategies:
[17:47:52.868] 1. sequential:
[17:47:52.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.868]    - tweaked: FALSE
[17:47:52.868]    - call: plan(strategy)
[17:47:52.869] plan(): nbrOfWorkers() = 1
[17:47:52.869] SequentialFuture started (and completed)
[17:47:52.869] - Launch lazy future ... done
[17:47:52.869] run() for ‘SequentialFuture’ ... done
[17:47:52.869] getGlobalsAndPackages() ...
[17:47:52.870] Searching for globals...
[17:47:52.870] - globals found: [1] ‘{’
[17:47:52.870] Searching for globals ... DONE
[17:47:52.870] Resolving globals: FALSE
[17:47:52.871] 
[17:47:52.871] 
[17:47:52.871] getGlobalsAndPackages() ... DONE
[17:47:52.871] run() for ‘Future’ ...
[17:47:52.871] - state: ‘created’
[17:47:52.871] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.871] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.872] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.872]   - Field: ‘label’
[17:47:52.872]   - Field: ‘local’
[17:47:52.872]   - Field: ‘owner’
[17:47:52.872]   - Field: ‘envir’
[17:47:52.872]   - Field: ‘packages’
[17:47:52.872]   - Field: ‘gc’
[17:47:52.872]   - Field: ‘conditions’
[17:47:52.872]   - Field: ‘expr’
[17:47:52.872]   - Field: ‘uuid’
[17:47:52.872]   - Field: ‘seed’
[17:47:52.873]   - Field: ‘version’
[17:47:52.873]   - Field: ‘result’
[17:47:52.873]   - Field: ‘asynchronous’
[17:47:52.873]   - Field: ‘calls’
[17:47:52.873]   - Field: ‘globals’
[17:47:52.873]   - Field: ‘stdout’
[17:47:52.873]   - Field: ‘earlySignal’
[17:47:52.873]   - Field: ‘lazy’
[17:47:52.873]   - Field: ‘state’
[17:47:52.873] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.873] - Launch lazy future ...
[17:47:52.874] Packages needed by the future expression (n = 0): <none>
[17:47:52.874] Packages needed by future strategies (n = 0): <none>
[17:47:52.874] {
[17:47:52.874]     {
[17:47:52.874]         {
[17:47:52.874]             ...future.startTime <- base::Sys.time()
[17:47:52.874]             {
[17:47:52.874]                 {
[17:47:52.874]                   {
[17:47:52.874]                     base::local({
[17:47:52.874]                       has_future <- base::requireNamespace("future", 
[17:47:52.874]                         quietly = TRUE)
[17:47:52.874]                       if (has_future) {
[17:47:52.874]                         ns <- base::getNamespace("future")
[17:47:52.874]                         version <- ns[[".package"]][["version"]]
[17:47:52.874]                         if (is.null(version)) 
[17:47:52.874]                           version <- utils::packageVersion("future")
[17:47:52.874]                       }
[17:47:52.874]                       else {
[17:47:52.874]                         version <- NULL
[17:47:52.874]                       }
[17:47:52.874]                       if (!has_future || version < "1.8.0") {
[17:47:52.874]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.874]                           "", base::R.version$version.string), 
[17:47:52.874]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.874]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.874]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.874]                             "release", "version")], collapse = " "), 
[17:47:52.874]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.874]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.874]                           info)
[17:47:52.874]                         info <- base::paste(info, collapse = "; ")
[17:47:52.874]                         if (!has_future) {
[17:47:52.874]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.874]                             info)
[17:47:52.874]                         }
[17:47:52.874]                         else {
[17:47:52.874]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.874]                             info, version)
[17:47:52.874]                         }
[17:47:52.874]                         base::stop(msg)
[17:47:52.874]                       }
[17:47:52.874]                     })
[17:47:52.874]                   }
[17:47:52.874]                   ...future.strategy.old <- future::plan("list")
[17:47:52.874]                   options(future.plan = NULL)
[17:47:52.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.874]                 }
[17:47:52.874]                 ...future.workdir <- getwd()
[17:47:52.874]             }
[17:47:52.874]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.874]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.874]         }
[17:47:52.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.874]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.874]             base::names(...future.oldOptions))
[17:47:52.874]     }
[17:47:52.874]     if (FALSE) {
[17:47:52.874]     }
[17:47:52.874]     else {
[17:47:52.874]         if (TRUE) {
[17:47:52.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.874]                 open = "w")
[17:47:52.874]         }
[17:47:52.874]         else {
[17:47:52.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.874]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.874]         }
[17:47:52.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.874]             base::sink(type = "output", split = FALSE)
[17:47:52.874]             base::close(...future.stdout)
[17:47:52.874]         }, add = TRUE)
[17:47:52.874]     }
[17:47:52.874]     ...future.frame <- base::sys.nframe()
[17:47:52.874]     ...future.conditions <- base::list()
[17:47:52.874]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.874]     if (FALSE) {
[17:47:52.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.874]     }
[17:47:52.874]     ...future.result <- base::tryCatch({
[17:47:52.874]         base::withCallingHandlers({
[17:47:52.874]             ...future.value <- base::withVisible(base::local({
[17:47:52.874]                 2
[17:47:52.874]             }))
[17:47:52.874]             future::FutureResult(value = ...future.value$value, 
[17:47:52.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.874]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.874]                     ...future.globalenv.names))
[17:47:52.874]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.874]         }, condition = base::local({
[17:47:52.874]             c <- base::c
[17:47:52.874]             inherits <- base::inherits
[17:47:52.874]             invokeRestart <- base::invokeRestart
[17:47:52.874]             length <- base::length
[17:47:52.874]             list <- base::list
[17:47:52.874]             seq.int <- base::seq.int
[17:47:52.874]             signalCondition <- base::signalCondition
[17:47:52.874]             sys.calls <- base::sys.calls
[17:47:52.874]             `[[` <- base::`[[`
[17:47:52.874]             `+` <- base::`+`
[17:47:52.874]             `<<-` <- base::`<<-`
[17:47:52.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.874]                   3L)]
[17:47:52.874]             }
[17:47:52.874]             function(cond) {
[17:47:52.874]                 is_error <- inherits(cond, "error")
[17:47:52.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.874]                   NULL)
[17:47:52.874]                 if (is_error) {
[17:47:52.874]                   sessionInformation <- function() {
[17:47:52.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.874]                       search = base::search(), system = base::Sys.info())
[17:47:52.874]                   }
[17:47:52.874]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.874]                     cond$call), session = sessionInformation(), 
[17:47:52.874]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.874]                   signalCondition(cond)
[17:47:52.874]                 }
[17:47:52.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.874]                 "immediateCondition"))) {
[17:47:52.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.874]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.874]                   if (TRUE && !signal) {
[17:47:52.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.874]                     {
[17:47:52.874]                       inherits <- base::inherits
[17:47:52.874]                       invokeRestart <- base::invokeRestart
[17:47:52.874]                       is.null <- base::is.null
[17:47:52.874]                       muffled <- FALSE
[17:47:52.874]                       if (inherits(cond, "message")) {
[17:47:52.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.874]                         if (muffled) 
[17:47:52.874]                           invokeRestart("muffleMessage")
[17:47:52.874]                       }
[17:47:52.874]                       else if (inherits(cond, "warning")) {
[17:47:52.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.874]                         if (muffled) 
[17:47:52.874]                           invokeRestart("muffleWarning")
[17:47:52.874]                       }
[17:47:52.874]                       else if (inherits(cond, "condition")) {
[17:47:52.874]                         if (!is.null(pattern)) {
[17:47:52.874]                           computeRestarts <- base::computeRestarts
[17:47:52.874]                           grepl <- base::grepl
[17:47:52.874]                           restarts <- computeRestarts(cond)
[17:47:52.874]                           for (restart in restarts) {
[17:47:52.874]                             name <- restart$name
[17:47:52.874]                             if (is.null(name)) 
[17:47:52.874]                               next
[17:47:52.874]                             if (!grepl(pattern, name)) 
[17:47:52.874]                               next
[17:47:52.874]                             invokeRestart(restart)
[17:47:52.874]                             muffled <- TRUE
[17:47:52.874]                             break
[17:47:52.874]                           }
[17:47:52.874]                         }
[17:47:52.874]                       }
[17:47:52.874]                       invisible(muffled)
[17:47:52.874]                     }
[17:47:52.874]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.874]                   }
[17:47:52.874]                 }
[17:47:52.874]                 else {
[17:47:52.874]                   if (TRUE) {
[17:47:52.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.874]                     {
[17:47:52.874]                       inherits <- base::inherits
[17:47:52.874]                       invokeRestart <- base::invokeRestart
[17:47:52.874]                       is.null <- base::is.null
[17:47:52.874]                       muffled <- FALSE
[17:47:52.874]                       if (inherits(cond, "message")) {
[17:47:52.874]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.874]                         if (muffled) 
[17:47:52.874]                           invokeRestart("muffleMessage")
[17:47:52.874]                       }
[17:47:52.874]                       else if (inherits(cond, "warning")) {
[17:47:52.874]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.874]                         if (muffled) 
[17:47:52.874]                           invokeRestart("muffleWarning")
[17:47:52.874]                       }
[17:47:52.874]                       else if (inherits(cond, "condition")) {
[17:47:52.874]                         if (!is.null(pattern)) {
[17:47:52.874]                           computeRestarts <- base::computeRestarts
[17:47:52.874]                           grepl <- base::grepl
[17:47:52.874]                           restarts <- computeRestarts(cond)
[17:47:52.874]                           for (restart in restarts) {
[17:47:52.874]                             name <- restart$name
[17:47:52.874]                             if (is.null(name)) 
[17:47:52.874]                               next
[17:47:52.874]                             if (!grepl(pattern, name)) 
[17:47:52.874]                               next
[17:47:52.874]                             invokeRestart(restart)
[17:47:52.874]                             muffled <- TRUE
[17:47:52.874]                             break
[17:47:52.874]                           }
[17:47:52.874]                         }
[17:47:52.874]                       }
[17:47:52.874]                       invisible(muffled)
[17:47:52.874]                     }
[17:47:52.874]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.874]                   }
[17:47:52.874]                 }
[17:47:52.874]             }
[17:47:52.874]         }))
[17:47:52.874]     }, error = function(ex) {
[17:47:52.874]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.874]                 ...future.rng), started = ...future.startTime, 
[17:47:52.874]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.874]             version = "1.8"), class = "FutureResult")
[17:47:52.874]     }, finally = {
[17:47:52.874]         if (!identical(...future.workdir, getwd())) 
[17:47:52.874]             setwd(...future.workdir)
[17:47:52.874]         {
[17:47:52.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.874]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.874]             }
[17:47:52.874]             base::options(...future.oldOptions)
[17:47:52.874]             if (.Platform$OS.type == "windows") {
[17:47:52.874]                 old_names <- names(...future.oldEnvVars)
[17:47:52.874]                 envs <- base::Sys.getenv()
[17:47:52.874]                 names <- names(envs)
[17:47:52.874]                 common <- intersect(names, old_names)
[17:47:52.874]                 added <- setdiff(names, old_names)
[17:47:52.874]                 removed <- setdiff(old_names, names)
[17:47:52.874]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.874]                   envs[common]]
[17:47:52.874]                 NAMES <- toupper(changed)
[17:47:52.874]                 args <- list()
[17:47:52.874]                 for (kk in seq_along(NAMES)) {
[17:47:52.874]                   name <- changed[[kk]]
[17:47:52.874]                   NAME <- NAMES[[kk]]
[17:47:52.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.874]                     next
[17:47:52.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.874]                 }
[17:47:52.874]                 NAMES <- toupper(added)
[17:47:52.874]                 for (kk in seq_along(NAMES)) {
[17:47:52.874]                   name <- added[[kk]]
[17:47:52.874]                   NAME <- NAMES[[kk]]
[17:47:52.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.874]                     next
[17:47:52.874]                   args[[name]] <- ""
[17:47:52.874]                 }
[17:47:52.874]                 NAMES <- toupper(removed)
[17:47:52.874]                 for (kk in seq_along(NAMES)) {
[17:47:52.874]                   name <- removed[[kk]]
[17:47:52.874]                   NAME <- NAMES[[kk]]
[17:47:52.874]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.874]                     next
[17:47:52.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.874]                 }
[17:47:52.874]                 if (length(args) > 0) 
[17:47:52.874]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.874]             }
[17:47:52.874]             else {
[17:47:52.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.874]             }
[17:47:52.874]             {
[17:47:52.874]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.874]                   0L) {
[17:47:52.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.874]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.874]                   base::options(opts)
[17:47:52.874]                 }
[17:47:52.874]                 {
[17:47:52.874]                   {
[17:47:52.874]                     NULL
[17:47:52.874]                     RNGkind("Mersenne-Twister")
[17:47:52.874]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.874]                       inherits = FALSE)
[17:47:52.874]                   }
[17:47:52.874]                   options(future.plan = NULL)
[17:47:52.874]                   if (is.na(NA_character_)) 
[17:47:52.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.874]                     .init = FALSE)
[17:47:52.874]                 }
[17:47:52.874]             }
[17:47:52.874]         }
[17:47:52.874]     })
[17:47:52.874]     if (TRUE) {
[17:47:52.874]         base::sink(type = "output", split = FALSE)
[17:47:52.874]         if (TRUE) {
[17:47:52.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.874]         }
[17:47:52.874]         else {
[17:47:52.874]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.874]         }
[17:47:52.874]         base::close(...future.stdout)
[17:47:52.874]         ...future.stdout <- NULL
[17:47:52.874]     }
[17:47:52.874]     ...future.result$conditions <- ...future.conditions
[17:47:52.874]     ...future.result$finished <- base::Sys.time()
[17:47:52.874]     ...future.result
[17:47:52.874] }
[17:47:52.876] plan(): Setting new future strategy stack:
[17:47:52.876] List of future strategies:
[17:47:52.876] 1. sequential:
[17:47:52.876]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.876]    - tweaked: FALSE
[17:47:52.876]    - call: NULL
[17:47:52.876] plan(): nbrOfWorkers() = 1
[17:47:52.877] plan(): Setting new future strategy stack:
[17:47:52.877] List of future strategies:
[17:47:52.877] 1. sequential:
[17:47:52.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.877]    - tweaked: FALSE
[17:47:52.877]    - call: plan(strategy)
[17:47:52.877] plan(): nbrOfWorkers() = 1
[17:47:52.878] SequentialFuture started (and completed)
[17:47:52.878] - Launch lazy future ... done
[17:47:52.878] run() for ‘SequentialFuture’ ... done
[17:47:52.880] resolve() on environment ...
[17:47:52.880]  recursive: 0
[17:47:52.881]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:47:52.881] resolved() for ‘SequentialFuture’ ...
[17:47:52.881] - state: ‘finished’
[17:47:52.881] - run: TRUE
[17:47:52.881] - result: ‘FutureResult’
[17:47:52.881] resolved() for ‘SequentialFuture’ ... done
[17:47:52.881] Future #1
[17:47:52.881]  length: 2 (resolved future 1)
[17:47:52.881] resolved() for ‘SequentialFuture’ ...
[17:47:52.881] - state: ‘finished’
[17:47:52.882] - run: TRUE
[17:47:52.882] - result: ‘FutureResult’
[17:47:52.882] resolved() for ‘SequentialFuture’ ... done
[17:47:52.882] Future #2
[17:47:52.882]  length: 1 (resolved future 2)
[17:47:52.882]  length: 0 (resolved future 3)
[17:47:52.882] resolve() on environment ... DONE
[17:47:52.882] getGlobalsAndPackages() ...
[17:47:52.883] Searching for globals...
[17:47:52.883] - globals found: [1] ‘{’
[17:47:52.883] Searching for globals ... DONE
[17:47:52.883] Resolving globals: FALSE
[17:47:52.884] 
[17:47:52.884] 
[17:47:52.884] getGlobalsAndPackages() ... DONE
[17:47:52.884] run() for ‘Future’ ...
[17:47:52.884] - state: ‘created’
[17:47:52.884] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.884] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.885]   - Field: ‘label’
[17:47:52.885]   - Field: ‘local’
[17:47:52.885]   - Field: ‘owner’
[17:47:52.885]   - Field: ‘envir’
[17:47:52.885]   - Field: ‘packages’
[17:47:52.885]   - Field: ‘gc’
[17:47:52.885]   - Field: ‘conditions’
[17:47:52.885]   - Field: ‘expr’
[17:47:52.885]   - Field: ‘uuid’
[17:47:52.885]   - Field: ‘seed’
[17:47:52.886]   - Field: ‘version’
[17:47:52.886]   - Field: ‘result’
[17:47:52.886]   - Field: ‘asynchronous’
[17:47:52.886]   - Field: ‘calls’
[17:47:52.886]   - Field: ‘globals’
[17:47:52.886]   - Field: ‘stdout’
[17:47:52.886]   - Field: ‘earlySignal’
[17:47:52.886]   - Field: ‘lazy’
[17:47:52.886]   - Field: ‘state’
[17:47:52.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.886] - Launch lazy future ...
[17:47:52.887] Packages needed by the future expression (n = 0): <none>
[17:47:52.887] Packages needed by future strategies (n = 0): <none>
[17:47:52.887] {
[17:47:52.887]     {
[17:47:52.887]         {
[17:47:52.887]             ...future.startTime <- base::Sys.time()
[17:47:52.887]             {
[17:47:52.887]                 {
[17:47:52.887]                   {
[17:47:52.887]                     base::local({
[17:47:52.887]                       has_future <- base::requireNamespace("future", 
[17:47:52.887]                         quietly = TRUE)
[17:47:52.887]                       if (has_future) {
[17:47:52.887]                         ns <- base::getNamespace("future")
[17:47:52.887]                         version <- ns[[".package"]][["version"]]
[17:47:52.887]                         if (is.null(version)) 
[17:47:52.887]                           version <- utils::packageVersion("future")
[17:47:52.887]                       }
[17:47:52.887]                       else {
[17:47:52.887]                         version <- NULL
[17:47:52.887]                       }
[17:47:52.887]                       if (!has_future || version < "1.8.0") {
[17:47:52.887]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.887]                           "", base::R.version$version.string), 
[17:47:52.887]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.887]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.887]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.887]                             "release", "version")], collapse = " "), 
[17:47:52.887]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.887]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.887]                           info)
[17:47:52.887]                         info <- base::paste(info, collapse = "; ")
[17:47:52.887]                         if (!has_future) {
[17:47:52.887]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.887]                             info)
[17:47:52.887]                         }
[17:47:52.887]                         else {
[17:47:52.887]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.887]                             info, version)
[17:47:52.887]                         }
[17:47:52.887]                         base::stop(msg)
[17:47:52.887]                       }
[17:47:52.887]                     })
[17:47:52.887]                   }
[17:47:52.887]                   ...future.strategy.old <- future::plan("list")
[17:47:52.887]                   options(future.plan = NULL)
[17:47:52.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.887]                 }
[17:47:52.887]                 ...future.workdir <- getwd()
[17:47:52.887]             }
[17:47:52.887]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.887]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.887]         }
[17:47:52.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.887]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.887]             base::names(...future.oldOptions))
[17:47:52.887]     }
[17:47:52.887]     if (FALSE) {
[17:47:52.887]     }
[17:47:52.887]     else {
[17:47:52.887]         if (TRUE) {
[17:47:52.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.887]                 open = "w")
[17:47:52.887]         }
[17:47:52.887]         else {
[17:47:52.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.887]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.887]         }
[17:47:52.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.887]             base::sink(type = "output", split = FALSE)
[17:47:52.887]             base::close(...future.stdout)
[17:47:52.887]         }, add = TRUE)
[17:47:52.887]     }
[17:47:52.887]     ...future.frame <- base::sys.nframe()
[17:47:52.887]     ...future.conditions <- base::list()
[17:47:52.887]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.887]     if (FALSE) {
[17:47:52.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.887]     }
[17:47:52.887]     ...future.result <- base::tryCatch({
[17:47:52.887]         base::withCallingHandlers({
[17:47:52.887]             ...future.value <- base::withVisible(base::local({
[17:47:52.887]                 1
[17:47:52.887]             }))
[17:47:52.887]             future::FutureResult(value = ...future.value$value, 
[17:47:52.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.887]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.887]                     ...future.globalenv.names))
[17:47:52.887]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.887]         }, condition = base::local({
[17:47:52.887]             c <- base::c
[17:47:52.887]             inherits <- base::inherits
[17:47:52.887]             invokeRestart <- base::invokeRestart
[17:47:52.887]             length <- base::length
[17:47:52.887]             list <- base::list
[17:47:52.887]             seq.int <- base::seq.int
[17:47:52.887]             signalCondition <- base::signalCondition
[17:47:52.887]             sys.calls <- base::sys.calls
[17:47:52.887]             `[[` <- base::`[[`
[17:47:52.887]             `+` <- base::`+`
[17:47:52.887]             `<<-` <- base::`<<-`
[17:47:52.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.887]                   3L)]
[17:47:52.887]             }
[17:47:52.887]             function(cond) {
[17:47:52.887]                 is_error <- inherits(cond, "error")
[17:47:52.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.887]                   NULL)
[17:47:52.887]                 if (is_error) {
[17:47:52.887]                   sessionInformation <- function() {
[17:47:52.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.887]                       search = base::search(), system = base::Sys.info())
[17:47:52.887]                   }
[17:47:52.887]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.887]                     cond$call), session = sessionInformation(), 
[17:47:52.887]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.887]                   signalCondition(cond)
[17:47:52.887]                 }
[17:47:52.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.887]                 "immediateCondition"))) {
[17:47:52.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.887]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.887]                   if (TRUE && !signal) {
[17:47:52.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.887]                     {
[17:47:52.887]                       inherits <- base::inherits
[17:47:52.887]                       invokeRestart <- base::invokeRestart
[17:47:52.887]                       is.null <- base::is.null
[17:47:52.887]                       muffled <- FALSE
[17:47:52.887]                       if (inherits(cond, "message")) {
[17:47:52.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.887]                         if (muffled) 
[17:47:52.887]                           invokeRestart("muffleMessage")
[17:47:52.887]                       }
[17:47:52.887]                       else if (inherits(cond, "warning")) {
[17:47:52.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.887]                         if (muffled) 
[17:47:52.887]                           invokeRestart("muffleWarning")
[17:47:52.887]                       }
[17:47:52.887]                       else if (inherits(cond, "condition")) {
[17:47:52.887]                         if (!is.null(pattern)) {
[17:47:52.887]                           computeRestarts <- base::computeRestarts
[17:47:52.887]                           grepl <- base::grepl
[17:47:52.887]                           restarts <- computeRestarts(cond)
[17:47:52.887]                           for (restart in restarts) {
[17:47:52.887]                             name <- restart$name
[17:47:52.887]                             if (is.null(name)) 
[17:47:52.887]                               next
[17:47:52.887]                             if (!grepl(pattern, name)) 
[17:47:52.887]                               next
[17:47:52.887]                             invokeRestart(restart)
[17:47:52.887]                             muffled <- TRUE
[17:47:52.887]                             break
[17:47:52.887]                           }
[17:47:52.887]                         }
[17:47:52.887]                       }
[17:47:52.887]                       invisible(muffled)
[17:47:52.887]                     }
[17:47:52.887]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.887]                   }
[17:47:52.887]                 }
[17:47:52.887]                 else {
[17:47:52.887]                   if (TRUE) {
[17:47:52.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.887]                     {
[17:47:52.887]                       inherits <- base::inherits
[17:47:52.887]                       invokeRestart <- base::invokeRestart
[17:47:52.887]                       is.null <- base::is.null
[17:47:52.887]                       muffled <- FALSE
[17:47:52.887]                       if (inherits(cond, "message")) {
[17:47:52.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.887]                         if (muffled) 
[17:47:52.887]                           invokeRestart("muffleMessage")
[17:47:52.887]                       }
[17:47:52.887]                       else if (inherits(cond, "warning")) {
[17:47:52.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.887]                         if (muffled) 
[17:47:52.887]                           invokeRestart("muffleWarning")
[17:47:52.887]                       }
[17:47:52.887]                       else if (inherits(cond, "condition")) {
[17:47:52.887]                         if (!is.null(pattern)) {
[17:47:52.887]                           computeRestarts <- base::computeRestarts
[17:47:52.887]                           grepl <- base::grepl
[17:47:52.887]                           restarts <- computeRestarts(cond)
[17:47:52.887]                           for (restart in restarts) {
[17:47:52.887]                             name <- restart$name
[17:47:52.887]                             if (is.null(name)) 
[17:47:52.887]                               next
[17:47:52.887]                             if (!grepl(pattern, name)) 
[17:47:52.887]                               next
[17:47:52.887]                             invokeRestart(restart)
[17:47:52.887]                             muffled <- TRUE
[17:47:52.887]                             break
[17:47:52.887]                           }
[17:47:52.887]                         }
[17:47:52.887]                       }
[17:47:52.887]                       invisible(muffled)
[17:47:52.887]                     }
[17:47:52.887]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.887]                   }
[17:47:52.887]                 }
[17:47:52.887]             }
[17:47:52.887]         }))
[17:47:52.887]     }, error = function(ex) {
[17:47:52.887]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.887]                 ...future.rng), started = ...future.startTime, 
[17:47:52.887]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.887]             version = "1.8"), class = "FutureResult")
[17:47:52.887]     }, finally = {
[17:47:52.887]         if (!identical(...future.workdir, getwd())) 
[17:47:52.887]             setwd(...future.workdir)
[17:47:52.887]         {
[17:47:52.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.887]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.887]             }
[17:47:52.887]             base::options(...future.oldOptions)
[17:47:52.887]             if (.Platform$OS.type == "windows") {
[17:47:52.887]                 old_names <- names(...future.oldEnvVars)
[17:47:52.887]                 envs <- base::Sys.getenv()
[17:47:52.887]                 names <- names(envs)
[17:47:52.887]                 common <- intersect(names, old_names)
[17:47:52.887]                 added <- setdiff(names, old_names)
[17:47:52.887]                 removed <- setdiff(old_names, names)
[17:47:52.887]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.887]                   envs[common]]
[17:47:52.887]                 NAMES <- toupper(changed)
[17:47:52.887]                 args <- list()
[17:47:52.887]                 for (kk in seq_along(NAMES)) {
[17:47:52.887]                   name <- changed[[kk]]
[17:47:52.887]                   NAME <- NAMES[[kk]]
[17:47:52.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.887]                     next
[17:47:52.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.887]                 }
[17:47:52.887]                 NAMES <- toupper(added)
[17:47:52.887]                 for (kk in seq_along(NAMES)) {
[17:47:52.887]                   name <- added[[kk]]
[17:47:52.887]                   NAME <- NAMES[[kk]]
[17:47:52.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.887]                     next
[17:47:52.887]                   args[[name]] <- ""
[17:47:52.887]                 }
[17:47:52.887]                 NAMES <- toupper(removed)
[17:47:52.887]                 for (kk in seq_along(NAMES)) {
[17:47:52.887]                   name <- removed[[kk]]
[17:47:52.887]                   NAME <- NAMES[[kk]]
[17:47:52.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.887]                     next
[17:47:52.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.887]                 }
[17:47:52.887]                 if (length(args) > 0) 
[17:47:52.887]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.887]             }
[17:47:52.887]             else {
[17:47:52.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.887]             }
[17:47:52.887]             {
[17:47:52.887]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.887]                   0L) {
[17:47:52.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.887]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.887]                   base::options(opts)
[17:47:52.887]                 }
[17:47:52.887]                 {
[17:47:52.887]                   {
[17:47:52.887]                     NULL
[17:47:52.887]                     RNGkind("Mersenne-Twister")
[17:47:52.887]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.887]                       inherits = FALSE)
[17:47:52.887]                   }
[17:47:52.887]                   options(future.plan = NULL)
[17:47:52.887]                   if (is.na(NA_character_)) 
[17:47:52.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.887]                     .init = FALSE)
[17:47:52.887]                 }
[17:47:52.887]             }
[17:47:52.887]         }
[17:47:52.887]     })
[17:47:52.887]     if (TRUE) {
[17:47:52.887]         base::sink(type = "output", split = FALSE)
[17:47:52.887]         if (TRUE) {
[17:47:52.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.887]         }
[17:47:52.887]         else {
[17:47:52.887]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.887]         }
[17:47:52.887]         base::close(...future.stdout)
[17:47:52.887]         ...future.stdout <- NULL
[17:47:52.887]     }
[17:47:52.887]     ...future.result$conditions <- ...future.conditions
[17:47:52.887]     ...future.result$finished <- base::Sys.time()
[17:47:52.887]     ...future.result
[17:47:52.887] }
[17:47:52.889] plan(): Setting new future strategy stack:
[17:47:52.889] List of future strategies:
[17:47:52.889] 1. sequential:
[17:47:52.889]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.889]    - tweaked: FALSE
[17:47:52.889]    - call: NULL
[17:47:52.889] plan(): nbrOfWorkers() = 1
[17:47:52.890] plan(): Setting new future strategy stack:
[17:47:52.890] List of future strategies:
[17:47:52.890] 1. sequential:
[17:47:52.890]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.890]    - tweaked: FALSE
[17:47:52.890]    - call: plan(strategy)
[17:47:52.891] plan(): nbrOfWorkers() = 1
[17:47:52.891] SequentialFuture started (and completed)
[17:47:52.891] - Launch lazy future ... done
[17:47:52.891] run() for ‘SequentialFuture’ ... done
[17:47:52.891] getGlobalsAndPackages() ...
[17:47:52.891] Searching for globals...
[17:47:52.892] - globals found: [1] ‘{’
[17:47:52.892] Searching for globals ... DONE
[17:47:52.892] Resolving globals: FALSE
[17:47:52.892] 
[17:47:52.892] 
[17:47:52.892] getGlobalsAndPackages() ... DONE
[17:47:52.893] run() for ‘Future’ ...
[17:47:52.893] - state: ‘created’
[17:47:52.893] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.893] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.893] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.893]   - Field: ‘label’
[17:47:52.893]   - Field: ‘local’
[17:47:52.894]   - Field: ‘owner’
[17:47:52.894]   - Field: ‘envir’
[17:47:52.894]   - Field: ‘packages’
[17:47:52.894]   - Field: ‘gc’
[17:47:52.894]   - Field: ‘conditions’
[17:47:52.894]   - Field: ‘expr’
[17:47:52.894]   - Field: ‘uuid’
[17:47:52.894]   - Field: ‘seed’
[17:47:52.894]   - Field: ‘version’
[17:47:52.894]   - Field: ‘result’
[17:47:52.894]   - Field: ‘asynchronous’
[17:47:52.894]   - Field: ‘calls’
[17:47:52.895]   - Field: ‘globals’
[17:47:52.895]   - Field: ‘stdout’
[17:47:52.895]   - Field: ‘earlySignal’
[17:47:52.895]   - Field: ‘lazy’
[17:47:52.895]   - Field: ‘state’
[17:47:52.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.895] - Launch lazy future ...
[17:47:52.895] Packages needed by the future expression (n = 0): <none>
[17:47:52.895] Packages needed by future strategies (n = 0): <none>
[17:47:52.896] {
[17:47:52.896]     {
[17:47:52.896]         {
[17:47:52.896]             ...future.startTime <- base::Sys.time()
[17:47:52.896]             {
[17:47:52.896]                 {
[17:47:52.896]                   {
[17:47:52.896]                     base::local({
[17:47:52.896]                       has_future <- base::requireNamespace("future", 
[17:47:52.896]                         quietly = TRUE)
[17:47:52.896]                       if (has_future) {
[17:47:52.896]                         ns <- base::getNamespace("future")
[17:47:52.896]                         version <- ns[[".package"]][["version"]]
[17:47:52.896]                         if (is.null(version)) 
[17:47:52.896]                           version <- utils::packageVersion("future")
[17:47:52.896]                       }
[17:47:52.896]                       else {
[17:47:52.896]                         version <- NULL
[17:47:52.896]                       }
[17:47:52.896]                       if (!has_future || version < "1.8.0") {
[17:47:52.896]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.896]                           "", base::R.version$version.string), 
[17:47:52.896]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.896]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.896]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.896]                             "release", "version")], collapse = " "), 
[17:47:52.896]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.896]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.896]                           info)
[17:47:52.896]                         info <- base::paste(info, collapse = "; ")
[17:47:52.896]                         if (!has_future) {
[17:47:52.896]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.896]                             info)
[17:47:52.896]                         }
[17:47:52.896]                         else {
[17:47:52.896]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.896]                             info, version)
[17:47:52.896]                         }
[17:47:52.896]                         base::stop(msg)
[17:47:52.896]                       }
[17:47:52.896]                     })
[17:47:52.896]                   }
[17:47:52.896]                   ...future.strategy.old <- future::plan("list")
[17:47:52.896]                   options(future.plan = NULL)
[17:47:52.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.896]                 }
[17:47:52.896]                 ...future.workdir <- getwd()
[17:47:52.896]             }
[17:47:52.896]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.896]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.896]         }
[17:47:52.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.896]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.896]             base::names(...future.oldOptions))
[17:47:52.896]     }
[17:47:52.896]     if (FALSE) {
[17:47:52.896]     }
[17:47:52.896]     else {
[17:47:52.896]         if (TRUE) {
[17:47:52.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.896]                 open = "w")
[17:47:52.896]         }
[17:47:52.896]         else {
[17:47:52.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.896]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.896]         }
[17:47:52.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.896]             base::sink(type = "output", split = FALSE)
[17:47:52.896]             base::close(...future.stdout)
[17:47:52.896]         }, add = TRUE)
[17:47:52.896]     }
[17:47:52.896]     ...future.frame <- base::sys.nframe()
[17:47:52.896]     ...future.conditions <- base::list()
[17:47:52.896]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.896]     if (FALSE) {
[17:47:52.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.896]     }
[17:47:52.896]     ...future.result <- base::tryCatch({
[17:47:52.896]         base::withCallingHandlers({
[17:47:52.896]             ...future.value <- base::withVisible(base::local({
[17:47:52.896]                 2
[17:47:52.896]             }))
[17:47:52.896]             future::FutureResult(value = ...future.value$value, 
[17:47:52.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.896]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.896]                     ...future.globalenv.names))
[17:47:52.896]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.896]         }, condition = base::local({
[17:47:52.896]             c <- base::c
[17:47:52.896]             inherits <- base::inherits
[17:47:52.896]             invokeRestart <- base::invokeRestart
[17:47:52.896]             length <- base::length
[17:47:52.896]             list <- base::list
[17:47:52.896]             seq.int <- base::seq.int
[17:47:52.896]             signalCondition <- base::signalCondition
[17:47:52.896]             sys.calls <- base::sys.calls
[17:47:52.896]             `[[` <- base::`[[`
[17:47:52.896]             `+` <- base::`+`
[17:47:52.896]             `<<-` <- base::`<<-`
[17:47:52.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.896]                   3L)]
[17:47:52.896]             }
[17:47:52.896]             function(cond) {
[17:47:52.896]                 is_error <- inherits(cond, "error")
[17:47:52.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.896]                   NULL)
[17:47:52.896]                 if (is_error) {
[17:47:52.896]                   sessionInformation <- function() {
[17:47:52.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.896]                       search = base::search(), system = base::Sys.info())
[17:47:52.896]                   }
[17:47:52.896]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.896]                     cond$call), session = sessionInformation(), 
[17:47:52.896]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.896]                   signalCondition(cond)
[17:47:52.896]                 }
[17:47:52.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.896]                 "immediateCondition"))) {
[17:47:52.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.896]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.896]                   if (TRUE && !signal) {
[17:47:52.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.896]                     {
[17:47:52.896]                       inherits <- base::inherits
[17:47:52.896]                       invokeRestart <- base::invokeRestart
[17:47:52.896]                       is.null <- base::is.null
[17:47:52.896]                       muffled <- FALSE
[17:47:52.896]                       if (inherits(cond, "message")) {
[17:47:52.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.896]                         if (muffled) 
[17:47:52.896]                           invokeRestart("muffleMessage")
[17:47:52.896]                       }
[17:47:52.896]                       else if (inherits(cond, "warning")) {
[17:47:52.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.896]                         if (muffled) 
[17:47:52.896]                           invokeRestart("muffleWarning")
[17:47:52.896]                       }
[17:47:52.896]                       else if (inherits(cond, "condition")) {
[17:47:52.896]                         if (!is.null(pattern)) {
[17:47:52.896]                           computeRestarts <- base::computeRestarts
[17:47:52.896]                           grepl <- base::grepl
[17:47:52.896]                           restarts <- computeRestarts(cond)
[17:47:52.896]                           for (restart in restarts) {
[17:47:52.896]                             name <- restart$name
[17:47:52.896]                             if (is.null(name)) 
[17:47:52.896]                               next
[17:47:52.896]                             if (!grepl(pattern, name)) 
[17:47:52.896]                               next
[17:47:52.896]                             invokeRestart(restart)
[17:47:52.896]                             muffled <- TRUE
[17:47:52.896]                             break
[17:47:52.896]                           }
[17:47:52.896]                         }
[17:47:52.896]                       }
[17:47:52.896]                       invisible(muffled)
[17:47:52.896]                     }
[17:47:52.896]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.896]                   }
[17:47:52.896]                 }
[17:47:52.896]                 else {
[17:47:52.896]                   if (TRUE) {
[17:47:52.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.896]                     {
[17:47:52.896]                       inherits <- base::inherits
[17:47:52.896]                       invokeRestart <- base::invokeRestart
[17:47:52.896]                       is.null <- base::is.null
[17:47:52.896]                       muffled <- FALSE
[17:47:52.896]                       if (inherits(cond, "message")) {
[17:47:52.896]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.896]                         if (muffled) 
[17:47:52.896]                           invokeRestart("muffleMessage")
[17:47:52.896]                       }
[17:47:52.896]                       else if (inherits(cond, "warning")) {
[17:47:52.896]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.896]                         if (muffled) 
[17:47:52.896]                           invokeRestart("muffleWarning")
[17:47:52.896]                       }
[17:47:52.896]                       else if (inherits(cond, "condition")) {
[17:47:52.896]                         if (!is.null(pattern)) {
[17:47:52.896]                           computeRestarts <- base::computeRestarts
[17:47:52.896]                           grepl <- base::grepl
[17:47:52.896]                           restarts <- computeRestarts(cond)
[17:47:52.896]                           for (restart in restarts) {
[17:47:52.896]                             name <- restart$name
[17:47:52.896]                             if (is.null(name)) 
[17:47:52.896]                               next
[17:47:52.896]                             if (!grepl(pattern, name)) 
[17:47:52.896]                               next
[17:47:52.896]                             invokeRestart(restart)
[17:47:52.896]                             muffled <- TRUE
[17:47:52.896]                             break
[17:47:52.896]                           }
[17:47:52.896]                         }
[17:47:52.896]                       }
[17:47:52.896]                       invisible(muffled)
[17:47:52.896]                     }
[17:47:52.896]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.896]                   }
[17:47:52.896]                 }
[17:47:52.896]             }
[17:47:52.896]         }))
[17:47:52.896]     }, error = function(ex) {
[17:47:52.896]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.896]                 ...future.rng), started = ...future.startTime, 
[17:47:52.896]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.896]             version = "1.8"), class = "FutureResult")
[17:47:52.896]     }, finally = {
[17:47:52.896]         if (!identical(...future.workdir, getwd())) 
[17:47:52.896]             setwd(...future.workdir)
[17:47:52.896]         {
[17:47:52.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.896]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.896]             }
[17:47:52.896]             base::options(...future.oldOptions)
[17:47:52.896]             if (.Platform$OS.type == "windows") {
[17:47:52.896]                 old_names <- names(...future.oldEnvVars)
[17:47:52.896]                 envs <- base::Sys.getenv()
[17:47:52.896]                 names <- names(envs)
[17:47:52.896]                 common <- intersect(names, old_names)
[17:47:52.896]                 added <- setdiff(names, old_names)
[17:47:52.896]                 removed <- setdiff(old_names, names)
[17:47:52.896]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.896]                   envs[common]]
[17:47:52.896]                 NAMES <- toupper(changed)
[17:47:52.896]                 args <- list()
[17:47:52.896]                 for (kk in seq_along(NAMES)) {
[17:47:52.896]                   name <- changed[[kk]]
[17:47:52.896]                   NAME <- NAMES[[kk]]
[17:47:52.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.896]                     next
[17:47:52.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.896]                 }
[17:47:52.896]                 NAMES <- toupper(added)
[17:47:52.896]                 for (kk in seq_along(NAMES)) {
[17:47:52.896]                   name <- added[[kk]]
[17:47:52.896]                   NAME <- NAMES[[kk]]
[17:47:52.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.896]                     next
[17:47:52.896]                   args[[name]] <- ""
[17:47:52.896]                 }
[17:47:52.896]                 NAMES <- toupper(removed)
[17:47:52.896]                 for (kk in seq_along(NAMES)) {
[17:47:52.896]                   name <- removed[[kk]]
[17:47:52.896]                   NAME <- NAMES[[kk]]
[17:47:52.896]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.896]                     next
[17:47:52.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.896]                 }
[17:47:52.896]                 if (length(args) > 0) 
[17:47:52.896]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.896]             }
[17:47:52.896]             else {
[17:47:52.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.896]             }
[17:47:52.896]             {
[17:47:52.896]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.896]                   0L) {
[17:47:52.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.896]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.896]                   base::options(opts)
[17:47:52.896]                 }
[17:47:52.896]                 {
[17:47:52.896]                   {
[17:47:52.896]                     NULL
[17:47:52.896]                     RNGkind("Mersenne-Twister")
[17:47:52.896]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.896]                       inherits = FALSE)
[17:47:52.896]                   }
[17:47:52.896]                   options(future.plan = NULL)
[17:47:52.896]                   if (is.na(NA_character_)) 
[17:47:52.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.896]                     .init = FALSE)
[17:47:52.896]                 }
[17:47:52.896]             }
[17:47:52.896]         }
[17:47:52.896]     })
[17:47:52.896]     if (TRUE) {
[17:47:52.896]         base::sink(type = "output", split = FALSE)
[17:47:52.896]         if (TRUE) {
[17:47:52.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.896]         }
[17:47:52.896]         else {
[17:47:52.896]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.896]         }
[17:47:52.896]         base::close(...future.stdout)
[17:47:52.896]         ...future.stdout <- NULL
[17:47:52.896]     }
[17:47:52.896]     ...future.result$conditions <- ...future.conditions
[17:47:52.896]     ...future.result$finished <- base::Sys.time()
[17:47:52.896]     ...future.result
[17:47:52.896] }
[17:47:52.897] plan(): Setting new future strategy stack:
[17:47:52.898] List of future strategies:
[17:47:52.898] 1. sequential:
[17:47:52.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.898]    - tweaked: FALSE
[17:47:52.898]    - call: NULL
[17:47:52.898] plan(): nbrOfWorkers() = 1
[17:47:52.899] plan(): Setting new future strategy stack:
[17:47:52.899] List of future strategies:
[17:47:52.899] 1. sequential:
[17:47:52.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.899]    - tweaked: FALSE
[17:47:52.899]    - call: plan(strategy)
[17:47:52.899] plan(): nbrOfWorkers() = 1
[17:47:52.899] SequentialFuture started (and completed)
[17:47:52.900] - Launch lazy future ... done
[17:47:52.900] run() for ‘SequentialFuture’ ... done
[17:47:52.900] resolve() on environment ...
[17:47:52.900]  recursive: 0
[17:47:52.901]  elements: [3] ‘a’
[17:47:52.901] resolved() for ‘SequentialFuture’ ...
[17:47:52.901] - state: ‘finished’
[17:47:52.901] - run: TRUE
[17:47:52.901] - result: ‘FutureResult’
[17:47:52.901] resolved() for ‘SequentialFuture’ ... done
[17:47:52.901] Future #1
[17:47:52.901]  length: 2 (resolved future 1)
[17:47:52.901] resolved() for ‘SequentialFuture’ ...
[17:47:52.902] - state: ‘finished’
[17:47:52.902] - run: TRUE
[17:47:52.902] - result: ‘FutureResult’
[17:47:52.902] resolved() for ‘SequentialFuture’ ... done
[17:47:52.902] Future #2
[17:47:52.902]  length: 1 (resolved future 2)
[17:47:52.902]  length: 0 (resolved future 3)
[17:47:52.902] resolve() on environment ... DONE
[17:47:52.902] resolved() for ‘SequentialFuture’ ...
[17:47:52.902] - state: ‘finished’
[17:47:52.902] - run: TRUE
[17:47:52.903] - result: ‘FutureResult’
[17:47:52.903] resolved() for ‘SequentialFuture’ ... done
[17:47:52.903] resolve() on environment ...
[17:47:52.903]  recursive: 0
[17:47:52.904]  elements: [3] ‘b’
[17:47:52.904] resolved() for ‘SequentialFuture’ ...
[17:47:52.904] - state: ‘finished’
[17:47:52.904] - run: TRUE
[17:47:52.904] - result: ‘FutureResult’
[17:47:52.904] resolved() for ‘SequentialFuture’ ... done
[17:47:52.904] Future #1
[17:47:52.904]  length: 2 (resolved future 1)
[17:47:52.904] resolved() for ‘SequentialFuture’ ...
[17:47:52.904] - state: ‘finished’
[17:47:52.905] - run: TRUE
[17:47:52.905] - result: ‘FutureResult’
[17:47:52.905] resolved() for ‘SequentialFuture’ ... done
[17:47:52.905] Future #2
[17:47:52.905]  length: 1 (resolved future 2)
[17:47:52.905]  length: 0 (resolved future 3)
[17:47:52.905] resolve() on environment ... DONE
[17:47:52.907] resolve() on environment ...
[17:47:52.907]  recursive: 0
[17:47:52.907]  elements: [3] ‘c’
[17:47:52.908] resolved() for ‘SequentialFuture’ ...
[17:47:52.908] - state: ‘finished’
[17:47:52.908] - run: TRUE
[17:47:52.908] - result: ‘FutureResult’
[17:47:52.908] resolved() for ‘SequentialFuture’ ... done
[17:47:52.908] Future #1
[17:47:52.908]  length: 2 (resolved future 1)
[17:47:52.908] resolved() for ‘SequentialFuture’ ...
[17:47:52.908] - state: ‘finished’
[17:47:52.908] - run: TRUE
[17:47:52.909] - result: ‘FutureResult’
[17:47:52.909] resolved() for ‘SequentialFuture’ ... done
[17:47:52.909] Future #2
[17:47:52.909]  length: 1 (resolved future 2)
[17:47:52.909]  length: 0 (resolved future 3)
[17:47:52.909] resolve() on environment ... DONE
[17:47:52.909] resolve() on environment ...
[17:47:52.910]  recursive: 0
[17:47:52.910]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:47:52.910] resolved() for ‘SequentialFuture’ ...
[17:47:52.910] - state: ‘finished’
[17:47:52.910] - run: TRUE
[17:47:52.910] - result: ‘FutureResult’
[17:47:52.910] resolved() for ‘SequentialFuture’ ... done
[17:47:52.911] Future #1
[17:47:52.911]  length: 2 (resolved future 1)
[17:47:52.911] resolved() for ‘SequentialFuture’ ...
[17:47:52.911] - state: ‘finished’
[17:47:52.911] - run: TRUE
[17:47:52.911] - result: ‘FutureResult’
[17:47:52.911] resolved() for ‘SequentialFuture’ ... done
[17:47:52.912] Future #2
[17:47:52.912]  length: 1 (resolved future 2)
[17:47:52.912]  length: 0 (resolved future 3)
[17:47:52.912] resolve() on environment ... DONE
[17:47:52.912] resolve() on environment ...
[17:47:52.912]  recursive: 99
[17:47:52.913]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:47:52.913] resolved() for ‘SequentialFuture’ ...
[17:47:52.913] - state: ‘finished’
[17:47:52.913] - run: TRUE
[17:47:52.913] - result: ‘FutureResult’
[17:47:52.913] resolved() for ‘SequentialFuture’ ... done
[17:47:52.913] Future #1
[17:47:52.914] resolved() for ‘SequentialFuture’ ...
[17:47:52.914] - state: ‘finished’
[17:47:52.914] - run: TRUE
[17:47:52.914] - result: ‘FutureResult’
[17:47:52.914] resolved() for ‘SequentialFuture’ ... done
[17:47:52.914] A SequentialFuture was resolved
[17:47:52.914]  length: 2 (resolved future 1)
[17:47:52.914] resolved() for ‘SequentialFuture’ ...
[17:47:52.914] - state: ‘finished’
[17:47:52.914] - run: TRUE
[17:47:52.914] - result: ‘FutureResult’
[17:47:52.915] resolved() for ‘SequentialFuture’ ... done
[17:47:52.915] Future #2
[17:47:52.915] resolved() for ‘SequentialFuture’ ...
[17:47:52.915] - state: ‘finished’
[17:47:52.915] - run: TRUE
[17:47:52.915] - result: ‘FutureResult’
[17:47:52.915] resolved() for ‘SequentialFuture’ ... done
[17:47:52.915] A SequentialFuture was resolved
[17:47:52.915]  length: 1 (resolved future 2)
[17:47:52.915]  length: 0 (resolved future 3)
[17:47:52.916] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:47:52.917] resolve() on list environment ...
[17:47:52.917]  recursive: 0
[17:47:52.917]  length: 2
[17:47:52.918]  elements: ‘a’, ‘b’
[17:47:52.918]  length: 1 (resolved future 1)
[17:47:52.918]  length: 0 (resolved future 2)
[17:47:52.918] resolve() on list environment ... DONE
[17:47:52.918] getGlobalsAndPackages() ...
[17:47:52.918] Searching for globals...
[17:47:52.918] 
[17:47:52.918] Searching for globals ... DONE
[17:47:52.919] - globals: [0] <none>
[17:47:52.919] getGlobalsAndPackages() ... DONE
[17:47:52.919] run() for ‘Future’ ...
[17:47:52.919] - state: ‘created’
[17:47:52.919] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.919] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.920]   - Field: ‘label’
[17:47:52.920]   - Field: ‘local’
[17:47:52.920]   - Field: ‘owner’
[17:47:52.920]   - Field: ‘envir’
[17:47:52.920]   - Field: ‘packages’
[17:47:52.920]   - Field: ‘gc’
[17:47:52.920]   - Field: ‘conditions’
[17:47:52.920]   - Field: ‘expr’
[17:47:52.920]   - Field: ‘uuid’
[17:47:52.920]   - Field: ‘seed’
[17:47:52.920]   - Field: ‘version’
[17:47:52.921]   - Field: ‘result’
[17:47:52.921]   - Field: ‘asynchronous’
[17:47:52.921]   - Field: ‘calls’
[17:47:52.921]   - Field: ‘globals’
[17:47:52.921]   - Field: ‘stdout’
[17:47:52.921]   - Field: ‘earlySignal’
[17:47:52.921]   - Field: ‘lazy’
[17:47:52.921]   - Field: ‘state’
[17:47:52.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.921] - Launch lazy future ...
[17:47:52.921] Packages needed by the future expression (n = 0): <none>
[17:47:52.922] Packages needed by future strategies (n = 0): <none>
[17:47:52.922] {
[17:47:52.922]     {
[17:47:52.922]         {
[17:47:52.922]             ...future.startTime <- base::Sys.time()
[17:47:52.922]             {
[17:47:52.922]                 {
[17:47:52.922]                   {
[17:47:52.922]                     base::local({
[17:47:52.922]                       has_future <- base::requireNamespace("future", 
[17:47:52.922]                         quietly = TRUE)
[17:47:52.922]                       if (has_future) {
[17:47:52.922]                         ns <- base::getNamespace("future")
[17:47:52.922]                         version <- ns[[".package"]][["version"]]
[17:47:52.922]                         if (is.null(version)) 
[17:47:52.922]                           version <- utils::packageVersion("future")
[17:47:52.922]                       }
[17:47:52.922]                       else {
[17:47:52.922]                         version <- NULL
[17:47:52.922]                       }
[17:47:52.922]                       if (!has_future || version < "1.8.0") {
[17:47:52.922]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.922]                           "", base::R.version$version.string), 
[17:47:52.922]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.922]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.922]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.922]                             "release", "version")], collapse = " "), 
[17:47:52.922]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.922]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.922]                           info)
[17:47:52.922]                         info <- base::paste(info, collapse = "; ")
[17:47:52.922]                         if (!has_future) {
[17:47:52.922]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.922]                             info)
[17:47:52.922]                         }
[17:47:52.922]                         else {
[17:47:52.922]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.922]                             info, version)
[17:47:52.922]                         }
[17:47:52.922]                         base::stop(msg)
[17:47:52.922]                       }
[17:47:52.922]                     })
[17:47:52.922]                   }
[17:47:52.922]                   ...future.strategy.old <- future::plan("list")
[17:47:52.922]                   options(future.plan = NULL)
[17:47:52.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.922]                 }
[17:47:52.922]                 ...future.workdir <- getwd()
[17:47:52.922]             }
[17:47:52.922]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.922]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.922]         }
[17:47:52.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.922]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.922]             base::names(...future.oldOptions))
[17:47:52.922]     }
[17:47:52.922]     if (FALSE) {
[17:47:52.922]     }
[17:47:52.922]     else {
[17:47:52.922]         if (TRUE) {
[17:47:52.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.922]                 open = "w")
[17:47:52.922]         }
[17:47:52.922]         else {
[17:47:52.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.922]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.922]         }
[17:47:52.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.922]             base::sink(type = "output", split = FALSE)
[17:47:52.922]             base::close(...future.stdout)
[17:47:52.922]         }, add = TRUE)
[17:47:52.922]     }
[17:47:52.922]     ...future.frame <- base::sys.nframe()
[17:47:52.922]     ...future.conditions <- base::list()
[17:47:52.922]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.922]     if (FALSE) {
[17:47:52.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.922]     }
[17:47:52.922]     ...future.result <- base::tryCatch({
[17:47:52.922]         base::withCallingHandlers({
[17:47:52.922]             ...future.value <- base::withVisible(base::local(1))
[17:47:52.922]             future::FutureResult(value = ...future.value$value, 
[17:47:52.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.922]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.922]                     ...future.globalenv.names))
[17:47:52.922]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.922]         }, condition = base::local({
[17:47:52.922]             c <- base::c
[17:47:52.922]             inherits <- base::inherits
[17:47:52.922]             invokeRestart <- base::invokeRestart
[17:47:52.922]             length <- base::length
[17:47:52.922]             list <- base::list
[17:47:52.922]             seq.int <- base::seq.int
[17:47:52.922]             signalCondition <- base::signalCondition
[17:47:52.922]             sys.calls <- base::sys.calls
[17:47:52.922]             `[[` <- base::`[[`
[17:47:52.922]             `+` <- base::`+`
[17:47:52.922]             `<<-` <- base::`<<-`
[17:47:52.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.922]                   3L)]
[17:47:52.922]             }
[17:47:52.922]             function(cond) {
[17:47:52.922]                 is_error <- inherits(cond, "error")
[17:47:52.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.922]                   NULL)
[17:47:52.922]                 if (is_error) {
[17:47:52.922]                   sessionInformation <- function() {
[17:47:52.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.922]                       search = base::search(), system = base::Sys.info())
[17:47:52.922]                   }
[17:47:52.922]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.922]                     cond$call), session = sessionInformation(), 
[17:47:52.922]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.922]                   signalCondition(cond)
[17:47:52.922]                 }
[17:47:52.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.922]                 "immediateCondition"))) {
[17:47:52.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.922]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.922]                   if (TRUE && !signal) {
[17:47:52.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.922]                     {
[17:47:52.922]                       inherits <- base::inherits
[17:47:52.922]                       invokeRestart <- base::invokeRestart
[17:47:52.922]                       is.null <- base::is.null
[17:47:52.922]                       muffled <- FALSE
[17:47:52.922]                       if (inherits(cond, "message")) {
[17:47:52.922]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.922]                         if (muffled) 
[17:47:52.922]                           invokeRestart("muffleMessage")
[17:47:52.922]                       }
[17:47:52.922]                       else if (inherits(cond, "warning")) {
[17:47:52.922]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.922]                         if (muffled) 
[17:47:52.922]                           invokeRestart("muffleWarning")
[17:47:52.922]                       }
[17:47:52.922]                       else if (inherits(cond, "condition")) {
[17:47:52.922]                         if (!is.null(pattern)) {
[17:47:52.922]                           computeRestarts <- base::computeRestarts
[17:47:52.922]                           grepl <- base::grepl
[17:47:52.922]                           restarts <- computeRestarts(cond)
[17:47:52.922]                           for (restart in restarts) {
[17:47:52.922]                             name <- restart$name
[17:47:52.922]                             if (is.null(name)) 
[17:47:52.922]                               next
[17:47:52.922]                             if (!grepl(pattern, name)) 
[17:47:52.922]                               next
[17:47:52.922]                             invokeRestart(restart)
[17:47:52.922]                             muffled <- TRUE
[17:47:52.922]                             break
[17:47:52.922]                           }
[17:47:52.922]                         }
[17:47:52.922]                       }
[17:47:52.922]                       invisible(muffled)
[17:47:52.922]                     }
[17:47:52.922]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.922]                   }
[17:47:52.922]                 }
[17:47:52.922]                 else {
[17:47:52.922]                   if (TRUE) {
[17:47:52.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.922]                     {
[17:47:52.922]                       inherits <- base::inherits
[17:47:52.922]                       invokeRestart <- base::invokeRestart
[17:47:52.922]                       is.null <- base::is.null
[17:47:52.922]                       muffled <- FALSE
[17:47:52.922]                       if (inherits(cond, "message")) {
[17:47:52.922]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.922]                         if (muffled) 
[17:47:52.922]                           invokeRestart("muffleMessage")
[17:47:52.922]                       }
[17:47:52.922]                       else if (inherits(cond, "warning")) {
[17:47:52.922]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.922]                         if (muffled) 
[17:47:52.922]                           invokeRestart("muffleWarning")
[17:47:52.922]                       }
[17:47:52.922]                       else if (inherits(cond, "condition")) {
[17:47:52.922]                         if (!is.null(pattern)) {
[17:47:52.922]                           computeRestarts <- base::computeRestarts
[17:47:52.922]                           grepl <- base::grepl
[17:47:52.922]                           restarts <- computeRestarts(cond)
[17:47:52.922]                           for (restart in restarts) {
[17:47:52.922]                             name <- restart$name
[17:47:52.922]                             if (is.null(name)) 
[17:47:52.922]                               next
[17:47:52.922]                             if (!grepl(pattern, name)) 
[17:47:52.922]                               next
[17:47:52.922]                             invokeRestart(restart)
[17:47:52.922]                             muffled <- TRUE
[17:47:52.922]                             break
[17:47:52.922]                           }
[17:47:52.922]                         }
[17:47:52.922]                       }
[17:47:52.922]                       invisible(muffled)
[17:47:52.922]                     }
[17:47:52.922]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.922]                   }
[17:47:52.922]                 }
[17:47:52.922]             }
[17:47:52.922]         }))
[17:47:52.922]     }, error = function(ex) {
[17:47:52.922]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.922]                 ...future.rng), started = ...future.startTime, 
[17:47:52.922]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.922]             version = "1.8"), class = "FutureResult")
[17:47:52.922]     }, finally = {
[17:47:52.922]         if (!identical(...future.workdir, getwd())) 
[17:47:52.922]             setwd(...future.workdir)
[17:47:52.922]         {
[17:47:52.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.922]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.922]             }
[17:47:52.922]             base::options(...future.oldOptions)
[17:47:52.922]             if (.Platform$OS.type == "windows") {
[17:47:52.922]                 old_names <- names(...future.oldEnvVars)
[17:47:52.922]                 envs <- base::Sys.getenv()
[17:47:52.922]                 names <- names(envs)
[17:47:52.922]                 common <- intersect(names, old_names)
[17:47:52.922]                 added <- setdiff(names, old_names)
[17:47:52.922]                 removed <- setdiff(old_names, names)
[17:47:52.922]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.922]                   envs[common]]
[17:47:52.922]                 NAMES <- toupper(changed)
[17:47:52.922]                 args <- list()
[17:47:52.922]                 for (kk in seq_along(NAMES)) {
[17:47:52.922]                   name <- changed[[kk]]
[17:47:52.922]                   NAME <- NAMES[[kk]]
[17:47:52.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.922]                     next
[17:47:52.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.922]                 }
[17:47:52.922]                 NAMES <- toupper(added)
[17:47:52.922]                 for (kk in seq_along(NAMES)) {
[17:47:52.922]                   name <- added[[kk]]
[17:47:52.922]                   NAME <- NAMES[[kk]]
[17:47:52.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.922]                     next
[17:47:52.922]                   args[[name]] <- ""
[17:47:52.922]                 }
[17:47:52.922]                 NAMES <- toupper(removed)
[17:47:52.922]                 for (kk in seq_along(NAMES)) {
[17:47:52.922]                   name <- removed[[kk]]
[17:47:52.922]                   NAME <- NAMES[[kk]]
[17:47:52.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.922]                     next
[17:47:52.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.922]                 }
[17:47:52.922]                 if (length(args) > 0) 
[17:47:52.922]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.922]             }
[17:47:52.922]             else {
[17:47:52.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.922]             }
[17:47:52.922]             {
[17:47:52.922]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.922]                   0L) {
[17:47:52.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.922]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.922]                   base::options(opts)
[17:47:52.922]                 }
[17:47:52.922]                 {
[17:47:52.922]                   {
[17:47:52.922]                     NULL
[17:47:52.922]                     RNGkind("Mersenne-Twister")
[17:47:52.922]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.922]                       inherits = FALSE)
[17:47:52.922]                   }
[17:47:52.922]                   options(future.plan = NULL)
[17:47:52.922]                   if (is.na(NA_character_)) 
[17:47:52.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.922]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.922]                     .init = FALSE)
[17:47:52.922]                 }
[17:47:52.922]             }
[17:47:52.922]         }
[17:47:52.922]     })
[17:47:52.922]     if (TRUE) {
[17:47:52.922]         base::sink(type = "output", split = FALSE)
[17:47:52.922]         if (TRUE) {
[17:47:52.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.922]         }
[17:47:52.922]         else {
[17:47:52.922]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.922]         }
[17:47:52.922]         base::close(...future.stdout)
[17:47:52.922]         ...future.stdout <- NULL
[17:47:52.922]     }
[17:47:52.922]     ...future.result$conditions <- ...future.conditions
[17:47:52.922]     ...future.result$finished <- base::Sys.time()
[17:47:52.922]     ...future.result
[17:47:52.922] }
[17:47:52.924] plan(): Setting new future strategy stack:
[17:47:52.924] List of future strategies:
[17:47:52.924] 1. sequential:
[17:47:52.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.924]    - tweaked: FALSE
[17:47:52.924]    - call: NULL
[17:47:52.924] plan(): nbrOfWorkers() = 1
[17:47:52.925] plan(): Setting new future strategy stack:
[17:47:52.925] List of future strategies:
[17:47:52.925] 1. sequential:
[17:47:52.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.925]    - tweaked: FALSE
[17:47:52.925]    - call: plan(strategy)
[17:47:52.925] plan(): nbrOfWorkers() = 1
[17:47:52.926] SequentialFuture started (and completed)
[17:47:52.926] - Launch lazy future ... done
[17:47:52.926] run() for ‘SequentialFuture’ ... done
[17:47:52.926] getGlobalsAndPackages() ...
[17:47:52.926] Searching for globals...
[17:47:52.926] 
[17:47:52.926] Searching for globals ... DONE
[17:47:52.926] - globals: [0] <none>
[17:47:52.927] getGlobalsAndPackages() ... DONE
[17:47:52.927] run() for ‘Future’ ...
[17:47:52.927] - state: ‘created’
[17:47:52.927] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.927] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.927] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.927]   - Field: ‘label’
[17:47:52.927]   - Field: ‘local’
[17:47:52.928]   - Field: ‘owner’
[17:47:52.928]   - Field: ‘envir’
[17:47:52.928]   - Field: ‘packages’
[17:47:52.928]   - Field: ‘gc’
[17:47:52.928]   - Field: ‘conditions’
[17:47:52.928]   - Field: ‘expr’
[17:47:52.928]   - Field: ‘uuid’
[17:47:52.928]   - Field: ‘seed’
[17:47:52.928]   - Field: ‘version’
[17:47:52.928]   - Field: ‘result’
[17:47:52.928]   - Field: ‘asynchronous’
[17:47:52.929]   - Field: ‘calls’
[17:47:52.929]   - Field: ‘globals’
[17:47:52.929]   - Field: ‘stdout’
[17:47:52.929]   - Field: ‘earlySignal’
[17:47:52.929]   - Field: ‘lazy’
[17:47:52.929]   - Field: ‘state’
[17:47:52.929] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.929] - Launch lazy future ...
[17:47:52.929] Packages needed by the future expression (n = 0): <none>
[17:47:52.929] Packages needed by future strategies (n = 0): <none>
[17:47:52.930] {
[17:47:52.930]     {
[17:47:52.930]         {
[17:47:52.930]             ...future.startTime <- base::Sys.time()
[17:47:52.930]             {
[17:47:52.930]                 {
[17:47:52.930]                   {
[17:47:52.930]                     base::local({
[17:47:52.930]                       has_future <- base::requireNamespace("future", 
[17:47:52.930]                         quietly = TRUE)
[17:47:52.930]                       if (has_future) {
[17:47:52.930]                         ns <- base::getNamespace("future")
[17:47:52.930]                         version <- ns[[".package"]][["version"]]
[17:47:52.930]                         if (is.null(version)) 
[17:47:52.930]                           version <- utils::packageVersion("future")
[17:47:52.930]                       }
[17:47:52.930]                       else {
[17:47:52.930]                         version <- NULL
[17:47:52.930]                       }
[17:47:52.930]                       if (!has_future || version < "1.8.0") {
[17:47:52.930]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.930]                           "", base::R.version$version.string), 
[17:47:52.930]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.930]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.930]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.930]                             "release", "version")], collapse = " "), 
[17:47:52.930]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.930]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.930]                           info)
[17:47:52.930]                         info <- base::paste(info, collapse = "; ")
[17:47:52.930]                         if (!has_future) {
[17:47:52.930]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.930]                             info)
[17:47:52.930]                         }
[17:47:52.930]                         else {
[17:47:52.930]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.930]                             info, version)
[17:47:52.930]                         }
[17:47:52.930]                         base::stop(msg)
[17:47:52.930]                       }
[17:47:52.930]                     })
[17:47:52.930]                   }
[17:47:52.930]                   ...future.strategy.old <- future::plan("list")
[17:47:52.930]                   options(future.plan = NULL)
[17:47:52.930]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.930]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.930]                 }
[17:47:52.930]                 ...future.workdir <- getwd()
[17:47:52.930]             }
[17:47:52.930]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.930]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.930]         }
[17:47:52.930]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.930]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.930]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.930]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.930]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.930]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.930]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.930]             base::names(...future.oldOptions))
[17:47:52.930]     }
[17:47:52.930]     if (FALSE) {
[17:47:52.930]     }
[17:47:52.930]     else {
[17:47:52.930]         if (TRUE) {
[17:47:52.930]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.930]                 open = "w")
[17:47:52.930]         }
[17:47:52.930]         else {
[17:47:52.930]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.930]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.930]         }
[17:47:52.930]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.930]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.930]             base::sink(type = "output", split = FALSE)
[17:47:52.930]             base::close(...future.stdout)
[17:47:52.930]         }, add = TRUE)
[17:47:52.930]     }
[17:47:52.930]     ...future.frame <- base::sys.nframe()
[17:47:52.930]     ...future.conditions <- base::list()
[17:47:52.930]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.930]     if (FALSE) {
[17:47:52.930]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.930]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.930]     }
[17:47:52.930]     ...future.result <- base::tryCatch({
[17:47:52.930]         base::withCallingHandlers({
[17:47:52.930]             ...future.value <- base::withVisible(base::local(2))
[17:47:52.930]             future::FutureResult(value = ...future.value$value, 
[17:47:52.930]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.930]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.930]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.930]                     ...future.globalenv.names))
[17:47:52.930]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.930]         }, condition = base::local({
[17:47:52.930]             c <- base::c
[17:47:52.930]             inherits <- base::inherits
[17:47:52.930]             invokeRestart <- base::invokeRestart
[17:47:52.930]             length <- base::length
[17:47:52.930]             list <- base::list
[17:47:52.930]             seq.int <- base::seq.int
[17:47:52.930]             signalCondition <- base::signalCondition
[17:47:52.930]             sys.calls <- base::sys.calls
[17:47:52.930]             `[[` <- base::`[[`
[17:47:52.930]             `+` <- base::`+`
[17:47:52.930]             `<<-` <- base::`<<-`
[17:47:52.930]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.930]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.930]                   3L)]
[17:47:52.930]             }
[17:47:52.930]             function(cond) {
[17:47:52.930]                 is_error <- inherits(cond, "error")
[17:47:52.930]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.930]                   NULL)
[17:47:52.930]                 if (is_error) {
[17:47:52.930]                   sessionInformation <- function() {
[17:47:52.930]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.930]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.930]                       search = base::search(), system = base::Sys.info())
[17:47:52.930]                   }
[17:47:52.930]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.930]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.930]                     cond$call), session = sessionInformation(), 
[17:47:52.930]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.930]                   signalCondition(cond)
[17:47:52.930]                 }
[17:47:52.930]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.930]                 "immediateCondition"))) {
[17:47:52.930]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.930]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.930]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.930]                   if (TRUE && !signal) {
[17:47:52.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.930]                     {
[17:47:52.930]                       inherits <- base::inherits
[17:47:52.930]                       invokeRestart <- base::invokeRestart
[17:47:52.930]                       is.null <- base::is.null
[17:47:52.930]                       muffled <- FALSE
[17:47:52.930]                       if (inherits(cond, "message")) {
[17:47:52.930]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.930]                         if (muffled) 
[17:47:52.930]                           invokeRestart("muffleMessage")
[17:47:52.930]                       }
[17:47:52.930]                       else if (inherits(cond, "warning")) {
[17:47:52.930]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.930]                         if (muffled) 
[17:47:52.930]                           invokeRestart("muffleWarning")
[17:47:52.930]                       }
[17:47:52.930]                       else if (inherits(cond, "condition")) {
[17:47:52.930]                         if (!is.null(pattern)) {
[17:47:52.930]                           computeRestarts <- base::computeRestarts
[17:47:52.930]                           grepl <- base::grepl
[17:47:52.930]                           restarts <- computeRestarts(cond)
[17:47:52.930]                           for (restart in restarts) {
[17:47:52.930]                             name <- restart$name
[17:47:52.930]                             if (is.null(name)) 
[17:47:52.930]                               next
[17:47:52.930]                             if (!grepl(pattern, name)) 
[17:47:52.930]                               next
[17:47:52.930]                             invokeRestart(restart)
[17:47:52.930]                             muffled <- TRUE
[17:47:52.930]                             break
[17:47:52.930]                           }
[17:47:52.930]                         }
[17:47:52.930]                       }
[17:47:52.930]                       invisible(muffled)
[17:47:52.930]                     }
[17:47:52.930]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.930]                   }
[17:47:52.930]                 }
[17:47:52.930]                 else {
[17:47:52.930]                   if (TRUE) {
[17:47:52.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.930]                     {
[17:47:52.930]                       inherits <- base::inherits
[17:47:52.930]                       invokeRestart <- base::invokeRestart
[17:47:52.930]                       is.null <- base::is.null
[17:47:52.930]                       muffled <- FALSE
[17:47:52.930]                       if (inherits(cond, "message")) {
[17:47:52.930]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.930]                         if (muffled) 
[17:47:52.930]                           invokeRestart("muffleMessage")
[17:47:52.930]                       }
[17:47:52.930]                       else if (inherits(cond, "warning")) {
[17:47:52.930]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.930]                         if (muffled) 
[17:47:52.930]                           invokeRestart("muffleWarning")
[17:47:52.930]                       }
[17:47:52.930]                       else if (inherits(cond, "condition")) {
[17:47:52.930]                         if (!is.null(pattern)) {
[17:47:52.930]                           computeRestarts <- base::computeRestarts
[17:47:52.930]                           grepl <- base::grepl
[17:47:52.930]                           restarts <- computeRestarts(cond)
[17:47:52.930]                           for (restart in restarts) {
[17:47:52.930]                             name <- restart$name
[17:47:52.930]                             if (is.null(name)) 
[17:47:52.930]                               next
[17:47:52.930]                             if (!grepl(pattern, name)) 
[17:47:52.930]                               next
[17:47:52.930]                             invokeRestart(restart)
[17:47:52.930]                             muffled <- TRUE
[17:47:52.930]                             break
[17:47:52.930]                           }
[17:47:52.930]                         }
[17:47:52.930]                       }
[17:47:52.930]                       invisible(muffled)
[17:47:52.930]                     }
[17:47:52.930]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.930]                   }
[17:47:52.930]                 }
[17:47:52.930]             }
[17:47:52.930]         }))
[17:47:52.930]     }, error = function(ex) {
[17:47:52.930]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.930]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.930]                 ...future.rng), started = ...future.startTime, 
[17:47:52.930]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.930]             version = "1.8"), class = "FutureResult")
[17:47:52.930]     }, finally = {
[17:47:52.930]         if (!identical(...future.workdir, getwd())) 
[17:47:52.930]             setwd(...future.workdir)
[17:47:52.930]         {
[17:47:52.930]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.930]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.930]             }
[17:47:52.930]             base::options(...future.oldOptions)
[17:47:52.930]             if (.Platform$OS.type == "windows") {
[17:47:52.930]                 old_names <- names(...future.oldEnvVars)
[17:47:52.930]                 envs <- base::Sys.getenv()
[17:47:52.930]                 names <- names(envs)
[17:47:52.930]                 common <- intersect(names, old_names)
[17:47:52.930]                 added <- setdiff(names, old_names)
[17:47:52.930]                 removed <- setdiff(old_names, names)
[17:47:52.930]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.930]                   envs[common]]
[17:47:52.930]                 NAMES <- toupper(changed)
[17:47:52.930]                 args <- list()
[17:47:52.930]                 for (kk in seq_along(NAMES)) {
[17:47:52.930]                   name <- changed[[kk]]
[17:47:52.930]                   NAME <- NAMES[[kk]]
[17:47:52.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.930]                     next
[17:47:52.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.930]                 }
[17:47:52.930]                 NAMES <- toupper(added)
[17:47:52.930]                 for (kk in seq_along(NAMES)) {
[17:47:52.930]                   name <- added[[kk]]
[17:47:52.930]                   NAME <- NAMES[[kk]]
[17:47:52.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.930]                     next
[17:47:52.930]                   args[[name]] <- ""
[17:47:52.930]                 }
[17:47:52.930]                 NAMES <- toupper(removed)
[17:47:52.930]                 for (kk in seq_along(NAMES)) {
[17:47:52.930]                   name <- removed[[kk]]
[17:47:52.930]                   NAME <- NAMES[[kk]]
[17:47:52.930]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.930]                     next
[17:47:52.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.930]                 }
[17:47:52.930]                 if (length(args) > 0) 
[17:47:52.930]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.930]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.930]             }
[17:47:52.930]             else {
[17:47:52.930]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.930]             }
[17:47:52.930]             {
[17:47:52.930]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.930]                   0L) {
[17:47:52.930]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.930]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.930]                   base::options(opts)
[17:47:52.930]                 }
[17:47:52.930]                 {
[17:47:52.930]                   {
[17:47:52.930]                     NULL
[17:47:52.930]                     RNGkind("Mersenne-Twister")
[17:47:52.930]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.930]                       inherits = FALSE)
[17:47:52.930]                   }
[17:47:52.930]                   options(future.plan = NULL)
[17:47:52.930]                   if (is.na(NA_character_)) 
[17:47:52.930]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.930]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.930]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.930]                     .init = FALSE)
[17:47:52.930]                 }
[17:47:52.930]             }
[17:47:52.930]         }
[17:47:52.930]     })
[17:47:52.930]     if (TRUE) {
[17:47:52.930]         base::sink(type = "output", split = FALSE)
[17:47:52.930]         if (TRUE) {
[17:47:52.930]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.930]         }
[17:47:52.930]         else {
[17:47:52.930]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.930]         }
[17:47:52.930]         base::close(...future.stdout)
[17:47:52.930]         ...future.stdout <- NULL
[17:47:52.930]     }
[17:47:52.930]     ...future.result$conditions <- ...future.conditions
[17:47:52.930]     ...future.result$finished <- base::Sys.time()
[17:47:52.930]     ...future.result
[17:47:52.930] }
[17:47:52.932] plan(): Setting new future strategy stack:
[17:47:52.932] List of future strategies:
[17:47:52.932] 1. sequential:
[17:47:52.932]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.932]    - tweaked: FALSE
[17:47:52.932]    - call: NULL
[17:47:52.932] plan(): nbrOfWorkers() = 1
[17:47:52.934] plan(): Setting new future strategy stack:
[17:47:52.934] List of future strategies:
[17:47:52.934] 1. sequential:
[17:47:52.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.934]    - tweaked: FALSE
[17:47:52.934]    - call: plan(strategy)
[17:47:52.935] plan(): nbrOfWorkers() = 1
[17:47:52.935] SequentialFuture started (and completed)
[17:47:52.935] - Launch lazy future ... done
[17:47:52.935] run() for ‘SequentialFuture’ ... done
[17:47:52.936] resolve() on list environment ...
[17:47:52.936]  recursive: 0
[17:47:52.936]  length: 3
[17:47:52.936]  elements: ‘a’, ‘b’, ‘c’
[17:47:52.937] resolved() for ‘SequentialFuture’ ...
[17:47:52.937] - state: ‘finished’
[17:47:52.937] - run: TRUE
[17:47:52.937] - result: ‘FutureResult’
[17:47:52.937] resolved() for ‘SequentialFuture’ ... done
[17:47:52.937] Future #1
[17:47:52.937]  length: 2 (resolved future 1)
[17:47:52.937] resolved() for ‘SequentialFuture’ ...
[17:47:52.937] - state: ‘finished’
[17:47:52.938] - run: TRUE
[17:47:52.938] - result: ‘FutureResult’
[17:47:52.938] resolved() for ‘SequentialFuture’ ... done
[17:47:52.938] Future #2
[17:47:52.938]  length: 1 (resolved future 2)
[17:47:52.938]  length: 0 (resolved future 3)
[17:47:52.938] resolve() on list environment ... DONE
[17:47:52.939] getGlobalsAndPackages() ...
[17:47:52.939] Searching for globals...
[17:47:52.939] - globals found: [1] ‘{’
[17:47:52.940] Searching for globals ... DONE
[17:47:52.940] Resolving globals: FALSE
[17:47:52.940] 
[17:47:52.940] 
[17:47:52.940] getGlobalsAndPackages() ... DONE
[17:47:52.940] run() for ‘Future’ ...
[17:47:52.940] - state: ‘created’
[17:47:52.941] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.941]   - Field: ‘label’
[17:47:52.941]   - Field: ‘local’
[17:47:52.941]   - Field: ‘owner’
[17:47:52.941]   - Field: ‘envir’
[17:47:52.941]   - Field: ‘packages’
[17:47:52.941]   - Field: ‘gc’
[17:47:52.942]   - Field: ‘conditions’
[17:47:52.942]   - Field: ‘expr’
[17:47:52.942]   - Field: ‘uuid’
[17:47:52.942]   - Field: ‘seed’
[17:47:52.942]   - Field: ‘version’
[17:47:52.942]   - Field: ‘result’
[17:47:52.942]   - Field: ‘asynchronous’
[17:47:52.942]   - Field: ‘calls’
[17:47:52.942]   - Field: ‘globals’
[17:47:52.942]   - Field: ‘stdout’
[17:47:52.942]   - Field: ‘earlySignal’
[17:47:52.942]   - Field: ‘lazy’
[17:47:52.943]   - Field: ‘state’
[17:47:52.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.943] - Launch lazy future ...
[17:47:52.943] Packages needed by the future expression (n = 0): <none>
[17:47:52.943] Packages needed by future strategies (n = 0): <none>
[17:47:52.943] {
[17:47:52.943]     {
[17:47:52.943]         {
[17:47:52.943]             ...future.startTime <- base::Sys.time()
[17:47:52.943]             {
[17:47:52.943]                 {
[17:47:52.943]                   {
[17:47:52.943]                     base::local({
[17:47:52.943]                       has_future <- base::requireNamespace("future", 
[17:47:52.943]                         quietly = TRUE)
[17:47:52.943]                       if (has_future) {
[17:47:52.943]                         ns <- base::getNamespace("future")
[17:47:52.943]                         version <- ns[[".package"]][["version"]]
[17:47:52.943]                         if (is.null(version)) 
[17:47:52.943]                           version <- utils::packageVersion("future")
[17:47:52.943]                       }
[17:47:52.943]                       else {
[17:47:52.943]                         version <- NULL
[17:47:52.943]                       }
[17:47:52.943]                       if (!has_future || version < "1.8.0") {
[17:47:52.943]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.943]                           "", base::R.version$version.string), 
[17:47:52.943]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.943]                             "release", "version")], collapse = " "), 
[17:47:52.943]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.943]                           info)
[17:47:52.943]                         info <- base::paste(info, collapse = "; ")
[17:47:52.943]                         if (!has_future) {
[17:47:52.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.943]                             info)
[17:47:52.943]                         }
[17:47:52.943]                         else {
[17:47:52.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.943]                             info, version)
[17:47:52.943]                         }
[17:47:52.943]                         base::stop(msg)
[17:47:52.943]                       }
[17:47:52.943]                     })
[17:47:52.943]                   }
[17:47:52.943]                   ...future.strategy.old <- future::plan("list")
[17:47:52.943]                   options(future.plan = NULL)
[17:47:52.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.943]                 }
[17:47:52.943]                 ...future.workdir <- getwd()
[17:47:52.943]             }
[17:47:52.943]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.943]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.943]         }
[17:47:52.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.943]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.943]             base::names(...future.oldOptions))
[17:47:52.943]     }
[17:47:52.943]     if (FALSE) {
[17:47:52.943]     }
[17:47:52.943]     else {
[17:47:52.943]         if (TRUE) {
[17:47:52.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.943]                 open = "w")
[17:47:52.943]         }
[17:47:52.943]         else {
[17:47:52.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.943]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.943]         }
[17:47:52.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.943]             base::sink(type = "output", split = FALSE)
[17:47:52.943]             base::close(...future.stdout)
[17:47:52.943]         }, add = TRUE)
[17:47:52.943]     }
[17:47:52.943]     ...future.frame <- base::sys.nframe()
[17:47:52.943]     ...future.conditions <- base::list()
[17:47:52.943]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.943]     if (FALSE) {
[17:47:52.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.943]     }
[17:47:52.943]     ...future.result <- base::tryCatch({
[17:47:52.943]         base::withCallingHandlers({
[17:47:52.943]             ...future.value <- base::withVisible(base::local({
[17:47:52.943]                 1
[17:47:52.943]             }))
[17:47:52.943]             future::FutureResult(value = ...future.value$value, 
[17:47:52.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.943]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.943]                     ...future.globalenv.names))
[17:47:52.943]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.943]         }, condition = base::local({
[17:47:52.943]             c <- base::c
[17:47:52.943]             inherits <- base::inherits
[17:47:52.943]             invokeRestart <- base::invokeRestart
[17:47:52.943]             length <- base::length
[17:47:52.943]             list <- base::list
[17:47:52.943]             seq.int <- base::seq.int
[17:47:52.943]             signalCondition <- base::signalCondition
[17:47:52.943]             sys.calls <- base::sys.calls
[17:47:52.943]             `[[` <- base::`[[`
[17:47:52.943]             `+` <- base::`+`
[17:47:52.943]             `<<-` <- base::`<<-`
[17:47:52.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.943]                   3L)]
[17:47:52.943]             }
[17:47:52.943]             function(cond) {
[17:47:52.943]                 is_error <- inherits(cond, "error")
[17:47:52.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.943]                   NULL)
[17:47:52.943]                 if (is_error) {
[17:47:52.943]                   sessionInformation <- function() {
[17:47:52.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.943]                       search = base::search(), system = base::Sys.info())
[17:47:52.943]                   }
[17:47:52.943]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.943]                     cond$call), session = sessionInformation(), 
[17:47:52.943]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.943]                   signalCondition(cond)
[17:47:52.943]                 }
[17:47:52.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.943]                 "immediateCondition"))) {
[17:47:52.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.943]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.943]                   if (TRUE && !signal) {
[17:47:52.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.943]                     {
[17:47:52.943]                       inherits <- base::inherits
[17:47:52.943]                       invokeRestart <- base::invokeRestart
[17:47:52.943]                       is.null <- base::is.null
[17:47:52.943]                       muffled <- FALSE
[17:47:52.943]                       if (inherits(cond, "message")) {
[17:47:52.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.943]                         if (muffled) 
[17:47:52.943]                           invokeRestart("muffleMessage")
[17:47:52.943]                       }
[17:47:52.943]                       else if (inherits(cond, "warning")) {
[17:47:52.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.943]                         if (muffled) 
[17:47:52.943]                           invokeRestart("muffleWarning")
[17:47:52.943]                       }
[17:47:52.943]                       else if (inherits(cond, "condition")) {
[17:47:52.943]                         if (!is.null(pattern)) {
[17:47:52.943]                           computeRestarts <- base::computeRestarts
[17:47:52.943]                           grepl <- base::grepl
[17:47:52.943]                           restarts <- computeRestarts(cond)
[17:47:52.943]                           for (restart in restarts) {
[17:47:52.943]                             name <- restart$name
[17:47:52.943]                             if (is.null(name)) 
[17:47:52.943]                               next
[17:47:52.943]                             if (!grepl(pattern, name)) 
[17:47:52.943]                               next
[17:47:52.943]                             invokeRestart(restart)
[17:47:52.943]                             muffled <- TRUE
[17:47:52.943]                             break
[17:47:52.943]                           }
[17:47:52.943]                         }
[17:47:52.943]                       }
[17:47:52.943]                       invisible(muffled)
[17:47:52.943]                     }
[17:47:52.943]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.943]                   }
[17:47:52.943]                 }
[17:47:52.943]                 else {
[17:47:52.943]                   if (TRUE) {
[17:47:52.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.943]                     {
[17:47:52.943]                       inherits <- base::inherits
[17:47:52.943]                       invokeRestart <- base::invokeRestart
[17:47:52.943]                       is.null <- base::is.null
[17:47:52.943]                       muffled <- FALSE
[17:47:52.943]                       if (inherits(cond, "message")) {
[17:47:52.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.943]                         if (muffled) 
[17:47:52.943]                           invokeRestart("muffleMessage")
[17:47:52.943]                       }
[17:47:52.943]                       else if (inherits(cond, "warning")) {
[17:47:52.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.943]                         if (muffled) 
[17:47:52.943]                           invokeRestart("muffleWarning")
[17:47:52.943]                       }
[17:47:52.943]                       else if (inherits(cond, "condition")) {
[17:47:52.943]                         if (!is.null(pattern)) {
[17:47:52.943]                           computeRestarts <- base::computeRestarts
[17:47:52.943]                           grepl <- base::grepl
[17:47:52.943]                           restarts <- computeRestarts(cond)
[17:47:52.943]                           for (restart in restarts) {
[17:47:52.943]                             name <- restart$name
[17:47:52.943]                             if (is.null(name)) 
[17:47:52.943]                               next
[17:47:52.943]                             if (!grepl(pattern, name)) 
[17:47:52.943]                               next
[17:47:52.943]                             invokeRestart(restart)
[17:47:52.943]                             muffled <- TRUE
[17:47:52.943]                             break
[17:47:52.943]                           }
[17:47:52.943]                         }
[17:47:52.943]                       }
[17:47:52.943]                       invisible(muffled)
[17:47:52.943]                     }
[17:47:52.943]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.943]                   }
[17:47:52.943]                 }
[17:47:52.943]             }
[17:47:52.943]         }))
[17:47:52.943]     }, error = function(ex) {
[17:47:52.943]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.943]                 ...future.rng), started = ...future.startTime, 
[17:47:52.943]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.943]             version = "1.8"), class = "FutureResult")
[17:47:52.943]     }, finally = {
[17:47:52.943]         if (!identical(...future.workdir, getwd())) 
[17:47:52.943]             setwd(...future.workdir)
[17:47:52.943]         {
[17:47:52.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.943]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.943]             }
[17:47:52.943]             base::options(...future.oldOptions)
[17:47:52.943]             if (.Platform$OS.type == "windows") {
[17:47:52.943]                 old_names <- names(...future.oldEnvVars)
[17:47:52.943]                 envs <- base::Sys.getenv()
[17:47:52.943]                 names <- names(envs)
[17:47:52.943]                 common <- intersect(names, old_names)
[17:47:52.943]                 added <- setdiff(names, old_names)
[17:47:52.943]                 removed <- setdiff(old_names, names)
[17:47:52.943]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.943]                   envs[common]]
[17:47:52.943]                 NAMES <- toupper(changed)
[17:47:52.943]                 args <- list()
[17:47:52.943]                 for (kk in seq_along(NAMES)) {
[17:47:52.943]                   name <- changed[[kk]]
[17:47:52.943]                   NAME <- NAMES[[kk]]
[17:47:52.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.943]                     next
[17:47:52.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.943]                 }
[17:47:52.943]                 NAMES <- toupper(added)
[17:47:52.943]                 for (kk in seq_along(NAMES)) {
[17:47:52.943]                   name <- added[[kk]]
[17:47:52.943]                   NAME <- NAMES[[kk]]
[17:47:52.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.943]                     next
[17:47:52.943]                   args[[name]] <- ""
[17:47:52.943]                 }
[17:47:52.943]                 NAMES <- toupper(removed)
[17:47:52.943]                 for (kk in seq_along(NAMES)) {
[17:47:52.943]                   name <- removed[[kk]]
[17:47:52.943]                   NAME <- NAMES[[kk]]
[17:47:52.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.943]                     next
[17:47:52.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.943]                 }
[17:47:52.943]                 if (length(args) > 0) 
[17:47:52.943]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.943]             }
[17:47:52.943]             else {
[17:47:52.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.943]             }
[17:47:52.943]             {
[17:47:52.943]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.943]                   0L) {
[17:47:52.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.943]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.943]                   base::options(opts)
[17:47:52.943]                 }
[17:47:52.943]                 {
[17:47:52.943]                   {
[17:47:52.943]                     NULL
[17:47:52.943]                     RNGkind("Mersenne-Twister")
[17:47:52.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.943]                       inherits = FALSE)
[17:47:52.943]                   }
[17:47:52.943]                   options(future.plan = NULL)
[17:47:52.943]                   if (is.na(NA_character_)) 
[17:47:52.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.943]                     .init = FALSE)
[17:47:52.943]                 }
[17:47:52.943]             }
[17:47:52.943]         }
[17:47:52.943]     })
[17:47:52.943]     if (TRUE) {
[17:47:52.943]         base::sink(type = "output", split = FALSE)
[17:47:52.943]         if (TRUE) {
[17:47:52.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.943]         }
[17:47:52.943]         else {
[17:47:52.943]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.943]         }
[17:47:52.943]         base::close(...future.stdout)
[17:47:52.943]         ...future.stdout <- NULL
[17:47:52.943]     }
[17:47:52.943]     ...future.result$conditions <- ...future.conditions
[17:47:52.943]     ...future.result$finished <- base::Sys.time()
[17:47:52.943]     ...future.result
[17:47:52.943] }
[17:47:52.945] plan(): Setting new future strategy stack:
[17:47:52.945] List of future strategies:
[17:47:52.945] 1. sequential:
[17:47:52.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.945]    - tweaked: FALSE
[17:47:52.945]    - call: NULL
[17:47:52.946] plan(): nbrOfWorkers() = 1
[17:47:52.946] plan(): Setting new future strategy stack:
[17:47:52.946] List of future strategies:
[17:47:52.946] 1. sequential:
[17:47:52.946]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.946]    - tweaked: FALSE
[17:47:52.946]    - call: plan(strategy)
[17:47:52.947] plan(): nbrOfWorkers() = 1
[17:47:52.947] SequentialFuture started (and completed)
[17:47:52.947] - Launch lazy future ... done
[17:47:52.947] run() for ‘SequentialFuture’ ... done
[17:47:52.947] getGlobalsAndPackages() ...
[17:47:52.948] Searching for globals...
[17:47:52.948] - globals found: [1] ‘{’
[17:47:52.948] Searching for globals ... DONE
[17:47:52.948] Resolving globals: FALSE
[17:47:52.949] 
[17:47:52.949] 
[17:47:52.949] getGlobalsAndPackages() ... DONE
[17:47:52.949] run() for ‘Future’ ...
[17:47:52.949] - state: ‘created’
[17:47:52.949] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.949] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.949] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.950]   - Field: ‘label’
[17:47:52.950]   - Field: ‘local’
[17:47:52.950]   - Field: ‘owner’
[17:47:52.950]   - Field: ‘envir’
[17:47:52.950]   - Field: ‘packages’
[17:47:52.950]   - Field: ‘gc’
[17:47:52.950]   - Field: ‘conditions’
[17:47:52.950]   - Field: ‘expr’
[17:47:52.950]   - Field: ‘uuid’
[17:47:52.950]   - Field: ‘seed’
[17:47:52.950]   - Field: ‘version’
[17:47:52.951]   - Field: ‘result’
[17:47:52.951]   - Field: ‘asynchronous’
[17:47:52.951]   - Field: ‘calls’
[17:47:52.951]   - Field: ‘globals’
[17:47:52.951]   - Field: ‘stdout’
[17:47:52.951]   - Field: ‘earlySignal’
[17:47:52.951]   - Field: ‘lazy’
[17:47:52.951]   - Field: ‘state’
[17:47:52.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.951] - Launch lazy future ...
[17:47:52.952] Packages needed by the future expression (n = 0): <none>
[17:47:52.952] Packages needed by future strategies (n = 0): <none>
[17:47:52.952] {
[17:47:52.952]     {
[17:47:52.952]         {
[17:47:52.952]             ...future.startTime <- base::Sys.time()
[17:47:52.952]             {
[17:47:52.952]                 {
[17:47:52.952]                   {
[17:47:52.952]                     base::local({
[17:47:52.952]                       has_future <- base::requireNamespace("future", 
[17:47:52.952]                         quietly = TRUE)
[17:47:52.952]                       if (has_future) {
[17:47:52.952]                         ns <- base::getNamespace("future")
[17:47:52.952]                         version <- ns[[".package"]][["version"]]
[17:47:52.952]                         if (is.null(version)) 
[17:47:52.952]                           version <- utils::packageVersion("future")
[17:47:52.952]                       }
[17:47:52.952]                       else {
[17:47:52.952]                         version <- NULL
[17:47:52.952]                       }
[17:47:52.952]                       if (!has_future || version < "1.8.0") {
[17:47:52.952]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.952]                           "", base::R.version$version.string), 
[17:47:52.952]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.952]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.952]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.952]                             "release", "version")], collapse = " "), 
[17:47:52.952]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.952]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.952]                           info)
[17:47:52.952]                         info <- base::paste(info, collapse = "; ")
[17:47:52.952]                         if (!has_future) {
[17:47:52.952]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.952]                             info)
[17:47:52.952]                         }
[17:47:52.952]                         else {
[17:47:52.952]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.952]                             info, version)
[17:47:52.952]                         }
[17:47:52.952]                         base::stop(msg)
[17:47:52.952]                       }
[17:47:52.952]                     })
[17:47:52.952]                   }
[17:47:52.952]                   ...future.strategy.old <- future::plan("list")
[17:47:52.952]                   options(future.plan = NULL)
[17:47:52.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.952]                 }
[17:47:52.952]                 ...future.workdir <- getwd()
[17:47:52.952]             }
[17:47:52.952]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.952]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.952]         }
[17:47:52.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.952]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.952]             base::names(...future.oldOptions))
[17:47:52.952]     }
[17:47:52.952]     if (FALSE) {
[17:47:52.952]     }
[17:47:52.952]     else {
[17:47:52.952]         if (TRUE) {
[17:47:52.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.952]                 open = "w")
[17:47:52.952]         }
[17:47:52.952]         else {
[17:47:52.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.952]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.952]         }
[17:47:52.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.952]             base::sink(type = "output", split = FALSE)
[17:47:52.952]             base::close(...future.stdout)
[17:47:52.952]         }, add = TRUE)
[17:47:52.952]     }
[17:47:52.952]     ...future.frame <- base::sys.nframe()
[17:47:52.952]     ...future.conditions <- base::list()
[17:47:52.952]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.952]     if (FALSE) {
[17:47:52.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.952]     }
[17:47:52.952]     ...future.result <- base::tryCatch({
[17:47:52.952]         base::withCallingHandlers({
[17:47:52.952]             ...future.value <- base::withVisible(base::local({
[17:47:52.952]                 2
[17:47:52.952]             }))
[17:47:52.952]             future::FutureResult(value = ...future.value$value, 
[17:47:52.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.952]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.952]                     ...future.globalenv.names))
[17:47:52.952]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.952]         }, condition = base::local({
[17:47:52.952]             c <- base::c
[17:47:52.952]             inherits <- base::inherits
[17:47:52.952]             invokeRestart <- base::invokeRestart
[17:47:52.952]             length <- base::length
[17:47:52.952]             list <- base::list
[17:47:52.952]             seq.int <- base::seq.int
[17:47:52.952]             signalCondition <- base::signalCondition
[17:47:52.952]             sys.calls <- base::sys.calls
[17:47:52.952]             `[[` <- base::`[[`
[17:47:52.952]             `+` <- base::`+`
[17:47:52.952]             `<<-` <- base::`<<-`
[17:47:52.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.952]                   3L)]
[17:47:52.952]             }
[17:47:52.952]             function(cond) {
[17:47:52.952]                 is_error <- inherits(cond, "error")
[17:47:52.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.952]                   NULL)
[17:47:52.952]                 if (is_error) {
[17:47:52.952]                   sessionInformation <- function() {
[17:47:52.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.952]                       search = base::search(), system = base::Sys.info())
[17:47:52.952]                   }
[17:47:52.952]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.952]                     cond$call), session = sessionInformation(), 
[17:47:52.952]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.952]                   signalCondition(cond)
[17:47:52.952]                 }
[17:47:52.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.952]                 "immediateCondition"))) {
[17:47:52.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.952]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.952]                   if (TRUE && !signal) {
[17:47:52.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.952]                     {
[17:47:52.952]                       inherits <- base::inherits
[17:47:52.952]                       invokeRestart <- base::invokeRestart
[17:47:52.952]                       is.null <- base::is.null
[17:47:52.952]                       muffled <- FALSE
[17:47:52.952]                       if (inherits(cond, "message")) {
[17:47:52.952]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.952]                         if (muffled) 
[17:47:52.952]                           invokeRestart("muffleMessage")
[17:47:52.952]                       }
[17:47:52.952]                       else if (inherits(cond, "warning")) {
[17:47:52.952]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.952]                         if (muffled) 
[17:47:52.952]                           invokeRestart("muffleWarning")
[17:47:52.952]                       }
[17:47:52.952]                       else if (inherits(cond, "condition")) {
[17:47:52.952]                         if (!is.null(pattern)) {
[17:47:52.952]                           computeRestarts <- base::computeRestarts
[17:47:52.952]                           grepl <- base::grepl
[17:47:52.952]                           restarts <- computeRestarts(cond)
[17:47:52.952]                           for (restart in restarts) {
[17:47:52.952]                             name <- restart$name
[17:47:52.952]                             if (is.null(name)) 
[17:47:52.952]                               next
[17:47:52.952]                             if (!grepl(pattern, name)) 
[17:47:52.952]                               next
[17:47:52.952]                             invokeRestart(restart)
[17:47:52.952]                             muffled <- TRUE
[17:47:52.952]                             break
[17:47:52.952]                           }
[17:47:52.952]                         }
[17:47:52.952]                       }
[17:47:52.952]                       invisible(muffled)
[17:47:52.952]                     }
[17:47:52.952]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.952]                   }
[17:47:52.952]                 }
[17:47:52.952]                 else {
[17:47:52.952]                   if (TRUE) {
[17:47:52.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.952]                     {
[17:47:52.952]                       inherits <- base::inherits
[17:47:52.952]                       invokeRestart <- base::invokeRestart
[17:47:52.952]                       is.null <- base::is.null
[17:47:52.952]                       muffled <- FALSE
[17:47:52.952]                       if (inherits(cond, "message")) {
[17:47:52.952]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.952]                         if (muffled) 
[17:47:52.952]                           invokeRestart("muffleMessage")
[17:47:52.952]                       }
[17:47:52.952]                       else if (inherits(cond, "warning")) {
[17:47:52.952]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.952]                         if (muffled) 
[17:47:52.952]                           invokeRestart("muffleWarning")
[17:47:52.952]                       }
[17:47:52.952]                       else if (inherits(cond, "condition")) {
[17:47:52.952]                         if (!is.null(pattern)) {
[17:47:52.952]                           computeRestarts <- base::computeRestarts
[17:47:52.952]                           grepl <- base::grepl
[17:47:52.952]                           restarts <- computeRestarts(cond)
[17:47:52.952]                           for (restart in restarts) {
[17:47:52.952]                             name <- restart$name
[17:47:52.952]                             if (is.null(name)) 
[17:47:52.952]                               next
[17:47:52.952]                             if (!grepl(pattern, name)) 
[17:47:52.952]                               next
[17:47:52.952]                             invokeRestart(restart)
[17:47:52.952]                             muffled <- TRUE
[17:47:52.952]                             break
[17:47:52.952]                           }
[17:47:52.952]                         }
[17:47:52.952]                       }
[17:47:52.952]                       invisible(muffled)
[17:47:52.952]                     }
[17:47:52.952]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.952]                   }
[17:47:52.952]                 }
[17:47:52.952]             }
[17:47:52.952]         }))
[17:47:52.952]     }, error = function(ex) {
[17:47:52.952]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.952]                 ...future.rng), started = ...future.startTime, 
[17:47:52.952]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.952]             version = "1.8"), class = "FutureResult")
[17:47:52.952]     }, finally = {
[17:47:52.952]         if (!identical(...future.workdir, getwd())) 
[17:47:52.952]             setwd(...future.workdir)
[17:47:52.952]         {
[17:47:52.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.952]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.952]             }
[17:47:52.952]             base::options(...future.oldOptions)
[17:47:52.952]             if (.Platform$OS.type == "windows") {
[17:47:52.952]                 old_names <- names(...future.oldEnvVars)
[17:47:52.952]                 envs <- base::Sys.getenv()
[17:47:52.952]                 names <- names(envs)
[17:47:52.952]                 common <- intersect(names, old_names)
[17:47:52.952]                 added <- setdiff(names, old_names)
[17:47:52.952]                 removed <- setdiff(old_names, names)
[17:47:52.952]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.952]                   envs[common]]
[17:47:52.952]                 NAMES <- toupper(changed)
[17:47:52.952]                 args <- list()
[17:47:52.952]                 for (kk in seq_along(NAMES)) {
[17:47:52.952]                   name <- changed[[kk]]
[17:47:52.952]                   NAME <- NAMES[[kk]]
[17:47:52.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.952]                     next
[17:47:52.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.952]                 }
[17:47:52.952]                 NAMES <- toupper(added)
[17:47:52.952]                 for (kk in seq_along(NAMES)) {
[17:47:52.952]                   name <- added[[kk]]
[17:47:52.952]                   NAME <- NAMES[[kk]]
[17:47:52.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.952]                     next
[17:47:52.952]                   args[[name]] <- ""
[17:47:52.952]                 }
[17:47:52.952]                 NAMES <- toupper(removed)
[17:47:52.952]                 for (kk in seq_along(NAMES)) {
[17:47:52.952]                   name <- removed[[kk]]
[17:47:52.952]                   NAME <- NAMES[[kk]]
[17:47:52.952]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.952]                     next
[17:47:52.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.952]                 }
[17:47:52.952]                 if (length(args) > 0) 
[17:47:52.952]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.952]             }
[17:47:52.952]             else {
[17:47:52.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.952]             }
[17:47:52.952]             {
[17:47:52.952]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.952]                   0L) {
[17:47:52.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.952]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.952]                   base::options(opts)
[17:47:52.952]                 }
[17:47:52.952]                 {
[17:47:52.952]                   {
[17:47:52.952]                     NULL
[17:47:52.952]                     RNGkind("Mersenne-Twister")
[17:47:52.952]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.952]                       inherits = FALSE)
[17:47:52.952]                   }
[17:47:52.952]                   options(future.plan = NULL)
[17:47:52.952]                   if (is.na(NA_character_)) 
[17:47:52.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.952]                     .init = FALSE)
[17:47:52.952]                 }
[17:47:52.952]             }
[17:47:52.952]         }
[17:47:52.952]     })
[17:47:52.952]     if (TRUE) {
[17:47:52.952]         base::sink(type = "output", split = FALSE)
[17:47:52.952]         if (TRUE) {
[17:47:52.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.952]         }
[17:47:52.952]         else {
[17:47:52.952]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.952]         }
[17:47:52.952]         base::close(...future.stdout)
[17:47:52.952]         ...future.stdout <- NULL
[17:47:52.952]     }
[17:47:52.952]     ...future.result$conditions <- ...future.conditions
[17:47:52.952]     ...future.result$finished <- base::Sys.time()
[17:47:52.952]     ...future.result
[17:47:52.952] }
[17:47:52.954] plan(): Setting new future strategy stack:
[17:47:52.954] List of future strategies:
[17:47:52.954] 1. sequential:
[17:47:52.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.954]    - tweaked: FALSE
[17:47:52.954]    - call: NULL
[17:47:52.954] plan(): nbrOfWorkers() = 1
[17:47:52.955] plan(): Setting new future strategy stack:
[17:47:52.955] List of future strategies:
[17:47:52.955] 1. sequential:
[17:47:52.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.955]    - tweaked: FALSE
[17:47:52.955]    - call: plan(strategy)
[17:47:52.955] plan(): nbrOfWorkers() = 1
[17:47:52.956] SequentialFuture started (and completed)
[17:47:52.956] - Launch lazy future ... done
[17:47:52.956] run() for ‘SequentialFuture’ ... done
[17:47:52.956] resolve() on list environment ...
[17:47:52.956]  recursive: 0
[17:47:52.957]  length: 3
[17:47:52.957]  elements: ‘a’, ‘b’, ‘c’
[17:47:52.957] resolved() for ‘SequentialFuture’ ...
[17:47:52.957] - state: ‘finished’
[17:47:52.957] - run: TRUE
[17:47:52.957] - result: ‘FutureResult’
[17:47:52.957] resolved() for ‘SequentialFuture’ ... done
[17:47:52.957] Future #1
[17:47:52.958]  length: 2 (resolved future 1)
[17:47:52.958] resolved() for ‘SequentialFuture’ ...
[17:47:52.958] - state: ‘finished’
[17:47:52.958] - run: TRUE
[17:47:52.958] - result: ‘FutureResult’
[17:47:52.958] resolved() for ‘SequentialFuture’ ... done
[17:47:52.958] Future #2
[17:47:52.958]  length: 1 (resolved future 2)
[17:47:52.958]  length: 0 (resolved future 3)
[17:47:52.958] resolve() on list environment ... DONE
[17:47:52.960] getGlobalsAndPackages() ...
[17:47:52.960] Searching for globals...
[17:47:52.961] - globals found: [1] ‘{’
[17:47:52.961] Searching for globals ... DONE
[17:47:52.961] Resolving globals: FALSE
[17:47:52.961] 
[17:47:52.961] 
[17:47:52.962] getGlobalsAndPackages() ... DONE
[17:47:52.962] run() for ‘Future’ ...
[17:47:52.962] - state: ‘created’
[17:47:52.962] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.962] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.962]   - Field: ‘label’
[17:47:52.962]   - Field: ‘local’
[17:47:52.963]   - Field: ‘owner’
[17:47:52.963]   - Field: ‘envir’
[17:47:52.963]   - Field: ‘packages’
[17:47:52.963]   - Field: ‘gc’
[17:47:52.963]   - Field: ‘conditions’
[17:47:52.963]   - Field: ‘expr’
[17:47:52.963]   - Field: ‘uuid’
[17:47:52.963]   - Field: ‘seed’
[17:47:52.963]   - Field: ‘version’
[17:47:52.963]   - Field: ‘result’
[17:47:52.963]   - Field: ‘asynchronous’
[17:47:52.964]   - Field: ‘calls’
[17:47:52.964]   - Field: ‘globals’
[17:47:52.964]   - Field: ‘stdout’
[17:47:52.964]   - Field: ‘earlySignal’
[17:47:52.964]   - Field: ‘lazy’
[17:47:52.964]   - Field: ‘state’
[17:47:52.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.964] - Launch lazy future ...
[17:47:52.964] Packages needed by the future expression (n = 0): <none>
[17:47:52.964] Packages needed by future strategies (n = 0): <none>
[17:47:52.965] {
[17:47:52.965]     {
[17:47:52.965]         {
[17:47:52.965]             ...future.startTime <- base::Sys.time()
[17:47:52.965]             {
[17:47:52.965]                 {
[17:47:52.965]                   {
[17:47:52.965]                     base::local({
[17:47:52.965]                       has_future <- base::requireNamespace("future", 
[17:47:52.965]                         quietly = TRUE)
[17:47:52.965]                       if (has_future) {
[17:47:52.965]                         ns <- base::getNamespace("future")
[17:47:52.965]                         version <- ns[[".package"]][["version"]]
[17:47:52.965]                         if (is.null(version)) 
[17:47:52.965]                           version <- utils::packageVersion("future")
[17:47:52.965]                       }
[17:47:52.965]                       else {
[17:47:52.965]                         version <- NULL
[17:47:52.965]                       }
[17:47:52.965]                       if (!has_future || version < "1.8.0") {
[17:47:52.965]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.965]                           "", base::R.version$version.string), 
[17:47:52.965]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.965]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.965]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.965]                             "release", "version")], collapse = " "), 
[17:47:52.965]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.965]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.965]                           info)
[17:47:52.965]                         info <- base::paste(info, collapse = "; ")
[17:47:52.965]                         if (!has_future) {
[17:47:52.965]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.965]                             info)
[17:47:52.965]                         }
[17:47:52.965]                         else {
[17:47:52.965]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.965]                             info, version)
[17:47:52.965]                         }
[17:47:52.965]                         base::stop(msg)
[17:47:52.965]                       }
[17:47:52.965]                     })
[17:47:52.965]                   }
[17:47:52.965]                   ...future.strategy.old <- future::plan("list")
[17:47:52.965]                   options(future.plan = NULL)
[17:47:52.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.965]                 }
[17:47:52.965]                 ...future.workdir <- getwd()
[17:47:52.965]             }
[17:47:52.965]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.965]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.965]         }
[17:47:52.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.965]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.965]             base::names(...future.oldOptions))
[17:47:52.965]     }
[17:47:52.965]     if (FALSE) {
[17:47:52.965]     }
[17:47:52.965]     else {
[17:47:52.965]         if (TRUE) {
[17:47:52.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.965]                 open = "w")
[17:47:52.965]         }
[17:47:52.965]         else {
[17:47:52.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.965]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.965]         }
[17:47:52.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.965]             base::sink(type = "output", split = FALSE)
[17:47:52.965]             base::close(...future.stdout)
[17:47:52.965]         }, add = TRUE)
[17:47:52.965]     }
[17:47:52.965]     ...future.frame <- base::sys.nframe()
[17:47:52.965]     ...future.conditions <- base::list()
[17:47:52.965]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.965]     if (FALSE) {
[17:47:52.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.965]     }
[17:47:52.965]     ...future.result <- base::tryCatch({
[17:47:52.965]         base::withCallingHandlers({
[17:47:52.965]             ...future.value <- base::withVisible(base::local({
[17:47:52.965]                 1
[17:47:52.965]             }))
[17:47:52.965]             future::FutureResult(value = ...future.value$value, 
[17:47:52.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.965]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.965]                     ...future.globalenv.names))
[17:47:52.965]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.965]         }, condition = base::local({
[17:47:52.965]             c <- base::c
[17:47:52.965]             inherits <- base::inherits
[17:47:52.965]             invokeRestart <- base::invokeRestart
[17:47:52.965]             length <- base::length
[17:47:52.965]             list <- base::list
[17:47:52.965]             seq.int <- base::seq.int
[17:47:52.965]             signalCondition <- base::signalCondition
[17:47:52.965]             sys.calls <- base::sys.calls
[17:47:52.965]             `[[` <- base::`[[`
[17:47:52.965]             `+` <- base::`+`
[17:47:52.965]             `<<-` <- base::`<<-`
[17:47:52.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.965]                   3L)]
[17:47:52.965]             }
[17:47:52.965]             function(cond) {
[17:47:52.965]                 is_error <- inherits(cond, "error")
[17:47:52.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.965]                   NULL)
[17:47:52.965]                 if (is_error) {
[17:47:52.965]                   sessionInformation <- function() {
[17:47:52.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.965]                       search = base::search(), system = base::Sys.info())
[17:47:52.965]                   }
[17:47:52.965]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.965]                     cond$call), session = sessionInformation(), 
[17:47:52.965]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.965]                   signalCondition(cond)
[17:47:52.965]                 }
[17:47:52.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.965]                 "immediateCondition"))) {
[17:47:52.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.965]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.965]                   if (TRUE && !signal) {
[17:47:52.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.965]                     {
[17:47:52.965]                       inherits <- base::inherits
[17:47:52.965]                       invokeRestart <- base::invokeRestart
[17:47:52.965]                       is.null <- base::is.null
[17:47:52.965]                       muffled <- FALSE
[17:47:52.965]                       if (inherits(cond, "message")) {
[17:47:52.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.965]                         if (muffled) 
[17:47:52.965]                           invokeRestart("muffleMessage")
[17:47:52.965]                       }
[17:47:52.965]                       else if (inherits(cond, "warning")) {
[17:47:52.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.965]                         if (muffled) 
[17:47:52.965]                           invokeRestart("muffleWarning")
[17:47:52.965]                       }
[17:47:52.965]                       else if (inherits(cond, "condition")) {
[17:47:52.965]                         if (!is.null(pattern)) {
[17:47:52.965]                           computeRestarts <- base::computeRestarts
[17:47:52.965]                           grepl <- base::grepl
[17:47:52.965]                           restarts <- computeRestarts(cond)
[17:47:52.965]                           for (restart in restarts) {
[17:47:52.965]                             name <- restart$name
[17:47:52.965]                             if (is.null(name)) 
[17:47:52.965]                               next
[17:47:52.965]                             if (!grepl(pattern, name)) 
[17:47:52.965]                               next
[17:47:52.965]                             invokeRestart(restart)
[17:47:52.965]                             muffled <- TRUE
[17:47:52.965]                             break
[17:47:52.965]                           }
[17:47:52.965]                         }
[17:47:52.965]                       }
[17:47:52.965]                       invisible(muffled)
[17:47:52.965]                     }
[17:47:52.965]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.965]                   }
[17:47:52.965]                 }
[17:47:52.965]                 else {
[17:47:52.965]                   if (TRUE) {
[17:47:52.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.965]                     {
[17:47:52.965]                       inherits <- base::inherits
[17:47:52.965]                       invokeRestart <- base::invokeRestart
[17:47:52.965]                       is.null <- base::is.null
[17:47:52.965]                       muffled <- FALSE
[17:47:52.965]                       if (inherits(cond, "message")) {
[17:47:52.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.965]                         if (muffled) 
[17:47:52.965]                           invokeRestart("muffleMessage")
[17:47:52.965]                       }
[17:47:52.965]                       else if (inherits(cond, "warning")) {
[17:47:52.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.965]                         if (muffled) 
[17:47:52.965]                           invokeRestart("muffleWarning")
[17:47:52.965]                       }
[17:47:52.965]                       else if (inherits(cond, "condition")) {
[17:47:52.965]                         if (!is.null(pattern)) {
[17:47:52.965]                           computeRestarts <- base::computeRestarts
[17:47:52.965]                           grepl <- base::grepl
[17:47:52.965]                           restarts <- computeRestarts(cond)
[17:47:52.965]                           for (restart in restarts) {
[17:47:52.965]                             name <- restart$name
[17:47:52.965]                             if (is.null(name)) 
[17:47:52.965]                               next
[17:47:52.965]                             if (!grepl(pattern, name)) 
[17:47:52.965]                               next
[17:47:52.965]                             invokeRestart(restart)
[17:47:52.965]                             muffled <- TRUE
[17:47:52.965]                             break
[17:47:52.965]                           }
[17:47:52.965]                         }
[17:47:52.965]                       }
[17:47:52.965]                       invisible(muffled)
[17:47:52.965]                     }
[17:47:52.965]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.965]                   }
[17:47:52.965]                 }
[17:47:52.965]             }
[17:47:52.965]         }))
[17:47:52.965]     }, error = function(ex) {
[17:47:52.965]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.965]                 ...future.rng), started = ...future.startTime, 
[17:47:52.965]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.965]             version = "1.8"), class = "FutureResult")
[17:47:52.965]     }, finally = {
[17:47:52.965]         if (!identical(...future.workdir, getwd())) 
[17:47:52.965]             setwd(...future.workdir)
[17:47:52.965]         {
[17:47:52.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.965]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.965]             }
[17:47:52.965]             base::options(...future.oldOptions)
[17:47:52.965]             if (.Platform$OS.type == "windows") {
[17:47:52.965]                 old_names <- names(...future.oldEnvVars)
[17:47:52.965]                 envs <- base::Sys.getenv()
[17:47:52.965]                 names <- names(envs)
[17:47:52.965]                 common <- intersect(names, old_names)
[17:47:52.965]                 added <- setdiff(names, old_names)
[17:47:52.965]                 removed <- setdiff(old_names, names)
[17:47:52.965]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.965]                   envs[common]]
[17:47:52.965]                 NAMES <- toupper(changed)
[17:47:52.965]                 args <- list()
[17:47:52.965]                 for (kk in seq_along(NAMES)) {
[17:47:52.965]                   name <- changed[[kk]]
[17:47:52.965]                   NAME <- NAMES[[kk]]
[17:47:52.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.965]                     next
[17:47:52.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.965]                 }
[17:47:52.965]                 NAMES <- toupper(added)
[17:47:52.965]                 for (kk in seq_along(NAMES)) {
[17:47:52.965]                   name <- added[[kk]]
[17:47:52.965]                   NAME <- NAMES[[kk]]
[17:47:52.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.965]                     next
[17:47:52.965]                   args[[name]] <- ""
[17:47:52.965]                 }
[17:47:52.965]                 NAMES <- toupper(removed)
[17:47:52.965]                 for (kk in seq_along(NAMES)) {
[17:47:52.965]                   name <- removed[[kk]]
[17:47:52.965]                   NAME <- NAMES[[kk]]
[17:47:52.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.965]                     next
[17:47:52.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.965]                 }
[17:47:52.965]                 if (length(args) > 0) 
[17:47:52.965]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.965]             }
[17:47:52.965]             else {
[17:47:52.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.965]             }
[17:47:52.965]             {
[17:47:52.965]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.965]                   0L) {
[17:47:52.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.965]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.965]                   base::options(opts)
[17:47:52.965]                 }
[17:47:52.965]                 {
[17:47:52.965]                   {
[17:47:52.965]                     NULL
[17:47:52.965]                     RNGkind("Mersenne-Twister")
[17:47:52.965]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.965]                       inherits = FALSE)
[17:47:52.965]                   }
[17:47:52.965]                   options(future.plan = NULL)
[17:47:52.965]                   if (is.na(NA_character_)) 
[17:47:52.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.965]                     .init = FALSE)
[17:47:52.965]                 }
[17:47:52.965]             }
[17:47:52.965]         }
[17:47:52.965]     })
[17:47:52.965]     if (TRUE) {
[17:47:52.965]         base::sink(type = "output", split = FALSE)
[17:47:52.965]         if (TRUE) {
[17:47:52.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.965]         }
[17:47:52.965]         else {
[17:47:52.965]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.965]         }
[17:47:52.965]         base::close(...future.stdout)
[17:47:52.965]         ...future.stdout <- NULL
[17:47:52.965]     }
[17:47:52.965]     ...future.result$conditions <- ...future.conditions
[17:47:52.965]     ...future.result$finished <- base::Sys.time()
[17:47:52.965]     ...future.result
[17:47:52.965] }
[17:47:52.966] plan(): Setting new future strategy stack:
[17:47:52.967] List of future strategies:
[17:47:52.967] 1. sequential:
[17:47:52.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.967]    - tweaked: FALSE
[17:47:52.967]    - call: NULL
[17:47:52.967] plan(): nbrOfWorkers() = 1
[17:47:52.968] plan(): Setting new future strategy stack:
[17:47:52.968] List of future strategies:
[17:47:52.968] 1. sequential:
[17:47:52.968]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.968]    - tweaked: FALSE
[17:47:52.968]    - call: plan(strategy)
[17:47:52.968] plan(): nbrOfWorkers() = 1
[17:47:52.968] SequentialFuture started (and completed)
[17:47:52.968] - Launch lazy future ... done
[17:47:52.969] run() for ‘SequentialFuture’ ... done
[17:47:52.969] getGlobalsAndPackages() ...
[17:47:52.969] Searching for globals...
[17:47:52.970] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:47:52.970] Searching for globals ... DONE
[17:47:52.970] Resolving globals: FALSE
[17:47:52.970] 
[17:47:52.970] 
[17:47:52.970] getGlobalsAndPackages() ... DONE
[17:47:52.971] run() for ‘Future’ ...
[17:47:52.971] - state: ‘created’
[17:47:52.971] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:52.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:52.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:52.971]   - Field: ‘label’
[17:47:52.971]   - Field: ‘local’
[17:47:52.971]   - Field: ‘owner’
[17:47:52.972]   - Field: ‘envir’
[17:47:52.972]   - Field: ‘packages’
[17:47:52.972]   - Field: ‘gc’
[17:47:52.972]   - Field: ‘conditions’
[17:47:52.972]   - Field: ‘expr’
[17:47:52.972]   - Field: ‘uuid’
[17:47:52.972]   - Field: ‘seed’
[17:47:52.972]   - Field: ‘version’
[17:47:52.972]   - Field: ‘result’
[17:47:52.972]   - Field: ‘asynchronous’
[17:47:52.972]   - Field: ‘calls’
[17:47:52.972]   - Field: ‘globals’
[17:47:52.973]   - Field: ‘stdout’
[17:47:52.973]   - Field: ‘earlySignal’
[17:47:52.973]   - Field: ‘lazy’
[17:47:52.973]   - Field: ‘state’
[17:47:52.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:52.973] - Launch lazy future ...
[17:47:52.973] Packages needed by the future expression (n = 0): <none>
[17:47:52.973] Packages needed by future strategies (n = 0): <none>
[17:47:52.974] {
[17:47:52.974]     {
[17:47:52.974]         {
[17:47:52.974]             ...future.startTime <- base::Sys.time()
[17:47:52.974]             {
[17:47:52.974]                 {
[17:47:52.974]                   {
[17:47:52.974]                     base::local({
[17:47:52.974]                       has_future <- base::requireNamespace("future", 
[17:47:52.974]                         quietly = TRUE)
[17:47:52.974]                       if (has_future) {
[17:47:52.974]                         ns <- base::getNamespace("future")
[17:47:52.974]                         version <- ns[[".package"]][["version"]]
[17:47:52.974]                         if (is.null(version)) 
[17:47:52.974]                           version <- utils::packageVersion("future")
[17:47:52.974]                       }
[17:47:52.974]                       else {
[17:47:52.974]                         version <- NULL
[17:47:52.974]                       }
[17:47:52.974]                       if (!has_future || version < "1.8.0") {
[17:47:52.974]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:52.974]                           "", base::R.version$version.string), 
[17:47:52.974]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:52.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:52.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:52.974]                             "release", "version")], collapse = " "), 
[17:47:52.974]                           hostname = base::Sys.info()[["nodename"]])
[17:47:52.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:52.974]                           info)
[17:47:52.974]                         info <- base::paste(info, collapse = "; ")
[17:47:52.974]                         if (!has_future) {
[17:47:52.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:52.974]                             info)
[17:47:52.974]                         }
[17:47:52.974]                         else {
[17:47:52.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:52.974]                             info, version)
[17:47:52.974]                         }
[17:47:52.974]                         base::stop(msg)
[17:47:52.974]                       }
[17:47:52.974]                     })
[17:47:52.974]                   }
[17:47:52.974]                   ...future.strategy.old <- future::plan("list")
[17:47:52.974]                   options(future.plan = NULL)
[17:47:52.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:52.974]                 }
[17:47:52.974]                 ...future.workdir <- getwd()
[17:47:52.974]             }
[17:47:52.974]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:52.974]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:52.974]         }
[17:47:52.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:52.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:52.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:52.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:52.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:52.974]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:52.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:52.974]             base::names(...future.oldOptions))
[17:47:52.974]     }
[17:47:52.974]     if (FALSE) {
[17:47:52.974]     }
[17:47:52.974]     else {
[17:47:52.974]         if (TRUE) {
[17:47:52.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:52.974]                 open = "w")
[17:47:52.974]         }
[17:47:52.974]         else {
[17:47:52.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:52.974]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:52.974]         }
[17:47:52.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:52.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:52.974]             base::sink(type = "output", split = FALSE)
[17:47:52.974]             base::close(...future.stdout)
[17:47:52.974]         }, add = TRUE)
[17:47:52.974]     }
[17:47:52.974]     ...future.frame <- base::sys.nframe()
[17:47:52.974]     ...future.conditions <- base::list()
[17:47:52.974]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:52.974]     if (FALSE) {
[17:47:52.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:52.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:52.974]     }
[17:47:52.974]     ...future.result <- base::tryCatch({
[17:47:52.974]         base::withCallingHandlers({
[17:47:52.974]             ...future.value <- base::withVisible(base::local({
[17:47:52.974]                 Sys.sleep(0.5)
[17:47:52.974]                 2
[17:47:52.974]             }))
[17:47:52.974]             future::FutureResult(value = ...future.value$value, 
[17:47:52.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.974]                   ...future.rng), globalenv = if (FALSE) 
[17:47:52.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:52.974]                     ...future.globalenv.names))
[17:47:52.974]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:52.974]         }, condition = base::local({
[17:47:52.974]             c <- base::c
[17:47:52.974]             inherits <- base::inherits
[17:47:52.974]             invokeRestart <- base::invokeRestart
[17:47:52.974]             length <- base::length
[17:47:52.974]             list <- base::list
[17:47:52.974]             seq.int <- base::seq.int
[17:47:52.974]             signalCondition <- base::signalCondition
[17:47:52.974]             sys.calls <- base::sys.calls
[17:47:52.974]             `[[` <- base::`[[`
[17:47:52.974]             `+` <- base::`+`
[17:47:52.974]             `<<-` <- base::`<<-`
[17:47:52.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:52.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:52.974]                   3L)]
[17:47:52.974]             }
[17:47:52.974]             function(cond) {
[17:47:52.974]                 is_error <- inherits(cond, "error")
[17:47:52.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:52.974]                   NULL)
[17:47:52.974]                 if (is_error) {
[17:47:52.974]                   sessionInformation <- function() {
[17:47:52.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:52.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:52.974]                       search = base::search(), system = base::Sys.info())
[17:47:52.974]                   }
[17:47:52.974]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:52.974]                     cond$call), session = sessionInformation(), 
[17:47:52.974]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:52.974]                   signalCondition(cond)
[17:47:52.974]                 }
[17:47:52.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:52.974]                 "immediateCondition"))) {
[17:47:52.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:52.974]                   ...future.conditions[[length(...future.conditions) + 
[17:47:52.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:52.974]                   if (TRUE && !signal) {
[17:47:52.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.974]                     {
[17:47:52.974]                       inherits <- base::inherits
[17:47:52.974]                       invokeRestart <- base::invokeRestart
[17:47:52.974]                       is.null <- base::is.null
[17:47:52.974]                       muffled <- FALSE
[17:47:52.974]                       if (inherits(cond, "message")) {
[17:47:52.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.974]                         if (muffled) 
[17:47:52.974]                           invokeRestart("muffleMessage")
[17:47:52.974]                       }
[17:47:52.974]                       else if (inherits(cond, "warning")) {
[17:47:52.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.974]                         if (muffled) 
[17:47:52.974]                           invokeRestart("muffleWarning")
[17:47:52.974]                       }
[17:47:52.974]                       else if (inherits(cond, "condition")) {
[17:47:52.974]                         if (!is.null(pattern)) {
[17:47:52.974]                           computeRestarts <- base::computeRestarts
[17:47:52.974]                           grepl <- base::grepl
[17:47:52.974]                           restarts <- computeRestarts(cond)
[17:47:52.974]                           for (restart in restarts) {
[17:47:52.974]                             name <- restart$name
[17:47:52.974]                             if (is.null(name)) 
[17:47:52.974]                               next
[17:47:52.974]                             if (!grepl(pattern, name)) 
[17:47:52.974]                               next
[17:47:52.974]                             invokeRestart(restart)
[17:47:52.974]                             muffled <- TRUE
[17:47:52.974]                             break
[17:47:52.974]                           }
[17:47:52.974]                         }
[17:47:52.974]                       }
[17:47:52.974]                       invisible(muffled)
[17:47:52.974]                     }
[17:47:52.974]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.974]                   }
[17:47:52.974]                 }
[17:47:52.974]                 else {
[17:47:52.974]                   if (TRUE) {
[17:47:52.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:52.974]                     {
[17:47:52.974]                       inherits <- base::inherits
[17:47:52.974]                       invokeRestart <- base::invokeRestart
[17:47:52.974]                       is.null <- base::is.null
[17:47:52.974]                       muffled <- FALSE
[17:47:52.974]                       if (inherits(cond, "message")) {
[17:47:52.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:52.974]                         if (muffled) 
[17:47:52.974]                           invokeRestart("muffleMessage")
[17:47:52.974]                       }
[17:47:52.974]                       else if (inherits(cond, "warning")) {
[17:47:52.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:52.974]                         if (muffled) 
[17:47:52.974]                           invokeRestart("muffleWarning")
[17:47:52.974]                       }
[17:47:52.974]                       else if (inherits(cond, "condition")) {
[17:47:52.974]                         if (!is.null(pattern)) {
[17:47:52.974]                           computeRestarts <- base::computeRestarts
[17:47:52.974]                           grepl <- base::grepl
[17:47:52.974]                           restarts <- computeRestarts(cond)
[17:47:52.974]                           for (restart in restarts) {
[17:47:52.974]                             name <- restart$name
[17:47:52.974]                             if (is.null(name)) 
[17:47:52.974]                               next
[17:47:52.974]                             if (!grepl(pattern, name)) 
[17:47:52.974]                               next
[17:47:52.974]                             invokeRestart(restart)
[17:47:52.974]                             muffled <- TRUE
[17:47:52.974]                             break
[17:47:52.974]                           }
[17:47:52.974]                         }
[17:47:52.974]                       }
[17:47:52.974]                       invisible(muffled)
[17:47:52.974]                     }
[17:47:52.974]                     muffleCondition(cond, pattern = "^muffle")
[17:47:52.974]                   }
[17:47:52.974]                 }
[17:47:52.974]             }
[17:47:52.974]         }))
[17:47:52.974]     }, error = function(ex) {
[17:47:52.974]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:52.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:52.974]                 ...future.rng), started = ...future.startTime, 
[17:47:52.974]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:52.974]             version = "1.8"), class = "FutureResult")
[17:47:52.974]     }, finally = {
[17:47:52.974]         if (!identical(...future.workdir, getwd())) 
[17:47:52.974]             setwd(...future.workdir)
[17:47:52.974]         {
[17:47:52.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:52.974]                 ...future.oldOptions$nwarnings <- NULL
[17:47:52.974]             }
[17:47:52.974]             base::options(...future.oldOptions)
[17:47:52.974]             if (.Platform$OS.type == "windows") {
[17:47:52.974]                 old_names <- names(...future.oldEnvVars)
[17:47:52.974]                 envs <- base::Sys.getenv()
[17:47:52.974]                 names <- names(envs)
[17:47:52.974]                 common <- intersect(names, old_names)
[17:47:52.974]                 added <- setdiff(names, old_names)
[17:47:52.974]                 removed <- setdiff(old_names, names)
[17:47:52.974]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:52.974]                   envs[common]]
[17:47:52.974]                 NAMES <- toupper(changed)
[17:47:52.974]                 args <- list()
[17:47:52.974]                 for (kk in seq_along(NAMES)) {
[17:47:52.974]                   name <- changed[[kk]]
[17:47:52.974]                   NAME <- NAMES[[kk]]
[17:47:52.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.974]                     next
[17:47:52.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.974]                 }
[17:47:52.974]                 NAMES <- toupper(added)
[17:47:52.974]                 for (kk in seq_along(NAMES)) {
[17:47:52.974]                   name <- added[[kk]]
[17:47:52.974]                   NAME <- NAMES[[kk]]
[17:47:52.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.974]                     next
[17:47:52.974]                   args[[name]] <- ""
[17:47:52.974]                 }
[17:47:52.974]                 NAMES <- toupper(removed)
[17:47:52.974]                 for (kk in seq_along(NAMES)) {
[17:47:52.974]                   name <- removed[[kk]]
[17:47:52.974]                   NAME <- NAMES[[kk]]
[17:47:52.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:52.974]                     next
[17:47:52.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:52.974]                 }
[17:47:52.974]                 if (length(args) > 0) 
[17:47:52.974]                   base::do.call(base::Sys.setenv, args = args)
[17:47:52.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:52.974]             }
[17:47:52.974]             else {
[17:47:52.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:52.974]             }
[17:47:52.974]             {
[17:47:52.974]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:52.974]                   0L) {
[17:47:52.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:52.974]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:52.974]                   base::options(opts)
[17:47:52.974]                 }
[17:47:52.974]                 {
[17:47:52.974]                   {
[17:47:52.974]                     NULL
[17:47:52.974]                     RNGkind("Mersenne-Twister")
[17:47:52.974]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:52.974]                       inherits = FALSE)
[17:47:52.974]                   }
[17:47:52.974]                   options(future.plan = NULL)
[17:47:52.974]                   if (is.na(NA_character_)) 
[17:47:52.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:52.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:52.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:52.974]                     .init = FALSE)
[17:47:52.974]                 }
[17:47:52.974]             }
[17:47:52.974]         }
[17:47:52.974]     })
[17:47:52.974]     if (TRUE) {
[17:47:52.974]         base::sink(type = "output", split = FALSE)
[17:47:52.974]         if (TRUE) {
[17:47:52.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:52.974]         }
[17:47:52.974]         else {
[17:47:52.974]             ...future.result["stdout"] <- base::list(NULL)
[17:47:52.974]         }
[17:47:52.974]         base::close(...future.stdout)
[17:47:52.974]         ...future.stdout <- NULL
[17:47:52.974]     }
[17:47:52.974]     ...future.result$conditions <- ...future.conditions
[17:47:52.974]     ...future.result$finished <- base::Sys.time()
[17:47:52.974]     ...future.result
[17:47:52.974] }
[17:47:52.975] plan(): Setting new future strategy stack:
[17:47:52.975] List of future strategies:
[17:47:52.975] 1. sequential:
[17:47:52.975]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:52.975]    - tweaked: FALSE
[17:47:52.975]    - call: NULL
[17:47:52.976] plan(): nbrOfWorkers() = 1
[17:47:53.477] plan(): Setting new future strategy stack:
[17:47:53.478] List of future strategies:
[17:47:53.478] 1. sequential:
[17:47:53.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.478]    - tweaked: FALSE
[17:47:53.478]    - call: plan(strategy)
[17:47:53.478] plan(): nbrOfWorkers() = 1
[17:47:53.478] SequentialFuture started (and completed)
[17:47:53.478] - Launch lazy future ... done
[17:47:53.479] run() for ‘SequentialFuture’ ... done
[17:47:53.479] getGlobalsAndPackages() ...
[17:47:53.479] Searching for globals...
[17:47:53.480] - globals found: [1] ‘{’
[17:47:53.480] Searching for globals ... DONE
[17:47:53.480] Resolving globals: FALSE
[17:47:53.480] 
[17:47:53.480] 
[17:47:53.480] getGlobalsAndPackages() ... DONE
[17:47:53.481] run() for ‘Future’ ...
[17:47:53.481] - state: ‘created’
[17:47:53.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:47:53.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:47:53.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:47:53.481]   - Field: ‘label’
[17:47:53.481]   - Field: ‘local’
[17:47:53.482]   - Field: ‘owner’
[17:47:53.482]   - Field: ‘envir’
[17:47:53.482]   - Field: ‘packages’
[17:47:53.482]   - Field: ‘gc’
[17:47:53.482]   - Field: ‘conditions’
[17:47:53.482]   - Field: ‘expr’
[17:47:53.482]   - Field: ‘uuid’
[17:47:53.482]   - Field: ‘seed’
[17:47:53.482]   - Field: ‘version’
[17:47:53.482]   - Field: ‘result’
[17:47:53.482]   - Field: ‘asynchronous’
[17:47:53.483]   - Field: ‘calls’
[17:47:53.483]   - Field: ‘globals’
[17:47:53.483]   - Field: ‘stdout’
[17:47:53.483]   - Field: ‘earlySignal’
[17:47:53.483]   - Field: ‘lazy’
[17:47:53.483]   - Field: ‘state’
[17:47:53.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:47:53.483] - Launch lazy future ...
[17:47:53.483] Packages needed by the future expression (n = 0): <none>
[17:47:53.484] Packages needed by future strategies (n = 0): <none>
[17:47:53.484] {
[17:47:53.484]     {
[17:47:53.484]         {
[17:47:53.484]             ...future.startTime <- base::Sys.time()
[17:47:53.484]             {
[17:47:53.484]                 {
[17:47:53.484]                   {
[17:47:53.484]                     base::local({
[17:47:53.484]                       has_future <- base::requireNamespace("future", 
[17:47:53.484]                         quietly = TRUE)
[17:47:53.484]                       if (has_future) {
[17:47:53.484]                         ns <- base::getNamespace("future")
[17:47:53.484]                         version <- ns[[".package"]][["version"]]
[17:47:53.484]                         if (is.null(version)) 
[17:47:53.484]                           version <- utils::packageVersion("future")
[17:47:53.484]                       }
[17:47:53.484]                       else {
[17:47:53.484]                         version <- NULL
[17:47:53.484]                       }
[17:47:53.484]                       if (!has_future || version < "1.8.0") {
[17:47:53.484]                         info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.484]                           "", base::R.version$version.string), 
[17:47:53.484]                           platform = base::sprintf("%s (%s-bit)", 
[17:47:53.484]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.484]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.484]                             "release", "version")], collapse = " "), 
[17:47:53.484]                           hostname = base::Sys.info()[["nodename"]])
[17:47:53.484]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.484]                           info)
[17:47:53.484]                         info <- base::paste(info, collapse = "; ")
[17:47:53.484]                         if (!has_future) {
[17:47:53.484]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.484]                             info)
[17:47:53.484]                         }
[17:47:53.484]                         else {
[17:47:53.484]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.484]                             info, version)
[17:47:53.484]                         }
[17:47:53.484]                         base::stop(msg)
[17:47:53.484]                       }
[17:47:53.484]                     })
[17:47:53.484]                   }
[17:47:53.484]                   ...future.strategy.old <- future::plan("list")
[17:47:53.484]                   options(future.plan = NULL)
[17:47:53.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.484]                 }
[17:47:53.484]                 ...future.workdir <- getwd()
[17:47:53.484]             }
[17:47:53.484]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.484]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.484]         }
[17:47:53.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.484]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.484]             base::names(...future.oldOptions))
[17:47:53.484]     }
[17:47:53.484]     if (FALSE) {
[17:47:53.484]     }
[17:47:53.484]     else {
[17:47:53.484]         if (TRUE) {
[17:47:53.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.484]                 open = "w")
[17:47:53.484]         }
[17:47:53.484]         else {
[17:47:53.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.484]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.484]         }
[17:47:53.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.484]             base::sink(type = "output", split = FALSE)
[17:47:53.484]             base::close(...future.stdout)
[17:47:53.484]         }, add = TRUE)
[17:47:53.484]     }
[17:47:53.484]     ...future.frame <- base::sys.nframe()
[17:47:53.484]     ...future.conditions <- base::list()
[17:47:53.484]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.484]     if (FALSE) {
[17:47:53.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.484]     }
[17:47:53.484]     ...future.result <- base::tryCatch({
[17:47:53.484]         base::withCallingHandlers({
[17:47:53.484]             ...future.value <- base::withVisible(base::local({
[17:47:53.484]                 3
[17:47:53.484]             }))
[17:47:53.484]             future::FutureResult(value = ...future.value$value, 
[17:47:53.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.484]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.484]                     ...future.globalenv.names))
[17:47:53.484]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.484]         }, condition = base::local({
[17:47:53.484]             c <- base::c
[17:47:53.484]             inherits <- base::inherits
[17:47:53.484]             invokeRestart <- base::invokeRestart
[17:47:53.484]             length <- base::length
[17:47:53.484]             list <- base::list
[17:47:53.484]             seq.int <- base::seq.int
[17:47:53.484]             signalCondition <- base::signalCondition
[17:47:53.484]             sys.calls <- base::sys.calls
[17:47:53.484]             `[[` <- base::`[[`
[17:47:53.484]             `+` <- base::`+`
[17:47:53.484]             `<<-` <- base::`<<-`
[17:47:53.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.484]                   3L)]
[17:47:53.484]             }
[17:47:53.484]             function(cond) {
[17:47:53.484]                 is_error <- inherits(cond, "error")
[17:47:53.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.484]                   NULL)
[17:47:53.484]                 if (is_error) {
[17:47:53.484]                   sessionInformation <- function() {
[17:47:53.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.484]                       search = base::search(), system = base::Sys.info())
[17:47:53.484]                   }
[17:47:53.484]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.484]                     cond$call), session = sessionInformation(), 
[17:47:53.484]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.484]                   signalCondition(cond)
[17:47:53.484]                 }
[17:47:53.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.484]                 "immediateCondition"))) {
[17:47:53.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.484]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.484]                   if (TRUE && !signal) {
[17:47:53.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.484]                     {
[17:47:53.484]                       inherits <- base::inherits
[17:47:53.484]                       invokeRestart <- base::invokeRestart
[17:47:53.484]                       is.null <- base::is.null
[17:47:53.484]                       muffled <- FALSE
[17:47:53.484]                       if (inherits(cond, "message")) {
[17:47:53.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.484]                         if (muffled) 
[17:47:53.484]                           invokeRestart("muffleMessage")
[17:47:53.484]                       }
[17:47:53.484]                       else if (inherits(cond, "warning")) {
[17:47:53.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.484]                         if (muffled) 
[17:47:53.484]                           invokeRestart("muffleWarning")
[17:47:53.484]                       }
[17:47:53.484]                       else if (inherits(cond, "condition")) {
[17:47:53.484]                         if (!is.null(pattern)) {
[17:47:53.484]                           computeRestarts <- base::computeRestarts
[17:47:53.484]                           grepl <- base::grepl
[17:47:53.484]                           restarts <- computeRestarts(cond)
[17:47:53.484]                           for (restart in restarts) {
[17:47:53.484]                             name <- restart$name
[17:47:53.484]                             if (is.null(name)) 
[17:47:53.484]                               next
[17:47:53.484]                             if (!grepl(pattern, name)) 
[17:47:53.484]                               next
[17:47:53.484]                             invokeRestart(restart)
[17:47:53.484]                             muffled <- TRUE
[17:47:53.484]                             break
[17:47:53.484]                           }
[17:47:53.484]                         }
[17:47:53.484]                       }
[17:47:53.484]                       invisible(muffled)
[17:47:53.484]                     }
[17:47:53.484]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.484]                   }
[17:47:53.484]                 }
[17:47:53.484]                 else {
[17:47:53.484]                   if (TRUE) {
[17:47:53.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.484]                     {
[17:47:53.484]                       inherits <- base::inherits
[17:47:53.484]                       invokeRestart <- base::invokeRestart
[17:47:53.484]                       is.null <- base::is.null
[17:47:53.484]                       muffled <- FALSE
[17:47:53.484]                       if (inherits(cond, "message")) {
[17:47:53.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.484]                         if (muffled) 
[17:47:53.484]                           invokeRestart("muffleMessage")
[17:47:53.484]                       }
[17:47:53.484]                       else if (inherits(cond, "warning")) {
[17:47:53.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.484]                         if (muffled) 
[17:47:53.484]                           invokeRestart("muffleWarning")
[17:47:53.484]                       }
[17:47:53.484]                       else if (inherits(cond, "condition")) {
[17:47:53.484]                         if (!is.null(pattern)) {
[17:47:53.484]                           computeRestarts <- base::computeRestarts
[17:47:53.484]                           grepl <- base::grepl
[17:47:53.484]                           restarts <- computeRestarts(cond)
[17:47:53.484]                           for (restart in restarts) {
[17:47:53.484]                             name <- restart$name
[17:47:53.484]                             if (is.null(name)) 
[17:47:53.484]                               next
[17:47:53.484]                             if (!grepl(pattern, name)) 
[17:47:53.484]                               next
[17:47:53.484]                             invokeRestart(restart)
[17:47:53.484]                             muffled <- TRUE
[17:47:53.484]                             break
[17:47:53.484]                           }
[17:47:53.484]                         }
[17:47:53.484]                       }
[17:47:53.484]                       invisible(muffled)
[17:47:53.484]                     }
[17:47:53.484]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.484]                   }
[17:47:53.484]                 }
[17:47:53.484]             }
[17:47:53.484]         }))
[17:47:53.484]     }, error = function(ex) {
[17:47:53.484]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.484]                 ...future.rng), started = ...future.startTime, 
[17:47:53.484]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.484]             version = "1.8"), class = "FutureResult")
[17:47:53.484]     }, finally = {
[17:47:53.484]         if (!identical(...future.workdir, getwd())) 
[17:47:53.484]             setwd(...future.workdir)
[17:47:53.484]         {
[17:47:53.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.484]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.484]             }
[17:47:53.484]             base::options(...future.oldOptions)
[17:47:53.484]             if (.Platform$OS.type == "windows") {
[17:47:53.484]                 old_names <- names(...future.oldEnvVars)
[17:47:53.484]                 envs <- base::Sys.getenv()
[17:47:53.484]                 names <- names(envs)
[17:47:53.484]                 common <- intersect(names, old_names)
[17:47:53.484]                 added <- setdiff(names, old_names)
[17:47:53.484]                 removed <- setdiff(old_names, names)
[17:47:53.484]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.484]                   envs[common]]
[17:47:53.484]                 NAMES <- toupper(changed)
[17:47:53.484]                 args <- list()
[17:47:53.484]                 for (kk in seq_along(NAMES)) {
[17:47:53.484]                   name <- changed[[kk]]
[17:47:53.484]                   NAME <- NAMES[[kk]]
[17:47:53.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.484]                     next
[17:47:53.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.484]                 }
[17:47:53.484]                 NAMES <- toupper(added)
[17:47:53.484]                 for (kk in seq_along(NAMES)) {
[17:47:53.484]                   name <- added[[kk]]
[17:47:53.484]                   NAME <- NAMES[[kk]]
[17:47:53.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.484]                     next
[17:47:53.484]                   args[[name]] <- ""
[17:47:53.484]                 }
[17:47:53.484]                 NAMES <- toupper(removed)
[17:47:53.484]                 for (kk in seq_along(NAMES)) {
[17:47:53.484]                   name <- removed[[kk]]
[17:47:53.484]                   NAME <- NAMES[[kk]]
[17:47:53.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.484]                     next
[17:47:53.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.484]                 }
[17:47:53.484]                 if (length(args) > 0) 
[17:47:53.484]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.484]             }
[17:47:53.484]             else {
[17:47:53.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.484]             }
[17:47:53.484]             {
[17:47:53.484]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.484]                   0L) {
[17:47:53.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.484]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.484]                   base::options(opts)
[17:47:53.484]                 }
[17:47:53.484]                 {
[17:47:53.484]                   {
[17:47:53.484]                     NULL
[17:47:53.484]                     RNGkind("Mersenne-Twister")
[17:47:53.484]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:47:53.484]                       inherits = FALSE)
[17:47:53.484]                   }
[17:47:53.484]                   options(future.plan = NULL)
[17:47:53.484]                   if (is.na(NA_character_)) 
[17:47:53.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.484]                     .init = FALSE)
[17:47:53.484]                 }
[17:47:53.484]             }
[17:47:53.484]         }
[17:47:53.484]     })
[17:47:53.484]     if (TRUE) {
[17:47:53.484]         base::sink(type = "output", split = FALSE)
[17:47:53.484]         if (TRUE) {
[17:47:53.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.484]         }
[17:47:53.484]         else {
[17:47:53.484]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.484]         }
[17:47:53.484]         base::close(...future.stdout)
[17:47:53.484]         ...future.stdout <- NULL
[17:47:53.484]     }
[17:47:53.484]     ...future.result$conditions <- ...future.conditions
[17:47:53.484]     ...future.result$finished <- base::Sys.time()
[17:47:53.484]     ...future.result
[17:47:53.484] }
[17:47:53.486] plan(): Setting new future strategy stack:
[17:47:53.486] List of future strategies:
[17:47:53.486] 1. sequential:
[17:47:53.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.486]    - tweaked: FALSE
[17:47:53.486]    - call: NULL
[17:47:53.486] plan(): nbrOfWorkers() = 1
[17:47:53.487] plan(): Setting new future strategy stack:
[17:47:53.487] List of future strategies:
[17:47:53.487] 1. sequential:
[17:47:53.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.487]    - tweaked: FALSE
[17:47:53.487]    - call: plan(strategy)
[17:47:53.488] plan(): nbrOfWorkers() = 1
[17:47:53.488] SequentialFuture started (and completed)
[17:47:53.490] - Launch lazy future ... done
[17:47:53.490] run() for ‘SequentialFuture’ ... done
[17:47:53.491] resolve() on list environment ...
[17:47:53.491]  recursive: 0
[17:47:53.491]  length: 4
[17:47:53.492]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:53.492] resolved() for ‘SequentialFuture’ ...
[17:47:53.492] - state: ‘finished’
[17:47:53.492] - run: TRUE
[17:47:53.492] - result: ‘FutureResult’
[17:47:53.492] resolved() for ‘SequentialFuture’ ... done
[17:47:53.492] Future #1
[17:47:53.492]  length: 3 (resolved future 1)
[17:47:53.492] resolved() for ‘SequentialFuture’ ...
[17:47:53.492] - state: ‘finished’
[17:47:53.493] - run: TRUE
[17:47:53.493] - result: ‘FutureResult’
[17:47:53.493] resolved() for ‘SequentialFuture’ ... done
[17:47:53.493] Future #2
[17:47:53.493]  length: 2 (resolved future 2)
[17:47:53.493] resolved() for ‘SequentialFuture’ ...
[17:47:53.493] - state: ‘finished’
[17:47:53.493] - run: TRUE
[17:47:53.493] - result: ‘FutureResult’
[17:47:53.493] resolved() for ‘SequentialFuture’ ... done
[17:47:53.493] Future #3
[17:47:53.494]  length: 1 (resolved future 3)
[17:47:53.494]  length: 0 (resolved future 4)
[17:47:53.494] resolve() on list environment ... DONE
[17:47:53.494] resolved() for ‘SequentialFuture’ ...
[17:47:53.494] - state: ‘finished’
[17:47:53.494] - run: TRUE
[17:47:53.494] - result: ‘FutureResult’
[17:47:53.495] resolved() for ‘SequentialFuture’ ... done
[17:47:53.495] resolve() on list environment ...
[17:47:53.495]  recursive: 0
[17:47:53.495]  length: 4
[17:47:53.495]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:53.496] resolved() for ‘SequentialFuture’ ...
[17:47:53.496] - state: ‘finished’
[17:47:53.496] - run: TRUE
[17:47:53.496] - result: ‘FutureResult’
[17:47:53.496] resolved() for ‘SequentialFuture’ ... done
[17:47:53.496] Future #1
[17:47:53.496]  length: 3 (resolved future 1)
[17:47:53.496] resolved() for ‘SequentialFuture’ ...
[17:47:53.496] - state: ‘finished’
[17:47:53.496] - run: TRUE
[17:47:53.497] - result: ‘FutureResult’
[17:47:53.497] resolved() for ‘SequentialFuture’ ... done
[17:47:53.497] Future #2
[17:47:53.497]  length: 2 (resolved future 2)
[17:47:53.497] resolved() for ‘SequentialFuture’ ...
[17:47:53.497] - state: ‘finished’
[17:47:53.497] - run: TRUE
[17:47:53.497] - result: ‘FutureResult’
[17:47:53.497] resolved() for ‘SequentialFuture’ ... done
[17:47:53.497] Future #3
[17:47:53.497]  length: 1 (resolved future 3)
[17:47:53.498]  length: 0 (resolved future 4)
[17:47:53.498] resolve() on list environment ... DONE
[17:47:53.498] resolve() on list environment ...
[17:47:53.498]  recursive: 0
[17:47:53.499]  length: 4
[17:47:53.499]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:53.499] resolved() for ‘SequentialFuture’ ...
[17:47:53.499] - state: ‘finished’
[17:47:53.499] - run: TRUE
[17:47:53.499] - result: ‘FutureResult’
[17:47:53.499] resolved() for ‘SequentialFuture’ ... done
[17:47:53.500] Future #1
[17:47:53.500]  length: 3 (resolved future 1)
[17:47:53.500] resolved() for ‘SequentialFuture’ ...
[17:47:53.500] - state: ‘finished’
[17:47:53.500] - run: TRUE
[17:47:53.500] - result: ‘FutureResult’
[17:47:53.500] resolved() for ‘SequentialFuture’ ... done
[17:47:53.500] Future #2
[17:47:53.500]  length: 2 (resolved future 2)
[17:47:53.500] resolved() for ‘SequentialFuture’ ...
[17:47:53.501] - state: ‘finished’
[17:47:53.501] - run: TRUE
[17:47:53.501] - result: ‘FutureResult’
[17:47:53.501] resolved() for ‘SequentialFuture’ ... done
[17:47:53.501] Future #3
[17:47:53.501]  length: 1 (resolved future 3)
[17:47:53.501]  length: 0 (resolved future 4)
[17:47:53.501] resolve() on list environment ... DONE
[17:47:53.502] resolve() on list environment ...
[17:47:53.502]  recursive: 0
[17:47:53.502]  length: 4
[17:47:53.502]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:53.502] resolved() for ‘SequentialFuture’ ...
[17:47:53.503] - state: ‘finished’
[17:47:53.503] - run: TRUE
[17:47:53.503] - result: ‘FutureResult’
[17:47:53.503] resolved() for ‘SequentialFuture’ ... done
[17:47:53.503] Future #1
[17:47:53.503]  length: 3 (resolved future 1)
[17:47:53.503] resolved() for ‘SequentialFuture’ ...
[17:47:53.503] - state: ‘finished’
[17:47:53.503] - run: TRUE
[17:47:53.503] - result: ‘FutureResult’
[17:47:53.504] resolved() for ‘SequentialFuture’ ... done
[17:47:53.504] Future #2
[17:47:53.504]  length: 2 (resolved future 2)
[17:47:53.504] resolved() for ‘SequentialFuture’ ...
[17:47:53.504] - state: ‘finished’
[17:47:53.504] - run: TRUE
[17:47:53.504] - result: ‘FutureResult’
[17:47:53.504] resolved() for ‘SequentialFuture’ ... done
[17:47:53.504] Future #3
[17:47:53.504]  length: 1 (resolved future 3)
[17:47:53.504]  length: 0 (resolved future 4)
[17:47:53.505] resolve() on list environment ... DONE
[17:47:53.505] resolve() on list environment ...
[17:47:53.505]  recursive: 0
[17:47:53.506]  length: 4
[17:47:53.506]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:53.506] resolved() for ‘SequentialFuture’ ...
[17:47:53.506] - state: ‘finished’
[17:47:53.506] - run: TRUE
[17:47:53.506] - result: ‘FutureResult’
[17:47:53.506] resolved() for ‘SequentialFuture’ ... done
[17:47:53.506] Future #1
[17:47:53.507]  length: 3 (resolved future 1)
[17:47:53.507] resolved() for ‘SequentialFuture’ ...
[17:47:53.507] - state: ‘finished’
[17:47:53.507] - run: TRUE
[17:47:53.507] - result: ‘FutureResult’
[17:47:53.507] resolved() for ‘SequentialFuture’ ... done
[17:47:53.507] Future #2
[17:47:53.507]  length: 2 (resolved future 2)
[17:47:53.507] resolved() for ‘SequentialFuture’ ...
[17:47:53.507] - state: ‘finished’
[17:47:53.508] - run: TRUE
[17:47:53.508] - result: ‘FutureResult’
[17:47:53.508] resolved() for ‘SequentialFuture’ ... done
[17:47:53.508] Future #3
[17:47:53.508]  length: 1 (resolved future 3)
[17:47:53.508]  length: 0 (resolved future 4)
[17:47:53.508] resolve() on list environment ... DONE
[17:47:53.509] resolve() on list environment ...
[17:47:53.509]  recursive: 99
[17:47:53.509]  length: 4
[17:47:53.509]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:53.509] resolved() for ‘SequentialFuture’ ...
[17:47:53.510] - state: ‘finished’
[17:47:53.510] - run: TRUE
[17:47:53.510] - result: ‘FutureResult’
[17:47:53.510] resolved() for ‘SequentialFuture’ ... done
[17:47:53.510] Future #1
[17:47:53.511] resolved() for ‘SequentialFuture’ ...
[17:47:53.512] - state: ‘finished’
[17:47:53.512] - run: TRUE
[17:47:53.512] - result: ‘FutureResult’
[17:47:53.512] resolved() for ‘SequentialFuture’ ... done
[17:47:53.512] A SequentialFuture was resolved
[17:47:53.512]  length: 3 (resolved future 1)
[17:47:53.512] resolved() for ‘SequentialFuture’ ...
[17:47:53.512] - state: ‘finished’
[17:47:53.512] - run: TRUE
[17:47:53.512] - result: ‘FutureResult’
[17:47:53.513] resolved() for ‘SequentialFuture’ ... done
[17:47:53.513] Future #2
[17:47:53.513] resolved() for ‘SequentialFuture’ ...
[17:47:53.513] - state: ‘finished’
[17:47:53.513] - run: TRUE
[17:47:53.513] - result: ‘FutureResult’
[17:47:53.513] resolved() for ‘SequentialFuture’ ... done
[17:47:53.513] A SequentialFuture was resolved
[17:47:53.513]  length: 2 (resolved future 2)
[17:47:53.513] resolved() for ‘SequentialFuture’ ...
[17:47:53.514] - state: ‘finished’
[17:47:53.514] - run: TRUE
[17:47:53.514] - result: ‘FutureResult’
[17:47:53.514] resolved() for ‘SequentialFuture’ ... done
[17:47:53.514] Future #3
[17:47:53.514] resolved() for ‘SequentialFuture’ ...
[17:47:53.514] - state: ‘finished’
[17:47:53.514] - run: TRUE
[17:47:53.514] - result: ‘FutureResult’
[17:47:53.514] resolved() for ‘SequentialFuture’ ... done
[17:47:53.514] A SequentialFuture was resolved
[17:47:53.515]  length: 1 (resolved future 3)
[17:47:53.515]  length: 0 (resolved future 4)
[17:47:53.515] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[17:47:53.515] plan(): Setting new future strategy stack:
[17:47:53.515] List of future strategies:
[17:47:53.515] 1. multicore:
[17:47:53.515]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.515]    - tweaked: FALSE
[17:47:53.515]    - call: plan(strategy)
[17:47:53.520] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[17:47:53.520] resolve() on list ...
[17:47:53.520]  recursive: 0
[17:47:53.520]  length: 2
[17:47:53.520]  elements: ‘a’, ‘b’
[17:47:53.520]  length: 1 (resolved future 1)
[17:47:53.520]  length: 0 (resolved future 2)
[17:47:53.520] resolve() on list ... DONE
[17:47:53.520] getGlobalsAndPackages() ...
[17:47:53.521] Searching for globals...
[17:47:53.521] 
[17:47:53.521] Searching for globals ... DONE
[17:47:53.521] - globals: [0] <none>
[17:47:53.521] getGlobalsAndPackages() ... DONE
[17:47:53.521] run() for ‘Future’ ...
[17:47:53.521] - state: ‘created’
[17:47:53.522] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.525] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.525]   - Field: ‘label’
[17:47:53.525]   - Field: ‘local’
[17:47:53.525]   - Field: ‘owner’
[17:47:53.525]   - Field: ‘envir’
[17:47:53.526]   - Field: ‘workers’
[17:47:53.526]   - Field: ‘packages’
[17:47:53.526]   - Field: ‘gc’
[17:47:53.526]   - Field: ‘job’
[17:47:53.526]   - Field: ‘conditions’
[17:47:53.526]   - Field: ‘expr’
[17:47:53.526]   - Field: ‘uuid’
[17:47:53.526]   - Field: ‘seed’
[17:47:53.526]   - Field: ‘version’
[17:47:53.526]   - Field: ‘result’
[17:47:53.526]   - Field: ‘asynchronous’
[17:47:53.527]   - Field: ‘calls’
[17:47:53.527]   - Field: ‘globals’
[17:47:53.527]   - Field: ‘stdout’
[17:47:53.527]   - Field: ‘earlySignal’
[17:47:53.527]   - Field: ‘lazy’
[17:47:53.527]   - Field: ‘state’
[17:47:53.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.527] - Launch lazy future ...
[17:47:53.528] Packages needed by the future expression (n = 0): <none>
[17:47:53.528] Packages needed by future strategies (n = 0): <none>
[17:47:53.529] {
[17:47:53.529]     {
[17:47:53.529]         {
[17:47:53.529]             ...future.startTime <- base::Sys.time()
[17:47:53.529]             {
[17:47:53.529]                 {
[17:47:53.529]                   {
[17:47:53.529]                     {
[17:47:53.529]                       base::local({
[17:47:53.529]                         has_future <- base::requireNamespace("future", 
[17:47:53.529]                           quietly = TRUE)
[17:47:53.529]                         if (has_future) {
[17:47:53.529]                           ns <- base::getNamespace("future")
[17:47:53.529]                           version <- ns[[".package"]][["version"]]
[17:47:53.529]                           if (is.null(version)) 
[17:47:53.529]                             version <- utils::packageVersion("future")
[17:47:53.529]                         }
[17:47:53.529]                         else {
[17:47:53.529]                           version <- NULL
[17:47:53.529]                         }
[17:47:53.529]                         if (!has_future || version < "1.8.0") {
[17:47:53.529]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.529]                             "", base::R.version$version.string), 
[17:47:53.529]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.529]                               "release", "version")], collapse = " "), 
[17:47:53.529]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.529]                             info)
[17:47:53.529]                           info <- base::paste(info, collapse = "; ")
[17:47:53.529]                           if (!has_future) {
[17:47:53.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.529]                               info)
[17:47:53.529]                           }
[17:47:53.529]                           else {
[17:47:53.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.529]                               info, version)
[17:47:53.529]                           }
[17:47:53.529]                           base::stop(msg)
[17:47:53.529]                         }
[17:47:53.529]                       })
[17:47:53.529]                     }
[17:47:53.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.529]                     base::options(mc.cores = 1L)
[17:47:53.529]                   }
[17:47:53.529]                   ...future.strategy.old <- future::plan("list")
[17:47:53.529]                   options(future.plan = NULL)
[17:47:53.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.529]                 }
[17:47:53.529]                 ...future.workdir <- getwd()
[17:47:53.529]             }
[17:47:53.529]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.529]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.529]         }
[17:47:53.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.529]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.529]             base::names(...future.oldOptions))
[17:47:53.529]     }
[17:47:53.529]     if (FALSE) {
[17:47:53.529]     }
[17:47:53.529]     else {
[17:47:53.529]         if (TRUE) {
[17:47:53.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.529]                 open = "w")
[17:47:53.529]         }
[17:47:53.529]         else {
[17:47:53.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.529]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.529]         }
[17:47:53.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.529]             base::sink(type = "output", split = FALSE)
[17:47:53.529]             base::close(...future.stdout)
[17:47:53.529]         }, add = TRUE)
[17:47:53.529]     }
[17:47:53.529]     ...future.frame <- base::sys.nframe()
[17:47:53.529]     ...future.conditions <- base::list()
[17:47:53.529]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.529]     if (FALSE) {
[17:47:53.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.529]     }
[17:47:53.529]     ...future.result <- base::tryCatch({
[17:47:53.529]         base::withCallingHandlers({
[17:47:53.529]             ...future.value <- base::withVisible(base::local({
[17:47:53.529]                 withCallingHandlers({
[17:47:53.529]                   1
[17:47:53.529]                 }, immediateCondition = function(cond) {
[17:47:53.529]                   save_rds <- function (object, pathname, ...) 
[17:47:53.529]                   {
[17:47:53.529]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.529]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.529]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.529]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.529]                         fi_tmp[["mtime"]])
[17:47:53.529]                     }
[17:47:53.529]                     tryCatch({
[17:47:53.529]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.529]                     }, error = function(ex) {
[17:47:53.529]                       msg <- conditionMessage(ex)
[17:47:53.529]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.529]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.529]                         fi_tmp[["mtime"]], msg)
[17:47:53.529]                       ex$message <- msg
[17:47:53.529]                       stop(ex)
[17:47:53.529]                     })
[17:47:53.529]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.529]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.529]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.529]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.529]                       fi <- file.info(pathname)
[17:47:53.529]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.529]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.529]                         fi[["size"]], fi[["mtime"]])
[17:47:53.529]                       stop(msg)
[17:47:53.529]                     }
[17:47:53.529]                     invisible(pathname)
[17:47:53.529]                   }
[17:47:53.529]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.529]                     rootPath = tempdir()) 
[17:47:53.529]                   {
[17:47:53.529]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.529]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.529]                       tmpdir = path, fileext = ".rds")
[17:47:53.529]                     save_rds(obj, file)
[17:47:53.529]                   }
[17:47:53.529]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.529]                   {
[17:47:53.529]                     inherits <- base::inherits
[17:47:53.529]                     invokeRestart <- base::invokeRestart
[17:47:53.529]                     is.null <- base::is.null
[17:47:53.529]                     muffled <- FALSE
[17:47:53.529]                     if (inherits(cond, "message")) {
[17:47:53.529]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.529]                       if (muffled) 
[17:47:53.529]                         invokeRestart("muffleMessage")
[17:47:53.529]                     }
[17:47:53.529]                     else if (inherits(cond, "warning")) {
[17:47:53.529]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.529]                       if (muffled) 
[17:47:53.529]                         invokeRestart("muffleWarning")
[17:47:53.529]                     }
[17:47:53.529]                     else if (inherits(cond, "condition")) {
[17:47:53.529]                       if (!is.null(pattern)) {
[17:47:53.529]                         computeRestarts <- base::computeRestarts
[17:47:53.529]                         grepl <- base::grepl
[17:47:53.529]                         restarts <- computeRestarts(cond)
[17:47:53.529]                         for (restart in restarts) {
[17:47:53.529]                           name <- restart$name
[17:47:53.529]                           if (is.null(name)) 
[17:47:53.529]                             next
[17:47:53.529]                           if (!grepl(pattern, name)) 
[17:47:53.529]                             next
[17:47:53.529]                           invokeRestart(restart)
[17:47:53.529]                           muffled <- TRUE
[17:47:53.529]                           break
[17:47:53.529]                         }
[17:47:53.529]                       }
[17:47:53.529]                     }
[17:47:53.529]                     invisible(muffled)
[17:47:53.529]                   }
[17:47:53.529]                   muffleCondition(cond)
[17:47:53.529]                 })
[17:47:53.529]             }))
[17:47:53.529]             future::FutureResult(value = ...future.value$value, 
[17:47:53.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.529]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.529]                     ...future.globalenv.names))
[17:47:53.529]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.529]         }, condition = base::local({
[17:47:53.529]             c <- base::c
[17:47:53.529]             inherits <- base::inherits
[17:47:53.529]             invokeRestart <- base::invokeRestart
[17:47:53.529]             length <- base::length
[17:47:53.529]             list <- base::list
[17:47:53.529]             seq.int <- base::seq.int
[17:47:53.529]             signalCondition <- base::signalCondition
[17:47:53.529]             sys.calls <- base::sys.calls
[17:47:53.529]             `[[` <- base::`[[`
[17:47:53.529]             `+` <- base::`+`
[17:47:53.529]             `<<-` <- base::`<<-`
[17:47:53.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.529]                   3L)]
[17:47:53.529]             }
[17:47:53.529]             function(cond) {
[17:47:53.529]                 is_error <- inherits(cond, "error")
[17:47:53.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.529]                   NULL)
[17:47:53.529]                 if (is_error) {
[17:47:53.529]                   sessionInformation <- function() {
[17:47:53.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.529]                       search = base::search(), system = base::Sys.info())
[17:47:53.529]                   }
[17:47:53.529]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.529]                     cond$call), session = sessionInformation(), 
[17:47:53.529]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.529]                   signalCondition(cond)
[17:47:53.529]                 }
[17:47:53.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.529]                 "immediateCondition"))) {
[17:47:53.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.529]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.529]                   if (TRUE && !signal) {
[17:47:53.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.529]                     {
[17:47:53.529]                       inherits <- base::inherits
[17:47:53.529]                       invokeRestart <- base::invokeRestart
[17:47:53.529]                       is.null <- base::is.null
[17:47:53.529]                       muffled <- FALSE
[17:47:53.529]                       if (inherits(cond, "message")) {
[17:47:53.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.529]                         if (muffled) 
[17:47:53.529]                           invokeRestart("muffleMessage")
[17:47:53.529]                       }
[17:47:53.529]                       else if (inherits(cond, "warning")) {
[17:47:53.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.529]                         if (muffled) 
[17:47:53.529]                           invokeRestart("muffleWarning")
[17:47:53.529]                       }
[17:47:53.529]                       else if (inherits(cond, "condition")) {
[17:47:53.529]                         if (!is.null(pattern)) {
[17:47:53.529]                           computeRestarts <- base::computeRestarts
[17:47:53.529]                           grepl <- base::grepl
[17:47:53.529]                           restarts <- computeRestarts(cond)
[17:47:53.529]                           for (restart in restarts) {
[17:47:53.529]                             name <- restart$name
[17:47:53.529]                             if (is.null(name)) 
[17:47:53.529]                               next
[17:47:53.529]                             if (!grepl(pattern, name)) 
[17:47:53.529]                               next
[17:47:53.529]                             invokeRestart(restart)
[17:47:53.529]                             muffled <- TRUE
[17:47:53.529]                             break
[17:47:53.529]                           }
[17:47:53.529]                         }
[17:47:53.529]                       }
[17:47:53.529]                       invisible(muffled)
[17:47:53.529]                     }
[17:47:53.529]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.529]                   }
[17:47:53.529]                 }
[17:47:53.529]                 else {
[17:47:53.529]                   if (TRUE) {
[17:47:53.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.529]                     {
[17:47:53.529]                       inherits <- base::inherits
[17:47:53.529]                       invokeRestart <- base::invokeRestart
[17:47:53.529]                       is.null <- base::is.null
[17:47:53.529]                       muffled <- FALSE
[17:47:53.529]                       if (inherits(cond, "message")) {
[17:47:53.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.529]                         if (muffled) 
[17:47:53.529]                           invokeRestart("muffleMessage")
[17:47:53.529]                       }
[17:47:53.529]                       else if (inherits(cond, "warning")) {
[17:47:53.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.529]                         if (muffled) 
[17:47:53.529]                           invokeRestart("muffleWarning")
[17:47:53.529]                       }
[17:47:53.529]                       else if (inherits(cond, "condition")) {
[17:47:53.529]                         if (!is.null(pattern)) {
[17:47:53.529]                           computeRestarts <- base::computeRestarts
[17:47:53.529]                           grepl <- base::grepl
[17:47:53.529]                           restarts <- computeRestarts(cond)
[17:47:53.529]                           for (restart in restarts) {
[17:47:53.529]                             name <- restart$name
[17:47:53.529]                             if (is.null(name)) 
[17:47:53.529]                               next
[17:47:53.529]                             if (!grepl(pattern, name)) 
[17:47:53.529]                               next
[17:47:53.529]                             invokeRestart(restart)
[17:47:53.529]                             muffled <- TRUE
[17:47:53.529]                             break
[17:47:53.529]                           }
[17:47:53.529]                         }
[17:47:53.529]                       }
[17:47:53.529]                       invisible(muffled)
[17:47:53.529]                     }
[17:47:53.529]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.529]                   }
[17:47:53.529]                 }
[17:47:53.529]             }
[17:47:53.529]         }))
[17:47:53.529]     }, error = function(ex) {
[17:47:53.529]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.529]                 ...future.rng), started = ...future.startTime, 
[17:47:53.529]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.529]             version = "1.8"), class = "FutureResult")
[17:47:53.529]     }, finally = {
[17:47:53.529]         if (!identical(...future.workdir, getwd())) 
[17:47:53.529]             setwd(...future.workdir)
[17:47:53.529]         {
[17:47:53.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.529]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.529]             }
[17:47:53.529]             base::options(...future.oldOptions)
[17:47:53.529]             if (.Platform$OS.type == "windows") {
[17:47:53.529]                 old_names <- names(...future.oldEnvVars)
[17:47:53.529]                 envs <- base::Sys.getenv()
[17:47:53.529]                 names <- names(envs)
[17:47:53.529]                 common <- intersect(names, old_names)
[17:47:53.529]                 added <- setdiff(names, old_names)
[17:47:53.529]                 removed <- setdiff(old_names, names)
[17:47:53.529]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.529]                   envs[common]]
[17:47:53.529]                 NAMES <- toupper(changed)
[17:47:53.529]                 args <- list()
[17:47:53.529]                 for (kk in seq_along(NAMES)) {
[17:47:53.529]                   name <- changed[[kk]]
[17:47:53.529]                   NAME <- NAMES[[kk]]
[17:47:53.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.529]                     next
[17:47:53.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.529]                 }
[17:47:53.529]                 NAMES <- toupper(added)
[17:47:53.529]                 for (kk in seq_along(NAMES)) {
[17:47:53.529]                   name <- added[[kk]]
[17:47:53.529]                   NAME <- NAMES[[kk]]
[17:47:53.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.529]                     next
[17:47:53.529]                   args[[name]] <- ""
[17:47:53.529]                 }
[17:47:53.529]                 NAMES <- toupper(removed)
[17:47:53.529]                 for (kk in seq_along(NAMES)) {
[17:47:53.529]                   name <- removed[[kk]]
[17:47:53.529]                   NAME <- NAMES[[kk]]
[17:47:53.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.529]                     next
[17:47:53.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.529]                 }
[17:47:53.529]                 if (length(args) > 0) 
[17:47:53.529]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.529]             }
[17:47:53.529]             else {
[17:47:53.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.529]             }
[17:47:53.529]             {
[17:47:53.529]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.529]                   0L) {
[17:47:53.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.529]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.529]                   base::options(opts)
[17:47:53.529]                 }
[17:47:53.529]                 {
[17:47:53.529]                   {
[17:47:53.529]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.529]                     NULL
[17:47:53.529]                   }
[17:47:53.529]                   options(future.plan = NULL)
[17:47:53.529]                   if (is.na(NA_character_)) 
[17:47:53.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.529]                     .init = FALSE)
[17:47:53.529]                 }
[17:47:53.529]             }
[17:47:53.529]         }
[17:47:53.529]     })
[17:47:53.529]     if (TRUE) {
[17:47:53.529]         base::sink(type = "output", split = FALSE)
[17:47:53.529]         if (TRUE) {
[17:47:53.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.529]         }
[17:47:53.529]         else {
[17:47:53.529]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.529]         }
[17:47:53.529]         base::close(...future.stdout)
[17:47:53.529]         ...future.stdout <- NULL
[17:47:53.529]     }
[17:47:53.529]     ...future.result$conditions <- ...future.conditions
[17:47:53.529]     ...future.result$finished <- base::Sys.time()
[17:47:53.529]     ...future.result
[17:47:53.529] }
[17:47:53.531] requestCore(): workers = 2
[17:47:53.534] MulticoreFuture started
[17:47:53.534] - Launch lazy future ... done
[17:47:53.534] run() for ‘MulticoreFuture’ ... done
[17:47:53.534] plan(): Setting new future strategy stack:
[17:47:53.535] getGlobalsAndPackages() ...
[17:47:53.535] Searching for globals...
[17:47:53.535] List of future strategies:
[17:47:53.535] 1. sequential:
[17:47:53.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.535]    - tweaked: FALSE
[17:47:53.535]    - call: NULL
[17:47:53.536] plan(): nbrOfWorkers() = 1
[17:47:53.536] 
[17:47:53.536] Searching for globals ... DONE
[17:47:53.536] - globals: [0] <none>
[17:47:53.536] getGlobalsAndPackages() ... DONE
[17:47:53.537] run() for ‘Future’ ...
[17:47:53.537] - state: ‘created’
[17:47:53.537] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.537] plan(): Setting new future strategy stack:
[17:47:53.538] List of future strategies:
[17:47:53.538] 1. multicore:
[17:47:53.538]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.538]    - tweaked: FALSE
[17:47:53.538]    - call: plan(strategy)
[17:47:53.542] plan(): nbrOfWorkers() = 2
[17:47:53.542] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.542] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.542]   - Field: ‘label’
[17:47:53.542]   - Field: ‘local’
[17:47:53.543]   - Field: ‘owner’
[17:47:53.543]   - Field: ‘envir’
[17:47:53.543]   - Field: ‘workers’
[17:47:53.543]   - Field: ‘packages’
[17:47:53.543]   - Field: ‘gc’
[17:47:53.543]   - Field: ‘job’
[17:47:53.543]   - Field: ‘conditions’
[17:47:53.544]   - Field: ‘expr’
[17:47:53.544]   - Field: ‘uuid’
[17:47:53.544]   - Field: ‘seed’
[17:47:53.544]   - Field: ‘version’
[17:47:53.544]   - Field: ‘result’
[17:47:53.544]   - Field: ‘asynchronous’
[17:47:53.544]   - Field: ‘calls’
[17:47:53.544]   - Field: ‘globals’
[17:47:53.545]   - Field: ‘stdout’
[17:47:53.545]   - Field: ‘earlySignal’
[17:47:53.545]   - Field: ‘lazy’
[17:47:53.545]   - Field: ‘state’
[17:47:53.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.545] - Launch lazy future ...
[17:47:53.546] Packages needed by the future expression (n = 0): <none>
[17:47:53.546] Packages needed by future strategies (n = 0): <none>
[17:47:53.547] {
[17:47:53.547]     {
[17:47:53.547]         {
[17:47:53.547]             ...future.startTime <- base::Sys.time()
[17:47:53.547]             {
[17:47:53.547]                 {
[17:47:53.547]                   {
[17:47:53.547]                     {
[17:47:53.547]                       base::local({
[17:47:53.547]                         has_future <- base::requireNamespace("future", 
[17:47:53.547]                           quietly = TRUE)
[17:47:53.547]                         if (has_future) {
[17:47:53.547]                           ns <- base::getNamespace("future")
[17:47:53.547]                           version <- ns[[".package"]][["version"]]
[17:47:53.547]                           if (is.null(version)) 
[17:47:53.547]                             version <- utils::packageVersion("future")
[17:47:53.547]                         }
[17:47:53.547]                         else {
[17:47:53.547]                           version <- NULL
[17:47:53.547]                         }
[17:47:53.547]                         if (!has_future || version < "1.8.0") {
[17:47:53.547]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.547]                             "", base::R.version$version.string), 
[17:47:53.547]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.547]                               "release", "version")], collapse = " "), 
[17:47:53.547]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.547]                             info)
[17:47:53.547]                           info <- base::paste(info, collapse = "; ")
[17:47:53.547]                           if (!has_future) {
[17:47:53.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.547]                               info)
[17:47:53.547]                           }
[17:47:53.547]                           else {
[17:47:53.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.547]                               info, version)
[17:47:53.547]                           }
[17:47:53.547]                           base::stop(msg)
[17:47:53.547]                         }
[17:47:53.547]                       })
[17:47:53.547]                     }
[17:47:53.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.547]                     base::options(mc.cores = 1L)
[17:47:53.547]                   }
[17:47:53.547]                   ...future.strategy.old <- future::plan("list")
[17:47:53.547]                   options(future.plan = NULL)
[17:47:53.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.547]                 }
[17:47:53.547]                 ...future.workdir <- getwd()
[17:47:53.547]             }
[17:47:53.547]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.547]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.547]         }
[17:47:53.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.547]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.547]             base::names(...future.oldOptions))
[17:47:53.547]     }
[17:47:53.547]     if (FALSE) {
[17:47:53.547]     }
[17:47:53.547]     else {
[17:47:53.547]         if (TRUE) {
[17:47:53.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.547]                 open = "w")
[17:47:53.547]         }
[17:47:53.547]         else {
[17:47:53.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.547]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.547]         }
[17:47:53.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.547]             base::sink(type = "output", split = FALSE)
[17:47:53.547]             base::close(...future.stdout)
[17:47:53.547]         }, add = TRUE)
[17:47:53.547]     }
[17:47:53.547]     ...future.frame <- base::sys.nframe()
[17:47:53.547]     ...future.conditions <- base::list()
[17:47:53.547]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.547]     if (FALSE) {
[17:47:53.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.547]     }
[17:47:53.547]     ...future.result <- base::tryCatch({
[17:47:53.547]         base::withCallingHandlers({
[17:47:53.547]             ...future.value <- base::withVisible(base::local({
[17:47:53.547]                 withCallingHandlers({
[17:47:53.547]                   2
[17:47:53.547]                 }, immediateCondition = function(cond) {
[17:47:53.547]                   save_rds <- function (object, pathname, ...) 
[17:47:53.547]                   {
[17:47:53.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.547]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.547]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.547]                         fi_tmp[["mtime"]])
[17:47:53.547]                     }
[17:47:53.547]                     tryCatch({
[17:47:53.547]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.547]                     }, error = function(ex) {
[17:47:53.547]                       msg <- conditionMessage(ex)
[17:47:53.547]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.547]                         fi_tmp[["mtime"]], msg)
[17:47:53.547]                       ex$message <- msg
[17:47:53.547]                       stop(ex)
[17:47:53.547]                     })
[17:47:53.547]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.547]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.547]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.547]                       fi <- file.info(pathname)
[17:47:53.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.547]                         fi[["size"]], fi[["mtime"]])
[17:47:53.547]                       stop(msg)
[17:47:53.547]                     }
[17:47:53.547]                     invisible(pathname)
[17:47:53.547]                   }
[17:47:53.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.547]                     rootPath = tempdir()) 
[17:47:53.547]                   {
[17:47:53.547]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.547]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.547]                       tmpdir = path, fileext = ".rds")
[17:47:53.547]                     save_rds(obj, file)
[17:47:53.547]                   }
[17:47:53.547]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.547]                   {
[17:47:53.547]                     inherits <- base::inherits
[17:47:53.547]                     invokeRestart <- base::invokeRestart
[17:47:53.547]                     is.null <- base::is.null
[17:47:53.547]                     muffled <- FALSE
[17:47:53.547]                     if (inherits(cond, "message")) {
[17:47:53.547]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.547]                       if (muffled) 
[17:47:53.547]                         invokeRestart("muffleMessage")
[17:47:53.547]                     }
[17:47:53.547]                     else if (inherits(cond, "warning")) {
[17:47:53.547]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.547]                       if (muffled) 
[17:47:53.547]                         invokeRestart("muffleWarning")
[17:47:53.547]                     }
[17:47:53.547]                     else if (inherits(cond, "condition")) {
[17:47:53.547]                       if (!is.null(pattern)) {
[17:47:53.547]                         computeRestarts <- base::computeRestarts
[17:47:53.547]                         grepl <- base::grepl
[17:47:53.547]                         restarts <- computeRestarts(cond)
[17:47:53.547]                         for (restart in restarts) {
[17:47:53.547]                           name <- restart$name
[17:47:53.547]                           if (is.null(name)) 
[17:47:53.547]                             next
[17:47:53.547]                           if (!grepl(pattern, name)) 
[17:47:53.547]                             next
[17:47:53.547]                           invokeRestart(restart)
[17:47:53.547]                           muffled <- TRUE
[17:47:53.547]                           break
[17:47:53.547]                         }
[17:47:53.547]                       }
[17:47:53.547]                     }
[17:47:53.547]                     invisible(muffled)
[17:47:53.547]                   }
[17:47:53.547]                   muffleCondition(cond)
[17:47:53.547]                 })
[17:47:53.547]             }))
[17:47:53.547]             future::FutureResult(value = ...future.value$value, 
[17:47:53.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.547]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.547]                     ...future.globalenv.names))
[17:47:53.547]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.547]         }, condition = base::local({
[17:47:53.547]             c <- base::c
[17:47:53.547]             inherits <- base::inherits
[17:47:53.547]             invokeRestart <- base::invokeRestart
[17:47:53.547]             length <- base::length
[17:47:53.547]             list <- base::list
[17:47:53.547]             seq.int <- base::seq.int
[17:47:53.547]             signalCondition <- base::signalCondition
[17:47:53.547]             sys.calls <- base::sys.calls
[17:47:53.547]             `[[` <- base::`[[`
[17:47:53.547]             `+` <- base::`+`
[17:47:53.547]             `<<-` <- base::`<<-`
[17:47:53.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.547]                   3L)]
[17:47:53.547]             }
[17:47:53.547]             function(cond) {
[17:47:53.547]                 is_error <- inherits(cond, "error")
[17:47:53.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.547]                   NULL)
[17:47:53.547]                 if (is_error) {
[17:47:53.547]                   sessionInformation <- function() {
[17:47:53.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.547]                       search = base::search(), system = base::Sys.info())
[17:47:53.547]                   }
[17:47:53.547]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.547]                     cond$call), session = sessionInformation(), 
[17:47:53.547]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.547]                   signalCondition(cond)
[17:47:53.547]                 }
[17:47:53.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.547]                 "immediateCondition"))) {
[17:47:53.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.547]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.547]                   if (TRUE && !signal) {
[17:47:53.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.547]                     {
[17:47:53.547]                       inherits <- base::inherits
[17:47:53.547]                       invokeRestart <- base::invokeRestart
[17:47:53.547]                       is.null <- base::is.null
[17:47:53.547]                       muffled <- FALSE
[17:47:53.547]                       if (inherits(cond, "message")) {
[17:47:53.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.547]                         if (muffled) 
[17:47:53.547]                           invokeRestart("muffleMessage")
[17:47:53.547]                       }
[17:47:53.547]                       else if (inherits(cond, "warning")) {
[17:47:53.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.547]                         if (muffled) 
[17:47:53.547]                           invokeRestart("muffleWarning")
[17:47:53.547]                       }
[17:47:53.547]                       else if (inherits(cond, "condition")) {
[17:47:53.547]                         if (!is.null(pattern)) {
[17:47:53.547]                           computeRestarts <- base::computeRestarts
[17:47:53.547]                           grepl <- base::grepl
[17:47:53.547]                           restarts <- computeRestarts(cond)
[17:47:53.547]                           for (restart in restarts) {
[17:47:53.547]                             name <- restart$name
[17:47:53.547]                             if (is.null(name)) 
[17:47:53.547]                               next
[17:47:53.547]                             if (!grepl(pattern, name)) 
[17:47:53.547]                               next
[17:47:53.547]                             invokeRestart(restart)
[17:47:53.547]                             muffled <- TRUE
[17:47:53.547]                             break
[17:47:53.547]                           }
[17:47:53.547]                         }
[17:47:53.547]                       }
[17:47:53.547]                       invisible(muffled)
[17:47:53.547]                     }
[17:47:53.547]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.547]                   }
[17:47:53.547]                 }
[17:47:53.547]                 else {
[17:47:53.547]                   if (TRUE) {
[17:47:53.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.547]                     {
[17:47:53.547]                       inherits <- base::inherits
[17:47:53.547]                       invokeRestart <- base::invokeRestart
[17:47:53.547]                       is.null <- base::is.null
[17:47:53.547]                       muffled <- FALSE
[17:47:53.547]                       if (inherits(cond, "message")) {
[17:47:53.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.547]                         if (muffled) 
[17:47:53.547]                           invokeRestart("muffleMessage")
[17:47:53.547]                       }
[17:47:53.547]                       else if (inherits(cond, "warning")) {
[17:47:53.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.547]                         if (muffled) 
[17:47:53.547]                           invokeRestart("muffleWarning")
[17:47:53.547]                       }
[17:47:53.547]                       else if (inherits(cond, "condition")) {
[17:47:53.547]                         if (!is.null(pattern)) {
[17:47:53.547]                           computeRestarts <- base::computeRestarts
[17:47:53.547]                           grepl <- base::grepl
[17:47:53.547]                           restarts <- computeRestarts(cond)
[17:47:53.547]                           for (restart in restarts) {
[17:47:53.547]                             name <- restart$name
[17:47:53.547]                             if (is.null(name)) 
[17:47:53.547]                               next
[17:47:53.547]                             if (!grepl(pattern, name)) 
[17:47:53.547]                               next
[17:47:53.547]                             invokeRestart(restart)
[17:47:53.547]                             muffled <- TRUE
[17:47:53.547]                             break
[17:47:53.547]                           }
[17:47:53.547]                         }
[17:47:53.547]                       }
[17:47:53.547]                       invisible(muffled)
[17:47:53.547]                     }
[17:47:53.547]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.547]                   }
[17:47:53.547]                 }
[17:47:53.547]             }
[17:47:53.547]         }))
[17:47:53.547]     }, error = function(ex) {
[17:47:53.547]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.547]                 ...future.rng), started = ...future.startTime, 
[17:47:53.547]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.547]             version = "1.8"), class = "FutureResult")
[17:47:53.547]     }, finally = {
[17:47:53.547]         if (!identical(...future.workdir, getwd())) 
[17:47:53.547]             setwd(...future.workdir)
[17:47:53.547]         {
[17:47:53.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.547]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.547]             }
[17:47:53.547]             base::options(...future.oldOptions)
[17:47:53.547]             if (.Platform$OS.type == "windows") {
[17:47:53.547]                 old_names <- names(...future.oldEnvVars)
[17:47:53.547]                 envs <- base::Sys.getenv()
[17:47:53.547]                 names <- names(envs)
[17:47:53.547]                 common <- intersect(names, old_names)
[17:47:53.547]                 added <- setdiff(names, old_names)
[17:47:53.547]                 removed <- setdiff(old_names, names)
[17:47:53.547]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.547]                   envs[common]]
[17:47:53.547]                 NAMES <- toupper(changed)
[17:47:53.547]                 args <- list()
[17:47:53.547]                 for (kk in seq_along(NAMES)) {
[17:47:53.547]                   name <- changed[[kk]]
[17:47:53.547]                   NAME <- NAMES[[kk]]
[17:47:53.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.547]                     next
[17:47:53.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.547]                 }
[17:47:53.547]                 NAMES <- toupper(added)
[17:47:53.547]                 for (kk in seq_along(NAMES)) {
[17:47:53.547]                   name <- added[[kk]]
[17:47:53.547]                   NAME <- NAMES[[kk]]
[17:47:53.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.547]                     next
[17:47:53.547]                   args[[name]] <- ""
[17:47:53.547]                 }
[17:47:53.547]                 NAMES <- toupper(removed)
[17:47:53.547]                 for (kk in seq_along(NAMES)) {
[17:47:53.547]                   name <- removed[[kk]]
[17:47:53.547]                   NAME <- NAMES[[kk]]
[17:47:53.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.547]                     next
[17:47:53.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.547]                 }
[17:47:53.547]                 if (length(args) > 0) 
[17:47:53.547]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.547]             }
[17:47:53.547]             else {
[17:47:53.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.547]             }
[17:47:53.547]             {
[17:47:53.547]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.547]                   0L) {
[17:47:53.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.547]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.547]                   base::options(opts)
[17:47:53.547]                 }
[17:47:53.547]                 {
[17:47:53.547]                   {
[17:47:53.547]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.547]                     NULL
[17:47:53.547]                   }
[17:47:53.547]                   options(future.plan = NULL)
[17:47:53.547]                   if (is.na(NA_character_)) 
[17:47:53.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.547]                     .init = FALSE)
[17:47:53.547]                 }
[17:47:53.547]             }
[17:47:53.547]         }
[17:47:53.547]     })
[17:47:53.547]     if (TRUE) {
[17:47:53.547]         base::sink(type = "output", split = FALSE)
[17:47:53.547]         if (TRUE) {
[17:47:53.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.547]         }
[17:47:53.547]         else {
[17:47:53.547]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.547]         }
[17:47:53.547]         base::close(...future.stdout)
[17:47:53.547]         ...future.stdout <- NULL
[17:47:53.547]     }
[17:47:53.547]     ...future.result$conditions <- ...future.conditions
[17:47:53.547]     ...future.result$finished <- base::Sys.time()
[17:47:53.547]     ...future.result
[17:47:53.547] }
[17:47:53.550] requestCore(): workers = 2
[17:47:53.556] MulticoreFuture started
[17:47:53.556] - Launch lazy future ... done
[17:47:53.556] run() for ‘MulticoreFuture’ ... done
[17:47:53.556] resolve() on list ...
[17:47:53.557]  recursive: 0
[17:47:53.557] plan(): Setting new future strategy stack:
[17:47:53.557]  length: 3
[17:47:53.557] List of future strategies:
[17:47:53.557] 1. sequential:
[17:47:53.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.557]    - tweaked: FALSE
[17:47:53.557]    - call: NULL
[17:47:53.604]  elements: ‘a’, ‘b’, ‘’
[17:47:53.604] plan(): nbrOfWorkers() = 1
[17:47:53.605] Future #1
[17:47:53.605]  length: 2 (resolved future 1)
[17:47:53.605] plan(): Setting new future strategy stack:
[17:47:53.605] List of future strategies:
[17:47:53.605] 1. multicore:
[17:47:53.605]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.605]    - tweaked: FALSE
[17:47:53.605]    - call: plan(strategy)
[17:47:53.609] plan(): nbrOfWorkers() = 2
[17:47:53.610] Future #2
[17:47:53.610]  length: 1 (resolved future 2)
[17:47:53.610]  length: 0 (resolved future 3)
[17:47:53.610] resolve() on list ... DONE
[17:47:53.611] getGlobalsAndPackages() ...
[17:47:53.611] Searching for globals...
[17:47:53.611] 
[17:47:53.611] Searching for globals ... DONE
[17:47:53.611] - globals: [0] <none>
[17:47:53.611] getGlobalsAndPackages() ... DONE
[17:47:53.612] getGlobalsAndPackages() ...
[17:47:53.612] Searching for globals...
[17:47:53.612] 
[17:47:53.612] Searching for globals ... DONE
[17:47:53.612] - globals: [0] <none>
[17:47:53.612] getGlobalsAndPackages() ... DONE
[17:47:53.613] run() for ‘Future’ ...
[17:47:53.613] - state: ‘created’
[17:47:53.613] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.616] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.617]   - Field: ‘label’
[17:47:53.617]   - Field: ‘local’
[17:47:53.617]   - Field: ‘owner’
[17:47:53.617]   - Field: ‘envir’
[17:47:53.617]   - Field: ‘workers’
[17:47:53.617]   - Field: ‘packages’
[17:47:53.617]   - Field: ‘gc’
[17:47:53.617]   - Field: ‘job’
[17:47:53.617]   - Field: ‘conditions’
[17:47:53.617]   - Field: ‘expr’
[17:47:53.618]   - Field: ‘uuid’
[17:47:53.618]   - Field: ‘seed’
[17:47:53.618]   - Field: ‘version’
[17:47:53.618]   - Field: ‘result’
[17:47:53.618]   - Field: ‘asynchronous’
[17:47:53.618]   - Field: ‘calls’
[17:47:53.618]   - Field: ‘globals’
[17:47:53.618]   - Field: ‘stdout’
[17:47:53.618]   - Field: ‘earlySignal’
[17:47:53.618]   - Field: ‘lazy’
[17:47:53.619]   - Field: ‘state’
[17:47:53.619] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.619] - Launch lazy future ...
[17:47:53.619] Packages needed by the future expression (n = 0): <none>
[17:47:53.619] Packages needed by future strategies (n = 0): <none>
[17:47:53.620] {
[17:47:53.620]     {
[17:47:53.620]         {
[17:47:53.620]             ...future.startTime <- base::Sys.time()
[17:47:53.620]             {
[17:47:53.620]                 {
[17:47:53.620]                   {
[17:47:53.620]                     {
[17:47:53.620]                       base::local({
[17:47:53.620]                         has_future <- base::requireNamespace("future", 
[17:47:53.620]                           quietly = TRUE)
[17:47:53.620]                         if (has_future) {
[17:47:53.620]                           ns <- base::getNamespace("future")
[17:47:53.620]                           version <- ns[[".package"]][["version"]]
[17:47:53.620]                           if (is.null(version)) 
[17:47:53.620]                             version <- utils::packageVersion("future")
[17:47:53.620]                         }
[17:47:53.620]                         else {
[17:47:53.620]                           version <- NULL
[17:47:53.620]                         }
[17:47:53.620]                         if (!has_future || version < "1.8.0") {
[17:47:53.620]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.620]                             "", base::R.version$version.string), 
[17:47:53.620]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.620]                               "release", "version")], collapse = " "), 
[17:47:53.620]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.620]                             info)
[17:47:53.620]                           info <- base::paste(info, collapse = "; ")
[17:47:53.620]                           if (!has_future) {
[17:47:53.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.620]                               info)
[17:47:53.620]                           }
[17:47:53.620]                           else {
[17:47:53.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.620]                               info, version)
[17:47:53.620]                           }
[17:47:53.620]                           base::stop(msg)
[17:47:53.620]                         }
[17:47:53.620]                       })
[17:47:53.620]                     }
[17:47:53.620]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.620]                     base::options(mc.cores = 1L)
[17:47:53.620]                   }
[17:47:53.620]                   ...future.strategy.old <- future::plan("list")
[17:47:53.620]                   options(future.plan = NULL)
[17:47:53.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.620]                 }
[17:47:53.620]                 ...future.workdir <- getwd()
[17:47:53.620]             }
[17:47:53.620]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.620]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.620]         }
[17:47:53.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.620]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.620]             base::names(...future.oldOptions))
[17:47:53.620]     }
[17:47:53.620]     if (FALSE) {
[17:47:53.620]     }
[17:47:53.620]     else {
[17:47:53.620]         if (TRUE) {
[17:47:53.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.620]                 open = "w")
[17:47:53.620]         }
[17:47:53.620]         else {
[17:47:53.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.620]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.620]         }
[17:47:53.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.620]             base::sink(type = "output", split = FALSE)
[17:47:53.620]             base::close(...future.stdout)
[17:47:53.620]         }, add = TRUE)
[17:47:53.620]     }
[17:47:53.620]     ...future.frame <- base::sys.nframe()
[17:47:53.620]     ...future.conditions <- base::list()
[17:47:53.620]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.620]     if (FALSE) {
[17:47:53.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.620]     }
[17:47:53.620]     ...future.result <- base::tryCatch({
[17:47:53.620]         base::withCallingHandlers({
[17:47:53.620]             ...future.value <- base::withVisible(base::local({
[17:47:53.620]                 withCallingHandlers({
[17:47:53.620]                   2
[17:47:53.620]                 }, immediateCondition = function(cond) {
[17:47:53.620]                   save_rds <- function (object, pathname, ...) 
[17:47:53.620]                   {
[17:47:53.620]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.620]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.620]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.620]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.620]                         fi_tmp[["mtime"]])
[17:47:53.620]                     }
[17:47:53.620]                     tryCatch({
[17:47:53.620]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.620]                     }, error = function(ex) {
[17:47:53.620]                       msg <- conditionMessage(ex)
[17:47:53.620]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.620]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.620]                         fi_tmp[["mtime"]], msg)
[17:47:53.620]                       ex$message <- msg
[17:47:53.620]                       stop(ex)
[17:47:53.620]                     })
[17:47:53.620]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.620]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.620]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.620]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.620]                       fi <- file.info(pathname)
[17:47:53.620]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.620]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.620]                         fi[["size"]], fi[["mtime"]])
[17:47:53.620]                       stop(msg)
[17:47:53.620]                     }
[17:47:53.620]                     invisible(pathname)
[17:47:53.620]                   }
[17:47:53.620]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.620]                     rootPath = tempdir()) 
[17:47:53.620]                   {
[17:47:53.620]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.620]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.620]                       tmpdir = path, fileext = ".rds")
[17:47:53.620]                     save_rds(obj, file)
[17:47:53.620]                   }
[17:47:53.620]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.620]                   {
[17:47:53.620]                     inherits <- base::inherits
[17:47:53.620]                     invokeRestart <- base::invokeRestart
[17:47:53.620]                     is.null <- base::is.null
[17:47:53.620]                     muffled <- FALSE
[17:47:53.620]                     if (inherits(cond, "message")) {
[17:47:53.620]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.620]                       if (muffled) 
[17:47:53.620]                         invokeRestart("muffleMessage")
[17:47:53.620]                     }
[17:47:53.620]                     else if (inherits(cond, "warning")) {
[17:47:53.620]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.620]                       if (muffled) 
[17:47:53.620]                         invokeRestart("muffleWarning")
[17:47:53.620]                     }
[17:47:53.620]                     else if (inherits(cond, "condition")) {
[17:47:53.620]                       if (!is.null(pattern)) {
[17:47:53.620]                         computeRestarts <- base::computeRestarts
[17:47:53.620]                         grepl <- base::grepl
[17:47:53.620]                         restarts <- computeRestarts(cond)
[17:47:53.620]                         for (restart in restarts) {
[17:47:53.620]                           name <- restart$name
[17:47:53.620]                           if (is.null(name)) 
[17:47:53.620]                             next
[17:47:53.620]                           if (!grepl(pattern, name)) 
[17:47:53.620]                             next
[17:47:53.620]                           invokeRestart(restart)
[17:47:53.620]                           muffled <- TRUE
[17:47:53.620]                           break
[17:47:53.620]                         }
[17:47:53.620]                       }
[17:47:53.620]                     }
[17:47:53.620]                     invisible(muffled)
[17:47:53.620]                   }
[17:47:53.620]                   muffleCondition(cond)
[17:47:53.620]                 })
[17:47:53.620]             }))
[17:47:53.620]             future::FutureResult(value = ...future.value$value, 
[17:47:53.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.620]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.620]                     ...future.globalenv.names))
[17:47:53.620]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.620]         }, condition = base::local({
[17:47:53.620]             c <- base::c
[17:47:53.620]             inherits <- base::inherits
[17:47:53.620]             invokeRestart <- base::invokeRestart
[17:47:53.620]             length <- base::length
[17:47:53.620]             list <- base::list
[17:47:53.620]             seq.int <- base::seq.int
[17:47:53.620]             signalCondition <- base::signalCondition
[17:47:53.620]             sys.calls <- base::sys.calls
[17:47:53.620]             `[[` <- base::`[[`
[17:47:53.620]             `+` <- base::`+`
[17:47:53.620]             `<<-` <- base::`<<-`
[17:47:53.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.620]                   3L)]
[17:47:53.620]             }
[17:47:53.620]             function(cond) {
[17:47:53.620]                 is_error <- inherits(cond, "error")
[17:47:53.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.620]                   NULL)
[17:47:53.620]                 if (is_error) {
[17:47:53.620]                   sessionInformation <- function() {
[17:47:53.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.620]                       search = base::search(), system = base::Sys.info())
[17:47:53.620]                   }
[17:47:53.620]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.620]                     cond$call), session = sessionInformation(), 
[17:47:53.620]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.620]                   signalCondition(cond)
[17:47:53.620]                 }
[17:47:53.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.620]                 "immediateCondition"))) {
[17:47:53.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.620]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.620]                   if (TRUE && !signal) {
[17:47:53.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.620]                     {
[17:47:53.620]                       inherits <- base::inherits
[17:47:53.620]                       invokeRestart <- base::invokeRestart
[17:47:53.620]                       is.null <- base::is.null
[17:47:53.620]                       muffled <- FALSE
[17:47:53.620]                       if (inherits(cond, "message")) {
[17:47:53.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.620]                         if (muffled) 
[17:47:53.620]                           invokeRestart("muffleMessage")
[17:47:53.620]                       }
[17:47:53.620]                       else if (inherits(cond, "warning")) {
[17:47:53.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.620]                         if (muffled) 
[17:47:53.620]                           invokeRestart("muffleWarning")
[17:47:53.620]                       }
[17:47:53.620]                       else if (inherits(cond, "condition")) {
[17:47:53.620]                         if (!is.null(pattern)) {
[17:47:53.620]                           computeRestarts <- base::computeRestarts
[17:47:53.620]                           grepl <- base::grepl
[17:47:53.620]                           restarts <- computeRestarts(cond)
[17:47:53.620]                           for (restart in restarts) {
[17:47:53.620]                             name <- restart$name
[17:47:53.620]                             if (is.null(name)) 
[17:47:53.620]                               next
[17:47:53.620]                             if (!grepl(pattern, name)) 
[17:47:53.620]                               next
[17:47:53.620]                             invokeRestart(restart)
[17:47:53.620]                             muffled <- TRUE
[17:47:53.620]                             break
[17:47:53.620]                           }
[17:47:53.620]                         }
[17:47:53.620]                       }
[17:47:53.620]                       invisible(muffled)
[17:47:53.620]                     }
[17:47:53.620]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.620]                   }
[17:47:53.620]                 }
[17:47:53.620]                 else {
[17:47:53.620]                   if (TRUE) {
[17:47:53.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.620]                     {
[17:47:53.620]                       inherits <- base::inherits
[17:47:53.620]                       invokeRestart <- base::invokeRestart
[17:47:53.620]                       is.null <- base::is.null
[17:47:53.620]                       muffled <- FALSE
[17:47:53.620]                       if (inherits(cond, "message")) {
[17:47:53.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.620]                         if (muffled) 
[17:47:53.620]                           invokeRestart("muffleMessage")
[17:47:53.620]                       }
[17:47:53.620]                       else if (inherits(cond, "warning")) {
[17:47:53.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.620]                         if (muffled) 
[17:47:53.620]                           invokeRestart("muffleWarning")
[17:47:53.620]                       }
[17:47:53.620]                       else if (inherits(cond, "condition")) {
[17:47:53.620]                         if (!is.null(pattern)) {
[17:47:53.620]                           computeRestarts <- base::computeRestarts
[17:47:53.620]                           grepl <- base::grepl
[17:47:53.620]                           restarts <- computeRestarts(cond)
[17:47:53.620]                           for (restart in restarts) {
[17:47:53.620]                             name <- restart$name
[17:47:53.620]                             if (is.null(name)) 
[17:47:53.620]                               next
[17:47:53.620]                             if (!grepl(pattern, name)) 
[17:47:53.620]                               next
[17:47:53.620]                             invokeRestart(restart)
[17:47:53.620]                             muffled <- TRUE
[17:47:53.620]                             break
[17:47:53.620]                           }
[17:47:53.620]                         }
[17:47:53.620]                       }
[17:47:53.620]                       invisible(muffled)
[17:47:53.620]                     }
[17:47:53.620]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.620]                   }
[17:47:53.620]                 }
[17:47:53.620]             }
[17:47:53.620]         }))
[17:47:53.620]     }, error = function(ex) {
[17:47:53.620]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.620]                 ...future.rng), started = ...future.startTime, 
[17:47:53.620]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.620]             version = "1.8"), class = "FutureResult")
[17:47:53.620]     }, finally = {
[17:47:53.620]         if (!identical(...future.workdir, getwd())) 
[17:47:53.620]             setwd(...future.workdir)
[17:47:53.620]         {
[17:47:53.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.620]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.620]             }
[17:47:53.620]             base::options(...future.oldOptions)
[17:47:53.620]             if (.Platform$OS.type == "windows") {
[17:47:53.620]                 old_names <- names(...future.oldEnvVars)
[17:47:53.620]                 envs <- base::Sys.getenv()
[17:47:53.620]                 names <- names(envs)
[17:47:53.620]                 common <- intersect(names, old_names)
[17:47:53.620]                 added <- setdiff(names, old_names)
[17:47:53.620]                 removed <- setdiff(old_names, names)
[17:47:53.620]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.620]                   envs[common]]
[17:47:53.620]                 NAMES <- toupper(changed)
[17:47:53.620]                 args <- list()
[17:47:53.620]                 for (kk in seq_along(NAMES)) {
[17:47:53.620]                   name <- changed[[kk]]
[17:47:53.620]                   NAME <- NAMES[[kk]]
[17:47:53.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.620]                     next
[17:47:53.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.620]                 }
[17:47:53.620]                 NAMES <- toupper(added)
[17:47:53.620]                 for (kk in seq_along(NAMES)) {
[17:47:53.620]                   name <- added[[kk]]
[17:47:53.620]                   NAME <- NAMES[[kk]]
[17:47:53.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.620]                     next
[17:47:53.620]                   args[[name]] <- ""
[17:47:53.620]                 }
[17:47:53.620]                 NAMES <- toupper(removed)
[17:47:53.620]                 for (kk in seq_along(NAMES)) {
[17:47:53.620]                   name <- removed[[kk]]
[17:47:53.620]                   NAME <- NAMES[[kk]]
[17:47:53.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.620]                     next
[17:47:53.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.620]                 }
[17:47:53.620]                 if (length(args) > 0) 
[17:47:53.620]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.620]             }
[17:47:53.620]             else {
[17:47:53.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.620]             }
[17:47:53.620]             {
[17:47:53.620]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.620]                   0L) {
[17:47:53.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.620]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.620]                   base::options(opts)
[17:47:53.620]                 }
[17:47:53.620]                 {
[17:47:53.620]                   {
[17:47:53.620]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.620]                     NULL
[17:47:53.620]                   }
[17:47:53.620]                   options(future.plan = NULL)
[17:47:53.620]                   if (is.na(NA_character_)) 
[17:47:53.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.620]                     .init = FALSE)
[17:47:53.620]                 }
[17:47:53.620]             }
[17:47:53.620]         }
[17:47:53.620]     })
[17:47:53.620]     if (TRUE) {
[17:47:53.620]         base::sink(type = "output", split = FALSE)
[17:47:53.620]         if (TRUE) {
[17:47:53.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.620]         }
[17:47:53.620]         else {
[17:47:53.620]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.620]         }
[17:47:53.620]         base::close(...future.stdout)
[17:47:53.620]         ...future.stdout <- NULL
[17:47:53.620]     }
[17:47:53.620]     ...future.result$conditions <- ...future.conditions
[17:47:53.620]     ...future.result$finished <- base::Sys.time()
[17:47:53.620]     ...future.result
[17:47:53.620] }
[17:47:53.622] requestCore(): workers = 2
[17:47:53.622] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:53.633] result() for MulticoreFuture ...
[17:47:53.634] result() for MulticoreFuture ...
[17:47:53.634] result() for MulticoreFuture ... done
[17:47:53.634] result() for MulticoreFuture ... done
[17:47:53.634] result() for MulticoreFuture ...
[17:47:53.634] result() for MulticoreFuture ... done
[17:47:53.637] MulticoreFuture started
[17:47:53.638] - Launch lazy future ... done
[17:47:53.638] run() for ‘MulticoreFuture’ ... done
[17:47:53.638] resolve() on list ...
[17:47:53.638] plan(): Setting new future strategy stack:
[17:47:53.639]  recursive: 0
[17:47:53.639]  length: 3
[17:47:53.639]  elements: ‘a’, ‘b’, ‘’
[17:47:53.639] run() for ‘Future’ ...
[17:47:53.640] - state: ‘created’
[17:47:53.639] List of future strategies:
[17:47:53.639] 1. sequential:
[17:47:53.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.639]    - tweaked: FALSE
[17:47:53.639]    - call: NULL
[17:47:53.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.640] plan(): nbrOfWorkers() = 1
[17:47:53.643] plan(): Setting new future strategy stack:
[17:47:53.643] List of future strategies:
[17:47:53.643] 1. multicore:
[17:47:53.643]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.643]    - tweaked: FALSE
[17:47:53.643]    - call: plan(strategy)
[17:47:53.646] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.647]   - Field: ‘label’
[17:47:53.647]   - Field: ‘local’
[17:47:53.647]   - Field: ‘owner’
[17:47:53.647]   - Field: ‘envir’
[17:47:53.648]   - Field: ‘workers’
[17:47:53.648] plan(): nbrOfWorkers() = 2
[17:47:53.648]   - Field: ‘packages’
[17:47:53.648]   - Field: ‘gc’
[17:47:53.648]   - Field: ‘job’
[17:47:53.649]   - Field: ‘conditions’
[17:47:53.649]   - Field: ‘expr’
[17:47:53.649]   - Field: ‘uuid’
[17:47:53.649]   - Field: ‘seed’
[17:47:53.649]   - Field: ‘version’
[17:47:53.649]   - Field: ‘result’
[17:47:53.649]   - Field: ‘asynchronous’
[17:47:53.650]   - Field: ‘calls’
[17:47:53.650]   - Field: ‘globals’
[17:47:53.650]   - Field: ‘stdout’
[17:47:53.650]   - Field: ‘earlySignal’
[17:47:53.650]   - Field: ‘lazy’
[17:47:53.650]   - Field: ‘state’
[17:47:53.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.651] - Launch lazy future ...
[17:47:53.651] Packages needed by the future expression (n = 0): <none>
[17:47:53.651] Packages needed by future strategies (n = 0): <none>
[17:47:53.652] {
[17:47:53.652]     {
[17:47:53.652]         {
[17:47:53.652]             ...future.startTime <- base::Sys.time()
[17:47:53.652]             {
[17:47:53.652]                 {
[17:47:53.652]                   {
[17:47:53.652]                     {
[17:47:53.652]                       base::local({
[17:47:53.652]                         has_future <- base::requireNamespace("future", 
[17:47:53.652]                           quietly = TRUE)
[17:47:53.652]                         if (has_future) {
[17:47:53.652]                           ns <- base::getNamespace("future")
[17:47:53.652]                           version <- ns[[".package"]][["version"]]
[17:47:53.652]                           if (is.null(version)) 
[17:47:53.652]                             version <- utils::packageVersion("future")
[17:47:53.652]                         }
[17:47:53.652]                         else {
[17:47:53.652]                           version <- NULL
[17:47:53.652]                         }
[17:47:53.652]                         if (!has_future || version < "1.8.0") {
[17:47:53.652]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.652]                             "", base::R.version$version.string), 
[17:47:53.652]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.652]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.652]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.652]                               "release", "version")], collapse = " "), 
[17:47:53.652]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.652]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.652]                             info)
[17:47:53.652]                           info <- base::paste(info, collapse = "; ")
[17:47:53.652]                           if (!has_future) {
[17:47:53.652]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.652]                               info)
[17:47:53.652]                           }
[17:47:53.652]                           else {
[17:47:53.652]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.652]                               info, version)
[17:47:53.652]                           }
[17:47:53.652]                           base::stop(msg)
[17:47:53.652]                         }
[17:47:53.652]                       })
[17:47:53.652]                     }
[17:47:53.652]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.652]                     base::options(mc.cores = 1L)
[17:47:53.652]                   }
[17:47:53.652]                   ...future.strategy.old <- future::plan("list")
[17:47:53.652]                   options(future.plan = NULL)
[17:47:53.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.652]                 }
[17:47:53.652]                 ...future.workdir <- getwd()
[17:47:53.652]             }
[17:47:53.652]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.652]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.652]         }
[17:47:53.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.652]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.652]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.652]             base::names(...future.oldOptions))
[17:47:53.652]     }
[17:47:53.652]     if (FALSE) {
[17:47:53.652]     }
[17:47:53.652]     else {
[17:47:53.652]         if (TRUE) {
[17:47:53.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.652]                 open = "w")
[17:47:53.652]         }
[17:47:53.652]         else {
[17:47:53.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.652]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.652]         }
[17:47:53.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.652]             base::sink(type = "output", split = FALSE)
[17:47:53.652]             base::close(...future.stdout)
[17:47:53.652]         }, add = TRUE)
[17:47:53.652]     }
[17:47:53.652]     ...future.frame <- base::sys.nframe()
[17:47:53.652]     ...future.conditions <- base::list()
[17:47:53.652]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.652]     if (FALSE) {
[17:47:53.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.652]     }
[17:47:53.652]     ...future.result <- base::tryCatch({
[17:47:53.652]         base::withCallingHandlers({
[17:47:53.652]             ...future.value <- base::withVisible(base::local({
[17:47:53.652]                 withCallingHandlers({
[17:47:53.652]                   1
[17:47:53.652]                 }, immediateCondition = function(cond) {
[17:47:53.652]                   save_rds <- function (object, pathname, ...) 
[17:47:53.652]                   {
[17:47:53.652]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.652]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.652]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.652]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.652]                         fi_tmp[["mtime"]])
[17:47:53.652]                     }
[17:47:53.652]                     tryCatch({
[17:47:53.652]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.652]                     }, error = function(ex) {
[17:47:53.652]                       msg <- conditionMessage(ex)
[17:47:53.652]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.652]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.652]                         fi_tmp[["mtime"]], msg)
[17:47:53.652]                       ex$message <- msg
[17:47:53.652]                       stop(ex)
[17:47:53.652]                     })
[17:47:53.652]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.652]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.652]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.652]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.652]                       fi <- file.info(pathname)
[17:47:53.652]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.652]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.652]                         fi[["size"]], fi[["mtime"]])
[17:47:53.652]                       stop(msg)
[17:47:53.652]                     }
[17:47:53.652]                     invisible(pathname)
[17:47:53.652]                   }
[17:47:53.652]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.652]                     rootPath = tempdir()) 
[17:47:53.652]                   {
[17:47:53.652]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.652]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.652]                       tmpdir = path, fileext = ".rds")
[17:47:53.652]                     save_rds(obj, file)
[17:47:53.652]                   }
[17:47:53.652]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.652]                   {
[17:47:53.652]                     inherits <- base::inherits
[17:47:53.652]                     invokeRestart <- base::invokeRestart
[17:47:53.652]                     is.null <- base::is.null
[17:47:53.652]                     muffled <- FALSE
[17:47:53.652]                     if (inherits(cond, "message")) {
[17:47:53.652]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.652]                       if (muffled) 
[17:47:53.652]                         invokeRestart("muffleMessage")
[17:47:53.652]                     }
[17:47:53.652]                     else if (inherits(cond, "warning")) {
[17:47:53.652]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.652]                       if (muffled) 
[17:47:53.652]                         invokeRestart("muffleWarning")
[17:47:53.652]                     }
[17:47:53.652]                     else if (inherits(cond, "condition")) {
[17:47:53.652]                       if (!is.null(pattern)) {
[17:47:53.652]                         computeRestarts <- base::computeRestarts
[17:47:53.652]                         grepl <- base::grepl
[17:47:53.652]                         restarts <- computeRestarts(cond)
[17:47:53.652]                         for (restart in restarts) {
[17:47:53.652]                           name <- restart$name
[17:47:53.652]                           if (is.null(name)) 
[17:47:53.652]                             next
[17:47:53.652]                           if (!grepl(pattern, name)) 
[17:47:53.652]                             next
[17:47:53.652]                           invokeRestart(restart)
[17:47:53.652]                           muffled <- TRUE
[17:47:53.652]                           break
[17:47:53.652]                         }
[17:47:53.652]                       }
[17:47:53.652]                     }
[17:47:53.652]                     invisible(muffled)
[17:47:53.652]                   }
[17:47:53.652]                   muffleCondition(cond)
[17:47:53.652]                 })
[17:47:53.652]             }))
[17:47:53.652]             future::FutureResult(value = ...future.value$value, 
[17:47:53.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.652]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.652]                     ...future.globalenv.names))
[17:47:53.652]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.652]         }, condition = base::local({
[17:47:53.652]             c <- base::c
[17:47:53.652]             inherits <- base::inherits
[17:47:53.652]             invokeRestart <- base::invokeRestart
[17:47:53.652]             length <- base::length
[17:47:53.652]             list <- base::list
[17:47:53.652]             seq.int <- base::seq.int
[17:47:53.652]             signalCondition <- base::signalCondition
[17:47:53.652]             sys.calls <- base::sys.calls
[17:47:53.652]             `[[` <- base::`[[`
[17:47:53.652]             `+` <- base::`+`
[17:47:53.652]             `<<-` <- base::`<<-`
[17:47:53.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.652]                   3L)]
[17:47:53.652]             }
[17:47:53.652]             function(cond) {
[17:47:53.652]                 is_error <- inherits(cond, "error")
[17:47:53.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.652]                   NULL)
[17:47:53.652]                 if (is_error) {
[17:47:53.652]                   sessionInformation <- function() {
[17:47:53.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.652]                       search = base::search(), system = base::Sys.info())
[17:47:53.652]                   }
[17:47:53.652]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.652]                     cond$call), session = sessionInformation(), 
[17:47:53.652]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.652]                   signalCondition(cond)
[17:47:53.652]                 }
[17:47:53.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.652]                 "immediateCondition"))) {
[17:47:53.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.652]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.652]                   if (TRUE && !signal) {
[17:47:53.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.652]                     {
[17:47:53.652]                       inherits <- base::inherits
[17:47:53.652]                       invokeRestart <- base::invokeRestart
[17:47:53.652]                       is.null <- base::is.null
[17:47:53.652]                       muffled <- FALSE
[17:47:53.652]                       if (inherits(cond, "message")) {
[17:47:53.652]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.652]                         if (muffled) 
[17:47:53.652]                           invokeRestart("muffleMessage")
[17:47:53.652]                       }
[17:47:53.652]                       else if (inherits(cond, "warning")) {
[17:47:53.652]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.652]                         if (muffled) 
[17:47:53.652]                           invokeRestart("muffleWarning")
[17:47:53.652]                       }
[17:47:53.652]                       else if (inherits(cond, "condition")) {
[17:47:53.652]                         if (!is.null(pattern)) {
[17:47:53.652]                           computeRestarts <- base::computeRestarts
[17:47:53.652]                           grepl <- base::grepl
[17:47:53.652]                           restarts <- computeRestarts(cond)
[17:47:53.652]                           for (restart in restarts) {
[17:47:53.652]                             name <- restart$name
[17:47:53.652]                             if (is.null(name)) 
[17:47:53.652]                               next
[17:47:53.652]                             if (!grepl(pattern, name)) 
[17:47:53.652]                               next
[17:47:53.652]                             invokeRestart(restart)
[17:47:53.652]                             muffled <- TRUE
[17:47:53.652]                             break
[17:47:53.652]                           }
[17:47:53.652]                         }
[17:47:53.652]                       }
[17:47:53.652]                       invisible(muffled)
[17:47:53.652]                     }
[17:47:53.652]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.652]                   }
[17:47:53.652]                 }
[17:47:53.652]                 else {
[17:47:53.652]                   if (TRUE) {
[17:47:53.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.652]                     {
[17:47:53.652]                       inherits <- base::inherits
[17:47:53.652]                       invokeRestart <- base::invokeRestart
[17:47:53.652]                       is.null <- base::is.null
[17:47:53.652]                       muffled <- FALSE
[17:47:53.652]                       if (inherits(cond, "message")) {
[17:47:53.652]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.652]                         if (muffled) 
[17:47:53.652]                           invokeRestart("muffleMessage")
[17:47:53.652]                       }
[17:47:53.652]                       else if (inherits(cond, "warning")) {
[17:47:53.652]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.652]                         if (muffled) 
[17:47:53.652]                           invokeRestart("muffleWarning")
[17:47:53.652]                       }
[17:47:53.652]                       else if (inherits(cond, "condition")) {
[17:47:53.652]                         if (!is.null(pattern)) {
[17:47:53.652]                           computeRestarts <- base::computeRestarts
[17:47:53.652]                           grepl <- base::grepl
[17:47:53.652]                           restarts <- computeRestarts(cond)
[17:47:53.652]                           for (restart in restarts) {
[17:47:53.652]                             name <- restart$name
[17:47:53.652]                             if (is.null(name)) 
[17:47:53.652]                               next
[17:47:53.652]                             if (!grepl(pattern, name)) 
[17:47:53.652]                               next
[17:47:53.652]                             invokeRestart(restart)
[17:47:53.652]                             muffled <- TRUE
[17:47:53.652]                             break
[17:47:53.652]                           }
[17:47:53.652]                         }
[17:47:53.652]                       }
[17:47:53.652]                       invisible(muffled)
[17:47:53.652]                     }
[17:47:53.652]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.652]                   }
[17:47:53.652]                 }
[17:47:53.652]             }
[17:47:53.652]         }))
[17:47:53.652]     }, error = function(ex) {
[17:47:53.652]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.652]                 ...future.rng), started = ...future.startTime, 
[17:47:53.652]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.652]             version = "1.8"), class = "FutureResult")
[17:47:53.652]     }, finally = {
[17:47:53.652]         if (!identical(...future.workdir, getwd())) 
[17:47:53.652]             setwd(...future.workdir)
[17:47:53.652]         {
[17:47:53.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.652]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.652]             }
[17:47:53.652]             base::options(...future.oldOptions)
[17:47:53.652]             if (.Platform$OS.type == "windows") {
[17:47:53.652]                 old_names <- names(...future.oldEnvVars)
[17:47:53.652]                 envs <- base::Sys.getenv()
[17:47:53.652]                 names <- names(envs)
[17:47:53.652]                 common <- intersect(names, old_names)
[17:47:53.652]                 added <- setdiff(names, old_names)
[17:47:53.652]                 removed <- setdiff(old_names, names)
[17:47:53.652]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.652]                   envs[common]]
[17:47:53.652]                 NAMES <- toupper(changed)
[17:47:53.652]                 args <- list()
[17:47:53.652]                 for (kk in seq_along(NAMES)) {
[17:47:53.652]                   name <- changed[[kk]]
[17:47:53.652]                   NAME <- NAMES[[kk]]
[17:47:53.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.652]                     next
[17:47:53.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.652]                 }
[17:47:53.652]                 NAMES <- toupper(added)
[17:47:53.652]                 for (kk in seq_along(NAMES)) {
[17:47:53.652]                   name <- added[[kk]]
[17:47:53.652]                   NAME <- NAMES[[kk]]
[17:47:53.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.652]                     next
[17:47:53.652]                   args[[name]] <- ""
[17:47:53.652]                 }
[17:47:53.652]                 NAMES <- toupper(removed)
[17:47:53.652]                 for (kk in seq_along(NAMES)) {
[17:47:53.652]                   name <- removed[[kk]]
[17:47:53.652]                   NAME <- NAMES[[kk]]
[17:47:53.652]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.652]                     next
[17:47:53.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.652]                 }
[17:47:53.652]                 if (length(args) > 0) 
[17:47:53.652]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.652]             }
[17:47:53.652]             else {
[17:47:53.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.652]             }
[17:47:53.652]             {
[17:47:53.652]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.652]                   0L) {
[17:47:53.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.652]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.652]                   base::options(opts)
[17:47:53.652]                 }
[17:47:53.652]                 {
[17:47:53.652]                   {
[17:47:53.652]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.652]                     NULL
[17:47:53.652]                   }
[17:47:53.652]                   options(future.plan = NULL)
[17:47:53.652]                   if (is.na(NA_character_)) 
[17:47:53.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.652]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.652]                     .init = FALSE)
[17:47:53.652]                 }
[17:47:53.652]             }
[17:47:53.652]         }
[17:47:53.652]     })
[17:47:53.652]     if (TRUE) {
[17:47:53.652]         base::sink(type = "output", split = FALSE)
[17:47:53.652]         if (TRUE) {
[17:47:53.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.652]         }
[17:47:53.652]         else {
[17:47:53.652]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.652]         }
[17:47:53.652]         base::close(...future.stdout)
[17:47:53.652]         ...future.stdout <- NULL
[17:47:53.652]     }
[17:47:53.652]     ...future.result$conditions <- ...future.conditions
[17:47:53.652]     ...future.result$finished <- base::Sys.time()
[17:47:53.652]     ...future.result
[17:47:53.652] }
[17:47:53.655] requestCore(): workers = 2
[17:47:53.656] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:53.683] result() for MulticoreFuture ...
[17:47:53.684] result() for MulticoreFuture ...
[17:47:53.684] result() for MulticoreFuture ... done
[17:47:53.684] result() for MulticoreFuture ... done
[17:47:53.684] result() for MulticoreFuture ...
[17:47:53.684] result() for MulticoreFuture ... done
[17:47:53.687] MulticoreFuture started
[17:47:53.688] - Launch lazy future ... done
[17:47:53.688] run() for ‘MulticoreFuture’ ... done
[17:47:53.688] plan(): Setting new future strategy stack:
[17:47:53.689] List of future strategies:
[17:47:53.689] 1. sequential:
[17:47:53.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.689]    - tweaked: FALSE
[17:47:53.689]    - call: NULL
[17:47:53.690] plan(): nbrOfWorkers() = 1
[17:47:53.693] plan(): Setting new future strategy stack:
[17:47:53.693] List of future strategies:
[17:47:53.693] 1. multicore:
[17:47:53.693]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.693]    - tweaked: FALSE
[17:47:53.693]    - call: plan(strategy)
[17:47:53.698] plan(): nbrOfWorkers() = 2
[17:47:53.699] Future #1
[17:47:53.699]  length: 2 (resolved future 1)
[17:47:53.700] Future #2
[17:47:53.700]  length: 1 (resolved future 2)
[17:47:53.700]  length: 0 (resolved future 3)
[17:47:53.700] resolve() on list ... DONE
[17:47:53.701] getGlobalsAndPackages() ...
[17:47:53.701] Searching for globals...
[17:47:53.702] 
[17:47:53.702] Searching for globals ... DONE
[17:47:53.702] - globals: [0] <none>
[17:47:53.702] getGlobalsAndPackages() ... DONE
[17:47:53.703] getGlobalsAndPackages() ...
[17:47:53.703] Searching for globals...
[17:47:53.703] 
[17:47:53.704] Searching for globals ... DONE
[17:47:53.704] - globals: [0] <none>
[17:47:53.704] getGlobalsAndPackages() ... DONE
[17:47:53.704] resolve() on list ...
[17:47:53.704]  recursive: 0
[17:47:53.705]  length: 3
[17:47:53.705]  elements: ‘a’, ‘b’, ‘’
[17:47:53.705] run() for ‘Future’ ...
[17:47:53.705] - state: ‘created’
[17:47:53.705] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.710] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.710]   - Field: ‘label’
[17:47:53.710]   - Field: ‘local’
[17:47:53.711]   - Field: ‘owner’
[17:47:53.711]   - Field: ‘envir’
[17:47:53.711]   - Field: ‘workers’
[17:47:53.711]   - Field: ‘packages’
[17:47:53.711]   - Field: ‘gc’
[17:47:53.711]   - Field: ‘job’
[17:47:53.712]   - Field: ‘conditions’
[17:47:53.712]   - Field: ‘expr’
[17:47:53.712]   - Field: ‘uuid’
[17:47:53.712]   - Field: ‘seed’
[17:47:53.712]   - Field: ‘version’
[17:47:53.712]   - Field: ‘result’
[17:47:53.712]   - Field: ‘asynchronous’
[17:47:53.713]   - Field: ‘calls’
[17:47:53.713]   - Field: ‘globals’
[17:47:53.713]   - Field: ‘stdout’
[17:47:53.713]   - Field: ‘earlySignal’
[17:47:53.713]   - Field: ‘lazy’
[17:47:53.713]   - Field: ‘state’
[17:47:53.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.714] - Launch lazy future ...
[17:47:53.714] Packages needed by the future expression (n = 0): <none>
[17:47:53.714] Packages needed by future strategies (n = 0): <none>
[17:47:53.715] {
[17:47:53.715]     {
[17:47:53.715]         {
[17:47:53.715]             ...future.startTime <- base::Sys.time()
[17:47:53.715]             {
[17:47:53.715]                 {
[17:47:53.715]                   {
[17:47:53.715]                     {
[17:47:53.715]                       base::local({
[17:47:53.715]                         has_future <- base::requireNamespace("future", 
[17:47:53.715]                           quietly = TRUE)
[17:47:53.715]                         if (has_future) {
[17:47:53.715]                           ns <- base::getNamespace("future")
[17:47:53.715]                           version <- ns[[".package"]][["version"]]
[17:47:53.715]                           if (is.null(version)) 
[17:47:53.715]                             version <- utils::packageVersion("future")
[17:47:53.715]                         }
[17:47:53.715]                         else {
[17:47:53.715]                           version <- NULL
[17:47:53.715]                         }
[17:47:53.715]                         if (!has_future || version < "1.8.0") {
[17:47:53.715]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.715]                             "", base::R.version$version.string), 
[17:47:53.715]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.715]                               "release", "version")], collapse = " "), 
[17:47:53.715]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.715]                             info)
[17:47:53.715]                           info <- base::paste(info, collapse = "; ")
[17:47:53.715]                           if (!has_future) {
[17:47:53.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.715]                               info)
[17:47:53.715]                           }
[17:47:53.715]                           else {
[17:47:53.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.715]                               info, version)
[17:47:53.715]                           }
[17:47:53.715]                           base::stop(msg)
[17:47:53.715]                         }
[17:47:53.715]                       })
[17:47:53.715]                     }
[17:47:53.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.715]                     base::options(mc.cores = 1L)
[17:47:53.715]                   }
[17:47:53.715]                   ...future.strategy.old <- future::plan("list")
[17:47:53.715]                   options(future.plan = NULL)
[17:47:53.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.715]                 }
[17:47:53.715]                 ...future.workdir <- getwd()
[17:47:53.715]             }
[17:47:53.715]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.715]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.715]         }
[17:47:53.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.715]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.715]             base::names(...future.oldOptions))
[17:47:53.715]     }
[17:47:53.715]     if (FALSE) {
[17:47:53.715]     }
[17:47:53.715]     else {
[17:47:53.715]         if (TRUE) {
[17:47:53.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.715]                 open = "w")
[17:47:53.715]         }
[17:47:53.715]         else {
[17:47:53.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.715]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.715]         }
[17:47:53.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.715]             base::sink(type = "output", split = FALSE)
[17:47:53.715]             base::close(...future.stdout)
[17:47:53.715]         }, add = TRUE)
[17:47:53.715]     }
[17:47:53.715]     ...future.frame <- base::sys.nframe()
[17:47:53.715]     ...future.conditions <- base::list()
[17:47:53.715]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.715]     if (FALSE) {
[17:47:53.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.715]     }
[17:47:53.715]     ...future.result <- base::tryCatch({
[17:47:53.715]         base::withCallingHandlers({
[17:47:53.715]             ...future.value <- base::withVisible(base::local({
[17:47:53.715]                 withCallingHandlers({
[17:47:53.715]                   1
[17:47:53.715]                 }, immediateCondition = function(cond) {
[17:47:53.715]                   save_rds <- function (object, pathname, ...) 
[17:47:53.715]                   {
[17:47:53.715]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.715]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.715]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.715]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.715]                         fi_tmp[["mtime"]])
[17:47:53.715]                     }
[17:47:53.715]                     tryCatch({
[17:47:53.715]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.715]                     }, error = function(ex) {
[17:47:53.715]                       msg <- conditionMessage(ex)
[17:47:53.715]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.715]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.715]                         fi_tmp[["mtime"]], msg)
[17:47:53.715]                       ex$message <- msg
[17:47:53.715]                       stop(ex)
[17:47:53.715]                     })
[17:47:53.715]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.715]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.715]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.715]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.715]                       fi <- file.info(pathname)
[17:47:53.715]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.715]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.715]                         fi[["size"]], fi[["mtime"]])
[17:47:53.715]                       stop(msg)
[17:47:53.715]                     }
[17:47:53.715]                     invisible(pathname)
[17:47:53.715]                   }
[17:47:53.715]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.715]                     rootPath = tempdir()) 
[17:47:53.715]                   {
[17:47:53.715]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.715]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.715]                       tmpdir = path, fileext = ".rds")
[17:47:53.715]                     save_rds(obj, file)
[17:47:53.715]                   }
[17:47:53.715]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.715]                   {
[17:47:53.715]                     inherits <- base::inherits
[17:47:53.715]                     invokeRestart <- base::invokeRestart
[17:47:53.715]                     is.null <- base::is.null
[17:47:53.715]                     muffled <- FALSE
[17:47:53.715]                     if (inherits(cond, "message")) {
[17:47:53.715]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.715]                       if (muffled) 
[17:47:53.715]                         invokeRestart("muffleMessage")
[17:47:53.715]                     }
[17:47:53.715]                     else if (inherits(cond, "warning")) {
[17:47:53.715]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.715]                       if (muffled) 
[17:47:53.715]                         invokeRestart("muffleWarning")
[17:47:53.715]                     }
[17:47:53.715]                     else if (inherits(cond, "condition")) {
[17:47:53.715]                       if (!is.null(pattern)) {
[17:47:53.715]                         computeRestarts <- base::computeRestarts
[17:47:53.715]                         grepl <- base::grepl
[17:47:53.715]                         restarts <- computeRestarts(cond)
[17:47:53.715]                         for (restart in restarts) {
[17:47:53.715]                           name <- restart$name
[17:47:53.715]                           if (is.null(name)) 
[17:47:53.715]                             next
[17:47:53.715]                           if (!grepl(pattern, name)) 
[17:47:53.715]                             next
[17:47:53.715]                           invokeRestart(restart)
[17:47:53.715]                           muffled <- TRUE
[17:47:53.715]                           break
[17:47:53.715]                         }
[17:47:53.715]                       }
[17:47:53.715]                     }
[17:47:53.715]                     invisible(muffled)
[17:47:53.715]                   }
[17:47:53.715]                   muffleCondition(cond)
[17:47:53.715]                 })
[17:47:53.715]             }))
[17:47:53.715]             future::FutureResult(value = ...future.value$value, 
[17:47:53.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.715]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.715]                     ...future.globalenv.names))
[17:47:53.715]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.715]         }, condition = base::local({
[17:47:53.715]             c <- base::c
[17:47:53.715]             inherits <- base::inherits
[17:47:53.715]             invokeRestart <- base::invokeRestart
[17:47:53.715]             length <- base::length
[17:47:53.715]             list <- base::list
[17:47:53.715]             seq.int <- base::seq.int
[17:47:53.715]             signalCondition <- base::signalCondition
[17:47:53.715]             sys.calls <- base::sys.calls
[17:47:53.715]             `[[` <- base::`[[`
[17:47:53.715]             `+` <- base::`+`
[17:47:53.715]             `<<-` <- base::`<<-`
[17:47:53.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.715]                   3L)]
[17:47:53.715]             }
[17:47:53.715]             function(cond) {
[17:47:53.715]                 is_error <- inherits(cond, "error")
[17:47:53.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.715]                   NULL)
[17:47:53.715]                 if (is_error) {
[17:47:53.715]                   sessionInformation <- function() {
[17:47:53.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.715]                       search = base::search(), system = base::Sys.info())
[17:47:53.715]                   }
[17:47:53.715]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.715]                     cond$call), session = sessionInformation(), 
[17:47:53.715]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.715]                   signalCondition(cond)
[17:47:53.715]                 }
[17:47:53.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.715]                 "immediateCondition"))) {
[17:47:53.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.715]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.715]                   if (TRUE && !signal) {
[17:47:53.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.715]                     {
[17:47:53.715]                       inherits <- base::inherits
[17:47:53.715]                       invokeRestart <- base::invokeRestart
[17:47:53.715]                       is.null <- base::is.null
[17:47:53.715]                       muffled <- FALSE
[17:47:53.715]                       if (inherits(cond, "message")) {
[17:47:53.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.715]                         if (muffled) 
[17:47:53.715]                           invokeRestart("muffleMessage")
[17:47:53.715]                       }
[17:47:53.715]                       else if (inherits(cond, "warning")) {
[17:47:53.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.715]                         if (muffled) 
[17:47:53.715]                           invokeRestart("muffleWarning")
[17:47:53.715]                       }
[17:47:53.715]                       else if (inherits(cond, "condition")) {
[17:47:53.715]                         if (!is.null(pattern)) {
[17:47:53.715]                           computeRestarts <- base::computeRestarts
[17:47:53.715]                           grepl <- base::grepl
[17:47:53.715]                           restarts <- computeRestarts(cond)
[17:47:53.715]                           for (restart in restarts) {
[17:47:53.715]                             name <- restart$name
[17:47:53.715]                             if (is.null(name)) 
[17:47:53.715]                               next
[17:47:53.715]                             if (!grepl(pattern, name)) 
[17:47:53.715]                               next
[17:47:53.715]                             invokeRestart(restart)
[17:47:53.715]                             muffled <- TRUE
[17:47:53.715]                             break
[17:47:53.715]                           }
[17:47:53.715]                         }
[17:47:53.715]                       }
[17:47:53.715]                       invisible(muffled)
[17:47:53.715]                     }
[17:47:53.715]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.715]                   }
[17:47:53.715]                 }
[17:47:53.715]                 else {
[17:47:53.715]                   if (TRUE) {
[17:47:53.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.715]                     {
[17:47:53.715]                       inherits <- base::inherits
[17:47:53.715]                       invokeRestart <- base::invokeRestart
[17:47:53.715]                       is.null <- base::is.null
[17:47:53.715]                       muffled <- FALSE
[17:47:53.715]                       if (inherits(cond, "message")) {
[17:47:53.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.715]                         if (muffled) 
[17:47:53.715]                           invokeRestart("muffleMessage")
[17:47:53.715]                       }
[17:47:53.715]                       else if (inherits(cond, "warning")) {
[17:47:53.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.715]                         if (muffled) 
[17:47:53.715]                           invokeRestart("muffleWarning")
[17:47:53.715]                       }
[17:47:53.715]                       else if (inherits(cond, "condition")) {
[17:47:53.715]                         if (!is.null(pattern)) {
[17:47:53.715]                           computeRestarts <- base::computeRestarts
[17:47:53.715]                           grepl <- base::grepl
[17:47:53.715]                           restarts <- computeRestarts(cond)
[17:47:53.715]                           for (restart in restarts) {
[17:47:53.715]                             name <- restart$name
[17:47:53.715]                             if (is.null(name)) 
[17:47:53.715]                               next
[17:47:53.715]                             if (!grepl(pattern, name)) 
[17:47:53.715]                               next
[17:47:53.715]                             invokeRestart(restart)
[17:47:53.715]                             muffled <- TRUE
[17:47:53.715]                             break
[17:47:53.715]                           }
[17:47:53.715]                         }
[17:47:53.715]                       }
[17:47:53.715]                       invisible(muffled)
[17:47:53.715]                     }
[17:47:53.715]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.715]                   }
[17:47:53.715]                 }
[17:47:53.715]             }
[17:47:53.715]         }))
[17:47:53.715]     }, error = function(ex) {
[17:47:53.715]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.715]                 ...future.rng), started = ...future.startTime, 
[17:47:53.715]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.715]             version = "1.8"), class = "FutureResult")
[17:47:53.715]     }, finally = {
[17:47:53.715]         if (!identical(...future.workdir, getwd())) 
[17:47:53.715]             setwd(...future.workdir)
[17:47:53.715]         {
[17:47:53.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.715]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.715]             }
[17:47:53.715]             base::options(...future.oldOptions)
[17:47:53.715]             if (.Platform$OS.type == "windows") {
[17:47:53.715]                 old_names <- names(...future.oldEnvVars)
[17:47:53.715]                 envs <- base::Sys.getenv()
[17:47:53.715]                 names <- names(envs)
[17:47:53.715]                 common <- intersect(names, old_names)
[17:47:53.715]                 added <- setdiff(names, old_names)
[17:47:53.715]                 removed <- setdiff(old_names, names)
[17:47:53.715]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.715]                   envs[common]]
[17:47:53.715]                 NAMES <- toupper(changed)
[17:47:53.715]                 args <- list()
[17:47:53.715]                 for (kk in seq_along(NAMES)) {
[17:47:53.715]                   name <- changed[[kk]]
[17:47:53.715]                   NAME <- NAMES[[kk]]
[17:47:53.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.715]                     next
[17:47:53.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.715]                 }
[17:47:53.715]                 NAMES <- toupper(added)
[17:47:53.715]                 for (kk in seq_along(NAMES)) {
[17:47:53.715]                   name <- added[[kk]]
[17:47:53.715]                   NAME <- NAMES[[kk]]
[17:47:53.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.715]                     next
[17:47:53.715]                   args[[name]] <- ""
[17:47:53.715]                 }
[17:47:53.715]                 NAMES <- toupper(removed)
[17:47:53.715]                 for (kk in seq_along(NAMES)) {
[17:47:53.715]                   name <- removed[[kk]]
[17:47:53.715]                   NAME <- NAMES[[kk]]
[17:47:53.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.715]                     next
[17:47:53.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.715]                 }
[17:47:53.715]                 if (length(args) > 0) 
[17:47:53.715]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.715]             }
[17:47:53.715]             else {
[17:47:53.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.715]             }
[17:47:53.715]             {
[17:47:53.715]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.715]                   0L) {
[17:47:53.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.715]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.715]                   base::options(opts)
[17:47:53.715]                 }
[17:47:53.715]                 {
[17:47:53.715]                   {
[17:47:53.715]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.715]                     NULL
[17:47:53.715]                   }
[17:47:53.715]                   options(future.plan = NULL)
[17:47:53.715]                   if (is.na(NA_character_)) 
[17:47:53.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.715]                     .init = FALSE)
[17:47:53.715]                 }
[17:47:53.715]             }
[17:47:53.715]         }
[17:47:53.715]     })
[17:47:53.715]     if (TRUE) {
[17:47:53.715]         base::sink(type = "output", split = FALSE)
[17:47:53.715]         if (TRUE) {
[17:47:53.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.715]         }
[17:47:53.715]         else {
[17:47:53.715]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.715]         }
[17:47:53.715]         base::close(...future.stdout)
[17:47:53.715]         ...future.stdout <- NULL
[17:47:53.715]     }
[17:47:53.715]     ...future.result$conditions <- ...future.conditions
[17:47:53.715]     ...future.result$finished <- base::Sys.time()
[17:47:53.715]     ...future.result
[17:47:53.715] }
[17:47:53.718] requestCore(): workers = 2
[17:47:53.719] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:53.729] result() for MulticoreFuture ...
[17:47:53.730] result() for MulticoreFuture ...
[17:47:53.730] result() for MulticoreFuture ... done
[17:47:53.731] result() for MulticoreFuture ... done
[17:47:53.731] result() for MulticoreFuture ...
[17:47:53.731] result() for MulticoreFuture ... done
[17:47:53.734] MulticoreFuture started
[17:47:53.734] - Launch lazy future ... done
[17:47:53.734] run() for ‘MulticoreFuture’ ... done
[17:47:53.735] plan(): Setting new future strategy stack:
[17:47:53.735] List of future strategies:
[17:47:53.735] 1. sequential:
[17:47:53.735]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.735]    - tweaked: FALSE
[17:47:53.735]    - call: NULL
[17:47:53.736] plan(): nbrOfWorkers() = 1
[17:47:53.739] plan(): Setting new future strategy stack:
[17:47:53.739] List of future strategies:
[17:47:53.739] 1. multicore:
[17:47:53.739]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.739]    - tweaked: FALSE
[17:47:53.739]    - call: plan(strategy)
[17:47:53.744] plan(): nbrOfWorkers() = 2
[17:47:53.745] Future #1
[17:47:53.745]  length: 2 (resolved future 1)
[17:47:53.745] run() for ‘Future’ ...
[17:47:53.745] - state: ‘created’
[17:47:53.745] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.750] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.750]   - Field: ‘label’
[17:47:53.750]   - Field: ‘local’
[17:47:53.751]   - Field: ‘owner’
[17:47:53.751]   - Field: ‘envir’
[17:47:53.751]   - Field: ‘workers’
[17:47:53.751]   - Field: ‘packages’
[17:47:53.751]   - Field: ‘gc’
[17:47:53.751]   - Field: ‘job’
[17:47:53.752]   - Field: ‘conditions’
[17:47:53.752]   - Field: ‘expr’
[17:47:53.752]   - Field: ‘uuid’
[17:47:53.752]   - Field: ‘seed’
[17:47:53.752]   - Field: ‘version’
[17:47:53.752]   - Field: ‘result’
[17:47:53.752]   - Field: ‘asynchronous’
[17:47:53.753]   - Field: ‘calls’
[17:47:53.753]   - Field: ‘globals’
[17:47:53.753]   - Field: ‘stdout’
[17:47:53.753]   - Field: ‘earlySignal’
[17:47:53.753]   - Field: ‘lazy’
[17:47:53.753]   - Field: ‘state’
[17:47:53.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.754] - Launch lazy future ...
[17:47:53.754] Packages needed by the future expression (n = 0): <none>
[17:47:53.754] Packages needed by future strategies (n = 0): <none>
[17:47:53.755] {
[17:47:53.755]     {
[17:47:53.755]         {
[17:47:53.755]             ...future.startTime <- base::Sys.time()
[17:47:53.755]             {
[17:47:53.755]                 {
[17:47:53.755]                   {
[17:47:53.755]                     {
[17:47:53.755]                       base::local({
[17:47:53.755]                         has_future <- base::requireNamespace("future", 
[17:47:53.755]                           quietly = TRUE)
[17:47:53.755]                         if (has_future) {
[17:47:53.755]                           ns <- base::getNamespace("future")
[17:47:53.755]                           version <- ns[[".package"]][["version"]]
[17:47:53.755]                           if (is.null(version)) 
[17:47:53.755]                             version <- utils::packageVersion("future")
[17:47:53.755]                         }
[17:47:53.755]                         else {
[17:47:53.755]                           version <- NULL
[17:47:53.755]                         }
[17:47:53.755]                         if (!has_future || version < "1.8.0") {
[17:47:53.755]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.755]                             "", base::R.version$version.string), 
[17:47:53.755]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.755]                               "release", "version")], collapse = " "), 
[17:47:53.755]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.755]                             info)
[17:47:53.755]                           info <- base::paste(info, collapse = "; ")
[17:47:53.755]                           if (!has_future) {
[17:47:53.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.755]                               info)
[17:47:53.755]                           }
[17:47:53.755]                           else {
[17:47:53.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.755]                               info, version)
[17:47:53.755]                           }
[17:47:53.755]                           base::stop(msg)
[17:47:53.755]                         }
[17:47:53.755]                       })
[17:47:53.755]                     }
[17:47:53.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.755]                     base::options(mc.cores = 1L)
[17:47:53.755]                   }
[17:47:53.755]                   ...future.strategy.old <- future::plan("list")
[17:47:53.755]                   options(future.plan = NULL)
[17:47:53.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.755]                 }
[17:47:53.755]                 ...future.workdir <- getwd()
[17:47:53.755]             }
[17:47:53.755]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.755]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.755]         }
[17:47:53.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.755]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.755]             base::names(...future.oldOptions))
[17:47:53.755]     }
[17:47:53.755]     if (FALSE) {
[17:47:53.755]     }
[17:47:53.755]     else {
[17:47:53.755]         if (TRUE) {
[17:47:53.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.755]                 open = "w")
[17:47:53.755]         }
[17:47:53.755]         else {
[17:47:53.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.755]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.755]         }
[17:47:53.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.755]             base::sink(type = "output", split = FALSE)
[17:47:53.755]             base::close(...future.stdout)
[17:47:53.755]         }, add = TRUE)
[17:47:53.755]     }
[17:47:53.755]     ...future.frame <- base::sys.nframe()
[17:47:53.755]     ...future.conditions <- base::list()
[17:47:53.755]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.755]     if (FALSE) {
[17:47:53.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.755]     }
[17:47:53.755]     ...future.result <- base::tryCatch({
[17:47:53.755]         base::withCallingHandlers({
[17:47:53.755]             ...future.value <- base::withVisible(base::local({
[17:47:53.755]                 withCallingHandlers({
[17:47:53.755]                   2
[17:47:53.755]                 }, immediateCondition = function(cond) {
[17:47:53.755]                   save_rds <- function (object, pathname, ...) 
[17:47:53.755]                   {
[17:47:53.755]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.755]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.755]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.755]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.755]                         fi_tmp[["mtime"]])
[17:47:53.755]                     }
[17:47:53.755]                     tryCatch({
[17:47:53.755]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.755]                     }, error = function(ex) {
[17:47:53.755]                       msg <- conditionMessage(ex)
[17:47:53.755]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.755]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.755]                         fi_tmp[["mtime"]], msg)
[17:47:53.755]                       ex$message <- msg
[17:47:53.755]                       stop(ex)
[17:47:53.755]                     })
[17:47:53.755]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.755]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.755]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.755]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.755]                       fi <- file.info(pathname)
[17:47:53.755]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.755]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.755]                         fi[["size"]], fi[["mtime"]])
[17:47:53.755]                       stop(msg)
[17:47:53.755]                     }
[17:47:53.755]                     invisible(pathname)
[17:47:53.755]                   }
[17:47:53.755]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.755]                     rootPath = tempdir()) 
[17:47:53.755]                   {
[17:47:53.755]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.755]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.755]                       tmpdir = path, fileext = ".rds")
[17:47:53.755]                     save_rds(obj, file)
[17:47:53.755]                   }
[17:47:53.755]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.755]                   {
[17:47:53.755]                     inherits <- base::inherits
[17:47:53.755]                     invokeRestart <- base::invokeRestart
[17:47:53.755]                     is.null <- base::is.null
[17:47:53.755]                     muffled <- FALSE
[17:47:53.755]                     if (inherits(cond, "message")) {
[17:47:53.755]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.755]                       if (muffled) 
[17:47:53.755]                         invokeRestart("muffleMessage")
[17:47:53.755]                     }
[17:47:53.755]                     else if (inherits(cond, "warning")) {
[17:47:53.755]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.755]                       if (muffled) 
[17:47:53.755]                         invokeRestart("muffleWarning")
[17:47:53.755]                     }
[17:47:53.755]                     else if (inherits(cond, "condition")) {
[17:47:53.755]                       if (!is.null(pattern)) {
[17:47:53.755]                         computeRestarts <- base::computeRestarts
[17:47:53.755]                         grepl <- base::grepl
[17:47:53.755]                         restarts <- computeRestarts(cond)
[17:47:53.755]                         for (restart in restarts) {
[17:47:53.755]                           name <- restart$name
[17:47:53.755]                           if (is.null(name)) 
[17:47:53.755]                             next
[17:47:53.755]                           if (!grepl(pattern, name)) 
[17:47:53.755]                             next
[17:47:53.755]                           invokeRestart(restart)
[17:47:53.755]                           muffled <- TRUE
[17:47:53.755]                           break
[17:47:53.755]                         }
[17:47:53.755]                       }
[17:47:53.755]                     }
[17:47:53.755]                     invisible(muffled)
[17:47:53.755]                   }
[17:47:53.755]                   muffleCondition(cond)
[17:47:53.755]                 })
[17:47:53.755]             }))
[17:47:53.755]             future::FutureResult(value = ...future.value$value, 
[17:47:53.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.755]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.755]                     ...future.globalenv.names))
[17:47:53.755]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.755]         }, condition = base::local({
[17:47:53.755]             c <- base::c
[17:47:53.755]             inherits <- base::inherits
[17:47:53.755]             invokeRestart <- base::invokeRestart
[17:47:53.755]             length <- base::length
[17:47:53.755]             list <- base::list
[17:47:53.755]             seq.int <- base::seq.int
[17:47:53.755]             signalCondition <- base::signalCondition
[17:47:53.755]             sys.calls <- base::sys.calls
[17:47:53.755]             `[[` <- base::`[[`
[17:47:53.755]             `+` <- base::`+`
[17:47:53.755]             `<<-` <- base::`<<-`
[17:47:53.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.755]                   3L)]
[17:47:53.755]             }
[17:47:53.755]             function(cond) {
[17:47:53.755]                 is_error <- inherits(cond, "error")
[17:47:53.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.755]                   NULL)
[17:47:53.755]                 if (is_error) {
[17:47:53.755]                   sessionInformation <- function() {
[17:47:53.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.755]                       search = base::search(), system = base::Sys.info())
[17:47:53.755]                   }
[17:47:53.755]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.755]                     cond$call), session = sessionInformation(), 
[17:47:53.755]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.755]                   signalCondition(cond)
[17:47:53.755]                 }
[17:47:53.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.755]                 "immediateCondition"))) {
[17:47:53.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.755]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.755]                   if (TRUE && !signal) {
[17:47:53.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.755]                     {
[17:47:53.755]                       inherits <- base::inherits
[17:47:53.755]                       invokeRestart <- base::invokeRestart
[17:47:53.755]                       is.null <- base::is.null
[17:47:53.755]                       muffled <- FALSE
[17:47:53.755]                       if (inherits(cond, "message")) {
[17:47:53.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.755]                         if (muffled) 
[17:47:53.755]                           invokeRestart("muffleMessage")
[17:47:53.755]                       }
[17:47:53.755]                       else if (inherits(cond, "warning")) {
[17:47:53.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.755]                         if (muffled) 
[17:47:53.755]                           invokeRestart("muffleWarning")
[17:47:53.755]                       }
[17:47:53.755]                       else if (inherits(cond, "condition")) {
[17:47:53.755]                         if (!is.null(pattern)) {
[17:47:53.755]                           computeRestarts <- base::computeRestarts
[17:47:53.755]                           grepl <- base::grepl
[17:47:53.755]                           restarts <- computeRestarts(cond)
[17:47:53.755]                           for (restart in restarts) {
[17:47:53.755]                             name <- restart$name
[17:47:53.755]                             if (is.null(name)) 
[17:47:53.755]                               next
[17:47:53.755]                             if (!grepl(pattern, name)) 
[17:47:53.755]                               next
[17:47:53.755]                             invokeRestart(restart)
[17:47:53.755]                             muffled <- TRUE
[17:47:53.755]                             break
[17:47:53.755]                           }
[17:47:53.755]                         }
[17:47:53.755]                       }
[17:47:53.755]                       invisible(muffled)
[17:47:53.755]                     }
[17:47:53.755]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.755]                   }
[17:47:53.755]                 }
[17:47:53.755]                 else {
[17:47:53.755]                   if (TRUE) {
[17:47:53.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.755]                     {
[17:47:53.755]                       inherits <- base::inherits
[17:47:53.755]                       invokeRestart <- base::invokeRestart
[17:47:53.755]                       is.null <- base::is.null
[17:47:53.755]                       muffled <- FALSE
[17:47:53.755]                       if (inherits(cond, "message")) {
[17:47:53.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.755]                         if (muffled) 
[17:47:53.755]                           invokeRestart("muffleMessage")
[17:47:53.755]                       }
[17:47:53.755]                       else if (inherits(cond, "warning")) {
[17:47:53.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.755]                         if (muffled) 
[17:47:53.755]                           invokeRestart("muffleWarning")
[17:47:53.755]                       }
[17:47:53.755]                       else if (inherits(cond, "condition")) {
[17:47:53.755]                         if (!is.null(pattern)) {
[17:47:53.755]                           computeRestarts <- base::computeRestarts
[17:47:53.755]                           grepl <- base::grepl
[17:47:53.755]                           restarts <- computeRestarts(cond)
[17:47:53.755]                           for (restart in restarts) {
[17:47:53.755]                             name <- restart$name
[17:47:53.755]                             if (is.null(name)) 
[17:47:53.755]                               next
[17:47:53.755]                             if (!grepl(pattern, name)) 
[17:47:53.755]                               next
[17:47:53.755]                             invokeRestart(restart)
[17:47:53.755]                             muffled <- TRUE
[17:47:53.755]                             break
[17:47:53.755]                           }
[17:47:53.755]                         }
[17:47:53.755]                       }
[17:47:53.755]                       invisible(muffled)
[17:47:53.755]                     }
[17:47:53.755]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.755]                   }
[17:47:53.755]                 }
[17:47:53.755]             }
[17:47:53.755]         }))
[17:47:53.755]     }, error = function(ex) {
[17:47:53.755]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.755]                 ...future.rng), started = ...future.startTime, 
[17:47:53.755]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.755]             version = "1.8"), class = "FutureResult")
[17:47:53.755]     }, finally = {
[17:47:53.755]         if (!identical(...future.workdir, getwd())) 
[17:47:53.755]             setwd(...future.workdir)
[17:47:53.755]         {
[17:47:53.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.755]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.755]             }
[17:47:53.755]             base::options(...future.oldOptions)
[17:47:53.755]             if (.Platform$OS.type == "windows") {
[17:47:53.755]                 old_names <- names(...future.oldEnvVars)
[17:47:53.755]                 envs <- base::Sys.getenv()
[17:47:53.755]                 names <- names(envs)
[17:47:53.755]                 common <- intersect(names, old_names)
[17:47:53.755]                 added <- setdiff(names, old_names)
[17:47:53.755]                 removed <- setdiff(old_names, names)
[17:47:53.755]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.755]                   envs[common]]
[17:47:53.755]                 NAMES <- toupper(changed)
[17:47:53.755]                 args <- list()
[17:47:53.755]                 for (kk in seq_along(NAMES)) {
[17:47:53.755]                   name <- changed[[kk]]
[17:47:53.755]                   NAME <- NAMES[[kk]]
[17:47:53.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.755]                     next
[17:47:53.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.755]                 }
[17:47:53.755]                 NAMES <- toupper(added)
[17:47:53.755]                 for (kk in seq_along(NAMES)) {
[17:47:53.755]                   name <- added[[kk]]
[17:47:53.755]                   NAME <- NAMES[[kk]]
[17:47:53.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.755]                     next
[17:47:53.755]                   args[[name]] <- ""
[17:47:53.755]                 }
[17:47:53.755]                 NAMES <- toupper(removed)
[17:47:53.755]                 for (kk in seq_along(NAMES)) {
[17:47:53.755]                   name <- removed[[kk]]
[17:47:53.755]                   NAME <- NAMES[[kk]]
[17:47:53.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.755]                     next
[17:47:53.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.755]                 }
[17:47:53.755]                 if (length(args) > 0) 
[17:47:53.755]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.755]             }
[17:47:53.755]             else {
[17:47:53.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.755]             }
[17:47:53.755]             {
[17:47:53.755]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.755]                   0L) {
[17:47:53.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.755]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.755]                   base::options(opts)
[17:47:53.755]                 }
[17:47:53.755]                 {
[17:47:53.755]                   {
[17:47:53.755]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.755]                     NULL
[17:47:53.755]                   }
[17:47:53.755]                   options(future.plan = NULL)
[17:47:53.755]                   if (is.na(NA_character_)) 
[17:47:53.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.755]                     .init = FALSE)
[17:47:53.755]                 }
[17:47:53.755]             }
[17:47:53.755]         }
[17:47:53.755]     })
[17:47:53.755]     if (TRUE) {
[17:47:53.755]         base::sink(type = "output", split = FALSE)
[17:47:53.755]         if (TRUE) {
[17:47:53.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.755]         }
[17:47:53.755]         else {
[17:47:53.755]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.755]         }
[17:47:53.755]         base::close(...future.stdout)
[17:47:53.755]         ...future.stdout <- NULL
[17:47:53.755]     }
[17:47:53.755]     ...future.result$conditions <- ...future.conditions
[17:47:53.755]     ...future.result$finished <- base::Sys.time()
[17:47:53.755]     ...future.result
[17:47:53.755] }
[17:47:53.758] requestCore(): workers = 2
[17:47:53.759] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:53.769] result() for MulticoreFuture ...
[17:47:53.770] result() for MulticoreFuture ...
[17:47:53.771] result() for MulticoreFuture ... done
[17:47:53.771] result() for MulticoreFuture ... done
[17:47:53.771] result() for MulticoreFuture ...
[17:47:53.771] result() for MulticoreFuture ... done
[17:47:53.774] MulticoreFuture started
[17:47:53.774] - Launch lazy future ... done
[17:47:53.775] run() for ‘MulticoreFuture’ ... done
[17:47:53.775] plan(): Setting new future strategy stack:
[17:47:53.775] List of future strategies:
[17:47:53.775] 1. sequential:
[17:47:53.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.775]    - tweaked: FALSE
[17:47:53.775]    - call: NULL
[17:47:53.776] plan(): nbrOfWorkers() = 1
[17:47:53.779] plan(): Setting new future strategy stack:
[17:47:53.779] List of future strategies:
[17:47:53.779] 1. multicore:
[17:47:53.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.779]    - tweaked: FALSE
[17:47:53.779]    - call: plan(strategy)
[17:47:53.784] plan(): nbrOfWorkers() = 2
[17:47:53.784] Future #2
[17:47:53.785]  length: 1 (resolved future 2)
[17:47:53.785]  length: 0 (resolved future 3)
[17:47:53.785] resolve() on list ... DONE
[17:47:53.785] getGlobalsAndPackages() ...
[17:47:53.786] Searching for globals...
[17:47:53.786] 
[17:47:53.787] Searching for globals ... DONE
[17:47:53.787] - globals: [0] <none>
[17:47:53.787] getGlobalsAndPackages() ... DONE
[17:47:53.787] run() for ‘Future’ ...
[17:47:53.788] - state: ‘created’
[17:47:53.788] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.792] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.793]   - Field: ‘label’
[17:47:53.793]   - Field: ‘local’
[17:47:53.793]   - Field: ‘owner’
[17:47:53.793]   - Field: ‘envir’
[17:47:53.793]   - Field: ‘workers’
[17:47:53.793]   - Field: ‘packages’
[17:47:53.794]   - Field: ‘gc’
[17:47:53.794]   - Field: ‘job’
[17:47:53.794]   - Field: ‘conditions’
[17:47:53.794]   - Field: ‘expr’
[17:47:53.794]   - Field: ‘uuid’
[17:47:53.794]   - Field: ‘seed’
[17:47:53.794]   - Field: ‘version’
[17:47:53.795]   - Field: ‘result’
[17:47:53.795]   - Field: ‘asynchronous’
[17:47:53.795]   - Field: ‘calls’
[17:47:53.795]   - Field: ‘globals’
[17:47:53.795]   - Field: ‘stdout’
[17:47:53.795]   - Field: ‘earlySignal’
[17:47:53.795]   - Field: ‘lazy’
[17:47:53.796]   - Field: ‘state’
[17:47:53.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.796] - Launch lazy future ...
[17:47:53.796] Packages needed by the future expression (n = 0): <none>
[17:47:53.797] Packages needed by future strategies (n = 0): <none>
[17:47:53.802] {
[17:47:53.802]     {
[17:47:53.802]         {
[17:47:53.802]             ...future.startTime <- base::Sys.time()
[17:47:53.802]             {
[17:47:53.802]                 {
[17:47:53.802]                   {
[17:47:53.802]                     {
[17:47:53.802]                       base::local({
[17:47:53.802]                         has_future <- base::requireNamespace("future", 
[17:47:53.802]                           quietly = TRUE)
[17:47:53.802]                         if (has_future) {
[17:47:53.802]                           ns <- base::getNamespace("future")
[17:47:53.802]                           version <- ns[[".package"]][["version"]]
[17:47:53.802]                           if (is.null(version)) 
[17:47:53.802]                             version <- utils::packageVersion("future")
[17:47:53.802]                         }
[17:47:53.802]                         else {
[17:47:53.802]                           version <- NULL
[17:47:53.802]                         }
[17:47:53.802]                         if (!has_future || version < "1.8.0") {
[17:47:53.802]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.802]                             "", base::R.version$version.string), 
[17:47:53.802]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.802]                               "release", "version")], collapse = " "), 
[17:47:53.802]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.802]                             info)
[17:47:53.802]                           info <- base::paste(info, collapse = "; ")
[17:47:53.802]                           if (!has_future) {
[17:47:53.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.802]                               info)
[17:47:53.802]                           }
[17:47:53.802]                           else {
[17:47:53.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.802]                               info, version)
[17:47:53.802]                           }
[17:47:53.802]                           base::stop(msg)
[17:47:53.802]                         }
[17:47:53.802]                       })
[17:47:53.802]                     }
[17:47:53.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.802]                     base::options(mc.cores = 1L)
[17:47:53.802]                   }
[17:47:53.802]                   ...future.strategy.old <- future::plan("list")
[17:47:53.802]                   options(future.plan = NULL)
[17:47:53.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.802]                 }
[17:47:53.802]                 ...future.workdir <- getwd()
[17:47:53.802]             }
[17:47:53.802]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.802]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.802]         }
[17:47:53.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.802]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.802]             base::names(...future.oldOptions))
[17:47:53.802]     }
[17:47:53.802]     if (FALSE) {
[17:47:53.802]     }
[17:47:53.802]     else {
[17:47:53.802]         if (TRUE) {
[17:47:53.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.802]                 open = "w")
[17:47:53.802]         }
[17:47:53.802]         else {
[17:47:53.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.802]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.802]         }
[17:47:53.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.802]             base::sink(type = "output", split = FALSE)
[17:47:53.802]             base::close(...future.stdout)
[17:47:53.802]         }, add = TRUE)
[17:47:53.802]     }
[17:47:53.802]     ...future.frame <- base::sys.nframe()
[17:47:53.802]     ...future.conditions <- base::list()
[17:47:53.802]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.802]     if (FALSE) {
[17:47:53.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.802]     }
[17:47:53.802]     ...future.result <- base::tryCatch({
[17:47:53.802]         base::withCallingHandlers({
[17:47:53.802]             ...future.value <- base::withVisible(base::local({
[17:47:53.802]                 withCallingHandlers({
[17:47:53.802]                   1
[17:47:53.802]                 }, immediateCondition = function(cond) {
[17:47:53.802]                   save_rds <- function (object, pathname, ...) 
[17:47:53.802]                   {
[17:47:53.802]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.802]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.802]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.802]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.802]                         fi_tmp[["mtime"]])
[17:47:53.802]                     }
[17:47:53.802]                     tryCatch({
[17:47:53.802]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.802]                     }, error = function(ex) {
[17:47:53.802]                       msg <- conditionMessage(ex)
[17:47:53.802]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.802]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.802]                         fi_tmp[["mtime"]], msg)
[17:47:53.802]                       ex$message <- msg
[17:47:53.802]                       stop(ex)
[17:47:53.802]                     })
[17:47:53.802]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.802]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.802]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.802]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.802]                       fi <- file.info(pathname)
[17:47:53.802]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.802]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.802]                         fi[["size"]], fi[["mtime"]])
[17:47:53.802]                       stop(msg)
[17:47:53.802]                     }
[17:47:53.802]                     invisible(pathname)
[17:47:53.802]                   }
[17:47:53.802]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.802]                     rootPath = tempdir()) 
[17:47:53.802]                   {
[17:47:53.802]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.802]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.802]                       tmpdir = path, fileext = ".rds")
[17:47:53.802]                     save_rds(obj, file)
[17:47:53.802]                   }
[17:47:53.802]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.802]                   {
[17:47:53.802]                     inherits <- base::inherits
[17:47:53.802]                     invokeRestart <- base::invokeRestart
[17:47:53.802]                     is.null <- base::is.null
[17:47:53.802]                     muffled <- FALSE
[17:47:53.802]                     if (inherits(cond, "message")) {
[17:47:53.802]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.802]                       if (muffled) 
[17:47:53.802]                         invokeRestart("muffleMessage")
[17:47:53.802]                     }
[17:47:53.802]                     else if (inherits(cond, "warning")) {
[17:47:53.802]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.802]                       if (muffled) 
[17:47:53.802]                         invokeRestart("muffleWarning")
[17:47:53.802]                     }
[17:47:53.802]                     else if (inherits(cond, "condition")) {
[17:47:53.802]                       if (!is.null(pattern)) {
[17:47:53.802]                         computeRestarts <- base::computeRestarts
[17:47:53.802]                         grepl <- base::grepl
[17:47:53.802]                         restarts <- computeRestarts(cond)
[17:47:53.802]                         for (restart in restarts) {
[17:47:53.802]                           name <- restart$name
[17:47:53.802]                           if (is.null(name)) 
[17:47:53.802]                             next
[17:47:53.802]                           if (!grepl(pattern, name)) 
[17:47:53.802]                             next
[17:47:53.802]                           invokeRestart(restart)
[17:47:53.802]                           muffled <- TRUE
[17:47:53.802]                           break
[17:47:53.802]                         }
[17:47:53.802]                       }
[17:47:53.802]                     }
[17:47:53.802]                     invisible(muffled)
[17:47:53.802]                   }
[17:47:53.802]                   muffleCondition(cond)
[17:47:53.802]                 })
[17:47:53.802]             }))
[17:47:53.802]             future::FutureResult(value = ...future.value$value, 
[17:47:53.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.802]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.802]                     ...future.globalenv.names))
[17:47:53.802]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.802]         }, condition = base::local({
[17:47:53.802]             c <- base::c
[17:47:53.802]             inherits <- base::inherits
[17:47:53.802]             invokeRestart <- base::invokeRestart
[17:47:53.802]             length <- base::length
[17:47:53.802]             list <- base::list
[17:47:53.802]             seq.int <- base::seq.int
[17:47:53.802]             signalCondition <- base::signalCondition
[17:47:53.802]             sys.calls <- base::sys.calls
[17:47:53.802]             `[[` <- base::`[[`
[17:47:53.802]             `+` <- base::`+`
[17:47:53.802]             `<<-` <- base::`<<-`
[17:47:53.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.802]                   3L)]
[17:47:53.802]             }
[17:47:53.802]             function(cond) {
[17:47:53.802]                 is_error <- inherits(cond, "error")
[17:47:53.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.802]                   NULL)
[17:47:53.802]                 if (is_error) {
[17:47:53.802]                   sessionInformation <- function() {
[17:47:53.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.802]                       search = base::search(), system = base::Sys.info())
[17:47:53.802]                   }
[17:47:53.802]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.802]                     cond$call), session = sessionInformation(), 
[17:47:53.802]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.802]                   signalCondition(cond)
[17:47:53.802]                 }
[17:47:53.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.802]                 "immediateCondition"))) {
[17:47:53.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.802]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.802]                   if (TRUE && !signal) {
[17:47:53.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.802]                     {
[17:47:53.802]                       inherits <- base::inherits
[17:47:53.802]                       invokeRestart <- base::invokeRestart
[17:47:53.802]                       is.null <- base::is.null
[17:47:53.802]                       muffled <- FALSE
[17:47:53.802]                       if (inherits(cond, "message")) {
[17:47:53.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.802]                         if (muffled) 
[17:47:53.802]                           invokeRestart("muffleMessage")
[17:47:53.802]                       }
[17:47:53.802]                       else if (inherits(cond, "warning")) {
[17:47:53.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.802]                         if (muffled) 
[17:47:53.802]                           invokeRestart("muffleWarning")
[17:47:53.802]                       }
[17:47:53.802]                       else if (inherits(cond, "condition")) {
[17:47:53.802]                         if (!is.null(pattern)) {
[17:47:53.802]                           computeRestarts <- base::computeRestarts
[17:47:53.802]                           grepl <- base::grepl
[17:47:53.802]                           restarts <- computeRestarts(cond)
[17:47:53.802]                           for (restart in restarts) {
[17:47:53.802]                             name <- restart$name
[17:47:53.802]                             if (is.null(name)) 
[17:47:53.802]                               next
[17:47:53.802]                             if (!grepl(pattern, name)) 
[17:47:53.802]                               next
[17:47:53.802]                             invokeRestart(restart)
[17:47:53.802]                             muffled <- TRUE
[17:47:53.802]                             break
[17:47:53.802]                           }
[17:47:53.802]                         }
[17:47:53.802]                       }
[17:47:53.802]                       invisible(muffled)
[17:47:53.802]                     }
[17:47:53.802]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.802]                   }
[17:47:53.802]                 }
[17:47:53.802]                 else {
[17:47:53.802]                   if (TRUE) {
[17:47:53.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.802]                     {
[17:47:53.802]                       inherits <- base::inherits
[17:47:53.802]                       invokeRestart <- base::invokeRestart
[17:47:53.802]                       is.null <- base::is.null
[17:47:53.802]                       muffled <- FALSE
[17:47:53.802]                       if (inherits(cond, "message")) {
[17:47:53.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.802]                         if (muffled) 
[17:47:53.802]                           invokeRestart("muffleMessage")
[17:47:53.802]                       }
[17:47:53.802]                       else if (inherits(cond, "warning")) {
[17:47:53.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.802]                         if (muffled) 
[17:47:53.802]                           invokeRestart("muffleWarning")
[17:47:53.802]                       }
[17:47:53.802]                       else if (inherits(cond, "condition")) {
[17:47:53.802]                         if (!is.null(pattern)) {
[17:47:53.802]                           computeRestarts <- base::computeRestarts
[17:47:53.802]                           grepl <- base::grepl
[17:47:53.802]                           restarts <- computeRestarts(cond)
[17:47:53.802]                           for (restart in restarts) {
[17:47:53.802]                             name <- restart$name
[17:47:53.802]                             if (is.null(name)) 
[17:47:53.802]                               next
[17:47:53.802]                             if (!grepl(pattern, name)) 
[17:47:53.802]                               next
[17:47:53.802]                             invokeRestart(restart)
[17:47:53.802]                             muffled <- TRUE
[17:47:53.802]                             break
[17:47:53.802]                           }
[17:47:53.802]                         }
[17:47:53.802]                       }
[17:47:53.802]                       invisible(muffled)
[17:47:53.802]                     }
[17:47:53.802]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.802]                   }
[17:47:53.802]                 }
[17:47:53.802]             }
[17:47:53.802]         }))
[17:47:53.802]     }, error = function(ex) {
[17:47:53.802]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.802]                 ...future.rng), started = ...future.startTime, 
[17:47:53.802]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.802]             version = "1.8"), class = "FutureResult")
[17:47:53.802]     }, finally = {
[17:47:53.802]         if (!identical(...future.workdir, getwd())) 
[17:47:53.802]             setwd(...future.workdir)
[17:47:53.802]         {
[17:47:53.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.802]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.802]             }
[17:47:53.802]             base::options(...future.oldOptions)
[17:47:53.802]             if (.Platform$OS.type == "windows") {
[17:47:53.802]                 old_names <- names(...future.oldEnvVars)
[17:47:53.802]                 envs <- base::Sys.getenv()
[17:47:53.802]                 names <- names(envs)
[17:47:53.802]                 common <- intersect(names, old_names)
[17:47:53.802]                 added <- setdiff(names, old_names)
[17:47:53.802]                 removed <- setdiff(old_names, names)
[17:47:53.802]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.802]                   envs[common]]
[17:47:53.802]                 NAMES <- toupper(changed)
[17:47:53.802]                 args <- list()
[17:47:53.802]                 for (kk in seq_along(NAMES)) {
[17:47:53.802]                   name <- changed[[kk]]
[17:47:53.802]                   NAME <- NAMES[[kk]]
[17:47:53.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.802]                     next
[17:47:53.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.802]                 }
[17:47:53.802]                 NAMES <- toupper(added)
[17:47:53.802]                 for (kk in seq_along(NAMES)) {
[17:47:53.802]                   name <- added[[kk]]
[17:47:53.802]                   NAME <- NAMES[[kk]]
[17:47:53.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.802]                     next
[17:47:53.802]                   args[[name]] <- ""
[17:47:53.802]                 }
[17:47:53.802]                 NAMES <- toupper(removed)
[17:47:53.802]                 for (kk in seq_along(NAMES)) {
[17:47:53.802]                   name <- removed[[kk]]
[17:47:53.802]                   NAME <- NAMES[[kk]]
[17:47:53.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.802]                     next
[17:47:53.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.802]                 }
[17:47:53.802]                 if (length(args) > 0) 
[17:47:53.802]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.802]             }
[17:47:53.802]             else {
[17:47:53.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.802]             }
[17:47:53.802]             {
[17:47:53.802]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.802]                   0L) {
[17:47:53.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.802]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.802]                   base::options(opts)
[17:47:53.802]                 }
[17:47:53.802]                 {
[17:47:53.802]                   {
[17:47:53.802]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.802]                     NULL
[17:47:53.802]                   }
[17:47:53.802]                   options(future.plan = NULL)
[17:47:53.802]                   if (is.na(NA_character_)) 
[17:47:53.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.802]                     .init = FALSE)
[17:47:53.802]                 }
[17:47:53.802]             }
[17:47:53.802]         }
[17:47:53.802]     })
[17:47:53.802]     if (TRUE) {
[17:47:53.802]         base::sink(type = "output", split = FALSE)
[17:47:53.802]         if (TRUE) {
[17:47:53.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.802]         }
[17:47:53.802]         else {
[17:47:53.802]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.802]         }
[17:47:53.802]         base::close(...future.stdout)
[17:47:53.802]         ...future.stdout <- NULL
[17:47:53.802]     }
[17:47:53.802]     ...future.result$conditions <- ...future.conditions
[17:47:53.802]     ...future.result$finished <- base::Sys.time()
[17:47:53.802]     ...future.result
[17:47:53.802] }
[17:47:53.805] requestCore(): workers = 2
[17:47:53.805] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:53.816] result() for MulticoreFuture ...
[17:47:53.818] result() for MulticoreFuture ...
[17:47:53.818] result() for MulticoreFuture ... done
[17:47:53.818] result() for MulticoreFuture ... done
[17:47:53.818] result() for MulticoreFuture ...
[17:47:53.818] result() for MulticoreFuture ... done
[17:47:53.821] MulticoreFuture started
[17:47:53.821] - Launch lazy future ... done
[17:47:53.821] run() for ‘MulticoreFuture’ ... done
[17:47:53.822] plan(): Setting new future strategy stack:
[17:47:53.822] getGlobalsAndPackages() ...
[17:47:53.822] Searching for globals...
[17:47:53.822] List of future strategies:
[17:47:53.822] 1. sequential:
[17:47:53.822]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.822]    - tweaked: FALSE
[17:47:53.822]    - call: NULL
[17:47:53.823] plan(): nbrOfWorkers() = 1
[17:47:53.825] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:47:53.825] Searching for globals ... DONE
[17:47:53.826] Resolving globals: FALSE
[17:47:53.826] plan(): Setting new future strategy stack:
[17:47:53.826] 
[17:47:53.826] List of future strategies:
[17:47:53.826] 1. multicore:
[17:47:53.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:53.826]    - tweaked: FALSE
[17:47:53.826]    - call: plan(strategy)
[17:47:53.826] 
[17:47:53.826] getGlobalsAndPackages() ... DONE
[17:47:53.827] run() for ‘Future’ ...
[17:47:53.827] - state: ‘created’
[17:47:53.827] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:53.831] plan(): nbrOfWorkers() = 2
[17:47:53.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:53.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:53.833]   - Field: ‘label’
[17:47:53.833]   - Field: ‘local’
[17:47:53.833]   - Field: ‘owner’
[17:47:53.834]   - Field: ‘envir’
[17:47:53.834]   - Field: ‘workers’
[17:47:53.834]   - Field: ‘packages’
[17:47:53.834]   - Field: ‘gc’
[17:47:53.834]   - Field: ‘job’
[17:47:53.834]   - Field: ‘conditions’
[17:47:53.835]   - Field: ‘expr’
[17:47:53.835]   - Field: ‘uuid’
[17:47:53.835]   - Field: ‘seed’
[17:47:53.835]   - Field: ‘version’
[17:47:53.835]   - Field: ‘result’
[17:47:53.835]   - Field: ‘asynchronous’
[17:47:53.835]   - Field: ‘calls’
[17:47:53.836]   - Field: ‘globals’
[17:47:53.836]   - Field: ‘stdout’
[17:47:53.836]   - Field: ‘earlySignal’
[17:47:53.836]   - Field: ‘lazy’
[17:47:53.836]   - Field: ‘state’
[17:47:53.836] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:53.836] - Launch lazy future ...
[17:47:53.837] Packages needed by the future expression (n = 0): <none>
[17:47:53.837] Packages needed by future strategies (n = 0): <none>
[17:47:53.838] {
[17:47:53.838]     {
[17:47:53.838]         {
[17:47:53.838]             ...future.startTime <- base::Sys.time()
[17:47:53.838]             {
[17:47:53.838]                 {
[17:47:53.838]                   {
[17:47:53.838]                     {
[17:47:53.838]                       base::local({
[17:47:53.838]                         has_future <- base::requireNamespace("future", 
[17:47:53.838]                           quietly = TRUE)
[17:47:53.838]                         if (has_future) {
[17:47:53.838]                           ns <- base::getNamespace("future")
[17:47:53.838]                           version <- ns[[".package"]][["version"]]
[17:47:53.838]                           if (is.null(version)) 
[17:47:53.838]                             version <- utils::packageVersion("future")
[17:47:53.838]                         }
[17:47:53.838]                         else {
[17:47:53.838]                           version <- NULL
[17:47:53.838]                         }
[17:47:53.838]                         if (!has_future || version < "1.8.0") {
[17:47:53.838]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:53.838]                             "", base::R.version$version.string), 
[17:47:53.838]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:53.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:53.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:53.838]                               "release", "version")], collapse = " "), 
[17:47:53.838]                             hostname = base::Sys.info()[["nodename"]])
[17:47:53.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:53.838]                             info)
[17:47:53.838]                           info <- base::paste(info, collapse = "; ")
[17:47:53.838]                           if (!has_future) {
[17:47:53.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:53.838]                               info)
[17:47:53.838]                           }
[17:47:53.838]                           else {
[17:47:53.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:53.838]                               info, version)
[17:47:53.838]                           }
[17:47:53.838]                           base::stop(msg)
[17:47:53.838]                         }
[17:47:53.838]                       })
[17:47:53.838]                     }
[17:47:53.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:53.838]                     base::options(mc.cores = 1L)
[17:47:53.838]                   }
[17:47:53.838]                   ...future.strategy.old <- future::plan("list")
[17:47:53.838]                   options(future.plan = NULL)
[17:47:53.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:53.838]                 }
[17:47:53.838]                 ...future.workdir <- getwd()
[17:47:53.838]             }
[17:47:53.838]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:53.838]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:53.838]         }
[17:47:53.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:53.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:53.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:53.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:53.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:53.838]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:53.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:53.838]             base::names(...future.oldOptions))
[17:47:53.838]     }
[17:47:53.838]     if (FALSE) {
[17:47:53.838]     }
[17:47:53.838]     else {
[17:47:53.838]         if (TRUE) {
[17:47:53.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:53.838]                 open = "w")
[17:47:53.838]         }
[17:47:53.838]         else {
[17:47:53.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:53.838]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:53.838]         }
[17:47:53.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:53.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:53.838]             base::sink(type = "output", split = FALSE)
[17:47:53.838]             base::close(...future.stdout)
[17:47:53.838]         }, add = TRUE)
[17:47:53.838]     }
[17:47:53.838]     ...future.frame <- base::sys.nframe()
[17:47:53.838]     ...future.conditions <- base::list()
[17:47:53.838]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:53.838]     if (FALSE) {
[17:47:53.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:53.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:53.838]     }
[17:47:53.838]     ...future.result <- base::tryCatch({
[17:47:53.838]         base::withCallingHandlers({
[17:47:53.838]             ...future.value <- base::withVisible(base::local({
[17:47:53.838]                 withCallingHandlers({
[17:47:53.838]                   {
[17:47:53.838]                     Sys.sleep(0.5)
[17:47:53.838]                     2
[17:47:53.838]                   }
[17:47:53.838]                 }, immediateCondition = function(cond) {
[17:47:53.838]                   save_rds <- function (object, pathname, ...) 
[17:47:53.838]                   {
[17:47:53.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:53.838]                     if (file_test("-f", pathname_tmp)) {
[17:47:53.838]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:53.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.838]                         fi_tmp[["mtime"]])
[17:47:53.838]                     }
[17:47:53.838]                     tryCatch({
[17:47:53.838]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:53.838]                     }, error = function(ex) {
[17:47:53.838]                       msg <- conditionMessage(ex)
[17:47:53.838]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:53.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.838]                         fi_tmp[["mtime"]], msg)
[17:47:53.838]                       ex$message <- msg
[17:47:53.838]                       stop(ex)
[17:47:53.838]                     })
[17:47:53.838]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:53.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:53.838]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:53.838]                       fi_tmp <- file.info(pathname_tmp)
[17:47:53.838]                       fi <- file.info(pathname)
[17:47:53.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:53.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:53.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:53.838]                         fi[["size"]], fi[["mtime"]])
[17:47:53.838]                       stop(msg)
[17:47:53.838]                     }
[17:47:53.838]                     invisible(pathname)
[17:47:53.838]                   }
[17:47:53.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:53.838]                     rootPath = tempdir()) 
[17:47:53.838]                   {
[17:47:53.838]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:53.838]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:53.838]                       tmpdir = path, fileext = ".rds")
[17:47:53.838]                     save_rds(obj, file)
[17:47:53.838]                   }
[17:47:53.838]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:53.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.838]                   {
[17:47:53.838]                     inherits <- base::inherits
[17:47:53.838]                     invokeRestart <- base::invokeRestart
[17:47:53.838]                     is.null <- base::is.null
[17:47:53.838]                     muffled <- FALSE
[17:47:53.838]                     if (inherits(cond, "message")) {
[17:47:53.838]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:53.838]                       if (muffled) 
[17:47:53.838]                         invokeRestart("muffleMessage")
[17:47:53.838]                     }
[17:47:53.838]                     else if (inherits(cond, "warning")) {
[17:47:53.838]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:53.838]                       if (muffled) 
[17:47:53.838]                         invokeRestart("muffleWarning")
[17:47:53.838]                     }
[17:47:53.838]                     else if (inherits(cond, "condition")) {
[17:47:53.838]                       if (!is.null(pattern)) {
[17:47:53.838]                         computeRestarts <- base::computeRestarts
[17:47:53.838]                         grepl <- base::grepl
[17:47:53.838]                         restarts <- computeRestarts(cond)
[17:47:53.838]                         for (restart in restarts) {
[17:47:53.838]                           name <- restart$name
[17:47:53.838]                           if (is.null(name)) 
[17:47:53.838]                             next
[17:47:53.838]                           if (!grepl(pattern, name)) 
[17:47:53.838]                             next
[17:47:53.838]                           invokeRestart(restart)
[17:47:53.838]                           muffled <- TRUE
[17:47:53.838]                           break
[17:47:53.838]                         }
[17:47:53.838]                       }
[17:47:53.838]                     }
[17:47:53.838]                     invisible(muffled)
[17:47:53.838]                   }
[17:47:53.838]                   muffleCondition(cond)
[17:47:53.838]                 })
[17:47:53.838]             }))
[17:47:53.838]             future::FutureResult(value = ...future.value$value, 
[17:47:53.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.838]                   ...future.rng), globalenv = if (FALSE) 
[17:47:53.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:53.838]                     ...future.globalenv.names))
[17:47:53.838]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:53.838]         }, condition = base::local({
[17:47:53.838]             c <- base::c
[17:47:53.838]             inherits <- base::inherits
[17:47:53.838]             invokeRestart <- base::invokeRestart
[17:47:53.838]             length <- base::length
[17:47:53.838]             list <- base::list
[17:47:53.838]             seq.int <- base::seq.int
[17:47:53.838]             signalCondition <- base::signalCondition
[17:47:53.838]             sys.calls <- base::sys.calls
[17:47:53.838]             `[[` <- base::`[[`
[17:47:53.838]             `+` <- base::`+`
[17:47:53.838]             `<<-` <- base::`<<-`
[17:47:53.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:53.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:53.838]                   3L)]
[17:47:53.838]             }
[17:47:53.838]             function(cond) {
[17:47:53.838]                 is_error <- inherits(cond, "error")
[17:47:53.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:53.838]                   NULL)
[17:47:53.838]                 if (is_error) {
[17:47:53.838]                   sessionInformation <- function() {
[17:47:53.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:53.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:53.838]                       search = base::search(), system = base::Sys.info())
[17:47:53.838]                   }
[17:47:53.838]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:53.838]                     cond$call), session = sessionInformation(), 
[17:47:53.838]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:53.838]                   signalCondition(cond)
[17:47:53.838]                 }
[17:47:53.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:53.838]                 "immediateCondition"))) {
[17:47:53.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:53.838]                   ...future.conditions[[length(...future.conditions) + 
[17:47:53.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:53.838]                   if (TRUE && !signal) {
[17:47:53.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.838]                     {
[17:47:53.838]                       inherits <- base::inherits
[17:47:53.838]                       invokeRestart <- base::invokeRestart
[17:47:53.838]                       is.null <- base::is.null
[17:47:53.838]                       muffled <- FALSE
[17:47:53.838]                       if (inherits(cond, "message")) {
[17:47:53.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.838]                         if (muffled) 
[17:47:53.838]                           invokeRestart("muffleMessage")
[17:47:53.838]                       }
[17:47:53.838]                       else if (inherits(cond, "warning")) {
[17:47:53.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.838]                         if (muffled) 
[17:47:53.838]                           invokeRestart("muffleWarning")
[17:47:53.838]                       }
[17:47:53.838]                       else if (inherits(cond, "condition")) {
[17:47:53.838]                         if (!is.null(pattern)) {
[17:47:53.838]                           computeRestarts <- base::computeRestarts
[17:47:53.838]                           grepl <- base::grepl
[17:47:53.838]                           restarts <- computeRestarts(cond)
[17:47:53.838]                           for (restart in restarts) {
[17:47:53.838]                             name <- restart$name
[17:47:53.838]                             if (is.null(name)) 
[17:47:53.838]                               next
[17:47:53.838]                             if (!grepl(pattern, name)) 
[17:47:53.838]                               next
[17:47:53.838]                             invokeRestart(restart)
[17:47:53.838]                             muffled <- TRUE
[17:47:53.838]                             break
[17:47:53.838]                           }
[17:47:53.838]                         }
[17:47:53.838]                       }
[17:47:53.838]                       invisible(muffled)
[17:47:53.838]                     }
[17:47:53.838]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.838]                   }
[17:47:53.838]                 }
[17:47:53.838]                 else {
[17:47:53.838]                   if (TRUE) {
[17:47:53.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:53.838]                     {
[17:47:53.838]                       inherits <- base::inherits
[17:47:53.838]                       invokeRestart <- base::invokeRestart
[17:47:53.838]                       is.null <- base::is.null
[17:47:53.838]                       muffled <- FALSE
[17:47:53.838]                       if (inherits(cond, "message")) {
[17:47:53.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:53.838]                         if (muffled) 
[17:47:53.838]                           invokeRestart("muffleMessage")
[17:47:53.838]                       }
[17:47:53.838]                       else if (inherits(cond, "warning")) {
[17:47:53.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:53.838]                         if (muffled) 
[17:47:53.838]                           invokeRestart("muffleWarning")
[17:47:53.838]                       }
[17:47:53.838]                       else if (inherits(cond, "condition")) {
[17:47:53.838]                         if (!is.null(pattern)) {
[17:47:53.838]                           computeRestarts <- base::computeRestarts
[17:47:53.838]                           grepl <- base::grepl
[17:47:53.838]                           restarts <- computeRestarts(cond)
[17:47:53.838]                           for (restart in restarts) {
[17:47:53.838]                             name <- restart$name
[17:47:53.838]                             if (is.null(name)) 
[17:47:53.838]                               next
[17:47:53.838]                             if (!grepl(pattern, name)) 
[17:47:53.838]                               next
[17:47:53.838]                             invokeRestart(restart)
[17:47:53.838]                             muffled <- TRUE
[17:47:53.838]                             break
[17:47:53.838]                           }
[17:47:53.838]                         }
[17:47:53.838]                       }
[17:47:53.838]                       invisible(muffled)
[17:47:53.838]                     }
[17:47:53.838]                     muffleCondition(cond, pattern = "^muffle")
[17:47:53.838]                   }
[17:47:53.838]                 }
[17:47:53.838]             }
[17:47:53.838]         }))
[17:47:53.838]     }, error = function(ex) {
[17:47:53.838]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:53.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:53.838]                 ...future.rng), started = ...future.startTime, 
[17:47:53.838]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:53.838]             version = "1.8"), class = "FutureResult")
[17:47:53.838]     }, finally = {
[17:47:53.838]         if (!identical(...future.workdir, getwd())) 
[17:47:53.838]             setwd(...future.workdir)
[17:47:53.838]         {
[17:47:53.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:53.838]                 ...future.oldOptions$nwarnings <- NULL
[17:47:53.838]             }
[17:47:53.838]             base::options(...future.oldOptions)
[17:47:53.838]             if (.Platform$OS.type == "windows") {
[17:47:53.838]                 old_names <- names(...future.oldEnvVars)
[17:47:53.838]                 envs <- base::Sys.getenv()
[17:47:53.838]                 names <- names(envs)
[17:47:53.838]                 common <- intersect(names, old_names)
[17:47:53.838]                 added <- setdiff(names, old_names)
[17:47:53.838]                 removed <- setdiff(old_names, names)
[17:47:53.838]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:53.838]                   envs[common]]
[17:47:53.838]                 NAMES <- toupper(changed)
[17:47:53.838]                 args <- list()
[17:47:53.838]                 for (kk in seq_along(NAMES)) {
[17:47:53.838]                   name <- changed[[kk]]
[17:47:53.838]                   NAME <- NAMES[[kk]]
[17:47:53.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.838]                     next
[17:47:53.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.838]                 }
[17:47:53.838]                 NAMES <- toupper(added)
[17:47:53.838]                 for (kk in seq_along(NAMES)) {
[17:47:53.838]                   name <- added[[kk]]
[17:47:53.838]                   NAME <- NAMES[[kk]]
[17:47:53.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.838]                     next
[17:47:53.838]                   args[[name]] <- ""
[17:47:53.838]                 }
[17:47:53.838]                 NAMES <- toupper(removed)
[17:47:53.838]                 for (kk in seq_along(NAMES)) {
[17:47:53.838]                   name <- removed[[kk]]
[17:47:53.838]                   NAME <- NAMES[[kk]]
[17:47:53.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:53.838]                     next
[17:47:53.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:53.838]                 }
[17:47:53.838]                 if (length(args) > 0) 
[17:47:53.838]                   base::do.call(base::Sys.setenv, args = args)
[17:47:53.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:53.838]             }
[17:47:53.838]             else {
[17:47:53.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:53.838]             }
[17:47:53.838]             {
[17:47:53.838]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:53.838]                   0L) {
[17:47:53.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:53.838]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:53.838]                   base::options(opts)
[17:47:53.838]                 }
[17:47:53.838]                 {
[17:47:53.838]                   {
[17:47:53.838]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:53.838]                     NULL
[17:47:53.838]                   }
[17:47:53.838]                   options(future.plan = NULL)
[17:47:53.838]                   if (is.na(NA_character_)) 
[17:47:53.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:53.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:53.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:53.838]                     .init = FALSE)
[17:47:53.838]                 }
[17:47:53.838]             }
[17:47:53.838]         }
[17:47:53.838]     })
[17:47:53.838]     if (TRUE) {
[17:47:53.838]         base::sink(type = "output", split = FALSE)
[17:47:53.838]         if (TRUE) {
[17:47:53.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:53.838]         }
[17:47:53.838]         else {
[17:47:53.838]             ...future.result["stdout"] <- base::list(NULL)
[17:47:53.838]         }
[17:47:53.838]         base::close(...future.stdout)
[17:47:53.838]         ...future.stdout <- NULL
[17:47:53.838]     }
[17:47:53.838]     ...future.result$conditions <- ...future.conditions
[17:47:53.838]     ...future.result$finished <- base::Sys.time()
[17:47:53.838]     ...future.result
[17:47:53.838] }
[17:47:53.841] requestCore(): workers = 2
[17:47:53.841] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:53.852] result() for MulticoreFuture ...
[17:47:53.853] result() for MulticoreFuture ...
[17:47:53.853] result() for MulticoreFuture ... done
[17:47:53.853] result() for MulticoreFuture ... done
[17:47:53.853] result() for MulticoreFuture ...
[17:47:53.853] result() for MulticoreFuture ... done
[17:47:53.856] MulticoreFuture started
[17:47:53.856] - Launch lazy future ... done
[17:47:53.856] run() for ‘MulticoreFuture’ ... done
[17:47:53.857] plan(): Setting new future strategy stack:
[17:47:53.857] resolve() on list ...
[17:47:53.857]  recursive: 0
[17:47:53.858]  length: 1
[17:47:53.858] 
[17:47:53.857] List of future strategies:
[17:47:53.857] 1. sequential:
[17:47:53.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:53.857]    - tweaked: FALSE
[17:47:53.857]    - call: NULL
[17:47:53.859] Future #1
[17:47:53.859] plan(): nbrOfWorkers() = 1
[17:47:53.859]  length: 0 (resolved future 1)
[17:47:53.859] resolve() on list ... DONE
[17:47:53.860] resolve() on list ...
[17:47:53.860]  recursive: 0
[17:47:53.860]  length: 1
[17:47:53.861] 
[17:47:54.362] plan(): Setting new future strategy stack:
[17:47:54.362] List of future strategies:
[17:47:54.362] 1. multicore:
[17:47:54.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.362]    - tweaked: FALSE
[17:47:54.362]    - call: plan(strategy)
[17:47:54.368] plan(): nbrOfWorkers() = 2
[17:47:54.370] Future #1
[17:47:54.371]  length: 0 (resolved future 1)
[17:47:54.371] resolve() on list ... DONE
[17:47:54.371] resolve() on list ...
[17:47:54.372]  recursive: 0
[17:47:54.372]  length: 1
[17:47:54.372] 
[17:47:54.372]  length: 0 (resolved future 1)
[17:47:54.372] resolve() on list ... DONE
[17:47:54.372] resolve() on list ...
[17:47:54.373]  recursive: 0
[17:47:54.373]  length: 4
[17:47:54.373] 
[17:47:54.373] Future #1
[17:47:54.373]  length: 3 (resolved future 1)
[17:47:54.374] Future #2
[17:47:54.374]  length: 2 (resolved future 2)
[17:47:54.374]  length: 1 (resolved future 3)
[17:47:54.374]  length: 0 (resolved future 4)
[17:47:54.374] resolve() on list ... DONE
[17:47:54.375] resolve() on list ...
[17:47:54.375]  recursive: 0
[17:47:54.375]  length: 4
[17:47:54.375] 
[17:47:54.375] Future #1
[17:47:54.376]  length: 3 (resolved future 1)
[17:47:54.376] Future #2
[17:47:54.376]  length: 2 (resolved future 2)
[17:47:54.376]  length: 1 (resolved future 3)
[17:47:54.376]  length: 0 (resolved future 4)
[17:47:54.376] resolve() on list ... DONE
[17:47:54.377] resolve() on list ...
[17:47:54.377]  recursive: 0
[17:47:54.377]  length: 1
[17:47:54.377] 
[17:47:54.377]  length: 0 (resolved future 1)
[17:47:54.377] resolve() on list ... DONE
[17:47:54.378] getGlobalsAndPackages() ...
[17:47:54.378] Searching for globals...
[17:47:54.380] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:54.380] Searching for globals ... DONE
[17:47:54.380] Resolving globals: FALSE
[17:47:54.381] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:54.381] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:54.382] - globals: [1] ‘kk’
[17:47:54.382] 
[17:47:54.382] getGlobalsAndPackages() ... DONE
[17:47:54.382] run() for ‘Future’ ...
[17:47:54.382] - state: ‘created’
[17:47:54.383] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.387] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.388]   - Field: ‘label’
[17:47:54.388]   - Field: ‘local’
[17:47:54.388]   - Field: ‘owner’
[17:47:54.388]   - Field: ‘envir’
[17:47:54.388]   - Field: ‘workers’
[17:47:54.388]   - Field: ‘packages’
[17:47:54.388]   - Field: ‘gc’
[17:47:54.389]   - Field: ‘job’
[17:47:54.389]   - Field: ‘conditions’
[17:47:54.389]   - Field: ‘expr’
[17:47:54.389]   - Field: ‘uuid’
[17:47:54.389]   - Field: ‘seed’
[17:47:54.389]   - Field: ‘version’
[17:47:54.389]   - Field: ‘result’
[17:47:54.390]   - Field: ‘asynchronous’
[17:47:54.393]   - Field: ‘calls’
[17:47:54.393]   - Field: ‘globals’
[17:47:54.393]   - Field: ‘stdout’
[17:47:54.394]   - Field: ‘earlySignal’
[17:47:54.394]   - Field: ‘lazy’
[17:47:54.394]   - Field: ‘state’
[17:47:54.394] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.395] - Launch lazy future ...
[17:47:54.395] Packages needed by the future expression (n = 0): <none>
[17:47:54.395] Packages needed by future strategies (n = 0): <none>
[17:47:54.396] {
[17:47:54.396]     {
[17:47:54.396]         {
[17:47:54.396]             ...future.startTime <- base::Sys.time()
[17:47:54.396]             {
[17:47:54.396]                 {
[17:47:54.396]                   {
[17:47:54.396]                     {
[17:47:54.396]                       base::local({
[17:47:54.396]                         has_future <- base::requireNamespace("future", 
[17:47:54.396]                           quietly = TRUE)
[17:47:54.396]                         if (has_future) {
[17:47:54.396]                           ns <- base::getNamespace("future")
[17:47:54.396]                           version <- ns[[".package"]][["version"]]
[17:47:54.396]                           if (is.null(version)) 
[17:47:54.396]                             version <- utils::packageVersion("future")
[17:47:54.396]                         }
[17:47:54.396]                         else {
[17:47:54.396]                           version <- NULL
[17:47:54.396]                         }
[17:47:54.396]                         if (!has_future || version < "1.8.0") {
[17:47:54.396]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.396]                             "", base::R.version$version.string), 
[17:47:54.396]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.396]                               "release", "version")], collapse = " "), 
[17:47:54.396]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.396]                             info)
[17:47:54.396]                           info <- base::paste(info, collapse = "; ")
[17:47:54.396]                           if (!has_future) {
[17:47:54.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.396]                               info)
[17:47:54.396]                           }
[17:47:54.396]                           else {
[17:47:54.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.396]                               info, version)
[17:47:54.396]                           }
[17:47:54.396]                           base::stop(msg)
[17:47:54.396]                         }
[17:47:54.396]                       })
[17:47:54.396]                     }
[17:47:54.396]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.396]                     base::options(mc.cores = 1L)
[17:47:54.396]                   }
[17:47:54.396]                   ...future.strategy.old <- future::plan("list")
[17:47:54.396]                   options(future.plan = NULL)
[17:47:54.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.396]                 }
[17:47:54.396]                 ...future.workdir <- getwd()
[17:47:54.396]             }
[17:47:54.396]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.396]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.396]         }
[17:47:54.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.396]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.396]             base::names(...future.oldOptions))
[17:47:54.396]     }
[17:47:54.396]     if (FALSE) {
[17:47:54.396]     }
[17:47:54.396]     else {
[17:47:54.396]         if (TRUE) {
[17:47:54.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.396]                 open = "w")
[17:47:54.396]         }
[17:47:54.396]         else {
[17:47:54.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.396]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.396]         }
[17:47:54.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.396]             base::sink(type = "output", split = FALSE)
[17:47:54.396]             base::close(...future.stdout)
[17:47:54.396]         }, add = TRUE)
[17:47:54.396]     }
[17:47:54.396]     ...future.frame <- base::sys.nframe()
[17:47:54.396]     ...future.conditions <- base::list()
[17:47:54.396]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.396]     if (FALSE) {
[17:47:54.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.396]     }
[17:47:54.396]     ...future.result <- base::tryCatch({
[17:47:54.396]         base::withCallingHandlers({
[17:47:54.396]             ...future.value <- base::withVisible(base::local({
[17:47:54.396]                 withCallingHandlers({
[17:47:54.396]                   {
[17:47:54.396]                     Sys.sleep(0.1)
[17:47:54.396]                     kk
[17:47:54.396]                   }
[17:47:54.396]                 }, immediateCondition = function(cond) {
[17:47:54.396]                   save_rds <- function (object, pathname, ...) 
[17:47:54.396]                   {
[17:47:54.396]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.396]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.396]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.396]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.396]                         fi_tmp[["mtime"]])
[17:47:54.396]                     }
[17:47:54.396]                     tryCatch({
[17:47:54.396]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.396]                     }, error = function(ex) {
[17:47:54.396]                       msg <- conditionMessage(ex)
[17:47:54.396]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.396]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.396]                         fi_tmp[["mtime"]], msg)
[17:47:54.396]                       ex$message <- msg
[17:47:54.396]                       stop(ex)
[17:47:54.396]                     })
[17:47:54.396]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.396]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.396]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.396]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.396]                       fi <- file.info(pathname)
[17:47:54.396]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.396]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.396]                         fi[["size"]], fi[["mtime"]])
[17:47:54.396]                       stop(msg)
[17:47:54.396]                     }
[17:47:54.396]                     invisible(pathname)
[17:47:54.396]                   }
[17:47:54.396]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.396]                     rootPath = tempdir()) 
[17:47:54.396]                   {
[17:47:54.396]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.396]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.396]                       tmpdir = path, fileext = ".rds")
[17:47:54.396]                     save_rds(obj, file)
[17:47:54.396]                   }
[17:47:54.396]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.396]                   {
[17:47:54.396]                     inherits <- base::inherits
[17:47:54.396]                     invokeRestart <- base::invokeRestart
[17:47:54.396]                     is.null <- base::is.null
[17:47:54.396]                     muffled <- FALSE
[17:47:54.396]                     if (inherits(cond, "message")) {
[17:47:54.396]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.396]                       if (muffled) 
[17:47:54.396]                         invokeRestart("muffleMessage")
[17:47:54.396]                     }
[17:47:54.396]                     else if (inherits(cond, "warning")) {
[17:47:54.396]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.396]                       if (muffled) 
[17:47:54.396]                         invokeRestart("muffleWarning")
[17:47:54.396]                     }
[17:47:54.396]                     else if (inherits(cond, "condition")) {
[17:47:54.396]                       if (!is.null(pattern)) {
[17:47:54.396]                         computeRestarts <- base::computeRestarts
[17:47:54.396]                         grepl <- base::grepl
[17:47:54.396]                         restarts <- computeRestarts(cond)
[17:47:54.396]                         for (restart in restarts) {
[17:47:54.396]                           name <- restart$name
[17:47:54.396]                           if (is.null(name)) 
[17:47:54.396]                             next
[17:47:54.396]                           if (!grepl(pattern, name)) 
[17:47:54.396]                             next
[17:47:54.396]                           invokeRestart(restart)
[17:47:54.396]                           muffled <- TRUE
[17:47:54.396]                           break
[17:47:54.396]                         }
[17:47:54.396]                       }
[17:47:54.396]                     }
[17:47:54.396]                     invisible(muffled)
[17:47:54.396]                   }
[17:47:54.396]                   muffleCondition(cond)
[17:47:54.396]                 })
[17:47:54.396]             }))
[17:47:54.396]             future::FutureResult(value = ...future.value$value, 
[17:47:54.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.396]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.396]                     ...future.globalenv.names))
[17:47:54.396]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.396]         }, condition = base::local({
[17:47:54.396]             c <- base::c
[17:47:54.396]             inherits <- base::inherits
[17:47:54.396]             invokeRestart <- base::invokeRestart
[17:47:54.396]             length <- base::length
[17:47:54.396]             list <- base::list
[17:47:54.396]             seq.int <- base::seq.int
[17:47:54.396]             signalCondition <- base::signalCondition
[17:47:54.396]             sys.calls <- base::sys.calls
[17:47:54.396]             `[[` <- base::`[[`
[17:47:54.396]             `+` <- base::`+`
[17:47:54.396]             `<<-` <- base::`<<-`
[17:47:54.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.396]                   3L)]
[17:47:54.396]             }
[17:47:54.396]             function(cond) {
[17:47:54.396]                 is_error <- inherits(cond, "error")
[17:47:54.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.396]                   NULL)
[17:47:54.396]                 if (is_error) {
[17:47:54.396]                   sessionInformation <- function() {
[17:47:54.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.396]                       search = base::search(), system = base::Sys.info())
[17:47:54.396]                   }
[17:47:54.396]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.396]                     cond$call), session = sessionInformation(), 
[17:47:54.396]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.396]                   signalCondition(cond)
[17:47:54.396]                 }
[17:47:54.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.396]                 "immediateCondition"))) {
[17:47:54.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.396]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.396]                   if (TRUE && !signal) {
[17:47:54.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.396]                     {
[17:47:54.396]                       inherits <- base::inherits
[17:47:54.396]                       invokeRestart <- base::invokeRestart
[17:47:54.396]                       is.null <- base::is.null
[17:47:54.396]                       muffled <- FALSE
[17:47:54.396]                       if (inherits(cond, "message")) {
[17:47:54.396]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.396]                         if (muffled) 
[17:47:54.396]                           invokeRestart("muffleMessage")
[17:47:54.396]                       }
[17:47:54.396]                       else if (inherits(cond, "warning")) {
[17:47:54.396]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.396]                         if (muffled) 
[17:47:54.396]                           invokeRestart("muffleWarning")
[17:47:54.396]                       }
[17:47:54.396]                       else if (inherits(cond, "condition")) {
[17:47:54.396]                         if (!is.null(pattern)) {
[17:47:54.396]                           computeRestarts <- base::computeRestarts
[17:47:54.396]                           grepl <- base::grepl
[17:47:54.396]                           restarts <- computeRestarts(cond)
[17:47:54.396]                           for (restart in restarts) {
[17:47:54.396]                             name <- restart$name
[17:47:54.396]                             if (is.null(name)) 
[17:47:54.396]                               next
[17:47:54.396]                             if (!grepl(pattern, name)) 
[17:47:54.396]                               next
[17:47:54.396]                             invokeRestart(restart)
[17:47:54.396]                             muffled <- TRUE
[17:47:54.396]                             break
[17:47:54.396]                           }
[17:47:54.396]                         }
[17:47:54.396]                       }
[17:47:54.396]                       invisible(muffled)
[17:47:54.396]                     }
[17:47:54.396]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.396]                   }
[17:47:54.396]                 }
[17:47:54.396]                 else {
[17:47:54.396]                   if (TRUE) {
[17:47:54.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.396]                     {
[17:47:54.396]                       inherits <- base::inherits
[17:47:54.396]                       invokeRestart <- base::invokeRestart
[17:47:54.396]                       is.null <- base::is.null
[17:47:54.396]                       muffled <- FALSE
[17:47:54.396]                       if (inherits(cond, "message")) {
[17:47:54.396]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.396]                         if (muffled) 
[17:47:54.396]                           invokeRestart("muffleMessage")
[17:47:54.396]                       }
[17:47:54.396]                       else if (inherits(cond, "warning")) {
[17:47:54.396]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.396]                         if (muffled) 
[17:47:54.396]                           invokeRestart("muffleWarning")
[17:47:54.396]                       }
[17:47:54.396]                       else if (inherits(cond, "condition")) {
[17:47:54.396]                         if (!is.null(pattern)) {
[17:47:54.396]                           computeRestarts <- base::computeRestarts
[17:47:54.396]                           grepl <- base::grepl
[17:47:54.396]                           restarts <- computeRestarts(cond)
[17:47:54.396]                           for (restart in restarts) {
[17:47:54.396]                             name <- restart$name
[17:47:54.396]                             if (is.null(name)) 
[17:47:54.396]                               next
[17:47:54.396]                             if (!grepl(pattern, name)) 
[17:47:54.396]                               next
[17:47:54.396]                             invokeRestart(restart)
[17:47:54.396]                             muffled <- TRUE
[17:47:54.396]                             break
[17:47:54.396]                           }
[17:47:54.396]                         }
[17:47:54.396]                       }
[17:47:54.396]                       invisible(muffled)
[17:47:54.396]                     }
[17:47:54.396]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.396]                   }
[17:47:54.396]                 }
[17:47:54.396]             }
[17:47:54.396]         }))
[17:47:54.396]     }, error = function(ex) {
[17:47:54.396]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.396]                 ...future.rng), started = ...future.startTime, 
[17:47:54.396]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.396]             version = "1.8"), class = "FutureResult")
[17:47:54.396]     }, finally = {
[17:47:54.396]         if (!identical(...future.workdir, getwd())) 
[17:47:54.396]             setwd(...future.workdir)
[17:47:54.396]         {
[17:47:54.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.396]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.396]             }
[17:47:54.396]             base::options(...future.oldOptions)
[17:47:54.396]             if (.Platform$OS.type == "windows") {
[17:47:54.396]                 old_names <- names(...future.oldEnvVars)
[17:47:54.396]                 envs <- base::Sys.getenv()
[17:47:54.396]                 names <- names(envs)
[17:47:54.396]                 common <- intersect(names, old_names)
[17:47:54.396]                 added <- setdiff(names, old_names)
[17:47:54.396]                 removed <- setdiff(old_names, names)
[17:47:54.396]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.396]                   envs[common]]
[17:47:54.396]                 NAMES <- toupper(changed)
[17:47:54.396]                 args <- list()
[17:47:54.396]                 for (kk in seq_along(NAMES)) {
[17:47:54.396]                   name <- changed[[kk]]
[17:47:54.396]                   NAME <- NAMES[[kk]]
[17:47:54.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.396]                     next
[17:47:54.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.396]                 }
[17:47:54.396]                 NAMES <- toupper(added)
[17:47:54.396]                 for (kk in seq_along(NAMES)) {
[17:47:54.396]                   name <- added[[kk]]
[17:47:54.396]                   NAME <- NAMES[[kk]]
[17:47:54.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.396]                     next
[17:47:54.396]                   args[[name]] <- ""
[17:47:54.396]                 }
[17:47:54.396]                 NAMES <- toupper(removed)
[17:47:54.396]                 for (kk in seq_along(NAMES)) {
[17:47:54.396]                   name <- removed[[kk]]
[17:47:54.396]                   NAME <- NAMES[[kk]]
[17:47:54.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.396]                     next
[17:47:54.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.396]                 }
[17:47:54.396]                 if (length(args) > 0) 
[17:47:54.396]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.396]             }
[17:47:54.396]             else {
[17:47:54.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.396]             }
[17:47:54.396]             {
[17:47:54.396]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.396]                   0L) {
[17:47:54.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.396]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.396]                   base::options(opts)
[17:47:54.396]                 }
[17:47:54.396]                 {
[17:47:54.396]                   {
[17:47:54.396]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.396]                     NULL
[17:47:54.396]                   }
[17:47:54.396]                   options(future.plan = NULL)
[17:47:54.396]                   if (is.na(NA_character_)) 
[17:47:54.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.396]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.396]                     .init = FALSE)
[17:47:54.396]                 }
[17:47:54.396]             }
[17:47:54.396]         }
[17:47:54.396]     })
[17:47:54.396]     if (TRUE) {
[17:47:54.396]         base::sink(type = "output", split = FALSE)
[17:47:54.396]         if (TRUE) {
[17:47:54.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.396]         }
[17:47:54.396]         else {
[17:47:54.396]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.396]         }
[17:47:54.396]         base::close(...future.stdout)
[17:47:54.396]         ...future.stdout <- NULL
[17:47:54.396]     }
[17:47:54.396]     ...future.result$conditions <- ...future.conditions
[17:47:54.396]     ...future.result$finished <- base::Sys.time()
[17:47:54.396]     ...future.result
[17:47:54.396] }
[17:47:54.399] assign_globals() ...
[17:47:54.399] List of 1
[17:47:54.399]  $ kk: int 1
[17:47:54.399]  - attr(*, "where")=List of 1
[17:47:54.399]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:54.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:54.399]  - attr(*, "resolved")= logi FALSE
[17:47:54.399]  - attr(*, "total_size")= num 56
[17:47:54.399]  - attr(*, "already-done")= logi TRUE
[17:47:54.403] - copied ‘kk’ to environment
[17:47:54.403] assign_globals() ... done
[17:47:54.403] requestCore(): workers = 2
[17:47:54.403] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:54.414] result() for MulticoreFuture ...
[17:47:54.415] result() for MulticoreFuture ...
[17:47:54.415] result() for MulticoreFuture ... done
[17:47:54.415] result() for MulticoreFuture ... done
[17:47:54.415] result() for MulticoreFuture ...
[17:47:54.415] result() for MulticoreFuture ... done
[17:47:54.418] MulticoreFuture started
[17:47:54.419] - Launch lazy future ... done
[17:47:54.419] run() for ‘MulticoreFuture’ ... done
[17:47:54.419] getGlobalsAndPackages() ...
[17:47:54.419] plan(): Setting new future strategy stack:
[17:47:54.420] Searching for globals...
[17:47:54.420] List of future strategies:
[17:47:54.420] 1. sequential:
[17:47:54.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:54.420]    - tweaked: FALSE
[17:47:54.420]    - call: NULL
[17:47:54.421] plan(): nbrOfWorkers() = 1
[17:47:54.422] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:54.422] Searching for globals ... DONE
[17:47:54.422] Resolving globals: FALSE
[17:47:54.423] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:54.424] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:54.424] - globals: [1] ‘kk’
[17:47:54.424] 
[17:47:54.424] getGlobalsAndPackages() ... DONE
[17:47:54.425] run() for ‘Future’ ...
[17:47:54.425] - state: ‘created’
[17:47:54.425] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.430] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.431] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.431]   - Field: ‘label’
[17:47:54.431]   - Field: ‘local’
[17:47:54.431]   - Field: ‘owner’
[17:47:54.431]   - Field: ‘envir’
[17:47:54.431]   - Field: ‘workers’
[17:47:54.432]   - Field: ‘packages’
[17:47:54.432]   - Field: ‘gc’
[17:47:54.432]   - Field: ‘job’
[17:47:54.432]   - Field: ‘conditions’
[17:47:54.432]   - Field: ‘expr’
[17:47:54.432]   - Field: ‘uuid’
[17:47:54.433]   - Field: ‘seed’
[17:47:54.433]   - Field: ‘version’
[17:47:54.433]   - Field: ‘result’
[17:47:54.433]   - Field: ‘asynchronous’
[17:47:54.433]   - Field: ‘calls’
[17:47:54.433]   - Field: ‘globals’
[17:47:54.433]   - Field: ‘stdout’
[17:47:54.433]   - Field: ‘earlySignal’
[17:47:54.434]   - Field: ‘lazy’
[17:47:54.434]   - Field: ‘state’
[17:47:54.434] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.434] - Launch lazy future ...
[17:47:54.434] Packages needed by the future expression (n = 0): <none>
[17:47:54.435] Packages needed by future strategies (n = 0): <none>
[17:47:54.435] {
[17:47:54.435]     {
[17:47:54.435]         {
[17:47:54.435]             ...future.startTime <- base::Sys.time()
[17:47:54.435]             {
[17:47:54.435]                 {
[17:47:54.435]                   {
[17:47:54.435]                     {
[17:47:54.435]                       base::local({
[17:47:54.435]                         has_future <- base::requireNamespace("future", 
[17:47:54.435]                           quietly = TRUE)
[17:47:54.435]                         if (has_future) {
[17:47:54.435]                           ns <- base::getNamespace("future")
[17:47:54.435]                           version <- ns[[".package"]][["version"]]
[17:47:54.435]                           if (is.null(version)) 
[17:47:54.435]                             version <- utils::packageVersion("future")
[17:47:54.435]                         }
[17:47:54.435]                         else {
[17:47:54.435]                           version <- NULL
[17:47:54.435]                         }
[17:47:54.435]                         if (!has_future || version < "1.8.0") {
[17:47:54.435]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.435]                             "", base::R.version$version.string), 
[17:47:54.435]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.435]                               "release", "version")], collapse = " "), 
[17:47:54.435]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.435]                             info)
[17:47:54.435]                           info <- base::paste(info, collapse = "; ")
[17:47:54.435]                           if (!has_future) {
[17:47:54.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.435]                               info)
[17:47:54.435]                           }
[17:47:54.435]                           else {
[17:47:54.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.435]                               info, version)
[17:47:54.435]                           }
[17:47:54.435]                           base::stop(msg)
[17:47:54.435]                         }
[17:47:54.435]                       })
[17:47:54.435]                     }
[17:47:54.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.435]                     base::options(mc.cores = 1L)
[17:47:54.435]                   }
[17:47:54.435]                   ...future.strategy.old <- future::plan("list")
[17:47:54.435]                   options(future.plan = NULL)
[17:47:54.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.435]                 }
[17:47:54.435]                 ...future.workdir <- getwd()
[17:47:54.435]             }
[17:47:54.435]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.435]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.435]         }
[17:47:54.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.435]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.435]             base::names(...future.oldOptions))
[17:47:54.435]     }
[17:47:54.435]     if (FALSE) {
[17:47:54.435]     }
[17:47:54.435]     else {
[17:47:54.435]         if (TRUE) {
[17:47:54.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.435]                 open = "w")
[17:47:54.435]         }
[17:47:54.435]         else {
[17:47:54.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.435]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.435]         }
[17:47:54.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.435]             base::sink(type = "output", split = FALSE)
[17:47:54.435]             base::close(...future.stdout)
[17:47:54.435]         }, add = TRUE)
[17:47:54.435]     }
[17:47:54.435]     ...future.frame <- base::sys.nframe()
[17:47:54.435]     ...future.conditions <- base::list()
[17:47:54.435]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.435]     if (FALSE) {
[17:47:54.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.435]     }
[17:47:54.435]     ...future.result <- base::tryCatch({
[17:47:54.435]         base::withCallingHandlers({
[17:47:54.435]             ...future.value <- base::withVisible(base::local({
[17:47:54.435]                 withCallingHandlers({
[17:47:54.435]                   {
[17:47:54.435]                     Sys.sleep(0.1)
[17:47:54.435]                     kk
[17:47:54.435]                   }
[17:47:54.435]                 }, immediateCondition = function(cond) {
[17:47:54.435]                   save_rds <- function (object, pathname, ...) 
[17:47:54.435]                   {
[17:47:54.435]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.435]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.435]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.435]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.435]                         fi_tmp[["mtime"]])
[17:47:54.435]                     }
[17:47:54.435]                     tryCatch({
[17:47:54.435]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.435]                     }, error = function(ex) {
[17:47:54.435]                       msg <- conditionMessage(ex)
[17:47:54.435]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.435]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.435]                         fi_tmp[["mtime"]], msg)
[17:47:54.435]                       ex$message <- msg
[17:47:54.435]                       stop(ex)
[17:47:54.435]                     })
[17:47:54.435]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.435]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.435]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.435]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.435]                       fi <- file.info(pathname)
[17:47:54.435]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.435]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.435]                         fi[["size"]], fi[["mtime"]])
[17:47:54.435]                       stop(msg)
[17:47:54.435]                     }
[17:47:54.435]                     invisible(pathname)
[17:47:54.435]                   }
[17:47:54.435]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.435]                     rootPath = tempdir()) 
[17:47:54.435]                   {
[17:47:54.435]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.435]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.435]                       tmpdir = path, fileext = ".rds")
[17:47:54.435]                     save_rds(obj, file)
[17:47:54.435]                   }
[17:47:54.435]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.435]                   {
[17:47:54.435]                     inherits <- base::inherits
[17:47:54.435]                     invokeRestart <- base::invokeRestart
[17:47:54.435]                     is.null <- base::is.null
[17:47:54.435]                     muffled <- FALSE
[17:47:54.435]                     if (inherits(cond, "message")) {
[17:47:54.435]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.435]                       if (muffled) 
[17:47:54.435]                         invokeRestart("muffleMessage")
[17:47:54.435]                     }
[17:47:54.435]                     else if (inherits(cond, "warning")) {
[17:47:54.435]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.435]                       if (muffled) 
[17:47:54.435]                         invokeRestart("muffleWarning")
[17:47:54.435]                     }
[17:47:54.435]                     else if (inherits(cond, "condition")) {
[17:47:54.435]                       if (!is.null(pattern)) {
[17:47:54.435]                         computeRestarts <- base::computeRestarts
[17:47:54.435]                         grepl <- base::grepl
[17:47:54.435]                         restarts <- computeRestarts(cond)
[17:47:54.435]                         for (restart in restarts) {
[17:47:54.435]                           name <- restart$name
[17:47:54.435]                           if (is.null(name)) 
[17:47:54.435]                             next
[17:47:54.435]                           if (!grepl(pattern, name)) 
[17:47:54.435]                             next
[17:47:54.435]                           invokeRestart(restart)
[17:47:54.435]                           muffled <- TRUE
[17:47:54.435]                           break
[17:47:54.435]                         }
[17:47:54.435]                       }
[17:47:54.435]                     }
[17:47:54.435]                     invisible(muffled)
[17:47:54.435]                   }
[17:47:54.435]                   muffleCondition(cond)
[17:47:54.435]                 })
[17:47:54.435]             }))
[17:47:54.435]             future::FutureResult(value = ...future.value$value, 
[17:47:54.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.435]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.435]                     ...future.globalenv.names))
[17:47:54.435]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.435]         }, condition = base::local({
[17:47:54.435]             c <- base::c
[17:47:54.435]             inherits <- base::inherits
[17:47:54.435]             invokeRestart <- base::invokeRestart
[17:47:54.435]             length <- base::length
[17:47:54.435]             list <- base::list
[17:47:54.435]             seq.int <- base::seq.int
[17:47:54.435]             signalCondition <- base::signalCondition
[17:47:54.435]             sys.calls <- base::sys.calls
[17:47:54.435]             `[[` <- base::`[[`
[17:47:54.435]             `+` <- base::`+`
[17:47:54.435]             `<<-` <- base::`<<-`
[17:47:54.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.435]                   3L)]
[17:47:54.435]             }
[17:47:54.435]             function(cond) {
[17:47:54.435]                 is_error <- inherits(cond, "error")
[17:47:54.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.435]                   NULL)
[17:47:54.435]                 if (is_error) {
[17:47:54.435]                   sessionInformation <- function() {
[17:47:54.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.435]                       search = base::search(), system = base::Sys.info())
[17:47:54.435]                   }
[17:47:54.435]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.435]                     cond$call), session = sessionInformation(), 
[17:47:54.435]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.435]                   signalCondition(cond)
[17:47:54.435]                 }
[17:47:54.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.435]                 "immediateCondition"))) {
[17:47:54.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.435]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.435]                   if (TRUE && !signal) {
[17:47:54.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.435]                     {
[17:47:54.435]                       inherits <- base::inherits
[17:47:54.435]                       invokeRestart <- base::invokeRestart
[17:47:54.435]                       is.null <- base::is.null
[17:47:54.435]                       muffled <- FALSE
[17:47:54.435]                       if (inherits(cond, "message")) {
[17:47:54.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.435]                         if (muffled) 
[17:47:54.435]                           invokeRestart("muffleMessage")
[17:47:54.435]                       }
[17:47:54.435]                       else if (inherits(cond, "warning")) {
[17:47:54.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.435]                         if (muffled) 
[17:47:54.435]                           invokeRestart("muffleWarning")
[17:47:54.435]                       }
[17:47:54.435]                       else if (inherits(cond, "condition")) {
[17:47:54.435]                         if (!is.null(pattern)) {
[17:47:54.435]                           computeRestarts <- base::computeRestarts
[17:47:54.435]                           grepl <- base::grepl
[17:47:54.435]                           restarts <- computeRestarts(cond)
[17:47:54.435]                           for (restart in restarts) {
[17:47:54.435]                             name <- restart$name
[17:47:54.435]                             if (is.null(name)) 
[17:47:54.435]                               next
[17:47:54.435]                             if (!grepl(pattern, name)) 
[17:47:54.435]                               next
[17:47:54.435]                             invokeRestart(restart)
[17:47:54.435]                             muffled <- TRUE
[17:47:54.435]                             break
[17:47:54.435]                           }
[17:47:54.435]                         }
[17:47:54.435]                       }
[17:47:54.435]                       invisible(muffled)
[17:47:54.435]                     }
[17:47:54.435]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.435]                   }
[17:47:54.435]                 }
[17:47:54.435]                 else {
[17:47:54.435]                   if (TRUE) {
[17:47:54.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.435]                     {
[17:47:54.435]                       inherits <- base::inherits
[17:47:54.435]                       invokeRestart <- base::invokeRestart
[17:47:54.435]                       is.null <- base::is.null
[17:47:54.435]                       muffled <- FALSE
[17:47:54.435]                       if (inherits(cond, "message")) {
[17:47:54.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.435]                         if (muffled) 
[17:47:54.435]                           invokeRestart("muffleMessage")
[17:47:54.435]                       }
[17:47:54.435]                       else if (inherits(cond, "warning")) {
[17:47:54.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.435]                         if (muffled) 
[17:47:54.435]                           invokeRestart("muffleWarning")
[17:47:54.435]                       }
[17:47:54.435]                       else if (inherits(cond, "condition")) {
[17:47:54.435]                         if (!is.null(pattern)) {
[17:47:54.435]                           computeRestarts <- base::computeRestarts
[17:47:54.435]                           grepl <- base::grepl
[17:47:54.435]                           restarts <- computeRestarts(cond)
[17:47:54.435]                           for (restart in restarts) {
[17:47:54.435]                             name <- restart$name
[17:47:54.435]                             if (is.null(name)) 
[17:47:54.435]                               next
[17:47:54.435]                             if (!grepl(pattern, name)) 
[17:47:54.435]                               next
[17:47:54.435]                             invokeRestart(restart)
[17:47:54.435]                             muffled <- TRUE
[17:47:54.435]                             break
[17:47:54.435]                           }
[17:47:54.435]                         }
[17:47:54.435]                       }
[17:47:54.435]                       invisible(muffled)
[17:47:54.435]                     }
[17:47:54.435]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.435]                   }
[17:47:54.435]                 }
[17:47:54.435]             }
[17:47:54.435]         }))
[17:47:54.435]     }, error = function(ex) {
[17:47:54.435]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.435]                 ...future.rng), started = ...future.startTime, 
[17:47:54.435]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.435]             version = "1.8"), class = "FutureResult")
[17:47:54.435]     }, finally = {
[17:47:54.435]         if (!identical(...future.workdir, getwd())) 
[17:47:54.435]             setwd(...future.workdir)
[17:47:54.435]         {
[17:47:54.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.435]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.435]             }
[17:47:54.435]             base::options(...future.oldOptions)
[17:47:54.435]             if (.Platform$OS.type == "windows") {
[17:47:54.435]                 old_names <- names(...future.oldEnvVars)
[17:47:54.435]                 envs <- base::Sys.getenv()
[17:47:54.435]                 names <- names(envs)
[17:47:54.435]                 common <- intersect(names, old_names)
[17:47:54.435]                 added <- setdiff(names, old_names)
[17:47:54.435]                 removed <- setdiff(old_names, names)
[17:47:54.435]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.435]                   envs[common]]
[17:47:54.435]                 NAMES <- toupper(changed)
[17:47:54.435]                 args <- list()
[17:47:54.435]                 for (kk in seq_along(NAMES)) {
[17:47:54.435]                   name <- changed[[kk]]
[17:47:54.435]                   NAME <- NAMES[[kk]]
[17:47:54.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.435]                     next
[17:47:54.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.435]                 }
[17:47:54.435]                 NAMES <- toupper(added)
[17:47:54.435]                 for (kk in seq_along(NAMES)) {
[17:47:54.435]                   name <- added[[kk]]
[17:47:54.435]                   NAME <- NAMES[[kk]]
[17:47:54.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.435]                     next
[17:47:54.435]                   args[[name]] <- ""
[17:47:54.435]                 }
[17:47:54.435]                 NAMES <- toupper(removed)
[17:47:54.435]                 for (kk in seq_along(NAMES)) {
[17:47:54.435]                   name <- removed[[kk]]
[17:47:54.435]                   NAME <- NAMES[[kk]]
[17:47:54.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.435]                     next
[17:47:54.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.435]                 }
[17:47:54.435]                 if (length(args) > 0) 
[17:47:54.435]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.435]             }
[17:47:54.435]             else {
[17:47:54.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.435]             }
[17:47:54.435]             {
[17:47:54.435]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.435]                   0L) {
[17:47:54.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.435]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.435]                   base::options(opts)
[17:47:54.435]                 }
[17:47:54.435]                 {
[17:47:54.435]                   {
[17:47:54.435]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.435]                     NULL
[17:47:54.435]                   }
[17:47:54.435]                   options(future.plan = NULL)
[17:47:54.435]                   if (is.na(NA_character_)) 
[17:47:54.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.435]                     .init = FALSE)
[17:47:54.435]                 }
[17:47:54.435]             }
[17:47:54.435]         }
[17:47:54.435]     })
[17:47:54.435]     if (TRUE) {
[17:47:54.435]         base::sink(type = "output", split = FALSE)
[17:47:54.435]         if (TRUE) {
[17:47:54.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.435]         }
[17:47:54.435]         else {
[17:47:54.435]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.435]         }
[17:47:54.435]         base::close(...future.stdout)
[17:47:54.435]         ...future.stdout <- NULL
[17:47:54.435]     }
[17:47:54.435]     ...future.result$conditions <- ...future.conditions
[17:47:54.435]     ...future.result$finished <- base::Sys.time()
[17:47:54.435]     ...future.result
[17:47:54.435] }
[17:47:54.439] assign_globals() ...
[17:47:54.439] List of 1
[17:47:54.439]  $ kk: int 2
[17:47:54.439]  - attr(*, "where")=List of 1
[17:47:54.439]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:54.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:54.439]  - attr(*, "resolved")= logi FALSE
[17:47:54.439]  - attr(*, "total_size")= num 56
[17:47:54.439]  - attr(*, "already-done")= logi TRUE
[17:47:54.443] - copied ‘kk’ to environment
[17:47:54.443] assign_globals() ... done
[17:47:54.443] requestCore(): workers = 2
[17:47:54.443] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:54.454] result() for MulticoreFuture ...
[17:47:54.455] result() for MulticoreFuture ...
[17:47:54.455] result() for MulticoreFuture ... done
[17:47:54.455] result() for MulticoreFuture ... done
[17:47:54.455] result() for MulticoreFuture ...
[17:47:54.455] result() for MulticoreFuture ... done
[17:47:54.458] MulticoreFuture started
[17:47:54.458] - Launch lazy future ... done
[17:47:54.458] run() for ‘MulticoreFuture’ ... done
[17:47:54.459] getGlobalsAndPackages() ...
[17:47:54.459] plan(): Setting new future strategy stack:
[17:47:54.459] Searching for globals...
[17:47:54.459] List of future strategies:
[17:47:54.459] 1. sequential:
[17:47:54.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:54.459]    - tweaked: FALSE
[17:47:54.459]    - call: NULL
[17:47:54.461] plan(): nbrOfWorkers() = 1
[17:47:54.462] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:54.462] Searching for globals ... DONE
[17:47:54.463] Resolving globals: FALSE
[17:47:54.463] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:54.464] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:54.464] - globals: [1] ‘kk’
[17:47:54.464] 
[17:47:54.465] getGlobalsAndPackages() ... DONE
[17:47:54.465] run() for ‘Future’ ...
[17:47:54.465] - state: ‘created’
[17:47:54.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.470] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.471]   - Field: ‘label’
[17:47:54.471]   - Field: ‘local’
[17:47:54.471]   - Field: ‘owner’
[17:47:54.471]   - Field: ‘envir’
[17:47:54.471]   - Field: ‘workers’
[17:47:54.472]   - Field: ‘packages’
[17:47:54.472]   - Field: ‘gc’
[17:47:54.472]   - Field: ‘job’
[17:47:54.472]   - Field: ‘conditions’
[17:47:54.472]   - Field: ‘expr’
[17:47:54.472]   - Field: ‘uuid’
[17:47:54.473]   - Field: ‘seed’
[17:47:54.473]   - Field: ‘version’
[17:47:54.473]   - Field: ‘result’
[17:47:54.473]   - Field: ‘asynchronous’
[17:47:54.473]   - Field: ‘calls’
[17:47:54.477]   - Field: ‘globals’
[17:47:54.477]   - Field: ‘stdout’
[17:47:54.477]   - Field: ‘earlySignal’
[17:47:54.478]   - Field: ‘lazy’
[17:47:54.478]   - Field: ‘state’
[17:47:54.478] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.479] - Launch lazy future ...
[17:47:54.479] Packages needed by the future expression (n = 0): <none>
[17:47:54.479] Packages needed by future strategies (n = 0): <none>
[17:47:54.481] {
[17:47:54.481]     {
[17:47:54.481]         {
[17:47:54.481]             ...future.startTime <- base::Sys.time()
[17:47:54.481]             {
[17:47:54.481]                 {
[17:47:54.481]                   {
[17:47:54.481]                     {
[17:47:54.481]                       base::local({
[17:47:54.481]                         has_future <- base::requireNamespace("future", 
[17:47:54.481]                           quietly = TRUE)
[17:47:54.481]                         if (has_future) {
[17:47:54.481]                           ns <- base::getNamespace("future")
[17:47:54.481]                           version <- ns[[".package"]][["version"]]
[17:47:54.481]                           if (is.null(version)) 
[17:47:54.481]                             version <- utils::packageVersion("future")
[17:47:54.481]                         }
[17:47:54.481]                         else {
[17:47:54.481]                           version <- NULL
[17:47:54.481]                         }
[17:47:54.481]                         if (!has_future || version < "1.8.0") {
[17:47:54.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.481]                             "", base::R.version$version.string), 
[17:47:54.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.481]                               "release", "version")], collapse = " "), 
[17:47:54.481]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.481]                             info)
[17:47:54.481]                           info <- base::paste(info, collapse = "; ")
[17:47:54.481]                           if (!has_future) {
[17:47:54.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.481]                               info)
[17:47:54.481]                           }
[17:47:54.481]                           else {
[17:47:54.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.481]                               info, version)
[17:47:54.481]                           }
[17:47:54.481]                           base::stop(msg)
[17:47:54.481]                         }
[17:47:54.481]                       })
[17:47:54.481]                     }
[17:47:54.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.481]                     base::options(mc.cores = 1L)
[17:47:54.481]                   }
[17:47:54.481]                   ...future.strategy.old <- future::plan("list")
[17:47:54.481]                   options(future.plan = NULL)
[17:47:54.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.481]                 }
[17:47:54.481]                 ...future.workdir <- getwd()
[17:47:54.481]             }
[17:47:54.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.481]         }
[17:47:54.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.481]             base::names(...future.oldOptions))
[17:47:54.481]     }
[17:47:54.481]     if (FALSE) {
[17:47:54.481]     }
[17:47:54.481]     else {
[17:47:54.481]         if (TRUE) {
[17:47:54.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.481]                 open = "w")
[17:47:54.481]         }
[17:47:54.481]         else {
[17:47:54.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.481]         }
[17:47:54.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.481]             base::sink(type = "output", split = FALSE)
[17:47:54.481]             base::close(...future.stdout)
[17:47:54.481]         }, add = TRUE)
[17:47:54.481]     }
[17:47:54.481]     ...future.frame <- base::sys.nframe()
[17:47:54.481]     ...future.conditions <- base::list()
[17:47:54.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.481]     if (FALSE) {
[17:47:54.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.481]     }
[17:47:54.481]     ...future.result <- base::tryCatch({
[17:47:54.481]         base::withCallingHandlers({
[17:47:54.481]             ...future.value <- base::withVisible(base::local({
[17:47:54.481]                 withCallingHandlers({
[17:47:54.481]                   {
[17:47:54.481]                     Sys.sleep(0.1)
[17:47:54.481]                     kk
[17:47:54.481]                   }
[17:47:54.481]                 }, immediateCondition = function(cond) {
[17:47:54.481]                   save_rds <- function (object, pathname, ...) 
[17:47:54.481]                   {
[17:47:54.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.481]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.481]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.481]                         fi_tmp[["mtime"]])
[17:47:54.481]                     }
[17:47:54.481]                     tryCatch({
[17:47:54.481]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.481]                     }, error = function(ex) {
[17:47:54.481]                       msg <- conditionMessage(ex)
[17:47:54.481]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.481]                         fi_tmp[["mtime"]], msg)
[17:47:54.481]                       ex$message <- msg
[17:47:54.481]                       stop(ex)
[17:47:54.481]                     })
[17:47:54.481]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.481]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.481]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.481]                       fi <- file.info(pathname)
[17:47:54.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.481]                         fi[["size"]], fi[["mtime"]])
[17:47:54.481]                       stop(msg)
[17:47:54.481]                     }
[17:47:54.481]                     invisible(pathname)
[17:47:54.481]                   }
[17:47:54.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.481]                     rootPath = tempdir()) 
[17:47:54.481]                   {
[17:47:54.481]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.481]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.481]                       tmpdir = path, fileext = ".rds")
[17:47:54.481]                     save_rds(obj, file)
[17:47:54.481]                   }
[17:47:54.481]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.481]                   {
[17:47:54.481]                     inherits <- base::inherits
[17:47:54.481]                     invokeRestart <- base::invokeRestart
[17:47:54.481]                     is.null <- base::is.null
[17:47:54.481]                     muffled <- FALSE
[17:47:54.481]                     if (inherits(cond, "message")) {
[17:47:54.481]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.481]                       if (muffled) 
[17:47:54.481]                         invokeRestart("muffleMessage")
[17:47:54.481]                     }
[17:47:54.481]                     else if (inherits(cond, "warning")) {
[17:47:54.481]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.481]                       if (muffled) 
[17:47:54.481]                         invokeRestart("muffleWarning")
[17:47:54.481]                     }
[17:47:54.481]                     else if (inherits(cond, "condition")) {
[17:47:54.481]                       if (!is.null(pattern)) {
[17:47:54.481]                         computeRestarts <- base::computeRestarts
[17:47:54.481]                         grepl <- base::grepl
[17:47:54.481]                         restarts <- computeRestarts(cond)
[17:47:54.481]                         for (restart in restarts) {
[17:47:54.481]                           name <- restart$name
[17:47:54.481]                           if (is.null(name)) 
[17:47:54.481]                             next
[17:47:54.481]                           if (!grepl(pattern, name)) 
[17:47:54.481]                             next
[17:47:54.481]                           invokeRestart(restart)
[17:47:54.481]                           muffled <- TRUE
[17:47:54.481]                           break
[17:47:54.481]                         }
[17:47:54.481]                       }
[17:47:54.481]                     }
[17:47:54.481]                     invisible(muffled)
[17:47:54.481]                   }
[17:47:54.481]                   muffleCondition(cond)
[17:47:54.481]                 })
[17:47:54.481]             }))
[17:47:54.481]             future::FutureResult(value = ...future.value$value, 
[17:47:54.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.481]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.481]                     ...future.globalenv.names))
[17:47:54.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.481]         }, condition = base::local({
[17:47:54.481]             c <- base::c
[17:47:54.481]             inherits <- base::inherits
[17:47:54.481]             invokeRestart <- base::invokeRestart
[17:47:54.481]             length <- base::length
[17:47:54.481]             list <- base::list
[17:47:54.481]             seq.int <- base::seq.int
[17:47:54.481]             signalCondition <- base::signalCondition
[17:47:54.481]             sys.calls <- base::sys.calls
[17:47:54.481]             `[[` <- base::`[[`
[17:47:54.481]             `+` <- base::`+`
[17:47:54.481]             `<<-` <- base::`<<-`
[17:47:54.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.481]                   3L)]
[17:47:54.481]             }
[17:47:54.481]             function(cond) {
[17:47:54.481]                 is_error <- inherits(cond, "error")
[17:47:54.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.481]                   NULL)
[17:47:54.481]                 if (is_error) {
[17:47:54.481]                   sessionInformation <- function() {
[17:47:54.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.481]                       search = base::search(), system = base::Sys.info())
[17:47:54.481]                   }
[17:47:54.481]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.481]                     cond$call), session = sessionInformation(), 
[17:47:54.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.481]                   signalCondition(cond)
[17:47:54.481]                 }
[17:47:54.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.481]                 "immediateCondition"))) {
[17:47:54.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.481]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.481]                   if (TRUE && !signal) {
[17:47:54.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.481]                     {
[17:47:54.481]                       inherits <- base::inherits
[17:47:54.481]                       invokeRestart <- base::invokeRestart
[17:47:54.481]                       is.null <- base::is.null
[17:47:54.481]                       muffled <- FALSE
[17:47:54.481]                       if (inherits(cond, "message")) {
[17:47:54.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.481]                         if (muffled) 
[17:47:54.481]                           invokeRestart("muffleMessage")
[17:47:54.481]                       }
[17:47:54.481]                       else if (inherits(cond, "warning")) {
[17:47:54.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.481]                         if (muffled) 
[17:47:54.481]                           invokeRestart("muffleWarning")
[17:47:54.481]                       }
[17:47:54.481]                       else if (inherits(cond, "condition")) {
[17:47:54.481]                         if (!is.null(pattern)) {
[17:47:54.481]                           computeRestarts <- base::computeRestarts
[17:47:54.481]                           grepl <- base::grepl
[17:47:54.481]                           restarts <- computeRestarts(cond)
[17:47:54.481]                           for (restart in restarts) {
[17:47:54.481]                             name <- restart$name
[17:47:54.481]                             if (is.null(name)) 
[17:47:54.481]                               next
[17:47:54.481]                             if (!grepl(pattern, name)) 
[17:47:54.481]                               next
[17:47:54.481]                             invokeRestart(restart)
[17:47:54.481]                             muffled <- TRUE
[17:47:54.481]                             break
[17:47:54.481]                           }
[17:47:54.481]                         }
[17:47:54.481]                       }
[17:47:54.481]                       invisible(muffled)
[17:47:54.481]                     }
[17:47:54.481]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.481]                   }
[17:47:54.481]                 }
[17:47:54.481]                 else {
[17:47:54.481]                   if (TRUE) {
[17:47:54.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.481]                     {
[17:47:54.481]                       inherits <- base::inherits
[17:47:54.481]                       invokeRestart <- base::invokeRestart
[17:47:54.481]                       is.null <- base::is.null
[17:47:54.481]                       muffled <- FALSE
[17:47:54.481]                       if (inherits(cond, "message")) {
[17:47:54.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.481]                         if (muffled) 
[17:47:54.481]                           invokeRestart("muffleMessage")
[17:47:54.481]                       }
[17:47:54.481]                       else if (inherits(cond, "warning")) {
[17:47:54.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.481]                         if (muffled) 
[17:47:54.481]                           invokeRestart("muffleWarning")
[17:47:54.481]                       }
[17:47:54.481]                       else if (inherits(cond, "condition")) {
[17:47:54.481]                         if (!is.null(pattern)) {
[17:47:54.481]                           computeRestarts <- base::computeRestarts
[17:47:54.481]                           grepl <- base::grepl
[17:47:54.481]                           restarts <- computeRestarts(cond)
[17:47:54.481]                           for (restart in restarts) {
[17:47:54.481]                             name <- restart$name
[17:47:54.481]                             if (is.null(name)) 
[17:47:54.481]                               next
[17:47:54.481]                             if (!grepl(pattern, name)) 
[17:47:54.481]                               next
[17:47:54.481]                             invokeRestart(restart)
[17:47:54.481]                             muffled <- TRUE
[17:47:54.481]                             break
[17:47:54.481]                           }
[17:47:54.481]                         }
[17:47:54.481]                       }
[17:47:54.481]                       invisible(muffled)
[17:47:54.481]                     }
[17:47:54.481]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.481]                   }
[17:47:54.481]                 }
[17:47:54.481]             }
[17:47:54.481]         }))
[17:47:54.481]     }, error = function(ex) {
[17:47:54.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.481]                 ...future.rng), started = ...future.startTime, 
[17:47:54.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.481]             version = "1.8"), class = "FutureResult")
[17:47:54.481]     }, finally = {
[17:47:54.481]         if (!identical(...future.workdir, getwd())) 
[17:47:54.481]             setwd(...future.workdir)
[17:47:54.481]         {
[17:47:54.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.481]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.481]             }
[17:47:54.481]             base::options(...future.oldOptions)
[17:47:54.481]             if (.Platform$OS.type == "windows") {
[17:47:54.481]                 old_names <- names(...future.oldEnvVars)
[17:47:54.481]                 envs <- base::Sys.getenv()
[17:47:54.481]                 names <- names(envs)
[17:47:54.481]                 common <- intersect(names, old_names)
[17:47:54.481]                 added <- setdiff(names, old_names)
[17:47:54.481]                 removed <- setdiff(old_names, names)
[17:47:54.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.481]                   envs[common]]
[17:47:54.481]                 NAMES <- toupper(changed)
[17:47:54.481]                 args <- list()
[17:47:54.481]                 for (kk in seq_along(NAMES)) {
[17:47:54.481]                   name <- changed[[kk]]
[17:47:54.481]                   NAME <- NAMES[[kk]]
[17:47:54.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.481]                     next
[17:47:54.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.481]                 }
[17:47:54.481]                 NAMES <- toupper(added)
[17:47:54.481]                 for (kk in seq_along(NAMES)) {
[17:47:54.481]                   name <- added[[kk]]
[17:47:54.481]                   NAME <- NAMES[[kk]]
[17:47:54.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.481]                     next
[17:47:54.481]                   args[[name]] <- ""
[17:47:54.481]                 }
[17:47:54.481]                 NAMES <- toupper(removed)
[17:47:54.481]                 for (kk in seq_along(NAMES)) {
[17:47:54.481]                   name <- removed[[kk]]
[17:47:54.481]                   NAME <- NAMES[[kk]]
[17:47:54.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.481]                     next
[17:47:54.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.481]                 }
[17:47:54.481]                 if (length(args) > 0) 
[17:47:54.481]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.481]             }
[17:47:54.481]             else {
[17:47:54.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.481]             }
[17:47:54.481]             {
[17:47:54.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.481]                   0L) {
[17:47:54.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.481]                   base::options(opts)
[17:47:54.481]                 }
[17:47:54.481]                 {
[17:47:54.481]                   {
[17:47:54.481]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.481]                     NULL
[17:47:54.481]                   }
[17:47:54.481]                   options(future.plan = NULL)
[17:47:54.481]                   if (is.na(NA_character_)) 
[17:47:54.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.481]                     .init = FALSE)
[17:47:54.481]                 }
[17:47:54.481]             }
[17:47:54.481]         }
[17:47:54.481]     })
[17:47:54.481]     if (TRUE) {
[17:47:54.481]         base::sink(type = "output", split = FALSE)
[17:47:54.481]         if (TRUE) {
[17:47:54.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.481]         }
[17:47:54.481]         else {
[17:47:54.481]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.481]         }
[17:47:54.481]         base::close(...future.stdout)
[17:47:54.481]         ...future.stdout <- NULL
[17:47:54.481]     }
[17:47:54.481]     ...future.result$conditions <- ...future.conditions
[17:47:54.481]     ...future.result$finished <- base::Sys.time()
[17:47:54.481]     ...future.result
[17:47:54.481] }
[17:47:54.484] assign_globals() ...
[17:47:54.484] List of 1
[17:47:54.484]  $ kk: int 3
[17:47:54.484]  - attr(*, "where")=List of 1
[17:47:54.484]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:54.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:54.484]  - attr(*, "resolved")= logi FALSE
[17:47:54.484]  - attr(*, "total_size")= num 56
[17:47:54.484]  - attr(*, "already-done")= logi TRUE
[17:47:54.488] - copied ‘kk’ to environment
[17:47:54.488] assign_globals() ... done
[17:47:54.488] requestCore(): workers = 2
[17:47:54.488] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:54.520] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:47:54.523] plan(): Setting new future strategy stack:
[17:47:54.523] List of future strategies:
[17:47:54.523] 1. multicore:
[17:47:54.523]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.523]    - tweaked: FALSE
[17:47:54.523]    - call: plan(strategy)
[17:47:54.528] plan(): nbrOfWorkers() = 2
[17:47:54.530] result() for MulticoreFuture ...
[17:47:54.531] result() for MulticoreFuture ...
[17:47:54.531] result() for MulticoreFuture ... done
[17:47:54.532] result() for MulticoreFuture ... done
[17:47:54.532] result() for MulticoreFuture ...
[17:47:54.532] result() for MulticoreFuture ... done
[17:47:54.535] MulticoreFuture started
[17:47:54.535] - Launch lazy future ... done
[17:47:54.535] run() for ‘MulticoreFuture’ ... done
[17:47:54.536] resolve() on list ...
[17:47:54.536]  recursive: 0
[17:47:54.536] plan(): Setting new future strategy stack:
[17:47:54.536]  length: 3
[17:47:54.536] 
[17:47:54.536] Future #1
[17:47:54.537]  length: 2 (resolved future 1)
[17:47:54.536] List of future strategies:
[17:47:54.536] 1. sequential:
[17:47:54.536]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:54.536]    - tweaked: FALSE
[17:47:54.536]    - call: NULL
[17:47:54.538] plan(): nbrOfWorkers() = 1
[17:47:54.564] plan(): Setting new future strategy stack:
[17:47:54.564] List of future strategies:
[17:47:54.564] 1. multicore:
[17:47:54.564]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.564]    - tweaked: FALSE
[17:47:54.564]    - call: plan(strategy)
[17:47:54.568] plan(): nbrOfWorkers() = 2
[17:47:54.569] Future #2
[17:47:54.569]  length: 1 (resolved future 2)
[17:47:54.640] plan(): Setting new future strategy stack:
[17:47:54.640] List of future strategies:
[17:47:54.640] 1. multicore:
[17:47:54.640]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.640]    - tweaked: FALSE
[17:47:54.640]    - call: plan(strategy)
[17:47:54.646] plan(): nbrOfWorkers() = 2
[17:47:54.651] Future #3
[17:47:54.651]  length: 0 (resolved future 3)
[17:47:54.651] resolve() on list ... DONE
[17:47:54.651] getGlobalsAndPackages() ...
[17:47:54.651] Searching for globals...
[17:47:54.654] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:54.654] Searching for globals ... DONE
[17:47:54.654] Resolving globals: FALSE
[17:47:54.655] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:54.655] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:54.656] - globals: [1] ‘kk’
[17:47:54.656] 
[17:47:54.656] getGlobalsAndPackages() ... DONE
[17:47:54.656] getGlobalsAndPackages() ...
[17:47:54.657] Searching for globals...
[17:47:54.658] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:54.658] Searching for globals ... DONE
[17:47:54.658] Resolving globals: FALSE
[17:47:54.659] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:54.659] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:54.660] - globals: [1] ‘kk’
[17:47:54.660] 
[17:47:54.660] getGlobalsAndPackages() ... DONE
[17:47:54.660] getGlobalsAndPackages() ...
[17:47:54.660] Searching for globals...
[17:47:54.662] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:47:54.662] Searching for globals ... DONE
[17:47:54.662] Resolving globals: FALSE
[17:47:54.663] The total size of the 1 globals is 56 bytes (56 bytes)
[17:47:54.663] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:47:54.663] - globals: [1] ‘kk’
[17:47:54.663] 
[17:47:54.664] getGlobalsAndPackages() ... DONE
[17:47:54.664] resolve() on list ...
[17:47:54.664]  recursive: 0
[17:47:54.664]  length: 3
[17:47:54.664] 
[17:47:54.665] run() for ‘Future’ ...
[17:47:54.665] - state: ‘created’
[17:47:54.665] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.669] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.670]   - Field: ‘label’
[17:47:54.670]   - Field: ‘local’
[17:47:54.670]   - Field: ‘owner’
[17:47:54.670]   - Field: ‘envir’
[17:47:54.670]   - Field: ‘workers’
[17:47:54.670]   - Field: ‘packages’
[17:47:54.671]   - Field: ‘gc’
[17:47:54.671]   - Field: ‘job’
[17:47:54.671]   - Field: ‘conditions’
[17:47:54.671]   - Field: ‘expr’
[17:47:54.671]   - Field: ‘uuid’
[17:47:54.671]   - Field: ‘seed’
[17:47:54.671]   - Field: ‘version’
[17:47:54.672]   - Field: ‘result’
[17:47:54.672]   - Field: ‘asynchronous’
[17:47:54.672]   - Field: ‘calls’
[17:47:54.672]   - Field: ‘globals’
[17:47:54.672]   - Field: ‘stdout’
[17:47:54.672]   - Field: ‘earlySignal’
[17:47:54.672]   - Field: ‘lazy’
[17:47:54.672]   - Field: ‘state’
[17:47:54.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.673] - Launch lazy future ...
[17:47:54.673] Packages needed by the future expression (n = 0): <none>
[17:47:54.673] Packages needed by future strategies (n = 0): <none>
[17:47:54.674] {
[17:47:54.674]     {
[17:47:54.674]         {
[17:47:54.674]             ...future.startTime <- base::Sys.time()
[17:47:54.674]             {
[17:47:54.674]                 {
[17:47:54.674]                   {
[17:47:54.674]                     {
[17:47:54.674]                       base::local({
[17:47:54.674]                         has_future <- base::requireNamespace("future", 
[17:47:54.674]                           quietly = TRUE)
[17:47:54.674]                         if (has_future) {
[17:47:54.674]                           ns <- base::getNamespace("future")
[17:47:54.674]                           version <- ns[[".package"]][["version"]]
[17:47:54.674]                           if (is.null(version)) 
[17:47:54.674]                             version <- utils::packageVersion("future")
[17:47:54.674]                         }
[17:47:54.674]                         else {
[17:47:54.674]                           version <- NULL
[17:47:54.674]                         }
[17:47:54.674]                         if (!has_future || version < "1.8.0") {
[17:47:54.674]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.674]                             "", base::R.version$version.string), 
[17:47:54.674]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.674]                               "release", "version")], collapse = " "), 
[17:47:54.674]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.674]                             info)
[17:47:54.674]                           info <- base::paste(info, collapse = "; ")
[17:47:54.674]                           if (!has_future) {
[17:47:54.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.674]                               info)
[17:47:54.674]                           }
[17:47:54.674]                           else {
[17:47:54.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.674]                               info, version)
[17:47:54.674]                           }
[17:47:54.674]                           base::stop(msg)
[17:47:54.674]                         }
[17:47:54.674]                       })
[17:47:54.674]                     }
[17:47:54.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.674]                     base::options(mc.cores = 1L)
[17:47:54.674]                   }
[17:47:54.674]                   ...future.strategy.old <- future::plan("list")
[17:47:54.674]                   options(future.plan = NULL)
[17:47:54.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.674]                 }
[17:47:54.674]                 ...future.workdir <- getwd()
[17:47:54.674]             }
[17:47:54.674]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.674]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.674]         }
[17:47:54.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.674]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.674]             base::names(...future.oldOptions))
[17:47:54.674]     }
[17:47:54.674]     if (FALSE) {
[17:47:54.674]     }
[17:47:54.674]     else {
[17:47:54.674]         if (TRUE) {
[17:47:54.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.674]                 open = "w")
[17:47:54.674]         }
[17:47:54.674]         else {
[17:47:54.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.674]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.674]         }
[17:47:54.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.674]             base::sink(type = "output", split = FALSE)
[17:47:54.674]             base::close(...future.stdout)
[17:47:54.674]         }, add = TRUE)
[17:47:54.674]     }
[17:47:54.674]     ...future.frame <- base::sys.nframe()
[17:47:54.674]     ...future.conditions <- base::list()
[17:47:54.674]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.674]     if (FALSE) {
[17:47:54.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.674]     }
[17:47:54.674]     ...future.result <- base::tryCatch({
[17:47:54.674]         base::withCallingHandlers({
[17:47:54.674]             ...future.value <- base::withVisible(base::local({
[17:47:54.674]                 withCallingHandlers({
[17:47:54.674]                   {
[17:47:54.674]                     Sys.sleep(0.1)
[17:47:54.674]                     kk
[17:47:54.674]                   }
[17:47:54.674]                 }, immediateCondition = function(cond) {
[17:47:54.674]                   save_rds <- function (object, pathname, ...) 
[17:47:54.674]                   {
[17:47:54.674]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.674]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.674]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.674]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.674]                         fi_tmp[["mtime"]])
[17:47:54.674]                     }
[17:47:54.674]                     tryCatch({
[17:47:54.674]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.674]                     }, error = function(ex) {
[17:47:54.674]                       msg <- conditionMessage(ex)
[17:47:54.674]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.674]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.674]                         fi_tmp[["mtime"]], msg)
[17:47:54.674]                       ex$message <- msg
[17:47:54.674]                       stop(ex)
[17:47:54.674]                     })
[17:47:54.674]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.674]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.674]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.674]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.674]                       fi <- file.info(pathname)
[17:47:54.674]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.674]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.674]                         fi[["size"]], fi[["mtime"]])
[17:47:54.674]                       stop(msg)
[17:47:54.674]                     }
[17:47:54.674]                     invisible(pathname)
[17:47:54.674]                   }
[17:47:54.674]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.674]                     rootPath = tempdir()) 
[17:47:54.674]                   {
[17:47:54.674]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.674]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.674]                       tmpdir = path, fileext = ".rds")
[17:47:54.674]                     save_rds(obj, file)
[17:47:54.674]                   }
[17:47:54.674]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.674]                   {
[17:47:54.674]                     inherits <- base::inherits
[17:47:54.674]                     invokeRestart <- base::invokeRestart
[17:47:54.674]                     is.null <- base::is.null
[17:47:54.674]                     muffled <- FALSE
[17:47:54.674]                     if (inherits(cond, "message")) {
[17:47:54.674]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.674]                       if (muffled) 
[17:47:54.674]                         invokeRestart("muffleMessage")
[17:47:54.674]                     }
[17:47:54.674]                     else if (inherits(cond, "warning")) {
[17:47:54.674]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.674]                       if (muffled) 
[17:47:54.674]                         invokeRestart("muffleWarning")
[17:47:54.674]                     }
[17:47:54.674]                     else if (inherits(cond, "condition")) {
[17:47:54.674]                       if (!is.null(pattern)) {
[17:47:54.674]                         computeRestarts <- base::computeRestarts
[17:47:54.674]                         grepl <- base::grepl
[17:47:54.674]                         restarts <- computeRestarts(cond)
[17:47:54.674]                         for (restart in restarts) {
[17:47:54.674]                           name <- restart$name
[17:47:54.674]                           if (is.null(name)) 
[17:47:54.674]                             next
[17:47:54.674]                           if (!grepl(pattern, name)) 
[17:47:54.674]                             next
[17:47:54.674]                           invokeRestart(restart)
[17:47:54.674]                           muffled <- TRUE
[17:47:54.674]                           break
[17:47:54.674]                         }
[17:47:54.674]                       }
[17:47:54.674]                     }
[17:47:54.674]                     invisible(muffled)
[17:47:54.674]                   }
[17:47:54.674]                   muffleCondition(cond)
[17:47:54.674]                 })
[17:47:54.674]             }))
[17:47:54.674]             future::FutureResult(value = ...future.value$value, 
[17:47:54.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.674]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.674]                     ...future.globalenv.names))
[17:47:54.674]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.674]         }, condition = base::local({
[17:47:54.674]             c <- base::c
[17:47:54.674]             inherits <- base::inherits
[17:47:54.674]             invokeRestart <- base::invokeRestart
[17:47:54.674]             length <- base::length
[17:47:54.674]             list <- base::list
[17:47:54.674]             seq.int <- base::seq.int
[17:47:54.674]             signalCondition <- base::signalCondition
[17:47:54.674]             sys.calls <- base::sys.calls
[17:47:54.674]             `[[` <- base::`[[`
[17:47:54.674]             `+` <- base::`+`
[17:47:54.674]             `<<-` <- base::`<<-`
[17:47:54.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.674]                   3L)]
[17:47:54.674]             }
[17:47:54.674]             function(cond) {
[17:47:54.674]                 is_error <- inherits(cond, "error")
[17:47:54.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.674]                   NULL)
[17:47:54.674]                 if (is_error) {
[17:47:54.674]                   sessionInformation <- function() {
[17:47:54.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.674]                       search = base::search(), system = base::Sys.info())
[17:47:54.674]                   }
[17:47:54.674]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.674]                     cond$call), session = sessionInformation(), 
[17:47:54.674]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.674]                   signalCondition(cond)
[17:47:54.674]                 }
[17:47:54.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.674]                 "immediateCondition"))) {
[17:47:54.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.674]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.674]                   if (TRUE && !signal) {
[17:47:54.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.674]                     {
[17:47:54.674]                       inherits <- base::inherits
[17:47:54.674]                       invokeRestart <- base::invokeRestart
[17:47:54.674]                       is.null <- base::is.null
[17:47:54.674]                       muffled <- FALSE
[17:47:54.674]                       if (inherits(cond, "message")) {
[17:47:54.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.674]                         if (muffled) 
[17:47:54.674]                           invokeRestart("muffleMessage")
[17:47:54.674]                       }
[17:47:54.674]                       else if (inherits(cond, "warning")) {
[17:47:54.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.674]                         if (muffled) 
[17:47:54.674]                           invokeRestart("muffleWarning")
[17:47:54.674]                       }
[17:47:54.674]                       else if (inherits(cond, "condition")) {
[17:47:54.674]                         if (!is.null(pattern)) {
[17:47:54.674]                           computeRestarts <- base::computeRestarts
[17:47:54.674]                           grepl <- base::grepl
[17:47:54.674]                           restarts <- computeRestarts(cond)
[17:47:54.674]                           for (restart in restarts) {
[17:47:54.674]                             name <- restart$name
[17:47:54.674]                             if (is.null(name)) 
[17:47:54.674]                               next
[17:47:54.674]                             if (!grepl(pattern, name)) 
[17:47:54.674]                               next
[17:47:54.674]                             invokeRestart(restart)
[17:47:54.674]                             muffled <- TRUE
[17:47:54.674]                             break
[17:47:54.674]                           }
[17:47:54.674]                         }
[17:47:54.674]                       }
[17:47:54.674]                       invisible(muffled)
[17:47:54.674]                     }
[17:47:54.674]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.674]                   }
[17:47:54.674]                 }
[17:47:54.674]                 else {
[17:47:54.674]                   if (TRUE) {
[17:47:54.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.674]                     {
[17:47:54.674]                       inherits <- base::inherits
[17:47:54.674]                       invokeRestart <- base::invokeRestart
[17:47:54.674]                       is.null <- base::is.null
[17:47:54.674]                       muffled <- FALSE
[17:47:54.674]                       if (inherits(cond, "message")) {
[17:47:54.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.674]                         if (muffled) 
[17:47:54.674]                           invokeRestart("muffleMessage")
[17:47:54.674]                       }
[17:47:54.674]                       else if (inherits(cond, "warning")) {
[17:47:54.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.674]                         if (muffled) 
[17:47:54.674]                           invokeRestart("muffleWarning")
[17:47:54.674]                       }
[17:47:54.674]                       else if (inherits(cond, "condition")) {
[17:47:54.674]                         if (!is.null(pattern)) {
[17:47:54.674]                           computeRestarts <- base::computeRestarts
[17:47:54.674]                           grepl <- base::grepl
[17:47:54.674]                           restarts <- computeRestarts(cond)
[17:47:54.674]                           for (restart in restarts) {
[17:47:54.674]                             name <- restart$name
[17:47:54.674]                             if (is.null(name)) 
[17:47:54.674]                               next
[17:47:54.674]                             if (!grepl(pattern, name)) 
[17:47:54.674]                               next
[17:47:54.674]                             invokeRestart(restart)
[17:47:54.674]                             muffled <- TRUE
[17:47:54.674]                             break
[17:47:54.674]                           }
[17:47:54.674]                         }
[17:47:54.674]                       }
[17:47:54.674]                       invisible(muffled)
[17:47:54.674]                     }
[17:47:54.674]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.674]                   }
[17:47:54.674]                 }
[17:47:54.674]             }
[17:47:54.674]         }))
[17:47:54.674]     }, error = function(ex) {
[17:47:54.674]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.674]                 ...future.rng), started = ...future.startTime, 
[17:47:54.674]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.674]             version = "1.8"), class = "FutureResult")
[17:47:54.674]     }, finally = {
[17:47:54.674]         if (!identical(...future.workdir, getwd())) 
[17:47:54.674]             setwd(...future.workdir)
[17:47:54.674]         {
[17:47:54.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.674]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.674]             }
[17:47:54.674]             base::options(...future.oldOptions)
[17:47:54.674]             if (.Platform$OS.type == "windows") {
[17:47:54.674]                 old_names <- names(...future.oldEnvVars)
[17:47:54.674]                 envs <- base::Sys.getenv()
[17:47:54.674]                 names <- names(envs)
[17:47:54.674]                 common <- intersect(names, old_names)
[17:47:54.674]                 added <- setdiff(names, old_names)
[17:47:54.674]                 removed <- setdiff(old_names, names)
[17:47:54.674]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.674]                   envs[common]]
[17:47:54.674]                 NAMES <- toupper(changed)
[17:47:54.674]                 args <- list()
[17:47:54.674]                 for (kk in seq_along(NAMES)) {
[17:47:54.674]                   name <- changed[[kk]]
[17:47:54.674]                   NAME <- NAMES[[kk]]
[17:47:54.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.674]                     next
[17:47:54.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.674]                 }
[17:47:54.674]                 NAMES <- toupper(added)
[17:47:54.674]                 for (kk in seq_along(NAMES)) {
[17:47:54.674]                   name <- added[[kk]]
[17:47:54.674]                   NAME <- NAMES[[kk]]
[17:47:54.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.674]                     next
[17:47:54.674]                   args[[name]] <- ""
[17:47:54.674]                 }
[17:47:54.674]                 NAMES <- toupper(removed)
[17:47:54.674]                 for (kk in seq_along(NAMES)) {
[17:47:54.674]                   name <- removed[[kk]]
[17:47:54.674]                   NAME <- NAMES[[kk]]
[17:47:54.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.674]                     next
[17:47:54.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.674]                 }
[17:47:54.674]                 if (length(args) > 0) 
[17:47:54.674]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.674]             }
[17:47:54.674]             else {
[17:47:54.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.674]             }
[17:47:54.674]             {
[17:47:54.674]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.674]                   0L) {
[17:47:54.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.674]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.674]                   base::options(opts)
[17:47:54.674]                 }
[17:47:54.674]                 {
[17:47:54.674]                   {
[17:47:54.674]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.674]                     NULL
[17:47:54.674]                   }
[17:47:54.674]                   options(future.plan = NULL)
[17:47:54.674]                   if (is.na(NA_character_)) 
[17:47:54.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.674]                     .init = FALSE)
[17:47:54.674]                 }
[17:47:54.674]             }
[17:47:54.674]         }
[17:47:54.674]     })
[17:47:54.674]     if (TRUE) {
[17:47:54.674]         base::sink(type = "output", split = FALSE)
[17:47:54.674]         if (TRUE) {
[17:47:54.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.674]         }
[17:47:54.674]         else {
[17:47:54.674]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.674]         }
[17:47:54.674]         base::close(...future.stdout)
[17:47:54.674]         ...future.stdout <- NULL
[17:47:54.674]     }
[17:47:54.674]     ...future.result$conditions <- ...future.conditions
[17:47:54.674]     ...future.result$finished <- base::Sys.time()
[17:47:54.674]     ...future.result
[17:47:54.674] }
[17:47:54.677] assign_globals() ...
[17:47:54.677] List of 1
[17:47:54.677]  $ kk: int 1
[17:47:54.677]  - attr(*, "where")=List of 1
[17:47:54.677]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:54.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:54.677]  - attr(*, "resolved")= logi FALSE
[17:47:54.677]  - attr(*, "total_size")= num 56
[17:47:54.677]  - attr(*, "already-done")= logi TRUE
[17:47:54.681] - copied ‘kk’ to environment
[17:47:54.681] assign_globals() ... done
[17:47:54.684] requestCore(): workers = 2
[17:47:54.685] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:54.696] result() for MulticoreFuture ...
[17:47:54.697] result() for MulticoreFuture ...
[17:47:54.697] result() for MulticoreFuture ... done
[17:47:54.697] result() for MulticoreFuture ... done
[17:47:54.697] result() for MulticoreFuture ...
[17:47:54.698] result() for MulticoreFuture ... done
[17:47:54.701] MulticoreFuture started
[17:47:54.701] - Launch lazy future ... done
[17:47:54.702] run() for ‘MulticoreFuture’ ... done
[17:47:54.702] plan(): Setting new future strategy stack:
[17:47:54.702] List of future strategies:
[17:47:54.702] 1. sequential:
[17:47:54.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:54.702]    - tweaked: FALSE
[17:47:54.702]    - call: NULL
[17:47:54.704] plan(): nbrOfWorkers() = 1
[17:47:54.713] run() for ‘Future’ ...
[17:47:54.713] - state: ‘created’
[17:47:54.713] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.719] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.720]   - Field: ‘label’
[17:47:54.720]   - Field: ‘local’
[17:47:54.720]   - Field: ‘owner’
[17:47:54.721]   - Field: ‘envir’
[17:47:54.721]   - Field: ‘workers’
[17:47:54.721]   - Field: ‘packages’
[17:47:54.721]   - Field: ‘gc’
[17:47:54.721]   - Field: ‘job’
[17:47:54.721]   - Field: ‘conditions’
[17:47:54.722]   - Field: ‘expr’
[17:47:54.722]   - Field: ‘uuid’
[17:47:54.722]   - Field: ‘seed’
[17:47:54.722]   - Field: ‘version’
[17:47:54.722]   - Field: ‘result’
[17:47:54.722]   - Field: ‘asynchronous’
[17:47:54.723]   - Field: ‘calls’
[17:47:54.723]   - Field: ‘globals’
[17:47:54.723]   - Field: ‘stdout’
[17:47:54.723]   - Field: ‘earlySignal’
[17:47:54.723]   - Field: ‘lazy’
[17:47:54.723]   - Field: ‘state’
[17:47:54.724] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.724] - Launch lazy future ...
[17:47:54.724] Packages needed by the future expression (n = 0): <none>
[17:47:54.724] Packages needed by future strategies (n = 0): <none>
[17:47:54.725] {
[17:47:54.725]     {
[17:47:54.725]         {
[17:47:54.725]             ...future.startTime <- base::Sys.time()
[17:47:54.725]             {
[17:47:54.725]                 {
[17:47:54.725]                   {
[17:47:54.725]                     {
[17:47:54.725]                       base::local({
[17:47:54.725]                         has_future <- base::requireNamespace("future", 
[17:47:54.725]                           quietly = TRUE)
[17:47:54.725]                         if (has_future) {
[17:47:54.725]                           ns <- base::getNamespace("future")
[17:47:54.725]                           version <- ns[[".package"]][["version"]]
[17:47:54.725]                           if (is.null(version)) 
[17:47:54.725]                             version <- utils::packageVersion("future")
[17:47:54.725]                         }
[17:47:54.725]                         else {
[17:47:54.725]                           version <- NULL
[17:47:54.725]                         }
[17:47:54.725]                         if (!has_future || version < "1.8.0") {
[17:47:54.725]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.725]                             "", base::R.version$version.string), 
[17:47:54.725]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.725]                               "release", "version")], collapse = " "), 
[17:47:54.725]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.725]                             info)
[17:47:54.725]                           info <- base::paste(info, collapse = "; ")
[17:47:54.725]                           if (!has_future) {
[17:47:54.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.725]                               info)
[17:47:54.725]                           }
[17:47:54.725]                           else {
[17:47:54.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.725]                               info, version)
[17:47:54.725]                           }
[17:47:54.725]                           base::stop(msg)
[17:47:54.725]                         }
[17:47:54.725]                       })
[17:47:54.725]                     }
[17:47:54.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.725]                     base::options(mc.cores = 1L)
[17:47:54.725]                   }
[17:47:54.725]                   ...future.strategy.old <- future::plan("list")
[17:47:54.725]                   options(future.plan = NULL)
[17:47:54.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.725]                 }
[17:47:54.725]                 ...future.workdir <- getwd()
[17:47:54.725]             }
[17:47:54.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.725]         }
[17:47:54.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.725]             base::names(...future.oldOptions))
[17:47:54.725]     }
[17:47:54.725]     if (FALSE) {
[17:47:54.725]     }
[17:47:54.725]     else {
[17:47:54.725]         if (TRUE) {
[17:47:54.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.725]                 open = "w")
[17:47:54.725]         }
[17:47:54.725]         else {
[17:47:54.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.725]         }
[17:47:54.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.725]             base::sink(type = "output", split = FALSE)
[17:47:54.725]             base::close(...future.stdout)
[17:47:54.725]         }, add = TRUE)
[17:47:54.725]     }
[17:47:54.725]     ...future.frame <- base::sys.nframe()
[17:47:54.725]     ...future.conditions <- base::list()
[17:47:54.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.725]     if (FALSE) {
[17:47:54.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.725]     }
[17:47:54.725]     ...future.result <- base::tryCatch({
[17:47:54.725]         base::withCallingHandlers({
[17:47:54.725]             ...future.value <- base::withVisible(base::local({
[17:47:54.725]                 withCallingHandlers({
[17:47:54.725]                   {
[17:47:54.725]                     Sys.sleep(0.1)
[17:47:54.725]                     kk
[17:47:54.725]                   }
[17:47:54.725]                 }, immediateCondition = function(cond) {
[17:47:54.725]                   save_rds <- function (object, pathname, ...) 
[17:47:54.725]                   {
[17:47:54.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.725]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.725]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.725]                         fi_tmp[["mtime"]])
[17:47:54.725]                     }
[17:47:54.725]                     tryCatch({
[17:47:54.725]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.725]                     }, error = function(ex) {
[17:47:54.725]                       msg <- conditionMessage(ex)
[17:47:54.725]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.725]                         fi_tmp[["mtime"]], msg)
[17:47:54.725]                       ex$message <- msg
[17:47:54.725]                       stop(ex)
[17:47:54.725]                     })
[17:47:54.725]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.725]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.725]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.725]                       fi <- file.info(pathname)
[17:47:54.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.725]                         fi[["size"]], fi[["mtime"]])
[17:47:54.725]                       stop(msg)
[17:47:54.725]                     }
[17:47:54.725]                     invisible(pathname)
[17:47:54.725]                   }
[17:47:54.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.725]                     rootPath = tempdir()) 
[17:47:54.725]                   {
[17:47:54.725]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.725]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.725]                       tmpdir = path, fileext = ".rds")
[17:47:54.725]                     save_rds(obj, file)
[17:47:54.725]                   }
[17:47:54.725]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.725]                   {
[17:47:54.725]                     inherits <- base::inherits
[17:47:54.725]                     invokeRestart <- base::invokeRestart
[17:47:54.725]                     is.null <- base::is.null
[17:47:54.725]                     muffled <- FALSE
[17:47:54.725]                     if (inherits(cond, "message")) {
[17:47:54.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.725]                       if (muffled) 
[17:47:54.725]                         invokeRestart("muffleMessage")
[17:47:54.725]                     }
[17:47:54.725]                     else if (inherits(cond, "warning")) {
[17:47:54.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.725]                       if (muffled) 
[17:47:54.725]                         invokeRestart("muffleWarning")
[17:47:54.725]                     }
[17:47:54.725]                     else if (inherits(cond, "condition")) {
[17:47:54.725]                       if (!is.null(pattern)) {
[17:47:54.725]                         computeRestarts <- base::computeRestarts
[17:47:54.725]                         grepl <- base::grepl
[17:47:54.725]                         restarts <- computeRestarts(cond)
[17:47:54.725]                         for (restart in restarts) {
[17:47:54.725]                           name <- restart$name
[17:47:54.725]                           if (is.null(name)) 
[17:47:54.725]                             next
[17:47:54.725]                           if (!grepl(pattern, name)) 
[17:47:54.725]                             next
[17:47:54.725]                           invokeRestart(restart)
[17:47:54.725]                           muffled <- TRUE
[17:47:54.725]                           break
[17:47:54.725]                         }
[17:47:54.725]                       }
[17:47:54.725]                     }
[17:47:54.725]                     invisible(muffled)
[17:47:54.725]                   }
[17:47:54.725]                   muffleCondition(cond)
[17:47:54.725]                 })
[17:47:54.725]             }))
[17:47:54.725]             future::FutureResult(value = ...future.value$value, 
[17:47:54.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.725]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.725]                     ...future.globalenv.names))
[17:47:54.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.725]         }, condition = base::local({
[17:47:54.725]             c <- base::c
[17:47:54.725]             inherits <- base::inherits
[17:47:54.725]             invokeRestart <- base::invokeRestart
[17:47:54.725]             length <- base::length
[17:47:54.725]             list <- base::list
[17:47:54.725]             seq.int <- base::seq.int
[17:47:54.725]             signalCondition <- base::signalCondition
[17:47:54.725]             sys.calls <- base::sys.calls
[17:47:54.725]             `[[` <- base::`[[`
[17:47:54.725]             `+` <- base::`+`
[17:47:54.725]             `<<-` <- base::`<<-`
[17:47:54.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.725]                   3L)]
[17:47:54.725]             }
[17:47:54.725]             function(cond) {
[17:47:54.725]                 is_error <- inherits(cond, "error")
[17:47:54.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.725]                   NULL)
[17:47:54.725]                 if (is_error) {
[17:47:54.725]                   sessionInformation <- function() {
[17:47:54.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.725]                       search = base::search(), system = base::Sys.info())
[17:47:54.725]                   }
[17:47:54.725]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.725]                     cond$call), session = sessionInformation(), 
[17:47:54.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.725]                   signalCondition(cond)
[17:47:54.725]                 }
[17:47:54.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.725]                 "immediateCondition"))) {
[17:47:54.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.725]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.725]                   if (TRUE && !signal) {
[17:47:54.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.725]                     {
[17:47:54.725]                       inherits <- base::inherits
[17:47:54.725]                       invokeRestart <- base::invokeRestart
[17:47:54.725]                       is.null <- base::is.null
[17:47:54.725]                       muffled <- FALSE
[17:47:54.725]                       if (inherits(cond, "message")) {
[17:47:54.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.725]                         if (muffled) 
[17:47:54.725]                           invokeRestart("muffleMessage")
[17:47:54.725]                       }
[17:47:54.725]                       else if (inherits(cond, "warning")) {
[17:47:54.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.725]                         if (muffled) 
[17:47:54.725]                           invokeRestart("muffleWarning")
[17:47:54.725]                       }
[17:47:54.725]                       else if (inherits(cond, "condition")) {
[17:47:54.725]                         if (!is.null(pattern)) {
[17:47:54.725]                           computeRestarts <- base::computeRestarts
[17:47:54.725]                           grepl <- base::grepl
[17:47:54.725]                           restarts <- computeRestarts(cond)
[17:47:54.725]                           for (restart in restarts) {
[17:47:54.725]                             name <- restart$name
[17:47:54.725]                             if (is.null(name)) 
[17:47:54.725]                               next
[17:47:54.725]                             if (!grepl(pattern, name)) 
[17:47:54.725]                               next
[17:47:54.725]                             invokeRestart(restart)
[17:47:54.725]                             muffled <- TRUE
[17:47:54.725]                             break
[17:47:54.725]                           }
[17:47:54.725]                         }
[17:47:54.725]                       }
[17:47:54.725]                       invisible(muffled)
[17:47:54.725]                     }
[17:47:54.725]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.725]                   }
[17:47:54.725]                 }
[17:47:54.725]                 else {
[17:47:54.725]                   if (TRUE) {
[17:47:54.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.725]                     {
[17:47:54.725]                       inherits <- base::inherits
[17:47:54.725]                       invokeRestart <- base::invokeRestart
[17:47:54.725]                       is.null <- base::is.null
[17:47:54.725]                       muffled <- FALSE
[17:47:54.725]                       if (inherits(cond, "message")) {
[17:47:54.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.725]                         if (muffled) 
[17:47:54.725]                           invokeRestart("muffleMessage")
[17:47:54.725]                       }
[17:47:54.725]                       else if (inherits(cond, "warning")) {
[17:47:54.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.725]                         if (muffled) 
[17:47:54.725]                           invokeRestart("muffleWarning")
[17:47:54.725]                       }
[17:47:54.725]                       else if (inherits(cond, "condition")) {
[17:47:54.725]                         if (!is.null(pattern)) {
[17:47:54.725]                           computeRestarts <- base::computeRestarts
[17:47:54.725]                           grepl <- base::grepl
[17:47:54.725]                           restarts <- computeRestarts(cond)
[17:47:54.725]                           for (restart in restarts) {
[17:47:54.725]                             name <- restart$name
[17:47:54.725]                             if (is.null(name)) 
[17:47:54.725]                               next
[17:47:54.725]                             if (!grepl(pattern, name)) 
[17:47:54.725]                               next
[17:47:54.725]                             invokeRestart(restart)
[17:47:54.725]                             muffled <- TRUE
[17:47:54.725]                             break
[17:47:54.725]                           }
[17:47:54.725]                         }
[17:47:54.725]                       }
[17:47:54.725]                       invisible(muffled)
[17:47:54.725]                     }
[17:47:54.725]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.725]                   }
[17:47:54.725]                 }
[17:47:54.725]             }
[17:47:54.725]         }))
[17:47:54.725]     }, error = function(ex) {
[17:47:54.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.725]                 ...future.rng), started = ...future.startTime, 
[17:47:54.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.725]             version = "1.8"), class = "FutureResult")
[17:47:54.725]     }, finally = {
[17:47:54.725]         if (!identical(...future.workdir, getwd())) 
[17:47:54.725]             setwd(...future.workdir)
[17:47:54.725]         {
[17:47:54.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.725]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.725]             }
[17:47:54.725]             base::options(...future.oldOptions)
[17:47:54.725]             if (.Platform$OS.type == "windows") {
[17:47:54.725]                 old_names <- names(...future.oldEnvVars)
[17:47:54.725]                 envs <- base::Sys.getenv()
[17:47:54.725]                 names <- names(envs)
[17:47:54.725]                 common <- intersect(names, old_names)
[17:47:54.725]                 added <- setdiff(names, old_names)
[17:47:54.725]                 removed <- setdiff(old_names, names)
[17:47:54.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.725]                   envs[common]]
[17:47:54.725]                 NAMES <- toupper(changed)
[17:47:54.725]                 args <- list()
[17:47:54.725]                 for (kk in seq_along(NAMES)) {
[17:47:54.725]                   name <- changed[[kk]]
[17:47:54.725]                   NAME <- NAMES[[kk]]
[17:47:54.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.725]                     next
[17:47:54.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.725]                 }
[17:47:54.725]                 NAMES <- toupper(added)
[17:47:54.725]                 for (kk in seq_along(NAMES)) {
[17:47:54.725]                   name <- added[[kk]]
[17:47:54.725]                   NAME <- NAMES[[kk]]
[17:47:54.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.725]                     next
[17:47:54.725]                   args[[name]] <- ""
[17:47:54.725]                 }
[17:47:54.725]                 NAMES <- toupper(removed)
[17:47:54.725]                 for (kk in seq_along(NAMES)) {
[17:47:54.725]                   name <- removed[[kk]]
[17:47:54.725]                   NAME <- NAMES[[kk]]
[17:47:54.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.725]                     next
[17:47:54.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.725]                 }
[17:47:54.725]                 if (length(args) > 0) 
[17:47:54.725]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.725]             }
[17:47:54.725]             else {
[17:47:54.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.725]             }
[17:47:54.725]             {
[17:47:54.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.725]                   0L) {
[17:47:54.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.725]                   base::options(opts)
[17:47:54.725]                 }
[17:47:54.725]                 {
[17:47:54.725]                   {
[17:47:54.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.725]                     NULL
[17:47:54.725]                   }
[17:47:54.725]                   options(future.plan = NULL)
[17:47:54.725]                   if (is.na(NA_character_)) 
[17:47:54.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.725]                     .init = FALSE)
[17:47:54.725]                 }
[17:47:54.725]             }
[17:47:54.725]         }
[17:47:54.725]     })
[17:47:54.725]     if (TRUE) {
[17:47:54.725]         base::sink(type = "output", split = FALSE)
[17:47:54.725]         if (TRUE) {
[17:47:54.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.725]         }
[17:47:54.725]         else {
[17:47:54.725]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.725]         }
[17:47:54.725]         base::close(...future.stdout)
[17:47:54.725]         ...future.stdout <- NULL
[17:47:54.725]     }
[17:47:54.725]     ...future.result$conditions <- ...future.conditions
[17:47:54.725]     ...future.result$finished <- base::Sys.time()
[17:47:54.725]     ...future.result
[17:47:54.725] }
[17:47:54.729] assign_globals() ...
[17:47:54.729] List of 1
[17:47:54.729]  $ kk: int 2
[17:47:54.729]  - attr(*, "where")=List of 1
[17:47:54.729]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:54.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:54.729]  - attr(*, "resolved")= logi FALSE
[17:47:54.729]  - attr(*, "total_size")= num 56
[17:47:54.729]  - attr(*, "already-done")= logi TRUE
[17:47:54.733] - copied ‘kk’ to environment
[17:47:54.733] assign_globals() ... done
[17:47:54.733] requestCore(): workers = 2
[17:47:54.734] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:54.744] result() for MulticoreFuture ...
[17:47:54.745] result() for MulticoreFuture ...
[17:47:54.745] result() for MulticoreFuture ... done
[17:47:54.745] result() for MulticoreFuture ... done
[17:47:54.745] result() for MulticoreFuture ...
[17:47:54.746] result() for MulticoreFuture ... done
[17:47:54.748] MulticoreFuture started
[17:47:54.749] - Launch lazy future ... done
[17:47:54.749] run() for ‘MulticoreFuture’ ... done
[17:47:54.749] plan(): Setting new future strategy stack:
[17:47:54.750] List of future strategies:
[17:47:54.750] 1. sequential:
[17:47:54.750]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:54.750]    - tweaked: FALSE
[17:47:54.750]    - call: NULL
[17:47:54.751] plan(): nbrOfWorkers() = 1
[17:47:54.760] run() for ‘Future’ ...
[17:47:54.760] - state: ‘created’
[17:47:54.760] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.766] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.766]   - Field: ‘label’
[17:47:54.766]   - Field: ‘local’
[17:47:54.766]   - Field: ‘owner’
[17:47:54.766]   - Field: ‘envir’
[17:47:54.767]   - Field: ‘workers’
[17:47:54.767]   - Field: ‘packages’
[17:47:54.767]   - Field: ‘gc’
[17:47:54.767]   - Field: ‘job’
[17:47:54.767]   - Field: ‘conditions’
[17:47:54.767]   - Field: ‘expr’
[17:47:54.768]   - Field: ‘uuid’
[17:47:54.768]   - Field: ‘seed’
[17:47:54.768]   - Field: ‘version’
[17:47:54.768]   - Field: ‘result’
[17:47:54.768]   - Field: ‘asynchronous’
[17:47:54.768]   - Field: ‘calls’
[17:47:54.768]   - Field: ‘globals’
[17:47:54.769]   - Field: ‘stdout’
[17:47:54.769]   - Field: ‘earlySignal’
[17:47:54.769]   - Field: ‘lazy’
[17:47:54.769]   - Field: ‘state’
[17:47:54.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.769] - Launch lazy future ...
[17:47:54.770] Packages needed by the future expression (n = 0): <none>
[17:47:54.770] Packages needed by future strategies (n = 0): <none>
[17:47:54.771] {
[17:47:54.771]     {
[17:47:54.771]         {
[17:47:54.771]             ...future.startTime <- base::Sys.time()
[17:47:54.771]             {
[17:47:54.771]                 {
[17:47:54.771]                   {
[17:47:54.771]                     {
[17:47:54.771]                       base::local({
[17:47:54.771]                         has_future <- base::requireNamespace("future", 
[17:47:54.771]                           quietly = TRUE)
[17:47:54.771]                         if (has_future) {
[17:47:54.771]                           ns <- base::getNamespace("future")
[17:47:54.771]                           version <- ns[[".package"]][["version"]]
[17:47:54.771]                           if (is.null(version)) 
[17:47:54.771]                             version <- utils::packageVersion("future")
[17:47:54.771]                         }
[17:47:54.771]                         else {
[17:47:54.771]                           version <- NULL
[17:47:54.771]                         }
[17:47:54.771]                         if (!has_future || version < "1.8.0") {
[17:47:54.771]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.771]                             "", base::R.version$version.string), 
[17:47:54.771]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.771]                               "release", "version")], collapse = " "), 
[17:47:54.771]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.771]                             info)
[17:47:54.771]                           info <- base::paste(info, collapse = "; ")
[17:47:54.771]                           if (!has_future) {
[17:47:54.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.771]                               info)
[17:47:54.771]                           }
[17:47:54.771]                           else {
[17:47:54.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.771]                               info, version)
[17:47:54.771]                           }
[17:47:54.771]                           base::stop(msg)
[17:47:54.771]                         }
[17:47:54.771]                       })
[17:47:54.771]                     }
[17:47:54.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.771]                     base::options(mc.cores = 1L)
[17:47:54.771]                   }
[17:47:54.771]                   ...future.strategy.old <- future::plan("list")
[17:47:54.771]                   options(future.plan = NULL)
[17:47:54.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.771]                 }
[17:47:54.771]                 ...future.workdir <- getwd()
[17:47:54.771]             }
[17:47:54.771]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.771]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.771]         }
[17:47:54.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.771]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.771]             base::names(...future.oldOptions))
[17:47:54.771]     }
[17:47:54.771]     if (FALSE) {
[17:47:54.771]     }
[17:47:54.771]     else {
[17:47:54.771]         if (TRUE) {
[17:47:54.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.771]                 open = "w")
[17:47:54.771]         }
[17:47:54.771]         else {
[17:47:54.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.771]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.771]         }
[17:47:54.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.771]             base::sink(type = "output", split = FALSE)
[17:47:54.771]             base::close(...future.stdout)
[17:47:54.771]         }, add = TRUE)
[17:47:54.771]     }
[17:47:54.771]     ...future.frame <- base::sys.nframe()
[17:47:54.771]     ...future.conditions <- base::list()
[17:47:54.771]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.771]     if (FALSE) {
[17:47:54.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.771]     }
[17:47:54.771]     ...future.result <- base::tryCatch({
[17:47:54.771]         base::withCallingHandlers({
[17:47:54.771]             ...future.value <- base::withVisible(base::local({
[17:47:54.771]                 withCallingHandlers({
[17:47:54.771]                   {
[17:47:54.771]                     Sys.sleep(0.1)
[17:47:54.771]                     kk
[17:47:54.771]                   }
[17:47:54.771]                 }, immediateCondition = function(cond) {
[17:47:54.771]                   save_rds <- function (object, pathname, ...) 
[17:47:54.771]                   {
[17:47:54.771]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.771]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.771]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.771]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.771]                         fi_tmp[["mtime"]])
[17:47:54.771]                     }
[17:47:54.771]                     tryCatch({
[17:47:54.771]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.771]                     }, error = function(ex) {
[17:47:54.771]                       msg <- conditionMessage(ex)
[17:47:54.771]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.771]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.771]                         fi_tmp[["mtime"]], msg)
[17:47:54.771]                       ex$message <- msg
[17:47:54.771]                       stop(ex)
[17:47:54.771]                     })
[17:47:54.771]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.771]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.771]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.771]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.771]                       fi <- file.info(pathname)
[17:47:54.771]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.771]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.771]                         fi[["size"]], fi[["mtime"]])
[17:47:54.771]                       stop(msg)
[17:47:54.771]                     }
[17:47:54.771]                     invisible(pathname)
[17:47:54.771]                   }
[17:47:54.771]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.771]                     rootPath = tempdir()) 
[17:47:54.771]                   {
[17:47:54.771]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.771]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.771]                       tmpdir = path, fileext = ".rds")
[17:47:54.771]                     save_rds(obj, file)
[17:47:54.771]                   }
[17:47:54.771]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.771]                   {
[17:47:54.771]                     inherits <- base::inherits
[17:47:54.771]                     invokeRestart <- base::invokeRestart
[17:47:54.771]                     is.null <- base::is.null
[17:47:54.771]                     muffled <- FALSE
[17:47:54.771]                     if (inherits(cond, "message")) {
[17:47:54.771]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.771]                       if (muffled) 
[17:47:54.771]                         invokeRestart("muffleMessage")
[17:47:54.771]                     }
[17:47:54.771]                     else if (inherits(cond, "warning")) {
[17:47:54.771]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.771]                       if (muffled) 
[17:47:54.771]                         invokeRestart("muffleWarning")
[17:47:54.771]                     }
[17:47:54.771]                     else if (inherits(cond, "condition")) {
[17:47:54.771]                       if (!is.null(pattern)) {
[17:47:54.771]                         computeRestarts <- base::computeRestarts
[17:47:54.771]                         grepl <- base::grepl
[17:47:54.771]                         restarts <- computeRestarts(cond)
[17:47:54.771]                         for (restart in restarts) {
[17:47:54.771]                           name <- restart$name
[17:47:54.771]                           if (is.null(name)) 
[17:47:54.771]                             next
[17:47:54.771]                           if (!grepl(pattern, name)) 
[17:47:54.771]                             next
[17:47:54.771]                           invokeRestart(restart)
[17:47:54.771]                           muffled <- TRUE
[17:47:54.771]                           break
[17:47:54.771]                         }
[17:47:54.771]                       }
[17:47:54.771]                     }
[17:47:54.771]                     invisible(muffled)
[17:47:54.771]                   }
[17:47:54.771]                   muffleCondition(cond)
[17:47:54.771]                 })
[17:47:54.771]             }))
[17:47:54.771]             future::FutureResult(value = ...future.value$value, 
[17:47:54.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.771]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.771]                     ...future.globalenv.names))
[17:47:54.771]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.771]         }, condition = base::local({
[17:47:54.771]             c <- base::c
[17:47:54.771]             inherits <- base::inherits
[17:47:54.771]             invokeRestart <- base::invokeRestart
[17:47:54.771]             length <- base::length
[17:47:54.771]             list <- base::list
[17:47:54.771]             seq.int <- base::seq.int
[17:47:54.771]             signalCondition <- base::signalCondition
[17:47:54.771]             sys.calls <- base::sys.calls
[17:47:54.771]             `[[` <- base::`[[`
[17:47:54.771]             `+` <- base::`+`
[17:47:54.771]             `<<-` <- base::`<<-`
[17:47:54.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.771]                   3L)]
[17:47:54.771]             }
[17:47:54.771]             function(cond) {
[17:47:54.771]                 is_error <- inherits(cond, "error")
[17:47:54.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.771]                   NULL)
[17:47:54.771]                 if (is_error) {
[17:47:54.771]                   sessionInformation <- function() {
[17:47:54.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.771]                       search = base::search(), system = base::Sys.info())
[17:47:54.771]                   }
[17:47:54.771]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.771]                     cond$call), session = sessionInformation(), 
[17:47:54.771]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.771]                   signalCondition(cond)
[17:47:54.771]                 }
[17:47:54.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.771]                 "immediateCondition"))) {
[17:47:54.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.771]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.771]                   if (TRUE && !signal) {
[17:47:54.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.771]                     {
[17:47:54.771]                       inherits <- base::inherits
[17:47:54.771]                       invokeRestart <- base::invokeRestart
[17:47:54.771]                       is.null <- base::is.null
[17:47:54.771]                       muffled <- FALSE
[17:47:54.771]                       if (inherits(cond, "message")) {
[17:47:54.771]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.771]                         if (muffled) 
[17:47:54.771]                           invokeRestart("muffleMessage")
[17:47:54.771]                       }
[17:47:54.771]                       else if (inherits(cond, "warning")) {
[17:47:54.771]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.771]                         if (muffled) 
[17:47:54.771]                           invokeRestart("muffleWarning")
[17:47:54.771]                       }
[17:47:54.771]                       else if (inherits(cond, "condition")) {
[17:47:54.771]                         if (!is.null(pattern)) {
[17:47:54.771]                           computeRestarts <- base::computeRestarts
[17:47:54.771]                           grepl <- base::grepl
[17:47:54.771]                           restarts <- computeRestarts(cond)
[17:47:54.771]                           for (restart in restarts) {
[17:47:54.771]                             name <- restart$name
[17:47:54.771]                             if (is.null(name)) 
[17:47:54.771]                               next
[17:47:54.771]                             if (!grepl(pattern, name)) 
[17:47:54.771]                               next
[17:47:54.771]                             invokeRestart(restart)
[17:47:54.771]                             muffled <- TRUE
[17:47:54.771]                             break
[17:47:54.771]                           }
[17:47:54.771]                         }
[17:47:54.771]                       }
[17:47:54.771]                       invisible(muffled)
[17:47:54.771]                     }
[17:47:54.771]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.771]                   }
[17:47:54.771]                 }
[17:47:54.771]                 else {
[17:47:54.771]                   if (TRUE) {
[17:47:54.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.771]                     {
[17:47:54.771]                       inherits <- base::inherits
[17:47:54.771]                       invokeRestart <- base::invokeRestart
[17:47:54.771]                       is.null <- base::is.null
[17:47:54.771]                       muffled <- FALSE
[17:47:54.771]                       if (inherits(cond, "message")) {
[17:47:54.771]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.771]                         if (muffled) 
[17:47:54.771]                           invokeRestart("muffleMessage")
[17:47:54.771]                       }
[17:47:54.771]                       else if (inherits(cond, "warning")) {
[17:47:54.771]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.771]                         if (muffled) 
[17:47:54.771]                           invokeRestart("muffleWarning")
[17:47:54.771]                       }
[17:47:54.771]                       else if (inherits(cond, "condition")) {
[17:47:54.771]                         if (!is.null(pattern)) {
[17:47:54.771]                           computeRestarts <- base::computeRestarts
[17:47:54.771]                           grepl <- base::grepl
[17:47:54.771]                           restarts <- computeRestarts(cond)
[17:47:54.771]                           for (restart in restarts) {
[17:47:54.771]                             name <- restart$name
[17:47:54.771]                             if (is.null(name)) 
[17:47:54.771]                               next
[17:47:54.771]                             if (!grepl(pattern, name)) 
[17:47:54.771]                               next
[17:47:54.771]                             invokeRestart(restart)
[17:47:54.771]                             muffled <- TRUE
[17:47:54.771]                             break
[17:47:54.771]                           }
[17:47:54.771]                         }
[17:47:54.771]                       }
[17:47:54.771]                       invisible(muffled)
[17:47:54.771]                     }
[17:47:54.771]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.771]                   }
[17:47:54.771]                 }
[17:47:54.771]             }
[17:47:54.771]         }))
[17:47:54.771]     }, error = function(ex) {
[17:47:54.771]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.771]                 ...future.rng), started = ...future.startTime, 
[17:47:54.771]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.771]             version = "1.8"), class = "FutureResult")
[17:47:54.771]     }, finally = {
[17:47:54.771]         if (!identical(...future.workdir, getwd())) 
[17:47:54.771]             setwd(...future.workdir)
[17:47:54.771]         {
[17:47:54.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.771]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.771]             }
[17:47:54.771]             base::options(...future.oldOptions)
[17:47:54.771]             if (.Platform$OS.type == "windows") {
[17:47:54.771]                 old_names <- names(...future.oldEnvVars)
[17:47:54.771]                 envs <- base::Sys.getenv()
[17:47:54.771]                 names <- names(envs)
[17:47:54.771]                 common <- intersect(names, old_names)
[17:47:54.771]                 added <- setdiff(names, old_names)
[17:47:54.771]                 removed <- setdiff(old_names, names)
[17:47:54.771]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.771]                   envs[common]]
[17:47:54.771]                 NAMES <- toupper(changed)
[17:47:54.771]                 args <- list()
[17:47:54.771]                 for (kk in seq_along(NAMES)) {
[17:47:54.771]                   name <- changed[[kk]]
[17:47:54.771]                   NAME <- NAMES[[kk]]
[17:47:54.771]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.771]                     next
[17:47:54.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.771]                 }
[17:47:54.771]                 NAMES <- toupper(added)
[17:47:54.771]                 for (kk in seq_along(NAMES)) {
[17:47:54.771]                   name <- added[[kk]]
[17:47:54.771]                   NAME <- NAMES[[kk]]
[17:47:54.771]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.771]                     next
[17:47:54.771]                   args[[name]] <- ""
[17:47:54.771]                 }
[17:47:54.771]                 NAMES <- toupper(removed)
[17:47:54.771]                 for (kk in seq_along(NAMES)) {
[17:47:54.771]                   name <- removed[[kk]]
[17:47:54.771]                   NAME <- NAMES[[kk]]
[17:47:54.771]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.771]                     next
[17:47:54.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.771]                 }
[17:47:54.771]                 if (length(args) > 0) 
[17:47:54.771]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.771]             }
[17:47:54.771]             else {
[17:47:54.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.771]             }
[17:47:54.771]             {
[17:47:54.771]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.771]                   0L) {
[17:47:54.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.771]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.771]                   base::options(opts)
[17:47:54.771]                 }
[17:47:54.771]                 {
[17:47:54.771]                   {
[17:47:54.771]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.771]                     NULL
[17:47:54.771]                   }
[17:47:54.771]                   options(future.plan = NULL)
[17:47:54.771]                   if (is.na(NA_character_)) 
[17:47:54.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.771]                     .init = FALSE)
[17:47:54.771]                 }
[17:47:54.771]             }
[17:47:54.771]         }
[17:47:54.771]     })
[17:47:54.771]     if (TRUE) {
[17:47:54.771]         base::sink(type = "output", split = FALSE)
[17:47:54.771]         if (TRUE) {
[17:47:54.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.771]         }
[17:47:54.771]         else {
[17:47:54.771]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.771]         }
[17:47:54.771]         base::close(...future.stdout)
[17:47:54.771]         ...future.stdout <- NULL
[17:47:54.771]     }
[17:47:54.771]     ...future.result$conditions <- ...future.conditions
[17:47:54.771]     ...future.result$finished <- base::Sys.time()
[17:47:54.771]     ...future.result
[17:47:54.771] }
[17:47:54.774] assign_globals() ...
[17:47:54.774] List of 1
[17:47:54.774]  $ kk: int 3
[17:47:54.774]  - attr(*, "where")=List of 1
[17:47:54.774]   ..$ kk:<environment: R_EmptyEnv> 
[17:47:54.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:47:54.774]  - attr(*, "resolved")= logi FALSE
[17:47:54.774]  - attr(*, "total_size")= num 56
[17:47:54.774]  - attr(*, "already-done")= logi TRUE
[17:47:54.778] - copied ‘kk’ to environment
[17:47:54.779] assign_globals() ... done
[17:47:54.779] requestCore(): workers = 2
[17:47:54.779] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:54.806] plan(): Setting new future strategy stack:
[17:47:54.807] List of future strategies:
[17:47:54.807] 1. multicore:
[17:47:54.807]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.807]    - tweaked: FALSE
[17:47:54.807]    - call: plan(strategy)
[17:47:54.810] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:47:54.811] plan(): nbrOfWorkers() = 2
[17:47:54.821] result() for MulticoreFuture ...
[17:47:54.822] result() for MulticoreFuture ...
[17:47:54.822] result() for MulticoreFuture ... done
[17:47:54.822] result() for MulticoreFuture ... done
[17:47:54.822] result() for MulticoreFuture ...
[17:47:54.822] result() for MulticoreFuture ... done
[17:47:54.825] MulticoreFuture started
[17:47:54.825] - Launch lazy future ... done
[17:47:54.825] run() for ‘MulticoreFuture’ ... done
[17:47:54.826] plan(): Setting new future strategy stack:
[17:47:54.826] List of future strategies:
[17:47:54.826] 1. sequential:
[17:47:54.826]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:54.826]    - tweaked: FALSE
[17:47:54.826]    - call: NULL
[17:47:54.827] plan(): nbrOfWorkers() = 1
[17:47:54.846] Future #1
[17:47:54.847]  length: 2 (resolved future 1)
[17:47:54.853] plan(): Setting new future strategy stack:
[17:47:54.853] List of future strategies:
[17:47:54.853] 1. multicore:
[17:47:54.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.853]    - tweaked: FALSE
[17:47:54.853]    - call: plan(strategy)
[17:47:54.857] plan(): nbrOfWorkers() = 2
[17:47:54.878] Future #2
[17:47:54.878]  length: 1 (resolved future 2)
[17:47:54.930] plan(): Setting new future strategy stack:
[17:47:54.930] List of future strategies:
[17:47:54.930] 1. multicore:
[17:47:54.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.930]    - tweaked: FALSE
[17:47:54.930]    - call: plan(strategy)
[17:47:54.935] plan(): nbrOfWorkers() = 2
[17:47:54.939] Future #3
[17:47:54.940]  length: 0 (resolved future 3)
[17:47:54.940] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:47:54.941] resolve() on environment ...
[17:47:54.941]  recursive: 0
[17:47:54.942]  elements: [2] ‘a’, ‘b’
[17:47:54.942]  length: 1 (resolved future 1)
[17:47:54.942]  length: 0 (resolved future 2)
[17:47:54.947] resolve() on environment ... DONE
[17:47:54.948] getGlobalsAndPackages() ...
[17:47:54.949] Searching for globals...
[17:47:54.950] 
[17:47:54.950] Searching for globals ... DONE
[17:47:54.951] - globals: [0] <none>
[17:47:54.951] getGlobalsAndPackages() ... DONE
[17:47:54.952] run() for ‘Future’ ...
[17:47:54.952] - state: ‘created’
[17:47:54.952] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.957] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.958]   - Field: ‘label’
[17:47:54.958]   - Field: ‘local’
[17:47:54.958]   - Field: ‘owner’
[17:47:54.958]   - Field: ‘envir’
[17:47:54.959]   - Field: ‘workers’
[17:47:54.959]   - Field: ‘packages’
[17:47:54.959]   - Field: ‘gc’
[17:47:54.959]   - Field: ‘job’
[17:47:54.959]   - Field: ‘conditions’
[17:47:54.960]   - Field: ‘expr’
[17:47:54.960]   - Field: ‘uuid’
[17:47:54.960]   - Field: ‘seed’
[17:47:54.960]   - Field: ‘version’
[17:47:54.960]   - Field: ‘result’
[17:47:54.960]   - Field: ‘asynchronous’
[17:47:54.961]   - Field: ‘calls’
[17:47:54.961]   - Field: ‘globals’
[17:47:54.961]   - Field: ‘stdout’
[17:47:54.961]   - Field: ‘earlySignal’
[17:47:54.961]   - Field: ‘lazy’
[17:47:54.961]   - Field: ‘state’
[17:47:54.961] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.962] - Launch lazy future ...
[17:47:54.962] Packages needed by the future expression (n = 0): <none>
[17:47:54.962] Packages needed by future strategies (n = 0): <none>
[17:47:54.963] {
[17:47:54.963]     {
[17:47:54.963]         {
[17:47:54.963]             ...future.startTime <- base::Sys.time()
[17:47:54.963]             {
[17:47:54.963]                 {
[17:47:54.963]                   {
[17:47:54.963]                     {
[17:47:54.963]                       base::local({
[17:47:54.963]                         has_future <- base::requireNamespace("future", 
[17:47:54.963]                           quietly = TRUE)
[17:47:54.963]                         if (has_future) {
[17:47:54.963]                           ns <- base::getNamespace("future")
[17:47:54.963]                           version <- ns[[".package"]][["version"]]
[17:47:54.963]                           if (is.null(version)) 
[17:47:54.963]                             version <- utils::packageVersion("future")
[17:47:54.963]                         }
[17:47:54.963]                         else {
[17:47:54.963]                           version <- NULL
[17:47:54.963]                         }
[17:47:54.963]                         if (!has_future || version < "1.8.0") {
[17:47:54.963]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.963]                             "", base::R.version$version.string), 
[17:47:54.963]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.963]                               "release", "version")], collapse = " "), 
[17:47:54.963]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.963]                             info)
[17:47:54.963]                           info <- base::paste(info, collapse = "; ")
[17:47:54.963]                           if (!has_future) {
[17:47:54.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.963]                               info)
[17:47:54.963]                           }
[17:47:54.963]                           else {
[17:47:54.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.963]                               info, version)
[17:47:54.963]                           }
[17:47:54.963]                           base::stop(msg)
[17:47:54.963]                         }
[17:47:54.963]                       })
[17:47:54.963]                     }
[17:47:54.963]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.963]                     base::options(mc.cores = 1L)
[17:47:54.963]                   }
[17:47:54.963]                   ...future.strategy.old <- future::plan("list")
[17:47:54.963]                   options(future.plan = NULL)
[17:47:54.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.963]                 }
[17:47:54.963]                 ...future.workdir <- getwd()
[17:47:54.963]             }
[17:47:54.963]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.963]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.963]         }
[17:47:54.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.963]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.963]             base::names(...future.oldOptions))
[17:47:54.963]     }
[17:47:54.963]     if (FALSE) {
[17:47:54.963]     }
[17:47:54.963]     else {
[17:47:54.963]         if (TRUE) {
[17:47:54.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.963]                 open = "w")
[17:47:54.963]         }
[17:47:54.963]         else {
[17:47:54.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.963]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.963]         }
[17:47:54.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.963]             base::sink(type = "output", split = FALSE)
[17:47:54.963]             base::close(...future.stdout)
[17:47:54.963]         }, add = TRUE)
[17:47:54.963]     }
[17:47:54.963]     ...future.frame <- base::sys.nframe()
[17:47:54.963]     ...future.conditions <- base::list()
[17:47:54.963]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.963]     if (FALSE) {
[17:47:54.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.963]     }
[17:47:54.963]     ...future.result <- base::tryCatch({
[17:47:54.963]         base::withCallingHandlers({
[17:47:54.963]             ...future.value <- base::withVisible(base::local({
[17:47:54.963]                 withCallingHandlers({
[17:47:54.963]                   1
[17:47:54.963]                 }, immediateCondition = function(cond) {
[17:47:54.963]                   save_rds <- function (object, pathname, ...) 
[17:47:54.963]                   {
[17:47:54.963]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.963]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.963]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.963]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.963]                         fi_tmp[["mtime"]])
[17:47:54.963]                     }
[17:47:54.963]                     tryCatch({
[17:47:54.963]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.963]                     }, error = function(ex) {
[17:47:54.963]                       msg <- conditionMessage(ex)
[17:47:54.963]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.963]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.963]                         fi_tmp[["mtime"]], msg)
[17:47:54.963]                       ex$message <- msg
[17:47:54.963]                       stop(ex)
[17:47:54.963]                     })
[17:47:54.963]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.963]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.963]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.963]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.963]                       fi <- file.info(pathname)
[17:47:54.963]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.963]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.963]                         fi[["size"]], fi[["mtime"]])
[17:47:54.963]                       stop(msg)
[17:47:54.963]                     }
[17:47:54.963]                     invisible(pathname)
[17:47:54.963]                   }
[17:47:54.963]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.963]                     rootPath = tempdir()) 
[17:47:54.963]                   {
[17:47:54.963]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.963]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.963]                       tmpdir = path, fileext = ".rds")
[17:47:54.963]                     save_rds(obj, file)
[17:47:54.963]                   }
[17:47:54.963]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.963]                   {
[17:47:54.963]                     inherits <- base::inherits
[17:47:54.963]                     invokeRestart <- base::invokeRestart
[17:47:54.963]                     is.null <- base::is.null
[17:47:54.963]                     muffled <- FALSE
[17:47:54.963]                     if (inherits(cond, "message")) {
[17:47:54.963]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.963]                       if (muffled) 
[17:47:54.963]                         invokeRestart("muffleMessage")
[17:47:54.963]                     }
[17:47:54.963]                     else if (inherits(cond, "warning")) {
[17:47:54.963]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.963]                       if (muffled) 
[17:47:54.963]                         invokeRestart("muffleWarning")
[17:47:54.963]                     }
[17:47:54.963]                     else if (inherits(cond, "condition")) {
[17:47:54.963]                       if (!is.null(pattern)) {
[17:47:54.963]                         computeRestarts <- base::computeRestarts
[17:47:54.963]                         grepl <- base::grepl
[17:47:54.963]                         restarts <- computeRestarts(cond)
[17:47:54.963]                         for (restart in restarts) {
[17:47:54.963]                           name <- restart$name
[17:47:54.963]                           if (is.null(name)) 
[17:47:54.963]                             next
[17:47:54.963]                           if (!grepl(pattern, name)) 
[17:47:54.963]                             next
[17:47:54.963]                           invokeRestart(restart)
[17:47:54.963]                           muffled <- TRUE
[17:47:54.963]                           break
[17:47:54.963]                         }
[17:47:54.963]                       }
[17:47:54.963]                     }
[17:47:54.963]                     invisible(muffled)
[17:47:54.963]                   }
[17:47:54.963]                   muffleCondition(cond)
[17:47:54.963]                 })
[17:47:54.963]             }))
[17:47:54.963]             future::FutureResult(value = ...future.value$value, 
[17:47:54.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.963]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.963]                     ...future.globalenv.names))
[17:47:54.963]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.963]         }, condition = base::local({
[17:47:54.963]             c <- base::c
[17:47:54.963]             inherits <- base::inherits
[17:47:54.963]             invokeRestart <- base::invokeRestart
[17:47:54.963]             length <- base::length
[17:47:54.963]             list <- base::list
[17:47:54.963]             seq.int <- base::seq.int
[17:47:54.963]             signalCondition <- base::signalCondition
[17:47:54.963]             sys.calls <- base::sys.calls
[17:47:54.963]             `[[` <- base::`[[`
[17:47:54.963]             `+` <- base::`+`
[17:47:54.963]             `<<-` <- base::`<<-`
[17:47:54.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.963]                   3L)]
[17:47:54.963]             }
[17:47:54.963]             function(cond) {
[17:47:54.963]                 is_error <- inherits(cond, "error")
[17:47:54.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.963]                   NULL)
[17:47:54.963]                 if (is_error) {
[17:47:54.963]                   sessionInformation <- function() {
[17:47:54.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.963]                       search = base::search(), system = base::Sys.info())
[17:47:54.963]                   }
[17:47:54.963]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.963]                     cond$call), session = sessionInformation(), 
[17:47:54.963]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.963]                   signalCondition(cond)
[17:47:54.963]                 }
[17:47:54.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.963]                 "immediateCondition"))) {
[17:47:54.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.963]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.963]                   if (TRUE && !signal) {
[17:47:54.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.963]                     {
[17:47:54.963]                       inherits <- base::inherits
[17:47:54.963]                       invokeRestart <- base::invokeRestart
[17:47:54.963]                       is.null <- base::is.null
[17:47:54.963]                       muffled <- FALSE
[17:47:54.963]                       if (inherits(cond, "message")) {
[17:47:54.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.963]                         if (muffled) 
[17:47:54.963]                           invokeRestart("muffleMessage")
[17:47:54.963]                       }
[17:47:54.963]                       else if (inherits(cond, "warning")) {
[17:47:54.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.963]                         if (muffled) 
[17:47:54.963]                           invokeRestart("muffleWarning")
[17:47:54.963]                       }
[17:47:54.963]                       else if (inherits(cond, "condition")) {
[17:47:54.963]                         if (!is.null(pattern)) {
[17:47:54.963]                           computeRestarts <- base::computeRestarts
[17:47:54.963]                           grepl <- base::grepl
[17:47:54.963]                           restarts <- computeRestarts(cond)
[17:47:54.963]                           for (restart in restarts) {
[17:47:54.963]                             name <- restart$name
[17:47:54.963]                             if (is.null(name)) 
[17:47:54.963]                               next
[17:47:54.963]                             if (!grepl(pattern, name)) 
[17:47:54.963]                               next
[17:47:54.963]                             invokeRestart(restart)
[17:47:54.963]                             muffled <- TRUE
[17:47:54.963]                             break
[17:47:54.963]                           }
[17:47:54.963]                         }
[17:47:54.963]                       }
[17:47:54.963]                       invisible(muffled)
[17:47:54.963]                     }
[17:47:54.963]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.963]                   }
[17:47:54.963]                 }
[17:47:54.963]                 else {
[17:47:54.963]                   if (TRUE) {
[17:47:54.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.963]                     {
[17:47:54.963]                       inherits <- base::inherits
[17:47:54.963]                       invokeRestart <- base::invokeRestart
[17:47:54.963]                       is.null <- base::is.null
[17:47:54.963]                       muffled <- FALSE
[17:47:54.963]                       if (inherits(cond, "message")) {
[17:47:54.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.963]                         if (muffled) 
[17:47:54.963]                           invokeRestart("muffleMessage")
[17:47:54.963]                       }
[17:47:54.963]                       else if (inherits(cond, "warning")) {
[17:47:54.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.963]                         if (muffled) 
[17:47:54.963]                           invokeRestart("muffleWarning")
[17:47:54.963]                       }
[17:47:54.963]                       else if (inherits(cond, "condition")) {
[17:47:54.963]                         if (!is.null(pattern)) {
[17:47:54.963]                           computeRestarts <- base::computeRestarts
[17:47:54.963]                           grepl <- base::grepl
[17:47:54.963]                           restarts <- computeRestarts(cond)
[17:47:54.963]                           for (restart in restarts) {
[17:47:54.963]                             name <- restart$name
[17:47:54.963]                             if (is.null(name)) 
[17:47:54.963]                               next
[17:47:54.963]                             if (!grepl(pattern, name)) 
[17:47:54.963]                               next
[17:47:54.963]                             invokeRestart(restart)
[17:47:54.963]                             muffled <- TRUE
[17:47:54.963]                             break
[17:47:54.963]                           }
[17:47:54.963]                         }
[17:47:54.963]                       }
[17:47:54.963]                       invisible(muffled)
[17:47:54.963]                     }
[17:47:54.963]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.963]                   }
[17:47:54.963]                 }
[17:47:54.963]             }
[17:47:54.963]         }))
[17:47:54.963]     }, error = function(ex) {
[17:47:54.963]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.963]                 ...future.rng), started = ...future.startTime, 
[17:47:54.963]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.963]             version = "1.8"), class = "FutureResult")
[17:47:54.963]     }, finally = {
[17:47:54.963]         if (!identical(...future.workdir, getwd())) 
[17:47:54.963]             setwd(...future.workdir)
[17:47:54.963]         {
[17:47:54.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.963]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.963]             }
[17:47:54.963]             base::options(...future.oldOptions)
[17:47:54.963]             if (.Platform$OS.type == "windows") {
[17:47:54.963]                 old_names <- names(...future.oldEnvVars)
[17:47:54.963]                 envs <- base::Sys.getenv()
[17:47:54.963]                 names <- names(envs)
[17:47:54.963]                 common <- intersect(names, old_names)
[17:47:54.963]                 added <- setdiff(names, old_names)
[17:47:54.963]                 removed <- setdiff(old_names, names)
[17:47:54.963]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.963]                   envs[common]]
[17:47:54.963]                 NAMES <- toupper(changed)
[17:47:54.963]                 args <- list()
[17:47:54.963]                 for (kk in seq_along(NAMES)) {
[17:47:54.963]                   name <- changed[[kk]]
[17:47:54.963]                   NAME <- NAMES[[kk]]
[17:47:54.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.963]                     next
[17:47:54.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.963]                 }
[17:47:54.963]                 NAMES <- toupper(added)
[17:47:54.963]                 for (kk in seq_along(NAMES)) {
[17:47:54.963]                   name <- added[[kk]]
[17:47:54.963]                   NAME <- NAMES[[kk]]
[17:47:54.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.963]                     next
[17:47:54.963]                   args[[name]] <- ""
[17:47:54.963]                 }
[17:47:54.963]                 NAMES <- toupper(removed)
[17:47:54.963]                 for (kk in seq_along(NAMES)) {
[17:47:54.963]                   name <- removed[[kk]]
[17:47:54.963]                   NAME <- NAMES[[kk]]
[17:47:54.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.963]                     next
[17:47:54.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.963]                 }
[17:47:54.963]                 if (length(args) > 0) 
[17:47:54.963]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.963]             }
[17:47:54.963]             else {
[17:47:54.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.963]             }
[17:47:54.963]             {
[17:47:54.963]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.963]                   0L) {
[17:47:54.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.963]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.963]                   base::options(opts)
[17:47:54.963]                 }
[17:47:54.963]                 {
[17:47:54.963]                   {
[17:47:54.963]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.963]                     NULL
[17:47:54.963]                   }
[17:47:54.963]                   options(future.plan = NULL)
[17:47:54.963]                   if (is.na(NA_character_)) 
[17:47:54.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.963]                     .init = FALSE)
[17:47:54.963]                 }
[17:47:54.963]             }
[17:47:54.963]         }
[17:47:54.963]     })
[17:47:54.963]     if (TRUE) {
[17:47:54.963]         base::sink(type = "output", split = FALSE)
[17:47:54.963]         if (TRUE) {
[17:47:54.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.963]         }
[17:47:54.963]         else {
[17:47:54.963]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.963]         }
[17:47:54.963]         base::close(...future.stdout)
[17:47:54.963]         ...future.stdout <- NULL
[17:47:54.963]     }
[17:47:54.963]     ...future.result$conditions <- ...future.conditions
[17:47:54.963]     ...future.result$finished <- base::Sys.time()
[17:47:54.963]     ...future.result
[17:47:54.963] }
[17:47:54.965] requestCore(): workers = 2
[17:47:54.966] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:54.976] result() for MulticoreFuture ...
[17:47:54.977] result() for MulticoreFuture ...
[17:47:54.977] result() for MulticoreFuture ... done
[17:47:54.977] result() for MulticoreFuture ... done
[17:47:54.977] result() for MulticoreFuture ...
[17:47:54.978] result() for MulticoreFuture ... done
[17:47:54.980] MulticoreFuture started
[17:47:54.980] - Launch lazy future ... done
[17:47:54.981] run() for ‘MulticoreFuture’ ... done
[17:47:54.981] getGlobalsAndPackages() ...
[17:47:54.981] plan(): Setting new future strategy stack:
[17:47:54.981] Searching for globals...
[17:47:54.981] List of future strategies:
[17:47:54.981] 1. sequential:
[17:47:54.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:54.981]    - tweaked: FALSE
[17:47:54.981]    - call: NULL
[17:47:54.982] 
[17:47:54.983] Searching for globals ... DONE
[17:47:54.983] plan(): nbrOfWorkers() = 1
[17:47:54.983] - globals: [0] <none>
[17:47:54.983] getGlobalsAndPackages() ... DONE
[17:47:54.984] run() for ‘Future’ ...
[17:47:54.984] - state: ‘created’
[17:47:54.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:54.986] plan(): Setting new future strategy stack:
[17:47:54.986] List of future strategies:
[17:47:54.986] 1. multicore:
[17:47:54.986]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:54.986]    - tweaked: FALSE
[17:47:54.986]    - call: plan(strategy)
[17:47:54.990] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:54.990] plan(): nbrOfWorkers() = 2
[17:47:54.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:54.991]   - Field: ‘label’
[17:47:54.991]   - Field: ‘local’
[17:47:54.991]   - Field: ‘owner’
[17:47:54.991]   - Field: ‘envir’
[17:47:54.991]   - Field: ‘workers’
[17:47:54.991]   - Field: ‘packages’
[17:47:54.992]   - Field: ‘gc’
[17:47:54.992]   - Field: ‘job’
[17:47:54.992]   - Field: ‘conditions’
[17:47:54.992]   - Field: ‘expr’
[17:47:54.992]   - Field: ‘uuid’
[17:47:54.992]   - Field: ‘seed’
[17:47:54.992]   - Field: ‘version’
[17:47:54.993]   - Field: ‘result’
[17:47:54.993]   - Field: ‘asynchronous’
[17:47:54.993]   - Field: ‘calls’
[17:47:54.993]   - Field: ‘globals’
[17:47:54.993]   - Field: ‘stdout’
[17:47:54.993]   - Field: ‘earlySignal’
[17:47:54.994]   - Field: ‘lazy’
[17:47:54.994]   - Field: ‘state’
[17:47:54.994] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:54.994] - Launch lazy future ...
[17:47:54.994] Packages needed by the future expression (n = 0): <none>
[17:47:54.995] Packages needed by future strategies (n = 0): <none>
[17:47:54.995] {
[17:47:54.995]     {
[17:47:54.995]         {
[17:47:54.995]             ...future.startTime <- base::Sys.time()
[17:47:54.995]             {
[17:47:54.995]                 {
[17:47:54.995]                   {
[17:47:54.995]                     {
[17:47:54.995]                       base::local({
[17:47:54.995]                         has_future <- base::requireNamespace("future", 
[17:47:54.995]                           quietly = TRUE)
[17:47:54.995]                         if (has_future) {
[17:47:54.995]                           ns <- base::getNamespace("future")
[17:47:54.995]                           version <- ns[[".package"]][["version"]]
[17:47:54.995]                           if (is.null(version)) 
[17:47:54.995]                             version <- utils::packageVersion("future")
[17:47:54.995]                         }
[17:47:54.995]                         else {
[17:47:54.995]                           version <- NULL
[17:47:54.995]                         }
[17:47:54.995]                         if (!has_future || version < "1.8.0") {
[17:47:54.995]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:54.995]                             "", base::R.version$version.string), 
[17:47:54.995]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:54.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:54.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:54.995]                               "release", "version")], collapse = " "), 
[17:47:54.995]                             hostname = base::Sys.info()[["nodename"]])
[17:47:54.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:54.995]                             info)
[17:47:54.995]                           info <- base::paste(info, collapse = "; ")
[17:47:54.995]                           if (!has_future) {
[17:47:54.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:54.995]                               info)
[17:47:54.995]                           }
[17:47:54.995]                           else {
[17:47:54.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:54.995]                               info, version)
[17:47:54.995]                           }
[17:47:54.995]                           base::stop(msg)
[17:47:54.995]                         }
[17:47:54.995]                       })
[17:47:54.995]                     }
[17:47:54.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:54.995]                     base::options(mc.cores = 1L)
[17:47:54.995]                   }
[17:47:54.995]                   ...future.strategy.old <- future::plan("list")
[17:47:54.995]                   options(future.plan = NULL)
[17:47:54.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:54.995]                 }
[17:47:54.995]                 ...future.workdir <- getwd()
[17:47:54.995]             }
[17:47:54.995]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:54.995]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:54.995]         }
[17:47:54.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:54.995]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:54.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:54.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:54.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:54.995]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:54.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:54.995]             base::names(...future.oldOptions))
[17:47:54.995]     }
[17:47:54.995]     if (FALSE) {
[17:47:54.995]     }
[17:47:54.995]     else {
[17:47:54.995]         if (TRUE) {
[17:47:54.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:54.995]                 open = "w")
[17:47:54.995]         }
[17:47:54.995]         else {
[17:47:54.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:54.995]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:54.995]         }
[17:47:54.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:54.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:54.995]             base::sink(type = "output", split = FALSE)
[17:47:54.995]             base::close(...future.stdout)
[17:47:54.995]         }, add = TRUE)
[17:47:54.995]     }
[17:47:54.995]     ...future.frame <- base::sys.nframe()
[17:47:54.995]     ...future.conditions <- base::list()
[17:47:54.995]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:54.995]     if (FALSE) {
[17:47:54.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:54.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:54.995]     }
[17:47:54.995]     ...future.result <- base::tryCatch({
[17:47:54.995]         base::withCallingHandlers({
[17:47:54.995]             ...future.value <- base::withVisible(base::local({
[17:47:54.995]                 withCallingHandlers({
[17:47:54.995]                   2
[17:47:54.995]                 }, immediateCondition = function(cond) {
[17:47:54.995]                   save_rds <- function (object, pathname, ...) 
[17:47:54.995]                   {
[17:47:54.995]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:54.995]                     if (file_test("-f", pathname_tmp)) {
[17:47:54.995]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.995]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:54.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.995]                         fi_tmp[["mtime"]])
[17:47:54.995]                     }
[17:47:54.995]                     tryCatch({
[17:47:54.995]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:54.995]                     }, error = function(ex) {
[17:47:54.995]                       msg <- conditionMessage(ex)
[17:47:54.995]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.995]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:54.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.995]                         fi_tmp[["mtime"]], msg)
[17:47:54.995]                       ex$message <- msg
[17:47:54.995]                       stop(ex)
[17:47:54.995]                     })
[17:47:54.995]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:54.995]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:54.995]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:54.995]                       fi_tmp <- file.info(pathname_tmp)
[17:47:54.995]                       fi <- file.info(pathname)
[17:47:54.995]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:54.995]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:54.995]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:54.995]                         fi[["size"]], fi[["mtime"]])
[17:47:54.995]                       stop(msg)
[17:47:54.995]                     }
[17:47:54.995]                     invisible(pathname)
[17:47:54.995]                   }
[17:47:54.995]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:54.995]                     rootPath = tempdir()) 
[17:47:54.995]                   {
[17:47:54.995]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:54.995]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:54.995]                       tmpdir = path, fileext = ".rds")
[17:47:54.995]                     save_rds(obj, file)
[17:47:54.995]                   }
[17:47:54.995]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:54.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.995]                   {
[17:47:54.995]                     inherits <- base::inherits
[17:47:54.995]                     invokeRestart <- base::invokeRestart
[17:47:54.995]                     is.null <- base::is.null
[17:47:54.995]                     muffled <- FALSE
[17:47:54.995]                     if (inherits(cond, "message")) {
[17:47:54.995]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:54.995]                       if (muffled) 
[17:47:54.995]                         invokeRestart("muffleMessage")
[17:47:54.995]                     }
[17:47:54.995]                     else if (inherits(cond, "warning")) {
[17:47:54.995]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:54.995]                       if (muffled) 
[17:47:54.995]                         invokeRestart("muffleWarning")
[17:47:54.995]                     }
[17:47:54.995]                     else if (inherits(cond, "condition")) {
[17:47:54.995]                       if (!is.null(pattern)) {
[17:47:54.995]                         computeRestarts <- base::computeRestarts
[17:47:54.995]                         grepl <- base::grepl
[17:47:54.995]                         restarts <- computeRestarts(cond)
[17:47:54.995]                         for (restart in restarts) {
[17:47:54.995]                           name <- restart$name
[17:47:54.995]                           if (is.null(name)) 
[17:47:54.995]                             next
[17:47:54.995]                           if (!grepl(pattern, name)) 
[17:47:54.995]                             next
[17:47:54.995]                           invokeRestart(restart)
[17:47:54.995]                           muffled <- TRUE
[17:47:54.995]                           break
[17:47:54.995]                         }
[17:47:54.995]                       }
[17:47:54.995]                     }
[17:47:54.995]                     invisible(muffled)
[17:47:54.995]                   }
[17:47:54.995]                   muffleCondition(cond)
[17:47:54.995]                 })
[17:47:54.995]             }))
[17:47:54.995]             future::FutureResult(value = ...future.value$value, 
[17:47:54.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.995]                   ...future.rng), globalenv = if (FALSE) 
[17:47:54.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:54.995]                     ...future.globalenv.names))
[17:47:54.995]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:54.995]         }, condition = base::local({
[17:47:54.995]             c <- base::c
[17:47:54.995]             inherits <- base::inherits
[17:47:54.995]             invokeRestart <- base::invokeRestart
[17:47:54.995]             length <- base::length
[17:47:54.995]             list <- base::list
[17:47:54.995]             seq.int <- base::seq.int
[17:47:54.995]             signalCondition <- base::signalCondition
[17:47:54.995]             sys.calls <- base::sys.calls
[17:47:54.995]             `[[` <- base::`[[`
[17:47:54.995]             `+` <- base::`+`
[17:47:54.995]             `<<-` <- base::`<<-`
[17:47:54.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:54.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:54.995]                   3L)]
[17:47:54.995]             }
[17:47:54.995]             function(cond) {
[17:47:54.995]                 is_error <- inherits(cond, "error")
[17:47:54.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:54.995]                   NULL)
[17:47:54.995]                 if (is_error) {
[17:47:54.995]                   sessionInformation <- function() {
[17:47:54.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:54.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:54.995]                       search = base::search(), system = base::Sys.info())
[17:47:54.995]                   }
[17:47:54.995]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:54.995]                     cond$call), session = sessionInformation(), 
[17:47:54.995]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:54.995]                   signalCondition(cond)
[17:47:54.995]                 }
[17:47:54.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:54.995]                 "immediateCondition"))) {
[17:47:54.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:54.995]                   ...future.conditions[[length(...future.conditions) + 
[17:47:54.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:54.995]                   if (TRUE && !signal) {
[17:47:54.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.995]                     {
[17:47:54.995]                       inherits <- base::inherits
[17:47:54.995]                       invokeRestart <- base::invokeRestart
[17:47:54.995]                       is.null <- base::is.null
[17:47:54.995]                       muffled <- FALSE
[17:47:54.995]                       if (inherits(cond, "message")) {
[17:47:54.995]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.995]                         if (muffled) 
[17:47:54.995]                           invokeRestart("muffleMessage")
[17:47:54.995]                       }
[17:47:54.995]                       else if (inherits(cond, "warning")) {
[17:47:54.995]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.995]                         if (muffled) 
[17:47:54.995]                           invokeRestart("muffleWarning")
[17:47:54.995]                       }
[17:47:54.995]                       else if (inherits(cond, "condition")) {
[17:47:54.995]                         if (!is.null(pattern)) {
[17:47:54.995]                           computeRestarts <- base::computeRestarts
[17:47:54.995]                           grepl <- base::grepl
[17:47:54.995]                           restarts <- computeRestarts(cond)
[17:47:54.995]                           for (restart in restarts) {
[17:47:54.995]                             name <- restart$name
[17:47:54.995]                             if (is.null(name)) 
[17:47:54.995]                               next
[17:47:54.995]                             if (!grepl(pattern, name)) 
[17:47:54.995]                               next
[17:47:54.995]                             invokeRestart(restart)
[17:47:54.995]                             muffled <- TRUE
[17:47:54.995]                             break
[17:47:54.995]                           }
[17:47:54.995]                         }
[17:47:54.995]                       }
[17:47:54.995]                       invisible(muffled)
[17:47:54.995]                     }
[17:47:54.995]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.995]                   }
[17:47:54.995]                 }
[17:47:54.995]                 else {
[17:47:54.995]                   if (TRUE) {
[17:47:54.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:54.995]                     {
[17:47:54.995]                       inherits <- base::inherits
[17:47:54.995]                       invokeRestart <- base::invokeRestart
[17:47:54.995]                       is.null <- base::is.null
[17:47:54.995]                       muffled <- FALSE
[17:47:54.995]                       if (inherits(cond, "message")) {
[17:47:54.995]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:54.995]                         if (muffled) 
[17:47:54.995]                           invokeRestart("muffleMessage")
[17:47:54.995]                       }
[17:47:54.995]                       else if (inherits(cond, "warning")) {
[17:47:54.995]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:54.995]                         if (muffled) 
[17:47:54.995]                           invokeRestart("muffleWarning")
[17:47:54.995]                       }
[17:47:54.995]                       else if (inherits(cond, "condition")) {
[17:47:54.995]                         if (!is.null(pattern)) {
[17:47:54.995]                           computeRestarts <- base::computeRestarts
[17:47:54.995]                           grepl <- base::grepl
[17:47:54.995]                           restarts <- computeRestarts(cond)
[17:47:54.995]                           for (restart in restarts) {
[17:47:54.995]                             name <- restart$name
[17:47:54.995]                             if (is.null(name)) 
[17:47:54.995]                               next
[17:47:54.995]                             if (!grepl(pattern, name)) 
[17:47:54.995]                               next
[17:47:54.995]                             invokeRestart(restart)
[17:47:54.995]                             muffled <- TRUE
[17:47:54.995]                             break
[17:47:54.995]                           }
[17:47:54.995]                         }
[17:47:54.995]                       }
[17:47:54.995]                       invisible(muffled)
[17:47:54.995]                     }
[17:47:54.995]                     muffleCondition(cond, pattern = "^muffle")
[17:47:54.995]                   }
[17:47:54.995]                 }
[17:47:54.995]             }
[17:47:54.995]         }))
[17:47:54.995]     }, error = function(ex) {
[17:47:54.995]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:54.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:54.995]                 ...future.rng), started = ...future.startTime, 
[17:47:54.995]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:54.995]             version = "1.8"), class = "FutureResult")
[17:47:54.995]     }, finally = {
[17:47:54.995]         if (!identical(...future.workdir, getwd())) 
[17:47:54.995]             setwd(...future.workdir)
[17:47:54.995]         {
[17:47:54.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:54.995]                 ...future.oldOptions$nwarnings <- NULL
[17:47:54.995]             }
[17:47:54.995]             base::options(...future.oldOptions)
[17:47:54.995]             if (.Platform$OS.type == "windows") {
[17:47:54.995]                 old_names <- names(...future.oldEnvVars)
[17:47:54.995]                 envs <- base::Sys.getenv()
[17:47:54.995]                 names <- names(envs)
[17:47:54.995]                 common <- intersect(names, old_names)
[17:47:54.995]                 added <- setdiff(names, old_names)
[17:47:54.995]                 removed <- setdiff(old_names, names)
[17:47:54.995]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:54.995]                   envs[common]]
[17:47:54.995]                 NAMES <- toupper(changed)
[17:47:54.995]                 args <- list()
[17:47:54.995]                 for (kk in seq_along(NAMES)) {
[17:47:54.995]                   name <- changed[[kk]]
[17:47:54.995]                   NAME <- NAMES[[kk]]
[17:47:54.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.995]                     next
[17:47:54.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.995]                 }
[17:47:54.995]                 NAMES <- toupper(added)
[17:47:54.995]                 for (kk in seq_along(NAMES)) {
[17:47:54.995]                   name <- added[[kk]]
[17:47:54.995]                   NAME <- NAMES[[kk]]
[17:47:54.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.995]                     next
[17:47:54.995]                   args[[name]] <- ""
[17:47:54.995]                 }
[17:47:54.995]                 NAMES <- toupper(removed)
[17:47:54.995]                 for (kk in seq_along(NAMES)) {
[17:47:54.995]                   name <- removed[[kk]]
[17:47:54.995]                   NAME <- NAMES[[kk]]
[17:47:54.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:54.995]                     next
[17:47:54.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:54.995]                 }
[17:47:54.995]                 if (length(args) > 0) 
[17:47:54.995]                   base::do.call(base::Sys.setenv, args = args)
[17:47:54.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:54.995]             }
[17:47:54.995]             else {
[17:47:54.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:54.995]             }
[17:47:54.995]             {
[17:47:54.995]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:54.995]                   0L) {
[17:47:54.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:54.995]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:54.995]                   base::options(opts)
[17:47:54.995]                 }
[17:47:54.995]                 {
[17:47:54.995]                   {
[17:47:54.995]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:54.995]                     NULL
[17:47:54.995]                   }
[17:47:54.995]                   options(future.plan = NULL)
[17:47:54.995]                   if (is.na(NA_character_)) 
[17:47:54.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:54.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:54.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:54.995]                     .init = FALSE)
[17:47:54.995]                 }
[17:47:54.995]             }
[17:47:54.995]         }
[17:47:54.995]     })
[17:47:54.995]     if (TRUE) {
[17:47:54.995]         base::sink(type = "output", split = FALSE)
[17:47:54.995]         if (TRUE) {
[17:47:54.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:54.995]         }
[17:47:54.995]         else {
[17:47:54.995]             ...future.result["stdout"] <- base::list(NULL)
[17:47:54.995]         }
[17:47:54.995]         base::close(...future.stdout)
[17:47:54.995]         ...future.stdout <- NULL
[17:47:54.995]     }
[17:47:54.995]     ...future.result$conditions <- ...future.conditions
[17:47:54.995]     ...future.result$finished <- base::Sys.time()
[17:47:54.995]     ...future.result
[17:47:54.995] }
[17:47:54.999] requestCore(): workers = 2
[17:47:54.999] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.010] result() for MulticoreFuture ...
[17:47:55.011] result() for MulticoreFuture ...
[17:47:55.011] result() for MulticoreFuture ... done
[17:47:55.011] result() for MulticoreFuture ... done
[17:47:55.011] result() for MulticoreFuture ...
[17:47:55.012] result() for MulticoreFuture ... done
[17:47:55.014] MulticoreFuture started
[17:47:55.014] - Launch lazy future ... done
[17:47:55.015] run() for ‘MulticoreFuture’ ... done
[17:47:55.015] plan(): Setting new future strategy stack:
[17:47:55.017] resolve() on environment ...
[17:47:55.016] List of future strategies:
[17:47:55.016] 1. sequential:
[17:47:55.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.016]    - tweaked: FALSE
[17:47:55.016]    - call: NULL
[17:47:55.017]  recursive: 0
[17:47:55.017] plan(): nbrOfWorkers() = 1
[17:47:55.018]  elements: [3] ‘a’, ‘b’, ‘c’
[17:47:55.019] Future #1
[17:47:55.019]  length: 2 (resolved future 1)
[17:47:55.020] plan(): Setting new future strategy stack:
[17:47:55.020] List of future strategies:
[17:47:55.020] 1. multicore:
[17:47:55.020]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.020]    - tweaked: FALSE
[17:47:55.020]    - call: plan(strategy)
[17:47:55.025] plan(): nbrOfWorkers() = 2
[17:47:55.025] Future #2
[17:47:55.025]  length: 1 (resolved future 2)
[17:47:55.026]  length: 0 (resolved future 3)
[17:47:55.026] resolve() on environment ... DONE
[17:47:55.027] getGlobalsAndPackages() ...
[17:47:55.027] Searching for globals...
[17:47:55.029] - globals found: [1] ‘{’
[17:47:55.029] Searching for globals ... DONE
[17:47:55.029] Resolving globals: FALSE
[17:47:55.029] 
[17:47:55.030] 
[17:47:55.030] getGlobalsAndPackages() ... DONE
[17:47:55.030] run() for ‘Future’ ...
[17:47:55.030] - state: ‘created’
[17:47:55.031] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.035] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.035]   - Field: ‘label’
[17:47:55.036]   - Field: ‘local’
[17:47:55.036]   - Field: ‘owner’
[17:47:55.036]   - Field: ‘envir’
[17:47:55.036]   - Field: ‘workers’
[17:47:55.036]   - Field: ‘packages’
[17:47:55.036]   - Field: ‘gc’
[17:47:55.036]   - Field: ‘job’
[17:47:55.037]   - Field: ‘conditions’
[17:47:55.037]   - Field: ‘expr’
[17:47:55.037]   - Field: ‘uuid’
[17:47:55.037]   - Field: ‘seed’
[17:47:55.037]   - Field: ‘version’
[17:47:55.037]   - Field: ‘result’
[17:47:55.037]   - Field: ‘asynchronous’
[17:47:55.038]   - Field: ‘calls’
[17:47:55.038]   - Field: ‘globals’
[17:47:55.038]   - Field: ‘stdout’
[17:47:55.038]   - Field: ‘earlySignal’
[17:47:55.038]   - Field: ‘lazy’
[17:47:55.038]   - Field: ‘state’
[17:47:55.038] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.039] - Launch lazy future ...
[17:47:55.043] Packages needed by the future expression (n = 0): <none>
[17:47:55.043] Packages needed by future strategies (n = 0): <none>
[17:47:55.045] {
[17:47:55.045]     {
[17:47:55.045]         {
[17:47:55.045]             ...future.startTime <- base::Sys.time()
[17:47:55.045]             {
[17:47:55.045]                 {
[17:47:55.045]                   {
[17:47:55.045]                     {
[17:47:55.045]                       base::local({
[17:47:55.045]                         has_future <- base::requireNamespace("future", 
[17:47:55.045]                           quietly = TRUE)
[17:47:55.045]                         if (has_future) {
[17:47:55.045]                           ns <- base::getNamespace("future")
[17:47:55.045]                           version <- ns[[".package"]][["version"]]
[17:47:55.045]                           if (is.null(version)) 
[17:47:55.045]                             version <- utils::packageVersion("future")
[17:47:55.045]                         }
[17:47:55.045]                         else {
[17:47:55.045]                           version <- NULL
[17:47:55.045]                         }
[17:47:55.045]                         if (!has_future || version < "1.8.0") {
[17:47:55.045]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.045]                             "", base::R.version$version.string), 
[17:47:55.045]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.045]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.045]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.045]                               "release", "version")], collapse = " "), 
[17:47:55.045]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.045]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.045]                             info)
[17:47:55.045]                           info <- base::paste(info, collapse = "; ")
[17:47:55.045]                           if (!has_future) {
[17:47:55.045]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.045]                               info)
[17:47:55.045]                           }
[17:47:55.045]                           else {
[17:47:55.045]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.045]                               info, version)
[17:47:55.045]                           }
[17:47:55.045]                           base::stop(msg)
[17:47:55.045]                         }
[17:47:55.045]                       })
[17:47:55.045]                     }
[17:47:55.045]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.045]                     base::options(mc.cores = 1L)
[17:47:55.045]                   }
[17:47:55.045]                   ...future.strategy.old <- future::plan("list")
[17:47:55.045]                   options(future.plan = NULL)
[17:47:55.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.045]                 }
[17:47:55.045]                 ...future.workdir <- getwd()
[17:47:55.045]             }
[17:47:55.045]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.045]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.045]         }
[17:47:55.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.045]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.045]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.045]             base::names(...future.oldOptions))
[17:47:55.045]     }
[17:47:55.045]     if (FALSE) {
[17:47:55.045]     }
[17:47:55.045]     else {
[17:47:55.045]         if (TRUE) {
[17:47:55.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.045]                 open = "w")
[17:47:55.045]         }
[17:47:55.045]         else {
[17:47:55.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.045]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.045]         }
[17:47:55.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.045]             base::sink(type = "output", split = FALSE)
[17:47:55.045]             base::close(...future.stdout)
[17:47:55.045]         }, add = TRUE)
[17:47:55.045]     }
[17:47:55.045]     ...future.frame <- base::sys.nframe()
[17:47:55.045]     ...future.conditions <- base::list()
[17:47:55.045]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.045]     if (FALSE) {
[17:47:55.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.045]     }
[17:47:55.045]     ...future.result <- base::tryCatch({
[17:47:55.045]         base::withCallingHandlers({
[17:47:55.045]             ...future.value <- base::withVisible(base::local({
[17:47:55.045]                 withCallingHandlers({
[17:47:55.045]                   {
[17:47:55.045]                     1
[17:47:55.045]                   }
[17:47:55.045]                 }, immediateCondition = function(cond) {
[17:47:55.045]                   save_rds <- function (object, pathname, ...) 
[17:47:55.045]                   {
[17:47:55.045]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.045]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.045]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.045]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.045]                         fi_tmp[["mtime"]])
[17:47:55.045]                     }
[17:47:55.045]                     tryCatch({
[17:47:55.045]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.045]                     }, error = function(ex) {
[17:47:55.045]                       msg <- conditionMessage(ex)
[17:47:55.045]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.045]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.045]                         fi_tmp[["mtime"]], msg)
[17:47:55.045]                       ex$message <- msg
[17:47:55.045]                       stop(ex)
[17:47:55.045]                     })
[17:47:55.045]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.045]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.045]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.045]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.045]                       fi <- file.info(pathname)
[17:47:55.045]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.045]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.045]                         fi[["size"]], fi[["mtime"]])
[17:47:55.045]                       stop(msg)
[17:47:55.045]                     }
[17:47:55.045]                     invisible(pathname)
[17:47:55.045]                   }
[17:47:55.045]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.045]                     rootPath = tempdir()) 
[17:47:55.045]                   {
[17:47:55.045]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.045]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.045]                       tmpdir = path, fileext = ".rds")
[17:47:55.045]                     save_rds(obj, file)
[17:47:55.045]                   }
[17:47:55.045]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.045]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.045]                   {
[17:47:55.045]                     inherits <- base::inherits
[17:47:55.045]                     invokeRestart <- base::invokeRestart
[17:47:55.045]                     is.null <- base::is.null
[17:47:55.045]                     muffled <- FALSE
[17:47:55.045]                     if (inherits(cond, "message")) {
[17:47:55.045]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.045]                       if (muffled) 
[17:47:55.045]                         invokeRestart("muffleMessage")
[17:47:55.045]                     }
[17:47:55.045]                     else if (inherits(cond, "warning")) {
[17:47:55.045]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.045]                       if (muffled) 
[17:47:55.045]                         invokeRestart("muffleWarning")
[17:47:55.045]                     }
[17:47:55.045]                     else if (inherits(cond, "condition")) {
[17:47:55.045]                       if (!is.null(pattern)) {
[17:47:55.045]                         computeRestarts <- base::computeRestarts
[17:47:55.045]                         grepl <- base::grepl
[17:47:55.045]                         restarts <- computeRestarts(cond)
[17:47:55.045]                         for (restart in restarts) {
[17:47:55.045]                           name <- restart$name
[17:47:55.045]                           if (is.null(name)) 
[17:47:55.045]                             next
[17:47:55.045]                           if (!grepl(pattern, name)) 
[17:47:55.045]                             next
[17:47:55.045]                           invokeRestart(restart)
[17:47:55.045]                           muffled <- TRUE
[17:47:55.045]                           break
[17:47:55.045]                         }
[17:47:55.045]                       }
[17:47:55.045]                     }
[17:47:55.045]                     invisible(muffled)
[17:47:55.045]                   }
[17:47:55.045]                   muffleCondition(cond)
[17:47:55.045]                 })
[17:47:55.045]             }))
[17:47:55.045]             future::FutureResult(value = ...future.value$value, 
[17:47:55.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.045]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.045]                     ...future.globalenv.names))
[17:47:55.045]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.045]         }, condition = base::local({
[17:47:55.045]             c <- base::c
[17:47:55.045]             inherits <- base::inherits
[17:47:55.045]             invokeRestart <- base::invokeRestart
[17:47:55.045]             length <- base::length
[17:47:55.045]             list <- base::list
[17:47:55.045]             seq.int <- base::seq.int
[17:47:55.045]             signalCondition <- base::signalCondition
[17:47:55.045]             sys.calls <- base::sys.calls
[17:47:55.045]             `[[` <- base::`[[`
[17:47:55.045]             `+` <- base::`+`
[17:47:55.045]             `<<-` <- base::`<<-`
[17:47:55.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.045]                   3L)]
[17:47:55.045]             }
[17:47:55.045]             function(cond) {
[17:47:55.045]                 is_error <- inherits(cond, "error")
[17:47:55.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.045]                   NULL)
[17:47:55.045]                 if (is_error) {
[17:47:55.045]                   sessionInformation <- function() {
[17:47:55.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.045]                       search = base::search(), system = base::Sys.info())
[17:47:55.045]                   }
[17:47:55.045]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.045]                     cond$call), session = sessionInformation(), 
[17:47:55.045]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.045]                   signalCondition(cond)
[17:47:55.045]                 }
[17:47:55.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.045]                 "immediateCondition"))) {
[17:47:55.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.045]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.045]                   if (TRUE && !signal) {
[17:47:55.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.045]                     {
[17:47:55.045]                       inherits <- base::inherits
[17:47:55.045]                       invokeRestart <- base::invokeRestart
[17:47:55.045]                       is.null <- base::is.null
[17:47:55.045]                       muffled <- FALSE
[17:47:55.045]                       if (inherits(cond, "message")) {
[17:47:55.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.045]                         if (muffled) 
[17:47:55.045]                           invokeRestart("muffleMessage")
[17:47:55.045]                       }
[17:47:55.045]                       else if (inherits(cond, "warning")) {
[17:47:55.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.045]                         if (muffled) 
[17:47:55.045]                           invokeRestart("muffleWarning")
[17:47:55.045]                       }
[17:47:55.045]                       else if (inherits(cond, "condition")) {
[17:47:55.045]                         if (!is.null(pattern)) {
[17:47:55.045]                           computeRestarts <- base::computeRestarts
[17:47:55.045]                           grepl <- base::grepl
[17:47:55.045]                           restarts <- computeRestarts(cond)
[17:47:55.045]                           for (restart in restarts) {
[17:47:55.045]                             name <- restart$name
[17:47:55.045]                             if (is.null(name)) 
[17:47:55.045]                               next
[17:47:55.045]                             if (!grepl(pattern, name)) 
[17:47:55.045]                               next
[17:47:55.045]                             invokeRestart(restart)
[17:47:55.045]                             muffled <- TRUE
[17:47:55.045]                             break
[17:47:55.045]                           }
[17:47:55.045]                         }
[17:47:55.045]                       }
[17:47:55.045]                       invisible(muffled)
[17:47:55.045]                     }
[17:47:55.045]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.045]                   }
[17:47:55.045]                 }
[17:47:55.045]                 else {
[17:47:55.045]                   if (TRUE) {
[17:47:55.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.045]                     {
[17:47:55.045]                       inherits <- base::inherits
[17:47:55.045]                       invokeRestart <- base::invokeRestart
[17:47:55.045]                       is.null <- base::is.null
[17:47:55.045]                       muffled <- FALSE
[17:47:55.045]                       if (inherits(cond, "message")) {
[17:47:55.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.045]                         if (muffled) 
[17:47:55.045]                           invokeRestart("muffleMessage")
[17:47:55.045]                       }
[17:47:55.045]                       else if (inherits(cond, "warning")) {
[17:47:55.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.045]                         if (muffled) 
[17:47:55.045]                           invokeRestart("muffleWarning")
[17:47:55.045]                       }
[17:47:55.045]                       else if (inherits(cond, "condition")) {
[17:47:55.045]                         if (!is.null(pattern)) {
[17:47:55.045]                           computeRestarts <- base::computeRestarts
[17:47:55.045]                           grepl <- base::grepl
[17:47:55.045]                           restarts <- computeRestarts(cond)
[17:47:55.045]                           for (restart in restarts) {
[17:47:55.045]                             name <- restart$name
[17:47:55.045]                             if (is.null(name)) 
[17:47:55.045]                               next
[17:47:55.045]                             if (!grepl(pattern, name)) 
[17:47:55.045]                               next
[17:47:55.045]                             invokeRestart(restart)
[17:47:55.045]                             muffled <- TRUE
[17:47:55.045]                             break
[17:47:55.045]                           }
[17:47:55.045]                         }
[17:47:55.045]                       }
[17:47:55.045]                       invisible(muffled)
[17:47:55.045]                     }
[17:47:55.045]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.045]                   }
[17:47:55.045]                 }
[17:47:55.045]             }
[17:47:55.045]         }))
[17:47:55.045]     }, error = function(ex) {
[17:47:55.045]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.045]                 ...future.rng), started = ...future.startTime, 
[17:47:55.045]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.045]             version = "1.8"), class = "FutureResult")
[17:47:55.045]     }, finally = {
[17:47:55.045]         if (!identical(...future.workdir, getwd())) 
[17:47:55.045]             setwd(...future.workdir)
[17:47:55.045]         {
[17:47:55.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.045]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.045]             }
[17:47:55.045]             base::options(...future.oldOptions)
[17:47:55.045]             if (.Platform$OS.type == "windows") {
[17:47:55.045]                 old_names <- names(...future.oldEnvVars)
[17:47:55.045]                 envs <- base::Sys.getenv()
[17:47:55.045]                 names <- names(envs)
[17:47:55.045]                 common <- intersect(names, old_names)
[17:47:55.045]                 added <- setdiff(names, old_names)
[17:47:55.045]                 removed <- setdiff(old_names, names)
[17:47:55.045]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.045]                   envs[common]]
[17:47:55.045]                 NAMES <- toupper(changed)
[17:47:55.045]                 args <- list()
[17:47:55.045]                 for (kk in seq_along(NAMES)) {
[17:47:55.045]                   name <- changed[[kk]]
[17:47:55.045]                   NAME <- NAMES[[kk]]
[17:47:55.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.045]                     next
[17:47:55.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.045]                 }
[17:47:55.045]                 NAMES <- toupper(added)
[17:47:55.045]                 for (kk in seq_along(NAMES)) {
[17:47:55.045]                   name <- added[[kk]]
[17:47:55.045]                   NAME <- NAMES[[kk]]
[17:47:55.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.045]                     next
[17:47:55.045]                   args[[name]] <- ""
[17:47:55.045]                 }
[17:47:55.045]                 NAMES <- toupper(removed)
[17:47:55.045]                 for (kk in seq_along(NAMES)) {
[17:47:55.045]                   name <- removed[[kk]]
[17:47:55.045]                   NAME <- NAMES[[kk]]
[17:47:55.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.045]                     next
[17:47:55.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.045]                 }
[17:47:55.045]                 if (length(args) > 0) 
[17:47:55.045]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.045]             }
[17:47:55.045]             else {
[17:47:55.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.045]             }
[17:47:55.045]             {
[17:47:55.045]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.045]                   0L) {
[17:47:55.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.045]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.045]                   base::options(opts)
[17:47:55.045]                 }
[17:47:55.045]                 {
[17:47:55.045]                   {
[17:47:55.045]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.045]                     NULL
[17:47:55.045]                   }
[17:47:55.045]                   options(future.plan = NULL)
[17:47:55.045]                   if (is.na(NA_character_)) 
[17:47:55.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.045]                     .init = FALSE)
[17:47:55.045]                 }
[17:47:55.045]             }
[17:47:55.045]         }
[17:47:55.045]     })
[17:47:55.045]     if (TRUE) {
[17:47:55.045]         base::sink(type = "output", split = FALSE)
[17:47:55.045]         if (TRUE) {
[17:47:55.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.045]         }
[17:47:55.045]         else {
[17:47:55.045]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.045]         }
[17:47:55.045]         base::close(...future.stdout)
[17:47:55.045]         ...future.stdout <- NULL
[17:47:55.045]     }
[17:47:55.045]     ...future.result$conditions <- ...future.conditions
[17:47:55.045]     ...future.result$finished <- base::Sys.time()
[17:47:55.045]     ...future.result
[17:47:55.045] }
[17:47:55.048] requestCore(): workers = 2
[17:47:55.048] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.059] result() for MulticoreFuture ...
[17:47:55.060] result() for MulticoreFuture ...
[17:47:55.060] result() for MulticoreFuture ... done
[17:47:55.060] result() for MulticoreFuture ... done
[17:47:55.061] result() for MulticoreFuture ...
[17:47:55.061] result() for MulticoreFuture ... done
[17:47:55.063] MulticoreFuture started
[17:47:55.064] - Launch lazy future ... done
[17:47:55.064] run() for ‘MulticoreFuture’ ... done
[17:47:55.065] plan(): Setting new future strategy stack:
[17:47:55.066] getGlobalsAndPackages() ...
[17:47:55.066] Searching for globals...
[17:47:55.065] List of future strategies:
[17:47:55.065] 1. sequential:
[17:47:55.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.065]    - tweaked: FALSE
[17:47:55.065]    - call: NULL
[17:47:55.067] plan(): nbrOfWorkers() = 1
[17:47:55.069] - globals found: [1] ‘{’
[17:47:55.069] Searching for globals ... DONE
[17:47:55.069] Resolving globals: FALSE
[17:47:55.070] plan(): Setting new future strategy stack:
[17:47:55.070] 
[17:47:55.070] 
[17:47:55.071] getGlobalsAndPackages() ... DONE
[17:47:55.070] List of future strategies:
[17:47:55.070] 1. multicore:
[17:47:55.070]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.070]    - tweaked: FALSE
[17:47:55.070]    - call: plan(strategy)
[17:47:55.071] run() for ‘Future’ ...
[17:47:55.072] - state: ‘created’
[17:47:55.072] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.076] plan(): nbrOfWorkers() = 2
[17:47:55.077] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.078]   - Field: ‘label’
[17:47:55.078]   - Field: ‘local’
[17:47:55.078]   - Field: ‘owner’
[17:47:55.078]   - Field: ‘envir’
[17:47:55.079]   - Field: ‘workers’
[17:47:55.079]   - Field: ‘packages’
[17:47:55.079]   - Field: ‘gc’
[17:47:55.079]   - Field: ‘job’
[17:47:55.079]   - Field: ‘conditions’
[17:47:55.079]   - Field: ‘expr’
[17:47:55.079]   - Field: ‘uuid’
[17:47:55.080]   - Field: ‘seed’
[17:47:55.080]   - Field: ‘version’
[17:47:55.080]   - Field: ‘result’
[17:47:55.080]   - Field: ‘asynchronous’
[17:47:55.080]   - Field: ‘calls’
[17:47:55.080]   - Field: ‘globals’
[17:47:55.080]   - Field: ‘stdout’
[17:47:55.081]   - Field: ‘earlySignal’
[17:47:55.081]   - Field: ‘lazy’
[17:47:55.081]   - Field: ‘state’
[17:47:55.081] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.081] - Launch lazy future ...
[17:47:55.082] Packages needed by the future expression (n = 0): <none>
[17:47:55.082] Packages needed by future strategies (n = 0): <none>
[17:47:55.083] {
[17:47:55.083]     {
[17:47:55.083]         {
[17:47:55.083]             ...future.startTime <- base::Sys.time()
[17:47:55.083]             {
[17:47:55.083]                 {
[17:47:55.083]                   {
[17:47:55.083]                     {
[17:47:55.083]                       base::local({
[17:47:55.083]                         has_future <- base::requireNamespace("future", 
[17:47:55.083]                           quietly = TRUE)
[17:47:55.083]                         if (has_future) {
[17:47:55.083]                           ns <- base::getNamespace("future")
[17:47:55.083]                           version <- ns[[".package"]][["version"]]
[17:47:55.083]                           if (is.null(version)) 
[17:47:55.083]                             version <- utils::packageVersion("future")
[17:47:55.083]                         }
[17:47:55.083]                         else {
[17:47:55.083]                           version <- NULL
[17:47:55.083]                         }
[17:47:55.083]                         if (!has_future || version < "1.8.0") {
[17:47:55.083]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.083]                             "", base::R.version$version.string), 
[17:47:55.083]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.083]                               "release", "version")], collapse = " "), 
[17:47:55.083]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.083]                             info)
[17:47:55.083]                           info <- base::paste(info, collapse = "; ")
[17:47:55.083]                           if (!has_future) {
[17:47:55.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.083]                               info)
[17:47:55.083]                           }
[17:47:55.083]                           else {
[17:47:55.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.083]                               info, version)
[17:47:55.083]                           }
[17:47:55.083]                           base::stop(msg)
[17:47:55.083]                         }
[17:47:55.083]                       })
[17:47:55.083]                     }
[17:47:55.083]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.083]                     base::options(mc.cores = 1L)
[17:47:55.083]                   }
[17:47:55.083]                   ...future.strategy.old <- future::plan("list")
[17:47:55.083]                   options(future.plan = NULL)
[17:47:55.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.083]                 }
[17:47:55.083]                 ...future.workdir <- getwd()
[17:47:55.083]             }
[17:47:55.083]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.083]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.083]         }
[17:47:55.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.083]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.083]             base::names(...future.oldOptions))
[17:47:55.083]     }
[17:47:55.083]     if (FALSE) {
[17:47:55.083]     }
[17:47:55.083]     else {
[17:47:55.083]         if (TRUE) {
[17:47:55.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.083]                 open = "w")
[17:47:55.083]         }
[17:47:55.083]         else {
[17:47:55.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.083]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.083]         }
[17:47:55.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.083]             base::sink(type = "output", split = FALSE)
[17:47:55.083]             base::close(...future.stdout)
[17:47:55.083]         }, add = TRUE)
[17:47:55.083]     }
[17:47:55.083]     ...future.frame <- base::sys.nframe()
[17:47:55.083]     ...future.conditions <- base::list()
[17:47:55.083]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.083]     if (FALSE) {
[17:47:55.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.083]     }
[17:47:55.083]     ...future.result <- base::tryCatch({
[17:47:55.083]         base::withCallingHandlers({
[17:47:55.083]             ...future.value <- base::withVisible(base::local({
[17:47:55.083]                 withCallingHandlers({
[17:47:55.083]                   {
[17:47:55.083]                     2
[17:47:55.083]                   }
[17:47:55.083]                 }, immediateCondition = function(cond) {
[17:47:55.083]                   save_rds <- function (object, pathname, ...) 
[17:47:55.083]                   {
[17:47:55.083]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.083]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.083]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.083]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.083]                         fi_tmp[["mtime"]])
[17:47:55.083]                     }
[17:47:55.083]                     tryCatch({
[17:47:55.083]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.083]                     }, error = function(ex) {
[17:47:55.083]                       msg <- conditionMessage(ex)
[17:47:55.083]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.083]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.083]                         fi_tmp[["mtime"]], msg)
[17:47:55.083]                       ex$message <- msg
[17:47:55.083]                       stop(ex)
[17:47:55.083]                     })
[17:47:55.083]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.083]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.083]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.083]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.083]                       fi <- file.info(pathname)
[17:47:55.083]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.083]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.083]                         fi[["size"]], fi[["mtime"]])
[17:47:55.083]                       stop(msg)
[17:47:55.083]                     }
[17:47:55.083]                     invisible(pathname)
[17:47:55.083]                   }
[17:47:55.083]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.083]                     rootPath = tempdir()) 
[17:47:55.083]                   {
[17:47:55.083]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.083]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.083]                       tmpdir = path, fileext = ".rds")
[17:47:55.083]                     save_rds(obj, file)
[17:47:55.083]                   }
[17:47:55.083]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.083]                   {
[17:47:55.083]                     inherits <- base::inherits
[17:47:55.083]                     invokeRestart <- base::invokeRestart
[17:47:55.083]                     is.null <- base::is.null
[17:47:55.083]                     muffled <- FALSE
[17:47:55.083]                     if (inherits(cond, "message")) {
[17:47:55.083]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.083]                       if (muffled) 
[17:47:55.083]                         invokeRestart("muffleMessage")
[17:47:55.083]                     }
[17:47:55.083]                     else if (inherits(cond, "warning")) {
[17:47:55.083]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.083]                       if (muffled) 
[17:47:55.083]                         invokeRestart("muffleWarning")
[17:47:55.083]                     }
[17:47:55.083]                     else if (inherits(cond, "condition")) {
[17:47:55.083]                       if (!is.null(pattern)) {
[17:47:55.083]                         computeRestarts <- base::computeRestarts
[17:47:55.083]                         grepl <- base::grepl
[17:47:55.083]                         restarts <- computeRestarts(cond)
[17:47:55.083]                         for (restart in restarts) {
[17:47:55.083]                           name <- restart$name
[17:47:55.083]                           if (is.null(name)) 
[17:47:55.083]                             next
[17:47:55.083]                           if (!grepl(pattern, name)) 
[17:47:55.083]                             next
[17:47:55.083]                           invokeRestart(restart)
[17:47:55.083]                           muffled <- TRUE
[17:47:55.083]                           break
[17:47:55.083]                         }
[17:47:55.083]                       }
[17:47:55.083]                     }
[17:47:55.083]                     invisible(muffled)
[17:47:55.083]                   }
[17:47:55.083]                   muffleCondition(cond)
[17:47:55.083]                 })
[17:47:55.083]             }))
[17:47:55.083]             future::FutureResult(value = ...future.value$value, 
[17:47:55.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.083]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.083]                     ...future.globalenv.names))
[17:47:55.083]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.083]         }, condition = base::local({
[17:47:55.083]             c <- base::c
[17:47:55.083]             inherits <- base::inherits
[17:47:55.083]             invokeRestart <- base::invokeRestart
[17:47:55.083]             length <- base::length
[17:47:55.083]             list <- base::list
[17:47:55.083]             seq.int <- base::seq.int
[17:47:55.083]             signalCondition <- base::signalCondition
[17:47:55.083]             sys.calls <- base::sys.calls
[17:47:55.083]             `[[` <- base::`[[`
[17:47:55.083]             `+` <- base::`+`
[17:47:55.083]             `<<-` <- base::`<<-`
[17:47:55.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.083]                   3L)]
[17:47:55.083]             }
[17:47:55.083]             function(cond) {
[17:47:55.083]                 is_error <- inherits(cond, "error")
[17:47:55.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.083]                   NULL)
[17:47:55.083]                 if (is_error) {
[17:47:55.083]                   sessionInformation <- function() {
[17:47:55.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.083]                       search = base::search(), system = base::Sys.info())
[17:47:55.083]                   }
[17:47:55.083]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.083]                     cond$call), session = sessionInformation(), 
[17:47:55.083]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.083]                   signalCondition(cond)
[17:47:55.083]                 }
[17:47:55.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.083]                 "immediateCondition"))) {
[17:47:55.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.083]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.083]                   if (TRUE && !signal) {
[17:47:55.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.083]                     {
[17:47:55.083]                       inherits <- base::inherits
[17:47:55.083]                       invokeRestart <- base::invokeRestart
[17:47:55.083]                       is.null <- base::is.null
[17:47:55.083]                       muffled <- FALSE
[17:47:55.083]                       if (inherits(cond, "message")) {
[17:47:55.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.083]                         if (muffled) 
[17:47:55.083]                           invokeRestart("muffleMessage")
[17:47:55.083]                       }
[17:47:55.083]                       else if (inherits(cond, "warning")) {
[17:47:55.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.083]                         if (muffled) 
[17:47:55.083]                           invokeRestart("muffleWarning")
[17:47:55.083]                       }
[17:47:55.083]                       else if (inherits(cond, "condition")) {
[17:47:55.083]                         if (!is.null(pattern)) {
[17:47:55.083]                           computeRestarts <- base::computeRestarts
[17:47:55.083]                           grepl <- base::grepl
[17:47:55.083]                           restarts <- computeRestarts(cond)
[17:47:55.083]                           for (restart in restarts) {
[17:47:55.083]                             name <- restart$name
[17:47:55.083]                             if (is.null(name)) 
[17:47:55.083]                               next
[17:47:55.083]                             if (!grepl(pattern, name)) 
[17:47:55.083]                               next
[17:47:55.083]                             invokeRestart(restart)
[17:47:55.083]                             muffled <- TRUE
[17:47:55.083]                             break
[17:47:55.083]                           }
[17:47:55.083]                         }
[17:47:55.083]                       }
[17:47:55.083]                       invisible(muffled)
[17:47:55.083]                     }
[17:47:55.083]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.083]                   }
[17:47:55.083]                 }
[17:47:55.083]                 else {
[17:47:55.083]                   if (TRUE) {
[17:47:55.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.083]                     {
[17:47:55.083]                       inherits <- base::inherits
[17:47:55.083]                       invokeRestart <- base::invokeRestart
[17:47:55.083]                       is.null <- base::is.null
[17:47:55.083]                       muffled <- FALSE
[17:47:55.083]                       if (inherits(cond, "message")) {
[17:47:55.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.083]                         if (muffled) 
[17:47:55.083]                           invokeRestart("muffleMessage")
[17:47:55.083]                       }
[17:47:55.083]                       else if (inherits(cond, "warning")) {
[17:47:55.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.083]                         if (muffled) 
[17:47:55.083]                           invokeRestart("muffleWarning")
[17:47:55.083]                       }
[17:47:55.083]                       else if (inherits(cond, "condition")) {
[17:47:55.083]                         if (!is.null(pattern)) {
[17:47:55.083]                           computeRestarts <- base::computeRestarts
[17:47:55.083]                           grepl <- base::grepl
[17:47:55.083]                           restarts <- computeRestarts(cond)
[17:47:55.083]                           for (restart in restarts) {
[17:47:55.083]                             name <- restart$name
[17:47:55.083]                             if (is.null(name)) 
[17:47:55.083]                               next
[17:47:55.083]                             if (!grepl(pattern, name)) 
[17:47:55.083]                               next
[17:47:55.083]                             invokeRestart(restart)
[17:47:55.083]                             muffled <- TRUE
[17:47:55.083]                             break
[17:47:55.083]                           }
[17:47:55.083]                         }
[17:47:55.083]                       }
[17:47:55.083]                       invisible(muffled)
[17:47:55.083]                     }
[17:47:55.083]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.083]                   }
[17:47:55.083]                 }
[17:47:55.083]             }
[17:47:55.083]         }))
[17:47:55.083]     }, error = function(ex) {
[17:47:55.083]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.083]                 ...future.rng), started = ...future.startTime, 
[17:47:55.083]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.083]             version = "1.8"), class = "FutureResult")
[17:47:55.083]     }, finally = {
[17:47:55.083]         if (!identical(...future.workdir, getwd())) 
[17:47:55.083]             setwd(...future.workdir)
[17:47:55.083]         {
[17:47:55.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.083]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.083]             }
[17:47:55.083]             base::options(...future.oldOptions)
[17:47:55.083]             if (.Platform$OS.type == "windows") {
[17:47:55.083]                 old_names <- names(...future.oldEnvVars)
[17:47:55.083]                 envs <- base::Sys.getenv()
[17:47:55.083]                 names <- names(envs)
[17:47:55.083]                 common <- intersect(names, old_names)
[17:47:55.083]                 added <- setdiff(names, old_names)
[17:47:55.083]                 removed <- setdiff(old_names, names)
[17:47:55.083]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.083]                   envs[common]]
[17:47:55.083]                 NAMES <- toupper(changed)
[17:47:55.083]                 args <- list()
[17:47:55.083]                 for (kk in seq_along(NAMES)) {
[17:47:55.083]                   name <- changed[[kk]]
[17:47:55.083]                   NAME <- NAMES[[kk]]
[17:47:55.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.083]                     next
[17:47:55.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.083]                 }
[17:47:55.083]                 NAMES <- toupper(added)
[17:47:55.083]                 for (kk in seq_along(NAMES)) {
[17:47:55.083]                   name <- added[[kk]]
[17:47:55.083]                   NAME <- NAMES[[kk]]
[17:47:55.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.083]                     next
[17:47:55.083]                   args[[name]] <- ""
[17:47:55.083]                 }
[17:47:55.083]                 NAMES <- toupper(removed)
[17:47:55.083]                 for (kk in seq_along(NAMES)) {
[17:47:55.083]                   name <- removed[[kk]]
[17:47:55.083]                   NAME <- NAMES[[kk]]
[17:47:55.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.083]                     next
[17:47:55.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.083]                 }
[17:47:55.083]                 if (length(args) > 0) 
[17:47:55.083]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.083]             }
[17:47:55.083]             else {
[17:47:55.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.083]             }
[17:47:55.083]             {
[17:47:55.083]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.083]                   0L) {
[17:47:55.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.083]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.083]                   base::options(opts)
[17:47:55.083]                 }
[17:47:55.083]                 {
[17:47:55.083]                   {
[17:47:55.083]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.083]                     NULL
[17:47:55.083]                   }
[17:47:55.083]                   options(future.plan = NULL)
[17:47:55.083]                   if (is.na(NA_character_)) 
[17:47:55.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.083]                     .init = FALSE)
[17:47:55.083]                 }
[17:47:55.083]             }
[17:47:55.083]         }
[17:47:55.083]     })
[17:47:55.083]     if (TRUE) {
[17:47:55.083]         base::sink(type = "output", split = FALSE)
[17:47:55.083]         if (TRUE) {
[17:47:55.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.083]         }
[17:47:55.083]         else {
[17:47:55.083]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.083]         }
[17:47:55.083]         base::close(...future.stdout)
[17:47:55.083]         ...future.stdout <- NULL
[17:47:55.083]     }
[17:47:55.083]     ...future.result$conditions <- ...future.conditions
[17:47:55.083]     ...future.result$finished <- base::Sys.time()
[17:47:55.083]     ...future.result
[17:47:55.083] }
[17:47:55.086] requestCore(): workers = 2
[17:47:55.086] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.097] result() for MulticoreFuture ...
[17:47:55.098] result() for MulticoreFuture ...
[17:47:55.098] result() for MulticoreFuture ... done
[17:47:55.098] result() for MulticoreFuture ... done
[17:47:55.098] result() for MulticoreFuture ...
[17:47:55.099] result() for MulticoreFuture ... done
[17:47:55.101] MulticoreFuture started
[17:47:55.102] - Launch lazy future ... done
[17:47:55.102] run() for ‘MulticoreFuture’ ... done
[17:47:55.103] plan(): Setting new future strategy stack:
[17:47:55.103] List of future strategies:
[17:47:55.103] 1. sequential:
[17:47:55.103]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.103]    - tweaked: FALSE
[17:47:55.103]    - call: NULL
[17:47:55.104] resolve() on environment ...
[17:47:55.104]  recursive: 0
[17:47:55.104] plan(): nbrOfWorkers() = 1
[17:47:55.105]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:47:55.105] Future #1
[17:47:55.105]  length: 2 (resolved future 1)
[17:47:55.106] plan(): Setting new future strategy stack:
[17:47:55.106] List of future strategies:
[17:47:55.106] 1. multicore:
[17:47:55.106]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.106]    - tweaked: FALSE
[17:47:55.106]    - call: plan(strategy)
[17:47:55.111] plan(): nbrOfWorkers() = 2
[17:47:55.112] Future #2
[17:47:55.112]  length: 1 (resolved future 2)
[17:47:55.112]  length: 0 (resolved future 3)
[17:47:55.112] resolve() on environment ... DONE
[17:47:55.113] getGlobalsAndPackages() ...
[17:47:55.113] Searching for globals...
[17:47:55.114] - globals found: [1] ‘{’
[17:47:55.114] Searching for globals ... DONE
[17:47:55.115] Resolving globals: FALSE
[17:47:55.115] 
[17:47:55.115] 
[17:47:55.115] getGlobalsAndPackages() ... DONE
[17:47:55.116] run() for ‘Future’ ...
[17:47:55.116] - state: ‘created’
[17:47:55.116] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.121] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.121]   - Field: ‘label’
[17:47:55.121]   - Field: ‘local’
[17:47:55.122]   - Field: ‘owner’
[17:47:55.122]   - Field: ‘envir’
[17:47:55.122]   - Field: ‘workers’
[17:47:55.122]   - Field: ‘packages’
[17:47:55.122]   - Field: ‘gc’
[17:47:55.122]   - Field: ‘job’
[17:47:55.122]   - Field: ‘conditions’
[17:47:55.123]   - Field: ‘expr’
[17:47:55.123]   - Field: ‘uuid’
[17:47:55.123]   - Field: ‘seed’
[17:47:55.123]   - Field: ‘version’
[17:47:55.123]   - Field: ‘result’
[17:47:55.123]   - Field: ‘asynchronous’
[17:47:55.123]   - Field: ‘calls’
[17:47:55.124]   - Field: ‘globals’
[17:47:55.124]   - Field: ‘stdout’
[17:47:55.124]   - Field: ‘earlySignal’
[17:47:55.124]   - Field: ‘lazy’
[17:47:55.124]   - Field: ‘state’
[17:47:55.124] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.124] - Launch lazy future ...
[17:47:55.125] Packages needed by the future expression (n = 0): <none>
[17:47:55.125] Packages needed by future strategies (n = 0): <none>
[17:47:55.126] {
[17:47:55.126]     {
[17:47:55.126]         {
[17:47:55.126]             ...future.startTime <- base::Sys.time()
[17:47:55.126]             {
[17:47:55.126]                 {
[17:47:55.126]                   {
[17:47:55.126]                     {
[17:47:55.126]                       base::local({
[17:47:55.126]                         has_future <- base::requireNamespace("future", 
[17:47:55.126]                           quietly = TRUE)
[17:47:55.126]                         if (has_future) {
[17:47:55.126]                           ns <- base::getNamespace("future")
[17:47:55.126]                           version <- ns[[".package"]][["version"]]
[17:47:55.126]                           if (is.null(version)) 
[17:47:55.126]                             version <- utils::packageVersion("future")
[17:47:55.126]                         }
[17:47:55.126]                         else {
[17:47:55.126]                           version <- NULL
[17:47:55.126]                         }
[17:47:55.126]                         if (!has_future || version < "1.8.0") {
[17:47:55.126]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.126]                             "", base::R.version$version.string), 
[17:47:55.126]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.126]                               "release", "version")], collapse = " "), 
[17:47:55.126]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.126]                             info)
[17:47:55.126]                           info <- base::paste(info, collapse = "; ")
[17:47:55.126]                           if (!has_future) {
[17:47:55.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.126]                               info)
[17:47:55.126]                           }
[17:47:55.126]                           else {
[17:47:55.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.126]                               info, version)
[17:47:55.126]                           }
[17:47:55.126]                           base::stop(msg)
[17:47:55.126]                         }
[17:47:55.126]                       })
[17:47:55.126]                     }
[17:47:55.126]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.126]                     base::options(mc.cores = 1L)
[17:47:55.126]                   }
[17:47:55.126]                   ...future.strategy.old <- future::plan("list")
[17:47:55.126]                   options(future.plan = NULL)
[17:47:55.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.126]                 }
[17:47:55.126]                 ...future.workdir <- getwd()
[17:47:55.126]             }
[17:47:55.126]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.126]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.126]         }
[17:47:55.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.126]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.126]             base::names(...future.oldOptions))
[17:47:55.126]     }
[17:47:55.126]     if (FALSE) {
[17:47:55.126]     }
[17:47:55.126]     else {
[17:47:55.126]         if (TRUE) {
[17:47:55.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.126]                 open = "w")
[17:47:55.126]         }
[17:47:55.126]         else {
[17:47:55.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.126]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.126]         }
[17:47:55.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.126]             base::sink(type = "output", split = FALSE)
[17:47:55.126]             base::close(...future.stdout)
[17:47:55.126]         }, add = TRUE)
[17:47:55.126]     }
[17:47:55.126]     ...future.frame <- base::sys.nframe()
[17:47:55.126]     ...future.conditions <- base::list()
[17:47:55.126]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.126]     if (FALSE) {
[17:47:55.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.126]     }
[17:47:55.126]     ...future.result <- base::tryCatch({
[17:47:55.126]         base::withCallingHandlers({
[17:47:55.126]             ...future.value <- base::withVisible(base::local({
[17:47:55.126]                 withCallingHandlers({
[17:47:55.126]                   {
[17:47:55.126]                     1
[17:47:55.126]                   }
[17:47:55.126]                 }, immediateCondition = function(cond) {
[17:47:55.126]                   save_rds <- function (object, pathname, ...) 
[17:47:55.126]                   {
[17:47:55.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.126]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.126]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.126]                         fi_tmp[["mtime"]])
[17:47:55.126]                     }
[17:47:55.126]                     tryCatch({
[17:47:55.126]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.126]                     }, error = function(ex) {
[17:47:55.126]                       msg <- conditionMessage(ex)
[17:47:55.126]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.126]                         fi_tmp[["mtime"]], msg)
[17:47:55.126]                       ex$message <- msg
[17:47:55.126]                       stop(ex)
[17:47:55.126]                     })
[17:47:55.126]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.126]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.126]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.126]                       fi <- file.info(pathname)
[17:47:55.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.126]                         fi[["size"]], fi[["mtime"]])
[17:47:55.126]                       stop(msg)
[17:47:55.126]                     }
[17:47:55.126]                     invisible(pathname)
[17:47:55.126]                   }
[17:47:55.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.126]                     rootPath = tempdir()) 
[17:47:55.126]                   {
[17:47:55.126]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.126]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.126]                       tmpdir = path, fileext = ".rds")
[17:47:55.126]                     save_rds(obj, file)
[17:47:55.126]                   }
[17:47:55.126]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.126]                   {
[17:47:55.126]                     inherits <- base::inherits
[17:47:55.126]                     invokeRestart <- base::invokeRestart
[17:47:55.126]                     is.null <- base::is.null
[17:47:55.126]                     muffled <- FALSE
[17:47:55.126]                     if (inherits(cond, "message")) {
[17:47:55.126]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.126]                       if (muffled) 
[17:47:55.126]                         invokeRestart("muffleMessage")
[17:47:55.126]                     }
[17:47:55.126]                     else if (inherits(cond, "warning")) {
[17:47:55.126]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.126]                       if (muffled) 
[17:47:55.126]                         invokeRestart("muffleWarning")
[17:47:55.126]                     }
[17:47:55.126]                     else if (inherits(cond, "condition")) {
[17:47:55.126]                       if (!is.null(pattern)) {
[17:47:55.126]                         computeRestarts <- base::computeRestarts
[17:47:55.126]                         grepl <- base::grepl
[17:47:55.126]                         restarts <- computeRestarts(cond)
[17:47:55.126]                         for (restart in restarts) {
[17:47:55.126]                           name <- restart$name
[17:47:55.126]                           if (is.null(name)) 
[17:47:55.126]                             next
[17:47:55.126]                           if (!grepl(pattern, name)) 
[17:47:55.126]                             next
[17:47:55.126]                           invokeRestart(restart)
[17:47:55.126]                           muffled <- TRUE
[17:47:55.126]                           break
[17:47:55.126]                         }
[17:47:55.126]                       }
[17:47:55.126]                     }
[17:47:55.126]                     invisible(muffled)
[17:47:55.126]                   }
[17:47:55.126]                   muffleCondition(cond)
[17:47:55.126]                 })
[17:47:55.126]             }))
[17:47:55.126]             future::FutureResult(value = ...future.value$value, 
[17:47:55.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.126]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.126]                     ...future.globalenv.names))
[17:47:55.126]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.126]         }, condition = base::local({
[17:47:55.126]             c <- base::c
[17:47:55.126]             inherits <- base::inherits
[17:47:55.126]             invokeRestart <- base::invokeRestart
[17:47:55.126]             length <- base::length
[17:47:55.126]             list <- base::list
[17:47:55.126]             seq.int <- base::seq.int
[17:47:55.126]             signalCondition <- base::signalCondition
[17:47:55.126]             sys.calls <- base::sys.calls
[17:47:55.126]             `[[` <- base::`[[`
[17:47:55.126]             `+` <- base::`+`
[17:47:55.126]             `<<-` <- base::`<<-`
[17:47:55.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.126]                   3L)]
[17:47:55.126]             }
[17:47:55.126]             function(cond) {
[17:47:55.126]                 is_error <- inherits(cond, "error")
[17:47:55.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.126]                   NULL)
[17:47:55.126]                 if (is_error) {
[17:47:55.126]                   sessionInformation <- function() {
[17:47:55.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.126]                       search = base::search(), system = base::Sys.info())
[17:47:55.126]                   }
[17:47:55.126]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.126]                     cond$call), session = sessionInformation(), 
[17:47:55.126]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.126]                   signalCondition(cond)
[17:47:55.126]                 }
[17:47:55.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.126]                 "immediateCondition"))) {
[17:47:55.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.126]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.126]                   if (TRUE && !signal) {
[17:47:55.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.126]                     {
[17:47:55.126]                       inherits <- base::inherits
[17:47:55.126]                       invokeRestart <- base::invokeRestart
[17:47:55.126]                       is.null <- base::is.null
[17:47:55.126]                       muffled <- FALSE
[17:47:55.126]                       if (inherits(cond, "message")) {
[17:47:55.126]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.126]                         if (muffled) 
[17:47:55.126]                           invokeRestart("muffleMessage")
[17:47:55.126]                       }
[17:47:55.126]                       else if (inherits(cond, "warning")) {
[17:47:55.126]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.126]                         if (muffled) 
[17:47:55.126]                           invokeRestart("muffleWarning")
[17:47:55.126]                       }
[17:47:55.126]                       else if (inherits(cond, "condition")) {
[17:47:55.126]                         if (!is.null(pattern)) {
[17:47:55.126]                           computeRestarts <- base::computeRestarts
[17:47:55.126]                           grepl <- base::grepl
[17:47:55.126]                           restarts <- computeRestarts(cond)
[17:47:55.126]                           for (restart in restarts) {
[17:47:55.126]                             name <- restart$name
[17:47:55.126]                             if (is.null(name)) 
[17:47:55.126]                               next
[17:47:55.126]                             if (!grepl(pattern, name)) 
[17:47:55.126]                               next
[17:47:55.126]                             invokeRestart(restart)
[17:47:55.126]                             muffled <- TRUE
[17:47:55.126]                             break
[17:47:55.126]                           }
[17:47:55.126]                         }
[17:47:55.126]                       }
[17:47:55.126]                       invisible(muffled)
[17:47:55.126]                     }
[17:47:55.126]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.126]                   }
[17:47:55.126]                 }
[17:47:55.126]                 else {
[17:47:55.126]                   if (TRUE) {
[17:47:55.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.126]                     {
[17:47:55.126]                       inherits <- base::inherits
[17:47:55.126]                       invokeRestart <- base::invokeRestart
[17:47:55.126]                       is.null <- base::is.null
[17:47:55.126]                       muffled <- FALSE
[17:47:55.126]                       if (inherits(cond, "message")) {
[17:47:55.126]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.126]                         if (muffled) 
[17:47:55.126]                           invokeRestart("muffleMessage")
[17:47:55.126]                       }
[17:47:55.126]                       else if (inherits(cond, "warning")) {
[17:47:55.126]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.126]                         if (muffled) 
[17:47:55.126]                           invokeRestart("muffleWarning")
[17:47:55.126]                       }
[17:47:55.126]                       else if (inherits(cond, "condition")) {
[17:47:55.126]                         if (!is.null(pattern)) {
[17:47:55.126]                           computeRestarts <- base::computeRestarts
[17:47:55.126]                           grepl <- base::grepl
[17:47:55.126]                           restarts <- computeRestarts(cond)
[17:47:55.126]                           for (restart in restarts) {
[17:47:55.126]                             name <- restart$name
[17:47:55.126]                             if (is.null(name)) 
[17:47:55.126]                               next
[17:47:55.126]                             if (!grepl(pattern, name)) 
[17:47:55.126]                               next
[17:47:55.126]                             invokeRestart(restart)
[17:47:55.126]                             muffled <- TRUE
[17:47:55.126]                             break
[17:47:55.126]                           }
[17:47:55.126]                         }
[17:47:55.126]                       }
[17:47:55.126]                       invisible(muffled)
[17:47:55.126]                     }
[17:47:55.126]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.126]                   }
[17:47:55.126]                 }
[17:47:55.126]             }
[17:47:55.126]         }))
[17:47:55.126]     }, error = function(ex) {
[17:47:55.126]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.126]                 ...future.rng), started = ...future.startTime, 
[17:47:55.126]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.126]             version = "1.8"), class = "FutureResult")
[17:47:55.126]     }, finally = {
[17:47:55.126]         if (!identical(...future.workdir, getwd())) 
[17:47:55.126]             setwd(...future.workdir)
[17:47:55.126]         {
[17:47:55.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.126]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.126]             }
[17:47:55.126]             base::options(...future.oldOptions)
[17:47:55.126]             if (.Platform$OS.type == "windows") {
[17:47:55.126]                 old_names <- names(...future.oldEnvVars)
[17:47:55.126]                 envs <- base::Sys.getenv()
[17:47:55.126]                 names <- names(envs)
[17:47:55.126]                 common <- intersect(names, old_names)
[17:47:55.126]                 added <- setdiff(names, old_names)
[17:47:55.126]                 removed <- setdiff(old_names, names)
[17:47:55.126]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.126]                   envs[common]]
[17:47:55.126]                 NAMES <- toupper(changed)
[17:47:55.126]                 args <- list()
[17:47:55.126]                 for (kk in seq_along(NAMES)) {
[17:47:55.126]                   name <- changed[[kk]]
[17:47:55.126]                   NAME <- NAMES[[kk]]
[17:47:55.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.126]                     next
[17:47:55.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.126]                 }
[17:47:55.126]                 NAMES <- toupper(added)
[17:47:55.126]                 for (kk in seq_along(NAMES)) {
[17:47:55.126]                   name <- added[[kk]]
[17:47:55.126]                   NAME <- NAMES[[kk]]
[17:47:55.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.126]                     next
[17:47:55.126]                   args[[name]] <- ""
[17:47:55.126]                 }
[17:47:55.126]                 NAMES <- toupper(removed)
[17:47:55.126]                 for (kk in seq_along(NAMES)) {
[17:47:55.126]                   name <- removed[[kk]]
[17:47:55.126]                   NAME <- NAMES[[kk]]
[17:47:55.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.126]                     next
[17:47:55.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.126]                 }
[17:47:55.126]                 if (length(args) > 0) 
[17:47:55.126]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.126]             }
[17:47:55.126]             else {
[17:47:55.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.126]             }
[17:47:55.126]             {
[17:47:55.126]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.126]                   0L) {
[17:47:55.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.126]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.126]                   base::options(opts)
[17:47:55.126]                 }
[17:47:55.126]                 {
[17:47:55.126]                   {
[17:47:55.126]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.126]                     NULL
[17:47:55.126]                   }
[17:47:55.126]                   options(future.plan = NULL)
[17:47:55.126]                   if (is.na(NA_character_)) 
[17:47:55.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.126]                     .init = FALSE)
[17:47:55.126]                 }
[17:47:55.126]             }
[17:47:55.126]         }
[17:47:55.126]     })
[17:47:55.126]     if (TRUE) {
[17:47:55.126]         base::sink(type = "output", split = FALSE)
[17:47:55.126]         if (TRUE) {
[17:47:55.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.126]         }
[17:47:55.126]         else {
[17:47:55.126]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.126]         }
[17:47:55.126]         base::close(...future.stdout)
[17:47:55.126]         ...future.stdout <- NULL
[17:47:55.126]     }
[17:47:55.126]     ...future.result$conditions <- ...future.conditions
[17:47:55.126]     ...future.result$finished <- base::Sys.time()
[17:47:55.126]     ...future.result
[17:47:55.126] }
[17:47:55.129] requestCore(): workers = 2
[17:47:55.129] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.140] result() for MulticoreFuture ...
[17:47:55.141] result() for MulticoreFuture ...
[17:47:55.141] result() for MulticoreFuture ... done
[17:47:55.141] result() for MulticoreFuture ... done
[17:47:55.141] result() for MulticoreFuture ...
[17:47:55.142] result() for MulticoreFuture ... done
[17:47:55.144] MulticoreFuture started
[17:47:55.145] - Launch lazy future ... done
[17:47:55.145] run() for ‘MulticoreFuture’ ... done
[17:47:55.145] plan(): Setting new future strategy stack:
[17:47:55.146] getGlobalsAndPackages() ...
[17:47:55.146] Searching for globals...
[17:47:55.145] List of future strategies:
[17:47:55.145] 1. sequential:
[17:47:55.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.145]    - tweaked: FALSE
[17:47:55.145]    - call: NULL
[17:47:55.146] plan(): nbrOfWorkers() = 1
[17:47:55.147] - globals found: [1] ‘{’
[17:47:55.147] Searching for globals ... DONE
[17:47:55.148] Resolving globals: FALSE
[17:47:55.148] 
[17:47:55.148] 
[17:47:55.148] getGlobalsAndPackages() ... DONE
[17:47:55.148] plan(): Setting new future strategy stack:
[17:47:55.149] List of future strategies:
[17:47:55.149] 1. multicore:
[17:47:55.149]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.149]    - tweaked: FALSE
[17:47:55.149]    - call: plan(strategy)
[17:47:55.154] run() for ‘Future’ ...
[17:47:55.155] - state: ‘created’
[17:47:55.155] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.158] plan(): nbrOfWorkers() = 2
[17:47:55.162] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.163]   - Field: ‘label’
[17:47:55.163]   - Field: ‘local’
[17:47:55.163]   - Field: ‘owner’
[17:47:55.163]   - Field: ‘envir’
[17:47:55.163]   - Field: ‘workers’
[17:47:55.164]   - Field: ‘packages’
[17:47:55.164]   - Field: ‘gc’
[17:47:55.164]   - Field: ‘job’
[17:47:55.164]   - Field: ‘conditions’
[17:47:55.164]   - Field: ‘expr’
[17:47:55.164]   - Field: ‘uuid’
[17:47:55.165]   - Field: ‘seed’
[17:47:55.165]   - Field: ‘version’
[17:47:55.165]   - Field: ‘result’
[17:47:55.165]   - Field: ‘asynchronous’
[17:47:55.165]   - Field: ‘calls’
[17:47:55.165]   - Field: ‘globals’
[17:47:55.166]   - Field: ‘stdout’
[17:47:55.166]   - Field: ‘earlySignal’
[17:47:55.166]   - Field: ‘lazy’
[17:47:55.166]   - Field: ‘state’
[17:47:55.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.166] - Launch lazy future ...
[17:47:55.167] Packages needed by the future expression (n = 0): <none>
[17:47:55.167] Packages needed by future strategies (n = 0): <none>
[17:47:55.168] {
[17:47:55.168]     {
[17:47:55.168]         {
[17:47:55.168]             ...future.startTime <- base::Sys.time()
[17:47:55.168]             {
[17:47:55.168]                 {
[17:47:55.168]                   {
[17:47:55.168]                     {
[17:47:55.168]                       base::local({
[17:47:55.168]                         has_future <- base::requireNamespace("future", 
[17:47:55.168]                           quietly = TRUE)
[17:47:55.168]                         if (has_future) {
[17:47:55.168]                           ns <- base::getNamespace("future")
[17:47:55.168]                           version <- ns[[".package"]][["version"]]
[17:47:55.168]                           if (is.null(version)) 
[17:47:55.168]                             version <- utils::packageVersion("future")
[17:47:55.168]                         }
[17:47:55.168]                         else {
[17:47:55.168]                           version <- NULL
[17:47:55.168]                         }
[17:47:55.168]                         if (!has_future || version < "1.8.0") {
[17:47:55.168]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.168]                             "", base::R.version$version.string), 
[17:47:55.168]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.168]                               "release", "version")], collapse = " "), 
[17:47:55.168]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.168]                             info)
[17:47:55.168]                           info <- base::paste(info, collapse = "; ")
[17:47:55.168]                           if (!has_future) {
[17:47:55.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.168]                               info)
[17:47:55.168]                           }
[17:47:55.168]                           else {
[17:47:55.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.168]                               info, version)
[17:47:55.168]                           }
[17:47:55.168]                           base::stop(msg)
[17:47:55.168]                         }
[17:47:55.168]                       })
[17:47:55.168]                     }
[17:47:55.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.168]                     base::options(mc.cores = 1L)
[17:47:55.168]                   }
[17:47:55.168]                   ...future.strategy.old <- future::plan("list")
[17:47:55.168]                   options(future.plan = NULL)
[17:47:55.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.168]                 }
[17:47:55.168]                 ...future.workdir <- getwd()
[17:47:55.168]             }
[17:47:55.168]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.168]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.168]         }
[17:47:55.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.168]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.168]             base::names(...future.oldOptions))
[17:47:55.168]     }
[17:47:55.168]     if (FALSE) {
[17:47:55.168]     }
[17:47:55.168]     else {
[17:47:55.168]         if (TRUE) {
[17:47:55.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.168]                 open = "w")
[17:47:55.168]         }
[17:47:55.168]         else {
[17:47:55.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.168]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.168]         }
[17:47:55.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.168]             base::sink(type = "output", split = FALSE)
[17:47:55.168]             base::close(...future.stdout)
[17:47:55.168]         }, add = TRUE)
[17:47:55.168]     }
[17:47:55.168]     ...future.frame <- base::sys.nframe()
[17:47:55.168]     ...future.conditions <- base::list()
[17:47:55.168]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.168]     if (FALSE) {
[17:47:55.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.168]     }
[17:47:55.168]     ...future.result <- base::tryCatch({
[17:47:55.168]         base::withCallingHandlers({
[17:47:55.168]             ...future.value <- base::withVisible(base::local({
[17:47:55.168]                 withCallingHandlers({
[17:47:55.168]                   {
[17:47:55.168]                     2
[17:47:55.168]                   }
[17:47:55.168]                 }, immediateCondition = function(cond) {
[17:47:55.168]                   save_rds <- function (object, pathname, ...) 
[17:47:55.168]                   {
[17:47:55.168]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.168]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.168]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.168]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.168]                         fi_tmp[["mtime"]])
[17:47:55.168]                     }
[17:47:55.168]                     tryCatch({
[17:47:55.168]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.168]                     }, error = function(ex) {
[17:47:55.168]                       msg <- conditionMessage(ex)
[17:47:55.168]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.168]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.168]                         fi_tmp[["mtime"]], msg)
[17:47:55.168]                       ex$message <- msg
[17:47:55.168]                       stop(ex)
[17:47:55.168]                     })
[17:47:55.168]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.168]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.168]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.168]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.168]                       fi <- file.info(pathname)
[17:47:55.168]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.168]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.168]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.168]                         fi[["size"]], fi[["mtime"]])
[17:47:55.168]                       stop(msg)
[17:47:55.168]                     }
[17:47:55.168]                     invisible(pathname)
[17:47:55.168]                   }
[17:47:55.168]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.168]                     rootPath = tempdir()) 
[17:47:55.168]                   {
[17:47:55.168]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.168]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.168]                       tmpdir = path, fileext = ".rds")
[17:47:55.168]                     save_rds(obj, file)
[17:47:55.168]                   }
[17:47:55.168]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.168]                   {
[17:47:55.168]                     inherits <- base::inherits
[17:47:55.168]                     invokeRestart <- base::invokeRestart
[17:47:55.168]                     is.null <- base::is.null
[17:47:55.168]                     muffled <- FALSE
[17:47:55.168]                     if (inherits(cond, "message")) {
[17:47:55.168]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.168]                       if (muffled) 
[17:47:55.168]                         invokeRestart("muffleMessage")
[17:47:55.168]                     }
[17:47:55.168]                     else if (inherits(cond, "warning")) {
[17:47:55.168]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.168]                       if (muffled) 
[17:47:55.168]                         invokeRestart("muffleWarning")
[17:47:55.168]                     }
[17:47:55.168]                     else if (inherits(cond, "condition")) {
[17:47:55.168]                       if (!is.null(pattern)) {
[17:47:55.168]                         computeRestarts <- base::computeRestarts
[17:47:55.168]                         grepl <- base::grepl
[17:47:55.168]                         restarts <- computeRestarts(cond)
[17:47:55.168]                         for (restart in restarts) {
[17:47:55.168]                           name <- restart$name
[17:47:55.168]                           if (is.null(name)) 
[17:47:55.168]                             next
[17:47:55.168]                           if (!grepl(pattern, name)) 
[17:47:55.168]                             next
[17:47:55.168]                           invokeRestart(restart)
[17:47:55.168]                           muffled <- TRUE
[17:47:55.168]                           break
[17:47:55.168]                         }
[17:47:55.168]                       }
[17:47:55.168]                     }
[17:47:55.168]                     invisible(muffled)
[17:47:55.168]                   }
[17:47:55.168]                   muffleCondition(cond)
[17:47:55.168]                 })
[17:47:55.168]             }))
[17:47:55.168]             future::FutureResult(value = ...future.value$value, 
[17:47:55.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.168]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.168]                     ...future.globalenv.names))
[17:47:55.168]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.168]         }, condition = base::local({
[17:47:55.168]             c <- base::c
[17:47:55.168]             inherits <- base::inherits
[17:47:55.168]             invokeRestart <- base::invokeRestart
[17:47:55.168]             length <- base::length
[17:47:55.168]             list <- base::list
[17:47:55.168]             seq.int <- base::seq.int
[17:47:55.168]             signalCondition <- base::signalCondition
[17:47:55.168]             sys.calls <- base::sys.calls
[17:47:55.168]             `[[` <- base::`[[`
[17:47:55.168]             `+` <- base::`+`
[17:47:55.168]             `<<-` <- base::`<<-`
[17:47:55.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.168]                   3L)]
[17:47:55.168]             }
[17:47:55.168]             function(cond) {
[17:47:55.168]                 is_error <- inherits(cond, "error")
[17:47:55.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.168]                   NULL)
[17:47:55.168]                 if (is_error) {
[17:47:55.168]                   sessionInformation <- function() {
[17:47:55.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.168]                       search = base::search(), system = base::Sys.info())
[17:47:55.168]                   }
[17:47:55.168]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.168]                     cond$call), session = sessionInformation(), 
[17:47:55.168]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.168]                   signalCondition(cond)
[17:47:55.168]                 }
[17:47:55.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.168]                 "immediateCondition"))) {
[17:47:55.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.168]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.168]                   if (TRUE && !signal) {
[17:47:55.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.168]                     {
[17:47:55.168]                       inherits <- base::inherits
[17:47:55.168]                       invokeRestart <- base::invokeRestart
[17:47:55.168]                       is.null <- base::is.null
[17:47:55.168]                       muffled <- FALSE
[17:47:55.168]                       if (inherits(cond, "message")) {
[17:47:55.168]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.168]                         if (muffled) 
[17:47:55.168]                           invokeRestart("muffleMessage")
[17:47:55.168]                       }
[17:47:55.168]                       else if (inherits(cond, "warning")) {
[17:47:55.168]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.168]                         if (muffled) 
[17:47:55.168]                           invokeRestart("muffleWarning")
[17:47:55.168]                       }
[17:47:55.168]                       else if (inherits(cond, "condition")) {
[17:47:55.168]                         if (!is.null(pattern)) {
[17:47:55.168]                           computeRestarts <- base::computeRestarts
[17:47:55.168]                           grepl <- base::grepl
[17:47:55.168]                           restarts <- computeRestarts(cond)
[17:47:55.168]                           for (restart in restarts) {
[17:47:55.168]                             name <- restart$name
[17:47:55.168]                             if (is.null(name)) 
[17:47:55.168]                               next
[17:47:55.168]                             if (!grepl(pattern, name)) 
[17:47:55.168]                               next
[17:47:55.168]                             invokeRestart(restart)
[17:47:55.168]                             muffled <- TRUE
[17:47:55.168]                             break
[17:47:55.168]                           }
[17:47:55.168]                         }
[17:47:55.168]                       }
[17:47:55.168]                       invisible(muffled)
[17:47:55.168]                     }
[17:47:55.168]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.168]                   }
[17:47:55.168]                 }
[17:47:55.168]                 else {
[17:47:55.168]                   if (TRUE) {
[17:47:55.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.168]                     {
[17:47:55.168]                       inherits <- base::inherits
[17:47:55.168]                       invokeRestart <- base::invokeRestart
[17:47:55.168]                       is.null <- base::is.null
[17:47:55.168]                       muffled <- FALSE
[17:47:55.168]                       if (inherits(cond, "message")) {
[17:47:55.168]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.168]                         if (muffled) 
[17:47:55.168]                           invokeRestart("muffleMessage")
[17:47:55.168]                       }
[17:47:55.168]                       else if (inherits(cond, "warning")) {
[17:47:55.168]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.168]                         if (muffled) 
[17:47:55.168]                           invokeRestart("muffleWarning")
[17:47:55.168]                       }
[17:47:55.168]                       else if (inherits(cond, "condition")) {
[17:47:55.168]                         if (!is.null(pattern)) {
[17:47:55.168]                           computeRestarts <- base::computeRestarts
[17:47:55.168]                           grepl <- base::grepl
[17:47:55.168]                           restarts <- computeRestarts(cond)
[17:47:55.168]                           for (restart in restarts) {
[17:47:55.168]                             name <- restart$name
[17:47:55.168]                             if (is.null(name)) 
[17:47:55.168]                               next
[17:47:55.168]                             if (!grepl(pattern, name)) 
[17:47:55.168]                               next
[17:47:55.168]                             invokeRestart(restart)
[17:47:55.168]                             muffled <- TRUE
[17:47:55.168]                             break
[17:47:55.168]                           }
[17:47:55.168]                         }
[17:47:55.168]                       }
[17:47:55.168]                       invisible(muffled)
[17:47:55.168]                     }
[17:47:55.168]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.168]                   }
[17:47:55.168]                 }
[17:47:55.168]             }
[17:47:55.168]         }))
[17:47:55.168]     }, error = function(ex) {
[17:47:55.168]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.168]                 ...future.rng), started = ...future.startTime, 
[17:47:55.168]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.168]             version = "1.8"), class = "FutureResult")
[17:47:55.168]     }, finally = {
[17:47:55.168]         if (!identical(...future.workdir, getwd())) 
[17:47:55.168]             setwd(...future.workdir)
[17:47:55.168]         {
[17:47:55.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.168]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.168]             }
[17:47:55.168]             base::options(...future.oldOptions)
[17:47:55.168]             if (.Platform$OS.type == "windows") {
[17:47:55.168]                 old_names <- names(...future.oldEnvVars)
[17:47:55.168]                 envs <- base::Sys.getenv()
[17:47:55.168]                 names <- names(envs)
[17:47:55.168]                 common <- intersect(names, old_names)
[17:47:55.168]                 added <- setdiff(names, old_names)
[17:47:55.168]                 removed <- setdiff(old_names, names)
[17:47:55.168]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.168]                   envs[common]]
[17:47:55.168]                 NAMES <- toupper(changed)
[17:47:55.168]                 args <- list()
[17:47:55.168]                 for (kk in seq_along(NAMES)) {
[17:47:55.168]                   name <- changed[[kk]]
[17:47:55.168]                   NAME <- NAMES[[kk]]
[17:47:55.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.168]                     next
[17:47:55.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.168]                 }
[17:47:55.168]                 NAMES <- toupper(added)
[17:47:55.168]                 for (kk in seq_along(NAMES)) {
[17:47:55.168]                   name <- added[[kk]]
[17:47:55.168]                   NAME <- NAMES[[kk]]
[17:47:55.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.168]                     next
[17:47:55.168]                   args[[name]] <- ""
[17:47:55.168]                 }
[17:47:55.168]                 NAMES <- toupper(removed)
[17:47:55.168]                 for (kk in seq_along(NAMES)) {
[17:47:55.168]                   name <- removed[[kk]]
[17:47:55.168]                   NAME <- NAMES[[kk]]
[17:47:55.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.168]                     next
[17:47:55.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.168]                 }
[17:47:55.168]                 if (length(args) > 0) 
[17:47:55.168]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.168]             }
[17:47:55.168]             else {
[17:47:55.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.168]             }
[17:47:55.168]             {
[17:47:55.168]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.168]                   0L) {
[17:47:55.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.168]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.168]                   base::options(opts)
[17:47:55.168]                 }
[17:47:55.168]                 {
[17:47:55.168]                   {
[17:47:55.168]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.168]                     NULL
[17:47:55.168]                   }
[17:47:55.168]                   options(future.plan = NULL)
[17:47:55.168]                   if (is.na(NA_character_)) 
[17:47:55.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.168]                     .init = FALSE)
[17:47:55.168]                 }
[17:47:55.168]             }
[17:47:55.168]         }
[17:47:55.168]     })
[17:47:55.168]     if (TRUE) {
[17:47:55.168]         base::sink(type = "output", split = FALSE)
[17:47:55.168]         if (TRUE) {
[17:47:55.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.168]         }
[17:47:55.168]         else {
[17:47:55.168]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.168]         }
[17:47:55.168]         base::close(...future.stdout)
[17:47:55.168]         ...future.stdout <- NULL
[17:47:55.168]     }
[17:47:55.168]     ...future.result$conditions <- ...future.conditions
[17:47:55.168]     ...future.result$finished <- base::Sys.time()
[17:47:55.168]     ...future.result
[17:47:55.168] }
[17:47:55.170] requestCore(): workers = 2
[17:47:55.171] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.181] result() for MulticoreFuture ...
[17:47:55.182] result() for MulticoreFuture ...
[17:47:55.182] result() for MulticoreFuture ... done
[17:47:55.182] result() for MulticoreFuture ... done
[17:47:55.182] result() for MulticoreFuture ...
[17:47:55.183] result() for MulticoreFuture ... done
[17:47:55.185] MulticoreFuture started
[17:47:55.185] - Launch lazy future ... done
[17:47:55.186] run() for ‘MulticoreFuture’ ... done
[17:47:55.186] plan(): Setting new future strategy stack:
[17:47:55.187] List of future strategies:
[17:47:55.187] 1. sequential:
[17:47:55.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.187]    - tweaked: FALSE
[17:47:55.187]    - call: NULL
[17:47:55.188] resolve() on environment ...
[17:47:55.188]  recursive: 0
[17:47:55.188] plan(): nbrOfWorkers() = 1
[17:47:55.189]  elements: [3] ‘a’
[17:47:55.190] Future #1
[17:47:55.190]  length: 2 (resolved future 1)
[17:47:55.191] plan(): Setting new future strategy stack:
[17:47:55.191] List of future strategies:
[17:47:55.191] 1. multicore:
[17:47:55.191]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.191]    - tweaked: FALSE
[17:47:55.191]    - call: plan(strategy)
[17:47:55.196] plan(): nbrOfWorkers() = 2
[17:47:55.196] Future #2
[17:47:55.197]  length: 1 (resolved future 2)
[17:47:55.197]  length: 0 (resolved future 3)
[17:47:55.197] resolve() on environment ... DONE
[17:47:55.198] resolve() on environment ...
[17:47:55.198]  recursive: 0
[17:47:55.199]  elements: [3] ‘b’
[17:47:55.199] Future #1
[17:47:55.199]  length: 2 (resolved future 1)
[17:47:55.200] Future #2
[17:47:55.200]  length: 1 (resolved future 2)
[17:47:55.200]  length: 0 (resolved future 3)
[17:47:55.200] resolve() on environment ... DONE
[17:47:55.201] resolve() on environment ...
[17:47:55.201]  recursive: 0
[17:47:55.202]  elements: [3] ‘c’
[17:47:55.202] Future #1
[17:47:55.202]  length: 2 (resolved future 1)
[17:47:55.202] Future #2
[17:47:55.203]  length: 1 (resolved future 2)
[17:47:55.203]  length: 0 (resolved future 3)
[17:47:55.203] resolve() on environment ... DONE
[17:47:55.204] resolve() on environment ...
[17:47:55.204]  recursive: 0
[17:47:55.204]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:47:55.205] Future #1
[17:47:55.205] result() for MulticoreFuture ...
[17:47:55.206] result() for MulticoreFuture ...
[17:47:55.206] result() for MulticoreFuture ... done
[17:47:55.206] result() for MulticoreFuture ... done
[17:47:55.206] result() for MulticoreFuture ...
[17:47:55.206] result() for MulticoreFuture ... done
[17:47:55.207]  length: 2 (resolved future 1)
[17:47:55.207] Future #2
[17:47:55.207] result() for MulticoreFuture ...
[17:47:55.208] result() for MulticoreFuture ...
[17:47:55.208] result() for MulticoreFuture ... done
[17:47:55.208] result() for MulticoreFuture ... done
[17:47:55.208] result() for MulticoreFuture ...
[17:47:55.208] result() for MulticoreFuture ... done
[17:47:55.209]  length: 1 (resolved future 2)
[17:47:55.209]  length: 0 (resolved future 3)
[17:47:55.209] resolve() on environment ... DONE
[17:47:55.210] resolve() on environment ...
[17:47:55.210]  recursive: 99
[17:47:55.211]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:47:55.211] Future #1
[17:47:55.211] result() for MulticoreFuture ...
[17:47:55.211] result() for MulticoreFuture ... done
[17:47:55.211] result() for MulticoreFuture ...
[17:47:55.211] result() for MulticoreFuture ... done
[17:47:55.212] A MulticoreFuture was resolved
[17:47:55.212]  length: 2 (resolved future 1)
[17:47:55.212] Future #2
[17:47:55.212] result() for MulticoreFuture ...
[17:47:55.212] result() for MulticoreFuture ... done
[17:47:55.212] result() for MulticoreFuture ...
[17:47:55.212] result() for MulticoreFuture ... done
[17:47:55.212] A MulticoreFuture was resolved
[17:47:55.213]  length: 1 (resolved future 2)
[17:47:55.213]  length: 0 (resolved future 3)
[17:47:55.213] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:47:55.214] resolve() on list environment ...
[17:47:55.214]  recursive: 0
[17:47:55.214]  length: 2
[17:47:55.214]  elements: ‘a’, ‘b’
[17:47:55.215]  length: 1 (resolved future 1)
[17:47:55.215]  length: 0 (resolved future 2)
[17:47:55.215] resolve() on list environment ... DONE
[17:47:55.215] getGlobalsAndPackages() ...
[17:47:55.215] Searching for globals...
[17:47:55.216] 
[17:47:55.216] Searching for globals ... DONE
[17:47:55.216] - globals: [0] <none>
[17:47:55.216] getGlobalsAndPackages() ... DONE
[17:47:55.216] run() for ‘Future’ ...
[17:47:55.216] - state: ‘created’
[17:47:55.217] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.221] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.221]   - Field: ‘label’
[17:47:55.221]   - Field: ‘local’
[17:47:55.221]   - Field: ‘owner’
[17:47:55.222]   - Field: ‘envir’
[17:47:55.224]   - Field: ‘workers’
[17:47:55.224]   - Field: ‘packages’
[17:47:55.224]   - Field: ‘gc’
[17:47:55.225]   - Field: ‘job’
[17:47:55.225]   - Field: ‘conditions’
[17:47:55.225]   - Field: ‘expr’
[17:47:55.225]   - Field: ‘uuid’
[17:47:55.225]   - Field: ‘seed’
[17:47:55.225]   - Field: ‘version’
[17:47:55.226]   - Field: ‘result’
[17:47:55.226]   - Field: ‘asynchronous’
[17:47:55.226]   - Field: ‘calls’
[17:47:55.226]   - Field: ‘globals’
[17:47:55.226]   - Field: ‘stdout’
[17:47:55.226]   - Field: ‘earlySignal’
[17:47:55.226]   - Field: ‘lazy’
[17:47:55.227]   - Field: ‘state’
[17:47:55.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.227] - Launch lazy future ...
[17:47:55.227] Packages needed by the future expression (n = 0): <none>
[17:47:55.227] Packages needed by future strategies (n = 0): <none>
[17:47:55.228] {
[17:47:55.228]     {
[17:47:55.228]         {
[17:47:55.228]             ...future.startTime <- base::Sys.time()
[17:47:55.228]             {
[17:47:55.228]                 {
[17:47:55.228]                   {
[17:47:55.228]                     {
[17:47:55.228]                       base::local({
[17:47:55.228]                         has_future <- base::requireNamespace("future", 
[17:47:55.228]                           quietly = TRUE)
[17:47:55.228]                         if (has_future) {
[17:47:55.228]                           ns <- base::getNamespace("future")
[17:47:55.228]                           version <- ns[[".package"]][["version"]]
[17:47:55.228]                           if (is.null(version)) 
[17:47:55.228]                             version <- utils::packageVersion("future")
[17:47:55.228]                         }
[17:47:55.228]                         else {
[17:47:55.228]                           version <- NULL
[17:47:55.228]                         }
[17:47:55.228]                         if (!has_future || version < "1.8.0") {
[17:47:55.228]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.228]                             "", base::R.version$version.string), 
[17:47:55.228]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.228]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.228]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.228]                               "release", "version")], collapse = " "), 
[17:47:55.228]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.228]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.228]                             info)
[17:47:55.228]                           info <- base::paste(info, collapse = "; ")
[17:47:55.228]                           if (!has_future) {
[17:47:55.228]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.228]                               info)
[17:47:55.228]                           }
[17:47:55.228]                           else {
[17:47:55.228]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.228]                               info, version)
[17:47:55.228]                           }
[17:47:55.228]                           base::stop(msg)
[17:47:55.228]                         }
[17:47:55.228]                       })
[17:47:55.228]                     }
[17:47:55.228]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.228]                     base::options(mc.cores = 1L)
[17:47:55.228]                   }
[17:47:55.228]                   ...future.strategy.old <- future::plan("list")
[17:47:55.228]                   options(future.plan = NULL)
[17:47:55.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.228]                 }
[17:47:55.228]                 ...future.workdir <- getwd()
[17:47:55.228]             }
[17:47:55.228]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.228]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.228]         }
[17:47:55.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.228]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.228]             base::names(...future.oldOptions))
[17:47:55.228]     }
[17:47:55.228]     if (FALSE) {
[17:47:55.228]     }
[17:47:55.228]     else {
[17:47:55.228]         if (TRUE) {
[17:47:55.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.228]                 open = "w")
[17:47:55.228]         }
[17:47:55.228]         else {
[17:47:55.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.228]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.228]         }
[17:47:55.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.228]             base::sink(type = "output", split = FALSE)
[17:47:55.228]             base::close(...future.stdout)
[17:47:55.228]         }, add = TRUE)
[17:47:55.228]     }
[17:47:55.228]     ...future.frame <- base::sys.nframe()
[17:47:55.228]     ...future.conditions <- base::list()
[17:47:55.228]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.228]     if (FALSE) {
[17:47:55.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.228]     }
[17:47:55.228]     ...future.result <- base::tryCatch({
[17:47:55.228]         base::withCallingHandlers({
[17:47:55.228]             ...future.value <- base::withVisible(base::local({
[17:47:55.228]                 withCallingHandlers({
[17:47:55.228]                   1
[17:47:55.228]                 }, immediateCondition = function(cond) {
[17:47:55.228]                   save_rds <- function (object, pathname, ...) 
[17:47:55.228]                   {
[17:47:55.228]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.228]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.228]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.228]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.228]                         fi_tmp[["mtime"]])
[17:47:55.228]                     }
[17:47:55.228]                     tryCatch({
[17:47:55.228]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.228]                     }, error = function(ex) {
[17:47:55.228]                       msg <- conditionMessage(ex)
[17:47:55.228]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.228]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.228]                         fi_tmp[["mtime"]], msg)
[17:47:55.228]                       ex$message <- msg
[17:47:55.228]                       stop(ex)
[17:47:55.228]                     })
[17:47:55.228]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.228]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.228]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.228]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.228]                       fi <- file.info(pathname)
[17:47:55.228]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.228]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.228]                         fi[["size"]], fi[["mtime"]])
[17:47:55.228]                       stop(msg)
[17:47:55.228]                     }
[17:47:55.228]                     invisible(pathname)
[17:47:55.228]                   }
[17:47:55.228]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.228]                     rootPath = tempdir()) 
[17:47:55.228]                   {
[17:47:55.228]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.228]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.228]                       tmpdir = path, fileext = ".rds")
[17:47:55.228]                     save_rds(obj, file)
[17:47:55.228]                   }
[17:47:55.228]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.228]                   {
[17:47:55.228]                     inherits <- base::inherits
[17:47:55.228]                     invokeRestart <- base::invokeRestart
[17:47:55.228]                     is.null <- base::is.null
[17:47:55.228]                     muffled <- FALSE
[17:47:55.228]                     if (inherits(cond, "message")) {
[17:47:55.228]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.228]                       if (muffled) 
[17:47:55.228]                         invokeRestart("muffleMessage")
[17:47:55.228]                     }
[17:47:55.228]                     else if (inherits(cond, "warning")) {
[17:47:55.228]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.228]                       if (muffled) 
[17:47:55.228]                         invokeRestart("muffleWarning")
[17:47:55.228]                     }
[17:47:55.228]                     else if (inherits(cond, "condition")) {
[17:47:55.228]                       if (!is.null(pattern)) {
[17:47:55.228]                         computeRestarts <- base::computeRestarts
[17:47:55.228]                         grepl <- base::grepl
[17:47:55.228]                         restarts <- computeRestarts(cond)
[17:47:55.228]                         for (restart in restarts) {
[17:47:55.228]                           name <- restart$name
[17:47:55.228]                           if (is.null(name)) 
[17:47:55.228]                             next
[17:47:55.228]                           if (!grepl(pattern, name)) 
[17:47:55.228]                             next
[17:47:55.228]                           invokeRestart(restart)
[17:47:55.228]                           muffled <- TRUE
[17:47:55.228]                           break
[17:47:55.228]                         }
[17:47:55.228]                       }
[17:47:55.228]                     }
[17:47:55.228]                     invisible(muffled)
[17:47:55.228]                   }
[17:47:55.228]                   muffleCondition(cond)
[17:47:55.228]                 })
[17:47:55.228]             }))
[17:47:55.228]             future::FutureResult(value = ...future.value$value, 
[17:47:55.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.228]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.228]                     ...future.globalenv.names))
[17:47:55.228]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.228]         }, condition = base::local({
[17:47:55.228]             c <- base::c
[17:47:55.228]             inherits <- base::inherits
[17:47:55.228]             invokeRestart <- base::invokeRestart
[17:47:55.228]             length <- base::length
[17:47:55.228]             list <- base::list
[17:47:55.228]             seq.int <- base::seq.int
[17:47:55.228]             signalCondition <- base::signalCondition
[17:47:55.228]             sys.calls <- base::sys.calls
[17:47:55.228]             `[[` <- base::`[[`
[17:47:55.228]             `+` <- base::`+`
[17:47:55.228]             `<<-` <- base::`<<-`
[17:47:55.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.228]                   3L)]
[17:47:55.228]             }
[17:47:55.228]             function(cond) {
[17:47:55.228]                 is_error <- inherits(cond, "error")
[17:47:55.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.228]                   NULL)
[17:47:55.228]                 if (is_error) {
[17:47:55.228]                   sessionInformation <- function() {
[17:47:55.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.228]                       search = base::search(), system = base::Sys.info())
[17:47:55.228]                   }
[17:47:55.228]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.228]                     cond$call), session = sessionInformation(), 
[17:47:55.228]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.228]                   signalCondition(cond)
[17:47:55.228]                 }
[17:47:55.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.228]                 "immediateCondition"))) {
[17:47:55.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.228]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.228]                   if (TRUE && !signal) {
[17:47:55.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.228]                     {
[17:47:55.228]                       inherits <- base::inherits
[17:47:55.228]                       invokeRestart <- base::invokeRestart
[17:47:55.228]                       is.null <- base::is.null
[17:47:55.228]                       muffled <- FALSE
[17:47:55.228]                       if (inherits(cond, "message")) {
[17:47:55.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.228]                         if (muffled) 
[17:47:55.228]                           invokeRestart("muffleMessage")
[17:47:55.228]                       }
[17:47:55.228]                       else if (inherits(cond, "warning")) {
[17:47:55.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.228]                         if (muffled) 
[17:47:55.228]                           invokeRestart("muffleWarning")
[17:47:55.228]                       }
[17:47:55.228]                       else if (inherits(cond, "condition")) {
[17:47:55.228]                         if (!is.null(pattern)) {
[17:47:55.228]                           computeRestarts <- base::computeRestarts
[17:47:55.228]                           grepl <- base::grepl
[17:47:55.228]                           restarts <- computeRestarts(cond)
[17:47:55.228]                           for (restart in restarts) {
[17:47:55.228]                             name <- restart$name
[17:47:55.228]                             if (is.null(name)) 
[17:47:55.228]                               next
[17:47:55.228]                             if (!grepl(pattern, name)) 
[17:47:55.228]                               next
[17:47:55.228]                             invokeRestart(restart)
[17:47:55.228]                             muffled <- TRUE
[17:47:55.228]                             break
[17:47:55.228]                           }
[17:47:55.228]                         }
[17:47:55.228]                       }
[17:47:55.228]                       invisible(muffled)
[17:47:55.228]                     }
[17:47:55.228]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.228]                   }
[17:47:55.228]                 }
[17:47:55.228]                 else {
[17:47:55.228]                   if (TRUE) {
[17:47:55.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.228]                     {
[17:47:55.228]                       inherits <- base::inherits
[17:47:55.228]                       invokeRestart <- base::invokeRestart
[17:47:55.228]                       is.null <- base::is.null
[17:47:55.228]                       muffled <- FALSE
[17:47:55.228]                       if (inherits(cond, "message")) {
[17:47:55.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.228]                         if (muffled) 
[17:47:55.228]                           invokeRestart("muffleMessage")
[17:47:55.228]                       }
[17:47:55.228]                       else if (inherits(cond, "warning")) {
[17:47:55.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.228]                         if (muffled) 
[17:47:55.228]                           invokeRestart("muffleWarning")
[17:47:55.228]                       }
[17:47:55.228]                       else if (inherits(cond, "condition")) {
[17:47:55.228]                         if (!is.null(pattern)) {
[17:47:55.228]                           computeRestarts <- base::computeRestarts
[17:47:55.228]                           grepl <- base::grepl
[17:47:55.228]                           restarts <- computeRestarts(cond)
[17:47:55.228]                           for (restart in restarts) {
[17:47:55.228]                             name <- restart$name
[17:47:55.228]                             if (is.null(name)) 
[17:47:55.228]                               next
[17:47:55.228]                             if (!grepl(pattern, name)) 
[17:47:55.228]                               next
[17:47:55.228]                             invokeRestart(restart)
[17:47:55.228]                             muffled <- TRUE
[17:47:55.228]                             break
[17:47:55.228]                           }
[17:47:55.228]                         }
[17:47:55.228]                       }
[17:47:55.228]                       invisible(muffled)
[17:47:55.228]                     }
[17:47:55.228]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.228]                   }
[17:47:55.228]                 }
[17:47:55.228]             }
[17:47:55.228]         }))
[17:47:55.228]     }, error = function(ex) {
[17:47:55.228]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.228]                 ...future.rng), started = ...future.startTime, 
[17:47:55.228]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.228]             version = "1.8"), class = "FutureResult")
[17:47:55.228]     }, finally = {
[17:47:55.228]         if (!identical(...future.workdir, getwd())) 
[17:47:55.228]             setwd(...future.workdir)
[17:47:55.228]         {
[17:47:55.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.228]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.228]             }
[17:47:55.228]             base::options(...future.oldOptions)
[17:47:55.228]             if (.Platform$OS.type == "windows") {
[17:47:55.228]                 old_names <- names(...future.oldEnvVars)
[17:47:55.228]                 envs <- base::Sys.getenv()
[17:47:55.228]                 names <- names(envs)
[17:47:55.228]                 common <- intersect(names, old_names)
[17:47:55.228]                 added <- setdiff(names, old_names)
[17:47:55.228]                 removed <- setdiff(old_names, names)
[17:47:55.228]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.228]                   envs[common]]
[17:47:55.228]                 NAMES <- toupper(changed)
[17:47:55.228]                 args <- list()
[17:47:55.228]                 for (kk in seq_along(NAMES)) {
[17:47:55.228]                   name <- changed[[kk]]
[17:47:55.228]                   NAME <- NAMES[[kk]]
[17:47:55.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.228]                     next
[17:47:55.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.228]                 }
[17:47:55.228]                 NAMES <- toupper(added)
[17:47:55.228]                 for (kk in seq_along(NAMES)) {
[17:47:55.228]                   name <- added[[kk]]
[17:47:55.228]                   NAME <- NAMES[[kk]]
[17:47:55.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.228]                     next
[17:47:55.228]                   args[[name]] <- ""
[17:47:55.228]                 }
[17:47:55.228]                 NAMES <- toupper(removed)
[17:47:55.228]                 for (kk in seq_along(NAMES)) {
[17:47:55.228]                   name <- removed[[kk]]
[17:47:55.228]                   NAME <- NAMES[[kk]]
[17:47:55.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.228]                     next
[17:47:55.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.228]                 }
[17:47:55.228]                 if (length(args) > 0) 
[17:47:55.228]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.228]             }
[17:47:55.228]             else {
[17:47:55.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.228]             }
[17:47:55.228]             {
[17:47:55.228]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.228]                   0L) {
[17:47:55.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.228]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.228]                   base::options(opts)
[17:47:55.228]                 }
[17:47:55.228]                 {
[17:47:55.228]                   {
[17:47:55.228]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.228]                     NULL
[17:47:55.228]                   }
[17:47:55.228]                   options(future.plan = NULL)
[17:47:55.228]                   if (is.na(NA_character_)) 
[17:47:55.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.228]                     .init = FALSE)
[17:47:55.228]                 }
[17:47:55.228]             }
[17:47:55.228]         }
[17:47:55.228]     })
[17:47:55.228]     if (TRUE) {
[17:47:55.228]         base::sink(type = "output", split = FALSE)
[17:47:55.228]         if (TRUE) {
[17:47:55.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.228]         }
[17:47:55.228]         else {
[17:47:55.228]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.228]         }
[17:47:55.228]         base::close(...future.stdout)
[17:47:55.228]         ...future.stdout <- NULL
[17:47:55.228]     }
[17:47:55.228]     ...future.result$conditions <- ...future.conditions
[17:47:55.228]     ...future.result$finished <- base::Sys.time()
[17:47:55.228]     ...future.result
[17:47:55.228] }
[17:47:55.230] requestCore(): workers = 2
[17:47:55.232] MulticoreFuture started
[17:47:55.233] - Launch lazy future ... done
[17:47:55.233] run() for ‘MulticoreFuture’ ... done
[17:47:55.234] plan(): Setting new future strategy stack:
[17:47:55.234] getGlobalsAndPackages() ...
[17:47:55.235] Searching for globals...
[17:47:55.234] List of future strategies:
[17:47:55.234] 1. sequential:
[17:47:55.234]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.234]    - tweaked: FALSE
[17:47:55.234]    - call: NULL
[17:47:55.236] 
[17:47:55.236] plan(): nbrOfWorkers() = 1
[17:47:55.236] Searching for globals ... DONE
[17:47:55.236] - globals: [0] <none>
[17:47:55.237] getGlobalsAndPackages() ... DONE
[17:47:55.237] run() for ‘Future’ ...
[17:47:55.238] - state: ‘created’
[17:47:55.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.239] plan(): Setting new future strategy stack:
[17:47:55.239] List of future strategies:
[17:47:55.239] 1. multicore:
[17:47:55.239]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.239]    - tweaked: FALSE
[17:47:55.239]    - call: plan(strategy)
[17:47:55.244] plan(): nbrOfWorkers() = 2
[17:47:55.245] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.245]   - Field: ‘label’
[17:47:55.245]   - Field: ‘local’
[17:47:55.246]   - Field: ‘owner’
[17:47:55.246]   - Field: ‘envir’
[17:47:55.246]   - Field: ‘workers’
[17:47:55.246]   - Field: ‘packages’
[17:47:55.246]   - Field: ‘gc’
[17:47:55.246]   - Field: ‘job’
[17:47:55.246]   - Field: ‘conditions’
[17:47:55.247]   - Field: ‘expr’
[17:47:55.247]   - Field: ‘uuid’
[17:47:55.247]   - Field: ‘seed’
[17:47:55.247]   - Field: ‘version’
[17:47:55.247]   - Field: ‘result’
[17:47:55.247]   - Field: ‘asynchronous’
[17:47:55.247]   - Field: ‘calls’
[17:47:55.248]   - Field: ‘globals’
[17:47:55.248]   - Field: ‘stdout’
[17:47:55.248]   - Field: ‘earlySignal’
[17:47:55.248]   - Field: ‘lazy’
[17:47:55.248]   - Field: ‘state’
[17:47:55.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.249] - Launch lazy future ...
[17:47:55.249] Packages needed by the future expression (n = 0): <none>
[17:47:55.249] Packages needed by future strategies (n = 0): <none>
[17:47:55.250] {
[17:47:55.250]     {
[17:47:55.250]         {
[17:47:55.250]             ...future.startTime <- base::Sys.time()
[17:47:55.250]             {
[17:47:55.250]                 {
[17:47:55.250]                   {
[17:47:55.250]                     {
[17:47:55.250]                       base::local({
[17:47:55.250]                         has_future <- base::requireNamespace("future", 
[17:47:55.250]                           quietly = TRUE)
[17:47:55.250]                         if (has_future) {
[17:47:55.250]                           ns <- base::getNamespace("future")
[17:47:55.250]                           version <- ns[[".package"]][["version"]]
[17:47:55.250]                           if (is.null(version)) 
[17:47:55.250]                             version <- utils::packageVersion("future")
[17:47:55.250]                         }
[17:47:55.250]                         else {
[17:47:55.250]                           version <- NULL
[17:47:55.250]                         }
[17:47:55.250]                         if (!has_future || version < "1.8.0") {
[17:47:55.250]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.250]                             "", base::R.version$version.string), 
[17:47:55.250]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.250]                               "release", "version")], collapse = " "), 
[17:47:55.250]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.250]                             info)
[17:47:55.250]                           info <- base::paste(info, collapse = "; ")
[17:47:55.250]                           if (!has_future) {
[17:47:55.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.250]                               info)
[17:47:55.250]                           }
[17:47:55.250]                           else {
[17:47:55.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.250]                               info, version)
[17:47:55.250]                           }
[17:47:55.250]                           base::stop(msg)
[17:47:55.250]                         }
[17:47:55.250]                       })
[17:47:55.250]                     }
[17:47:55.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.250]                     base::options(mc.cores = 1L)
[17:47:55.250]                   }
[17:47:55.250]                   ...future.strategy.old <- future::plan("list")
[17:47:55.250]                   options(future.plan = NULL)
[17:47:55.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.250]                 }
[17:47:55.250]                 ...future.workdir <- getwd()
[17:47:55.250]             }
[17:47:55.250]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.250]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.250]         }
[17:47:55.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.250]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.250]             base::names(...future.oldOptions))
[17:47:55.250]     }
[17:47:55.250]     if (FALSE) {
[17:47:55.250]     }
[17:47:55.250]     else {
[17:47:55.250]         if (TRUE) {
[17:47:55.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.250]                 open = "w")
[17:47:55.250]         }
[17:47:55.250]         else {
[17:47:55.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.250]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.250]         }
[17:47:55.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.250]             base::sink(type = "output", split = FALSE)
[17:47:55.250]             base::close(...future.stdout)
[17:47:55.250]         }, add = TRUE)
[17:47:55.250]     }
[17:47:55.250]     ...future.frame <- base::sys.nframe()
[17:47:55.250]     ...future.conditions <- base::list()
[17:47:55.250]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.250]     if (FALSE) {
[17:47:55.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.250]     }
[17:47:55.250]     ...future.result <- base::tryCatch({
[17:47:55.250]         base::withCallingHandlers({
[17:47:55.250]             ...future.value <- base::withVisible(base::local({
[17:47:55.250]                 withCallingHandlers({
[17:47:55.250]                   2
[17:47:55.250]                 }, immediateCondition = function(cond) {
[17:47:55.250]                   save_rds <- function (object, pathname, ...) 
[17:47:55.250]                   {
[17:47:55.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.250]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.250]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.250]                         fi_tmp[["mtime"]])
[17:47:55.250]                     }
[17:47:55.250]                     tryCatch({
[17:47:55.250]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.250]                     }, error = function(ex) {
[17:47:55.250]                       msg <- conditionMessage(ex)
[17:47:55.250]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.250]                         fi_tmp[["mtime"]], msg)
[17:47:55.250]                       ex$message <- msg
[17:47:55.250]                       stop(ex)
[17:47:55.250]                     })
[17:47:55.250]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.250]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.250]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.250]                       fi <- file.info(pathname)
[17:47:55.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.250]                         fi[["size"]], fi[["mtime"]])
[17:47:55.250]                       stop(msg)
[17:47:55.250]                     }
[17:47:55.250]                     invisible(pathname)
[17:47:55.250]                   }
[17:47:55.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.250]                     rootPath = tempdir()) 
[17:47:55.250]                   {
[17:47:55.250]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.250]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.250]                       tmpdir = path, fileext = ".rds")
[17:47:55.250]                     save_rds(obj, file)
[17:47:55.250]                   }
[17:47:55.250]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.250]                   {
[17:47:55.250]                     inherits <- base::inherits
[17:47:55.250]                     invokeRestart <- base::invokeRestart
[17:47:55.250]                     is.null <- base::is.null
[17:47:55.250]                     muffled <- FALSE
[17:47:55.250]                     if (inherits(cond, "message")) {
[17:47:55.250]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.250]                       if (muffled) 
[17:47:55.250]                         invokeRestart("muffleMessage")
[17:47:55.250]                     }
[17:47:55.250]                     else if (inherits(cond, "warning")) {
[17:47:55.250]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.250]                       if (muffled) 
[17:47:55.250]                         invokeRestart("muffleWarning")
[17:47:55.250]                     }
[17:47:55.250]                     else if (inherits(cond, "condition")) {
[17:47:55.250]                       if (!is.null(pattern)) {
[17:47:55.250]                         computeRestarts <- base::computeRestarts
[17:47:55.250]                         grepl <- base::grepl
[17:47:55.250]                         restarts <- computeRestarts(cond)
[17:47:55.250]                         for (restart in restarts) {
[17:47:55.250]                           name <- restart$name
[17:47:55.250]                           if (is.null(name)) 
[17:47:55.250]                             next
[17:47:55.250]                           if (!grepl(pattern, name)) 
[17:47:55.250]                             next
[17:47:55.250]                           invokeRestart(restart)
[17:47:55.250]                           muffled <- TRUE
[17:47:55.250]                           break
[17:47:55.250]                         }
[17:47:55.250]                       }
[17:47:55.250]                     }
[17:47:55.250]                     invisible(muffled)
[17:47:55.250]                   }
[17:47:55.250]                   muffleCondition(cond)
[17:47:55.250]                 })
[17:47:55.250]             }))
[17:47:55.250]             future::FutureResult(value = ...future.value$value, 
[17:47:55.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.250]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.250]                     ...future.globalenv.names))
[17:47:55.250]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.250]         }, condition = base::local({
[17:47:55.250]             c <- base::c
[17:47:55.250]             inherits <- base::inherits
[17:47:55.250]             invokeRestart <- base::invokeRestart
[17:47:55.250]             length <- base::length
[17:47:55.250]             list <- base::list
[17:47:55.250]             seq.int <- base::seq.int
[17:47:55.250]             signalCondition <- base::signalCondition
[17:47:55.250]             sys.calls <- base::sys.calls
[17:47:55.250]             `[[` <- base::`[[`
[17:47:55.250]             `+` <- base::`+`
[17:47:55.250]             `<<-` <- base::`<<-`
[17:47:55.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.250]                   3L)]
[17:47:55.250]             }
[17:47:55.250]             function(cond) {
[17:47:55.250]                 is_error <- inherits(cond, "error")
[17:47:55.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.250]                   NULL)
[17:47:55.250]                 if (is_error) {
[17:47:55.250]                   sessionInformation <- function() {
[17:47:55.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.250]                       search = base::search(), system = base::Sys.info())
[17:47:55.250]                   }
[17:47:55.250]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.250]                     cond$call), session = sessionInformation(), 
[17:47:55.250]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.250]                   signalCondition(cond)
[17:47:55.250]                 }
[17:47:55.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.250]                 "immediateCondition"))) {
[17:47:55.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.250]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.250]                   if (TRUE && !signal) {
[17:47:55.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.250]                     {
[17:47:55.250]                       inherits <- base::inherits
[17:47:55.250]                       invokeRestart <- base::invokeRestart
[17:47:55.250]                       is.null <- base::is.null
[17:47:55.250]                       muffled <- FALSE
[17:47:55.250]                       if (inherits(cond, "message")) {
[17:47:55.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.250]                         if (muffled) 
[17:47:55.250]                           invokeRestart("muffleMessage")
[17:47:55.250]                       }
[17:47:55.250]                       else if (inherits(cond, "warning")) {
[17:47:55.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.250]                         if (muffled) 
[17:47:55.250]                           invokeRestart("muffleWarning")
[17:47:55.250]                       }
[17:47:55.250]                       else if (inherits(cond, "condition")) {
[17:47:55.250]                         if (!is.null(pattern)) {
[17:47:55.250]                           computeRestarts <- base::computeRestarts
[17:47:55.250]                           grepl <- base::grepl
[17:47:55.250]                           restarts <- computeRestarts(cond)
[17:47:55.250]                           for (restart in restarts) {
[17:47:55.250]                             name <- restart$name
[17:47:55.250]                             if (is.null(name)) 
[17:47:55.250]                               next
[17:47:55.250]                             if (!grepl(pattern, name)) 
[17:47:55.250]                               next
[17:47:55.250]                             invokeRestart(restart)
[17:47:55.250]                             muffled <- TRUE
[17:47:55.250]                             break
[17:47:55.250]                           }
[17:47:55.250]                         }
[17:47:55.250]                       }
[17:47:55.250]                       invisible(muffled)
[17:47:55.250]                     }
[17:47:55.250]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.250]                   }
[17:47:55.250]                 }
[17:47:55.250]                 else {
[17:47:55.250]                   if (TRUE) {
[17:47:55.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.250]                     {
[17:47:55.250]                       inherits <- base::inherits
[17:47:55.250]                       invokeRestart <- base::invokeRestart
[17:47:55.250]                       is.null <- base::is.null
[17:47:55.250]                       muffled <- FALSE
[17:47:55.250]                       if (inherits(cond, "message")) {
[17:47:55.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.250]                         if (muffled) 
[17:47:55.250]                           invokeRestart("muffleMessage")
[17:47:55.250]                       }
[17:47:55.250]                       else if (inherits(cond, "warning")) {
[17:47:55.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.250]                         if (muffled) 
[17:47:55.250]                           invokeRestart("muffleWarning")
[17:47:55.250]                       }
[17:47:55.250]                       else if (inherits(cond, "condition")) {
[17:47:55.250]                         if (!is.null(pattern)) {
[17:47:55.250]                           computeRestarts <- base::computeRestarts
[17:47:55.250]                           grepl <- base::grepl
[17:47:55.250]                           restarts <- computeRestarts(cond)
[17:47:55.250]                           for (restart in restarts) {
[17:47:55.250]                             name <- restart$name
[17:47:55.250]                             if (is.null(name)) 
[17:47:55.250]                               next
[17:47:55.250]                             if (!grepl(pattern, name)) 
[17:47:55.250]                               next
[17:47:55.250]                             invokeRestart(restart)
[17:47:55.250]                             muffled <- TRUE
[17:47:55.250]                             break
[17:47:55.250]                           }
[17:47:55.250]                         }
[17:47:55.250]                       }
[17:47:55.250]                       invisible(muffled)
[17:47:55.250]                     }
[17:47:55.250]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.250]                   }
[17:47:55.250]                 }
[17:47:55.250]             }
[17:47:55.250]         }))
[17:47:55.250]     }, error = function(ex) {
[17:47:55.250]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.250]                 ...future.rng), started = ...future.startTime, 
[17:47:55.250]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.250]             version = "1.8"), class = "FutureResult")
[17:47:55.250]     }, finally = {
[17:47:55.250]         if (!identical(...future.workdir, getwd())) 
[17:47:55.250]             setwd(...future.workdir)
[17:47:55.250]         {
[17:47:55.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.250]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.250]             }
[17:47:55.250]             base::options(...future.oldOptions)
[17:47:55.250]             if (.Platform$OS.type == "windows") {
[17:47:55.250]                 old_names <- names(...future.oldEnvVars)
[17:47:55.250]                 envs <- base::Sys.getenv()
[17:47:55.250]                 names <- names(envs)
[17:47:55.250]                 common <- intersect(names, old_names)
[17:47:55.250]                 added <- setdiff(names, old_names)
[17:47:55.250]                 removed <- setdiff(old_names, names)
[17:47:55.250]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.250]                   envs[common]]
[17:47:55.250]                 NAMES <- toupper(changed)
[17:47:55.250]                 args <- list()
[17:47:55.250]                 for (kk in seq_along(NAMES)) {
[17:47:55.250]                   name <- changed[[kk]]
[17:47:55.250]                   NAME <- NAMES[[kk]]
[17:47:55.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.250]                     next
[17:47:55.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.250]                 }
[17:47:55.250]                 NAMES <- toupper(added)
[17:47:55.250]                 for (kk in seq_along(NAMES)) {
[17:47:55.250]                   name <- added[[kk]]
[17:47:55.250]                   NAME <- NAMES[[kk]]
[17:47:55.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.250]                     next
[17:47:55.250]                   args[[name]] <- ""
[17:47:55.250]                 }
[17:47:55.250]                 NAMES <- toupper(removed)
[17:47:55.250]                 for (kk in seq_along(NAMES)) {
[17:47:55.250]                   name <- removed[[kk]]
[17:47:55.250]                   NAME <- NAMES[[kk]]
[17:47:55.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.250]                     next
[17:47:55.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.250]                 }
[17:47:55.250]                 if (length(args) > 0) 
[17:47:55.250]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.250]             }
[17:47:55.250]             else {
[17:47:55.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.250]             }
[17:47:55.250]             {
[17:47:55.250]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.250]                   0L) {
[17:47:55.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.250]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.250]                   base::options(opts)
[17:47:55.250]                 }
[17:47:55.250]                 {
[17:47:55.250]                   {
[17:47:55.250]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.250]                     NULL
[17:47:55.250]                   }
[17:47:55.250]                   options(future.plan = NULL)
[17:47:55.250]                   if (is.na(NA_character_)) 
[17:47:55.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.250]                     .init = FALSE)
[17:47:55.250]                 }
[17:47:55.250]             }
[17:47:55.250]         }
[17:47:55.250]     })
[17:47:55.250]     if (TRUE) {
[17:47:55.250]         base::sink(type = "output", split = FALSE)
[17:47:55.250]         if (TRUE) {
[17:47:55.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.250]         }
[17:47:55.250]         else {
[17:47:55.250]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.250]         }
[17:47:55.250]         base::close(...future.stdout)
[17:47:55.250]         ...future.stdout <- NULL
[17:47:55.250]     }
[17:47:55.250]     ...future.result$conditions <- ...future.conditions
[17:47:55.250]     ...future.result$finished <- base::Sys.time()
[17:47:55.250]     ...future.result
[17:47:55.250] }
[17:47:55.253] requestCore(): workers = 2
[17:47:55.256] MulticoreFuture started
[17:47:55.256] - Launch lazy future ... done
[17:47:55.256] run() for ‘MulticoreFuture’ ... done
[17:47:55.257] plan(): Setting new future strategy stack:
[17:47:55.258] resolve() on list environment ...
[17:47:55.258]  recursive: 0
[17:47:55.257] List of future strategies:
[17:47:55.257] 1. sequential:
[17:47:55.257]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.257]    - tweaked: FALSE
[17:47:55.257]    - call: NULL
[17:47:55.258] plan(): nbrOfWorkers() = 1
[17:47:55.259]  length: 3
[17:47:55.259]  elements: ‘a’, ‘b’, ‘c’
[17:47:55.260] Future #1
[17:47:55.260]  length: 2 (resolved future 1)
[17:47:55.260] plan(): Setting new future strategy stack:
[17:47:55.261] List of future strategies:
[17:47:55.261] 1. multicore:
[17:47:55.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.261]    - tweaked: FALSE
[17:47:55.261]    - call: plan(strategy)
[17:47:55.266] plan(): nbrOfWorkers() = 2
[17:47:55.266] Future #2
[17:47:55.266]  length: 1 (resolved future 2)
[17:47:55.266]  length: 0 (resolved future 3)
[17:47:55.267] resolve() on list environment ... DONE
[17:47:55.268] getGlobalsAndPackages() ...
[17:47:55.268] Searching for globals...
[17:47:55.269] - globals found: [1] ‘{’
[17:47:55.269] Searching for globals ... DONE
[17:47:55.270] Resolving globals: FALSE
[17:47:55.270] 
[17:47:55.270] 
[17:47:55.270] getGlobalsAndPackages() ... DONE
[17:47:55.271] run() for ‘Future’ ...
[17:47:55.271] - state: ‘created’
[17:47:55.271] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.276] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.276]   - Field: ‘label’
[17:47:55.276]   - Field: ‘local’
[17:47:55.276]   - Field: ‘owner’
[17:47:55.277]   - Field: ‘envir’
[17:47:55.277]   - Field: ‘workers’
[17:47:55.277]   - Field: ‘packages’
[17:47:55.277]   - Field: ‘gc’
[17:47:55.277]   - Field: ‘job’
[17:47:55.277]   - Field: ‘conditions’
[17:47:55.278]   - Field: ‘expr’
[17:47:55.278]   - Field: ‘uuid’
[17:47:55.278]   - Field: ‘seed’
[17:47:55.278]   - Field: ‘version’
[17:47:55.278]   - Field: ‘result’
[17:47:55.278]   - Field: ‘asynchronous’
[17:47:55.278]   - Field: ‘calls’
[17:47:55.279]   - Field: ‘globals’
[17:47:55.279]   - Field: ‘stdout’
[17:47:55.279]   - Field: ‘earlySignal’
[17:47:55.279]   - Field: ‘lazy’
[17:47:55.279]   - Field: ‘state’
[17:47:55.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.279] - Launch lazy future ...
[17:47:55.280] Packages needed by the future expression (n = 0): <none>
[17:47:55.280] Packages needed by future strategies (n = 0): <none>
[17:47:55.281] {
[17:47:55.281]     {
[17:47:55.281]         {
[17:47:55.281]             ...future.startTime <- base::Sys.time()
[17:47:55.281]             {
[17:47:55.281]                 {
[17:47:55.281]                   {
[17:47:55.281]                     {
[17:47:55.281]                       base::local({
[17:47:55.281]                         has_future <- base::requireNamespace("future", 
[17:47:55.281]                           quietly = TRUE)
[17:47:55.281]                         if (has_future) {
[17:47:55.281]                           ns <- base::getNamespace("future")
[17:47:55.281]                           version <- ns[[".package"]][["version"]]
[17:47:55.281]                           if (is.null(version)) 
[17:47:55.281]                             version <- utils::packageVersion("future")
[17:47:55.281]                         }
[17:47:55.281]                         else {
[17:47:55.281]                           version <- NULL
[17:47:55.281]                         }
[17:47:55.281]                         if (!has_future || version < "1.8.0") {
[17:47:55.281]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.281]                             "", base::R.version$version.string), 
[17:47:55.281]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.281]                               "release", "version")], collapse = " "), 
[17:47:55.281]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.281]                             info)
[17:47:55.281]                           info <- base::paste(info, collapse = "; ")
[17:47:55.281]                           if (!has_future) {
[17:47:55.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.281]                               info)
[17:47:55.281]                           }
[17:47:55.281]                           else {
[17:47:55.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.281]                               info, version)
[17:47:55.281]                           }
[17:47:55.281]                           base::stop(msg)
[17:47:55.281]                         }
[17:47:55.281]                       })
[17:47:55.281]                     }
[17:47:55.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.281]                     base::options(mc.cores = 1L)
[17:47:55.281]                   }
[17:47:55.281]                   ...future.strategy.old <- future::plan("list")
[17:47:55.281]                   options(future.plan = NULL)
[17:47:55.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.281]                 }
[17:47:55.281]                 ...future.workdir <- getwd()
[17:47:55.281]             }
[17:47:55.281]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.281]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.281]         }
[17:47:55.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.281]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.281]             base::names(...future.oldOptions))
[17:47:55.281]     }
[17:47:55.281]     if (FALSE) {
[17:47:55.281]     }
[17:47:55.281]     else {
[17:47:55.281]         if (TRUE) {
[17:47:55.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.281]                 open = "w")
[17:47:55.281]         }
[17:47:55.281]         else {
[17:47:55.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.281]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.281]         }
[17:47:55.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.281]             base::sink(type = "output", split = FALSE)
[17:47:55.281]             base::close(...future.stdout)
[17:47:55.281]         }, add = TRUE)
[17:47:55.281]     }
[17:47:55.281]     ...future.frame <- base::sys.nframe()
[17:47:55.281]     ...future.conditions <- base::list()
[17:47:55.281]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.281]     if (FALSE) {
[17:47:55.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.281]     }
[17:47:55.281]     ...future.result <- base::tryCatch({
[17:47:55.281]         base::withCallingHandlers({
[17:47:55.281]             ...future.value <- base::withVisible(base::local({
[17:47:55.281]                 withCallingHandlers({
[17:47:55.281]                   {
[17:47:55.281]                     1
[17:47:55.281]                   }
[17:47:55.281]                 }, immediateCondition = function(cond) {
[17:47:55.281]                   save_rds <- function (object, pathname, ...) 
[17:47:55.281]                   {
[17:47:55.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.281]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.281]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.281]                         fi_tmp[["mtime"]])
[17:47:55.281]                     }
[17:47:55.281]                     tryCatch({
[17:47:55.281]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.281]                     }, error = function(ex) {
[17:47:55.281]                       msg <- conditionMessage(ex)
[17:47:55.281]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.281]                         fi_tmp[["mtime"]], msg)
[17:47:55.281]                       ex$message <- msg
[17:47:55.281]                       stop(ex)
[17:47:55.281]                     })
[17:47:55.281]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.281]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.281]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.281]                       fi <- file.info(pathname)
[17:47:55.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.281]                         fi[["size"]], fi[["mtime"]])
[17:47:55.281]                       stop(msg)
[17:47:55.281]                     }
[17:47:55.281]                     invisible(pathname)
[17:47:55.281]                   }
[17:47:55.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.281]                     rootPath = tempdir()) 
[17:47:55.281]                   {
[17:47:55.281]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.281]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.281]                       tmpdir = path, fileext = ".rds")
[17:47:55.281]                     save_rds(obj, file)
[17:47:55.281]                   }
[17:47:55.281]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.281]                   {
[17:47:55.281]                     inherits <- base::inherits
[17:47:55.281]                     invokeRestart <- base::invokeRestart
[17:47:55.281]                     is.null <- base::is.null
[17:47:55.281]                     muffled <- FALSE
[17:47:55.281]                     if (inherits(cond, "message")) {
[17:47:55.281]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.281]                       if (muffled) 
[17:47:55.281]                         invokeRestart("muffleMessage")
[17:47:55.281]                     }
[17:47:55.281]                     else if (inherits(cond, "warning")) {
[17:47:55.281]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.281]                       if (muffled) 
[17:47:55.281]                         invokeRestart("muffleWarning")
[17:47:55.281]                     }
[17:47:55.281]                     else if (inherits(cond, "condition")) {
[17:47:55.281]                       if (!is.null(pattern)) {
[17:47:55.281]                         computeRestarts <- base::computeRestarts
[17:47:55.281]                         grepl <- base::grepl
[17:47:55.281]                         restarts <- computeRestarts(cond)
[17:47:55.281]                         for (restart in restarts) {
[17:47:55.281]                           name <- restart$name
[17:47:55.281]                           if (is.null(name)) 
[17:47:55.281]                             next
[17:47:55.281]                           if (!grepl(pattern, name)) 
[17:47:55.281]                             next
[17:47:55.281]                           invokeRestart(restart)
[17:47:55.281]                           muffled <- TRUE
[17:47:55.281]                           break
[17:47:55.281]                         }
[17:47:55.281]                       }
[17:47:55.281]                     }
[17:47:55.281]                     invisible(muffled)
[17:47:55.281]                   }
[17:47:55.281]                   muffleCondition(cond)
[17:47:55.281]                 })
[17:47:55.281]             }))
[17:47:55.281]             future::FutureResult(value = ...future.value$value, 
[17:47:55.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.281]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.281]                     ...future.globalenv.names))
[17:47:55.281]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.281]         }, condition = base::local({
[17:47:55.281]             c <- base::c
[17:47:55.281]             inherits <- base::inherits
[17:47:55.281]             invokeRestart <- base::invokeRestart
[17:47:55.281]             length <- base::length
[17:47:55.281]             list <- base::list
[17:47:55.281]             seq.int <- base::seq.int
[17:47:55.281]             signalCondition <- base::signalCondition
[17:47:55.281]             sys.calls <- base::sys.calls
[17:47:55.281]             `[[` <- base::`[[`
[17:47:55.281]             `+` <- base::`+`
[17:47:55.281]             `<<-` <- base::`<<-`
[17:47:55.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.281]                   3L)]
[17:47:55.281]             }
[17:47:55.281]             function(cond) {
[17:47:55.281]                 is_error <- inherits(cond, "error")
[17:47:55.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.281]                   NULL)
[17:47:55.281]                 if (is_error) {
[17:47:55.281]                   sessionInformation <- function() {
[17:47:55.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.281]                       search = base::search(), system = base::Sys.info())
[17:47:55.281]                   }
[17:47:55.281]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.281]                     cond$call), session = sessionInformation(), 
[17:47:55.281]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.281]                   signalCondition(cond)
[17:47:55.281]                 }
[17:47:55.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.281]                 "immediateCondition"))) {
[17:47:55.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.281]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.281]                   if (TRUE && !signal) {
[17:47:55.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.281]                     {
[17:47:55.281]                       inherits <- base::inherits
[17:47:55.281]                       invokeRestart <- base::invokeRestart
[17:47:55.281]                       is.null <- base::is.null
[17:47:55.281]                       muffled <- FALSE
[17:47:55.281]                       if (inherits(cond, "message")) {
[17:47:55.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.281]                         if (muffled) 
[17:47:55.281]                           invokeRestart("muffleMessage")
[17:47:55.281]                       }
[17:47:55.281]                       else if (inherits(cond, "warning")) {
[17:47:55.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.281]                         if (muffled) 
[17:47:55.281]                           invokeRestart("muffleWarning")
[17:47:55.281]                       }
[17:47:55.281]                       else if (inherits(cond, "condition")) {
[17:47:55.281]                         if (!is.null(pattern)) {
[17:47:55.281]                           computeRestarts <- base::computeRestarts
[17:47:55.281]                           grepl <- base::grepl
[17:47:55.281]                           restarts <- computeRestarts(cond)
[17:47:55.281]                           for (restart in restarts) {
[17:47:55.281]                             name <- restart$name
[17:47:55.281]                             if (is.null(name)) 
[17:47:55.281]                               next
[17:47:55.281]                             if (!grepl(pattern, name)) 
[17:47:55.281]                               next
[17:47:55.281]                             invokeRestart(restart)
[17:47:55.281]                             muffled <- TRUE
[17:47:55.281]                             break
[17:47:55.281]                           }
[17:47:55.281]                         }
[17:47:55.281]                       }
[17:47:55.281]                       invisible(muffled)
[17:47:55.281]                     }
[17:47:55.281]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.281]                   }
[17:47:55.281]                 }
[17:47:55.281]                 else {
[17:47:55.281]                   if (TRUE) {
[17:47:55.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.281]                     {
[17:47:55.281]                       inherits <- base::inherits
[17:47:55.281]                       invokeRestart <- base::invokeRestart
[17:47:55.281]                       is.null <- base::is.null
[17:47:55.281]                       muffled <- FALSE
[17:47:55.281]                       if (inherits(cond, "message")) {
[17:47:55.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.281]                         if (muffled) 
[17:47:55.281]                           invokeRestart("muffleMessage")
[17:47:55.281]                       }
[17:47:55.281]                       else if (inherits(cond, "warning")) {
[17:47:55.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.281]                         if (muffled) 
[17:47:55.281]                           invokeRestart("muffleWarning")
[17:47:55.281]                       }
[17:47:55.281]                       else if (inherits(cond, "condition")) {
[17:47:55.281]                         if (!is.null(pattern)) {
[17:47:55.281]                           computeRestarts <- base::computeRestarts
[17:47:55.281]                           grepl <- base::grepl
[17:47:55.281]                           restarts <- computeRestarts(cond)
[17:47:55.281]                           for (restart in restarts) {
[17:47:55.281]                             name <- restart$name
[17:47:55.281]                             if (is.null(name)) 
[17:47:55.281]                               next
[17:47:55.281]                             if (!grepl(pattern, name)) 
[17:47:55.281]                               next
[17:47:55.281]                             invokeRestart(restart)
[17:47:55.281]                             muffled <- TRUE
[17:47:55.281]                             break
[17:47:55.281]                           }
[17:47:55.281]                         }
[17:47:55.281]                       }
[17:47:55.281]                       invisible(muffled)
[17:47:55.281]                     }
[17:47:55.281]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.281]                   }
[17:47:55.281]                 }
[17:47:55.281]             }
[17:47:55.281]         }))
[17:47:55.281]     }, error = function(ex) {
[17:47:55.281]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.281]                 ...future.rng), started = ...future.startTime, 
[17:47:55.281]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.281]             version = "1.8"), class = "FutureResult")
[17:47:55.281]     }, finally = {
[17:47:55.281]         if (!identical(...future.workdir, getwd())) 
[17:47:55.281]             setwd(...future.workdir)
[17:47:55.281]         {
[17:47:55.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.281]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.281]             }
[17:47:55.281]             base::options(...future.oldOptions)
[17:47:55.281]             if (.Platform$OS.type == "windows") {
[17:47:55.281]                 old_names <- names(...future.oldEnvVars)
[17:47:55.281]                 envs <- base::Sys.getenv()
[17:47:55.281]                 names <- names(envs)
[17:47:55.281]                 common <- intersect(names, old_names)
[17:47:55.281]                 added <- setdiff(names, old_names)
[17:47:55.281]                 removed <- setdiff(old_names, names)
[17:47:55.281]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.281]                   envs[common]]
[17:47:55.281]                 NAMES <- toupper(changed)
[17:47:55.281]                 args <- list()
[17:47:55.281]                 for (kk in seq_along(NAMES)) {
[17:47:55.281]                   name <- changed[[kk]]
[17:47:55.281]                   NAME <- NAMES[[kk]]
[17:47:55.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.281]                     next
[17:47:55.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.281]                 }
[17:47:55.281]                 NAMES <- toupper(added)
[17:47:55.281]                 for (kk in seq_along(NAMES)) {
[17:47:55.281]                   name <- added[[kk]]
[17:47:55.281]                   NAME <- NAMES[[kk]]
[17:47:55.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.281]                     next
[17:47:55.281]                   args[[name]] <- ""
[17:47:55.281]                 }
[17:47:55.281]                 NAMES <- toupper(removed)
[17:47:55.281]                 for (kk in seq_along(NAMES)) {
[17:47:55.281]                   name <- removed[[kk]]
[17:47:55.281]                   NAME <- NAMES[[kk]]
[17:47:55.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.281]                     next
[17:47:55.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.281]                 }
[17:47:55.281]                 if (length(args) > 0) 
[17:47:55.281]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.281]             }
[17:47:55.281]             else {
[17:47:55.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.281]             }
[17:47:55.281]             {
[17:47:55.281]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.281]                   0L) {
[17:47:55.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.281]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.281]                   base::options(opts)
[17:47:55.281]                 }
[17:47:55.281]                 {
[17:47:55.281]                   {
[17:47:55.281]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.281]                     NULL
[17:47:55.281]                   }
[17:47:55.281]                   options(future.plan = NULL)
[17:47:55.281]                   if (is.na(NA_character_)) 
[17:47:55.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.281]                     .init = FALSE)
[17:47:55.281]                 }
[17:47:55.281]             }
[17:47:55.281]         }
[17:47:55.281]     })
[17:47:55.281]     if (TRUE) {
[17:47:55.281]         base::sink(type = "output", split = FALSE)
[17:47:55.281]         if (TRUE) {
[17:47:55.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.281]         }
[17:47:55.281]         else {
[17:47:55.281]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.281]         }
[17:47:55.281]         base::close(...future.stdout)
[17:47:55.281]         ...future.stdout <- NULL
[17:47:55.281]     }
[17:47:55.281]     ...future.result$conditions <- ...future.conditions
[17:47:55.281]     ...future.result$finished <- base::Sys.time()
[17:47:55.281]     ...future.result
[17:47:55.281] }
[17:47:55.284] requestCore(): workers = 2
[17:47:55.284] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.295] result() for MulticoreFuture ...
[17:47:55.296] result() for MulticoreFuture ...
[17:47:55.296] result() for MulticoreFuture ... done
[17:47:55.296] result() for MulticoreFuture ... done
[17:47:55.297] result() for MulticoreFuture ...
[17:47:55.297] result() for MulticoreFuture ... done
[17:47:55.299] MulticoreFuture started
[17:47:55.299] - Launch lazy future ... done
[17:47:55.300] run() for ‘MulticoreFuture’ ... done
[17:47:55.300] plan(): Setting new future strategy stack:
[17:47:55.301] getGlobalsAndPackages() ...
[17:47:55.301] Searching for globals...
[17:47:55.301] List of future strategies:
[17:47:55.301] 1. sequential:
[17:47:55.301]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.301]    - tweaked: FALSE
[17:47:55.301]    - call: NULL
[17:47:55.302] plan(): nbrOfWorkers() = 1
[17:47:55.303] - globals found: [1] ‘{’
[17:47:55.303] Searching for globals ... DONE
[17:47:55.304] Resolving globals: FALSE
[17:47:55.305] 
[17:47:55.305] 
[17:47:55.305] plan(): Setting new future strategy stack:
[17:47:55.305] getGlobalsAndPackages() ... DONE
[17:47:55.305] List of future strategies:
[17:47:55.305] 1. multicore:
[17:47:55.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.305]    - tweaked: FALSE
[17:47:55.305]    - call: plan(strategy)
[17:47:55.306] run() for ‘Future’ ...
[17:47:55.306] - state: ‘created’
[17:47:55.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.316] plan(): nbrOfWorkers() = 2
[17:47:55.318] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.319]   - Field: ‘label’
[17:47:55.320]   - Field: ‘local’
[17:47:55.320]   - Field: ‘owner’
[17:47:55.320]   - Field: ‘envir’
[17:47:55.320]   - Field: ‘workers’
[17:47:55.320]   - Field: ‘packages’
[17:47:55.321]   - Field: ‘gc’
[17:47:55.321]   - Field: ‘job’
[17:47:55.321]   - Field: ‘conditions’
[17:47:55.321]   - Field: ‘expr’
[17:47:55.321]   - Field: ‘uuid’
[17:47:55.321]   - Field: ‘seed’
[17:47:55.322]   - Field: ‘version’
[17:47:55.322]   - Field: ‘result’
[17:47:55.322]   - Field: ‘asynchronous’
[17:47:55.322]   - Field: ‘calls’
[17:47:55.322]   - Field: ‘globals’
[17:47:55.322]   - Field: ‘stdout’
[17:47:55.323]   - Field: ‘earlySignal’
[17:47:55.323]   - Field: ‘lazy’
[17:47:55.323]   - Field: ‘state’
[17:47:55.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.323] - Launch lazy future ...
[17:47:55.324] Packages needed by the future expression (n = 0): <none>
[17:47:55.324] Packages needed by future strategies (n = 0): <none>
[17:47:55.325] {
[17:47:55.325]     {
[17:47:55.325]         {
[17:47:55.325]             ...future.startTime <- base::Sys.time()
[17:47:55.325]             {
[17:47:55.325]                 {
[17:47:55.325]                   {
[17:47:55.325]                     {
[17:47:55.325]                       base::local({
[17:47:55.325]                         has_future <- base::requireNamespace("future", 
[17:47:55.325]                           quietly = TRUE)
[17:47:55.325]                         if (has_future) {
[17:47:55.325]                           ns <- base::getNamespace("future")
[17:47:55.325]                           version <- ns[[".package"]][["version"]]
[17:47:55.325]                           if (is.null(version)) 
[17:47:55.325]                             version <- utils::packageVersion("future")
[17:47:55.325]                         }
[17:47:55.325]                         else {
[17:47:55.325]                           version <- NULL
[17:47:55.325]                         }
[17:47:55.325]                         if (!has_future || version < "1.8.0") {
[17:47:55.325]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.325]                             "", base::R.version$version.string), 
[17:47:55.325]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.325]                               "release", "version")], collapse = " "), 
[17:47:55.325]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.325]                             info)
[17:47:55.325]                           info <- base::paste(info, collapse = "; ")
[17:47:55.325]                           if (!has_future) {
[17:47:55.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.325]                               info)
[17:47:55.325]                           }
[17:47:55.325]                           else {
[17:47:55.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.325]                               info, version)
[17:47:55.325]                           }
[17:47:55.325]                           base::stop(msg)
[17:47:55.325]                         }
[17:47:55.325]                       })
[17:47:55.325]                     }
[17:47:55.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.325]                     base::options(mc.cores = 1L)
[17:47:55.325]                   }
[17:47:55.325]                   ...future.strategy.old <- future::plan("list")
[17:47:55.325]                   options(future.plan = NULL)
[17:47:55.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.325]                 }
[17:47:55.325]                 ...future.workdir <- getwd()
[17:47:55.325]             }
[17:47:55.325]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.325]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.325]         }
[17:47:55.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.325]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.325]             base::names(...future.oldOptions))
[17:47:55.325]     }
[17:47:55.325]     if (FALSE) {
[17:47:55.325]     }
[17:47:55.325]     else {
[17:47:55.325]         if (TRUE) {
[17:47:55.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.325]                 open = "w")
[17:47:55.325]         }
[17:47:55.325]         else {
[17:47:55.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.325]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.325]         }
[17:47:55.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.325]             base::sink(type = "output", split = FALSE)
[17:47:55.325]             base::close(...future.stdout)
[17:47:55.325]         }, add = TRUE)
[17:47:55.325]     }
[17:47:55.325]     ...future.frame <- base::sys.nframe()
[17:47:55.325]     ...future.conditions <- base::list()
[17:47:55.325]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.325]     if (FALSE) {
[17:47:55.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.325]     }
[17:47:55.325]     ...future.result <- base::tryCatch({
[17:47:55.325]         base::withCallingHandlers({
[17:47:55.325]             ...future.value <- base::withVisible(base::local({
[17:47:55.325]                 withCallingHandlers({
[17:47:55.325]                   {
[17:47:55.325]                     2
[17:47:55.325]                   }
[17:47:55.325]                 }, immediateCondition = function(cond) {
[17:47:55.325]                   save_rds <- function (object, pathname, ...) 
[17:47:55.325]                   {
[17:47:55.325]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.325]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.325]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.325]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.325]                         fi_tmp[["mtime"]])
[17:47:55.325]                     }
[17:47:55.325]                     tryCatch({
[17:47:55.325]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.325]                     }, error = function(ex) {
[17:47:55.325]                       msg <- conditionMessage(ex)
[17:47:55.325]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.325]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.325]                         fi_tmp[["mtime"]], msg)
[17:47:55.325]                       ex$message <- msg
[17:47:55.325]                       stop(ex)
[17:47:55.325]                     })
[17:47:55.325]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.325]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.325]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.325]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.325]                       fi <- file.info(pathname)
[17:47:55.325]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.325]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.325]                         fi[["size"]], fi[["mtime"]])
[17:47:55.325]                       stop(msg)
[17:47:55.325]                     }
[17:47:55.325]                     invisible(pathname)
[17:47:55.325]                   }
[17:47:55.325]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.325]                     rootPath = tempdir()) 
[17:47:55.325]                   {
[17:47:55.325]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.325]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.325]                       tmpdir = path, fileext = ".rds")
[17:47:55.325]                     save_rds(obj, file)
[17:47:55.325]                   }
[17:47:55.325]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.325]                   {
[17:47:55.325]                     inherits <- base::inherits
[17:47:55.325]                     invokeRestart <- base::invokeRestart
[17:47:55.325]                     is.null <- base::is.null
[17:47:55.325]                     muffled <- FALSE
[17:47:55.325]                     if (inherits(cond, "message")) {
[17:47:55.325]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.325]                       if (muffled) 
[17:47:55.325]                         invokeRestart("muffleMessage")
[17:47:55.325]                     }
[17:47:55.325]                     else if (inherits(cond, "warning")) {
[17:47:55.325]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.325]                       if (muffled) 
[17:47:55.325]                         invokeRestart("muffleWarning")
[17:47:55.325]                     }
[17:47:55.325]                     else if (inherits(cond, "condition")) {
[17:47:55.325]                       if (!is.null(pattern)) {
[17:47:55.325]                         computeRestarts <- base::computeRestarts
[17:47:55.325]                         grepl <- base::grepl
[17:47:55.325]                         restarts <- computeRestarts(cond)
[17:47:55.325]                         for (restart in restarts) {
[17:47:55.325]                           name <- restart$name
[17:47:55.325]                           if (is.null(name)) 
[17:47:55.325]                             next
[17:47:55.325]                           if (!grepl(pattern, name)) 
[17:47:55.325]                             next
[17:47:55.325]                           invokeRestart(restart)
[17:47:55.325]                           muffled <- TRUE
[17:47:55.325]                           break
[17:47:55.325]                         }
[17:47:55.325]                       }
[17:47:55.325]                     }
[17:47:55.325]                     invisible(muffled)
[17:47:55.325]                   }
[17:47:55.325]                   muffleCondition(cond)
[17:47:55.325]                 })
[17:47:55.325]             }))
[17:47:55.325]             future::FutureResult(value = ...future.value$value, 
[17:47:55.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.325]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.325]                     ...future.globalenv.names))
[17:47:55.325]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.325]         }, condition = base::local({
[17:47:55.325]             c <- base::c
[17:47:55.325]             inherits <- base::inherits
[17:47:55.325]             invokeRestart <- base::invokeRestart
[17:47:55.325]             length <- base::length
[17:47:55.325]             list <- base::list
[17:47:55.325]             seq.int <- base::seq.int
[17:47:55.325]             signalCondition <- base::signalCondition
[17:47:55.325]             sys.calls <- base::sys.calls
[17:47:55.325]             `[[` <- base::`[[`
[17:47:55.325]             `+` <- base::`+`
[17:47:55.325]             `<<-` <- base::`<<-`
[17:47:55.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.325]                   3L)]
[17:47:55.325]             }
[17:47:55.325]             function(cond) {
[17:47:55.325]                 is_error <- inherits(cond, "error")
[17:47:55.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.325]                   NULL)
[17:47:55.325]                 if (is_error) {
[17:47:55.325]                   sessionInformation <- function() {
[17:47:55.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.325]                       search = base::search(), system = base::Sys.info())
[17:47:55.325]                   }
[17:47:55.325]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.325]                     cond$call), session = sessionInformation(), 
[17:47:55.325]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.325]                   signalCondition(cond)
[17:47:55.325]                 }
[17:47:55.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.325]                 "immediateCondition"))) {
[17:47:55.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.325]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.325]                   if (TRUE && !signal) {
[17:47:55.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.325]                     {
[17:47:55.325]                       inherits <- base::inherits
[17:47:55.325]                       invokeRestart <- base::invokeRestart
[17:47:55.325]                       is.null <- base::is.null
[17:47:55.325]                       muffled <- FALSE
[17:47:55.325]                       if (inherits(cond, "message")) {
[17:47:55.325]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.325]                         if (muffled) 
[17:47:55.325]                           invokeRestart("muffleMessage")
[17:47:55.325]                       }
[17:47:55.325]                       else if (inherits(cond, "warning")) {
[17:47:55.325]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.325]                         if (muffled) 
[17:47:55.325]                           invokeRestart("muffleWarning")
[17:47:55.325]                       }
[17:47:55.325]                       else if (inherits(cond, "condition")) {
[17:47:55.325]                         if (!is.null(pattern)) {
[17:47:55.325]                           computeRestarts <- base::computeRestarts
[17:47:55.325]                           grepl <- base::grepl
[17:47:55.325]                           restarts <- computeRestarts(cond)
[17:47:55.325]                           for (restart in restarts) {
[17:47:55.325]                             name <- restart$name
[17:47:55.325]                             if (is.null(name)) 
[17:47:55.325]                               next
[17:47:55.325]                             if (!grepl(pattern, name)) 
[17:47:55.325]                               next
[17:47:55.325]                             invokeRestart(restart)
[17:47:55.325]                             muffled <- TRUE
[17:47:55.325]                             break
[17:47:55.325]                           }
[17:47:55.325]                         }
[17:47:55.325]                       }
[17:47:55.325]                       invisible(muffled)
[17:47:55.325]                     }
[17:47:55.325]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.325]                   }
[17:47:55.325]                 }
[17:47:55.325]                 else {
[17:47:55.325]                   if (TRUE) {
[17:47:55.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.325]                     {
[17:47:55.325]                       inherits <- base::inherits
[17:47:55.325]                       invokeRestart <- base::invokeRestart
[17:47:55.325]                       is.null <- base::is.null
[17:47:55.325]                       muffled <- FALSE
[17:47:55.325]                       if (inherits(cond, "message")) {
[17:47:55.325]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.325]                         if (muffled) 
[17:47:55.325]                           invokeRestart("muffleMessage")
[17:47:55.325]                       }
[17:47:55.325]                       else if (inherits(cond, "warning")) {
[17:47:55.325]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.325]                         if (muffled) 
[17:47:55.325]                           invokeRestart("muffleWarning")
[17:47:55.325]                       }
[17:47:55.325]                       else if (inherits(cond, "condition")) {
[17:47:55.325]                         if (!is.null(pattern)) {
[17:47:55.325]                           computeRestarts <- base::computeRestarts
[17:47:55.325]                           grepl <- base::grepl
[17:47:55.325]                           restarts <- computeRestarts(cond)
[17:47:55.325]                           for (restart in restarts) {
[17:47:55.325]                             name <- restart$name
[17:47:55.325]                             if (is.null(name)) 
[17:47:55.325]                               next
[17:47:55.325]                             if (!grepl(pattern, name)) 
[17:47:55.325]                               next
[17:47:55.325]                             invokeRestart(restart)
[17:47:55.325]                             muffled <- TRUE
[17:47:55.325]                             break
[17:47:55.325]                           }
[17:47:55.325]                         }
[17:47:55.325]                       }
[17:47:55.325]                       invisible(muffled)
[17:47:55.325]                     }
[17:47:55.325]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.325]                   }
[17:47:55.325]                 }
[17:47:55.325]             }
[17:47:55.325]         }))
[17:47:55.325]     }, error = function(ex) {
[17:47:55.325]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.325]                 ...future.rng), started = ...future.startTime, 
[17:47:55.325]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.325]             version = "1.8"), class = "FutureResult")
[17:47:55.325]     }, finally = {
[17:47:55.325]         if (!identical(...future.workdir, getwd())) 
[17:47:55.325]             setwd(...future.workdir)
[17:47:55.325]         {
[17:47:55.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.325]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.325]             }
[17:47:55.325]             base::options(...future.oldOptions)
[17:47:55.325]             if (.Platform$OS.type == "windows") {
[17:47:55.325]                 old_names <- names(...future.oldEnvVars)
[17:47:55.325]                 envs <- base::Sys.getenv()
[17:47:55.325]                 names <- names(envs)
[17:47:55.325]                 common <- intersect(names, old_names)
[17:47:55.325]                 added <- setdiff(names, old_names)
[17:47:55.325]                 removed <- setdiff(old_names, names)
[17:47:55.325]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.325]                   envs[common]]
[17:47:55.325]                 NAMES <- toupper(changed)
[17:47:55.325]                 args <- list()
[17:47:55.325]                 for (kk in seq_along(NAMES)) {
[17:47:55.325]                   name <- changed[[kk]]
[17:47:55.325]                   NAME <- NAMES[[kk]]
[17:47:55.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.325]                     next
[17:47:55.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.325]                 }
[17:47:55.325]                 NAMES <- toupper(added)
[17:47:55.325]                 for (kk in seq_along(NAMES)) {
[17:47:55.325]                   name <- added[[kk]]
[17:47:55.325]                   NAME <- NAMES[[kk]]
[17:47:55.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.325]                     next
[17:47:55.325]                   args[[name]] <- ""
[17:47:55.325]                 }
[17:47:55.325]                 NAMES <- toupper(removed)
[17:47:55.325]                 for (kk in seq_along(NAMES)) {
[17:47:55.325]                   name <- removed[[kk]]
[17:47:55.325]                   NAME <- NAMES[[kk]]
[17:47:55.325]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.325]                     next
[17:47:55.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.325]                 }
[17:47:55.325]                 if (length(args) > 0) 
[17:47:55.325]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.325]             }
[17:47:55.325]             else {
[17:47:55.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.325]             }
[17:47:55.325]             {
[17:47:55.325]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.325]                   0L) {
[17:47:55.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.325]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.325]                   base::options(opts)
[17:47:55.325]                 }
[17:47:55.325]                 {
[17:47:55.325]                   {
[17:47:55.325]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.325]                     NULL
[17:47:55.325]                   }
[17:47:55.325]                   options(future.plan = NULL)
[17:47:55.325]                   if (is.na(NA_character_)) 
[17:47:55.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.325]                     .init = FALSE)
[17:47:55.325]                 }
[17:47:55.325]             }
[17:47:55.325]         }
[17:47:55.325]     })
[17:47:55.325]     if (TRUE) {
[17:47:55.325]         base::sink(type = "output", split = FALSE)
[17:47:55.325]         if (TRUE) {
[17:47:55.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.325]         }
[17:47:55.325]         else {
[17:47:55.325]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.325]         }
[17:47:55.325]         base::close(...future.stdout)
[17:47:55.325]         ...future.stdout <- NULL
[17:47:55.325]     }
[17:47:55.325]     ...future.result$conditions <- ...future.conditions
[17:47:55.325]     ...future.result$finished <- base::Sys.time()
[17:47:55.325]     ...future.result
[17:47:55.325] }
[17:47:55.327] requestCore(): workers = 2
[17:47:55.328] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.338] result() for MulticoreFuture ...
[17:47:55.339] result() for MulticoreFuture ...
[17:47:55.339] result() for MulticoreFuture ... done
[17:47:55.339] result() for MulticoreFuture ... done
[17:47:55.340] result() for MulticoreFuture ...
[17:47:55.340] result() for MulticoreFuture ... done
[17:47:55.342] MulticoreFuture started
[17:47:55.343] - Launch lazy future ... done
[17:47:55.343] run() for ‘MulticoreFuture’ ... done
[17:47:55.343] plan(): Setting new future strategy stack:
[17:47:55.345] resolve() on list environment ...
[17:47:55.344] List of future strategies:
[17:47:55.344] 1. sequential:
[17:47:55.344]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.344]    - tweaked: FALSE
[17:47:55.344]    - call: NULL
[17:47:55.345]  recursive: 0
[17:47:55.345] plan(): nbrOfWorkers() = 1
[17:47:55.346]  length: 3
[17:47:55.347]  elements: ‘a’, ‘b’, ‘c’
[17:47:55.347] Future #1
[17:47:55.348]  length: 2 (resolved future 1)
[17:47:55.348] plan(): Setting new future strategy stack:
[17:47:55.348] List of future strategies:
[17:47:55.348] 1. multicore:
[17:47:55.348]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.348]    - tweaked: FALSE
[17:47:55.348]    - call: plan(strategy)
[17:47:55.353] plan(): nbrOfWorkers() = 2
[17:47:55.354] Future #2
[17:47:55.354]  length: 1 (resolved future 2)
[17:47:55.354]  length: 0 (resolved future 3)
[17:47:55.354] resolve() on list environment ... DONE
[17:47:55.355] getGlobalsAndPackages() ...
[17:47:55.355] Searching for globals...
[17:47:55.357] - globals found: [1] ‘{’
[17:47:55.357] Searching for globals ... DONE
[17:47:55.357] Resolving globals: FALSE
[17:47:55.358] 
[17:47:55.358] 
[17:47:55.358] getGlobalsAndPackages() ... DONE
[17:47:55.358] run() for ‘Future’ ...
[17:47:55.358] - state: ‘created’
[17:47:55.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.364]   - Field: ‘label’
[17:47:55.364]   - Field: ‘local’
[17:47:55.364]   - Field: ‘owner’
[17:47:55.364]   - Field: ‘envir’
[17:47:55.364]   - Field: ‘workers’
[17:47:55.364]   - Field: ‘packages’
[17:47:55.365]   - Field: ‘gc’
[17:47:55.365]   - Field: ‘job’
[17:47:55.365]   - Field: ‘conditions’
[17:47:55.365]   - Field: ‘expr’
[17:47:55.365]   - Field: ‘uuid’
[17:47:55.365]   - Field: ‘seed’
[17:47:55.365]   - Field: ‘version’
[17:47:55.365]   - Field: ‘result’
[17:47:55.366]   - Field: ‘asynchronous’
[17:47:55.366]   - Field: ‘calls’
[17:47:55.366]   - Field: ‘globals’
[17:47:55.366]   - Field: ‘stdout’
[17:47:55.366]   - Field: ‘earlySignal’
[17:47:55.366]   - Field: ‘lazy’
[17:47:55.366]   - Field: ‘state’
[17:47:55.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.367] - Launch lazy future ...
[17:47:55.367] Packages needed by the future expression (n = 0): <none>
[17:47:55.367] Packages needed by future strategies (n = 0): <none>
[17:47:55.368] {
[17:47:55.368]     {
[17:47:55.368]         {
[17:47:55.368]             ...future.startTime <- base::Sys.time()
[17:47:55.368]             {
[17:47:55.368]                 {
[17:47:55.368]                   {
[17:47:55.368]                     {
[17:47:55.368]                       base::local({
[17:47:55.368]                         has_future <- base::requireNamespace("future", 
[17:47:55.368]                           quietly = TRUE)
[17:47:55.368]                         if (has_future) {
[17:47:55.368]                           ns <- base::getNamespace("future")
[17:47:55.368]                           version <- ns[[".package"]][["version"]]
[17:47:55.368]                           if (is.null(version)) 
[17:47:55.368]                             version <- utils::packageVersion("future")
[17:47:55.368]                         }
[17:47:55.368]                         else {
[17:47:55.368]                           version <- NULL
[17:47:55.368]                         }
[17:47:55.368]                         if (!has_future || version < "1.8.0") {
[17:47:55.368]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.368]                             "", base::R.version$version.string), 
[17:47:55.368]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.368]                               "release", "version")], collapse = " "), 
[17:47:55.368]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.368]                             info)
[17:47:55.368]                           info <- base::paste(info, collapse = "; ")
[17:47:55.368]                           if (!has_future) {
[17:47:55.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.368]                               info)
[17:47:55.368]                           }
[17:47:55.368]                           else {
[17:47:55.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.368]                               info, version)
[17:47:55.368]                           }
[17:47:55.368]                           base::stop(msg)
[17:47:55.368]                         }
[17:47:55.368]                       })
[17:47:55.368]                     }
[17:47:55.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.368]                     base::options(mc.cores = 1L)
[17:47:55.368]                   }
[17:47:55.368]                   ...future.strategy.old <- future::plan("list")
[17:47:55.368]                   options(future.plan = NULL)
[17:47:55.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.368]                 }
[17:47:55.368]                 ...future.workdir <- getwd()
[17:47:55.368]             }
[17:47:55.368]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.368]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.368]         }
[17:47:55.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.368]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.368]             base::names(...future.oldOptions))
[17:47:55.368]     }
[17:47:55.368]     if (FALSE) {
[17:47:55.368]     }
[17:47:55.368]     else {
[17:47:55.368]         if (TRUE) {
[17:47:55.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.368]                 open = "w")
[17:47:55.368]         }
[17:47:55.368]         else {
[17:47:55.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.368]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.368]         }
[17:47:55.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.368]             base::sink(type = "output", split = FALSE)
[17:47:55.368]             base::close(...future.stdout)
[17:47:55.368]         }, add = TRUE)
[17:47:55.368]     }
[17:47:55.368]     ...future.frame <- base::sys.nframe()
[17:47:55.368]     ...future.conditions <- base::list()
[17:47:55.368]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.368]     if (FALSE) {
[17:47:55.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.368]     }
[17:47:55.368]     ...future.result <- base::tryCatch({
[17:47:55.368]         base::withCallingHandlers({
[17:47:55.368]             ...future.value <- base::withVisible(base::local({
[17:47:55.368]                 withCallingHandlers({
[17:47:55.368]                   {
[17:47:55.368]                     1
[17:47:55.368]                   }
[17:47:55.368]                 }, immediateCondition = function(cond) {
[17:47:55.368]                   save_rds <- function (object, pathname, ...) 
[17:47:55.368]                   {
[17:47:55.368]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.368]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.368]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.368]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.368]                         fi_tmp[["mtime"]])
[17:47:55.368]                     }
[17:47:55.368]                     tryCatch({
[17:47:55.368]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.368]                     }, error = function(ex) {
[17:47:55.368]                       msg <- conditionMessage(ex)
[17:47:55.368]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.368]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.368]                         fi_tmp[["mtime"]], msg)
[17:47:55.368]                       ex$message <- msg
[17:47:55.368]                       stop(ex)
[17:47:55.368]                     })
[17:47:55.368]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.368]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.368]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.368]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.368]                       fi <- file.info(pathname)
[17:47:55.368]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.368]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.368]                         fi[["size"]], fi[["mtime"]])
[17:47:55.368]                       stop(msg)
[17:47:55.368]                     }
[17:47:55.368]                     invisible(pathname)
[17:47:55.368]                   }
[17:47:55.368]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.368]                     rootPath = tempdir()) 
[17:47:55.368]                   {
[17:47:55.368]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.368]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.368]                       tmpdir = path, fileext = ".rds")
[17:47:55.368]                     save_rds(obj, file)
[17:47:55.368]                   }
[17:47:55.368]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.368]                   {
[17:47:55.368]                     inherits <- base::inherits
[17:47:55.368]                     invokeRestart <- base::invokeRestart
[17:47:55.368]                     is.null <- base::is.null
[17:47:55.368]                     muffled <- FALSE
[17:47:55.368]                     if (inherits(cond, "message")) {
[17:47:55.368]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.368]                       if (muffled) 
[17:47:55.368]                         invokeRestart("muffleMessage")
[17:47:55.368]                     }
[17:47:55.368]                     else if (inherits(cond, "warning")) {
[17:47:55.368]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.368]                       if (muffled) 
[17:47:55.368]                         invokeRestart("muffleWarning")
[17:47:55.368]                     }
[17:47:55.368]                     else if (inherits(cond, "condition")) {
[17:47:55.368]                       if (!is.null(pattern)) {
[17:47:55.368]                         computeRestarts <- base::computeRestarts
[17:47:55.368]                         grepl <- base::grepl
[17:47:55.368]                         restarts <- computeRestarts(cond)
[17:47:55.368]                         for (restart in restarts) {
[17:47:55.368]                           name <- restart$name
[17:47:55.368]                           if (is.null(name)) 
[17:47:55.368]                             next
[17:47:55.368]                           if (!grepl(pattern, name)) 
[17:47:55.368]                             next
[17:47:55.368]                           invokeRestart(restart)
[17:47:55.368]                           muffled <- TRUE
[17:47:55.368]                           break
[17:47:55.368]                         }
[17:47:55.368]                       }
[17:47:55.368]                     }
[17:47:55.368]                     invisible(muffled)
[17:47:55.368]                   }
[17:47:55.368]                   muffleCondition(cond)
[17:47:55.368]                 })
[17:47:55.368]             }))
[17:47:55.368]             future::FutureResult(value = ...future.value$value, 
[17:47:55.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.368]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.368]                     ...future.globalenv.names))
[17:47:55.368]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.368]         }, condition = base::local({
[17:47:55.368]             c <- base::c
[17:47:55.368]             inherits <- base::inherits
[17:47:55.368]             invokeRestart <- base::invokeRestart
[17:47:55.368]             length <- base::length
[17:47:55.368]             list <- base::list
[17:47:55.368]             seq.int <- base::seq.int
[17:47:55.368]             signalCondition <- base::signalCondition
[17:47:55.368]             sys.calls <- base::sys.calls
[17:47:55.368]             `[[` <- base::`[[`
[17:47:55.368]             `+` <- base::`+`
[17:47:55.368]             `<<-` <- base::`<<-`
[17:47:55.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.368]                   3L)]
[17:47:55.368]             }
[17:47:55.368]             function(cond) {
[17:47:55.368]                 is_error <- inherits(cond, "error")
[17:47:55.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.368]                   NULL)
[17:47:55.368]                 if (is_error) {
[17:47:55.368]                   sessionInformation <- function() {
[17:47:55.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.368]                       search = base::search(), system = base::Sys.info())
[17:47:55.368]                   }
[17:47:55.368]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.368]                     cond$call), session = sessionInformation(), 
[17:47:55.368]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.368]                   signalCondition(cond)
[17:47:55.368]                 }
[17:47:55.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.368]                 "immediateCondition"))) {
[17:47:55.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.368]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.368]                   if (TRUE && !signal) {
[17:47:55.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.368]                     {
[17:47:55.368]                       inherits <- base::inherits
[17:47:55.368]                       invokeRestart <- base::invokeRestart
[17:47:55.368]                       is.null <- base::is.null
[17:47:55.368]                       muffled <- FALSE
[17:47:55.368]                       if (inherits(cond, "message")) {
[17:47:55.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.368]                         if (muffled) 
[17:47:55.368]                           invokeRestart("muffleMessage")
[17:47:55.368]                       }
[17:47:55.368]                       else if (inherits(cond, "warning")) {
[17:47:55.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.368]                         if (muffled) 
[17:47:55.368]                           invokeRestart("muffleWarning")
[17:47:55.368]                       }
[17:47:55.368]                       else if (inherits(cond, "condition")) {
[17:47:55.368]                         if (!is.null(pattern)) {
[17:47:55.368]                           computeRestarts <- base::computeRestarts
[17:47:55.368]                           grepl <- base::grepl
[17:47:55.368]                           restarts <- computeRestarts(cond)
[17:47:55.368]                           for (restart in restarts) {
[17:47:55.368]                             name <- restart$name
[17:47:55.368]                             if (is.null(name)) 
[17:47:55.368]                               next
[17:47:55.368]                             if (!grepl(pattern, name)) 
[17:47:55.368]                               next
[17:47:55.368]                             invokeRestart(restart)
[17:47:55.368]                             muffled <- TRUE
[17:47:55.368]                             break
[17:47:55.368]                           }
[17:47:55.368]                         }
[17:47:55.368]                       }
[17:47:55.368]                       invisible(muffled)
[17:47:55.368]                     }
[17:47:55.368]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.368]                   }
[17:47:55.368]                 }
[17:47:55.368]                 else {
[17:47:55.368]                   if (TRUE) {
[17:47:55.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.368]                     {
[17:47:55.368]                       inherits <- base::inherits
[17:47:55.368]                       invokeRestart <- base::invokeRestart
[17:47:55.368]                       is.null <- base::is.null
[17:47:55.368]                       muffled <- FALSE
[17:47:55.368]                       if (inherits(cond, "message")) {
[17:47:55.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.368]                         if (muffled) 
[17:47:55.368]                           invokeRestart("muffleMessage")
[17:47:55.368]                       }
[17:47:55.368]                       else if (inherits(cond, "warning")) {
[17:47:55.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.368]                         if (muffled) 
[17:47:55.368]                           invokeRestart("muffleWarning")
[17:47:55.368]                       }
[17:47:55.368]                       else if (inherits(cond, "condition")) {
[17:47:55.368]                         if (!is.null(pattern)) {
[17:47:55.368]                           computeRestarts <- base::computeRestarts
[17:47:55.368]                           grepl <- base::grepl
[17:47:55.368]                           restarts <- computeRestarts(cond)
[17:47:55.368]                           for (restart in restarts) {
[17:47:55.368]                             name <- restart$name
[17:47:55.368]                             if (is.null(name)) 
[17:47:55.368]                               next
[17:47:55.368]                             if (!grepl(pattern, name)) 
[17:47:55.368]                               next
[17:47:55.368]                             invokeRestart(restart)
[17:47:55.368]                             muffled <- TRUE
[17:47:55.368]                             break
[17:47:55.368]                           }
[17:47:55.368]                         }
[17:47:55.368]                       }
[17:47:55.368]                       invisible(muffled)
[17:47:55.368]                     }
[17:47:55.368]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.368]                   }
[17:47:55.368]                 }
[17:47:55.368]             }
[17:47:55.368]         }))
[17:47:55.368]     }, error = function(ex) {
[17:47:55.368]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.368]                 ...future.rng), started = ...future.startTime, 
[17:47:55.368]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.368]             version = "1.8"), class = "FutureResult")
[17:47:55.368]     }, finally = {
[17:47:55.368]         if (!identical(...future.workdir, getwd())) 
[17:47:55.368]             setwd(...future.workdir)
[17:47:55.368]         {
[17:47:55.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.368]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.368]             }
[17:47:55.368]             base::options(...future.oldOptions)
[17:47:55.368]             if (.Platform$OS.type == "windows") {
[17:47:55.368]                 old_names <- names(...future.oldEnvVars)
[17:47:55.368]                 envs <- base::Sys.getenv()
[17:47:55.368]                 names <- names(envs)
[17:47:55.368]                 common <- intersect(names, old_names)
[17:47:55.368]                 added <- setdiff(names, old_names)
[17:47:55.368]                 removed <- setdiff(old_names, names)
[17:47:55.368]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.368]                   envs[common]]
[17:47:55.368]                 NAMES <- toupper(changed)
[17:47:55.368]                 args <- list()
[17:47:55.368]                 for (kk in seq_along(NAMES)) {
[17:47:55.368]                   name <- changed[[kk]]
[17:47:55.368]                   NAME <- NAMES[[kk]]
[17:47:55.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.368]                     next
[17:47:55.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.368]                 }
[17:47:55.368]                 NAMES <- toupper(added)
[17:47:55.368]                 for (kk in seq_along(NAMES)) {
[17:47:55.368]                   name <- added[[kk]]
[17:47:55.368]                   NAME <- NAMES[[kk]]
[17:47:55.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.368]                     next
[17:47:55.368]                   args[[name]] <- ""
[17:47:55.368]                 }
[17:47:55.368]                 NAMES <- toupper(removed)
[17:47:55.368]                 for (kk in seq_along(NAMES)) {
[17:47:55.368]                   name <- removed[[kk]]
[17:47:55.368]                   NAME <- NAMES[[kk]]
[17:47:55.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.368]                     next
[17:47:55.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.368]                 }
[17:47:55.368]                 if (length(args) > 0) 
[17:47:55.368]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.368]             }
[17:47:55.368]             else {
[17:47:55.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.368]             }
[17:47:55.368]             {
[17:47:55.368]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.368]                   0L) {
[17:47:55.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.368]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.368]                   base::options(opts)
[17:47:55.368]                 }
[17:47:55.368]                 {
[17:47:55.368]                   {
[17:47:55.368]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.368]                     NULL
[17:47:55.368]                   }
[17:47:55.368]                   options(future.plan = NULL)
[17:47:55.368]                   if (is.na(NA_character_)) 
[17:47:55.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.368]                     .init = FALSE)
[17:47:55.368]                 }
[17:47:55.368]             }
[17:47:55.368]         }
[17:47:55.368]     })
[17:47:55.368]     if (TRUE) {
[17:47:55.368]         base::sink(type = "output", split = FALSE)
[17:47:55.368]         if (TRUE) {
[17:47:55.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.368]         }
[17:47:55.368]         else {
[17:47:55.368]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.368]         }
[17:47:55.368]         base::close(...future.stdout)
[17:47:55.368]         ...future.stdout <- NULL
[17:47:55.368]     }
[17:47:55.368]     ...future.result$conditions <- ...future.conditions
[17:47:55.368]     ...future.result$finished <- base::Sys.time()
[17:47:55.368]     ...future.result
[17:47:55.368] }
[17:47:55.372] requestCore(): workers = 2
[17:47:55.372] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.383] result() for MulticoreFuture ...
[17:47:55.384] result() for MulticoreFuture ...
[17:47:55.384] result() for MulticoreFuture ... done
[17:47:55.384] result() for MulticoreFuture ... done
[17:47:55.384] result() for MulticoreFuture ...
[17:47:55.384] result() for MulticoreFuture ... done
[17:47:55.386] MulticoreFuture started
[17:47:55.387] - Launch lazy future ... done
[17:47:55.387] run() for ‘MulticoreFuture’ ... done
[17:47:55.388] plan(): Setting new future strategy stack:
[17:47:55.389] getGlobalsAndPackages() ...
[17:47:55.389] Searching for globals...
[17:47:55.388] List of future strategies:
[17:47:55.388] 1. sequential:
[17:47:55.388]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.388]    - tweaked: FALSE
[17:47:55.388]    - call: NULL
[17:47:55.390] plan(): nbrOfWorkers() = 1
[17:47:55.392] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:47:55.392] Searching for globals ... DONE
[17:47:55.392] Resolving globals: FALSE
[17:47:55.392] plan(): Setting new future strategy stack:
[17:47:55.393] 
[17:47:55.393] 
[17:47:55.393] List of future strategies:
[17:47:55.393] 1. multicore:
[17:47:55.393]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.393]    - tweaked: FALSE
[17:47:55.393]    - call: plan(strategy)
[17:47:55.393] getGlobalsAndPackages() ... DONE
[17:47:55.394] run() for ‘Future’ ...
[17:47:55.394] - state: ‘created’
[17:47:55.395] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.399] plan(): nbrOfWorkers() = 2
[17:47:55.400] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.400]   - Field: ‘label’
[17:47:55.400]   - Field: ‘local’
[17:47:55.400]   - Field: ‘owner’
[17:47:55.401]   - Field: ‘envir’
[17:47:55.401]   - Field: ‘workers’
[17:47:55.401]   - Field: ‘packages’
[17:47:55.401]   - Field: ‘gc’
[17:47:55.401]   - Field: ‘job’
[17:47:55.401]   - Field: ‘conditions’
[17:47:55.401]   - Field: ‘expr’
[17:47:55.402]   - Field: ‘uuid’
[17:47:55.402]   - Field: ‘seed’
[17:47:55.402]   - Field: ‘version’
[17:47:55.402]   - Field: ‘result’
[17:47:55.402]   - Field: ‘asynchronous’
[17:47:55.402]   - Field: ‘calls’
[17:47:55.402]   - Field: ‘globals’
[17:47:55.403]   - Field: ‘stdout’
[17:47:55.407]   - Field: ‘earlySignal’
[17:47:55.407]   - Field: ‘lazy’
[17:47:55.407]   - Field: ‘state’
[17:47:55.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.408] - Launch lazy future ...
[17:47:55.409] Packages needed by the future expression (n = 0): <none>
[17:47:55.409] Packages needed by future strategies (n = 0): <none>
[17:47:55.411] {
[17:47:55.411]     {
[17:47:55.411]         {
[17:47:55.411]             ...future.startTime <- base::Sys.time()
[17:47:55.411]             {
[17:47:55.411]                 {
[17:47:55.411]                   {
[17:47:55.411]                     {
[17:47:55.411]                       base::local({
[17:47:55.411]                         has_future <- base::requireNamespace("future", 
[17:47:55.411]                           quietly = TRUE)
[17:47:55.411]                         if (has_future) {
[17:47:55.411]                           ns <- base::getNamespace("future")
[17:47:55.411]                           version <- ns[[".package"]][["version"]]
[17:47:55.411]                           if (is.null(version)) 
[17:47:55.411]                             version <- utils::packageVersion("future")
[17:47:55.411]                         }
[17:47:55.411]                         else {
[17:47:55.411]                           version <- NULL
[17:47:55.411]                         }
[17:47:55.411]                         if (!has_future || version < "1.8.0") {
[17:47:55.411]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.411]                             "", base::R.version$version.string), 
[17:47:55.411]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.411]                               "release", "version")], collapse = " "), 
[17:47:55.411]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.411]                             info)
[17:47:55.411]                           info <- base::paste(info, collapse = "; ")
[17:47:55.411]                           if (!has_future) {
[17:47:55.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.411]                               info)
[17:47:55.411]                           }
[17:47:55.411]                           else {
[17:47:55.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.411]                               info, version)
[17:47:55.411]                           }
[17:47:55.411]                           base::stop(msg)
[17:47:55.411]                         }
[17:47:55.411]                       })
[17:47:55.411]                     }
[17:47:55.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.411]                     base::options(mc.cores = 1L)
[17:47:55.411]                   }
[17:47:55.411]                   ...future.strategy.old <- future::plan("list")
[17:47:55.411]                   options(future.plan = NULL)
[17:47:55.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.411]                 }
[17:47:55.411]                 ...future.workdir <- getwd()
[17:47:55.411]             }
[17:47:55.411]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.411]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.411]         }
[17:47:55.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.411]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.411]             base::names(...future.oldOptions))
[17:47:55.411]     }
[17:47:55.411]     if (FALSE) {
[17:47:55.411]     }
[17:47:55.411]     else {
[17:47:55.411]         if (TRUE) {
[17:47:55.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.411]                 open = "w")
[17:47:55.411]         }
[17:47:55.411]         else {
[17:47:55.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.411]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.411]         }
[17:47:55.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.411]             base::sink(type = "output", split = FALSE)
[17:47:55.411]             base::close(...future.stdout)
[17:47:55.411]         }, add = TRUE)
[17:47:55.411]     }
[17:47:55.411]     ...future.frame <- base::sys.nframe()
[17:47:55.411]     ...future.conditions <- base::list()
[17:47:55.411]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.411]     if (FALSE) {
[17:47:55.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.411]     }
[17:47:55.411]     ...future.result <- base::tryCatch({
[17:47:55.411]         base::withCallingHandlers({
[17:47:55.411]             ...future.value <- base::withVisible(base::local({
[17:47:55.411]                 withCallingHandlers({
[17:47:55.411]                   {
[17:47:55.411]                     Sys.sleep(0.5)
[17:47:55.411]                     2
[17:47:55.411]                   }
[17:47:55.411]                 }, immediateCondition = function(cond) {
[17:47:55.411]                   save_rds <- function (object, pathname, ...) 
[17:47:55.411]                   {
[17:47:55.411]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.411]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.411]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.411]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.411]                         fi_tmp[["mtime"]])
[17:47:55.411]                     }
[17:47:55.411]                     tryCatch({
[17:47:55.411]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.411]                     }, error = function(ex) {
[17:47:55.411]                       msg <- conditionMessage(ex)
[17:47:55.411]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.411]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.411]                         fi_tmp[["mtime"]], msg)
[17:47:55.411]                       ex$message <- msg
[17:47:55.411]                       stop(ex)
[17:47:55.411]                     })
[17:47:55.411]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.411]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.411]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.411]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.411]                       fi <- file.info(pathname)
[17:47:55.411]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.411]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.411]                         fi[["size"]], fi[["mtime"]])
[17:47:55.411]                       stop(msg)
[17:47:55.411]                     }
[17:47:55.411]                     invisible(pathname)
[17:47:55.411]                   }
[17:47:55.411]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.411]                     rootPath = tempdir()) 
[17:47:55.411]                   {
[17:47:55.411]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.411]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.411]                       tmpdir = path, fileext = ".rds")
[17:47:55.411]                     save_rds(obj, file)
[17:47:55.411]                   }
[17:47:55.411]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.411]                   {
[17:47:55.411]                     inherits <- base::inherits
[17:47:55.411]                     invokeRestart <- base::invokeRestart
[17:47:55.411]                     is.null <- base::is.null
[17:47:55.411]                     muffled <- FALSE
[17:47:55.411]                     if (inherits(cond, "message")) {
[17:47:55.411]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.411]                       if (muffled) 
[17:47:55.411]                         invokeRestart("muffleMessage")
[17:47:55.411]                     }
[17:47:55.411]                     else if (inherits(cond, "warning")) {
[17:47:55.411]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.411]                       if (muffled) 
[17:47:55.411]                         invokeRestart("muffleWarning")
[17:47:55.411]                     }
[17:47:55.411]                     else if (inherits(cond, "condition")) {
[17:47:55.411]                       if (!is.null(pattern)) {
[17:47:55.411]                         computeRestarts <- base::computeRestarts
[17:47:55.411]                         grepl <- base::grepl
[17:47:55.411]                         restarts <- computeRestarts(cond)
[17:47:55.411]                         for (restart in restarts) {
[17:47:55.411]                           name <- restart$name
[17:47:55.411]                           if (is.null(name)) 
[17:47:55.411]                             next
[17:47:55.411]                           if (!grepl(pattern, name)) 
[17:47:55.411]                             next
[17:47:55.411]                           invokeRestart(restart)
[17:47:55.411]                           muffled <- TRUE
[17:47:55.411]                           break
[17:47:55.411]                         }
[17:47:55.411]                       }
[17:47:55.411]                     }
[17:47:55.411]                     invisible(muffled)
[17:47:55.411]                   }
[17:47:55.411]                   muffleCondition(cond)
[17:47:55.411]                 })
[17:47:55.411]             }))
[17:47:55.411]             future::FutureResult(value = ...future.value$value, 
[17:47:55.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.411]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.411]                     ...future.globalenv.names))
[17:47:55.411]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.411]         }, condition = base::local({
[17:47:55.411]             c <- base::c
[17:47:55.411]             inherits <- base::inherits
[17:47:55.411]             invokeRestart <- base::invokeRestart
[17:47:55.411]             length <- base::length
[17:47:55.411]             list <- base::list
[17:47:55.411]             seq.int <- base::seq.int
[17:47:55.411]             signalCondition <- base::signalCondition
[17:47:55.411]             sys.calls <- base::sys.calls
[17:47:55.411]             `[[` <- base::`[[`
[17:47:55.411]             `+` <- base::`+`
[17:47:55.411]             `<<-` <- base::`<<-`
[17:47:55.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.411]                   3L)]
[17:47:55.411]             }
[17:47:55.411]             function(cond) {
[17:47:55.411]                 is_error <- inherits(cond, "error")
[17:47:55.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.411]                   NULL)
[17:47:55.411]                 if (is_error) {
[17:47:55.411]                   sessionInformation <- function() {
[17:47:55.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.411]                       search = base::search(), system = base::Sys.info())
[17:47:55.411]                   }
[17:47:55.411]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.411]                     cond$call), session = sessionInformation(), 
[17:47:55.411]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.411]                   signalCondition(cond)
[17:47:55.411]                 }
[17:47:55.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.411]                 "immediateCondition"))) {
[17:47:55.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.411]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.411]                   if (TRUE && !signal) {
[17:47:55.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.411]                     {
[17:47:55.411]                       inherits <- base::inherits
[17:47:55.411]                       invokeRestart <- base::invokeRestart
[17:47:55.411]                       is.null <- base::is.null
[17:47:55.411]                       muffled <- FALSE
[17:47:55.411]                       if (inherits(cond, "message")) {
[17:47:55.411]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.411]                         if (muffled) 
[17:47:55.411]                           invokeRestart("muffleMessage")
[17:47:55.411]                       }
[17:47:55.411]                       else if (inherits(cond, "warning")) {
[17:47:55.411]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.411]                         if (muffled) 
[17:47:55.411]                           invokeRestart("muffleWarning")
[17:47:55.411]                       }
[17:47:55.411]                       else if (inherits(cond, "condition")) {
[17:47:55.411]                         if (!is.null(pattern)) {
[17:47:55.411]                           computeRestarts <- base::computeRestarts
[17:47:55.411]                           grepl <- base::grepl
[17:47:55.411]                           restarts <- computeRestarts(cond)
[17:47:55.411]                           for (restart in restarts) {
[17:47:55.411]                             name <- restart$name
[17:47:55.411]                             if (is.null(name)) 
[17:47:55.411]                               next
[17:47:55.411]                             if (!grepl(pattern, name)) 
[17:47:55.411]                               next
[17:47:55.411]                             invokeRestart(restart)
[17:47:55.411]                             muffled <- TRUE
[17:47:55.411]                             break
[17:47:55.411]                           }
[17:47:55.411]                         }
[17:47:55.411]                       }
[17:47:55.411]                       invisible(muffled)
[17:47:55.411]                     }
[17:47:55.411]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.411]                   }
[17:47:55.411]                 }
[17:47:55.411]                 else {
[17:47:55.411]                   if (TRUE) {
[17:47:55.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.411]                     {
[17:47:55.411]                       inherits <- base::inherits
[17:47:55.411]                       invokeRestart <- base::invokeRestart
[17:47:55.411]                       is.null <- base::is.null
[17:47:55.411]                       muffled <- FALSE
[17:47:55.411]                       if (inherits(cond, "message")) {
[17:47:55.411]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.411]                         if (muffled) 
[17:47:55.411]                           invokeRestart("muffleMessage")
[17:47:55.411]                       }
[17:47:55.411]                       else if (inherits(cond, "warning")) {
[17:47:55.411]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.411]                         if (muffled) 
[17:47:55.411]                           invokeRestart("muffleWarning")
[17:47:55.411]                       }
[17:47:55.411]                       else if (inherits(cond, "condition")) {
[17:47:55.411]                         if (!is.null(pattern)) {
[17:47:55.411]                           computeRestarts <- base::computeRestarts
[17:47:55.411]                           grepl <- base::grepl
[17:47:55.411]                           restarts <- computeRestarts(cond)
[17:47:55.411]                           for (restart in restarts) {
[17:47:55.411]                             name <- restart$name
[17:47:55.411]                             if (is.null(name)) 
[17:47:55.411]                               next
[17:47:55.411]                             if (!grepl(pattern, name)) 
[17:47:55.411]                               next
[17:47:55.411]                             invokeRestart(restart)
[17:47:55.411]                             muffled <- TRUE
[17:47:55.411]                             break
[17:47:55.411]                           }
[17:47:55.411]                         }
[17:47:55.411]                       }
[17:47:55.411]                       invisible(muffled)
[17:47:55.411]                     }
[17:47:55.411]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.411]                   }
[17:47:55.411]                 }
[17:47:55.411]             }
[17:47:55.411]         }))
[17:47:55.411]     }, error = function(ex) {
[17:47:55.411]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.411]                 ...future.rng), started = ...future.startTime, 
[17:47:55.411]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.411]             version = "1.8"), class = "FutureResult")
[17:47:55.411]     }, finally = {
[17:47:55.411]         if (!identical(...future.workdir, getwd())) 
[17:47:55.411]             setwd(...future.workdir)
[17:47:55.411]         {
[17:47:55.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.411]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.411]             }
[17:47:55.411]             base::options(...future.oldOptions)
[17:47:55.411]             if (.Platform$OS.type == "windows") {
[17:47:55.411]                 old_names <- names(...future.oldEnvVars)
[17:47:55.411]                 envs <- base::Sys.getenv()
[17:47:55.411]                 names <- names(envs)
[17:47:55.411]                 common <- intersect(names, old_names)
[17:47:55.411]                 added <- setdiff(names, old_names)
[17:47:55.411]                 removed <- setdiff(old_names, names)
[17:47:55.411]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.411]                   envs[common]]
[17:47:55.411]                 NAMES <- toupper(changed)
[17:47:55.411]                 args <- list()
[17:47:55.411]                 for (kk in seq_along(NAMES)) {
[17:47:55.411]                   name <- changed[[kk]]
[17:47:55.411]                   NAME <- NAMES[[kk]]
[17:47:55.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.411]                     next
[17:47:55.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.411]                 }
[17:47:55.411]                 NAMES <- toupper(added)
[17:47:55.411]                 for (kk in seq_along(NAMES)) {
[17:47:55.411]                   name <- added[[kk]]
[17:47:55.411]                   NAME <- NAMES[[kk]]
[17:47:55.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.411]                     next
[17:47:55.411]                   args[[name]] <- ""
[17:47:55.411]                 }
[17:47:55.411]                 NAMES <- toupper(removed)
[17:47:55.411]                 for (kk in seq_along(NAMES)) {
[17:47:55.411]                   name <- removed[[kk]]
[17:47:55.411]                   NAME <- NAMES[[kk]]
[17:47:55.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.411]                     next
[17:47:55.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.411]                 }
[17:47:55.411]                 if (length(args) > 0) 
[17:47:55.411]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.411]             }
[17:47:55.411]             else {
[17:47:55.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.411]             }
[17:47:55.411]             {
[17:47:55.411]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.411]                   0L) {
[17:47:55.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.411]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.411]                   base::options(opts)
[17:47:55.411]                 }
[17:47:55.411]                 {
[17:47:55.411]                   {
[17:47:55.411]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.411]                     NULL
[17:47:55.411]                   }
[17:47:55.411]                   options(future.plan = NULL)
[17:47:55.411]                   if (is.na(NA_character_)) 
[17:47:55.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.411]                     .init = FALSE)
[17:47:55.411]                 }
[17:47:55.411]             }
[17:47:55.411]         }
[17:47:55.411]     })
[17:47:55.411]     if (TRUE) {
[17:47:55.411]         base::sink(type = "output", split = FALSE)
[17:47:55.411]         if (TRUE) {
[17:47:55.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.411]         }
[17:47:55.411]         else {
[17:47:55.411]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.411]         }
[17:47:55.411]         base::close(...future.stdout)
[17:47:55.411]         ...future.stdout <- NULL
[17:47:55.411]     }
[17:47:55.411]     ...future.result$conditions <- ...future.conditions
[17:47:55.411]     ...future.result$finished <- base::Sys.time()
[17:47:55.411]     ...future.result
[17:47:55.411] }
[17:47:55.414] requestCore(): workers = 2
[17:47:55.414] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.425] result() for MulticoreFuture ...
[17:47:55.426] result() for MulticoreFuture ...
[17:47:55.426] result() for MulticoreFuture ... done
[17:47:55.426] result() for MulticoreFuture ... done
[17:47:55.426] result() for MulticoreFuture ...
[17:47:55.427] result() for MulticoreFuture ... done
[17:47:55.429] MulticoreFuture started
[17:47:55.430] - Launch lazy future ... done
[17:47:55.430] run() for ‘MulticoreFuture’ ... done
[17:47:55.430] plan(): Setting new future strategy stack:
[17:47:55.432] getGlobalsAndPackages() ...
[17:47:55.431] List of future strategies:
[17:47:55.431] 1. sequential:
[17:47:55.431]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.431]    - tweaked: FALSE
[17:47:55.431]    - call: NULL
[17:47:55.432] Searching for globals...
[17:47:55.433] plan(): nbrOfWorkers() = 1
[17:47:55.434] - globals found: [1] ‘{’
[17:47:55.435] Searching for globals ... DONE
[17:47:55.435] Resolving globals: FALSE
[17:47:55.435] 
[17:47:55.436] 
[17:47:55.436] getGlobalsAndPackages() ... DONE
[17:47:55.436] run() for ‘Future’ ...
[17:47:55.436] - state: ‘created’
[17:47:55.437] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:47:55.442] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:55.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:47:55.442]   - Field: ‘label’
[17:47:55.442]   - Field: ‘local’
[17:47:55.443]   - Field: ‘owner’
[17:47:55.443]   - Field: ‘envir’
[17:47:55.443]   - Field: ‘workers’
[17:47:55.443]   - Field: ‘packages’
[17:47:55.443]   - Field: ‘gc’
[17:47:55.443]   - Field: ‘job’
[17:47:55.444]   - Field: ‘conditions’
[17:47:55.444]   - Field: ‘expr’
[17:47:55.444]   - Field: ‘uuid’
[17:47:55.444]   - Field: ‘seed’
[17:47:55.444]   - Field: ‘version’
[17:47:55.444]   - Field: ‘result’
[17:47:55.444]   - Field: ‘asynchronous’
[17:47:55.445]   - Field: ‘calls’
[17:47:55.445]   - Field: ‘globals’
[17:47:55.445]   - Field: ‘stdout’
[17:47:55.445]   - Field: ‘earlySignal’
[17:47:55.445]   - Field: ‘lazy’
[17:47:55.445]   - Field: ‘state’
[17:47:55.446] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:47:55.446] - Launch lazy future ...
[17:47:55.446] Packages needed by the future expression (n = 0): <none>
[17:47:55.446] Packages needed by future strategies (n = 0): <none>
[17:47:55.447] {
[17:47:55.447]     {
[17:47:55.447]         {
[17:47:55.447]             ...future.startTime <- base::Sys.time()
[17:47:55.447]             {
[17:47:55.447]                 {
[17:47:55.447]                   {
[17:47:55.447]                     {
[17:47:55.447]                       base::local({
[17:47:55.447]                         has_future <- base::requireNamespace("future", 
[17:47:55.447]                           quietly = TRUE)
[17:47:55.447]                         if (has_future) {
[17:47:55.447]                           ns <- base::getNamespace("future")
[17:47:55.447]                           version <- ns[[".package"]][["version"]]
[17:47:55.447]                           if (is.null(version)) 
[17:47:55.447]                             version <- utils::packageVersion("future")
[17:47:55.447]                         }
[17:47:55.447]                         else {
[17:47:55.447]                           version <- NULL
[17:47:55.447]                         }
[17:47:55.447]                         if (!has_future || version < "1.8.0") {
[17:47:55.447]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:55.447]                             "", base::R.version$version.string), 
[17:47:55.447]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:55.447]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:55.447]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:55.447]                               "release", "version")], collapse = " "), 
[17:47:55.447]                             hostname = base::Sys.info()[["nodename"]])
[17:47:55.447]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:55.447]                             info)
[17:47:55.447]                           info <- base::paste(info, collapse = "; ")
[17:47:55.447]                           if (!has_future) {
[17:47:55.447]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:55.447]                               info)
[17:47:55.447]                           }
[17:47:55.447]                           else {
[17:47:55.447]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:55.447]                               info, version)
[17:47:55.447]                           }
[17:47:55.447]                           base::stop(msg)
[17:47:55.447]                         }
[17:47:55.447]                       })
[17:47:55.447]                     }
[17:47:55.447]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:55.447]                     base::options(mc.cores = 1L)
[17:47:55.447]                   }
[17:47:55.447]                   ...future.strategy.old <- future::plan("list")
[17:47:55.447]                   options(future.plan = NULL)
[17:47:55.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:55.447]                 }
[17:47:55.447]                 ...future.workdir <- getwd()
[17:47:55.447]             }
[17:47:55.447]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:55.447]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:55.447]         }
[17:47:55.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:55.447]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:55.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:55.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:55.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:55.447]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:55.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:55.447]             base::names(...future.oldOptions))
[17:47:55.447]     }
[17:47:55.447]     if (FALSE) {
[17:47:55.447]     }
[17:47:55.447]     else {
[17:47:55.447]         if (TRUE) {
[17:47:55.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:55.447]                 open = "w")
[17:47:55.447]         }
[17:47:55.447]         else {
[17:47:55.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:55.447]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:55.447]         }
[17:47:55.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:55.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:55.447]             base::sink(type = "output", split = FALSE)
[17:47:55.447]             base::close(...future.stdout)
[17:47:55.447]         }, add = TRUE)
[17:47:55.447]     }
[17:47:55.447]     ...future.frame <- base::sys.nframe()
[17:47:55.447]     ...future.conditions <- base::list()
[17:47:55.447]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:55.447]     if (FALSE) {
[17:47:55.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:55.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:55.447]     }
[17:47:55.447]     ...future.result <- base::tryCatch({
[17:47:55.447]         base::withCallingHandlers({
[17:47:55.447]             ...future.value <- base::withVisible(base::local({
[17:47:55.447]                 withCallingHandlers({
[17:47:55.447]                   {
[17:47:55.447]                     3
[17:47:55.447]                   }
[17:47:55.447]                 }, immediateCondition = function(cond) {
[17:47:55.447]                   save_rds <- function (object, pathname, ...) 
[17:47:55.447]                   {
[17:47:55.447]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:47:55.447]                     if (file_test("-f", pathname_tmp)) {
[17:47:55.447]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.447]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:47:55.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.447]                         fi_tmp[["mtime"]])
[17:47:55.447]                     }
[17:47:55.447]                     tryCatch({
[17:47:55.447]                       saveRDS(object, file = pathname_tmp, ...)
[17:47:55.447]                     }, error = function(ex) {
[17:47:55.447]                       msg <- conditionMessage(ex)
[17:47:55.447]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.447]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:47:55.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.447]                         fi_tmp[["mtime"]], msg)
[17:47:55.447]                       ex$message <- msg
[17:47:55.447]                       stop(ex)
[17:47:55.447]                     })
[17:47:55.447]                     stopifnot(file_test("-f", pathname_tmp))
[17:47:55.447]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:47:55.447]                     if (!res || file_test("-f", pathname_tmp)) {
[17:47:55.447]                       fi_tmp <- file.info(pathname_tmp)
[17:47:55.447]                       fi <- file.info(pathname)
[17:47:55.447]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:47:55.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:47:55.447]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:47:55.447]                         fi[["size"]], fi[["mtime"]])
[17:47:55.447]                       stop(msg)
[17:47:55.447]                     }
[17:47:55.447]                     invisible(pathname)
[17:47:55.447]                   }
[17:47:55.447]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:47:55.447]                     rootPath = tempdir()) 
[17:47:55.447]                   {
[17:47:55.447]                     obj <- list(time = Sys.time(), condition = cond)
[17:47:55.447]                     file <- tempfile(pattern = class(cond)[1], 
[17:47:55.447]                       tmpdir = path, fileext = ".rds")
[17:47:55.447]                     save_rds(obj, file)
[17:47:55.447]                   }
[17:47:55.447]                   saveImmediateCondition(cond, path = "/tmp/Rtmpj8kG8N/.future/immediateConditions")
[17:47:55.447]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.447]                   {
[17:47:55.447]                     inherits <- base::inherits
[17:47:55.447]                     invokeRestart <- base::invokeRestart
[17:47:55.447]                     is.null <- base::is.null
[17:47:55.447]                     muffled <- FALSE
[17:47:55.447]                     if (inherits(cond, "message")) {
[17:47:55.447]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:55.447]                       if (muffled) 
[17:47:55.447]                         invokeRestart("muffleMessage")
[17:47:55.447]                     }
[17:47:55.447]                     else if (inherits(cond, "warning")) {
[17:47:55.447]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:55.447]                       if (muffled) 
[17:47:55.447]                         invokeRestart("muffleWarning")
[17:47:55.447]                     }
[17:47:55.447]                     else if (inherits(cond, "condition")) {
[17:47:55.447]                       if (!is.null(pattern)) {
[17:47:55.447]                         computeRestarts <- base::computeRestarts
[17:47:55.447]                         grepl <- base::grepl
[17:47:55.447]                         restarts <- computeRestarts(cond)
[17:47:55.447]                         for (restart in restarts) {
[17:47:55.447]                           name <- restart$name
[17:47:55.447]                           if (is.null(name)) 
[17:47:55.447]                             next
[17:47:55.447]                           if (!grepl(pattern, name)) 
[17:47:55.447]                             next
[17:47:55.447]                           invokeRestart(restart)
[17:47:55.447]                           muffled <- TRUE
[17:47:55.447]                           break
[17:47:55.447]                         }
[17:47:55.447]                       }
[17:47:55.447]                     }
[17:47:55.447]                     invisible(muffled)
[17:47:55.447]                   }
[17:47:55.447]                   muffleCondition(cond)
[17:47:55.447]                 })
[17:47:55.447]             }))
[17:47:55.447]             future::FutureResult(value = ...future.value$value, 
[17:47:55.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.447]                   ...future.rng), globalenv = if (FALSE) 
[17:47:55.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:55.447]                     ...future.globalenv.names))
[17:47:55.447]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:55.447]         }, condition = base::local({
[17:47:55.447]             c <- base::c
[17:47:55.447]             inherits <- base::inherits
[17:47:55.447]             invokeRestart <- base::invokeRestart
[17:47:55.447]             length <- base::length
[17:47:55.447]             list <- base::list
[17:47:55.447]             seq.int <- base::seq.int
[17:47:55.447]             signalCondition <- base::signalCondition
[17:47:55.447]             sys.calls <- base::sys.calls
[17:47:55.447]             `[[` <- base::`[[`
[17:47:55.447]             `+` <- base::`+`
[17:47:55.447]             `<<-` <- base::`<<-`
[17:47:55.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:55.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:55.447]                   3L)]
[17:47:55.447]             }
[17:47:55.447]             function(cond) {
[17:47:55.447]                 is_error <- inherits(cond, "error")
[17:47:55.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:55.447]                   NULL)
[17:47:55.447]                 if (is_error) {
[17:47:55.447]                   sessionInformation <- function() {
[17:47:55.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:55.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:55.447]                       search = base::search(), system = base::Sys.info())
[17:47:55.447]                   }
[17:47:55.447]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:55.447]                     cond$call), session = sessionInformation(), 
[17:47:55.447]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:55.447]                   signalCondition(cond)
[17:47:55.447]                 }
[17:47:55.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:55.447]                 "immediateCondition"))) {
[17:47:55.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:55.447]                   ...future.conditions[[length(...future.conditions) + 
[17:47:55.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:55.447]                   if (TRUE && !signal) {
[17:47:55.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.447]                     {
[17:47:55.447]                       inherits <- base::inherits
[17:47:55.447]                       invokeRestart <- base::invokeRestart
[17:47:55.447]                       is.null <- base::is.null
[17:47:55.447]                       muffled <- FALSE
[17:47:55.447]                       if (inherits(cond, "message")) {
[17:47:55.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.447]                         if (muffled) 
[17:47:55.447]                           invokeRestart("muffleMessage")
[17:47:55.447]                       }
[17:47:55.447]                       else if (inherits(cond, "warning")) {
[17:47:55.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.447]                         if (muffled) 
[17:47:55.447]                           invokeRestart("muffleWarning")
[17:47:55.447]                       }
[17:47:55.447]                       else if (inherits(cond, "condition")) {
[17:47:55.447]                         if (!is.null(pattern)) {
[17:47:55.447]                           computeRestarts <- base::computeRestarts
[17:47:55.447]                           grepl <- base::grepl
[17:47:55.447]                           restarts <- computeRestarts(cond)
[17:47:55.447]                           for (restart in restarts) {
[17:47:55.447]                             name <- restart$name
[17:47:55.447]                             if (is.null(name)) 
[17:47:55.447]                               next
[17:47:55.447]                             if (!grepl(pattern, name)) 
[17:47:55.447]                               next
[17:47:55.447]                             invokeRestart(restart)
[17:47:55.447]                             muffled <- TRUE
[17:47:55.447]                             break
[17:47:55.447]                           }
[17:47:55.447]                         }
[17:47:55.447]                       }
[17:47:55.447]                       invisible(muffled)
[17:47:55.447]                     }
[17:47:55.447]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.447]                   }
[17:47:55.447]                 }
[17:47:55.447]                 else {
[17:47:55.447]                   if (TRUE) {
[17:47:55.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:55.447]                     {
[17:47:55.447]                       inherits <- base::inherits
[17:47:55.447]                       invokeRestart <- base::invokeRestart
[17:47:55.447]                       is.null <- base::is.null
[17:47:55.447]                       muffled <- FALSE
[17:47:55.447]                       if (inherits(cond, "message")) {
[17:47:55.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:55.447]                         if (muffled) 
[17:47:55.447]                           invokeRestart("muffleMessage")
[17:47:55.447]                       }
[17:47:55.447]                       else if (inherits(cond, "warning")) {
[17:47:55.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:55.447]                         if (muffled) 
[17:47:55.447]                           invokeRestart("muffleWarning")
[17:47:55.447]                       }
[17:47:55.447]                       else if (inherits(cond, "condition")) {
[17:47:55.447]                         if (!is.null(pattern)) {
[17:47:55.447]                           computeRestarts <- base::computeRestarts
[17:47:55.447]                           grepl <- base::grepl
[17:47:55.447]                           restarts <- computeRestarts(cond)
[17:47:55.447]                           for (restart in restarts) {
[17:47:55.447]                             name <- restart$name
[17:47:55.447]                             if (is.null(name)) 
[17:47:55.447]                               next
[17:47:55.447]                             if (!grepl(pattern, name)) 
[17:47:55.447]                               next
[17:47:55.447]                             invokeRestart(restart)
[17:47:55.447]                             muffled <- TRUE
[17:47:55.447]                             break
[17:47:55.447]                           }
[17:47:55.447]                         }
[17:47:55.447]                       }
[17:47:55.447]                       invisible(muffled)
[17:47:55.447]                     }
[17:47:55.447]                     muffleCondition(cond, pattern = "^muffle")
[17:47:55.447]                   }
[17:47:55.447]                 }
[17:47:55.447]             }
[17:47:55.447]         }))
[17:47:55.447]     }, error = function(ex) {
[17:47:55.447]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:55.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:55.447]                 ...future.rng), started = ...future.startTime, 
[17:47:55.447]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:55.447]             version = "1.8"), class = "FutureResult")
[17:47:55.447]     }, finally = {
[17:47:55.447]         if (!identical(...future.workdir, getwd())) 
[17:47:55.447]             setwd(...future.workdir)
[17:47:55.447]         {
[17:47:55.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:55.447]                 ...future.oldOptions$nwarnings <- NULL
[17:47:55.447]             }
[17:47:55.447]             base::options(...future.oldOptions)
[17:47:55.447]             if (.Platform$OS.type == "windows") {
[17:47:55.447]                 old_names <- names(...future.oldEnvVars)
[17:47:55.447]                 envs <- base::Sys.getenv()
[17:47:55.447]                 names <- names(envs)
[17:47:55.447]                 common <- intersect(names, old_names)
[17:47:55.447]                 added <- setdiff(names, old_names)
[17:47:55.447]                 removed <- setdiff(old_names, names)
[17:47:55.447]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:55.447]                   envs[common]]
[17:47:55.447]                 NAMES <- toupper(changed)
[17:47:55.447]                 args <- list()
[17:47:55.447]                 for (kk in seq_along(NAMES)) {
[17:47:55.447]                   name <- changed[[kk]]
[17:47:55.447]                   NAME <- NAMES[[kk]]
[17:47:55.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.447]                     next
[17:47:55.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.447]                 }
[17:47:55.447]                 NAMES <- toupper(added)
[17:47:55.447]                 for (kk in seq_along(NAMES)) {
[17:47:55.447]                   name <- added[[kk]]
[17:47:55.447]                   NAME <- NAMES[[kk]]
[17:47:55.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.447]                     next
[17:47:55.447]                   args[[name]] <- ""
[17:47:55.447]                 }
[17:47:55.447]                 NAMES <- toupper(removed)
[17:47:55.447]                 for (kk in seq_along(NAMES)) {
[17:47:55.447]                   name <- removed[[kk]]
[17:47:55.447]                   NAME <- NAMES[[kk]]
[17:47:55.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:55.447]                     next
[17:47:55.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:55.447]                 }
[17:47:55.447]                 if (length(args) > 0) 
[17:47:55.447]                   base::do.call(base::Sys.setenv, args = args)
[17:47:55.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:55.447]             }
[17:47:55.447]             else {
[17:47:55.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:55.447]             }
[17:47:55.447]             {
[17:47:55.447]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:55.447]                   0L) {
[17:47:55.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:55.447]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:55.447]                   base::options(opts)
[17:47:55.447]                 }
[17:47:55.447]                 {
[17:47:55.447]                   {
[17:47:55.447]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:55.447]                     NULL
[17:47:55.447]                   }
[17:47:55.447]                   options(future.plan = NULL)
[17:47:55.447]                   if (is.na(NA_character_)) 
[17:47:55.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:55.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:55.447]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:55.447]                     .init = FALSE)
[17:47:55.447]                 }
[17:47:55.447]             }
[17:47:55.447]         }
[17:47:55.447]     })
[17:47:55.447]     if (TRUE) {
[17:47:55.447]         base::sink(type = "output", split = FALSE)
[17:47:55.447]         if (TRUE) {
[17:47:55.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:55.447]         }
[17:47:55.447]         else {
[17:47:55.447]             ...future.result["stdout"] <- base::list(NULL)
[17:47:55.447]         }
[17:47:55.447]         base::close(...future.stdout)
[17:47:55.447]         ...future.stdout <- NULL
[17:47:55.447]     }
[17:47:55.447]     ...future.result$conditions <- ...future.conditions
[17:47:55.447]     ...future.result$finished <- base::Sys.time()
[17:47:55.447]     ...future.result
[17:47:55.447] }
[17:47:55.450] requestCore(): workers = 2
[17:47:55.451] Poll #1 (0): usedCores() = 2, workers = 2
[17:47:55.462] result() for MulticoreFuture ...
[17:47:55.463] result() for MulticoreFuture ...
[17:47:55.463] result() for MulticoreFuture ... done
[17:47:55.463] result() for MulticoreFuture ... done
[17:47:55.463] result() for MulticoreFuture ...
[17:47:55.463] result() for MulticoreFuture ... done
[17:47:55.466] MulticoreFuture started
[17:47:55.467] - Launch lazy future ... done
[17:47:55.467] run() for ‘MulticoreFuture’ ... done
[17:47:55.467] plan(): Setting new future strategy stack:
[17:47:55.467] List of future strategies:
[17:47:55.467] 1. sequential:
[17:47:55.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:47:55.467]    - tweaked: FALSE
[17:47:55.467]    - call: NULL
[17:47:55.468] resolve() on list environment ...
[17:47:55.468]  recursive: 0
[17:47:55.469] plan(): nbrOfWorkers() = 1
[17:47:55.470]  length: 4
[17:47:55.470]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:55.470] Future #1
[17:47:55.470]  length: 3 (resolved future 1)
[17:47:55.471] plan(): Setting new future strategy stack:
[17:47:55.471] List of future strategies:
[17:47:55.471] 1. multicore:
[17:47:55.471]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.471]    - tweaked: FALSE
[17:47:55.471]    - call: plan(strategy)
[17:47:55.476] plan(): nbrOfWorkers() = 2
[17:47:55.481] Future #3
[17:47:55.481]  length: 2 (resolved future 3)
[17:47:55.481]  length: 1 (resolved future 4)
[17:47:55.936] plan(): Setting new future strategy stack:
[17:47:55.936] List of future strategies:
[17:47:55.936] 1. multicore:
[17:47:55.936]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:47:55.936]    - tweaked: FALSE
[17:47:55.936]    - call: plan(strategy)
[17:47:55.941] plan(): nbrOfWorkers() = 2
[17:47:55.941] Future #2
[17:47:55.941]  length: 0 (resolved future 2)
[17:47:55.942] resolve() on list environment ... DONE
[17:47:55.942] resolve() on list environment ...
[17:47:55.942]  recursive: 0
[17:47:55.943]  length: 4
[17:47:55.943]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:55.944] Future #1
[17:47:55.944]  length: 3 (resolved future 1)
[17:47:55.944] Future #2
[17:47:55.944]  length: 2 (resolved future 2)
[17:47:55.945] Future #3
[17:47:55.945]  length: 1 (resolved future 3)
[17:47:55.945]  length: 0 (resolved future 4)
[17:47:55.945] resolve() on list environment ... DONE
[17:47:55.946] resolve() on list environment ...
[17:47:55.946]  recursive: 0
[17:47:55.947]  length: 4
[17:47:55.947]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:55.947] Future #1
[17:47:55.948]  length: 3 (resolved future 1)
[17:47:55.948] Future #2
[17:47:55.948]  length: 2 (resolved future 2)
[17:47:55.948] Future #3
[17:47:55.949]  length: 1 (resolved future 3)
[17:47:55.949]  length: 0 (resolved future 4)
[17:47:55.949] resolve() on list environment ... DONE
[17:47:55.950] resolve() on list environment ...
[17:47:55.950]  recursive: 0
[17:47:55.951]  length: 4
[17:47:55.951]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:55.955] Future #1
[17:47:55.955]  length: 3 (resolved future 1)
[17:47:55.956] Future #2
[17:47:55.956]  length: 2 (resolved future 2)
[17:47:55.957] Future #3
[17:47:55.957]  length: 1 (resolved future 3)
[17:47:55.957]  length: 0 (resolved future 4)
[17:47:55.958] resolve() on list environment ... DONE
[17:47:55.959] resolve() on list environment ...
[17:47:55.959]  recursive: 0
[17:47:55.960]  length: 4
[17:47:55.960]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:55.961] Future #1
[17:47:55.961] result() for MulticoreFuture ...
[17:47:55.961] result() for MulticoreFuture ... done
[17:47:55.961] result() for MulticoreFuture ...
[17:47:55.961] result() for MulticoreFuture ... done
[17:47:55.962]  length: 3 (resolved future 1)
[17:47:55.962] Future #2
[17:47:55.962] result() for MulticoreFuture ...
[17:47:55.963] result() for MulticoreFuture ...
[17:47:55.963] result() for MulticoreFuture ... done
[17:47:55.963] result() for MulticoreFuture ... done
[17:47:55.963] result() for MulticoreFuture ...
[17:47:55.963] result() for MulticoreFuture ... done
[17:47:55.964]  length: 2 (resolved future 2)
[17:47:55.964] Future #3
[17:47:55.964] result() for MulticoreFuture ...
[17:47:55.965] result() for MulticoreFuture ...
[17:47:55.965] result() for MulticoreFuture ... done
[17:47:55.965] result() for MulticoreFuture ... done
[17:47:55.965] result() for MulticoreFuture ...
[17:47:55.966] result() for MulticoreFuture ... done
[17:47:55.966]  length: 1 (resolved future 3)
[17:47:55.966]  length: 0 (resolved future 4)
[17:47:55.966] resolve() on list environment ... DONE
[17:47:55.967] resolve() on list environment ...
[17:47:55.967]  recursive: 99
[17:47:55.968]  length: 4
[17:47:55.968]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:47:55.968] Future #1
[17:47:55.969] result() for MulticoreFuture ...
[17:47:55.969] result() for MulticoreFuture ... done
[17:47:55.969] result() for MulticoreFuture ...
[17:47:55.969] result() for MulticoreFuture ... done
[17:47:55.969] A MulticoreFuture was resolved
[17:47:55.969]  length: 3 (resolved future 1)
[17:47:55.969] Future #2
[17:47:55.969] result() for MulticoreFuture ...
[17:47:55.969] result() for MulticoreFuture ... done
[17:47:55.970] result() for MulticoreFuture ...
[17:47:55.970] result() for MulticoreFuture ... done
[17:47:55.970] A MulticoreFuture was resolved
[17:47:55.970]  length: 2 (resolved future 2)
[17:47:55.970] Future #3
[17:47:55.970] result() for MulticoreFuture ...
[17:47:55.970] result() for MulticoreFuture ... done
[17:47:55.970] result() for MulticoreFuture ...
[17:47:55.971] result() for MulticoreFuture ... done
[17:47:55.971] A MulticoreFuture was resolved
[17:47:55.971]  length: 1 (resolved future 3)
[17:47:55.971]  length: 0 (resolved future 4)
[17:47:55.971] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[17:47:55.972] plan(): Setting new future strategy stack:
[17:47:55.972] List of future strategies:
[17:47:55.972] 1. multisession:
[17:47:55.972]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:55.972]    - tweaked: FALSE
[17:47:55.972]    - call: plan(strategy)
[17:47:55.972] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:47:55.972] multisession:
[17:47:55.972] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:47:55.972] - tweaked: FALSE
[17:47:55.972] - call: plan(strategy)
[17:47:55.978] getGlobalsAndPackages() ...
[17:47:55.979] Not searching for globals
[17:47:55.979] - globals: [0] <none>
[17:47:55.979] getGlobalsAndPackages() ... DONE
[17:47:55.979] [local output] makeClusterPSOCK() ...
[17:47:56.022] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:47:56.023] [local output] Base port: 11335
[17:47:56.023] [local output] Getting setup options for 2 cluster nodes ...
[17:47:56.023] [local output]  - Node 1 of 2 ...
[17:47:56.024] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:56.024] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpj8kG8N/worker.rank=1.parallelly.parent=48732.be5c57e46b8b.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpj8kG8N/worker.rank=1.parallelly.parent=48732.be5c57e46b8b.pid")'’
[17:47:56.211] - Possible to infer worker's PID: TRUE
[17:47:56.211] [local output] Rscript port: 11335

[17:47:56.212] [local output]  - Node 2 of 2 ...
[17:47:56.212] [local output] localMachine=TRUE => revtunnel=FALSE

[17:47:56.213] [local output] Rscript port: 11335

[17:47:56.213] [local output] Getting setup options for 2 cluster nodes ... done
[17:47:56.213] [local output]  - Parallel setup requested for some PSOCK nodes
[17:47:56.214] [local output] Setting up PSOCK nodes in parallel
[17:47:56.214] List of 36
[17:47:56.214]  $ worker          : chr "localhost"
[17:47:56.214]   ..- attr(*, "localhost")= logi TRUE
[17:47:56.214]  $ master          : chr "localhost"
[17:47:56.214]  $ port            : int 11335
[17:47:56.214]  $ connectTimeout  : num 120
[17:47:56.214]  $ timeout         : num 2592000
[17:47:56.214]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:47:56.214]  $ homogeneous     : logi TRUE
[17:47:56.214]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:47:56.214]  $ rscript_envs    : NULL
[17:47:56.214]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:56.214]  $ rscript_startup : NULL
[17:47:56.214]  $ rscript_sh      : chr "sh"
[17:47:56.214]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:56.214]  $ methods         : logi TRUE
[17:47:56.214]  $ socketOptions   : chr "no-delay"
[17:47:56.214]  $ useXDR          : logi FALSE
[17:47:56.214]  $ outfile         : chr "/dev/null"
[17:47:56.214]  $ renice          : int NA
[17:47:56.214]  $ rshcmd          : NULL
[17:47:56.214]  $ user            : chr(0) 
[17:47:56.214]  $ revtunnel       : logi FALSE
[17:47:56.214]  $ rshlogfile      : NULL
[17:47:56.214]  $ rshopts         : chr(0) 
[17:47:56.214]  $ rank            : int 1
[17:47:56.214]  $ manual          : logi FALSE
[17:47:56.214]  $ dryrun          : logi FALSE
[17:47:56.214]  $ quiet           : logi FALSE
[17:47:56.214]  $ setup_strategy  : chr "parallel"
[17:47:56.214]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:56.214]  $ pidfile         : chr "/tmp/Rtmpj8kG8N/worker.rank=1.parallelly.parent=48732.be5c57e46b8b.pid"
[17:47:56.214]  $ rshcmd_label    : NULL
[17:47:56.214]  $ rsh_call        : NULL
[17:47:56.214]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:47:56.214]  $ localMachine    : logi TRUE
[17:47:56.214]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:47:56.214]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:47:56.214]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:47:56.214]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:47:56.214]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:47:56.214]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:47:56.214]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:47:56.214]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:47:56.214]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:47:56.214]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:47:56.214]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:47:56.214]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:47:56.214]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:47:56.214]  $ arguments       :List of 28
[17:47:56.214]   ..$ worker          : chr "localhost"
[17:47:56.214]   ..$ master          : NULL
[17:47:56.214]   ..$ port            : int 11335
[17:47:56.214]   ..$ connectTimeout  : num 120
[17:47:56.214]   ..$ timeout         : num 2592000
[17:47:56.214]   ..$ rscript         : NULL
[17:47:56.214]   ..$ homogeneous     : NULL
[17:47:56.214]   ..$ rscript_args    : NULL
[17:47:56.214]   ..$ rscript_envs    : NULL
[17:47:56.214]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:47:56.214]   ..$ rscript_startup : NULL
[17:47:56.214]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:47:56.214]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:47:56.214]   ..$ methods         : logi TRUE
[17:47:56.214]   ..$ socketOptions   : chr "no-delay"
[17:47:56.214]   ..$ useXDR          : logi FALSE
[17:47:56.214]   ..$ outfile         : chr "/dev/null"
[17:47:56.214]   ..$ renice          : int NA
[17:47:56.214]   ..$ rshcmd          : NULL
[17:47:56.214]   ..$ user            : NULL
[17:47:56.214]   ..$ revtunnel       : logi NA
[17:47:56.214]   ..$ rshlogfile      : NULL
[17:47:56.214]   ..$ rshopts         : NULL
[17:47:56.214]   ..$ rank            : int 1
[17:47:56.214]   ..$ manual          : logi FALSE
[17:47:56.214]   ..$ dryrun          : logi FALSE
[17:47:56.214]   ..$ quiet           : logi FALSE
[17:47:56.214]   ..$ setup_strategy  : chr "parallel"
[17:47:56.214]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:47:56.230] [local output] System call to launch all workers:
[17:47:56.230] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpj8kG8N/worker.rank=1.parallelly.parent=48732.be5c57e46b8b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11335 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:47:56.230] [local output] Starting PSOCK main server
[17:47:56.236] [local output] Workers launched
[17:47:56.236] [local output] Waiting for workers to connect back
[17:47:56.237]  - [local output] 0 workers out of 2 ready
[17:47:56.470]  - [local output] 0 workers out of 2 ready
[17:47:56.471]  - [local output] 1 workers out of 2 ready
[17:47:56.485]  - [local output] 1 workers out of 2 ready
[17:47:56.486]  - [local output] 2 workers out of 2 ready
[17:47:56.486] [local output] Launching of workers completed
[17:47:56.486] [local output] Collecting session information from workers
[17:47:56.487] [local output]  - Worker #1 of 2
[17:47:56.487] [local output]  - Worker #2 of 2
[17:47:56.488] [local output] makeClusterPSOCK() ... done
[17:47:56.499] Packages needed by the future expression (n = 0): <none>
[17:47:56.499] Packages needed by future strategies (n = 0): <none>
[17:47:56.499] {
[17:47:56.499]     {
[17:47:56.499]         {
[17:47:56.499]             ...future.startTime <- base::Sys.time()
[17:47:56.499]             {
[17:47:56.499]                 {
[17:47:56.499]                   {
[17:47:56.499]                     {
[17:47:56.499]                       base::local({
[17:47:56.499]                         has_future <- base::requireNamespace("future", 
[17:47:56.499]                           quietly = TRUE)
[17:47:56.499]                         if (has_future) {
[17:47:56.499]                           ns <- base::getNamespace("future")
[17:47:56.499]                           version <- ns[[".package"]][["version"]]
[17:47:56.499]                           if (is.null(version)) 
[17:47:56.499]                             version <- utils::packageVersion("future")
[17:47:56.499]                         }
[17:47:56.499]                         else {
[17:47:56.499]                           version <- NULL
[17:47:56.499]                         }
[17:47:56.499]                         if (!has_future || version < "1.8.0") {
[17:47:56.499]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:56.499]                             "", base::R.version$version.string), 
[17:47:56.499]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:56.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:56.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:56.499]                               "release", "version")], collapse = " "), 
[17:47:56.499]                             hostname = base::Sys.info()[["nodename"]])
[17:47:56.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:56.499]                             info)
[17:47:56.499]                           info <- base::paste(info, collapse = "; ")
[17:47:56.499]                           if (!has_future) {
[17:47:56.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:56.499]                               info)
[17:47:56.499]                           }
[17:47:56.499]                           else {
[17:47:56.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:56.499]                               info, version)
[17:47:56.499]                           }
[17:47:56.499]                           base::stop(msg)
[17:47:56.499]                         }
[17:47:56.499]                       })
[17:47:56.499]                     }
[17:47:56.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:56.499]                     base::options(mc.cores = 1L)
[17:47:56.499]                   }
[17:47:56.499]                   ...future.strategy.old <- future::plan("list")
[17:47:56.499]                   options(future.plan = NULL)
[17:47:56.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:56.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:56.499]                 }
[17:47:56.499]                 ...future.workdir <- getwd()
[17:47:56.499]             }
[17:47:56.499]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:56.499]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:56.499]         }
[17:47:56.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:56.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:56.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:56.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:56.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:56.499]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:56.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:56.499]             base::names(...future.oldOptions))
[17:47:56.499]     }
[17:47:56.499]     if (FALSE) {
[17:47:56.499]     }
[17:47:56.499]     else {
[17:47:56.499]         if (TRUE) {
[17:47:56.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:56.499]                 open = "w")
[17:47:56.499]         }
[17:47:56.499]         else {
[17:47:56.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:56.499]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:56.499]         }
[17:47:56.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:56.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:56.499]             base::sink(type = "output", split = FALSE)
[17:47:56.499]             base::close(...future.stdout)
[17:47:56.499]         }, add = TRUE)
[17:47:56.499]     }
[17:47:56.499]     ...future.frame <- base::sys.nframe()
[17:47:56.499]     ...future.conditions <- base::list()
[17:47:56.499]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:56.499]     if (FALSE) {
[17:47:56.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:56.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:56.499]     }
[17:47:56.499]     ...future.result <- base::tryCatch({
[17:47:56.499]         base::withCallingHandlers({
[17:47:56.499]             ...future.value <- base::withVisible(base::local({
[17:47:56.499]                 ...future.makeSendCondition <- base::local({
[17:47:56.499]                   sendCondition <- NULL
[17:47:56.499]                   function(frame = 1L) {
[17:47:56.499]                     if (is.function(sendCondition)) 
[17:47:56.499]                       return(sendCondition)
[17:47:56.499]                     ns <- getNamespace("parallel")
[17:47:56.499]                     if (exists("sendData", mode = "function", 
[17:47:56.499]                       envir = ns)) {
[17:47:56.499]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:56.499]                         envir = ns)
[17:47:56.499]                       envir <- sys.frame(frame)
[17:47:56.499]                       master <- NULL
[17:47:56.499]                       while (!identical(envir, .GlobalEnv) && 
[17:47:56.499]                         !identical(envir, emptyenv())) {
[17:47:56.499]                         if (exists("master", mode = "list", envir = envir, 
[17:47:56.499]                           inherits = FALSE)) {
[17:47:56.499]                           master <- get("master", mode = "list", 
[17:47:56.499]                             envir = envir, inherits = FALSE)
[17:47:56.499]                           if (inherits(master, c("SOCKnode", 
[17:47:56.499]                             "SOCK0node"))) {
[17:47:56.499]                             sendCondition <<- function(cond) {
[17:47:56.499]                               data <- list(type = "VALUE", value = cond, 
[17:47:56.499]                                 success = TRUE)
[17:47:56.499]                               parallel_sendData(master, data)
[17:47:56.499]                             }
[17:47:56.499]                             return(sendCondition)
[17:47:56.499]                           }
[17:47:56.499]                         }
[17:47:56.499]                         frame <- frame + 1L
[17:47:56.499]                         envir <- sys.frame(frame)
[17:47:56.499]                       }
[17:47:56.499]                     }
[17:47:56.499]                     sendCondition <<- function(cond) NULL
[17:47:56.499]                   }
[17:47:56.499]                 })
[17:47:56.499]                 withCallingHandlers({
[17:47:56.499]                   NA
[17:47:56.499]                 }, immediateCondition = function(cond) {
[17:47:56.499]                   sendCondition <- ...future.makeSendCondition()
[17:47:56.499]                   sendCondition(cond)
[17:47:56.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:56.499]                   {
[17:47:56.499]                     inherits <- base::inherits
[17:47:56.499]                     invokeRestart <- base::invokeRestart
[17:47:56.499]                     is.null <- base::is.null
[17:47:56.499]                     muffled <- FALSE
[17:47:56.499]                     if (inherits(cond, "message")) {
[17:47:56.499]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:56.499]                       if (muffled) 
[17:47:56.499]                         invokeRestart("muffleMessage")
[17:47:56.499]                     }
[17:47:56.499]                     else if (inherits(cond, "warning")) {
[17:47:56.499]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:56.499]                       if (muffled) 
[17:47:56.499]                         invokeRestart("muffleWarning")
[17:47:56.499]                     }
[17:47:56.499]                     else if (inherits(cond, "condition")) {
[17:47:56.499]                       if (!is.null(pattern)) {
[17:47:56.499]                         computeRestarts <- base::computeRestarts
[17:47:56.499]                         grepl <- base::grepl
[17:47:56.499]                         restarts <- computeRestarts(cond)
[17:47:56.499]                         for (restart in restarts) {
[17:47:56.499]                           name <- restart$name
[17:47:56.499]                           if (is.null(name)) 
[17:47:56.499]                             next
[17:47:56.499]                           if (!grepl(pattern, name)) 
[17:47:56.499]                             next
[17:47:56.499]                           invokeRestart(restart)
[17:47:56.499]                           muffled <- TRUE
[17:47:56.499]                           break
[17:47:56.499]                         }
[17:47:56.499]                       }
[17:47:56.499]                     }
[17:47:56.499]                     invisible(muffled)
[17:47:56.499]                   }
[17:47:56.499]                   muffleCondition(cond)
[17:47:56.499]                 })
[17:47:56.499]             }))
[17:47:56.499]             future::FutureResult(value = ...future.value$value, 
[17:47:56.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:56.499]                   ...future.rng), globalenv = if (FALSE) 
[17:47:56.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:56.499]                     ...future.globalenv.names))
[17:47:56.499]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:56.499]         }, condition = base::local({
[17:47:56.499]             c <- base::c
[17:47:56.499]             inherits <- base::inherits
[17:47:56.499]             invokeRestart <- base::invokeRestart
[17:47:56.499]             length <- base::length
[17:47:56.499]             list <- base::list
[17:47:56.499]             seq.int <- base::seq.int
[17:47:56.499]             signalCondition <- base::signalCondition
[17:47:56.499]             sys.calls <- base::sys.calls
[17:47:56.499]             `[[` <- base::`[[`
[17:47:56.499]             `+` <- base::`+`
[17:47:56.499]             `<<-` <- base::`<<-`
[17:47:56.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:56.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:56.499]                   3L)]
[17:47:56.499]             }
[17:47:56.499]             function(cond) {
[17:47:56.499]                 is_error <- inherits(cond, "error")
[17:47:56.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:56.499]                   NULL)
[17:47:56.499]                 if (is_error) {
[17:47:56.499]                   sessionInformation <- function() {
[17:47:56.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:56.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:56.499]                       search = base::search(), system = base::Sys.info())
[17:47:56.499]                   }
[17:47:56.499]                   ...future.conditions[[length(...future.conditions) + 
[17:47:56.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:56.499]                     cond$call), session = sessionInformation(), 
[17:47:56.499]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:56.499]                   signalCondition(cond)
[17:47:56.499]                 }
[17:47:56.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:56.499]                 "immediateCondition"))) {
[17:47:56.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:56.499]                   ...future.conditions[[length(...future.conditions) + 
[17:47:56.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:56.499]                   if (TRUE && !signal) {
[17:47:56.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:56.499]                     {
[17:47:56.499]                       inherits <- base::inherits
[17:47:56.499]                       invokeRestart <- base::invokeRestart
[17:47:56.499]                       is.null <- base::is.null
[17:47:56.499]                       muffled <- FALSE
[17:47:56.499]                       if (inherits(cond, "message")) {
[17:47:56.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:56.499]                         if (muffled) 
[17:47:56.499]                           invokeRestart("muffleMessage")
[17:47:56.499]                       }
[17:47:56.499]                       else if (inherits(cond, "warning")) {
[17:47:56.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:56.499]                         if (muffled) 
[17:47:56.499]                           invokeRestart("muffleWarning")
[17:47:56.499]                       }
[17:47:56.499]                       else if (inherits(cond, "condition")) {
[17:47:56.499]                         if (!is.null(pattern)) {
[17:47:56.499]                           computeRestarts <- base::computeRestarts
[17:47:56.499]                           grepl <- base::grepl
[17:47:56.499]                           restarts <- computeRestarts(cond)
[17:47:56.499]                           for (restart in restarts) {
[17:47:56.499]                             name <- restart$name
[17:47:56.499]                             if (is.null(name)) 
[17:47:56.499]                               next
[17:47:56.499]                             if (!grepl(pattern, name)) 
[17:47:56.499]                               next
[17:47:56.499]                             invokeRestart(restart)
[17:47:56.499]                             muffled <- TRUE
[17:47:56.499]                             break
[17:47:56.499]                           }
[17:47:56.499]                         }
[17:47:56.499]                       }
[17:47:56.499]                       invisible(muffled)
[17:47:56.499]                     }
[17:47:56.499]                     muffleCondition(cond, pattern = "^muffle")
[17:47:56.499]                   }
[17:47:56.499]                 }
[17:47:56.499]                 else {
[17:47:56.499]                   if (TRUE) {
[17:47:56.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:56.499]                     {
[17:47:56.499]                       inherits <- base::inherits
[17:47:56.499]                       invokeRestart <- base::invokeRestart
[17:47:56.499]                       is.null <- base::is.null
[17:47:56.499]                       muffled <- FALSE
[17:47:56.499]                       if (inherits(cond, "message")) {
[17:47:56.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:56.499]                         if (muffled) 
[17:47:56.499]                           invokeRestart("muffleMessage")
[17:47:56.499]                       }
[17:47:56.499]                       else if (inherits(cond, "warning")) {
[17:47:56.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:56.499]                         if (muffled) 
[17:47:56.499]                           invokeRestart("muffleWarning")
[17:47:56.499]                       }
[17:47:56.499]                       else if (inherits(cond, "condition")) {
[17:47:56.499]                         if (!is.null(pattern)) {
[17:47:56.499]                           computeRestarts <- base::computeRestarts
[17:47:56.499]                           grepl <- base::grepl
[17:47:56.499]                           restarts <- computeRestarts(cond)
[17:47:56.499]                           for (restart in restarts) {
[17:47:56.499]                             name <- restart$name
[17:47:56.499]                             if (is.null(name)) 
[17:47:56.499]                               next
[17:47:56.499]                             if (!grepl(pattern, name)) 
[17:47:56.499]                               next
[17:47:56.499]                             invokeRestart(restart)
[17:47:56.499]                             muffled <- TRUE
[17:47:56.499]                             break
[17:47:56.499]                           }
[17:47:56.499]                         }
[17:47:56.499]                       }
[17:47:56.499]                       invisible(muffled)
[17:47:56.499]                     }
[17:47:56.499]                     muffleCondition(cond, pattern = "^muffle")
[17:47:56.499]                   }
[17:47:56.499]                 }
[17:47:56.499]             }
[17:47:56.499]         }))
[17:47:56.499]     }, error = function(ex) {
[17:47:56.499]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:56.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:56.499]                 ...future.rng), started = ...future.startTime, 
[17:47:56.499]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:56.499]             version = "1.8"), class = "FutureResult")
[17:47:56.499]     }, finally = {
[17:47:56.499]         if (!identical(...future.workdir, getwd())) 
[17:47:56.499]             setwd(...future.workdir)
[17:47:56.499]         {
[17:47:56.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:56.499]                 ...future.oldOptions$nwarnings <- NULL
[17:47:56.499]             }
[17:47:56.499]             base::options(...future.oldOptions)
[17:47:56.499]             if (.Platform$OS.type == "windows") {
[17:47:56.499]                 old_names <- names(...future.oldEnvVars)
[17:47:56.499]                 envs <- base::Sys.getenv()
[17:47:56.499]                 names <- names(envs)
[17:47:56.499]                 common <- intersect(names, old_names)
[17:47:56.499]                 added <- setdiff(names, old_names)
[17:47:56.499]                 removed <- setdiff(old_names, names)
[17:47:56.499]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:56.499]                   envs[common]]
[17:47:56.499]                 NAMES <- toupper(changed)
[17:47:56.499]                 args <- list()
[17:47:56.499]                 for (kk in seq_along(NAMES)) {
[17:47:56.499]                   name <- changed[[kk]]
[17:47:56.499]                   NAME <- NAMES[[kk]]
[17:47:56.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:56.499]                     next
[17:47:56.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:56.499]                 }
[17:47:56.499]                 NAMES <- toupper(added)
[17:47:56.499]                 for (kk in seq_along(NAMES)) {
[17:47:56.499]                   name <- added[[kk]]
[17:47:56.499]                   NAME <- NAMES[[kk]]
[17:47:56.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:56.499]                     next
[17:47:56.499]                   args[[name]] <- ""
[17:47:56.499]                 }
[17:47:56.499]                 NAMES <- toupper(removed)
[17:47:56.499]                 for (kk in seq_along(NAMES)) {
[17:47:56.499]                   name <- removed[[kk]]
[17:47:56.499]                   NAME <- NAMES[[kk]]
[17:47:56.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:56.499]                     next
[17:47:56.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:56.499]                 }
[17:47:56.499]                 if (length(args) > 0) 
[17:47:56.499]                   base::do.call(base::Sys.setenv, args = args)
[17:47:56.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:56.499]             }
[17:47:56.499]             else {
[17:47:56.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:56.499]             }
[17:47:56.499]             {
[17:47:56.499]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:56.499]                   0L) {
[17:47:56.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:56.499]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:56.499]                   base::options(opts)
[17:47:56.499]                 }
[17:47:56.499]                 {
[17:47:56.499]                   {
[17:47:56.499]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:56.499]                     NULL
[17:47:56.499]                   }
[17:47:56.499]                   options(future.plan = NULL)
[17:47:56.499]                   if (is.na(NA_character_)) 
[17:47:56.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:56.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:56.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:56.499]                     .init = FALSE)
[17:47:56.499]                 }
[17:47:56.499]             }
[17:47:56.499]         }
[17:47:56.499]     })
[17:47:56.499]     if (TRUE) {
[17:47:56.499]         base::sink(type = "output", split = FALSE)
[17:47:56.499]         if (TRUE) {
[17:47:56.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:56.499]         }
[17:47:56.499]         else {
[17:47:56.499]             ...future.result["stdout"] <- base::list(NULL)
[17:47:56.499]         }
[17:47:56.499]         base::close(...future.stdout)
[17:47:56.499]         ...future.stdout <- NULL
[17:47:56.499]     }
[17:47:56.499]     ...future.result$conditions <- ...future.conditions
[17:47:56.499]     ...future.result$finished <- base::Sys.time()
[17:47:56.499]     ...future.result
[17:47:56.499] }
[17:47:56.551] MultisessionFuture started
[17:47:56.552] result() for ClusterFuture ...
[17:47:56.552] receiveMessageFromWorker() for ClusterFuture ...
[17:47:56.552] - Validating connection of MultisessionFuture
[17:47:56.584] - received message: FutureResult
[17:47:56.584] - Received FutureResult
[17:47:56.584] - Erased future from FutureRegistry
[17:47:56.584] result() for ClusterFuture ...
[17:47:56.584] - result already collected: FutureResult
[17:47:56.584] result() for ClusterFuture ... done
[17:47:56.584] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:56.584] result() for ClusterFuture ... done
[17:47:56.585] result() for ClusterFuture ...
[17:47:56.585] - result already collected: FutureResult
[17:47:56.585] result() for ClusterFuture ... done
[17:47:56.585] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:47:56.589] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[17:47:56.592] getGlobalsAndPackages() ...
[17:47:56.592] Searching for globals...
[17:47:56.594] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:56.594] Searching for globals ... DONE
[17:47:56.594] Resolving globals: FALSE
[17:47:56.594] 
[17:47:56.595] 
[17:47:56.595] getGlobalsAndPackages() ... DONE
[17:47:56.595] run() for ‘Future’ ...
[17:47:56.595] - state: ‘created’
[17:47:56.595] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:56.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:56.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:56.610]   - Field: ‘node’
[17:47:56.610]   - Field: ‘label’
[17:47:56.610]   - Field: ‘local’
[17:47:56.610]   - Field: ‘owner’
[17:47:56.610]   - Field: ‘envir’
[17:47:56.610]   - Field: ‘workers’
[17:47:56.610]   - Field: ‘packages’
[17:47:56.611]   - Field: ‘gc’
[17:47:56.611]   - Field: ‘conditions’
[17:47:56.611]   - Field: ‘persistent’
[17:47:56.611]   - Field: ‘expr’
[17:47:56.611]   - Field: ‘uuid’
[17:47:56.611]   - Field: ‘seed’
[17:47:56.611]   - Field: ‘version’
[17:47:56.611]   - Field: ‘result’
[17:47:56.612]   - Field: ‘asynchronous’
[17:47:56.612]   - Field: ‘calls’
[17:47:56.612]   - Field: ‘globals’
[17:47:56.612]   - Field: ‘stdout’
[17:47:56.612]   - Field: ‘earlySignal’
[17:47:56.612]   - Field: ‘lazy’
[17:47:56.612]   - Field: ‘state’
[17:47:56.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:56.612] - Launch lazy future ...
[17:47:56.613] Packages needed by the future expression (n = 0): <none>
[17:47:56.613] Packages needed by future strategies (n = 0): <none>
[17:47:56.613] {
[17:47:56.613]     {
[17:47:56.613]         {
[17:47:56.613]             ...future.startTime <- base::Sys.time()
[17:47:56.613]             {
[17:47:56.613]                 {
[17:47:56.613]                   {
[17:47:56.613]                     {
[17:47:56.613]                       base::local({
[17:47:56.613]                         has_future <- base::requireNamespace("future", 
[17:47:56.613]                           quietly = TRUE)
[17:47:56.613]                         if (has_future) {
[17:47:56.613]                           ns <- base::getNamespace("future")
[17:47:56.613]                           version <- ns[[".package"]][["version"]]
[17:47:56.613]                           if (is.null(version)) 
[17:47:56.613]                             version <- utils::packageVersion("future")
[17:47:56.613]                         }
[17:47:56.613]                         else {
[17:47:56.613]                           version <- NULL
[17:47:56.613]                         }
[17:47:56.613]                         if (!has_future || version < "1.8.0") {
[17:47:56.613]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:56.613]                             "", base::R.version$version.string), 
[17:47:56.613]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:56.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:56.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:56.613]                               "release", "version")], collapse = " "), 
[17:47:56.613]                             hostname = base::Sys.info()[["nodename"]])
[17:47:56.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:56.613]                             info)
[17:47:56.613]                           info <- base::paste(info, collapse = "; ")
[17:47:56.613]                           if (!has_future) {
[17:47:56.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:56.613]                               info)
[17:47:56.613]                           }
[17:47:56.613]                           else {
[17:47:56.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:56.613]                               info, version)
[17:47:56.613]                           }
[17:47:56.613]                           base::stop(msg)
[17:47:56.613]                         }
[17:47:56.613]                       })
[17:47:56.613]                     }
[17:47:56.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:56.613]                     base::options(mc.cores = 1L)
[17:47:56.613]                   }
[17:47:56.613]                   ...future.strategy.old <- future::plan("list")
[17:47:56.613]                   options(future.plan = NULL)
[17:47:56.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:56.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:56.613]                 }
[17:47:56.613]                 ...future.workdir <- getwd()
[17:47:56.613]             }
[17:47:56.613]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:56.613]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:56.613]         }
[17:47:56.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:56.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:56.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:56.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:56.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:56.613]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:56.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:56.613]             base::names(...future.oldOptions))
[17:47:56.613]     }
[17:47:56.613]     if (FALSE) {
[17:47:56.613]     }
[17:47:56.613]     else {
[17:47:56.613]         if (TRUE) {
[17:47:56.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:56.613]                 open = "w")
[17:47:56.613]         }
[17:47:56.613]         else {
[17:47:56.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:56.613]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:56.613]         }
[17:47:56.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:56.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:56.613]             base::sink(type = "output", split = FALSE)
[17:47:56.613]             base::close(...future.stdout)
[17:47:56.613]         }, add = TRUE)
[17:47:56.613]     }
[17:47:56.613]     ...future.frame <- base::sys.nframe()
[17:47:56.613]     ...future.conditions <- base::list()
[17:47:56.613]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:56.613]     if (FALSE) {
[17:47:56.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:56.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:56.613]     }
[17:47:56.613]     ...future.result <- base::tryCatch({
[17:47:56.613]         base::withCallingHandlers({
[17:47:56.613]             ...future.value <- base::withVisible(base::local({
[17:47:56.613]                 ...future.makeSendCondition <- base::local({
[17:47:56.613]                   sendCondition <- NULL
[17:47:56.613]                   function(frame = 1L) {
[17:47:56.613]                     if (is.function(sendCondition)) 
[17:47:56.613]                       return(sendCondition)
[17:47:56.613]                     ns <- getNamespace("parallel")
[17:47:56.613]                     if (exists("sendData", mode = "function", 
[17:47:56.613]                       envir = ns)) {
[17:47:56.613]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:56.613]                         envir = ns)
[17:47:56.613]                       envir <- sys.frame(frame)
[17:47:56.613]                       master <- NULL
[17:47:56.613]                       while (!identical(envir, .GlobalEnv) && 
[17:47:56.613]                         !identical(envir, emptyenv())) {
[17:47:56.613]                         if (exists("master", mode = "list", envir = envir, 
[17:47:56.613]                           inherits = FALSE)) {
[17:47:56.613]                           master <- get("master", mode = "list", 
[17:47:56.613]                             envir = envir, inherits = FALSE)
[17:47:56.613]                           if (inherits(master, c("SOCKnode", 
[17:47:56.613]                             "SOCK0node"))) {
[17:47:56.613]                             sendCondition <<- function(cond) {
[17:47:56.613]                               data <- list(type = "VALUE", value = cond, 
[17:47:56.613]                                 success = TRUE)
[17:47:56.613]                               parallel_sendData(master, data)
[17:47:56.613]                             }
[17:47:56.613]                             return(sendCondition)
[17:47:56.613]                           }
[17:47:56.613]                         }
[17:47:56.613]                         frame <- frame + 1L
[17:47:56.613]                         envir <- sys.frame(frame)
[17:47:56.613]                       }
[17:47:56.613]                     }
[17:47:56.613]                     sendCondition <<- function(cond) NULL
[17:47:56.613]                   }
[17:47:56.613]                 })
[17:47:56.613]                 withCallingHandlers({
[17:47:56.613]                   {
[17:47:56.613]                     Sys.sleep(0.5)
[17:47:56.613]                     list(a = 1, b = 42L)
[17:47:56.613]                   }
[17:47:56.613]                 }, immediateCondition = function(cond) {
[17:47:56.613]                   sendCondition <- ...future.makeSendCondition()
[17:47:56.613]                   sendCondition(cond)
[17:47:56.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:56.613]                   {
[17:47:56.613]                     inherits <- base::inherits
[17:47:56.613]                     invokeRestart <- base::invokeRestart
[17:47:56.613]                     is.null <- base::is.null
[17:47:56.613]                     muffled <- FALSE
[17:47:56.613]                     if (inherits(cond, "message")) {
[17:47:56.613]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:56.613]                       if (muffled) 
[17:47:56.613]                         invokeRestart("muffleMessage")
[17:47:56.613]                     }
[17:47:56.613]                     else if (inherits(cond, "warning")) {
[17:47:56.613]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:56.613]                       if (muffled) 
[17:47:56.613]                         invokeRestart("muffleWarning")
[17:47:56.613]                     }
[17:47:56.613]                     else if (inherits(cond, "condition")) {
[17:47:56.613]                       if (!is.null(pattern)) {
[17:47:56.613]                         computeRestarts <- base::computeRestarts
[17:47:56.613]                         grepl <- base::grepl
[17:47:56.613]                         restarts <- computeRestarts(cond)
[17:47:56.613]                         for (restart in restarts) {
[17:47:56.613]                           name <- restart$name
[17:47:56.613]                           if (is.null(name)) 
[17:47:56.613]                             next
[17:47:56.613]                           if (!grepl(pattern, name)) 
[17:47:56.613]                             next
[17:47:56.613]                           invokeRestart(restart)
[17:47:56.613]                           muffled <- TRUE
[17:47:56.613]                           break
[17:47:56.613]                         }
[17:47:56.613]                       }
[17:47:56.613]                     }
[17:47:56.613]                     invisible(muffled)
[17:47:56.613]                   }
[17:47:56.613]                   muffleCondition(cond)
[17:47:56.613]                 })
[17:47:56.613]             }))
[17:47:56.613]             future::FutureResult(value = ...future.value$value, 
[17:47:56.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:56.613]                   ...future.rng), globalenv = if (FALSE) 
[17:47:56.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:56.613]                     ...future.globalenv.names))
[17:47:56.613]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:56.613]         }, condition = base::local({
[17:47:56.613]             c <- base::c
[17:47:56.613]             inherits <- base::inherits
[17:47:56.613]             invokeRestart <- base::invokeRestart
[17:47:56.613]             length <- base::length
[17:47:56.613]             list <- base::list
[17:47:56.613]             seq.int <- base::seq.int
[17:47:56.613]             signalCondition <- base::signalCondition
[17:47:56.613]             sys.calls <- base::sys.calls
[17:47:56.613]             `[[` <- base::`[[`
[17:47:56.613]             `+` <- base::`+`
[17:47:56.613]             `<<-` <- base::`<<-`
[17:47:56.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:56.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:56.613]                   3L)]
[17:47:56.613]             }
[17:47:56.613]             function(cond) {
[17:47:56.613]                 is_error <- inherits(cond, "error")
[17:47:56.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:56.613]                   NULL)
[17:47:56.613]                 if (is_error) {
[17:47:56.613]                   sessionInformation <- function() {
[17:47:56.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:56.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:56.613]                       search = base::search(), system = base::Sys.info())
[17:47:56.613]                   }
[17:47:56.613]                   ...future.conditions[[length(...future.conditions) + 
[17:47:56.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:56.613]                     cond$call), session = sessionInformation(), 
[17:47:56.613]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:56.613]                   signalCondition(cond)
[17:47:56.613]                 }
[17:47:56.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:56.613]                 "immediateCondition"))) {
[17:47:56.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:56.613]                   ...future.conditions[[length(...future.conditions) + 
[17:47:56.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:56.613]                   if (TRUE && !signal) {
[17:47:56.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:56.613]                     {
[17:47:56.613]                       inherits <- base::inherits
[17:47:56.613]                       invokeRestart <- base::invokeRestart
[17:47:56.613]                       is.null <- base::is.null
[17:47:56.613]                       muffled <- FALSE
[17:47:56.613]                       if (inherits(cond, "message")) {
[17:47:56.613]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:56.613]                         if (muffled) 
[17:47:56.613]                           invokeRestart("muffleMessage")
[17:47:56.613]                       }
[17:47:56.613]                       else if (inherits(cond, "warning")) {
[17:47:56.613]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:56.613]                         if (muffled) 
[17:47:56.613]                           invokeRestart("muffleWarning")
[17:47:56.613]                       }
[17:47:56.613]                       else if (inherits(cond, "condition")) {
[17:47:56.613]                         if (!is.null(pattern)) {
[17:47:56.613]                           computeRestarts <- base::computeRestarts
[17:47:56.613]                           grepl <- base::grepl
[17:47:56.613]                           restarts <- computeRestarts(cond)
[17:47:56.613]                           for (restart in restarts) {
[17:47:56.613]                             name <- restart$name
[17:47:56.613]                             if (is.null(name)) 
[17:47:56.613]                               next
[17:47:56.613]                             if (!grepl(pattern, name)) 
[17:47:56.613]                               next
[17:47:56.613]                             invokeRestart(restart)
[17:47:56.613]                             muffled <- TRUE
[17:47:56.613]                             break
[17:47:56.613]                           }
[17:47:56.613]                         }
[17:47:56.613]                       }
[17:47:56.613]                       invisible(muffled)
[17:47:56.613]                     }
[17:47:56.613]                     muffleCondition(cond, pattern = "^muffle")
[17:47:56.613]                   }
[17:47:56.613]                 }
[17:47:56.613]                 else {
[17:47:56.613]                   if (TRUE) {
[17:47:56.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:56.613]                     {
[17:47:56.613]                       inherits <- base::inherits
[17:47:56.613]                       invokeRestart <- base::invokeRestart
[17:47:56.613]                       is.null <- base::is.null
[17:47:56.613]                       muffled <- FALSE
[17:47:56.613]                       if (inherits(cond, "message")) {
[17:47:56.613]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:56.613]                         if (muffled) 
[17:47:56.613]                           invokeRestart("muffleMessage")
[17:47:56.613]                       }
[17:47:56.613]                       else if (inherits(cond, "warning")) {
[17:47:56.613]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:56.613]                         if (muffled) 
[17:47:56.613]                           invokeRestart("muffleWarning")
[17:47:56.613]                       }
[17:47:56.613]                       else if (inherits(cond, "condition")) {
[17:47:56.613]                         if (!is.null(pattern)) {
[17:47:56.613]                           computeRestarts <- base::computeRestarts
[17:47:56.613]                           grepl <- base::grepl
[17:47:56.613]                           restarts <- computeRestarts(cond)
[17:47:56.613]                           for (restart in restarts) {
[17:47:56.613]                             name <- restart$name
[17:47:56.613]                             if (is.null(name)) 
[17:47:56.613]                               next
[17:47:56.613]                             if (!grepl(pattern, name)) 
[17:47:56.613]                               next
[17:47:56.613]                             invokeRestart(restart)
[17:47:56.613]                             muffled <- TRUE
[17:47:56.613]                             break
[17:47:56.613]                           }
[17:47:56.613]                         }
[17:47:56.613]                       }
[17:47:56.613]                       invisible(muffled)
[17:47:56.613]                     }
[17:47:56.613]                     muffleCondition(cond, pattern = "^muffle")
[17:47:56.613]                   }
[17:47:56.613]                 }
[17:47:56.613]             }
[17:47:56.613]         }))
[17:47:56.613]     }, error = function(ex) {
[17:47:56.613]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:56.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:56.613]                 ...future.rng), started = ...future.startTime, 
[17:47:56.613]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:56.613]             version = "1.8"), class = "FutureResult")
[17:47:56.613]     }, finally = {
[17:47:56.613]         if (!identical(...future.workdir, getwd())) 
[17:47:56.613]             setwd(...future.workdir)
[17:47:56.613]         {
[17:47:56.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:56.613]                 ...future.oldOptions$nwarnings <- NULL
[17:47:56.613]             }
[17:47:56.613]             base::options(...future.oldOptions)
[17:47:56.613]             if (.Platform$OS.type == "windows") {
[17:47:56.613]                 old_names <- names(...future.oldEnvVars)
[17:47:56.613]                 envs <- base::Sys.getenv()
[17:47:56.613]                 names <- names(envs)
[17:47:56.613]                 common <- intersect(names, old_names)
[17:47:56.613]                 added <- setdiff(names, old_names)
[17:47:56.613]                 removed <- setdiff(old_names, names)
[17:47:56.613]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:56.613]                   envs[common]]
[17:47:56.613]                 NAMES <- toupper(changed)
[17:47:56.613]                 args <- list()
[17:47:56.613]                 for (kk in seq_along(NAMES)) {
[17:47:56.613]                   name <- changed[[kk]]
[17:47:56.613]                   NAME <- NAMES[[kk]]
[17:47:56.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:56.613]                     next
[17:47:56.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:56.613]                 }
[17:47:56.613]                 NAMES <- toupper(added)
[17:47:56.613]                 for (kk in seq_along(NAMES)) {
[17:47:56.613]                   name <- added[[kk]]
[17:47:56.613]                   NAME <- NAMES[[kk]]
[17:47:56.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:56.613]                     next
[17:47:56.613]                   args[[name]] <- ""
[17:47:56.613]                 }
[17:47:56.613]                 NAMES <- toupper(removed)
[17:47:56.613]                 for (kk in seq_along(NAMES)) {
[17:47:56.613]                   name <- removed[[kk]]
[17:47:56.613]                   NAME <- NAMES[[kk]]
[17:47:56.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:56.613]                     next
[17:47:56.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:56.613]                 }
[17:47:56.613]                 if (length(args) > 0) 
[17:47:56.613]                   base::do.call(base::Sys.setenv, args = args)
[17:47:56.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:56.613]             }
[17:47:56.613]             else {
[17:47:56.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:56.613]             }
[17:47:56.613]             {
[17:47:56.613]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:56.613]                   0L) {
[17:47:56.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:56.613]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:56.613]                   base::options(opts)
[17:47:56.613]                 }
[17:47:56.613]                 {
[17:47:56.613]                   {
[17:47:56.613]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:56.613]                     NULL
[17:47:56.613]                   }
[17:47:56.613]                   options(future.plan = NULL)
[17:47:56.613]                   if (is.na(NA_character_)) 
[17:47:56.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:56.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:56.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:56.613]                     .init = FALSE)
[17:47:56.613]                 }
[17:47:56.613]             }
[17:47:56.613]         }
[17:47:56.613]     })
[17:47:56.613]     if (TRUE) {
[17:47:56.613]         base::sink(type = "output", split = FALSE)
[17:47:56.613]         if (TRUE) {
[17:47:56.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:56.613]         }
[17:47:56.613]         else {
[17:47:56.613]             ...future.result["stdout"] <- base::list(NULL)
[17:47:56.613]         }
[17:47:56.613]         base::close(...future.stdout)
[17:47:56.613]         ...future.stdout <- NULL
[17:47:56.613]     }
[17:47:56.613]     ...future.result$conditions <- ...future.conditions
[17:47:56.613]     ...future.result$finished <- base::Sys.time()
[17:47:56.613]     ...future.result
[17:47:56.613] }
[17:47:56.617] MultisessionFuture started
[17:47:56.617] - Launch lazy future ... done
[17:47:56.617] run() for ‘MultisessionFuture’ ... done
[17:47:57.119] receiveMessageFromWorker() for ClusterFuture ...
[17:47:57.119] - Validating connection of MultisessionFuture
[17:47:57.120] - received message: FutureResult
[17:47:57.120] - Received FutureResult
[17:47:57.120] - Erased future from FutureRegistry
[17:47:57.120] result() for ClusterFuture ...
[17:47:57.120] - result already collected: FutureResult
[17:47:57.120] result() for ClusterFuture ... done
[17:47:57.120] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:57.121] A MultisessionFuture was resolved (result was not collected)
[17:47:57.121] getGlobalsAndPackages() ...
[17:47:57.121] Searching for globals...
[17:47:57.122] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:57.122] Searching for globals ... DONE
[17:47:57.123] Resolving globals: FALSE
[17:47:57.123] 
[17:47:57.123] 
[17:47:57.123] getGlobalsAndPackages() ... DONE
[17:47:57.124] run() for ‘Future’ ...
[17:47:57.124] - state: ‘created’
[17:47:57.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:57.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:57.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:57.139]   - Field: ‘node’
[17:47:57.139]   - Field: ‘label’
[17:47:57.139]   - Field: ‘local’
[17:47:57.139]   - Field: ‘owner’
[17:47:57.139]   - Field: ‘envir’
[17:47:57.139]   - Field: ‘workers’
[17:47:57.139]   - Field: ‘packages’
[17:47:57.139]   - Field: ‘gc’
[17:47:57.139]   - Field: ‘conditions’
[17:47:57.140]   - Field: ‘persistent’
[17:47:57.140]   - Field: ‘expr’
[17:47:57.140]   - Field: ‘uuid’
[17:47:57.140]   - Field: ‘seed’
[17:47:57.140]   - Field: ‘version’
[17:47:57.140]   - Field: ‘result’
[17:47:57.140]   - Field: ‘asynchronous’
[17:47:57.140]   - Field: ‘calls’
[17:47:57.140]   - Field: ‘globals’
[17:47:57.141]   - Field: ‘stdout’
[17:47:57.141]   - Field: ‘earlySignal’
[17:47:57.141]   - Field: ‘lazy’
[17:47:57.141]   - Field: ‘state’
[17:47:57.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:57.141] - Launch lazy future ...
[17:47:57.141] Packages needed by the future expression (n = 0): <none>
[17:47:57.142] Packages needed by future strategies (n = 0): <none>
[17:47:57.142] {
[17:47:57.142]     {
[17:47:57.142]         {
[17:47:57.142]             ...future.startTime <- base::Sys.time()
[17:47:57.142]             {
[17:47:57.142]                 {
[17:47:57.142]                   {
[17:47:57.142]                     {
[17:47:57.142]                       base::local({
[17:47:57.142]                         has_future <- base::requireNamespace("future", 
[17:47:57.142]                           quietly = TRUE)
[17:47:57.142]                         if (has_future) {
[17:47:57.142]                           ns <- base::getNamespace("future")
[17:47:57.142]                           version <- ns[[".package"]][["version"]]
[17:47:57.142]                           if (is.null(version)) 
[17:47:57.142]                             version <- utils::packageVersion("future")
[17:47:57.142]                         }
[17:47:57.142]                         else {
[17:47:57.142]                           version <- NULL
[17:47:57.142]                         }
[17:47:57.142]                         if (!has_future || version < "1.8.0") {
[17:47:57.142]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:57.142]                             "", base::R.version$version.string), 
[17:47:57.142]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:57.142]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:57.142]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:57.142]                               "release", "version")], collapse = " "), 
[17:47:57.142]                             hostname = base::Sys.info()[["nodename"]])
[17:47:57.142]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:57.142]                             info)
[17:47:57.142]                           info <- base::paste(info, collapse = "; ")
[17:47:57.142]                           if (!has_future) {
[17:47:57.142]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:57.142]                               info)
[17:47:57.142]                           }
[17:47:57.142]                           else {
[17:47:57.142]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:57.142]                               info, version)
[17:47:57.142]                           }
[17:47:57.142]                           base::stop(msg)
[17:47:57.142]                         }
[17:47:57.142]                       })
[17:47:57.142]                     }
[17:47:57.142]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:57.142]                     base::options(mc.cores = 1L)
[17:47:57.142]                   }
[17:47:57.142]                   ...future.strategy.old <- future::plan("list")
[17:47:57.142]                   options(future.plan = NULL)
[17:47:57.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:57.142]                 }
[17:47:57.142]                 ...future.workdir <- getwd()
[17:47:57.142]             }
[17:47:57.142]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:57.142]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:57.142]         }
[17:47:57.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:57.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:57.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:57.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:57.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:57.142]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:57.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:57.142]             base::names(...future.oldOptions))
[17:47:57.142]     }
[17:47:57.142]     if (FALSE) {
[17:47:57.142]     }
[17:47:57.142]     else {
[17:47:57.142]         if (TRUE) {
[17:47:57.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:57.142]                 open = "w")
[17:47:57.142]         }
[17:47:57.142]         else {
[17:47:57.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:57.142]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:57.142]         }
[17:47:57.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:57.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:57.142]             base::sink(type = "output", split = FALSE)
[17:47:57.142]             base::close(...future.stdout)
[17:47:57.142]         }, add = TRUE)
[17:47:57.142]     }
[17:47:57.142]     ...future.frame <- base::sys.nframe()
[17:47:57.142]     ...future.conditions <- base::list()
[17:47:57.142]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:57.142]     if (FALSE) {
[17:47:57.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:57.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:57.142]     }
[17:47:57.142]     ...future.result <- base::tryCatch({
[17:47:57.142]         base::withCallingHandlers({
[17:47:57.142]             ...future.value <- base::withVisible(base::local({
[17:47:57.142]                 ...future.makeSendCondition <- base::local({
[17:47:57.142]                   sendCondition <- NULL
[17:47:57.142]                   function(frame = 1L) {
[17:47:57.142]                     if (is.function(sendCondition)) 
[17:47:57.142]                       return(sendCondition)
[17:47:57.142]                     ns <- getNamespace("parallel")
[17:47:57.142]                     if (exists("sendData", mode = "function", 
[17:47:57.142]                       envir = ns)) {
[17:47:57.142]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:57.142]                         envir = ns)
[17:47:57.142]                       envir <- sys.frame(frame)
[17:47:57.142]                       master <- NULL
[17:47:57.142]                       while (!identical(envir, .GlobalEnv) && 
[17:47:57.142]                         !identical(envir, emptyenv())) {
[17:47:57.142]                         if (exists("master", mode = "list", envir = envir, 
[17:47:57.142]                           inherits = FALSE)) {
[17:47:57.142]                           master <- get("master", mode = "list", 
[17:47:57.142]                             envir = envir, inherits = FALSE)
[17:47:57.142]                           if (inherits(master, c("SOCKnode", 
[17:47:57.142]                             "SOCK0node"))) {
[17:47:57.142]                             sendCondition <<- function(cond) {
[17:47:57.142]                               data <- list(type = "VALUE", value = cond, 
[17:47:57.142]                                 success = TRUE)
[17:47:57.142]                               parallel_sendData(master, data)
[17:47:57.142]                             }
[17:47:57.142]                             return(sendCondition)
[17:47:57.142]                           }
[17:47:57.142]                         }
[17:47:57.142]                         frame <- frame + 1L
[17:47:57.142]                         envir <- sys.frame(frame)
[17:47:57.142]                       }
[17:47:57.142]                     }
[17:47:57.142]                     sendCondition <<- function(cond) NULL
[17:47:57.142]                   }
[17:47:57.142]                 })
[17:47:57.142]                 withCallingHandlers({
[17:47:57.142]                   {
[17:47:57.142]                     Sys.sleep(0.5)
[17:47:57.142]                     list(a = 1, b = 42L)
[17:47:57.142]                   }
[17:47:57.142]                 }, immediateCondition = function(cond) {
[17:47:57.142]                   sendCondition <- ...future.makeSendCondition()
[17:47:57.142]                   sendCondition(cond)
[17:47:57.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.142]                   {
[17:47:57.142]                     inherits <- base::inherits
[17:47:57.142]                     invokeRestart <- base::invokeRestart
[17:47:57.142]                     is.null <- base::is.null
[17:47:57.142]                     muffled <- FALSE
[17:47:57.142]                     if (inherits(cond, "message")) {
[17:47:57.142]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:57.142]                       if (muffled) 
[17:47:57.142]                         invokeRestart("muffleMessage")
[17:47:57.142]                     }
[17:47:57.142]                     else if (inherits(cond, "warning")) {
[17:47:57.142]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:57.142]                       if (muffled) 
[17:47:57.142]                         invokeRestart("muffleWarning")
[17:47:57.142]                     }
[17:47:57.142]                     else if (inherits(cond, "condition")) {
[17:47:57.142]                       if (!is.null(pattern)) {
[17:47:57.142]                         computeRestarts <- base::computeRestarts
[17:47:57.142]                         grepl <- base::grepl
[17:47:57.142]                         restarts <- computeRestarts(cond)
[17:47:57.142]                         for (restart in restarts) {
[17:47:57.142]                           name <- restart$name
[17:47:57.142]                           if (is.null(name)) 
[17:47:57.142]                             next
[17:47:57.142]                           if (!grepl(pattern, name)) 
[17:47:57.142]                             next
[17:47:57.142]                           invokeRestart(restart)
[17:47:57.142]                           muffled <- TRUE
[17:47:57.142]                           break
[17:47:57.142]                         }
[17:47:57.142]                       }
[17:47:57.142]                     }
[17:47:57.142]                     invisible(muffled)
[17:47:57.142]                   }
[17:47:57.142]                   muffleCondition(cond)
[17:47:57.142]                 })
[17:47:57.142]             }))
[17:47:57.142]             future::FutureResult(value = ...future.value$value, 
[17:47:57.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.142]                   ...future.rng), globalenv = if (FALSE) 
[17:47:57.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:57.142]                     ...future.globalenv.names))
[17:47:57.142]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:57.142]         }, condition = base::local({
[17:47:57.142]             c <- base::c
[17:47:57.142]             inherits <- base::inherits
[17:47:57.142]             invokeRestart <- base::invokeRestart
[17:47:57.142]             length <- base::length
[17:47:57.142]             list <- base::list
[17:47:57.142]             seq.int <- base::seq.int
[17:47:57.142]             signalCondition <- base::signalCondition
[17:47:57.142]             sys.calls <- base::sys.calls
[17:47:57.142]             `[[` <- base::`[[`
[17:47:57.142]             `+` <- base::`+`
[17:47:57.142]             `<<-` <- base::`<<-`
[17:47:57.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:57.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:57.142]                   3L)]
[17:47:57.142]             }
[17:47:57.142]             function(cond) {
[17:47:57.142]                 is_error <- inherits(cond, "error")
[17:47:57.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:57.142]                   NULL)
[17:47:57.142]                 if (is_error) {
[17:47:57.142]                   sessionInformation <- function() {
[17:47:57.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:57.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:57.142]                       search = base::search(), system = base::Sys.info())
[17:47:57.142]                   }
[17:47:57.142]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:57.142]                     cond$call), session = sessionInformation(), 
[17:47:57.142]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:57.142]                   signalCondition(cond)
[17:47:57.142]                 }
[17:47:57.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:57.142]                 "immediateCondition"))) {
[17:47:57.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:57.142]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:57.142]                   if (TRUE && !signal) {
[17:47:57.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.142]                     {
[17:47:57.142]                       inherits <- base::inherits
[17:47:57.142]                       invokeRestart <- base::invokeRestart
[17:47:57.142]                       is.null <- base::is.null
[17:47:57.142]                       muffled <- FALSE
[17:47:57.142]                       if (inherits(cond, "message")) {
[17:47:57.142]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.142]                         if (muffled) 
[17:47:57.142]                           invokeRestart("muffleMessage")
[17:47:57.142]                       }
[17:47:57.142]                       else if (inherits(cond, "warning")) {
[17:47:57.142]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.142]                         if (muffled) 
[17:47:57.142]                           invokeRestart("muffleWarning")
[17:47:57.142]                       }
[17:47:57.142]                       else if (inherits(cond, "condition")) {
[17:47:57.142]                         if (!is.null(pattern)) {
[17:47:57.142]                           computeRestarts <- base::computeRestarts
[17:47:57.142]                           grepl <- base::grepl
[17:47:57.142]                           restarts <- computeRestarts(cond)
[17:47:57.142]                           for (restart in restarts) {
[17:47:57.142]                             name <- restart$name
[17:47:57.142]                             if (is.null(name)) 
[17:47:57.142]                               next
[17:47:57.142]                             if (!grepl(pattern, name)) 
[17:47:57.142]                               next
[17:47:57.142]                             invokeRestart(restart)
[17:47:57.142]                             muffled <- TRUE
[17:47:57.142]                             break
[17:47:57.142]                           }
[17:47:57.142]                         }
[17:47:57.142]                       }
[17:47:57.142]                       invisible(muffled)
[17:47:57.142]                     }
[17:47:57.142]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.142]                   }
[17:47:57.142]                 }
[17:47:57.142]                 else {
[17:47:57.142]                   if (TRUE) {
[17:47:57.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.142]                     {
[17:47:57.142]                       inherits <- base::inherits
[17:47:57.142]                       invokeRestart <- base::invokeRestart
[17:47:57.142]                       is.null <- base::is.null
[17:47:57.142]                       muffled <- FALSE
[17:47:57.142]                       if (inherits(cond, "message")) {
[17:47:57.142]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.142]                         if (muffled) 
[17:47:57.142]                           invokeRestart("muffleMessage")
[17:47:57.142]                       }
[17:47:57.142]                       else if (inherits(cond, "warning")) {
[17:47:57.142]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.142]                         if (muffled) 
[17:47:57.142]                           invokeRestart("muffleWarning")
[17:47:57.142]                       }
[17:47:57.142]                       else if (inherits(cond, "condition")) {
[17:47:57.142]                         if (!is.null(pattern)) {
[17:47:57.142]                           computeRestarts <- base::computeRestarts
[17:47:57.142]                           grepl <- base::grepl
[17:47:57.142]                           restarts <- computeRestarts(cond)
[17:47:57.142]                           for (restart in restarts) {
[17:47:57.142]                             name <- restart$name
[17:47:57.142]                             if (is.null(name)) 
[17:47:57.142]                               next
[17:47:57.142]                             if (!grepl(pattern, name)) 
[17:47:57.142]                               next
[17:47:57.142]                             invokeRestart(restart)
[17:47:57.142]                             muffled <- TRUE
[17:47:57.142]                             break
[17:47:57.142]                           }
[17:47:57.142]                         }
[17:47:57.142]                       }
[17:47:57.142]                       invisible(muffled)
[17:47:57.142]                     }
[17:47:57.142]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.142]                   }
[17:47:57.142]                 }
[17:47:57.142]             }
[17:47:57.142]         }))
[17:47:57.142]     }, error = function(ex) {
[17:47:57.142]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:57.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.142]                 ...future.rng), started = ...future.startTime, 
[17:47:57.142]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:57.142]             version = "1.8"), class = "FutureResult")
[17:47:57.142]     }, finally = {
[17:47:57.142]         if (!identical(...future.workdir, getwd())) 
[17:47:57.142]             setwd(...future.workdir)
[17:47:57.142]         {
[17:47:57.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:57.142]                 ...future.oldOptions$nwarnings <- NULL
[17:47:57.142]             }
[17:47:57.142]             base::options(...future.oldOptions)
[17:47:57.142]             if (.Platform$OS.type == "windows") {
[17:47:57.142]                 old_names <- names(...future.oldEnvVars)
[17:47:57.142]                 envs <- base::Sys.getenv()
[17:47:57.142]                 names <- names(envs)
[17:47:57.142]                 common <- intersect(names, old_names)
[17:47:57.142]                 added <- setdiff(names, old_names)
[17:47:57.142]                 removed <- setdiff(old_names, names)
[17:47:57.142]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:57.142]                   envs[common]]
[17:47:57.142]                 NAMES <- toupper(changed)
[17:47:57.142]                 args <- list()
[17:47:57.142]                 for (kk in seq_along(NAMES)) {
[17:47:57.142]                   name <- changed[[kk]]
[17:47:57.142]                   NAME <- NAMES[[kk]]
[17:47:57.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.142]                     next
[17:47:57.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.142]                 }
[17:47:57.142]                 NAMES <- toupper(added)
[17:47:57.142]                 for (kk in seq_along(NAMES)) {
[17:47:57.142]                   name <- added[[kk]]
[17:47:57.142]                   NAME <- NAMES[[kk]]
[17:47:57.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.142]                     next
[17:47:57.142]                   args[[name]] <- ""
[17:47:57.142]                 }
[17:47:57.142]                 NAMES <- toupper(removed)
[17:47:57.142]                 for (kk in seq_along(NAMES)) {
[17:47:57.142]                   name <- removed[[kk]]
[17:47:57.142]                   NAME <- NAMES[[kk]]
[17:47:57.142]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.142]                     next
[17:47:57.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.142]                 }
[17:47:57.142]                 if (length(args) > 0) 
[17:47:57.142]                   base::do.call(base::Sys.setenv, args = args)
[17:47:57.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:57.142]             }
[17:47:57.142]             else {
[17:47:57.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:57.142]             }
[17:47:57.142]             {
[17:47:57.142]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:57.142]                   0L) {
[17:47:57.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:57.142]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:57.142]                   base::options(opts)
[17:47:57.142]                 }
[17:47:57.142]                 {
[17:47:57.142]                   {
[17:47:57.142]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:57.142]                     NULL
[17:47:57.142]                   }
[17:47:57.142]                   options(future.plan = NULL)
[17:47:57.142]                   if (is.na(NA_character_)) 
[17:47:57.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:57.142]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:57.142]                     .init = FALSE)
[17:47:57.142]                 }
[17:47:57.142]             }
[17:47:57.142]         }
[17:47:57.142]     })
[17:47:57.142]     if (TRUE) {
[17:47:57.142]         base::sink(type = "output", split = FALSE)
[17:47:57.142]         if (TRUE) {
[17:47:57.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:57.142]         }
[17:47:57.142]         else {
[17:47:57.142]             ...future.result["stdout"] <- base::list(NULL)
[17:47:57.142]         }
[17:47:57.142]         base::close(...future.stdout)
[17:47:57.142]         ...future.stdout <- NULL
[17:47:57.142]     }
[17:47:57.142]     ...future.result$conditions <- ...future.conditions
[17:47:57.142]     ...future.result$finished <- base::Sys.time()
[17:47:57.142]     ...future.result
[17:47:57.142] }
[17:47:57.145] MultisessionFuture started
[17:47:57.146] - Launch lazy future ... done
[17:47:57.146] run() for ‘MultisessionFuture’ ... done
[17:47:57.651] receiveMessageFromWorker() for ClusterFuture ...
[17:47:57.652] - Validating connection of MultisessionFuture
[17:47:57.652] - received message: FutureResult
[17:47:57.652] - Received FutureResult
[17:47:57.652] - Erased future from FutureRegistry
[17:47:57.652] result() for ClusterFuture ...
[17:47:57.652] - result already collected: FutureResult
[17:47:57.653] result() for ClusterFuture ... done
[17:47:57.653] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:57.653] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:47:57.653] getGlobalsAndPackages() ...
[17:47:57.653] Searching for globals...
[17:47:57.654] - globals found: [2] ‘list’, ‘stop’
[17:47:57.654] Searching for globals ... DONE
[17:47:57.654] Resolving globals: FALSE
[17:47:57.655] 
[17:47:57.655] 
[17:47:57.655] getGlobalsAndPackages() ... DONE
[17:47:57.655] run() for ‘Future’ ...
[17:47:57.655] - state: ‘created’
[17:47:57.655] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:57.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:57.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:57.672]   - Field: ‘node’
[17:47:57.672]   - Field: ‘label’
[17:47:57.672]   - Field: ‘local’
[17:47:57.673]   - Field: ‘owner’
[17:47:57.673]   - Field: ‘envir’
[17:47:57.673]   - Field: ‘workers’
[17:47:57.673]   - Field: ‘packages’
[17:47:57.673]   - Field: ‘gc’
[17:47:57.673]   - Field: ‘conditions’
[17:47:57.673]   - Field: ‘persistent’
[17:47:57.673]   - Field: ‘expr’
[17:47:57.673]   - Field: ‘uuid’
[17:47:57.673]   - Field: ‘seed’
[17:47:57.673]   - Field: ‘version’
[17:47:57.674]   - Field: ‘result’
[17:47:57.674]   - Field: ‘asynchronous’
[17:47:57.674]   - Field: ‘calls’
[17:47:57.674]   - Field: ‘globals’
[17:47:57.674]   - Field: ‘stdout’
[17:47:57.674]   - Field: ‘earlySignal’
[17:47:57.674]   - Field: ‘lazy’
[17:47:57.674]   - Field: ‘state’
[17:47:57.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:57.674] - Launch lazy future ...
[17:47:57.675] Packages needed by the future expression (n = 0): <none>
[17:47:57.675] Packages needed by future strategies (n = 0): <none>
[17:47:57.675] {
[17:47:57.675]     {
[17:47:57.675]         {
[17:47:57.675]             ...future.startTime <- base::Sys.time()
[17:47:57.675]             {
[17:47:57.675]                 {
[17:47:57.675]                   {
[17:47:57.675]                     {
[17:47:57.675]                       base::local({
[17:47:57.675]                         has_future <- base::requireNamespace("future", 
[17:47:57.675]                           quietly = TRUE)
[17:47:57.675]                         if (has_future) {
[17:47:57.675]                           ns <- base::getNamespace("future")
[17:47:57.675]                           version <- ns[[".package"]][["version"]]
[17:47:57.675]                           if (is.null(version)) 
[17:47:57.675]                             version <- utils::packageVersion("future")
[17:47:57.675]                         }
[17:47:57.675]                         else {
[17:47:57.675]                           version <- NULL
[17:47:57.675]                         }
[17:47:57.675]                         if (!has_future || version < "1.8.0") {
[17:47:57.675]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:57.675]                             "", base::R.version$version.string), 
[17:47:57.675]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:57.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:57.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:57.675]                               "release", "version")], collapse = " "), 
[17:47:57.675]                             hostname = base::Sys.info()[["nodename"]])
[17:47:57.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:57.675]                             info)
[17:47:57.675]                           info <- base::paste(info, collapse = "; ")
[17:47:57.675]                           if (!has_future) {
[17:47:57.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:57.675]                               info)
[17:47:57.675]                           }
[17:47:57.675]                           else {
[17:47:57.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:57.675]                               info, version)
[17:47:57.675]                           }
[17:47:57.675]                           base::stop(msg)
[17:47:57.675]                         }
[17:47:57.675]                       })
[17:47:57.675]                     }
[17:47:57.675]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:57.675]                     base::options(mc.cores = 1L)
[17:47:57.675]                   }
[17:47:57.675]                   ...future.strategy.old <- future::plan("list")
[17:47:57.675]                   options(future.plan = NULL)
[17:47:57.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:57.675]                 }
[17:47:57.675]                 ...future.workdir <- getwd()
[17:47:57.675]             }
[17:47:57.675]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:57.675]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:57.675]         }
[17:47:57.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:57.675]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:57.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:57.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:57.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:57.675]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:57.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:57.675]             base::names(...future.oldOptions))
[17:47:57.675]     }
[17:47:57.675]     if (FALSE) {
[17:47:57.675]     }
[17:47:57.675]     else {
[17:47:57.675]         if (TRUE) {
[17:47:57.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:57.675]                 open = "w")
[17:47:57.675]         }
[17:47:57.675]         else {
[17:47:57.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:57.675]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:57.675]         }
[17:47:57.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:57.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:57.675]             base::sink(type = "output", split = FALSE)
[17:47:57.675]             base::close(...future.stdout)
[17:47:57.675]         }, add = TRUE)
[17:47:57.675]     }
[17:47:57.675]     ...future.frame <- base::sys.nframe()
[17:47:57.675]     ...future.conditions <- base::list()
[17:47:57.675]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:57.675]     if (FALSE) {
[17:47:57.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:57.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:57.675]     }
[17:47:57.675]     ...future.result <- base::tryCatch({
[17:47:57.675]         base::withCallingHandlers({
[17:47:57.675]             ...future.value <- base::withVisible(base::local({
[17:47:57.675]                 ...future.makeSendCondition <- base::local({
[17:47:57.675]                   sendCondition <- NULL
[17:47:57.675]                   function(frame = 1L) {
[17:47:57.675]                     if (is.function(sendCondition)) 
[17:47:57.675]                       return(sendCondition)
[17:47:57.675]                     ns <- getNamespace("parallel")
[17:47:57.675]                     if (exists("sendData", mode = "function", 
[17:47:57.675]                       envir = ns)) {
[17:47:57.675]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:57.675]                         envir = ns)
[17:47:57.675]                       envir <- sys.frame(frame)
[17:47:57.675]                       master <- NULL
[17:47:57.675]                       while (!identical(envir, .GlobalEnv) && 
[17:47:57.675]                         !identical(envir, emptyenv())) {
[17:47:57.675]                         if (exists("master", mode = "list", envir = envir, 
[17:47:57.675]                           inherits = FALSE)) {
[17:47:57.675]                           master <- get("master", mode = "list", 
[17:47:57.675]                             envir = envir, inherits = FALSE)
[17:47:57.675]                           if (inherits(master, c("SOCKnode", 
[17:47:57.675]                             "SOCK0node"))) {
[17:47:57.675]                             sendCondition <<- function(cond) {
[17:47:57.675]                               data <- list(type = "VALUE", value = cond, 
[17:47:57.675]                                 success = TRUE)
[17:47:57.675]                               parallel_sendData(master, data)
[17:47:57.675]                             }
[17:47:57.675]                             return(sendCondition)
[17:47:57.675]                           }
[17:47:57.675]                         }
[17:47:57.675]                         frame <- frame + 1L
[17:47:57.675]                         envir <- sys.frame(frame)
[17:47:57.675]                       }
[17:47:57.675]                     }
[17:47:57.675]                     sendCondition <<- function(cond) NULL
[17:47:57.675]                   }
[17:47:57.675]                 })
[17:47:57.675]                 withCallingHandlers({
[17:47:57.675]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:47:57.675]                 }, immediateCondition = function(cond) {
[17:47:57.675]                   sendCondition <- ...future.makeSendCondition()
[17:47:57.675]                   sendCondition(cond)
[17:47:57.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.675]                   {
[17:47:57.675]                     inherits <- base::inherits
[17:47:57.675]                     invokeRestart <- base::invokeRestart
[17:47:57.675]                     is.null <- base::is.null
[17:47:57.675]                     muffled <- FALSE
[17:47:57.675]                     if (inherits(cond, "message")) {
[17:47:57.675]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:57.675]                       if (muffled) 
[17:47:57.675]                         invokeRestart("muffleMessage")
[17:47:57.675]                     }
[17:47:57.675]                     else if (inherits(cond, "warning")) {
[17:47:57.675]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:57.675]                       if (muffled) 
[17:47:57.675]                         invokeRestart("muffleWarning")
[17:47:57.675]                     }
[17:47:57.675]                     else if (inherits(cond, "condition")) {
[17:47:57.675]                       if (!is.null(pattern)) {
[17:47:57.675]                         computeRestarts <- base::computeRestarts
[17:47:57.675]                         grepl <- base::grepl
[17:47:57.675]                         restarts <- computeRestarts(cond)
[17:47:57.675]                         for (restart in restarts) {
[17:47:57.675]                           name <- restart$name
[17:47:57.675]                           if (is.null(name)) 
[17:47:57.675]                             next
[17:47:57.675]                           if (!grepl(pattern, name)) 
[17:47:57.675]                             next
[17:47:57.675]                           invokeRestart(restart)
[17:47:57.675]                           muffled <- TRUE
[17:47:57.675]                           break
[17:47:57.675]                         }
[17:47:57.675]                       }
[17:47:57.675]                     }
[17:47:57.675]                     invisible(muffled)
[17:47:57.675]                   }
[17:47:57.675]                   muffleCondition(cond)
[17:47:57.675]                 })
[17:47:57.675]             }))
[17:47:57.675]             future::FutureResult(value = ...future.value$value, 
[17:47:57.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.675]                   ...future.rng), globalenv = if (FALSE) 
[17:47:57.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:57.675]                     ...future.globalenv.names))
[17:47:57.675]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:57.675]         }, condition = base::local({
[17:47:57.675]             c <- base::c
[17:47:57.675]             inherits <- base::inherits
[17:47:57.675]             invokeRestart <- base::invokeRestart
[17:47:57.675]             length <- base::length
[17:47:57.675]             list <- base::list
[17:47:57.675]             seq.int <- base::seq.int
[17:47:57.675]             signalCondition <- base::signalCondition
[17:47:57.675]             sys.calls <- base::sys.calls
[17:47:57.675]             `[[` <- base::`[[`
[17:47:57.675]             `+` <- base::`+`
[17:47:57.675]             `<<-` <- base::`<<-`
[17:47:57.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:57.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:57.675]                   3L)]
[17:47:57.675]             }
[17:47:57.675]             function(cond) {
[17:47:57.675]                 is_error <- inherits(cond, "error")
[17:47:57.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:57.675]                   NULL)
[17:47:57.675]                 if (is_error) {
[17:47:57.675]                   sessionInformation <- function() {
[17:47:57.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:57.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:57.675]                       search = base::search(), system = base::Sys.info())
[17:47:57.675]                   }
[17:47:57.675]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:57.675]                     cond$call), session = sessionInformation(), 
[17:47:57.675]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:57.675]                   signalCondition(cond)
[17:47:57.675]                 }
[17:47:57.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:57.675]                 "immediateCondition"))) {
[17:47:57.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:57.675]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:57.675]                   if (TRUE && !signal) {
[17:47:57.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.675]                     {
[17:47:57.675]                       inherits <- base::inherits
[17:47:57.675]                       invokeRestart <- base::invokeRestart
[17:47:57.675]                       is.null <- base::is.null
[17:47:57.675]                       muffled <- FALSE
[17:47:57.675]                       if (inherits(cond, "message")) {
[17:47:57.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.675]                         if (muffled) 
[17:47:57.675]                           invokeRestart("muffleMessage")
[17:47:57.675]                       }
[17:47:57.675]                       else if (inherits(cond, "warning")) {
[17:47:57.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.675]                         if (muffled) 
[17:47:57.675]                           invokeRestart("muffleWarning")
[17:47:57.675]                       }
[17:47:57.675]                       else if (inherits(cond, "condition")) {
[17:47:57.675]                         if (!is.null(pattern)) {
[17:47:57.675]                           computeRestarts <- base::computeRestarts
[17:47:57.675]                           grepl <- base::grepl
[17:47:57.675]                           restarts <- computeRestarts(cond)
[17:47:57.675]                           for (restart in restarts) {
[17:47:57.675]                             name <- restart$name
[17:47:57.675]                             if (is.null(name)) 
[17:47:57.675]                               next
[17:47:57.675]                             if (!grepl(pattern, name)) 
[17:47:57.675]                               next
[17:47:57.675]                             invokeRestart(restart)
[17:47:57.675]                             muffled <- TRUE
[17:47:57.675]                             break
[17:47:57.675]                           }
[17:47:57.675]                         }
[17:47:57.675]                       }
[17:47:57.675]                       invisible(muffled)
[17:47:57.675]                     }
[17:47:57.675]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.675]                   }
[17:47:57.675]                 }
[17:47:57.675]                 else {
[17:47:57.675]                   if (TRUE) {
[17:47:57.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.675]                     {
[17:47:57.675]                       inherits <- base::inherits
[17:47:57.675]                       invokeRestart <- base::invokeRestart
[17:47:57.675]                       is.null <- base::is.null
[17:47:57.675]                       muffled <- FALSE
[17:47:57.675]                       if (inherits(cond, "message")) {
[17:47:57.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.675]                         if (muffled) 
[17:47:57.675]                           invokeRestart("muffleMessage")
[17:47:57.675]                       }
[17:47:57.675]                       else if (inherits(cond, "warning")) {
[17:47:57.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.675]                         if (muffled) 
[17:47:57.675]                           invokeRestart("muffleWarning")
[17:47:57.675]                       }
[17:47:57.675]                       else if (inherits(cond, "condition")) {
[17:47:57.675]                         if (!is.null(pattern)) {
[17:47:57.675]                           computeRestarts <- base::computeRestarts
[17:47:57.675]                           grepl <- base::grepl
[17:47:57.675]                           restarts <- computeRestarts(cond)
[17:47:57.675]                           for (restart in restarts) {
[17:47:57.675]                             name <- restart$name
[17:47:57.675]                             if (is.null(name)) 
[17:47:57.675]                               next
[17:47:57.675]                             if (!grepl(pattern, name)) 
[17:47:57.675]                               next
[17:47:57.675]                             invokeRestart(restart)
[17:47:57.675]                             muffled <- TRUE
[17:47:57.675]                             break
[17:47:57.675]                           }
[17:47:57.675]                         }
[17:47:57.675]                       }
[17:47:57.675]                       invisible(muffled)
[17:47:57.675]                     }
[17:47:57.675]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.675]                   }
[17:47:57.675]                 }
[17:47:57.675]             }
[17:47:57.675]         }))
[17:47:57.675]     }, error = function(ex) {
[17:47:57.675]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:57.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.675]                 ...future.rng), started = ...future.startTime, 
[17:47:57.675]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:57.675]             version = "1.8"), class = "FutureResult")
[17:47:57.675]     }, finally = {
[17:47:57.675]         if (!identical(...future.workdir, getwd())) 
[17:47:57.675]             setwd(...future.workdir)
[17:47:57.675]         {
[17:47:57.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:57.675]                 ...future.oldOptions$nwarnings <- NULL
[17:47:57.675]             }
[17:47:57.675]             base::options(...future.oldOptions)
[17:47:57.675]             if (.Platform$OS.type == "windows") {
[17:47:57.675]                 old_names <- names(...future.oldEnvVars)
[17:47:57.675]                 envs <- base::Sys.getenv()
[17:47:57.675]                 names <- names(envs)
[17:47:57.675]                 common <- intersect(names, old_names)
[17:47:57.675]                 added <- setdiff(names, old_names)
[17:47:57.675]                 removed <- setdiff(old_names, names)
[17:47:57.675]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:57.675]                   envs[common]]
[17:47:57.675]                 NAMES <- toupper(changed)
[17:47:57.675]                 args <- list()
[17:47:57.675]                 for (kk in seq_along(NAMES)) {
[17:47:57.675]                   name <- changed[[kk]]
[17:47:57.675]                   NAME <- NAMES[[kk]]
[17:47:57.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.675]                     next
[17:47:57.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.675]                 }
[17:47:57.675]                 NAMES <- toupper(added)
[17:47:57.675]                 for (kk in seq_along(NAMES)) {
[17:47:57.675]                   name <- added[[kk]]
[17:47:57.675]                   NAME <- NAMES[[kk]]
[17:47:57.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.675]                     next
[17:47:57.675]                   args[[name]] <- ""
[17:47:57.675]                 }
[17:47:57.675]                 NAMES <- toupper(removed)
[17:47:57.675]                 for (kk in seq_along(NAMES)) {
[17:47:57.675]                   name <- removed[[kk]]
[17:47:57.675]                   NAME <- NAMES[[kk]]
[17:47:57.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.675]                     next
[17:47:57.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.675]                 }
[17:47:57.675]                 if (length(args) > 0) 
[17:47:57.675]                   base::do.call(base::Sys.setenv, args = args)
[17:47:57.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:57.675]             }
[17:47:57.675]             else {
[17:47:57.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:57.675]             }
[17:47:57.675]             {
[17:47:57.675]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:57.675]                   0L) {
[17:47:57.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:57.675]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:57.675]                   base::options(opts)
[17:47:57.675]                 }
[17:47:57.675]                 {
[17:47:57.675]                   {
[17:47:57.675]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:57.675]                     NULL
[17:47:57.675]                   }
[17:47:57.675]                   options(future.plan = NULL)
[17:47:57.675]                   if (is.na(NA_character_)) 
[17:47:57.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:57.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:57.675]                     .init = FALSE)
[17:47:57.675]                 }
[17:47:57.675]             }
[17:47:57.675]         }
[17:47:57.675]     })
[17:47:57.675]     if (TRUE) {
[17:47:57.675]         base::sink(type = "output", split = FALSE)
[17:47:57.675]         if (TRUE) {
[17:47:57.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:57.675]         }
[17:47:57.675]         else {
[17:47:57.675]             ...future.result["stdout"] <- base::list(NULL)
[17:47:57.675]         }
[17:47:57.675]         base::close(...future.stdout)
[17:47:57.675]         ...future.stdout <- NULL
[17:47:57.675]     }
[17:47:57.675]     ...future.result$conditions <- ...future.conditions
[17:47:57.675]     ...future.result$finished <- base::Sys.time()
[17:47:57.675]     ...future.result
[17:47:57.675] }
[17:47:57.678] MultisessionFuture started
[17:47:57.678] - Launch lazy future ... done
[17:47:57.678] run() for ‘MultisessionFuture’ ... done
[17:47:57.680] receiveMessageFromWorker() for ClusterFuture ...
[17:47:57.680] - Validating connection of MultisessionFuture
[17:47:57.680] - received message: FutureResult
[17:47:57.681] - Received FutureResult
[17:47:57.681] - Erased future from FutureRegistry
[17:47:57.681] result() for ClusterFuture ...
[17:47:57.681] - result already collected: FutureResult
[17:47:57.681] result() for ClusterFuture ... done
[17:47:57.681] signalConditions() ...
[17:47:57.681]  - include = ‘immediateCondition’
[17:47:57.681]  - exclude = 
[17:47:57.681]  - resignal = FALSE
[17:47:57.681]  - Number of conditions: 1
[17:47:57.681] signalConditions() ... done
[17:47:57.681] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:57.682] A MultisessionFuture was resolved (result was not collected)
[17:47:57.682] getGlobalsAndPackages() ...
[17:47:57.682] Searching for globals...
[17:47:57.682] - globals found: [2] ‘list’, ‘stop’
[17:47:57.682] Searching for globals ... DONE
[17:47:57.683] Resolving globals: FALSE
[17:47:57.683] 
[17:47:57.683] 
[17:47:57.683] getGlobalsAndPackages() ... DONE
[17:47:57.683] run() for ‘Future’ ...
[17:47:57.683] - state: ‘created’
[17:47:57.684] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:57.697] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:57.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:57.697]   - Field: ‘node’
[17:47:57.697]   - Field: ‘label’
[17:47:57.697]   - Field: ‘local’
[17:47:57.697]   - Field: ‘owner’
[17:47:57.697]   - Field: ‘envir’
[17:47:57.698]   - Field: ‘workers’
[17:47:57.698]   - Field: ‘packages’
[17:47:57.698]   - Field: ‘gc’
[17:47:57.698]   - Field: ‘conditions’
[17:47:57.698]   - Field: ‘persistent’
[17:47:57.698]   - Field: ‘expr’
[17:47:57.698]   - Field: ‘uuid’
[17:47:57.698]   - Field: ‘seed’
[17:47:57.698]   - Field: ‘version’
[17:47:57.698]   - Field: ‘result’
[17:47:57.698]   - Field: ‘asynchronous’
[17:47:57.698]   - Field: ‘calls’
[17:47:57.699]   - Field: ‘globals’
[17:47:57.699]   - Field: ‘stdout’
[17:47:57.699]   - Field: ‘earlySignal’
[17:47:57.699]   - Field: ‘lazy’
[17:47:57.699]   - Field: ‘state’
[17:47:57.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:57.699] - Launch lazy future ...
[17:47:57.699] Packages needed by the future expression (n = 0): <none>
[17:47:57.699] Packages needed by future strategies (n = 0): <none>
[17:47:57.700] {
[17:47:57.700]     {
[17:47:57.700]         {
[17:47:57.700]             ...future.startTime <- base::Sys.time()
[17:47:57.700]             {
[17:47:57.700]                 {
[17:47:57.700]                   {
[17:47:57.700]                     {
[17:47:57.700]                       base::local({
[17:47:57.700]                         has_future <- base::requireNamespace("future", 
[17:47:57.700]                           quietly = TRUE)
[17:47:57.700]                         if (has_future) {
[17:47:57.700]                           ns <- base::getNamespace("future")
[17:47:57.700]                           version <- ns[[".package"]][["version"]]
[17:47:57.700]                           if (is.null(version)) 
[17:47:57.700]                             version <- utils::packageVersion("future")
[17:47:57.700]                         }
[17:47:57.700]                         else {
[17:47:57.700]                           version <- NULL
[17:47:57.700]                         }
[17:47:57.700]                         if (!has_future || version < "1.8.0") {
[17:47:57.700]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:57.700]                             "", base::R.version$version.string), 
[17:47:57.700]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:57.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:57.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:57.700]                               "release", "version")], collapse = " "), 
[17:47:57.700]                             hostname = base::Sys.info()[["nodename"]])
[17:47:57.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:57.700]                             info)
[17:47:57.700]                           info <- base::paste(info, collapse = "; ")
[17:47:57.700]                           if (!has_future) {
[17:47:57.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:57.700]                               info)
[17:47:57.700]                           }
[17:47:57.700]                           else {
[17:47:57.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:57.700]                               info, version)
[17:47:57.700]                           }
[17:47:57.700]                           base::stop(msg)
[17:47:57.700]                         }
[17:47:57.700]                       })
[17:47:57.700]                     }
[17:47:57.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:57.700]                     base::options(mc.cores = 1L)
[17:47:57.700]                   }
[17:47:57.700]                   ...future.strategy.old <- future::plan("list")
[17:47:57.700]                   options(future.plan = NULL)
[17:47:57.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:57.700]                 }
[17:47:57.700]                 ...future.workdir <- getwd()
[17:47:57.700]             }
[17:47:57.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:57.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:57.700]         }
[17:47:57.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:57.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:57.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:57.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:57.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:57.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:57.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:57.700]             base::names(...future.oldOptions))
[17:47:57.700]     }
[17:47:57.700]     if (FALSE) {
[17:47:57.700]     }
[17:47:57.700]     else {
[17:47:57.700]         if (TRUE) {
[17:47:57.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:57.700]                 open = "w")
[17:47:57.700]         }
[17:47:57.700]         else {
[17:47:57.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:57.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:57.700]         }
[17:47:57.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:57.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:57.700]             base::sink(type = "output", split = FALSE)
[17:47:57.700]             base::close(...future.stdout)
[17:47:57.700]         }, add = TRUE)
[17:47:57.700]     }
[17:47:57.700]     ...future.frame <- base::sys.nframe()
[17:47:57.700]     ...future.conditions <- base::list()
[17:47:57.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:57.700]     if (FALSE) {
[17:47:57.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:57.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:57.700]     }
[17:47:57.700]     ...future.result <- base::tryCatch({
[17:47:57.700]         base::withCallingHandlers({
[17:47:57.700]             ...future.value <- base::withVisible(base::local({
[17:47:57.700]                 ...future.makeSendCondition <- base::local({
[17:47:57.700]                   sendCondition <- NULL
[17:47:57.700]                   function(frame = 1L) {
[17:47:57.700]                     if (is.function(sendCondition)) 
[17:47:57.700]                       return(sendCondition)
[17:47:57.700]                     ns <- getNamespace("parallel")
[17:47:57.700]                     if (exists("sendData", mode = "function", 
[17:47:57.700]                       envir = ns)) {
[17:47:57.700]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:57.700]                         envir = ns)
[17:47:57.700]                       envir <- sys.frame(frame)
[17:47:57.700]                       master <- NULL
[17:47:57.700]                       while (!identical(envir, .GlobalEnv) && 
[17:47:57.700]                         !identical(envir, emptyenv())) {
[17:47:57.700]                         if (exists("master", mode = "list", envir = envir, 
[17:47:57.700]                           inherits = FALSE)) {
[17:47:57.700]                           master <- get("master", mode = "list", 
[17:47:57.700]                             envir = envir, inherits = FALSE)
[17:47:57.700]                           if (inherits(master, c("SOCKnode", 
[17:47:57.700]                             "SOCK0node"))) {
[17:47:57.700]                             sendCondition <<- function(cond) {
[17:47:57.700]                               data <- list(type = "VALUE", value = cond, 
[17:47:57.700]                                 success = TRUE)
[17:47:57.700]                               parallel_sendData(master, data)
[17:47:57.700]                             }
[17:47:57.700]                             return(sendCondition)
[17:47:57.700]                           }
[17:47:57.700]                         }
[17:47:57.700]                         frame <- frame + 1L
[17:47:57.700]                         envir <- sys.frame(frame)
[17:47:57.700]                       }
[17:47:57.700]                     }
[17:47:57.700]                     sendCondition <<- function(cond) NULL
[17:47:57.700]                   }
[17:47:57.700]                 })
[17:47:57.700]                 withCallingHandlers({
[17:47:57.700]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:47:57.700]                 }, immediateCondition = function(cond) {
[17:47:57.700]                   sendCondition <- ...future.makeSendCondition()
[17:47:57.700]                   sendCondition(cond)
[17:47:57.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.700]                   {
[17:47:57.700]                     inherits <- base::inherits
[17:47:57.700]                     invokeRestart <- base::invokeRestart
[17:47:57.700]                     is.null <- base::is.null
[17:47:57.700]                     muffled <- FALSE
[17:47:57.700]                     if (inherits(cond, "message")) {
[17:47:57.700]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:57.700]                       if (muffled) 
[17:47:57.700]                         invokeRestart("muffleMessage")
[17:47:57.700]                     }
[17:47:57.700]                     else if (inherits(cond, "warning")) {
[17:47:57.700]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:57.700]                       if (muffled) 
[17:47:57.700]                         invokeRestart("muffleWarning")
[17:47:57.700]                     }
[17:47:57.700]                     else if (inherits(cond, "condition")) {
[17:47:57.700]                       if (!is.null(pattern)) {
[17:47:57.700]                         computeRestarts <- base::computeRestarts
[17:47:57.700]                         grepl <- base::grepl
[17:47:57.700]                         restarts <- computeRestarts(cond)
[17:47:57.700]                         for (restart in restarts) {
[17:47:57.700]                           name <- restart$name
[17:47:57.700]                           if (is.null(name)) 
[17:47:57.700]                             next
[17:47:57.700]                           if (!grepl(pattern, name)) 
[17:47:57.700]                             next
[17:47:57.700]                           invokeRestart(restart)
[17:47:57.700]                           muffled <- TRUE
[17:47:57.700]                           break
[17:47:57.700]                         }
[17:47:57.700]                       }
[17:47:57.700]                     }
[17:47:57.700]                     invisible(muffled)
[17:47:57.700]                   }
[17:47:57.700]                   muffleCondition(cond)
[17:47:57.700]                 })
[17:47:57.700]             }))
[17:47:57.700]             future::FutureResult(value = ...future.value$value, 
[17:47:57.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.700]                   ...future.rng), globalenv = if (FALSE) 
[17:47:57.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:57.700]                     ...future.globalenv.names))
[17:47:57.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:57.700]         }, condition = base::local({
[17:47:57.700]             c <- base::c
[17:47:57.700]             inherits <- base::inherits
[17:47:57.700]             invokeRestart <- base::invokeRestart
[17:47:57.700]             length <- base::length
[17:47:57.700]             list <- base::list
[17:47:57.700]             seq.int <- base::seq.int
[17:47:57.700]             signalCondition <- base::signalCondition
[17:47:57.700]             sys.calls <- base::sys.calls
[17:47:57.700]             `[[` <- base::`[[`
[17:47:57.700]             `+` <- base::`+`
[17:47:57.700]             `<<-` <- base::`<<-`
[17:47:57.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:57.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:57.700]                   3L)]
[17:47:57.700]             }
[17:47:57.700]             function(cond) {
[17:47:57.700]                 is_error <- inherits(cond, "error")
[17:47:57.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:57.700]                   NULL)
[17:47:57.700]                 if (is_error) {
[17:47:57.700]                   sessionInformation <- function() {
[17:47:57.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:57.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:57.700]                       search = base::search(), system = base::Sys.info())
[17:47:57.700]                   }
[17:47:57.700]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:57.700]                     cond$call), session = sessionInformation(), 
[17:47:57.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:57.700]                   signalCondition(cond)
[17:47:57.700]                 }
[17:47:57.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:57.700]                 "immediateCondition"))) {
[17:47:57.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:57.700]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:57.700]                   if (TRUE && !signal) {
[17:47:57.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.700]                     {
[17:47:57.700]                       inherits <- base::inherits
[17:47:57.700]                       invokeRestart <- base::invokeRestart
[17:47:57.700]                       is.null <- base::is.null
[17:47:57.700]                       muffled <- FALSE
[17:47:57.700]                       if (inherits(cond, "message")) {
[17:47:57.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.700]                         if (muffled) 
[17:47:57.700]                           invokeRestart("muffleMessage")
[17:47:57.700]                       }
[17:47:57.700]                       else if (inherits(cond, "warning")) {
[17:47:57.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.700]                         if (muffled) 
[17:47:57.700]                           invokeRestart("muffleWarning")
[17:47:57.700]                       }
[17:47:57.700]                       else if (inherits(cond, "condition")) {
[17:47:57.700]                         if (!is.null(pattern)) {
[17:47:57.700]                           computeRestarts <- base::computeRestarts
[17:47:57.700]                           grepl <- base::grepl
[17:47:57.700]                           restarts <- computeRestarts(cond)
[17:47:57.700]                           for (restart in restarts) {
[17:47:57.700]                             name <- restart$name
[17:47:57.700]                             if (is.null(name)) 
[17:47:57.700]                               next
[17:47:57.700]                             if (!grepl(pattern, name)) 
[17:47:57.700]                               next
[17:47:57.700]                             invokeRestart(restart)
[17:47:57.700]                             muffled <- TRUE
[17:47:57.700]                             break
[17:47:57.700]                           }
[17:47:57.700]                         }
[17:47:57.700]                       }
[17:47:57.700]                       invisible(muffled)
[17:47:57.700]                     }
[17:47:57.700]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.700]                   }
[17:47:57.700]                 }
[17:47:57.700]                 else {
[17:47:57.700]                   if (TRUE) {
[17:47:57.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.700]                     {
[17:47:57.700]                       inherits <- base::inherits
[17:47:57.700]                       invokeRestart <- base::invokeRestart
[17:47:57.700]                       is.null <- base::is.null
[17:47:57.700]                       muffled <- FALSE
[17:47:57.700]                       if (inherits(cond, "message")) {
[17:47:57.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.700]                         if (muffled) 
[17:47:57.700]                           invokeRestart("muffleMessage")
[17:47:57.700]                       }
[17:47:57.700]                       else if (inherits(cond, "warning")) {
[17:47:57.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.700]                         if (muffled) 
[17:47:57.700]                           invokeRestart("muffleWarning")
[17:47:57.700]                       }
[17:47:57.700]                       else if (inherits(cond, "condition")) {
[17:47:57.700]                         if (!is.null(pattern)) {
[17:47:57.700]                           computeRestarts <- base::computeRestarts
[17:47:57.700]                           grepl <- base::grepl
[17:47:57.700]                           restarts <- computeRestarts(cond)
[17:47:57.700]                           for (restart in restarts) {
[17:47:57.700]                             name <- restart$name
[17:47:57.700]                             if (is.null(name)) 
[17:47:57.700]                               next
[17:47:57.700]                             if (!grepl(pattern, name)) 
[17:47:57.700]                               next
[17:47:57.700]                             invokeRestart(restart)
[17:47:57.700]                             muffled <- TRUE
[17:47:57.700]                             break
[17:47:57.700]                           }
[17:47:57.700]                         }
[17:47:57.700]                       }
[17:47:57.700]                       invisible(muffled)
[17:47:57.700]                     }
[17:47:57.700]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.700]                   }
[17:47:57.700]                 }
[17:47:57.700]             }
[17:47:57.700]         }))
[17:47:57.700]     }, error = function(ex) {
[17:47:57.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:57.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.700]                 ...future.rng), started = ...future.startTime, 
[17:47:57.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:57.700]             version = "1.8"), class = "FutureResult")
[17:47:57.700]     }, finally = {
[17:47:57.700]         if (!identical(...future.workdir, getwd())) 
[17:47:57.700]             setwd(...future.workdir)
[17:47:57.700]         {
[17:47:57.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:57.700]                 ...future.oldOptions$nwarnings <- NULL
[17:47:57.700]             }
[17:47:57.700]             base::options(...future.oldOptions)
[17:47:57.700]             if (.Platform$OS.type == "windows") {
[17:47:57.700]                 old_names <- names(...future.oldEnvVars)
[17:47:57.700]                 envs <- base::Sys.getenv()
[17:47:57.700]                 names <- names(envs)
[17:47:57.700]                 common <- intersect(names, old_names)
[17:47:57.700]                 added <- setdiff(names, old_names)
[17:47:57.700]                 removed <- setdiff(old_names, names)
[17:47:57.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:57.700]                   envs[common]]
[17:47:57.700]                 NAMES <- toupper(changed)
[17:47:57.700]                 args <- list()
[17:47:57.700]                 for (kk in seq_along(NAMES)) {
[17:47:57.700]                   name <- changed[[kk]]
[17:47:57.700]                   NAME <- NAMES[[kk]]
[17:47:57.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.700]                     next
[17:47:57.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.700]                 }
[17:47:57.700]                 NAMES <- toupper(added)
[17:47:57.700]                 for (kk in seq_along(NAMES)) {
[17:47:57.700]                   name <- added[[kk]]
[17:47:57.700]                   NAME <- NAMES[[kk]]
[17:47:57.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.700]                     next
[17:47:57.700]                   args[[name]] <- ""
[17:47:57.700]                 }
[17:47:57.700]                 NAMES <- toupper(removed)
[17:47:57.700]                 for (kk in seq_along(NAMES)) {
[17:47:57.700]                   name <- removed[[kk]]
[17:47:57.700]                   NAME <- NAMES[[kk]]
[17:47:57.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.700]                     next
[17:47:57.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.700]                 }
[17:47:57.700]                 if (length(args) > 0) 
[17:47:57.700]                   base::do.call(base::Sys.setenv, args = args)
[17:47:57.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:57.700]             }
[17:47:57.700]             else {
[17:47:57.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:57.700]             }
[17:47:57.700]             {
[17:47:57.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:57.700]                   0L) {
[17:47:57.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:57.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:57.700]                   base::options(opts)
[17:47:57.700]                 }
[17:47:57.700]                 {
[17:47:57.700]                   {
[17:47:57.700]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:57.700]                     NULL
[17:47:57.700]                   }
[17:47:57.700]                   options(future.plan = NULL)
[17:47:57.700]                   if (is.na(NA_character_)) 
[17:47:57.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:57.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:57.700]                     .init = FALSE)
[17:47:57.700]                 }
[17:47:57.700]             }
[17:47:57.700]         }
[17:47:57.700]     })
[17:47:57.700]     if (TRUE) {
[17:47:57.700]         base::sink(type = "output", split = FALSE)
[17:47:57.700]         if (TRUE) {
[17:47:57.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:57.700]         }
[17:47:57.700]         else {
[17:47:57.700]             ...future.result["stdout"] <- base::list(NULL)
[17:47:57.700]         }
[17:47:57.700]         base::close(...future.stdout)
[17:47:57.700]         ...future.stdout <- NULL
[17:47:57.700]     }
[17:47:57.700]     ...future.result$conditions <- ...future.conditions
[17:47:57.700]     ...future.result$finished <- base::Sys.time()
[17:47:57.700]     ...future.result
[17:47:57.700] }
[17:47:57.703] MultisessionFuture started
[17:47:57.703] - Launch lazy future ... done
[17:47:57.703] run() for ‘MultisessionFuture’ ... done
[17:47:57.704] receiveMessageFromWorker() for ClusterFuture ...
[17:47:57.704] - Validating connection of MultisessionFuture
[17:47:57.705] - received message: FutureResult
[17:47:57.705] - Received FutureResult
[17:47:57.705] - Erased future from FutureRegistry
[17:47:57.705] result() for ClusterFuture ...
[17:47:57.705] - result already collected: FutureResult
[17:47:57.705] result() for ClusterFuture ... done
[17:47:57.705] signalConditions() ...
[17:47:57.705]  - include = ‘immediateCondition’
[17:47:57.705]  - exclude = 
[17:47:57.705]  - resignal = FALSE
[17:47:57.706]  - Number of conditions: 1
[17:47:57.706] signalConditions() ... done
[17:47:57.706] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:57.706] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[17:47:57.706] getGlobalsAndPackages() ...
[17:47:57.706] Searching for globals...
[17:47:57.707] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:57.707] Searching for globals ... DONE
[17:47:57.707] Resolving globals: FALSE
[17:47:57.708] 
[17:47:57.708] 
[17:47:57.708] getGlobalsAndPackages() ... DONE
[17:47:57.708] run() for ‘Future’ ...
[17:47:57.708] - state: ‘created’
[17:47:57.708] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:57.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:57.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:57.724]   - Field: ‘node’
[17:47:57.724]   - Field: ‘label’
[17:47:57.724]   - Field: ‘local’
[17:47:57.724]   - Field: ‘owner’
[17:47:57.724]   - Field: ‘envir’
[17:47:57.724]   - Field: ‘workers’
[17:47:57.724]   - Field: ‘packages’
[17:47:57.724]   - Field: ‘gc’
[17:47:57.724]   - Field: ‘conditions’
[17:47:57.724]   - Field: ‘persistent’
[17:47:57.724]   - Field: ‘expr’
[17:47:57.725]   - Field: ‘uuid’
[17:47:57.725]   - Field: ‘seed’
[17:47:57.725]   - Field: ‘version’
[17:47:57.725]   - Field: ‘result’
[17:47:57.725]   - Field: ‘asynchronous’
[17:47:57.725]   - Field: ‘calls’
[17:47:57.725]   - Field: ‘globals’
[17:47:57.725]   - Field: ‘stdout’
[17:47:57.725]   - Field: ‘earlySignal’
[17:47:57.725]   - Field: ‘lazy’
[17:47:57.725]   - Field: ‘state’
[17:47:57.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:57.726] - Launch lazy future ...
[17:47:57.726] Packages needed by the future expression (n = 0): <none>
[17:47:57.726] Packages needed by future strategies (n = 0): <none>
[17:47:57.726] {
[17:47:57.726]     {
[17:47:57.726]         {
[17:47:57.726]             ...future.startTime <- base::Sys.time()
[17:47:57.726]             {
[17:47:57.726]                 {
[17:47:57.726]                   {
[17:47:57.726]                     {
[17:47:57.726]                       base::local({
[17:47:57.726]                         has_future <- base::requireNamespace("future", 
[17:47:57.726]                           quietly = TRUE)
[17:47:57.726]                         if (has_future) {
[17:47:57.726]                           ns <- base::getNamespace("future")
[17:47:57.726]                           version <- ns[[".package"]][["version"]]
[17:47:57.726]                           if (is.null(version)) 
[17:47:57.726]                             version <- utils::packageVersion("future")
[17:47:57.726]                         }
[17:47:57.726]                         else {
[17:47:57.726]                           version <- NULL
[17:47:57.726]                         }
[17:47:57.726]                         if (!has_future || version < "1.8.0") {
[17:47:57.726]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:57.726]                             "", base::R.version$version.string), 
[17:47:57.726]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:57.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:57.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:57.726]                               "release", "version")], collapse = " "), 
[17:47:57.726]                             hostname = base::Sys.info()[["nodename"]])
[17:47:57.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:57.726]                             info)
[17:47:57.726]                           info <- base::paste(info, collapse = "; ")
[17:47:57.726]                           if (!has_future) {
[17:47:57.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:57.726]                               info)
[17:47:57.726]                           }
[17:47:57.726]                           else {
[17:47:57.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:57.726]                               info, version)
[17:47:57.726]                           }
[17:47:57.726]                           base::stop(msg)
[17:47:57.726]                         }
[17:47:57.726]                       })
[17:47:57.726]                     }
[17:47:57.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:57.726]                     base::options(mc.cores = 1L)
[17:47:57.726]                   }
[17:47:57.726]                   ...future.strategy.old <- future::plan("list")
[17:47:57.726]                   options(future.plan = NULL)
[17:47:57.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:57.726]                 }
[17:47:57.726]                 ...future.workdir <- getwd()
[17:47:57.726]             }
[17:47:57.726]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:57.726]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:57.726]         }
[17:47:57.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:57.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:57.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:57.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:57.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:57.726]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:57.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:57.726]             base::names(...future.oldOptions))
[17:47:57.726]     }
[17:47:57.726]     if (FALSE) {
[17:47:57.726]     }
[17:47:57.726]     else {
[17:47:57.726]         if (TRUE) {
[17:47:57.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:57.726]                 open = "w")
[17:47:57.726]         }
[17:47:57.726]         else {
[17:47:57.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:57.726]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:57.726]         }
[17:47:57.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:57.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:57.726]             base::sink(type = "output", split = FALSE)
[17:47:57.726]             base::close(...future.stdout)
[17:47:57.726]         }, add = TRUE)
[17:47:57.726]     }
[17:47:57.726]     ...future.frame <- base::sys.nframe()
[17:47:57.726]     ...future.conditions <- base::list()
[17:47:57.726]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:57.726]     if (FALSE) {
[17:47:57.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:57.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:57.726]     }
[17:47:57.726]     ...future.result <- base::tryCatch({
[17:47:57.726]         base::withCallingHandlers({
[17:47:57.726]             ...future.value <- base::withVisible(base::local({
[17:47:57.726]                 ...future.makeSendCondition <- base::local({
[17:47:57.726]                   sendCondition <- NULL
[17:47:57.726]                   function(frame = 1L) {
[17:47:57.726]                     if (is.function(sendCondition)) 
[17:47:57.726]                       return(sendCondition)
[17:47:57.726]                     ns <- getNamespace("parallel")
[17:47:57.726]                     if (exists("sendData", mode = "function", 
[17:47:57.726]                       envir = ns)) {
[17:47:57.726]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:57.726]                         envir = ns)
[17:47:57.726]                       envir <- sys.frame(frame)
[17:47:57.726]                       master <- NULL
[17:47:57.726]                       while (!identical(envir, .GlobalEnv) && 
[17:47:57.726]                         !identical(envir, emptyenv())) {
[17:47:57.726]                         if (exists("master", mode = "list", envir = envir, 
[17:47:57.726]                           inherits = FALSE)) {
[17:47:57.726]                           master <- get("master", mode = "list", 
[17:47:57.726]                             envir = envir, inherits = FALSE)
[17:47:57.726]                           if (inherits(master, c("SOCKnode", 
[17:47:57.726]                             "SOCK0node"))) {
[17:47:57.726]                             sendCondition <<- function(cond) {
[17:47:57.726]                               data <- list(type = "VALUE", value = cond, 
[17:47:57.726]                                 success = TRUE)
[17:47:57.726]                               parallel_sendData(master, data)
[17:47:57.726]                             }
[17:47:57.726]                             return(sendCondition)
[17:47:57.726]                           }
[17:47:57.726]                         }
[17:47:57.726]                         frame <- frame + 1L
[17:47:57.726]                         envir <- sys.frame(frame)
[17:47:57.726]                       }
[17:47:57.726]                     }
[17:47:57.726]                     sendCondition <<- function(cond) NULL
[17:47:57.726]                   }
[17:47:57.726]                 })
[17:47:57.726]                 withCallingHandlers({
[17:47:57.726]                   {
[17:47:57.726]                     Sys.sleep(0.5)
[17:47:57.726]                     list(a = 1, b = 42L)
[17:47:57.726]                   }
[17:47:57.726]                 }, immediateCondition = function(cond) {
[17:47:57.726]                   sendCondition <- ...future.makeSendCondition()
[17:47:57.726]                   sendCondition(cond)
[17:47:57.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.726]                   {
[17:47:57.726]                     inherits <- base::inherits
[17:47:57.726]                     invokeRestart <- base::invokeRestart
[17:47:57.726]                     is.null <- base::is.null
[17:47:57.726]                     muffled <- FALSE
[17:47:57.726]                     if (inherits(cond, "message")) {
[17:47:57.726]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:57.726]                       if (muffled) 
[17:47:57.726]                         invokeRestart("muffleMessage")
[17:47:57.726]                     }
[17:47:57.726]                     else if (inherits(cond, "warning")) {
[17:47:57.726]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:57.726]                       if (muffled) 
[17:47:57.726]                         invokeRestart("muffleWarning")
[17:47:57.726]                     }
[17:47:57.726]                     else if (inherits(cond, "condition")) {
[17:47:57.726]                       if (!is.null(pattern)) {
[17:47:57.726]                         computeRestarts <- base::computeRestarts
[17:47:57.726]                         grepl <- base::grepl
[17:47:57.726]                         restarts <- computeRestarts(cond)
[17:47:57.726]                         for (restart in restarts) {
[17:47:57.726]                           name <- restart$name
[17:47:57.726]                           if (is.null(name)) 
[17:47:57.726]                             next
[17:47:57.726]                           if (!grepl(pattern, name)) 
[17:47:57.726]                             next
[17:47:57.726]                           invokeRestart(restart)
[17:47:57.726]                           muffled <- TRUE
[17:47:57.726]                           break
[17:47:57.726]                         }
[17:47:57.726]                       }
[17:47:57.726]                     }
[17:47:57.726]                     invisible(muffled)
[17:47:57.726]                   }
[17:47:57.726]                   muffleCondition(cond)
[17:47:57.726]                 })
[17:47:57.726]             }))
[17:47:57.726]             future::FutureResult(value = ...future.value$value, 
[17:47:57.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.726]                   ...future.rng), globalenv = if (FALSE) 
[17:47:57.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:57.726]                     ...future.globalenv.names))
[17:47:57.726]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:57.726]         }, condition = base::local({
[17:47:57.726]             c <- base::c
[17:47:57.726]             inherits <- base::inherits
[17:47:57.726]             invokeRestart <- base::invokeRestart
[17:47:57.726]             length <- base::length
[17:47:57.726]             list <- base::list
[17:47:57.726]             seq.int <- base::seq.int
[17:47:57.726]             signalCondition <- base::signalCondition
[17:47:57.726]             sys.calls <- base::sys.calls
[17:47:57.726]             `[[` <- base::`[[`
[17:47:57.726]             `+` <- base::`+`
[17:47:57.726]             `<<-` <- base::`<<-`
[17:47:57.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:57.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:57.726]                   3L)]
[17:47:57.726]             }
[17:47:57.726]             function(cond) {
[17:47:57.726]                 is_error <- inherits(cond, "error")
[17:47:57.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:57.726]                   NULL)
[17:47:57.726]                 if (is_error) {
[17:47:57.726]                   sessionInformation <- function() {
[17:47:57.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:57.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:57.726]                       search = base::search(), system = base::Sys.info())
[17:47:57.726]                   }
[17:47:57.726]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:57.726]                     cond$call), session = sessionInformation(), 
[17:47:57.726]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:57.726]                   signalCondition(cond)
[17:47:57.726]                 }
[17:47:57.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:57.726]                 "immediateCondition"))) {
[17:47:57.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:57.726]                   ...future.conditions[[length(...future.conditions) + 
[17:47:57.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:57.726]                   if (TRUE && !signal) {
[17:47:57.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.726]                     {
[17:47:57.726]                       inherits <- base::inherits
[17:47:57.726]                       invokeRestart <- base::invokeRestart
[17:47:57.726]                       is.null <- base::is.null
[17:47:57.726]                       muffled <- FALSE
[17:47:57.726]                       if (inherits(cond, "message")) {
[17:47:57.726]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.726]                         if (muffled) 
[17:47:57.726]                           invokeRestart("muffleMessage")
[17:47:57.726]                       }
[17:47:57.726]                       else if (inherits(cond, "warning")) {
[17:47:57.726]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.726]                         if (muffled) 
[17:47:57.726]                           invokeRestart("muffleWarning")
[17:47:57.726]                       }
[17:47:57.726]                       else if (inherits(cond, "condition")) {
[17:47:57.726]                         if (!is.null(pattern)) {
[17:47:57.726]                           computeRestarts <- base::computeRestarts
[17:47:57.726]                           grepl <- base::grepl
[17:47:57.726]                           restarts <- computeRestarts(cond)
[17:47:57.726]                           for (restart in restarts) {
[17:47:57.726]                             name <- restart$name
[17:47:57.726]                             if (is.null(name)) 
[17:47:57.726]                               next
[17:47:57.726]                             if (!grepl(pattern, name)) 
[17:47:57.726]                               next
[17:47:57.726]                             invokeRestart(restart)
[17:47:57.726]                             muffled <- TRUE
[17:47:57.726]                             break
[17:47:57.726]                           }
[17:47:57.726]                         }
[17:47:57.726]                       }
[17:47:57.726]                       invisible(muffled)
[17:47:57.726]                     }
[17:47:57.726]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.726]                   }
[17:47:57.726]                 }
[17:47:57.726]                 else {
[17:47:57.726]                   if (TRUE) {
[17:47:57.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:57.726]                     {
[17:47:57.726]                       inherits <- base::inherits
[17:47:57.726]                       invokeRestart <- base::invokeRestart
[17:47:57.726]                       is.null <- base::is.null
[17:47:57.726]                       muffled <- FALSE
[17:47:57.726]                       if (inherits(cond, "message")) {
[17:47:57.726]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:57.726]                         if (muffled) 
[17:47:57.726]                           invokeRestart("muffleMessage")
[17:47:57.726]                       }
[17:47:57.726]                       else if (inherits(cond, "warning")) {
[17:47:57.726]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:57.726]                         if (muffled) 
[17:47:57.726]                           invokeRestart("muffleWarning")
[17:47:57.726]                       }
[17:47:57.726]                       else if (inherits(cond, "condition")) {
[17:47:57.726]                         if (!is.null(pattern)) {
[17:47:57.726]                           computeRestarts <- base::computeRestarts
[17:47:57.726]                           grepl <- base::grepl
[17:47:57.726]                           restarts <- computeRestarts(cond)
[17:47:57.726]                           for (restart in restarts) {
[17:47:57.726]                             name <- restart$name
[17:47:57.726]                             if (is.null(name)) 
[17:47:57.726]                               next
[17:47:57.726]                             if (!grepl(pattern, name)) 
[17:47:57.726]                               next
[17:47:57.726]                             invokeRestart(restart)
[17:47:57.726]                             muffled <- TRUE
[17:47:57.726]                             break
[17:47:57.726]                           }
[17:47:57.726]                         }
[17:47:57.726]                       }
[17:47:57.726]                       invisible(muffled)
[17:47:57.726]                     }
[17:47:57.726]                     muffleCondition(cond, pattern = "^muffle")
[17:47:57.726]                   }
[17:47:57.726]                 }
[17:47:57.726]             }
[17:47:57.726]         }))
[17:47:57.726]     }, error = function(ex) {
[17:47:57.726]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:57.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:57.726]                 ...future.rng), started = ...future.startTime, 
[17:47:57.726]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:57.726]             version = "1.8"), class = "FutureResult")
[17:47:57.726]     }, finally = {
[17:47:57.726]         if (!identical(...future.workdir, getwd())) 
[17:47:57.726]             setwd(...future.workdir)
[17:47:57.726]         {
[17:47:57.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:57.726]                 ...future.oldOptions$nwarnings <- NULL
[17:47:57.726]             }
[17:47:57.726]             base::options(...future.oldOptions)
[17:47:57.726]             if (.Platform$OS.type == "windows") {
[17:47:57.726]                 old_names <- names(...future.oldEnvVars)
[17:47:57.726]                 envs <- base::Sys.getenv()
[17:47:57.726]                 names <- names(envs)
[17:47:57.726]                 common <- intersect(names, old_names)
[17:47:57.726]                 added <- setdiff(names, old_names)
[17:47:57.726]                 removed <- setdiff(old_names, names)
[17:47:57.726]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:57.726]                   envs[common]]
[17:47:57.726]                 NAMES <- toupper(changed)
[17:47:57.726]                 args <- list()
[17:47:57.726]                 for (kk in seq_along(NAMES)) {
[17:47:57.726]                   name <- changed[[kk]]
[17:47:57.726]                   NAME <- NAMES[[kk]]
[17:47:57.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.726]                     next
[17:47:57.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.726]                 }
[17:47:57.726]                 NAMES <- toupper(added)
[17:47:57.726]                 for (kk in seq_along(NAMES)) {
[17:47:57.726]                   name <- added[[kk]]
[17:47:57.726]                   NAME <- NAMES[[kk]]
[17:47:57.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.726]                     next
[17:47:57.726]                   args[[name]] <- ""
[17:47:57.726]                 }
[17:47:57.726]                 NAMES <- toupper(removed)
[17:47:57.726]                 for (kk in seq_along(NAMES)) {
[17:47:57.726]                   name <- removed[[kk]]
[17:47:57.726]                   NAME <- NAMES[[kk]]
[17:47:57.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:57.726]                     next
[17:47:57.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:57.726]                 }
[17:47:57.726]                 if (length(args) > 0) 
[17:47:57.726]                   base::do.call(base::Sys.setenv, args = args)
[17:47:57.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:57.726]             }
[17:47:57.726]             else {
[17:47:57.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:57.726]             }
[17:47:57.726]             {
[17:47:57.726]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:57.726]                   0L) {
[17:47:57.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:57.726]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:57.726]                   base::options(opts)
[17:47:57.726]                 }
[17:47:57.726]                 {
[17:47:57.726]                   {
[17:47:57.726]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:57.726]                     NULL
[17:47:57.726]                   }
[17:47:57.726]                   options(future.plan = NULL)
[17:47:57.726]                   if (is.na(NA_character_)) 
[17:47:57.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:57.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:57.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:57.726]                     .init = FALSE)
[17:47:57.726]                 }
[17:47:57.726]             }
[17:47:57.726]         }
[17:47:57.726]     })
[17:47:57.726]     if (TRUE) {
[17:47:57.726]         base::sink(type = "output", split = FALSE)
[17:47:57.726]         if (TRUE) {
[17:47:57.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:57.726]         }
[17:47:57.726]         else {
[17:47:57.726]             ...future.result["stdout"] <- base::list(NULL)
[17:47:57.726]         }
[17:47:57.726]         base::close(...future.stdout)
[17:47:57.726]         ...future.stdout <- NULL
[17:47:57.726]     }
[17:47:57.726]     ...future.result$conditions <- ...future.conditions
[17:47:57.726]     ...future.result$finished <- base::Sys.time()
[17:47:57.726]     ...future.result
[17:47:57.726] }
[17:47:57.729] MultisessionFuture started
[17:47:57.729] - Launch lazy future ... done
[17:47:57.729] run() for ‘MultisessionFuture’ ... done
[17:47:58.231] receiveMessageFromWorker() for ClusterFuture ...
[17:47:58.232] - Validating connection of MultisessionFuture
[17:47:58.232] - received message: FutureResult
[17:47:58.232] - Received FutureResult
[17:47:58.232] - Erased future from FutureRegistry
[17:47:58.232] result() for ClusterFuture ...
[17:47:58.232] - result already collected: FutureResult
[17:47:58.232] result() for ClusterFuture ... done
[17:47:58.233] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:58.233] A MultisessionFuture was resolved (result was not collected)
[17:47:58.233] getGlobalsAndPackages() ...
[17:47:58.233] Searching for globals...
[17:47:58.234] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:58.234] Searching for globals ... DONE
[17:47:58.234] Resolving globals: FALSE
[17:47:58.234] 
[17:47:58.235] 
[17:47:58.235] getGlobalsAndPackages() ... DONE
[17:47:58.235] run() for ‘Future’ ...
[17:47:58.235] - state: ‘created’
[17:47:58.235] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:58.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:58.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:58.250]   - Field: ‘node’
[17:47:58.250]   - Field: ‘label’
[17:47:58.250]   - Field: ‘local’
[17:47:58.250]   - Field: ‘owner’
[17:47:58.250]   - Field: ‘envir’
[17:47:58.250]   - Field: ‘workers’
[17:47:58.250]   - Field: ‘packages’
[17:47:58.250]   - Field: ‘gc’
[17:47:58.250]   - Field: ‘conditions’
[17:47:58.250]   - Field: ‘persistent’
[17:47:58.250]   - Field: ‘expr’
[17:47:58.251]   - Field: ‘uuid’
[17:47:58.251]   - Field: ‘seed’
[17:47:58.251]   - Field: ‘version’
[17:47:58.251]   - Field: ‘result’
[17:47:58.251]   - Field: ‘asynchronous’
[17:47:58.251]   - Field: ‘calls’
[17:47:58.251]   - Field: ‘globals’
[17:47:58.251]   - Field: ‘stdout’
[17:47:58.251]   - Field: ‘earlySignal’
[17:47:58.251]   - Field: ‘lazy’
[17:47:58.252]   - Field: ‘state’
[17:47:58.252] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:58.252] - Launch lazy future ...
[17:47:58.252] Packages needed by the future expression (n = 0): <none>
[17:47:58.252] Packages needed by future strategies (n = 0): <none>
[17:47:58.253] {
[17:47:58.253]     {
[17:47:58.253]         {
[17:47:58.253]             ...future.startTime <- base::Sys.time()
[17:47:58.253]             {
[17:47:58.253]                 {
[17:47:58.253]                   {
[17:47:58.253]                     {
[17:47:58.253]                       base::local({
[17:47:58.253]                         has_future <- base::requireNamespace("future", 
[17:47:58.253]                           quietly = TRUE)
[17:47:58.253]                         if (has_future) {
[17:47:58.253]                           ns <- base::getNamespace("future")
[17:47:58.253]                           version <- ns[[".package"]][["version"]]
[17:47:58.253]                           if (is.null(version)) 
[17:47:58.253]                             version <- utils::packageVersion("future")
[17:47:58.253]                         }
[17:47:58.253]                         else {
[17:47:58.253]                           version <- NULL
[17:47:58.253]                         }
[17:47:58.253]                         if (!has_future || version < "1.8.0") {
[17:47:58.253]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:58.253]                             "", base::R.version$version.string), 
[17:47:58.253]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:58.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:58.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:58.253]                               "release", "version")], collapse = " "), 
[17:47:58.253]                             hostname = base::Sys.info()[["nodename"]])
[17:47:58.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:58.253]                             info)
[17:47:58.253]                           info <- base::paste(info, collapse = "; ")
[17:47:58.253]                           if (!has_future) {
[17:47:58.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:58.253]                               info)
[17:47:58.253]                           }
[17:47:58.253]                           else {
[17:47:58.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:58.253]                               info, version)
[17:47:58.253]                           }
[17:47:58.253]                           base::stop(msg)
[17:47:58.253]                         }
[17:47:58.253]                       })
[17:47:58.253]                     }
[17:47:58.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:58.253]                     base::options(mc.cores = 1L)
[17:47:58.253]                   }
[17:47:58.253]                   ...future.strategy.old <- future::plan("list")
[17:47:58.253]                   options(future.plan = NULL)
[17:47:58.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:58.253]                 }
[17:47:58.253]                 ...future.workdir <- getwd()
[17:47:58.253]             }
[17:47:58.253]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:58.253]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:58.253]         }
[17:47:58.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:58.253]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:58.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:58.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:58.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:58.253]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:58.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:58.253]             base::names(...future.oldOptions))
[17:47:58.253]     }
[17:47:58.253]     if (FALSE) {
[17:47:58.253]     }
[17:47:58.253]     else {
[17:47:58.253]         if (TRUE) {
[17:47:58.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:58.253]                 open = "w")
[17:47:58.253]         }
[17:47:58.253]         else {
[17:47:58.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:58.253]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:58.253]         }
[17:47:58.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:58.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:58.253]             base::sink(type = "output", split = FALSE)
[17:47:58.253]             base::close(...future.stdout)
[17:47:58.253]         }, add = TRUE)
[17:47:58.253]     }
[17:47:58.253]     ...future.frame <- base::sys.nframe()
[17:47:58.253]     ...future.conditions <- base::list()
[17:47:58.253]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:58.253]     if (FALSE) {
[17:47:58.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:58.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:58.253]     }
[17:47:58.253]     ...future.result <- base::tryCatch({
[17:47:58.253]         base::withCallingHandlers({
[17:47:58.253]             ...future.value <- base::withVisible(base::local({
[17:47:58.253]                 ...future.makeSendCondition <- base::local({
[17:47:58.253]                   sendCondition <- NULL
[17:47:58.253]                   function(frame = 1L) {
[17:47:58.253]                     if (is.function(sendCondition)) 
[17:47:58.253]                       return(sendCondition)
[17:47:58.253]                     ns <- getNamespace("parallel")
[17:47:58.253]                     if (exists("sendData", mode = "function", 
[17:47:58.253]                       envir = ns)) {
[17:47:58.253]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:58.253]                         envir = ns)
[17:47:58.253]                       envir <- sys.frame(frame)
[17:47:58.253]                       master <- NULL
[17:47:58.253]                       while (!identical(envir, .GlobalEnv) && 
[17:47:58.253]                         !identical(envir, emptyenv())) {
[17:47:58.253]                         if (exists("master", mode = "list", envir = envir, 
[17:47:58.253]                           inherits = FALSE)) {
[17:47:58.253]                           master <- get("master", mode = "list", 
[17:47:58.253]                             envir = envir, inherits = FALSE)
[17:47:58.253]                           if (inherits(master, c("SOCKnode", 
[17:47:58.253]                             "SOCK0node"))) {
[17:47:58.253]                             sendCondition <<- function(cond) {
[17:47:58.253]                               data <- list(type = "VALUE", value = cond, 
[17:47:58.253]                                 success = TRUE)
[17:47:58.253]                               parallel_sendData(master, data)
[17:47:58.253]                             }
[17:47:58.253]                             return(sendCondition)
[17:47:58.253]                           }
[17:47:58.253]                         }
[17:47:58.253]                         frame <- frame + 1L
[17:47:58.253]                         envir <- sys.frame(frame)
[17:47:58.253]                       }
[17:47:58.253]                     }
[17:47:58.253]                     sendCondition <<- function(cond) NULL
[17:47:58.253]                   }
[17:47:58.253]                 })
[17:47:58.253]                 withCallingHandlers({
[17:47:58.253]                   {
[17:47:58.253]                     Sys.sleep(0.5)
[17:47:58.253]                     list(a = 1, b = 42L)
[17:47:58.253]                   }
[17:47:58.253]                 }, immediateCondition = function(cond) {
[17:47:58.253]                   sendCondition <- ...future.makeSendCondition()
[17:47:58.253]                   sendCondition(cond)
[17:47:58.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.253]                   {
[17:47:58.253]                     inherits <- base::inherits
[17:47:58.253]                     invokeRestart <- base::invokeRestart
[17:47:58.253]                     is.null <- base::is.null
[17:47:58.253]                     muffled <- FALSE
[17:47:58.253]                     if (inherits(cond, "message")) {
[17:47:58.253]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:58.253]                       if (muffled) 
[17:47:58.253]                         invokeRestart("muffleMessage")
[17:47:58.253]                     }
[17:47:58.253]                     else if (inherits(cond, "warning")) {
[17:47:58.253]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:58.253]                       if (muffled) 
[17:47:58.253]                         invokeRestart("muffleWarning")
[17:47:58.253]                     }
[17:47:58.253]                     else if (inherits(cond, "condition")) {
[17:47:58.253]                       if (!is.null(pattern)) {
[17:47:58.253]                         computeRestarts <- base::computeRestarts
[17:47:58.253]                         grepl <- base::grepl
[17:47:58.253]                         restarts <- computeRestarts(cond)
[17:47:58.253]                         for (restart in restarts) {
[17:47:58.253]                           name <- restart$name
[17:47:58.253]                           if (is.null(name)) 
[17:47:58.253]                             next
[17:47:58.253]                           if (!grepl(pattern, name)) 
[17:47:58.253]                             next
[17:47:58.253]                           invokeRestart(restart)
[17:47:58.253]                           muffled <- TRUE
[17:47:58.253]                           break
[17:47:58.253]                         }
[17:47:58.253]                       }
[17:47:58.253]                     }
[17:47:58.253]                     invisible(muffled)
[17:47:58.253]                   }
[17:47:58.253]                   muffleCondition(cond)
[17:47:58.253]                 })
[17:47:58.253]             }))
[17:47:58.253]             future::FutureResult(value = ...future.value$value, 
[17:47:58.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.253]                   ...future.rng), globalenv = if (FALSE) 
[17:47:58.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:58.253]                     ...future.globalenv.names))
[17:47:58.253]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:58.253]         }, condition = base::local({
[17:47:58.253]             c <- base::c
[17:47:58.253]             inherits <- base::inherits
[17:47:58.253]             invokeRestart <- base::invokeRestart
[17:47:58.253]             length <- base::length
[17:47:58.253]             list <- base::list
[17:47:58.253]             seq.int <- base::seq.int
[17:47:58.253]             signalCondition <- base::signalCondition
[17:47:58.253]             sys.calls <- base::sys.calls
[17:47:58.253]             `[[` <- base::`[[`
[17:47:58.253]             `+` <- base::`+`
[17:47:58.253]             `<<-` <- base::`<<-`
[17:47:58.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:58.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:58.253]                   3L)]
[17:47:58.253]             }
[17:47:58.253]             function(cond) {
[17:47:58.253]                 is_error <- inherits(cond, "error")
[17:47:58.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:58.253]                   NULL)
[17:47:58.253]                 if (is_error) {
[17:47:58.253]                   sessionInformation <- function() {
[17:47:58.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:58.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:58.253]                       search = base::search(), system = base::Sys.info())
[17:47:58.253]                   }
[17:47:58.253]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:58.253]                     cond$call), session = sessionInformation(), 
[17:47:58.253]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:58.253]                   signalCondition(cond)
[17:47:58.253]                 }
[17:47:58.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:58.253]                 "immediateCondition"))) {
[17:47:58.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:58.253]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:58.253]                   if (TRUE && !signal) {
[17:47:58.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.253]                     {
[17:47:58.253]                       inherits <- base::inherits
[17:47:58.253]                       invokeRestart <- base::invokeRestart
[17:47:58.253]                       is.null <- base::is.null
[17:47:58.253]                       muffled <- FALSE
[17:47:58.253]                       if (inherits(cond, "message")) {
[17:47:58.253]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.253]                         if (muffled) 
[17:47:58.253]                           invokeRestart("muffleMessage")
[17:47:58.253]                       }
[17:47:58.253]                       else if (inherits(cond, "warning")) {
[17:47:58.253]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.253]                         if (muffled) 
[17:47:58.253]                           invokeRestart("muffleWarning")
[17:47:58.253]                       }
[17:47:58.253]                       else if (inherits(cond, "condition")) {
[17:47:58.253]                         if (!is.null(pattern)) {
[17:47:58.253]                           computeRestarts <- base::computeRestarts
[17:47:58.253]                           grepl <- base::grepl
[17:47:58.253]                           restarts <- computeRestarts(cond)
[17:47:58.253]                           for (restart in restarts) {
[17:47:58.253]                             name <- restart$name
[17:47:58.253]                             if (is.null(name)) 
[17:47:58.253]                               next
[17:47:58.253]                             if (!grepl(pattern, name)) 
[17:47:58.253]                               next
[17:47:58.253]                             invokeRestart(restart)
[17:47:58.253]                             muffled <- TRUE
[17:47:58.253]                             break
[17:47:58.253]                           }
[17:47:58.253]                         }
[17:47:58.253]                       }
[17:47:58.253]                       invisible(muffled)
[17:47:58.253]                     }
[17:47:58.253]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.253]                   }
[17:47:58.253]                 }
[17:47:58.253]                 else {
[17:47:58.253]                   if (TRUE) {
[17:47:58.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.253]                     {
[17:47:58.253]                       inherits <- base::inherits
[17:47:58.253]                       invokeRestart <- base::invokeRestart
[17:47:58.253]                       is.null <- base::is.null
[17:47:58.253]                       muffled <- FALSE
[17:47:58.253]                       if (inherits(cond, "message")) {
[17:47:58.253]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.253]                         if (muffled) 
[17:47:58.253]                           invokeRestart("muffleMessage")
[17:47:58.253]                       }
[17:47:58.253]                       else if (inherits(cond, "warning")) {
[17:47:58.253]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.253]                         if (muffled) 
[17:47:58.253]                           invokeRestart("muffleWarning")
[17:47:58.253]                       }
[17:47:58.253]                       else if (inherits(cond, "condition")) {
[17:47:58.253]                         if (!is.null(pattern)) {
[17:47:58.253]                           computeRestarts <- base::computeRestarts
[17:47:58.253]                           grepl <- base::grepl
[17:47:58.253]                           restarts <- computeRestarts(cond)
[17:47:58.253]                           for (restart in restarts) {
[17:47:58.253]                             name <- restart$name
[17:47:58.253]                             if (is.null(name)) 
[17:47:58.253]                               next
[17:47:58.253]                             if (!grepl(pattern, name)) 
[17:47:58.253]                               next
[17:47:58.253]                             invokeRestart(restart)
[17:47:58.253]                             muffled <- TRUE
[17:47:58.253]                             break
[17:47:58.253]                           }
[17:47:58.253]                         }
[17:47:58.253]                       }
[17:47:58.253]                       invisible(muffled)
[17:47:58.253]                     }
[17:47:58.253]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.253]                   }
[17:47:58.253]                 }
[17:47:58.253]             }
[17:47:58.253]         }))
[17:47:58.253]     }, error = function(ex) {
[17:47:58.253]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:58.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.253]                 ...future.rng), started = ...future.startTime, 
[17:47:58.253]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:58.253]             version = "1.8"), class = "FutureResult")
[17:47:58.253]     }, finally = {
[17:47:58.253]         if (!identical(...future.workdir, getwd())) 
[17:47:58.253]             setwd(...future.workdir)
[17:47:58.253]         {
[17:47:58.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:58.253]                 ...future.oldOptions$nwarnings <- NULL
[17:47:58.253]             }
[17:47:58.253]             base::options(...future.oldOptions)
[17:47:58.253]             if (.Platform$OS.type == "windows") {
[17:47:58.253]                 old_names <- names(...future.oldEnvVars)
[17:47:58.253]                 envs <- base::Sys.getenv()
[17:47:58.253]                 names <- names(envs)
[17:47:58.253]                 common <- intersect(names, old_names)
[17:47:58.253]                 added <- setdiff(names, old_names)
[17:47:58.253]                 removed <- setdiff(old_names, names)
[17:47:58.253]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:58.253]                   envs[common]]
[17:47:58.253]                 NAMES <- toupper(changed)
[17:47:58.253]                 args <- list()
[17:47:58.253]                 for (kk in seq_along(NAMES)) {
[17:47:58.253]                   name <- changed[[kk]]
[17:47:58.253]                   NAME <- NAMES[[kk]]
[17:47:58.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.253]                     next
[17:47:58.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.253]                 }
[17:47:58.253]                 NAMES <- toupper(added)
[17:47:58.253]                 for (kk in seq_along(NAMES)) {
[17:47:58.253]                   name <- added[[kk]]
[17:47:58.253]                   NAME <- NAMES[[kk]]
[17:47:58.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.253]                     next
[17:47:58.253]                   args[[name]] <- ""
[17:47:58.253]                 }
[17:47:58.253]                 NAMES <- toupper(removed)
[17:47:58.253]                 for (kk in seq_along(NAMES)) {
[17:47:58.253]                   name <- removed[[kk]]
[17:47:58.253]                   NAME <- NAMES[[kk]]
[17:47:58.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.253]                     next
[17:47:58.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.253]                 }
[17:47:58.253]                 if (length(args) > 0) 
[17:47:58.253]                   base::do.call(base::Sys.setenv, args = args)
[17:47:58.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:58.253]             }
[17:47:58.253]             else {
[17:47:58.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:58.253]             }
[17:47:58.253]             {
[17:47:58.253]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:58.253]                   0L) {
[17:47:58.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:58.253]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:58.253]                   base::options(opts)
[17:47:58.253]                 }
[17:47:58.253]                 {
[17:47:58.253]                   {
[17:47:58.253]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:58.253]                     NULL
[17:47:58.253]                   }
[17:47:58.253]                   options(future.plan = NULL)
[17:47:58.253]                   if (is.na(NA_character_)) 
[17:47:58.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:58.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:58.253]                     .init = FALSE)
[17:47:58.253]                 }
[17:47:58.253]             }
[17:47:58.253]         }
[17:47:58.253]     })
[17:47:58.253]     if (TRUE) {
[17:47:58.253]         base::sink(type = "output", split = FALSE)
[17:47:58.253]         if (TRUE) {
[17:47:58.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:58.253]         }
[17:47:58.253]         else {
[17:47:58.253]             ...future.result["stdout"] <- base::list(NULL)
[17:47:58.253]         }
[17:47:58.253]         base::close(...future.stdout)
[17:47:58.253]         ...future.stdout <- NULL
[17:47:58.253]     }
[17:47:58.253]     ...future.result$conditions <- ...future.conditions
[17:47:58.253]     ...future.result$finished <- base::Sys.time()
[17:47:58.253]     ...future.result
[17:47:58.253] }
[17:47:58.255] MultisessionFuture started
[17:47:58.256] - Launch lazy future ... done
[17:47:58.256] run() for ‘MultisessionFuture’ ... done
[17:47:58.758] receiveMessageFromWorker() for ClusterFuture ...
[17:47:58.758] - Validating connection of MultisessionFuture
[17:47:58.758] - received message: FutureResult
[17:47:58.759] - Received FutureResult
[17:47:58.759] - Erased future from FutureRegistry
[17:47:58.759] result() for ClusterFuture ...
[17:47:58.759] - result already collected: FutureResult
[17:47:58.759] result() for ClusterFuture ... done
[17:47:58.759] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:58.759] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:47:58.759] getGlobalsAndPackages() ...
[17:47:58.759] Searching for globals...
[17:47:58.760] - globals found: [2] ‘list’, ‘stop’
[17:47:58.760] Searching for globals ... DONE
[17:47:58.760] Resolving globals: FALSE
[17:47:58.761] 
[17:47:58.761] 
[17:47:58.761] getGlobalsAndPackages() ... DONE
[17:47:58.761] run() for ‘Future’ ...
[17:47:58.761] - state: ‘created’
[17:47:58.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:58.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:58.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:58.776]   - Field: ‘node’
[17:47:58.776]   - Field: ‘label’
[17:47:58.776]   - Field: ‘local’
[17:47:58.776]   - Field: ‘owner’
[17:47:58.776]   - Field: ‘envir’
[17:47:58.776]   - Field: ‘workers’
[17:47:58.776]   - Field: ‘packages’
[17:47:58.776]   - Field: ‘gc’
[17:47:58.776]   - Field: ‘conditions’
[17:47:58.776]   - Field: ‘persistent’
[17:47:58.776]   - Field: ‘expr’
[17:47:58.777]   - Field: ‘uuid’
[17:47:58.777]   - Field: ‘seed’
[17:47:58.777]   - Field: ‘version’
[17:47:58.777]   - Field: ‘result’
[17:47:58.777]   - Field: ‘asynchronous’
[17:47:58.777]   - Field: ‘calls’
[17:47:58.777]   - Field: ‘globals’
[17:47:58.777]   - Field: ‘stdout’
[17:47:58.777]   - Field: ‘earlySignal’
[17:47:58.777]   - Field: ‘lazy’
[17:47:58.777]   - Field: ‘state’
[17:47:58.778] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:58.778] - Launch lazy future ...
[17:47:58.778] Packages needed by the future expression (n = 0): <none>
[17:47:58.778] Packages needed by future strategies (n = 0): <none>
[17:47:58.778] {
[17:47:58.778]     {
[17:47:58.778]         {
[17:47:58.778]             ...future.startTime <- base::Sys.time()
[17:47:58.778]             {
[17:47:58.778]                 {
[17:47:58.778]                   {
[17:47:58.778]                     {
[17:47:58.778]                       base::local({
[17:47:58.778]                         has_future <- base::requireNamespace("future", 
[17:47:58.778]                           quietly = TRUE)
[17:47:58.778]                         if (has_future) {
[17:47:58.778]                           ns <- base::getNamespace("future")
[17:47:58.778]                           version <- ns[[".package"]][["version"]]
[17:47:58.778]                           if (is.null(version)) 
[17:47:58.778]                             version <- utils::packageVersion("future")
[17:47:58.778]                         }
[17:47:58.778]                         else {
[17:47:58.778]                           version <- NULL
[17:47:58.778]                         }
[17:47:58.778]                         if (!has_future || version < "1.8.0") {
[17:47:58.778]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:58.778]                             "", base::R.version$version.string), 
[17:47:58.778]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:58.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:58.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:58.778]                               "release", "version")], collapse = " "), 
[17:47:58.778]                             hostname = base::Sys.info()[["nodename"]])
[17:47:58.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:58.778]                             info)
[17:47:58.778]                           info <- base::paste(info, collapse = "; ")
[17:47:58.778]                           if (!has_future) {
[17:47:58.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:58.778]                               info)
[17:47:58.778]                           }
[17:47:58.778]                           else {
[17:47:58.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:58.778]                               info, version)
[17:47:58.778]                           }
[17:47:58.778]                           base::stop(msg)
[17:47:58.778]                         }
[17:47:58.778]                       })
[17:47:58.778]                     }
[17:47:58.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:58.778]                     base::options(mc.cores = 1L)
[17:47:58.778]                   }
[17:47:58.778]                   ...future.strategy.old <- future::plan("list")
[17:47:58.778]                   options(future.plan = NULL)
[17:47:58.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:58.778]                 }
[17:47:58.778]                 ...future.workdir <- getwd()
[17:47:58.778]             }
[17:47:58.778]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:58.778]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:58.778]         }
[17:47:58.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:58.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:58.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:58.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:58.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:58.778]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:58.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:58.778]             base::names(...future.oldOptions))
[17:47:58.778]     }
[17:47:58.778]     if (FALSE) {
[17:47:58.778]     }
[17:47:58.778]     else {
[17:47:58.778]         if (TRUE) {
[17:47:58.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:58.778]                 open = "w")
[17:47:58.778]         }
[17:47:58.778]         else {
[17:47:58.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:58.778]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:58.778]         }
[17:47:58.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:58.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:58.778]             base::sink(type = "output", split = FALSE)
[17:47:58.778]             base::close(...future.stdout)
[17:47:58.778]         }, add = TRUE)
[17:47:58.778]     }
[17:47:58.778]     ...future.frame <- base::sys.nframe()
[17:47:58.778]     ...future.conditions <- base::list()
[17:47:58.778]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:58.778]     if (FALSE) {
[17:47:58.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:58.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:58.778]     }
[17:47:58.778]     ...future.result <- base::tryCatch({
[17:47:58.778]         base::withCallingHandlers({
[17:47:58.778]             ...future.value <- base::withVisible(base::local({
[17:47:58.778]                 ...future.makeSendCondition <- base::local({
[17:47:58.778]                   sendCondition <- NULL
[17:47:58.778]                   function(frame = 1L) {
[17:47:58.778]                     if (is.function(sendCondition)) 
[17:47:58.778]                       return(sendCondition)
[17:47:58.778]                     ns <- getNamespace("parallel")
[17:47:58.778]                     if (exists("sendData", mode = "function", 
[17:47:58.778]                       envir = ns)) {
[17:47:58.778]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:58.778]                         envir = ns)
[17:47:58.778]                       envir <- sys.frame(frame)
[17:47:58.778]                       master <- NULL
[17:47:58.778]                       while (!identical(envir, .GlobalEnv) && 
[17:47:58.778]                         !identical(envir, emptyenv())) {
[17:47:58.778]                         if (exists("master", mode = "list", envir = envir, 
[17:47:58.778]                           inherits = FALSE)) {
[17:47:58.778]                           master <- get("master", mode = "list", 
[17:47:58.778]                             envir = envir, inherits = FALSE)
[17:47:58.778]                           if (inherits(master, c("SOCKnode", 
[17:47:58.778]                             "SOCK0node"))) {
[17:47:58.778]                             sendCondition <<- function(cond) {
[17:47:58.778]                               data <- list(type = "VALUE", value = cond, 
[17:47:58.778]                                 success = TRUE)
[17:47:58.778]                               parallel_sendData(master, data)
[17:47:58.778]                             }
[17:47:58.778]                             return(sendCondition)
[17:47:58.778]                           }
[17:47:58.778]                         }
[17:47:58.778]                         frame <- frame + 1L
[17:47:58.778]                         envir <- sys.frame(frame)
[17:47:58.778]                       }
[17:47:58.778]                     }
[17:47:58.778]                     sendCondition <<- function(cond) NULL
[17:47:58.778]                   }
[17:47:58.778]                 })
[17:47:58.778]                 withCallingHandlers({
[17:47:58.778]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:47:58.778]                 }, immediateCondition = function(cond) {
[17:47:58.778]                   sendCondition <- ...future.makeSendCondition()
[17:47:58.778]                   sendCondition(cond)
[17:47:58.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.778]                   {
[17:47:58.778]                     inherits <- base::inherits
[17:47:58.778]                     invokeRestart <- base::invokeRestart
[17:47:58.778]                     is.null <- base::is.null
[17:47:58.778]                     muffled <- FALSE
[17:47:58.778]                     if (inherits(cond, "message")) {
[17:47:58.778]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:58.778]                       if (muffled) 
[17:47:58.778]                         invokeRestart("muffleMessage")
[17:47:58.778]                     }
[17:47:58.778]                     else if (inherits(cond, "warning")) {
[17:47:58.778]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:58.778]                       if (muffled) 
[17:47:58.778]                         invokeRestart("muffleWarning")
[17:47:58.778]                     }
[17:47:58.778]                     else if (inherits(cond, "condition")) {
[17:47:58.778]                       if (!is.null(pattern)) {
[17:47:58.778]                         computeRestarts <- base::computeRestarts
[17:47:58.778]                         grepl <- base::grepl
[17:47:58.778]                         restarts <- computeRestarts(cond)
[17:47:58.778]                         for (restart in restarts) {
[17:47:58.778]                           name <- restart$name
[17:47:58.778]                           if (is.null(name)) 
[17:47:58.778]                             next
[17:47:58.778]                           if (!grepl(pattern, name)) 
[17:47:58.778]                             next
[17:47:58.778]                           invokeRestart(restart)
[17:47:58.778]                           muffled <- TRUE
[17:47:58.778]                           break
[17:47:58.778]                         }
[17:47:58.778]                       }
[17:47:58.778]                     }
[17:47:58.778]                     invisible(muffled)
[17:47:58.778]                   }
[17:47:58.778]                   muffleCondition(cond)
[17:47:58.778]                 })
[17:47:58.778]             }))
[17:47:58.778]             future::FutureResult(value = ...future.value$value, 
[17:47:58.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.778]                   ...future.rng), globalenv = if (FALSE) 
[17:47:58.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:58.778]                     ...future.globalenv.names))
[17:47:58.778]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:58.778]         }, condition = base::local({
[17:47:58.778]             c <- base::c
[17:47:58.778]             inherits <- base::inherits
[17:47:58.778]             invokeRestart <- base::invokeRestart
[17:47:58.778]             length <- base::length
[17:47:58.778]             list <- base::list
[17:47:58.778]             seq.int <- base::seq.int
[17:47:58.778]             signalCondition <- base::signalCondition
[17:47:58.778]             sys.calls <- base::sys.calls
[17:47:58.778]             `[[` <- base::`[[`
[17:47:58.778]             `+` <- base::`+`
[17:47:58.778]             `<<-` <- base::`<<-`
[17:47:58.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:58.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:58.778]                   3L)]
[17:47:58.778]             }
[17:47:58.778]             function(cond) {
[17:47:58.778]                 is_error <- inherits(cond, "error")
[17:47:58.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:58.778]                   NULL)
[17:47:58.778]                 if (is_error) {
[17:47:58.778]                   sessionInformation <- function() {
[17:47:58.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:58.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:58.778]                       search = base::search(), system = base::Sys.info())
[17:47:58.778]                   }
[17:47:58.778]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:58.778]                     cond$call), session = sessionInformation(), 
[17:47:58.778]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:58.778]                   signalCondition(cond)
[17:47:58.778]                 }
[17:47:58.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:58.778]                 "immediateCondition"))) {
[17:47:58.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:58.778]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:58.778]                   if (TRUE && !signal) {
[17:47:58.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.778]                     {
[17:47:58.778]                       inherits <- base::inherits
[17:47:58.778]                       invokeRestart <- base::invokeRestart
[17:47:58.778]                       is.null <- base::is.null
[17:47:58.778]                       muffled <- FALSE
[17:47:58.778]                       if (inherits(cond, "message")) {
[17:47:58.778]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.778]                         if (muffled) 
[17:47:58.778]                           invokeRestart("muffleMessage")
[17:47:58.778]                       }
[17:47:58.778]                       else if (inherits(cond, "warning")) {
[17:47:58.778]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.778]                         if (muffled) 
[17:47:58.778]                           invokeRestart("muffleWarning")
[17:47:58.778]                       }
[17:47:58.778]                       else if (inherits(cond, "condition")) {
[17:47:58.778]                         if (!is.null(pattern)) {
[17:47:58.778]                           computeRestarts <- base::computeRestarts
[17:47:58.778]                           grepl <- base::grepl
[17:47:58.778]                           restarts <- computeRestarts(cond)
[17:47:58.778]                           for (restart in restarts) {
[17:47:58.778]                             name <- restart$name
[17:47:58.778]                             if (is.null(name)) 
[17:47:58.778]                               next
[17:47:58.778]                             if (!grepl(pattern, name)) 
[17:47:58.778]                               next
[17:47:58.778]                             invokeRestart(restart)
[17:47:58.778]                             muffled <- TRUE
[17:47:58.778]                             break
[17:47:58.778]                           }
[17:47:58.778]                         }
[17:47:58.778]                       }
[17:47:58.778]                       invisible(muffled)
[17:47:58.778]                     }
[17:47:58.778]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.778]                   }
[17:47:58.778]                 }
[17:47:58.778]                 else {
[17:47:58.778]                   if (TRUE) {
[17:47:58.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.778]                     {
[17:47:58.778]                       inherits <- base::inherits
[17:47:58.778]                       invokeRestart <- base::invokeRestart
[17:47:58.778]                       is.null <- base::is.null
[17:47:58.778]                       muffled <- FALSE
[17:47:58.778]                       if (inherits(cond, "message")) {
[17:47:58.778]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.778]                         if (muffled) 
[17:47:58.778]                           invokeRestart("muffleMessage")
[17:47:58.778]                       }
[17:47:58.778]                       else if (inherits(cond, "warning")) {
[17:47:58.778]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.778]                         if (muffled) 
[17:47:58.778]                           invokeRestart("muffleWarning")
[17:47:58.778]                       }
[17:47:58.778]                       else if (inherits(cond, "condition")) {
[17:47:58.778]                         if (!is.null(pattern)) {
[17:47:58.778]                           computeRestarts <- base::computeRestarts
[17:47:58.778]                           grepl <- base::grepl
[17:47:58.778]                           restarts <- computeRestarts(cond)
[17:47:58.778]                           for (restart in restarts) {
[17:47:58.778]                             name <- restart$name
[17:47:58.778]                             if (is.null(name)) 
[17:47:58.778]                               next
[17:47:58.778]                             if (!grepl(pattern, name)) 
[17:47:58.778]                               next
[17:47:58.778]                             invokeRestart(restart)
[17:47:58.778]                             muffled <- TRUE
[17:47:58.778]                             break
[17:47:58.778]                           }
[17:47:58.778]                         }
[17:47:58.778]                       }
[17:47:58.778]                       invisible(muffled)
[17:47:58.778]                     }
[17:47:58.778]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.778]                   }
[17:47:58.778]                 }
[17:47:58.778]             }
[17:47:58.778]         }))
[17:47:58.778]     }, error = function(ex) {
[17:47:58.778]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:58.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.778]                 ...future.rng), started = ...future.startTime, 
[17:47:58.778]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:58.778]             version = "1.8"), class = "FutureResult")
[17:47:58.778]     }, finally = {
[17:47:58.778]         if (!identical(...future.workdir, getwd())) 
[17:47:58.778]             setwd(...future.workdir)
[17:47:58.778]         {
[17:47:58.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:58.778]                 ...future.oldOptions$nwarnings <- NULL
[17:47:58.778]             }
[17:47:58.778]             base::options(...future.oldOptions)
[17:47:58.778]             if (.Platform$OS.type == "windows") {
[17:47:58.778]                 old_names <- names(...future.oldEnvVars)
[17:47:58.778]                 envs <- base::Sys.getenv()
[17:47:58.778]                 names <- names(envs)
[17:47:58.778]                 common <- intersect(names, old_names)
[17:47:58.778]                 added <- setdiff(names, old_names)
[17:47:58.778]                 removed <- setdiff(old_names, names)
[17:47:58.778]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:58.778]                   envs[common]]
[17:47:58.778]                 NAMES <- toupper(changed)
[17:47:58.778]                 args <- list()
[17:47:58.778]                 for (kk in seq_along(NAMES)) {
[17:47:58.778]                   name <- changed[[kk]]
[17:47:58.778]                   NAME <- NAMES[[kk]]
[17:47:58.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.778]                     next
[17:47:58.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.778]                 }
[17:47:58.778]                 NAMES <- toupper(added)
[17:47:58.778]                 for (kk in seq_along(NAMES)) {
[17:47:58.778]                   name <- added[[kk]]
[17:47:58.778]                   NAME <- NAMES[[kk]]
[17:47:58.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.778]                     next
[17:47:58.778]                   args[[name]] <- ""
[17:47:58.778]                 }
[17:47:58.778]                 NAMES <- toupper(removed)
[17:47:58.778]                 for (kk in seq_along(NAMES)) {
[17:47:58.778]                   name <- removed[[kk]]
[17:47:58.778]                   NAME <- NAMES[[kk]]
[17:47:58.778]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.778]                     next
[17:47:58.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.778]                 }
[17:47:58.778]                 if (length(args) > 0) 
[17:47:58.778]                   base::do.call(base::Sys.setenv, args = args)
[17:47:58.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:58.778]             }
[17:47:58.778]             else {
[17:47:58.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:58.778]             }
[17:47:58.778]             {
[17:47:58.778]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:58.778]                   0L) {
[17:47:58.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:58.778]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:58.778]                   base::options(opts)
[17:47:58.778]                 }
[17:47:58.778]                 {
[17:47:58.778]                   {
[17:47:58.778]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:58.778]                     NULL
[17:47:58.778]                   }
[17:47:58.778]                   options(future.plan = NULL)
[17:47:58.778]                   if (is.na(NA_character_)) 
[17:47:58.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:58.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:58.778]                     .init = FALSE)
[17:47:58.778]                 }
[17:47:58.778]             }
[17:47:58.778]         }
[17:47:58.778]     })
[17:47:58.778]     if (TRUE) {
[17:47:58.778]         base::sink(type = "output", split = FALSE)
[17:47:58.778]         if (TRUE) {
[17:47:58.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:58.778]         }
[17:47:58.778]         else {
[17:47:58.778]             ...future.result["stdout"] <- base::list(NULL)
[17:47:58.778]         }
[17:47:58.778]         base::close(...future.stdout)
[17:47:58.778]         ...future.stdout <- NULL
[17:47:58.778]     }
[17:47:58.778]     ...future.result$conditions <- ...future.conditions
[17:47:58.778]     ...future.result$finished <- base::Sys.time()
[17:47:58.778]     ...future.result
[17:47:58.778] }
[17:47:58.781] MultisessionFuture started
[17:47:58.782] - Launch lazy future ... done
[17:47:58.782] run() for ‘MultisessionFuture’ ... done
[17:47:58.783] receiveMessageFromWorker() for ClusterFuture ...
[17:47:58.783] - Validating connection of MultisessionFuture
[17:47:58.784] - received message: FutureResult
[17:47:58.784] - Received FutureResult
[17:47:58.784] - Erased future from FutureRegistry
[17:47:58.784] result() for ClusterFuture ...
[17:47:58.784] - result already collected: FutureResult
[17:47:58.784] result() for ClusterFuture ... done
[17:47:58.784] signalConditions() ...
[17:47:58.784]  - include = ‘immediateCondition’
[17:47:58.784]  - exclude = 
[17:47:58.785]  - resignal = FALSE
[17:47:58.785]  - Number of conditions: 1
[17:47:58.785] signalConditions() ... done
[17:47:58.785] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:58.785] A MultisessionFuture was resolved (result was not collected)
[17:47:58.785] getGlobalsAndPackages() ...
[17:47:58.785] Searching for globals...
[17:47:58.786] - globals found: [2] ‘list’, ‘stop’
[17:47:58.786] Searching for globals ... DONE
[17:47:58.786] Resolving globals: FALSE
[17:47:58.786] 
[17:47:58.786] 
[17:47:58.786] getGlobalsAndPackages() ... DONE
[17:47:58.787] run() for ‘Future’ ...
[17:47:58.787] - state: ‘created’
[17:47:58.787] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:58.801] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:58.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:58.801]   - Field: ‘node’
[17:47:58.801]   - Field: ‘label’
[17:47:58.801]   - Field: ‘local’
[17:47:58.801]   - Field: ‘owner’
[17:47:58.801]   - Field: ‘envir’
[17:47:58.802]   - Field: ‘workers’
[17:47:58.802]   - Field: ‘packages’
[17:47:58.802]   - Field: ‘gc’
[17:47:58.802]   - Field: ‘conditions’
[17:47:58.802]   - Field: ‘persistent’
[17:47:58.802]   - Field: ‘expr’
[17:47:58.802]   - Field: ‘uuid’
[17:47:58.802]   - Field: ‘seed’
[17:47:58.802]   - Field: ‘version’
[17:47:58.802]   - Field: ‘result’
[17:47:58.802]   - Field: ‘asynchronous’
[17:47:58.803]   - Field: ‘calls’
[17:47:58.803]   - Field: ‘globals’
[17:47:58.803]   - Field: ‘stdout’
[17:47:58.803]   - Field: ‘earlySignal’
[17:47:58.803]   - Field: ‘lazy’
[17:47:58.803]   - Field: ‘state’
[17:47:58.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:58.803] - Launch lazy future ...
[17:47:58.803] Packages needed by the future expression (n = 0): <none>
[17:47:58.804] Packages needed by future strategies (n = 0): <none>
[17:47:58.804] {
[17:47:58.804]     {
[17:47:58.804]         {
[17:47:58.804]             ...future.startTime <- base::Sys.time()
[17:47:58.804]             {
[17:47:58.804]                 {
[17:47:58.804]                   {
[17:47:58.804]                     {
[17:47:58.804]                       base::local({
[17:47:58.804]                         has_future <- base::requireNamespace("future", 
[17:47:58.804]                           quietly = TRUE)
[17:47:58.804]                         if (has_future) {
[17:47:58.804]                           ns <- base::getNamespace("future")
[17:47:58.804]                           version <- ns[[".package"]][["version"]]
[17:47:58.804]                           if (is.null(version)) 
[17:47:58.804]                             version <- utils::packageVersion("future")
[17:47:58.804]                         }
[17:47:58.804]                         else {
[17:47:58.804]                           version <- NULL
[17:47:58.804]                         }
[17:47:58.804]                         if (!has_future || version < "1.8.0") {
[17:47:58.804]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:58.804]                             "", base::R.version$version.string), 
[17:47:58.804]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:58.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:58.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:58.804]                               "release", "version")], collapse = " "), 
[17:47:58.804]                             hostname = base::Sys.info()[["nodename"]])
[17:47:58.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:58.804]                             info)
[17:47:58.804]                           info <- base::paste(info, collapse = "; ")
[17:47:58.804]                           if (!has_future) {
[17:47:58.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:58.804]                               info)
[17:47:58.804]                           }
[17:47:58.804]                           else {
[17:47:58.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:58.804]                               info, version)
[17:47:58.804]                           }
[17:47:58.804]                           base::stop(msg)
[17:47:58.804]                         }
[17:47:58.804]                       })
[17:47:58.804]                     }
[17:47:58.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:58.804]                     base::options(mc.cores = 1L)
[17:47:58.804]                   }
[17:47:58.804]                   ...future.strategy.old <- future::plan("list")
[17:47:58.804]                   options(future.plan = NULL)
[17:47:58.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:58.804]                 }
[17:47:58.804]                 ...future.workdir <- getwd()
[17:47:58.804]             }
[17:47:58.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:58.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:58.804]         }
[17:47:58.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:58.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:58.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:58.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:58.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:58.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:58.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:58.804]             base::names(...future.oldOptions))
[17:47:58.804]     }
[17:47:58.804]     if (FALSE) {
[17:47:58.804]     }
[17:47:58.804]     else {
[17:47:58.804]         if (TRUE) {
[17:47:58.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:58.804]                 open = "w")
[17:47:58.804]         }
[17:47:58.804]         else {
[17:47:58.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:58.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:58.804]         }
[17:47:58.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:58.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:58.804]             base::sink(type = "output", split = FALSE)
[17:47:58.804]             base::close(...future.stdout)
[17:47:58.804]         }, add = TRUE)
[17:47:58.804]     }
[17:47:58.804]     ...future.frame <- base::sys.nframe()
[17:47:58.804]     ...future.conditions <- base::list()
[17:47:58.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:58.804]     if (FALSE) {
[17:47:58.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:58.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:58.804]     }
[17:47:58.804]     ...future.result <- base::tryCatch({
[17:47:58.804]         base::withCallingHandlers({
[17:47:58.804]             ...future.value <- base::withVisible(base::local({
[17:47:58.804]                 ...future.makeSendCondition <- base::local({
[17:47:58.804]                   sendCondition <- NULL
[17:47:58.804]                   function(frame = 1L) {
[17:47:58.804]                     if (is.function(sendCondition)) 
[17:47:58.804]                       return(sendCondition)
[17:47:58.804]                     ns <- getNamespace("parallel")
[17:47:58.804]                     if (exists("sendData", mode = "function", 
[17:47:58.804]                       envir = ns)) {
[17:47:58.804]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:58.804]                         envir = ns)
[17:47:58.804]                       envir <- sys.frame(frame)
[17:47:58.804]                       master <- NULL
[17:47:58.804]                       while (!identical(envir, .GlobalEnv) && 
[17:47:58.804]                         !identical(envir, emptyenv())) {
[17:47:58.804]                         if (exists("master", mode = "list", envir = envir, 
[17:47:58.804]                           inherits = FALSE)) {
[17:47:58.804]                           master <- get("master", mode = "list", 
[17:47:58.804]                             envir = envir, inherits = FALSE)
[17:47:58.804]                           if (inherits(master, c("SOCKnode", 
[17:47:58.804]                             "SOCK0node"))) {
[17:47:58.804]                             sendCondition <<- function(cond) {
[17:47:58.804]                               data <- list(type = "VALUE", value = cond, 
[17:47:58.804]                                 success = TRUE)
[17:47:58.804]                               parallel_sendData(master, data)
[17:47:58.804]                             }
[17:47:58.804]                             return(sendCondition)
[17:47:58.804]                           }
[17:47:58.804]                         }
[17:47:58.804]                         frame <- frame + 1L
[17:47:58.804]                         envir <- sys.frame(frame)
[17:47:58.804]                       }
[17:47:58.804]                     }
[17:47:58.804]                     sendCondition <<- function(cond) NULL
[17:47:58.804]                   }
[17:47:58.804]                 })
[17:47:58.804]                 withCallingHandlers({
[17:47:58.804]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:47:58.804]                 }, immediateCondition = function(cond) {
[17:47:58.804]                   sendCondition <- ...future.makeSendCondition()
[17:47:58.804]                   sendCondition(cond)
[17:47:58.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.804]                   {
[17:47:58.804]                     inherits <- base::inherits
[17:47:58.804]                     invokeRestart <- base::invokeRestart
[17:47:58.804]                     is.null <- base::is.null
[17:47:58.804]                     muffled <- FALSE
[17:47:58.804]                     if (inherits(cond, "message")) {
[17:47:58.804]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:58.804]                       if (muffled) 
[17:47:58.804]                         invokeRestart("muffleMessage")
[17:47:58.804]                     }
[17:47:58.804]                     else if (inherits(cond, "warning")) {
[17:47:58.804]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:58.804]                       if (muffled) 
[17:47:58.804]                         invokeRestart("muffleWarning")
[17:47:58.804]                     }
[17:47:58.804]                     else if (inherits(cond, "condition")) {
[17:47:58.804]                       if (!is.null(pattern)) {
[17:47:58.804]                         computeRestarts <- base::computeRestarts
[17:47:58.804]                         grepl <- base::grepl
[17:47:58.804]                         restarts <- computeRestarts(cond)
[17:47:58.804]                         for (restart in restarts) {
[17:47:58.804]                           name <- restart$name
[17:47:58.804]                           if (is.null(name)) 
[17:47:58.804]                             next
[17:47:58.804]                           if (!grepl(pattern, name)) 
[17:47:58.804]                             next
[17:47:58.804]                           invokeRestart(restart)
[17:47:58.804]                           muffled <- TRUE
[17:47:58.804]                           break
[17:47:58.804]                         }
[17:47:58.804]                       }
[17:47:58.804]                     }
[17:47:58.804]                     invisible(muffled)
[17:47:58.804]                   }
[17:47:58.804]                   muffleCondition(cond)
[17:47:58.804]                 })
[17:47:58.804]             }))
[17:47:58.804]             future::FutureResult(value = ...future.value$value, 
[17:47:58.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.804]                   ...future.rng), globalenv = if (FALSE) 
[17:47:58.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:58.804]                     ...future.globalenv.names))
[17:47:58.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:58.804]         }, condition = base::local({
[17:47:58.804]             c <- base::c
[17:47:58.804]             inherits <- base::inherits
[17:47:58.804]             invokeRestart <- base::invokeRestart
[17:47:58.804]             length <- base::length
[17:47:58.804]             list <- base::list
[17:47:58.804]             seq.int <- base::seq.int
[17:47:58.804]             signalCondition <- base::signalCondition
[17:47:58.804]             sys.calls <- base::sys.calls
[17:47:58.804]             `[[` <- base::`[[`
[17:47:58.804]             `+` <- base::`+`
[17:47:58.804]             `<<-` <- base::`<<-`
[17:47:58.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:58.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:58.804]                   3L)]
[17:47:58.804]             }
[17:47:58.804]             function(cond) {
[17:47:58.804]                 is_error <- inherits(cond, "error")
[17:47:58.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:58.804]                   NULL)
[17:47:58.804]                 if (is_error) {
[17:47:58.804]                   sessionInformation <- function() {
[17:47:58.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:58.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:58.804]                       search = base::search(), system = base::Sys.info())
[17:47:58.804]                   }
[17:47:58.804]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:58.804]                     cond$call), session = sessionInformation(), 
[17:47:58.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:58.804]                   signalCondition(cond)
[17:47:58.804]                 }
[17:47:58.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:58.804]                 "immediateCondition"))) {
[17:47:58.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:58.804]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:58.804]                   if (TRUE && !signal) {
[17:47:58.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.804]                     {
[17:47:58.804]                       inherits <- base::inherits
[17:47:58.804]                       invokeRestart <- base::invokeRestart
[17:47:58.804]                       is.null <- base::is.null
[17:47:58.804]                       muffled <- FALSE
[17:47:58.804]                       if (inherits(cond, "message")) {
[17:47:58.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.804]                         if (muffled) 
[17:47:58.804]                           invokeRestart("muffleMessage")
[17:47:58.804]                       }
[17:47:58.804]                       else if (inherits(cond, "warning")) {
[17:47:58.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.804]                         if (muffled) 
[17:47:58.804]                           invokeRestart("muffleWarning")
[17:47:58.804]                       }
[17:47:58.804]                       else if (inherits(cond, "condition")) {
[17:47:58.804]                         if (!is.null(pattern)) {
[17:47:58.804]                           computeRestarts <- base::computeRestarts
[17:47:58.804]                           grepl <- base::grepl
[17:47:58.804]                           restarts <- computeRestarts(cond)
[17:47:58.804]                           for (restart in restarts) {
[17:47:58.804]                             name <- restart$name
[17:47:58.804]                             if (is.null(name)) 
[17:47:58.804]                               next
[17:47:58.804]                             if (!grepl(pattern, name)) 
[17:47:58.804]                               next
[17:47:58.804]                             invokeRestart(restart)
[17:47:58.804]                             muffled <- TRUE
[17:47:58.804]                             break
[17:47:58.804]                           }
[17:47:58.804]                         }
[17:47:58.804]                       }
[17:47:58.804]                       invisible(muffled)
[17:47:58.804]                     }
[17:47:58.804]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.804]                   }
[17:47:58.804]                 }
[17:47:58.804]                 else {
[17:47:58.804]                   if (TRUE) {
[17:47:58.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.804]                     {
[17:47:58.804]                       inherits <- base::inherits
[17:47:58.804]                       invokeRestart <- base::invokeRestart
[17:47:58.804]                       is.null <- base::is.null
[17:47:58.804]                       muffled <- FALSE
[17:47:58.804]                       if (inherits(cond, "message")) {
[17:47:58.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.804]                         if (muffled) 
[17:47:58.804]                           invokeRestart("muffleMessage")
[17:47:58.804]                       }
[17:47:58.804]                       else if (inherits(cond, "warning")) {
[17:47:58.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.804]                         if (muffled) 
[17:47:58.804]                           invokeRestart("muffleWarning")
[17:47:58.804]                       }
[17:47:58.804]                       else if (inherits(cond, "condition")) {
[17:47:58.804]                         if (!is.null(pattern)) {
[17:47:58.804]                           computeRestarts <- base::computeRestarts
[17:47:58.804]                           grepl <- base::grepl
[17:47:58.804]                           restarts <- computeRestarts(cond)
[17:47:58.804]                           for (restart in restarts) {
[17:47:58.804]                             name <- restart$name
[17:47:58.804]                             if (is.null(name)) 
[17:47:58.804]                               next
[17:47:58.804]                             if (!grepl(pattern, name)) 
[17:47:58.804]                               next
[17:47:58.804]                             invokeRestart(restart)
[17:47:58.804]                             muffled <- TRUE
[17:47:58.804]                             break
[17:47:58.804]                           }
[17:47:58.804]                         }
[17:47:58.804]                       }
[17:47:58.804]                       invisible(muffled)
[17:47:58.804]                     }
[17:47:58.804]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.804]                   }
[17:47:58.804]                 }
[17:47:58.804]             }
[17:47:58.804]         }))
[17:47:58.804]     }, error = function(ex) {
[17:47:58.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:58.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.804]                 ...future.rng), started = ...future.startTime, 
[17:47:58.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:58.804]             version = "1.8"), class = "FutureResult")
[17:47:58.804]     }, finally = {
[17:47:58.804]         if (!identical(...future.workdir, getwd())) 
[17:47:58.804]             setwd(...future.workdir)
[17:47:58.804]         {
[17:47:58.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:58.804]                 ...future.oldOptions$nwarnings <- NULL
[17:47:58.804]             }
[17:47:58.804]             base::options(...future.oldOptions)
[17:47:58.804]             if (.Platform$OS.type == "windows") {
[17:47:58.804]                 old_names <- names(...future.oldEnvVars)
[17:47:58.804]                 envs <- base::Sys.getenv()
[17:47:58.804]                 names <- names(envs)
[17:47:58.804]                 common <- intersect(names, old_names)
[17:47:58.804]                 added <- setdiff(names, old_names)
[17:47:58.804]                 removed <- setdiff(old_names, names)
[17:47:58.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:58.804]                   envs[common]]
[17:47:58.804]                 NAMES <- toupper(changed)
[17:47:58.804]                 args <- list()
[17:47:58.804]                 for (kk in seq_along(NAMES)) {
[17:47:58.804]                   name <- changed[[kk]]
[17:47:58.804]                   NAME <- NAMES[[kk]]
[17:47:58.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.804]                     next
[17:47:58.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.804]                 }
[17:47:58.804]                 NAMES <- toupper(added)
[17:47:58.804]                 for (kk in seq_along(NAMES)) {
[17:47:58.804]                   name <- added[[kk]]
[17:47:58.804]                   NAME <- NAMES[[kk]]
[17:47:58.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.804]                     next
[17:47:58.804]                   args[[name]] <- ""
[17:47:58.804]                 }
[17:47:58.804]                 NAMES <- toupper(removed)
[17:47:58.804]                 for (kk in seq_along(NAMES)) {
[17:47:58.804]                   name <- removed[[kk]]
[17:47:58.804]                   NAME <- NAMES[[kk]]
[17:47:58.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.804]                     next
[17:47:58.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.804]                 }
[17:47:58.804]                 if (length(args) > 0) 
[17:47:58.804]                   base::do.call(base::Sys.setenv, args = args)
[17:47:58.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:58.804]             }
[17:47:58.804]             else {
[17:47:58.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:58.804]             }
[17:47:58.804]             {
[17:47:58.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:58.804]                   0L) {
[17:47:58.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:58.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:58.804]                   base::options(opts)
[17:47:58.804]                 }
[17:47:58.804]                 {
[17:47:58.804]                   {
[17:47:58.804]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:58.804]                     NULL
[17:47:58.804]                   }
[17:47:58.804]                   options(future.plan = NULL)
[17:47:58.804]                   if (is.na(NA_character_)) 
[17:47:58.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:58.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:58.804]                     .init = FALSE)
[17:47:58.804]                 }
[17:47:58.804]             }
[17:47:58.804]         }
[17:47:58.804]     })
[17:47:58.804]     if (TRUE) {
[17:47:58.804]         base::sink(type = "output", split = FALSE)
[17:47:58.804]         if (TRUE) {
[17:47:58.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:58.804]         }
[17:47:58.804]         else {
[17:47:58.804]             ...future.result["stdout"] <- base::list(NULL)
[17:47:58.804]         }
[17:47:58.804]         base::close(...future.stdout)
[17:47:58.804]         ...future.stdout <- NULL
[17:47:58.804]     }
[17:47:58.804]     ...future.result$conditions <- ...future.conditions
[17:47:58.804]     ...future.result$finished <- base::Sys.time()
[17:47:58.804]     ...future.result
[17:47:58.804] }
[17:47:58.807] MultisessionFuture started
[17:47:58.807] - Launch lazy future ... done
[17:47:58.807] run() for ‘MultisessionFuture’ ... done
[17:47:58.809] receiveMessageFromWorker() for ClusterFuture ...
[17:47:58.809] - Validating connection of MultisessionFuture
[17:47:58.809] - received message: FutureResult
[17:47:58.809] - Received FutureResult
[17:47:58.812] - Erased future from FutureRegistry
[17:47:58.812] result() for ClusterFuture ...
[17:47:58.812] - result already collected: FutureResult
[17:47:58.812] result() for ClusterFuture ... done
[17:47:58.812] signalConditions() ...
[17:47:58.812]  - include = ‘immediateCondition’
[17:47:58.812]  - exclude = 
[17:47:58.812]  - resignal = FALSE
[17:47:58.813]  - Number of conditions: 1
[17:47:58.813] signalConditions() ... done
[17:47:58.813] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:58.813] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[17:47:58.813] getGlobalsAndPackages() ...
[17:47:58.813] Searching for globals...
[17:47:58.814] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:58.814] Searching for globals ... DONE
[17:47:58.814] Resolving globals: FALSE
[17:47:58.815] 
[17:47:58.815] 
[17:47:58.815] getGlobalsAndPackages() ... DONE
[17:47:58.815] run() for ‘Future’ ...
[17:47:58.815] - state: ‘created’
[17:47:58.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:58.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:58.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:58.829]   - Field: ‘node’
[17:47:58.829]   - Field: ‘label’
[17:47:58.829]   - Field: ‘local’
[17:47:58.829]   - Field: ‘owner’
[17:47:58.829]   - Field: ‘envir’
[17:47:58.830]   - Field: ‘workers’
[17:47:58.830]   - Field: ‘packages’
[17:47:58.830]   - Field: ‘gc’
[17:47:58.830]   - Field: ‘conditions’
[17:47:58.830]   - Field: ‘persistent’
[17:47:58.830]   - Field: ‘expr’
[17:47:58.830]   - Field: ‘uuid’
[17:47:58.830]   - Field: ‘seed’
[17:47:58.830]   - Field: ‘version’
[17:47:58.830]   - Field: ‘result’
[17:47:58.830]   - Field: ‘asynchronous’
[17:47:58.831]   - Field: ‘calls’
[17:47:58.831]   - Field: ‘globals’
[17:47:58.831]   - Field: ‘stdout’
[17:47:58.831]   - Field: ‘earlySignal’
[17:47:58.831]   - Field: ‘lazy’
[17:47:58.831]   - Field: ‘state’
[17:47:58.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:58.831] - Launch lazy future ...
[17:47:58.831] Packages needed by the future expression (n = 0): <none>
[17:47:58.832] Packages needed by future strategies (n = 0): <none>
[17:47:58.832] {
[17:47:58.832]     {
[17:47:58.832]         {
[17:47:58.832]             ...future.startTime <- base::Sys.time()
[17:47:58.832]             {
[17:47:58.832]                 {
[17:47:58.832]                   {
[17:47:58.832]                     {
[17:47:58.832]                       base::local({
[17:47:58.832]                         has_future <- base::requireNamespace("future", 
[17:47:58.832]                           quietly = TRUE)
[17:47:58.832]                         if (has_future) {
[17:47:58.832]                           ns <- base::getNamespace("future")
[17:47:58.832]                           version <- ns[[".package"]][["version"]]
[17:47:58.832]                           if (is.null(version)) 
[17:47:58.832]                             version <- utils::packageVersion("future")
[17:47:58.832]                         }
[17:47:58.832]                         else {
[17:47:58.832]                           version <- NULL
[17:47:58.832]                         }
[17:47:58.832]                         if (!has_future || version < "1.8.0") {
[17:47:58.832]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:58.832]                             "", base::R.version$version.string), 
[17:47:58.832]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:58.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:58.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:58.832]                               "release", "version")], collapse = " "), 
[17:47:58.832]                             hostname = base::Sys.info()[["nodename"]])
[17:47:58.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:58.832]                             info)
[17:47:58.832]                           info <- base::paste(info, collapse = "; ")
[17:47:58.832]                           if (!has_future) {
[17:47:58.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:58.832]                               info)
[17:47:58.832]                           }
[17:47:58.832]                           else {
[17:47:58.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:58.832]                               info, version)
[17:47:58.832]                           }
[17:47:58.832]                           base::stop(msg)
[17:47:58.832]                         }
[17:47:58.832]                       })
[17:47:58.832]                     }
[17:47:58.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:58.832]                     base::options(mc.cores = 1L)
[17:47:58.832]                   }
[17:47:58.832]                   ...future.strategy.old <- future::plan("list")
[17:47:58.832]                   options(future.plan = NULL)
[17:47:58.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:58.832]                 }
[17:47:58.832]                 ...future.workdir <- getwd()
[17:47:58.832]             }
[17:47:58.832]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:58.832]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:58.832]         }
[17:47:58.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:58.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:58.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:58.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:58.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:58.832]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:58.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:58.832]             base::names(...future.oldOptions))
[17:47:58.832]     }
[17:47:58.832]     if (FALSE) {
[17:47:58.832]     }
[17:47:58.832]     else {
[17:47:58.832]         if (TRUE) {
[17:47:58.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:58.832]                 open = "w")
[17:47:58.832]         }
[17:47:58.832]         else {
[17:47:58.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:58.832]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:58.832]         }
[17:47:58.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:58.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:58.832]             base::sink(type = "output", split = FALSE)
[17:47:58.832]             base::close(...future.stdout)
[17:47:58.832]         }, add = TRUE)
[17:47:58.832]     }
[17:47:58.832]     ...future.frame <- base::sys.nframe()
[17:47:58.832]     ...future.conditions <- base::list()
[17:47:58.832]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:58.832]     if (FALSE) {
[17:47:58.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:58.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:58.832]     }
[17:47:58.832]     ...future.result <- base::tryCatch({
[17:47:58.832]         base::withCallingHandlers({
[17:47:58.832]             ...future.value <- base::withVisible(base::local({
[17:47:58.832]                 ...future.makeSendCondition <- base::local({
[17:47:58.832]                   sendCondition <- NULL
[17:47:58.832]                   function(frame = 1L) {
[17:47:58.832]                     if (is.function(sendCondition)) 
[17:47:58.832]                       return(sendCondition)
[17:47:58.832]                     ns <- getNamespace("parallel")
[17:47:58.832]                     if (exists("sendData", mode = "function", 
[17:47:58.832]                       envir = ns)) {
[17:47:58.832]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:58.832]                         envir = ns)
[17:47:58.832]                       envir <- sys.frame(frame)
[17:47:58.832]                       master <- NULL
[17:47:58.832]                       while (!identical(envir, .GlobalEnv) && 
[17:47:58.832]                         !identical(envir, emptyenv())) {
[17:47:58.832]                         if (exists("master", mode = "list", envir = envir, 
[17:47:58.832]                           inherits = FALSE)) {
[17:47:58.832]                           master <- get("master", mode = "list", 
[17:47:58.832]                             envir = envir, inherits = FALSE)
[17:47:58.832]                           if (inherits(master, c("SOCKnode", 
[17:47:58.832]                             "SOCK0node"))) {
[17:47:58.832]                             sendCondition <<- function(cond) {
[17:47:58.832]                               data <- list(type = "VALUE", value = cond, 
[17:47:58.832]                                 success = TRUE)
[17:47:58.832]                               parallel_sendData(master, data)
[17:47:58.832]                             }
[17:47:58.832]                             return(sendCondition)
[17:47:58.832]                           }
[17:47:58.832]                         }
[17:47:58.832]                         frame <- frame + 1L
[17:47:58.832]                         envir <- sys.frame(frame)
[17:47:58.832]                       }
[17:47:58.832]                     }
[17:47:58.832]                     sendCondition <<- function(cond) NULL
[17:47:58.832]                   }
[17:47:58.832]                 })
[17:47:58.832]                 withCallingHandlers({
[17:47:58.832]                   {
[17:47:58.832]                     Sys.sleep(0.5)
[17:47:58.832]                     list(a = 1, b = 42L)
[17:47:58.832]                   }
[17:47:58.832]                 }, immediateCondition = function(cond) {
[17:47:58.832]                   sendCondition <- ...future.makeSendCondition()
[17:47:58.832]                   sendCondition(cond)
[17:47:58.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.832]                   {
[17:47:58.832]                     inherits <- base::inherits
[17:47:58.832]                     invokeRestart <- base::invokeRestart
[17:47:58.832]                     is.null <- base::is.null
[17:47:58.832]                     muffled <- FALSE
[17:47:58.832]                     if (inherits(cond, "message")) {
[17:47:58.832]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:58.832]                       if (muffled) 
[17:47:58.832]                         invokeRestart("muffleMessage")
[17:47:58.832]                     }
[17:47:58.832]                     else if (inherits(cond, "warning")) {
[17:47:58.832]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:58.832]                       if (muffled) 
[17:47:58.832]                         invokeRestart("muffleWarning")
[17:47:58.832]                     }
[17:47:58.832]                     else if (inherits(cond, "condition")) {
[17:47:58.832]                       if (!is.null(pattern)) {
[17:47:58.832]                         computeRestarts <- base::computeRestarts
[17:47:58.832]                         grepl <- base::grepl
[17:47:58.832]                         restarts <- computeRestarts(cond)
[17:47:58.832]                         for (restart in restarts) {
[17:47:58.832]                           name <- restart$name
[17:47:58.832]                           if (is.null(name)) 
[17:47:58.832]                             next
[17:47:58.832]                           if (!grepl(pattern, name)) 
[17:47:58.832]                             next
[17:47:58.832]                           invokeRestart(restart)
[17:47:58.832]                           muffled <- TRUE
[17:47:58.832]                           break
[17:47:58.832]                         }
[17:47:58.832]                       }
[17:47:58.832]                     }
[17:47:58.832]                     invisible(muffled)
[17:47:58.832]                   }
[17:47:58.832]                   muffleCondition(cond)
[17:47:58.832]                 })
[17:47:58.832]             }))
[17:47:58.832]             future::FutureResult(value = ...future.value$value, 
[17:47:58.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.832]                   ...future.rng), globalenv = if (FALSE) 
[17:47:58.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:58.832]                     ...future.globalenv.names))
[17:47:58.832]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:58.832]         }, condition = base::local({
[17:47:58.832]             c <- base::c
[17:47:58.832]             inherits <- base::inherits
[17:47:58.832]             invokeRestart <- base::invokeRestart
[17:47:58.832]             length <- base::length
[17:47:58.832]             list <- base::list
[17:47:58.832]             seq.int <- base::seq.int
[17:47:58.832]             signalCondition <- base::signalCondition
[17:47:58.832]             sys.calls <- base::sys.calls
[17:47:58.832]             `[[` <- base::`[[`
[17:47:58.832]             `+` <- base::`+`
[17:47:58.832]             `<<-` <- base::`<<-`
[17:47:58.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:58.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:58.832]                   3L)]
[17:47:58.832]             }
[17:47:58.832]             function(cond) {
[17:47:58.832]                 is_error <- inherits(cond, "error")
[17:47:58.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:58.832]                   NULL)
[17:47:58.832]                 if (is_error) {
[17:47:58.832]                   sessionInformation <- function() {
[17:47:58.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:58.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:58.832]                       search = base::search(), system = base::Sys.info())
[17:47:58.832]                   }
[17:47:58.832]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:58.832]                     cond$call), session = sessionInformation(), 
[17:47:58.832]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:58.832]                   signalCondition(cond)
[17:47:58.832]                 }
[17:47:58.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:58.832]                 "immediateCondition"))) {
[17:47:58.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:58.832]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:58.832]                   if (TRUE && !signal) {
[17:47:58.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.832]                     {
[17:47:58.832]                       inherits <- base::inherits
[17:47:58.832]                       invokeRestart <- base::invokeRestart
[17:47:58.832]                       is.null <- base::is.null
[17:47:58.832]                       muffled <- FALSE
[17:47:58.832]                       if (inherits(cond, "message")) {
[17:47:58.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.832]                         if (muffled) 
[17:47:58.832]                           invokeRestart("muffleMessage")
[17:47:58.832]                       }
[17:47:58.832]                       else if (inherits(cond, "warning")) {
[17:47:58.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.832]                         if (muffled) 
[17:47:58.832]                           invokeRestart("muffleWarning")
[17:47:58.832]                       }
[17:47:58.832]                       else if (inherits(cond, "condition")) {
[17:47:58.832]                         if (!is.null(pattern)) {
[17:47:58.832]                           computeRestarts <- base::computeRestarts
[17:47:58.832]                           grepl <- base::grepl
[17:47:58.832]                           restarts <- computeRestarts(cond)
[17:47:58.832]                           for (restart in restarts) {
[17:47:58.832]                             name <- restart$name
[17:47:58.832]                             if (is.null(name)) 
[17:47:58.832]                               next
[17:47:58.832]                             if (!grepl(pattern, name)) 
[17:47:58.832]                               next
[17:47:58.832]                             invokeRestart(restart)
[17:47:58.832]                             muffled <- TRUE
[17:47:58.832]                             break
[17:47:58.832]                           }
[17:47:58.832]                         }
[17:47:58.832]                       }
[17:47:58.832]                       invisible(muffled)
[17:47:58.832]                     }
[17:47:58.832]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.832]                   }
[17:47:58.832]                 }
[17:47:58.832]                 else {
[17:47:58.832]                   if (TRUE) {
[17:47:58.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.832]                     {
[17:47:58.832]                       inherits <- base::inherits
[17:47:58.832]                       invokeRestart <- base::invokeRestart
[17:47:58.832]                       is.null <- base::is.null
[17:47:58.832]                       muffled <- FALSE
[17:47:58.832]                       if (inherits(cond, "message")) {
[17:47:58.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.832]                         if (muffled) 
[17:47:58.832]                           invokeRestart("muffleMessage")
[17:47:58.832]                       }
[17:47:58.832]                       else if (inherits(cond, "warning")) {
[17:47:58.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.832]                         if (muffled) 
[17:47:58.832]                           invokeRestart("muffleWarning")
[17:47:58.832]                       }
[17:47:58.832]                       else if (inherits(cond, "condition")) {
[17:47:58.832]                         if (!is.null(pattern)) {
[17:47:58.832]                           computeRestarts <- base::computeRestarts
[17:47:58.832]                           grepl <- base::grepl
[17:47:58.832]                           restarts <- computeRestarts(cond)
[17:47:58.832]                           for (restart in restarts) {
[17:47:58.832]                             name <- restart$name
[17:47:58.832]                             if (is.null(name)) 
[17:47:58.832]                               next
[17:47:58.832]                             if (!grepl(pattern, name)) 
[17:47:58.832]                               next
[17:47:58.832]                             invokeRestart(restart)
[17:47:58.832]                             muffled <- TRUE
[17:47:58.832]                             break
[17:47:58.832]                           }
[17:47:58.832]                         }
[17:47:58.832]                       }
[17:47:58.832]                       invisible(muffled)
[17:47:58.832]                     }
[17:47:58.832]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.832]                   }
[17:47:58.832]                 }
[17:47:58.832]             }
[17:47:58.832]         }))
[17:47:58.832]     }, error = function(ex) {
[17:47:58.832]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:58.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.832]                 ...future.rng), started = ...future.startTime, 
[17:47:58.832]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:58.832]             version = "1.8"), class = "FutureResult")
[17:47:58.832]     }, finally = {
[17:47:58.832]         if (!identical(...future.workdir, getwd())) 
[17:47:58.832]             setwd(...future.workdir)
[17:47:58.832]         {
[17:47:58.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:58.832]                 ...future.oldOptions$nwarnings <- NULL
[17:47:58.832]             }
[17:47:58.832]             base::options(...future.oldOptions)
[17:47:58.832]             if (.Platform$OS.type == "windows") {
[17:47:58.832]                 old_names <- names(...future.oldEnvVars)
[17:47:58.832]                 envs <- base::Sys.getenv()
[17:47:58.832]                 names <- names(envs)
[17:47:58.832]                 common <- intersect(names, old_names)
[17:47:58.832]                 added <- setdiff(names, old_names)
[17:47:58.832]                 removed <- setdiff(old_names, names)
[17:47:58.832]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:58.832]                   envs[common]]
[17:47:58.832]                 NAMES <- toupper(changed)
[17:47:58.832]                 args <- list()
[17:47:58.832]                 for (kk in seq_along(NAMES)) {
[17:47:58.832]                   name <- changed[[kk]]
[17:47:58.832]                   NAME <- NAMES[[kk]]
[17:47:58.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.832]                     next
[17:47:58.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.832]                 }
[17:47:58.832]                 NAMES <- toupper(added)
[17:47:58.832]                 for (kk in seq_along(NAMES)) {
[17:47:58.832]                   name <- added[[kk]]
[17:47:58.832]                   NAME <- NAMES[[kk]]
[17:47:58.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.832]                     next
[17:47:58.832]                   args[[name]] <- ""
[17:47:58.832]                 }
[17:47:58.832]                 NAMES <- toupper(removed)
[17:47:58.832]                 for (kk in seq_along(NAMES)) {
[17:47:58.832]                   name <- removed[[kk]]
[17:47:58.832]                   NAME <- NAMES[[kk]]
[17:47:58.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.832]                     next
[17:47:58.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.832]                 }
[17:47:58.832]                 if (length(args) > 0) 
[17:47:58.832]                   base::do.call(base::Sys.setenv, args = args)
[17:47:58.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:58.832]             }
[17:47:58.832]             else {
[17:47:58.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:58.832]             }
[17:47:58.832]             {
[17:47:58.832]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:58.832]                   0L) {
[17:47:58.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:58.832]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:58.832]                   base::options(opts)
[17:47:58.832]                 }
[17:47:58.832]                 {
[17:47:58.832]                   {
[17:47:58.832]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:58.832]                     NULL
[17:47:58.832]                   }
[17:47:58.832]                   options(future.plan = NULL)
[17:47:58.832]                   if (is.na(NA_character_)) 
[17:47:58.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:58.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:58.832]                     .init = FALSE)
[17:47:58.832]                 }
[17:47:58.832]             }
[17:47:58.832]         }
[17:47:58.832]     })
[17:47:58.832]     if (TRUE) {
[17:47:58.832]         base::sink(type = "output", split = FALSE)
[17:47:58.832]         if (TRUE) {
[17:47:58.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:58.832]         }
[17:47:58.832]         else {
[17:47:58.832]             ...future.result["stdout"] <- base::list(NULL)
[17:47:58.832]         }
[17:47:58.832]         base::close(...future.stdout)
[17:47:58.832]         ...future.stdout <- NULL
[17:47:58.832]     }
[17:47:58.832]     ...future.result$conditions <- ...future.conditions
[17:47:58.832]     ...future.result$finished <- base::Sys.time()
[17:47:58.832]     ...future.result
[17:47:58.832] }
[17:47:58.835] MultisessionFuture started
[17:47:58.835] - Launch lazy future ... done
[17:47:58.835] run() for ‘MultisessionFuture’ ... done
[17:47:58.835] getGlobalsAndPackages() ...
[17:47:58.835] Searching for globals...
[17:47:58.836] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:58.836] Searching for globals ... DONE
[17:47:58.836] Resolving globals: FALSE
[17:47:58.837] 
[17:47:58.837] 
[17:47:58.837] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:47:58.837] getGlobalsAndPackages() ...
[17:47:58.837] Searching for globals...
[17:47:58.838] - globals found: [2] ‘list’, ‘stop’
[17:47:58.838] Searching for globals ... DONE
[17:47:58.838] Resolving globals: FALSE
[17:47:58.838] 
[17:47:58.838] 
[17:47:58.838] getGlobalsAndPackages() ... DONE
[17:47:58.839] run() for ‘Future’ ...
[17:47:58.839] - state: ‘created’
[17:47:58.839] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:58.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:58.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:58.853]   - Field: ‘node’
[17:47:58.853]   - Field: ‘label’
[17:47:58.853]   - Field: ‘local’
[17:47:58.853]   - Field: ‘owner’
[17:47:58.853]   - Field: ‘envir’
[17:47:58.853]   - Field: ‘workers’
[17:47:58.853]   - Field: ‘packages’
[17:47:58.854]   - Field: ‘gc’
[17:47:58.854]   - Field: ‘conditions’
[17:47:58.854]   - Field: ‘persistent’
[17:47:58.854]   - Field: ‘expr’
[17:47:58.854]   - Field: ‘uuid’
[17:47:58.854]   - Field: ‘seed’
[17:47:58.854]   - Field: ‘version’
[17:47:58.854]   - Field: ‘result’
[17:47:58.854]   - Field: ‘asynchronous’
[17:47:58.854]   - Field: ‘calls’
[17:47:58.854]   - Field: ‘globals’
[17:47:58.854]   - Field: ‘stdout’
[17:47:58.855]   - Field: ‘earlySignal’
[17:47:58.855]   - Field: ‘lazy’
[17:47:58.855]   - Field: ‘state’
[17:47:58.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:58.855] - Launch lazy future ...
[17:47:58.855] Packages needed by the future expression (n = 0): <none>
[17:47:58.855] Packages needed by future strategies (n = 0): <none>
[17:47:58.856] {
[17:47:58.856]     {
[17:47:58.856]         {
[17:47:58.856]             ...future.startTime <- base::Sys.time()
[17:47:58.856]             {
[17:47:58.856]                 {
[17:47:58.856]                   {
[17:47:58.856]                     {
[17:47:58.856]                       base::local({
[17:47:58.856]                         has_future <- base::requireNamespace("future", 
[17:47:58.856]                           quietly = TRUE)
[17:47:58.856]                         if (has_future) {
[17:47:58.856]                           ns <- base::getNamespace("future")
[17:47:58.856]                           version <- ns[[".package"]][["version"]]
[17:47:58.856]                           if (is.null(version)) 
[17:47:58.856]                             version <- utils::packageVersion("future")
[17:47:58.856]                         }
[17:47:58.856]                         else {
[17:47:58.856]                           version <- NULL
[17:47:58.856]                         }
[17:47:58.856]                         if (!has_future || version < "1.8.0") {
[17:47:58.856]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:58.856]                             "", base::R.version$version.string), 
[17:47:58.856]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:58.856]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:58.856]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:58.856]                               "release", "version")], collapse = " "), 
[17:47:58.856]                             hostname = base::Sys.info()[["nodename"]])
[17:47:58.856]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:58.856]                             info)
[17:47:58.856]                           info <- base::paste(info, collapse = "; ")
[17:47:58.856]                           if (!has_future) {
[17:47:58.856]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:58.856]                               info)
[17:47:58.856]                           }
[17:47:58.856]                           else {
[17:47:58.856]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:58.856]                               info, version)
[17:47:58.856]                           }
[17:47:58.856]                           base::stop(msg)
[17:47:58.856]                         }
[17:47:58.856]                       })
[17:47:58.856]                     }
[17:47:58.856]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:58.856]                     base::options(mc.cores = 1L)
[17:47:58.856]                   }
[17:47:58.856]                   ...future.strategy.old <- future::plan("list")
[17:47:58.856]                   options(future.plan = NULL)
[17:47:58.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:58.856]                 }
[17:47:58.856]                 ...future.workdir <- getwd()
[17:47:58.856]             }
[17:47:58.856]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:58.856]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:58.856]         }
[17:47:58.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:58.856]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:58.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:58.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:58.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:58.856]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:58.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:58.856]             base::names(...future.oldOptions))
[17:47:58.856]     }
[17:47:58.856]     if (FALSE) {
[17:47:58.856]     }
[17:47:58.856]     else {
[17:47:58.856]         if (TRUE) {
[17:47:58.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:58.856]                 open = "w")
[17:47:58.856]         }
[17:47:58.856]         else {
[17:47:58.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:58.856]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:58.856]         }
[17:47:58.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:58.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:58.856]             base::sink(type = "output", split = FALSE)
[17:47:58.856]             base::close(...future.stdout)
[17:47:58.856]         }, add = TRUE)
[17:47:58.856]     }
[17:47:58.856]     ...future.frame <- base::sys.nframe()
[17:47:58.856]     ...future.conditions <- base::list()
[17:47:58.856]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:58.856]     if (FALSE) {
[17:47:58.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:58.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:58.856]     }
[17:47:58.856]     ...future.result <- base::tryCatch({
[17:47:58.856]         base::withCallingHandlers({
[17:47:58.856]             ...future.value <- base::withVisible(base::local({
[17:47:58.856]                 ...future.makeSendCondition <- base::local({
[17:47:58.856]                   sendCondition <- NULL
[17:47:58.856]                   function(frame = 1L) {
[17:47:58.856]                     if (is.function(sendCondition)) 
[17:47:58.856]                       return(sendCondition)
[17:47:58.856]                     ns <- getNamespace("parallel")
[17:47:58.856]                     if (exists("sendData", mode = "function", 
[17:47:58.856]                       envir = ns)) {
[17:47:58.856]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:58.856]                         envir = ns)
[17:47:58.856]                       envir <- sys.frame(frame)
[17:47:58.856]                       master <- NULL
[17:47:58.856]                       while (!identical(envir, .GlobalEnv) && 
[17:47:58.856]                         !identical(envir, emptyenv())) {
[17:47:58.856]                         if (exists("master", mode = "list", envir = envir, 
[17:47:58.856]                           inherits = FALSE)) {
[17:47:58.856]                           master <- get("master", mode = "list", 
[17:47:58.856]                             envir = envir, inherits = FALSE)
[17:47:58.856]                           if (inherits(master, c("SOCKnode", 
[17:47:58.856]                             "SOCK0node"))) {
[17:47:58.856]                             sendCondition <<- function(cond) {
[17:47:58.856]                               data <- list(type = "VALUE", value = cond, 
[17:47:58.856]                                 success = TRUE)
[17:47:58.856]                               parallel_sendData(master, data)
[17:47:58.856]                             }
[17:47:58.856]                             return(sendCondition)
[17:47:58.856]                           }
[17:47:58.856]                         }
[17:47:58.856]                         frame <- frame + 1L
[17:47:58.856]                         envir <- sys.frame(frame)
[17:47:58.856]                       }
[17:47:58.856]                     }
[17:47:58.856]                     sendCondition <<- function(cond) NULL
[17:47:58.856]                   }
[17:47:58.856]                 })
[17:47:58.856]                 withCallingHandlers({
[17:47:58.856]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:47:58.856]                 }, immediateCondition = function(cond) {
[17:47:58.856]                   sendCondition <- ...future.makeSendCondition()
[17:47:58.856]                   sendCondition(cond)
[17:47:58.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.856]                   {
[17:47:58.856]                     inherits <- base::inherits
[17:47:58.856]                     invokeRestart <- base::invokeRestart
[17:47:58.856]                     is.null <- base::is.null
[17:47:58.856]                     muffled <- FALSE
[17:47:58.856]                     if (inherits(cond, "message")) {
[17:47:58.856]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:58.856]                       if (muffled) 
[17:47:58.856]                         invokeRestart("muffleMessage")
[17:47:58.856]                     }
[17:47:58.856]                     else if (inherits(cond, "warning")) {
[17:47:58.856]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:58.856]                       if (muffled) 
[17:47:58.856]                         invokeRestart("muffleWarning")
[17:47:58.856]                     }
[17:47:58.856]                     else if (inherits(cond, "condition")) {
[17:47:58.856]                       if (!is.null(pattern)) {
[17:47:58.856]                         computeRestarts <- base::computeRestarts
[17:47:58.856]                         grepl <- base::grepl
[17:47:58.856]                         restarts <- computeRestarts(cond)
[17:47:58.856]                         for (restart in restarts) {
[17:47:58.856]                           name <- restart$name
[17:47:58.856]                           if (is.null(name)) 
[17:47:58.856]                             next
[17:47:58.856]                           if (!grepl(pattern, name)) 
[17:47:58.856]                             next
[17:47:58.856]                           invokeRestart(restart)
[17:47:58.856]                           muffled <- TRUE
[17:47:58.856]                           break
[17:47:58.856]                         }
[17:47:58.856]                       }
[17:47:58.856]                     }
[17:47:58.856]                     invisible(muffled)
[17:47:58.856]                   }
[17:47:58.856]                   muffleCondition(cond)
[17:47:58.856]                 })
[17:47:58.856]             }))
[17:47:58.856]             future::FutureResult(value = ...future.value$value, 
[17:47:58.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.856]                   ...future.rng), globalenv = if (FALSE) 
[17:47:58.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:58.856]                     ...future.globalenv.names))
[17:47:58.856]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:58.856]         }, condition = base::local({
[17:47:58.856]             c <- base::c
[17:47:58.856]             inherits <- base::inherits
[17:47:58.856]             invokeRestart <- base::invokeRestart
[17:47:58.856]             length <- base::length
[17:47:58.856]             list <- base::list
[17:47:58.856]             seq.int <- base::seq.int
[17:47:58.856]             signalCondition <- base::signalCondition
[17:47:58.856]             sys.calls <- base::sys.calls
[17:47:58.856]             `[[` <- base::`[[`
[17:47:58.856]             `+` <- base::`+`
[17:47:58.856]             `<<-` <- base::`<<-`
[17:47:58.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:58.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:58.856]                   3L)]
[17:47:58.856]             }
[17:47:58.856]             function(cond) {
[17:47:58.856]                 is_error <- inherits(cond, "error")
[17:47:58.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:58.856]                   NULL)
[17:47:58.856]                 if (is_error) {
[17:47:58.856]                   sessionInformation <- function() {
[17:47:58.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:58.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:58.856]                       search = base::search(), system = base::Sys.info())
[17:47:58.856]                   }
[17:47:58.856]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:58.856]                     cond$call), session = sessionInformation(), 
[17:47:58.856]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:58.856]                   signalCondition(cond)
[17:47:58.856]                 }
[17:47:58.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:58.856]                 "immediateCondition"))) {
[17:47:58.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:58.856]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:58.856]                   if (TRUE && !signal) {
[17:47:58.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.856]                     {
[17:47:58.856]                       inherits <- base::inherits
[17:47:58.856]                       invokeRestart <- base::invokeRestart
[17:47:58.856]                       is.null <- base::is.null
[17:47:58.856]                       muffled <- FALSE
[17:47:58.856]                       if (inherits(cond, "message")) {
[17:47:58.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.856]                         if (muffled) 
[17:47:58.856]                           invokeRestart("muffleMessage")
[17:47:58.856]                       }
[17:47:58.856]                       else if (inherits(cond, "warning")) {
[17:47:58.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.856]                         if (muffled) 
[17:47:58.856]                           invokeRestart("muffleWarning")
[17:47:58.856]                       }
[17:47:58.856]                       else if (inherits(cond, "condition")) {
[17:47:58.856]                         if (!is.null(pattern)) {
[17:47:58.856]                           computeRestarts <- base::computeRestarts
[17:47:58.856]                           grepl <- base::grepl
[17:47:58.856]                           restarts <- computeRestarts(cond)
[17:47:58.856]                           for (restart in restarts) {
[17:47:58.856]                             name <- restart$name
[17:47:58.856]                             if (is.null(name)) 
[17:47:58.856]                               next
[17:47:58.856]                             if (!grepl(pattern, name)) 
[17:47:58.856]                               next
[17:47:58.856]                             invokeRestart(restart)
[17:47:58.856]                             muffled <- TRUE
[17:47:58.856]                             break
[17:47:58.856]                           }
[17:47:58.856]                         }
[17:47:58.856]                       }
[17:47:58.856]                       invisible(muffled)
[17:47:58.856]                     }
[17:47:58.856]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.856]                   }
[17:47:58.856]                 }
[17:47:58.856]                 else {
[17:47:58.856]                   if (TRUE) {
[17:47:58.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.856]                     {
[17:47:58.856]                       inherits <- base::inherits
[17:47:58.856]                       invokeRestart <- base::invokeRestart
[17:47:58.856]                       is.null <- base::is.null
[17:47:58.856]                       muffled <- FALSE
[17:47:58.856]                       if (inherits(cond, "message")) {
[17:47:58.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.856]                         if (muffled) 
[17:47:58.856]                           invokeRestart("muffleMessage")
[17:47:58.856]                       }
[17:47:58.856]                       else if (inherits(cond, "warning")) {
[17:47:58.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.856]                         if (muffled) 
[17:47:58.856]                           invokeRestart("muffleWarning")
[17:47:58.856]                       }
[17:47:58.856]                       else if (inherits(cond, "condition")) {
[17:47:58.856]                         if (!is.null(pattern)) {
[17:47:58.856]                           computeRestarts <- base::computeRestarts
[17:47:58.856]                           grepl <- base::grepl
[17:47:58.856]                           restarts <- computeRestarts(cond)
[17:47:58.856]                           for (restart in restarts) {
[17:47:58.856]                             name <- restart$name
[17:47:58.856]                             if (is.null(name)) 
[17:47:58.856]                               next
[17:47:58.856]                             if (!grepl(pattern, name)) 
[17:47:58.856]                               next
[17:47:58.856]                             invokeRestart(restart)
[17:47:58.856]                             muffled <- TRUE
[17:47:58.856]                             break
[17:47:58.856]                           }
[17:47:58.856]                         }
[17:47:58.856]                       }
[17:47:58.856]                       invisible(muffled)
[17:47:58.856]                     }
[17:47:58.856]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.856]                   }
[17:47:58.856]                 }
[17:47:58.856]             }
[17:47:58.856]         }))
[17:47:58.856]     }, error = function(ex) {
[17:47:58.856]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:58.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.856]                 ...future.rng), started = ...future.startTime, 
[17:47:58.856]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:58.856]             version = "1.8"), class = "FutureResult")
[17:47:58.856]     }, finally = {
[17:47:58.856]         if (!identical(...future.workdir, getwd())) 
[17:47:58.856]             setwd(...future.workdir)
[17:47:58.856]         {
[17:47:58.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:58.856]                 ...future.oldOptions$nwarnings <- NULL
[17:47:58.856]             }
[17:47:58.856]             base::options(...future.oldOptions)
[17:47:58.856]             if (.Platform$OS.type == "windows") {
[17:47:58.856]                 old_names <- names(...future.oldEnvVars)
[17:47:58.856]                 envs <- base::Sys.getenv()
[17:47:58.856]                 names <- names(envs)
[17:47:58.856]                 common <- intersect(names, old_names)
[17:47:58.856]                 added <- setdiff(names, old_names)
[17:47:58.856]                 removed <- setdiff(old_names, names)
[17:47:58.856]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:58.856]                   envs[common]]
[17:47:58.856]                 NAMES <- toupper(changed)
[17:47:58.856]                 args <- list()
[17:47:58.856]                 for (kk in seq_along(NAMES)) {
[17:47:58.856]                   name <- changed[[kk]]
[17:47:58.856]                   NAME <- NAMES[[kk]]
[17:47:58.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.856]                     next
[17:47:58.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.856]                 }
[17:47:58.856]                 NAMES <- toupper(added)
[17:47:58.856]                 for (kk in seq_along(NAMES)) {
[17:47:58.856]                   name <- added[[kk]]
[17:47:58.856]                   NAME <- NAMES[[kk]]
[17:47:58.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.856]                     next
[17:47:58.856]                   args[[name]] <- ""
[17:47:58.856]                 }
[17:47:58.856]                 NAMES <- toupper(removed)
[17:47:58.856]                 for (kk in seq_along(NAMES)) {
[17:47:58.856]                   name <- removed[[kk]]
[17:47:58.856]                   NAME <- NAMES[[kk]]
[17:47:58.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.856]                     next
[17:47:58.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.856]                 }
[17:47:58.856]                 if (length(args) > 0) 
[17:47:58.856]                   base::do.call(base::Sys.setenv, args = args)
[17:47:58.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:58.856]             }
[17:47:58.856]             else {
[17:47:58.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:58.856]             }
[17:47:58.856]             {
[17:47:58.856]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:58.856]                   0L) {
[17:47:58.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:58.856]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:58.856]                   base::options(opts)
[17:47:58.856]                 }
[17:47:58.856]                 {
[17:47:58.856]                   {
[17:47:58.856]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:58.856]                     NULL
[17:47:58.856]                   }
[17:47:58.856]                   options(future.plan = NULL)
[17:47:58.856]                   if (is.na(NA_character_)) 
[17:47:58.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:58.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:58.856]                     .init = FALSE)
[17:47:58.856]                 }
[17:47:58.856]             }
[17:47:58.856]         }
[17:47:58.856]     })
[17:47:58.856]     if (TRUE) {
[17:47:58.856]         base::sink(type = "output", split = FALSE)
[17:47:58.856]         if (TRUE) {
[17:47:58.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:58.856]         }
[17:47:58.856]         else {
[17:47:58.856]             ...future.result["stdout"] <- base::list(NULL)
[17:47:58.856]         }
[17:47:58.856]         base::close(...future.stdout)
[17:47:58.856]         ...future.stdout <- NULL
[17:47:58.856]     }
[17:47:58.856]     ...future.result$conditions <- ...future.conditions
[17:47:58.856]     ...future.result$finished <- base::Sys.time()
[17:47:58.856]     ...future.result
[17:47:58.856] }
[17:47:58.908] MultisessionFuture started
[17:47:58.909] - Launch lazy future ... done
[17:47:58.909] run() for ‘MultisessionFuture’ ... done
[17:47:58.909] getGlobalsAndPackages() ...
[17:47:58.909] Searching for globals...
[17:47:58.910] - globals found: [2] ‘list’, ‘stop’
[17:47:58.910] Searching for globals ... DONE
[17:47:58.911] Resolving globals: FALSE
[17:47:58.911] 
[17:47:58.911] 
[17:47:58.911] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[17:47:58.912] getGlobalsAndPackages() ...
[17:47:58.912] Searching for globals...
[17:47:58.914] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:58.914] Searching for globals ... DONE
[17:47:58.914] Resolving globals: FALSE
[17:47:58.915] 
[17:47:58.915] 
[17:47:58.915] getGlobalsAndPackages() ... DONE
[17:47:58.915] run() for ‘Future’ ...
[17:47:58.916] - state: ‘created’
[17:47:58.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:58.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:58.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:58.933]   - Field: ‘node’
[17:47:58.933]   - Field: ‘label’
[17:47:58.934]   - Field: ‘local’
[17:47:58.934]   - Field: ‘owner’
[17:47:58.934]   - Field: ‘envir’
[17:47:58.934]   - Field: ‘workers’
[17:47:58.934]   - Field: ‘packages’
[17:47:58.934]   - Field: ‘gc’
[17:47:58.935]   - Field: ‘conditions’
[17:47:58.935]   - Field: ‘persistent’
[17:47:58.935]   - Field: ‘expr’
[17:47:58.935]   - Field: ‘uuid’
[17:47:58.935]   - Field: ‘seed’
[17:47:58.935]   - Field: ‘version’
[17:47:58.936]   - Field: ‘result’
[17:47:58.936]   - Field: ‘asynchronous’
[17:47:58.936]   - Field: ‘calls’
[17:47:58.936]   - Field: ‘globals’
[17:47:58.936]   - Field: ‘stdout’
[17:47:58.936]   - Field: ‘earlySignal’
[17:47:58.937]   - Field: ‘lazy’
[17:47:58.937]   - Field: ‘state’
[17:47:58.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:58.937] - Launch lazy future ...
[17:47:58.937] Packages needed by the future expression (n = 0): <none>
[17:47:58.938] Packages needed by future strategies (n = 0): <none>
[17:47:58.938] {
[17:47:58.938]     {
[17:47:58.938]         {
[17:47:58.938]             ...future.startTime <- base::Sys.time()
[17:47:58.938]             {
[17:47:58.938]                 {
[17:47:58.938]                   {
[17:47:58.938]                     {
[17:47:58.938]                       base::local({
[17:47:58.938]                         has_future <- base::requireNamespace("future", 
[17:47:58.938]                           quietly = TRUE)
[17:47:58.938]                         if (has_future) {
[17:47:58.938]                           ns <- base::getNamespace("future")
[17:47:58.938]                           version <- ns[[".package"]][["version"]]
[17:47:58.938]                           if (is.null(version)) 
[17:47:58.938]                             version <- utils::packageVersion("future")
[17:47:58.938]                         }
[17:47:58.938]                         else {
[17:47:58.938]                           version <- NULL
[17:47:58.938]                         }
[17:47:58.938]                         if (!has_future || version < "1.8.0") {
[17:47:58.938]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:58.938]                             "", base::R.version$version.string), 
[17:47:58.938]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:58.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:58.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:58.938]                               "release", "version")], collapse = " "), 
[17:47:58.938]                             hostname = base::Sys.info()[["nodename"]])
[17:47:58.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:58.938]                             info)
[17:47:58.938]                           info <- base::paste(info, collapse = "; ")
[17:47:58.938]                           if (!has_future) {
[17:47:58.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:58.938]                               info)
[17:47:58.938]                           }
[17:47:58.938]                           else {
[17:47:58.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:58.938]                               info, version)
[17:47:58.938]                           }
[17:47:58.938]                           base::stop(msg)
[17:47:58.938]                         }
[17:47:58.938]                       })
[17:47:58.938]                     }
[17:47:58.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:58.938]                     base::options(mc.cores = 1L)
[17:47:58.938]                   }
[17:47:58.938]                   ...future.strategy.old <- future::plan("list")
[17:47:58.938]                   options(future.plan = NULL)
[17:47:58.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:58.938]                 }
[17:47:58.938]                 ...future.workdir <- getwd()
[17:47:58.938]             }
[17:47:58.938]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:58.938]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:58.938]         }
[17:47:58.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:58.938]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:58.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:58.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:58.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:58.938]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:58.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:58.938]             base::names(...future.oldOptions))
[17:47:58.938]     }
[17:47:58.938]     if (FALSE) {
[17:47:58.938]     }
[17:47:58.938]     else {
[17:47:58.938]         if (TRUE) {
[17:47:58.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:58.938]                 open = "w")
[17:47:58.938]         }
[17:47:58.938]         else {
[17:47:58.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:58.938]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:58.938]         }
[17:47:58.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:58.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:58.938]             base::sink(type = "output", split = FALSE)
[17:47:58.938]             base::close(...future.stdout)
[17:47:58.938]         }, add = TRUE)
[17:47:58.938]     }
[17:47:58.938]     ...future.frame <- base::sys.nframe()
[17:47:58.938]     ...future.conditions <- base::list()
[17:47:58.938]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:58.938]     if (FALSE) {
[17:47:58.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:58.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:58.938]     }
[17:47:58.938]     ...future.result <- base::tryCatch({
[17:47:58.938]         base::withCallingHandlers({
[17:47:58.938]             ...future.value <- base::withVisible(base::local({
[17:47:58.938]                 ...future.makeSendCondition <- base::local({
[17:47:58.938]                   sendCondition <- NULL
[17:47:58.938]                   function(frame = 1L) {
[17:47:58.938]                     if (is.function(sendCondition)) 
[17:47:58.938]                       return(sendCondition)
[17:47:58.938]                     ns <- getNamespace("parallel")
[17:47:58.938]                     if (exists("sendData", mode = "function", 
[17:47:58.938]                       envir = ns)) {
[17:47:58.938]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:58.938]                         envir = ns)
[17:47:58.938]                       envir <- sys.frame(frame)
[17:47:58.938]                       master <- NULL
[17:47:58.938]                       while (!identical(envir, .GlobalEnv) && 
[17:47:58.938]                         !identical(envir, emptyenv())) {
[17:47:58.938]                         if (exists("master", mode = "list", envir = envir, 
[17:47:58.938]                           inherits = FALSE)) {
[17:47:58.938]                           master <- get("master", mode = "list", 
[17:47:58.938]                             envir = envir, inherits = FALSE)
[17:47:58.938]                           if (inherits(master, c("SOCKnode", 
[17:47:58.938]                             "SOCK0node"))) {
[17:47:58.938]                             sendCondition <<- function(cond) {
[17:47:58.938]                               data <- list(type = "VALUE", value = cond, 
[17:47:58.938]                                 success = TRUE)
[17:47:58.938]                               parallel_sendData(master, data)
[17:47:58.938]                             }
[17:47:58.938]                             return(sendCondition)
[17:47:58.938]                           }
[17:47:58.938]                         }
[17:47:58.938]                         frame <- frame + 1L
[17:47:58.938]                         envir <- sys.frame(frame)
[17:47:58.938]                       }
[17:47:58.938]                     }
[17:47:58.938]                     sendCondition <<- function(cond) NULL
[17:47:58.938]                   }
[17:47:58.938]                 })
[17:47:58.938]                 withCallingHandlers({
[17:47:58.938]                   {
[17:47:58.938]                     Sys.sleep(0.5)
[17:47:58.938]                     list(a = 1, b = 42L)
[17:47:58.938]                   }
[17:47:58.938]                 }, immediateCondition = function(cond) {
[17:47:58.938]                   sendCondition <- ...future.makeSendCondition()
[17:47:58.938]                   sendCondition(cond)
[17:47:58.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.938]                   {
[17:47:58.938]                     inherits <- base::inherits
[17:47:58.938]                     invokeRestart <- base::invokeRestart
[17:47:58.938]                     is.null <- base::is.null
[17:47:58.938]                     muffled <- FALSE
[17:47:58.938]                     if (inherits(cond, "message")) {
[17:47:58.938]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:58.938]                       if (muffled) 
[17:47:58.938]                         invokeRestart("muffleMessage")
[17:47:58.938]                     }
[17:47:58.938]                     else if (inherits(cond, "warning")) {
[17:47:58.938]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:58.938]                       if (muffled) 
[17:47:58.938]                         invokeRestart("muffleWarning")
[17:47:58.938]                     }
[17:47:58.938]                     else if (inherits(cond, "condition")) {
[17:47:58.938]                       if (!is.null(pattern)) {
[17:47:58.938]                         computeRestarts <- base::computeRestarts
[17:47:58.938]                         grepl <- base::grepl
[17:47:58.938]                         restarts <- computeRestarts(cond)
[17:47:58.938]                         for (restart in restarts) {
[17:47:58.938]                           name <- restart$name
[17:47:58.938]                           if (is.null(name)) 
[17:47:58.938]                             next
[17:47:58.938]                           if (!grepl(pattern, name)) 
[17:47:58.938]                             next
[17:47:58.938]                           invokeRestart(restart)
[17:47:58.938]                           muffled <- TRUE
[17:47:58.938]                           break
[17:47:58.938]                         }
[17:47:58.938]                       }
[17:47:58.938]                     }
[17:47:58.938]                     invisible(muffled)
[17:47:58.938]                   }
[17:47:58.938]                   muffleCondition(cond)
[17:47:58.938]                 })
[17:47:58.938]             }))
[17:47:58.938]             future::FutureResult(value = ...future.value$value, 
[17:47:58.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.938]                   ...future.rng), globalenv = if (FALSE) 
[17:47:58.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:58.938]                     ...future.globalenv.names))
[17:47:58.938]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:58.938]         }, condition = base::local({
[17:47:58.938]             c <- base::c
[17:47:58.938]             inherits <- base::inherits
[17:47:58.938]             invokeRestart <- base::invokeRestart
[17:47:58.938]             length <- base::length
[17:47:58.938]             list <- base::list
[17:47:58.938]             seq.int <- base::seq.int
[17:47:58.938]             signalCondition <- base::signalCondition
[17:47:58.938]             sys.calls <- base::sys.calls
[17:47:58.938]             `[[` <- base::`[[`
[17:47:58.938]             `+` <- base::`+`
[17:47:58.938]             `<<-` <- base::`<<-`
[17:47:58.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:58.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:58.938]                   3L)]
[17:47:58.938]             }
[17:47:58.938]             function(cond) {
[17:47:58.938]                 is_error <- inherits(cond, "error")
[17:47:58.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:58.938]                   NULL)
[17:47:58.938]                 if (is_error) {
[17:47:58.938]                   sessionInformation <- function() {
[17:47:58.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:58.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:58.938]                       search = base::search(), system = base::Sys.info())
[17:47:58.938]                   }
[17:47:58.938]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:58.938]                     cond$call), session = sessionInformation(), 
[17:47:58.938]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:58.938]                   signalCondition(cond)
[17:47:58.938]                 }
[17:47:58.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:58.938]                 "immediateCondition"))) {
[17:47:58.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:58.938]                   ...future.conditions[[length(...future.conditions) + 
[17:47:58.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:58.938]                   if (TRUE && !signal) {
[17:47:58.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.938]                     {
[17:47:58.938]                       inherits <- base::inherits
[17:47:58.938]                       invokeRestart <- base::invokeRestart
[17:47:58.938]                       is.null <- base::is.null
[17:47:58.938]                       muffled <- FALSE
[17:47:58.938]                       if (inherits(cond, "message")) {
[17:47:58.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.938]                         if (muffled) 
[17:47:58.938]                           invokeRestart("muffleMessage")
[17:47:58.938]                       }
[17:47:58.938]                       else if (inherits(cond, "warning")) {
[17:47:58.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.938]                         if (muffled) 
[17:47:58.938]                           invokeRestart("muffleWarning")
[17:47:58.938]                       }
[17:47:58.938]                       else if (inherits(cond, "condition")) {
[17:47:58.938]                         if (!is.null(pattern)) {
[17:47:58.938]                           computeRestarts <- base::computeRestarts
[17:47:58.938]                           grepl <- base::grepl
[17:47:58.938]                           restarts <- computeRestarts(cond)
[17:47:58.938]                           for (restart in restarts) {
[17:47:58.938]                             name <- restart$name
[17:47:58.938]                             if (is.null(name)) 
[17:47:58.938]                               next
[17:47:58.938]                             if (!grepl(pattern, name)) 
[17:47:58.938]                               next
[17:47:58.938]                             invokeRestart(restart)
[17:47:58.938]                             muffled <- TRUE
[17:47:58.938]                             break
[17:47:58.938]                           }
[17:47:58.938]                         }
[17:47:58.938]                       }
[17:47:58.938]                       invisible(muffled)
[17:47:58.938]                     }
[17:47:58.938]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.938]                   }
[17:47:58.938]                 }
[17:47:58.938]                 else {
[17:47:58.938]                   if (TRUE) {
[17:47:58.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:58.938]                     {
[17:47:58.938]                       inherits <- base::inherits
[17:47:58.938]                       invokeRestart <- base::invokeRestart
[17:47:58.938]                       is.null <- base::is.null
[17:47:58.938]                       muffled <- FALSE
[17:47:58.938]                       if (inherits(cond, "message")) {
[17:47:58.938]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:58.938]                         if (muffled) 
[17:47:58.938]                           invokeRestart("muffleMessage")
[17:47:58.938]                       }
[17:47:58.938]                       else if (inherits(cond, "warning")) {
[17:47:58.938]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:58.938]                         if (muffled) 
[17:47:58.938]                           invokeRestart("muffleWarning")
[17:47:58.938]                       }
[17:47:58.938]                       else if (inherits(cond, "condition")) {
[17:47:58.938]                         if (!is.null(pattern)) {
[17:47:58.938]                           computeRestarts <- base::computeRestarts
[17:47:58.938]                           grepl <- base::grepl
[17:47:58.938]                           restarts <- computeRestarts(cond)
[17:47:58.938]                           for (restart in restarts) {
[17:47:58.938]                             name <- restart$name
[17:47:58.938]                             if (is.null(name)) 
[17:47:58.938]                               next
[17:47:58.938]                             if (!grepl(pattern, name)) 
[17:47:58.938]                               next
[17:47:58.938]                             invokeRestart(restart)
[17:47:58.938]                             muffled <- TRUE
[17:47:58.938]                             break
[17:47:58.938]                           }
[17:47:58.938]                         }
[17:47:58.938]                       }
[17:47:58.938]                       invisible(muffled)
[17:47:58.938]                     }
[17:47:58.938]                     muffleCondition(cond, pattern = "^muffle")
[17:47:58.938]                   }
[17:47:58.938]                 }
[17:47:58.938]             }
[17:47:58.938]         }))
[17:47:58.938]     }, error = function(ex) {
[17:47:58.938]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:58.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:58.938]                 ...future.rng), started = ...future.startTime, 
[17:47:58.938]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:58.938]             version = "1.8"), class = "FutureResult")
[17:47:58.938]     }, finally = {
[17:47:58.938]         if (!identical(...future.workdir, getwd())) 
[17:47:58.938]             setwd(...future.workdir)
[17:47:58.938]         {
[17:47:58.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:58.938]                 ...future.oldOptions$nwarnings <- NULL
[17:47:58.938]             }
[17:47:58.938]             base::options(...future.oldOptions)
[17:47:58.938]             if (.Platform$OS.type == "windows") {
[17:47:58.938]                 old_names <- names(...future.oldEnvVars)
[17:47:58.938]                 envs <- base::Sys.getenv()
[17:47:58.938]                 names <- names(envs)
[17:47:58.938]                 common <- intersect(names, old_names)
[17:47:58.938]                 added <- setdiff(names, old_names)
[17:47:58.938]                 removed <- setdiff(old_names, names)
[17:47:58.938]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:58.938]                   envs[common]]
[17:47:58.938]                 NAMES <- toupper(changed)
[17:47:58.938]                 args <- list()
[17:47:58.938]                 for (kk in seq_along(NAMES)) {
[17:47:58.938]                   name <- changed[[kk]]
[17:47:58.938]                   NAME <- NAMES[[kk]]
[17:47:58.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.938]                     next
[17:47:58.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.938]                 }
[17:47:58.938]                 NAMES <- toupper(added)
[17:47:58.938]                 for (kk in seq_along(NAMES)) {
[17:47:58.938]                   name <- added[[kk]]
[17:47:58.938]                   NAME <- NAMES[[kk]]
[17:47:58.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.938]                     next
[17:47:58.938]                   args[[name]] <- ""
[17:47:58.938]                 }
[17:47:58.938]                 NAMES <- toupper(removed)
[17:47:58.938]                 for (kk in seq_along(NAMES)) {
[17:47:58.938]                   name <- removed[[kk]]
[17:47:58.938]                   NAME <- NAMES[[kk]]
[17:47:58.938]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:58.938]                     next
[17:47:58.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:58.938]                 }
[17:47:58.938]                 if (length(args) > 0) 
[17:47:58.938]                   base::do.call(base::Sys.setenv, args = args)
[17:47:58.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:58.938]             }
[17:47:58.938]             else {
[17:47:58.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:58.938]             }
[17:47:58.938]             {
[17:47:58.938]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:58.938]                   0L) {
[17:47:58.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:58.938]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:58.938]                   base::options(opts)
[17:47:58.938]                 }
[17:47:58.938]                 {
[17:47:58.938]                   {
[17:47:58.938]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:58.938]                     NULL
[17:47:58.938]                   }
[17:47:58.938]                   options(future.plan = NULL)
[17:47:58.938]                   if (is.na(NA_character_)) 
[17:47:58.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:58.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:58.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:58.938]                     .init = FALSE)
[17:47:58.938]                 }
[17:47:58.938]             }
[17:47:58.938]         }
[17:47:58.938]     })
[17:47:58.938]     if (TRUE) {
[17:47:58.938]         base::sink(type = "output", split = FALSE)
[17:47:58.938]         if (TRUE) {
[17:47:58.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:58.938]         }
[17:47:58.938]         else {
[17:47:58.938]             ...future.result["stdout"] <- base::list(NULL)
[17:47:58.938]         }
[17:47:58.938]         base::close(...future.stdout)
[17:47:58.938]         ...future.stdout <- NULL
[17:47:58.938]     }
[17:47:58.938]     ...future.result$conditions <- ...future.conditions
[17:47:58.938]     ...future.result$finished <- base::Sys.time()
[17:47:58.938]     ...future.result
[17:47:58.938] }
[17:47:58.942] Poll #1 (0): usedNodes() = 2, workers = 2
[17:47:58.964] receiveMessageFromWorker() for ClusterFuture ...
[17:47:58.964] - Validating connection of MultisessionFuture
[17:47:58.964] - received message: FutureResult
[17:47:58.964] - Received FutureResult
[17:47:58.964] - Erased future from FutureRegistry
[17:47:58.965] result() for ClusterFuture ...
[17:47:58.965] - result already collected: FutureResult
[17:47:58.965] result() for ClusterFuture ... done
[17:47:58.965] signalConditions() ...
[17:47:58.965]  - include = ‘immediateCondition’
[17:47:58.965]  - exclude = 
[17:47:58.965]  - resignal = FALSE
[17:47:58.965]  - Number of conditions: 1
[17:47:58.965] signalConditions() ... done
[17:47:58.965] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:58.966] result() for ClusterFuture ...
[17:47:58.966] - result already collected: FutureResult
[17:47:58.966] result() for ClusterFuture ... done
[17:47:58.966] result() for ClusterFuture ...
[17:47:58.966] - result already collected: FutureResult
[17:47:58.966] result() for ClusterFuture ... done
[17:47:58.966] signalConditions() ...
[17:47:58.966]  - include = ‘immediateCondition’
[17:47:58.966]  - exclude = 
[17:47:58.966]  - resignal = FALSE
[17:47:58.966]  - Number of conditions: 1
[17:47:58.966] signalConditions() ... done
[17:47:58.968] MultisessionFuture started
[17:47:58.968] - Launch lazy future ... done
[17:47:58.968] run() for ‘MultisessionFuture’ ... done
[17:47:59.471] receiveMessageFromWorker() for ClusterFuture ...
[17:47:59.471] - Validating connection of MultisessionFuture
[17:47:59.471] - received message: FutureResult
[17:47:59.471] - Received FutureResult
[17:47:59.471] - Erased future from FutureRegistry
[17:47:59.471] result() for ClusterFuture ...
[17:47:59.472] - result already collected: FutureResult
[17:47:59.472] result() for ClusterFuture ... done
[17:47:59.472] receiveMessageFromWorker() for ClusterFuture ... done
[17:47:59.472] A MultisessionFuture was resolved (result was not collected)
[17:47:59.472] getGlobalsAndPackages() ...
[17:47:59.472] Searching for globals...
[17:47:59.473] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:47:59.473] Searching for globals ... DONE
[17:47:59.473] Resolving globals: FALSE
[17:47:59.474] 
[17:47:59.474] 
[17:47:59.474] getGlobalsAndPackages() ... DONE
[17:47:59.474] run() for ‘Future’ ...
[17:47:59.474] - state: ‘created’
[17:47:59.474] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:47:59.488] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:47:59.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:47:59.488]   - Field: ‘node’
[17:47:59.489]   - Field: ‘label’
[17:47:59.489]   - Field: ‘local’
[17:47:59.489]   - Field: ‘owner’
[17:47:59.489]   - Field: ‘envir’
[17:47:59.489]   - Field: ‘workers’
[17:47:59.489]   - Field: ‘packages’
[17:47:59.489]   - Field: ‘gc’
[17:47:59.489]   - Field: ‘conditions’
[17:47:59.489]   - Field: ‘persistent’
[17:47:59.489]   - Field: ‘expr’
[17:47:59.489]   - Field: ‘uuid’
[17:47:59.490]   - Field: ‘seed’
[17:47:59.490]   - Field: ‘version’
[17:47:59.490]   - Field: ‘result’
[17:47:59.490]   - Field: ‘asynchronous’
[17:47:59.490]   - Field: ‘calls’
[17:47:59.490]   - Field: ‘globals’
[17:47:59.490]   - Field: ‘stdout’
[17:47:59.490]   - Field: ‘earlySignal’
[17:47:59.490]   - Field: ‘lazy’
[17:47:59.490]   - Field: ‘state’
[17:47:59.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:47:59.491] - Launch lazy future ...
[17:47:59.491] Packages needed by the future expression (n = 0): <none>
[17:47:59.491] Packages needed by future strategies (n = 0): <none>
[17:47:59.491] {
[17:47:59.491]     {
[17:47:59.491]         {
[17:47:59.491]             ...future.startTime <- base::Sys.time()
[17:47:59.491]             {
[17:47:59.491]                 {
[17:47:59.491]                   {
[17:47:59.491]                     {
[17:47:59.491]                       base::local({
[17:47:59.491]                         has_future <- base::requireNamespace("future", 
[17:47:59.491]                           quietly = TRUE)
[17:47:59.491]                         if (has_future) {
[17:47:59.491]                           ns <- base::getNamespace("future")
[17:47:59.491]                           version <- ns[[".package"]][["version"]]
[17:47:59.491]                           if (is.null(version)) 
[17:47:59.491]                             version <- utils::packageVersion("future")
[17:47:59.491]                         }
[17:47:59.491]                         else {
[17:47:59.491]                           version <- NULL
[17:47:59.491]                         }
[17:47:59.491]                         if (!has_future || version < "1.8.0") {
[17:47:59.491]                           info <- base::c(r_version = base::gsub("R version ", 
[17:47:59.491]                             "", base::R.version$version.string), 
[17:47:59.491]                             platform = base::sprintf("%s (%s-bit)", 
[17:47:59.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:47:59.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:47:59.491]                               "release", "version")], collapse = " "), 
[17:47:59.491]                             hostname = base::Sys.info()[["nodename"]])
[17:47:59.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:47:59.491]                             info)
[17:47:59.491]                           info <- base::paste(info, collapse = "; ")
[17:47:59.491]                           if (!has_future) {
[17:47:59.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:47:59.491]                               info)
[17:47:59.491]                           }
[17:47:59.491]                           else {
[17:47:59.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:47:59.491]                               info, version)
[17:47:59.491]                           }
[17:47:59.491]                           base::stop(msg)
[17:47:59.491]                         }
[17:47:59.491]                       })
[17:47:59.491]                     }
[17:47:59.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:47:59.491]                     base::options(mc.cores = 1L)
[17:47:59.491]                   }
[17:47:59.491]                   ...future.strategy.old <- future::plan("list")
[17:47:59.491]                   options(future.plan = NULL)
[17:47:59.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:47:59.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:47:59.491]                 }
[17:47:59.491]                 ...future.workdir <- getwd()
[17:47:59.491]             }
[17:47:59.491]             ...future.oldOptions <- base::as.list(base::.Options)
[17:47:59.491]             ...future.oldEnvVars <- base::Sys.getenv()
[17:47:59.491]         }
[17:47:59.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:47:59.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:47:59.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:47:59.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:47:59.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:47:59.491]             future.stdout.windows.reencode = NULL, width = 80L)
[17:47:59.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:47:59.491]             base::names(...future.oldOptions))
[17:47:59.491]     }
[17:47:59.491]     if (FALSE) {
[17:47:59.491]     }
[17:47:59.491]     else {
[17:47:59.491]         if (TRUE) {
[17:47:59.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:47:59.491]                 open = "w")
[17:47:59.491]         }
[17:47:59.491]         else {
[17:47:59.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:47:59.491]                 windows = "NUL", "/dev/null"), open = "w")
[17:47:59.491]         }
[17:47:59.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:47:59.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:47:59.491]             base::sink(type = "output", split = FALSE)
[17:47:59.491]             base::close(...future.stdout)
[17:47:59.491]         }, add = TRUE)
[17:47:59.491]     }
[17:47:59.491]     ...future.frame <- base::sys.nframe()
[17:47:59.491]     ...future.conditions <- base::list()
[17:47:59.491]     ...future.rng <- base::globalenv()$.Random.seed
[17:47:59.491]     if (FALSE) {
[17:47:59.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:47:59.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:47:59.491]     }
[17:47:59.491]     ...future.result <- base::tryCatch({
[17:47:59.491]         base::withCallingHandlers({
[17:47:59.491]             ...future.value <- base::withVisible(base::local({
[17:47:59.491]                 ...future.makeSendCondition <- base::local({
[17:47:59.491]                   sendCondition <- NULL
[17:47:59.491]                   function(frame = 1L) {
[17:47:59.491]                     if (is.function(sendCondition)) 
[17:47:59.491]                       return(sendCondition)
[17:47:59.491]                     ns <- getNamespace("parallel")
[17:47:59.491]                     if (exists("sendData", mode = "function", 
[17:47:59.491]                       envir = ns)) {
[17:47:59.491]                       parallel_sendData <- get("sendData", mode = "function", 
[17:47:59.491]                         envir = ns)
[17:47:59.491]                       envir <- sys.frame(frame)
[17:47:59.491]                       master <- NULL
[17:47:59.491]                       while (!identical(envir, .GlobalEnv) && 
[17:47:59.491]                         !identical(envir, emptyenv())) {
[17:47:59.491]                         if (exists("master", mode = "list", envir = envir, 
[17:47:59.491]                           inherits = FALSE)) {
[17:47:59.491]                           master <- get("master", mode = "list", 
[17:47:59.491]                             envir = envir, inherits = FALSE)
[17:47:59.491]                           if (inherits(master, c("SOCKnode", 
[17:47:59.491]                             "SOCK0node"))) {
[17:47:59.491]                             sendCondition <<- function(cond) {
[17:47:59.491]                               data <- list(type = "VALUE", value = cond, 
[17:47:59.491]                                 success = TRUE)
[17:47:59.491]                               parallel_sendData(master, data)
[17:47:59.491]                             }
[17:47:59.491]                             return(sendCondition)
[17:47:59.491]                           }
[17:47:59.491]                         }
[17:47:59.491]                         frame <- frame + 1L
[17:47:59.491]                         envir <- sys.frame(frame)
[17:47:59.491]                       }
[17:47:59.491]                     }
[17:47:59.491]                     sendCondition <<- function(cond) NULL
[17:47:59.491]                   }
[17:47:59.491]                 })
[17:47:59.491]                 withCallingHandlers({
[17:47:59.491]                   {
[17:47:59.491]                     Sys.sleep(0.5)
[17:47:59.491]                     list(a = 1, b = 42L)
[17:47:59.491]                   }
[17:47:59.491]                 }, immediateCondition = function(cond) {
[17:47:59.491]                   sendCondition <- ...future.makeSendCondition()
[17:47:59.491]                   sendCondition(cond)
[17:47:59.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:59.491]                   {
[17:47:59.491]                     inherits <- base::inherits
[17:47:59.491]                     invokeRestart <- base::invokeRestart
[17:47:59.491]                     is.null <- base::is.null
[17:47:59.491]                     muffled <- FALSE
[17:47:59.491]                     if (inherits(cond, "message")) {
[17:47:59.491]                       muffled <- grepl(pattern, "muffleMessage")
[17:47:59.491]                       if (muffled) 
[17:47:59.491]                         invokeRestart("muffleMessage")
[17:47:59.491]                     }
[17:47:59.491]                     else if (inherits(cond, "warning")) {
[17:47:59.491]                       muffled <- grepl(pattern, "muffleWarning")
[17:47:59.491]                       if (muffled) 
[17:47:59.491]                         invokeRestart("muffleWarning")
[17:47:59.491]                     }
[17:47:59.491]                     else if (inherits(cond, "condition")) {
[17:47:59.491]                       if (!is.null(pattern)) {
[17:47:59.491]                         computeRestarts <- base::computeRestarts
[17:47:59.491]                         grepl <- base::grepl
[17:47:59.491]                         restarts <- computeRestarts(cond)
[17:47:59.491]                         for (restart in restarts) {
[17:47:59.491]                           name <- restart$name
[17:47:59.491]                           if (is.null(name)) 
[17:47:59.491]                             next
[17:47:59.491]                           if (!grepl(pattern, name)) 
[17:47:59.491]                             next
[17:47:59.491]                           invokeRestart(restart)
[17:47:59.491]                           muffled <- TRUE
[17:47:59.491]                           break
[17:47:59.491]                         }
[17:47:59.491]                       }
[17:47:59.491]                     }
[17:47:59.491]                     invisible(muffled)
[17:47:59.491]                   }
[17:47:59.491]                   muffleCondition(cond)
[17:47:59.491]                 })
[17:47:59.491]             }))
[17:47:59.491]             future::FutureResult(value = ...future.value$value, 
[17:47:59.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:59.491]                   ...future.rng), globalenv = if (FALSE) 
[17:47:59.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:47:59.491]                     ...future.globalenv.names))
[17:47:59.491]                 else NULL, started = ...future.startTime, version = "1.8")
[17:47:59.491]         }, condition = base::local({
[17:47:59.491]             c <- base::c
[17:47:59.491]             inherits <- base::inherits
[17:47:59.491]             invokeRestart <- base::invokeRestart
[17:47:59.491]             length <- base::length
[17:47:59.491]             list <- base::list
[17:47:59.491]             seq.int <- base::seq.int
[17:47:59.491]             signalCondition <- base::signalCondition
[17:47:59.491]             sys.calls <- base::sys.calls
[17:47:59.491]             `[[` <- base::`[[`
[17:47:59.491]             `+` <- base::`+`
[17:47:59.491]             `<<-` <- base::`<<-`
[17:47:59.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:47:59.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:47:59.491]                   3L)]
[17:47:59.491]             }
[17:47:59.491]             function(cond) {
[17:47:59.491]                 is_error <- inherits(cond, "error")
[17:47:59.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:47:59.491]                   NULL)
[17:47:59.491]                 if (is_error) {
[17:47:59.491]                   sessionInformation <- function() {
[17:47:59.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:47:59.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:47:59.491]                       search = base::search(), system = base::Sys.info())
[17:47:59.491]                   }
[17:47:59.491]                   ...future.conditions[[length(...future.conditions) + 
[17:47:59.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:47:59.491]                     cond$call), session = sessionInformation(), 
[17:47:59.491]                     timestamp = base::Sys.time(), signaled = 0L)
[17:47:59.491]                   signalCondition(cond)
[17:47:59.491]                 }
[17:47:59.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:47:59.491]                 "immediateCondition"))) {
[17:47:59.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:47:59.491]                   ...future.conditions[[length(...future.conditions) + 
[17:47:59.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:47:59.491]                   if (TRUE && !signal) {
[17:47:59.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:59.491]                     {
[17:47:59.491]                       inherits <- base::inherits
[17:47:59.491]                       invokeRestart <- base::invokeRestart
[17:47:59.491]                       is.null <- base::is.null
[17:47:59.491]                       muffled <- FALSE
[17:47:59.491]                       if (inherits(cond, "message")) {
[17:47:59.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:59.491]                         if (muffled) 
[17:47:59.491]                           invokeRestart("muffleMessage")
[17:47:59.491]                       }
[17:47:59.491]                       else if (inherits(cond, "warning")) {
[17:47:59.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:59.491]                         if (muffled) 
[17:47:59.491]                           invokeRestart("muffleWarning")
[17:47:59.491]                       }
[17:47:59.491]                       else if (inherits(cond, "condition")) {
[17:47:59.491]                         if (!is.null(pattern)) {
[17:47:59.491]                           computeRestarts <- base::computeRestarts
[17:47:59.491]                           grepl <- base::grepl
[17:47:59.491]                           restarts <- computeRestarts(cond)
[17:47:59.491]                           for (restart in restarts) {
[17:47:59.491]                             name <- restart$name
[17:47:59.491]                             if (is.null(name)) 
[17:47:59.491]                               next
[17:47:59.491]                             if (!grepl(pattern, name)) 
[17:47:59.491]                               next
[17:47:59.491]                             invokeRestart(restart)
[17:47:59.491]                             muffled <- TRUE
[17:47:59.491]                             break
[17:47:59.491]                           }
[17:47:59.491]                         }
[17:47:59.491]                       }
[17:47:59.491]                       invisible(muffled)
[17:47:59.491]                     }
[17:47:59.491]                     muffleCondition(cond, pattern = "^muffle")
[17:47:59.491]                   }
[17:47:59.491]                 }
[17:47:59.491]                 else {
[17:47:59.491]                   if (TRUE) {
[17:47:59.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:47:59.491]                     {
[17:47:59.491]                       inherits <- base::inherits
[17:47:59.491]                       invokeRestart <- base::invokeRestart
[17:47:59.491]                       is.null <- base::is.null
[17:47:59.491]                       muffled <- FALSE
[17:47:59.491]                       if (inherits(cond, "message")) {
[17:47:59.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:47:59.491]                         if (muffled) 
[17:47:59.491]                           invokeRestart("muffleMessage")
[17:47:59.491]                       }
[17:47:59.491]                       else if (inherits(cond, "warning")) {
[17:47:59.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:47:59.491]                         if (muffled) 
[17:47:59.491]                           invokeRestart("muffleWarning")
[17:47:59.491]                       }
[17:47:59.491]                       else if (inherits(cond, "condition")) {
[17:47:59.491]                         if (!is.null(pattern)) {
[17:47:59.491]                           computeRestarts <- base::computeRestarts
[17:47:59.491]                           grepl <- base::grepl
[17:47:59.491]                           restarts <- computeRestarts(cond)
[17:47:59.491]                           for (restart in restarts) {
[17:47:59.491]                             name <- restart$name
[17:47:59.491]                             if (is.null(name)) 
[17:47:59.491]                               next
[17:47:59.491]                             if (!grepl(pattern, name)) 
[17:47:59.491]                               next
[17:47:59.491]                             invokeRestart(restart)
[17:47:59.491]                             muffled <- TRUE
[17:47:59.491]                             break
[17:47:59.491]                           }
[17:47:59.491]                         }
[17:47:59.491]                       }
[17:47:59.491]                       invisible(muffled)
[17:47:59.491]                     }
[17:47:59.491]                     muffleCondition(cond, pattern = "^muffle")
[17:47:59.491]                   }
[17:47:59.491]                 }
[17:47:59.491]             }
[17:47:59.491]         }))
[17:47:59.491]     }, error = function(ex) {
[17:47:59.491]         base::structure(base::list(value = NULL, visible = NULL, 
[17:47:59.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:47:59.491]                 ...future.rng), started = ...future.startTime, 
[17:47:59.491]             finished = Sys.time(), session_uuid = NA_character_, 
[17:47:59.491]             version = "1.8"), class = "FutureResult")
[17:47:59.491]     }, finally = {
[17:47:59.491]         if (!identical(...future.workdir, getwd())) 
[17:47:59.491]             setwd(...future.workdir)
[17:47:59.491]         {
[17:47:59.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:47:59.491]                 ...future.oldOptions$nwarnings <- NULL
[17:47:59.491]             }
[17:47:59.491]             base::options(...future.oldOptions)
[17:47:59.491]             if (.Platform$OS.type == "windows") {
[17:47:59.491]                 old_names <- names(...future.oldEnvVars)
[17:47:59.491]                 envs <- base::Sys.getenv()
[17:47:59.491]                 names <- names(envs)
[17:47:59.491]                 common <- intersect(names, old_names)
[17:47:59.491]                 added <- setdiff(names, old_names)
[17:47:59.491]                 removed <- setdiff(old_names, names)
[17:47:59.491]                 changed <- common[...future.oldEnvVars[common] != 
[17:47:59.491]                   envs[common]]
[17:47:59.491]                 NAMES <- toupper(changed)
[17:47:59.491]                 args <- list()
[17:47:59.491]                 for (kk in seq_along(NAMES)) {
[17:47:59.491]                   name <- changed[[kk]]
[17:47:59.491]                   NAME <- NAMES[[kk]]
[17:47:59.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:59.491]                     next
[17:47:59.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:59.491]                 }
[17:47:59.491]                 NAMES <- toupper(added)
[17:47:59.491]                 for (kk in seq_along(NAMES)) {
[17:47:59.491]                   name <- added[[kk]]
[17:47:59.491]                   NAME <- NAMES[[kk]]
[17:47:59.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:59.491]                     next
[17:47:59.491]                   args[[name]] <- ""
[17:47:59.491]                 }
[17:47:59.491]                 NAMES <- toupper(removed)
[17:47:59.491]                 for (kk in seq_along(NAMES)) {
[17:47:59.491]                   name <- removed[[kk]]
[17:47:59.491]                   NAME <- NAMES[[kk]]
[17:47:59.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:47:59.491]                     next
[17:47:59.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:47:59.491]                 }
[17:47:59.491]                 if (length(args) > 0) 
[17:47:59.491]                   base::do.call(base::Sys.setenv, args = args)
[17:47:59.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:47:59.491]             }
[17:47:59.491]             else {
[17:47:59.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:47:59.491]             }
[17:47:59.491]             {
[17:47:59.491]                 if (base::length(...future.futureOptionsAdded) > 
[17:47:59.491]                   0L) {
[17:47:59.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:47:59.491]                   base::names(opts) <- ...future.futureOptionsAdded
[17:47:59.491]                   base::options(opts)
[17:47:59.491]                 }
[17:47:59.491]                 {
[17:47:59.491]                   {
[17:47:59.491]                     base::options(mc.cores = ...future.mc.cores.old)
[17:47:59.491]                     NULL
[17:47:59.491]                   }
[17:47:59.491]                   options(future.plan = NULL)
[17:47:59.491]                   if (is.na(NA_character_)) 
[17:47:59.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:47:59.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:47:59.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:47:59.491]                     .init = FALSE)
[17:47:59.491]                 }
[17:47:59.491]             }
[17:47:59.491]         }
[17:47:59.491]     })
[17:47:59.491]     if (TRUE) {
[17:47:59.491]         base::sink(type = "output", split = FALSE)
[17:47:59.491]         if (TRUE) {
[17:47:59.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:47:59.491]         }
[17:47:59.491]         else {
[17:47:59.491]             ...future.result["stdout"] <- base::list(NULL)
[17:47:59.491]         }
[17:47:59.491]         base::close(...future.stdout)
[17:47:59.491]         ...future.stdout <- NULL
[17:47:59.491]     }
[17:47:59.491]     ...future.result$conditions <- ...future.conditions
[17:47:59.491]     ...future.result$finished <- base::Sys.time()
[17:47:59.491]     ...future.result
[17:47:59.491] }
[17:47:59.494] MultisessionFuture started
[17:47:59.494] - Launch lazy future ... done
[17:47:59.495] run() for ‘MultisessionFuture’ ... done
[17:48:00.011] receiveMessageFromWorker() for ClusterFuture ...
[17:48:00.011] - Validating connection of MultisessionFuture
[17:48:00.011] - received message: FutureResult
[17:48:00.011] - Received FutureResult
[17:48:00.011] - Erased future from FutureRegistry
[17:48:00.012] result() for ClusterFuture ...
[17:48:00.012] - result already collected: FutureResult
[17:48:00.012] result() for ClusterFuture ... done
[17:48:00.012] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:00.012] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:48:00.012] getGlobalsAndPackages() ...
[17:48:00.012] Searching for globals...
[17:48:00.013] - globals found: [2] ‘list’, ‘stop’
[17:48:00.013] Searching for globals ... DONE
[17:48:00.013] Resolving globals: FALSE
[17:48:00.013] 
[17:48:00.014] 
[17:48:00.014] getGlobalsAndPackages() ... DONE
[17:48:00.014] run() for ‘Future’ ...
[17:48:00.014] - state: ‘created’
[17:48:00.014] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:00.028] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:00.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:00.028]   - Field: ‘node’
[17:48:00.028]   - Field: ‘label’
[17:48:00.028]   - Field: ‘local’
[17:48:00.028]   - Field: ‘owner’
[17:48:00.029]   - Field: ‘envir’
[17:48:00.029]   - Field: ‘workers’
[17:48:00.029]   - Field: ‘packages’
[17:48:00.029]   - Field: ‘gc’
[17:48:00.029]   - Field: ‘conditions’
[17:48:00.029]   - Field: ‘persistent’
[17:48:00.029]   - Field: ‘expr’
[17:48:00.029]   - Field: ‘uuid’
[17:48:00.029]   - Field: ‘seed’
[17:48:00.029]   - Field: ‘version’
[17:48:00.029]   - Field: ‘result’
[17:48:00.029]   - Field: ‘asynchronous’
[17:48:00.030]   - Field: ‘calls’
[17:48:00.030]   - Field: ‘globals’
[17:48:00.030]   - Field: ‘stdout’
[17:48:00.030]   - Field: ‘earlySignal’
[17:48:00.030]   - Field: ‘lazy’
[17:48:00.030]   - Field: ‘state’
[17:48:00.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:00.030] - Launch lazy future ...
[17:48:00.030] Packages needed by the future expression (n = 0): <none>
[17:48:00.031] Packages needed by future strategies (n = 0): <none>
[17:48:00.031] {
[17:48:00.031]     {
[17:48:00.031]         {
[17:48:00.031]             ...future.startTime <- base::Sys.time()
[17:48:00.031]             {
[17:48:00.031]                 {
[17:48:00.031]                   {
[17:48:00.031]                     {
[17:48:00.031]                       base::local({
[17:48:00.031]                         has_future <- base::requireNamespace("future", 
[17:48:00.031]                           quietly = TRUE)
[17:48:00.031]                         if (has_future) {
[17:48:00.031]                           ns <- base::getNamespace("future")
[17:48:00.031]                           version <- ns[[".package"]][["version"]]
[17:48:00.031]                           if (is.null(version)) 
[17:48:00.031]                             version <- utils::packageVersion("future")
[17:48:00.031]                         }
[17:48:00.031]                         else {
[17:48:00.031]                           version <- NULL
[17:48:00.031]                         }
[17:48:00.031]                         if (!has_future || version < "1.8.0") {
[17:48:00.031]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:00.031]                             "", base::R.version$version.string), 
[17:48:00.031]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:00.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:00.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:00.031]                               "release", "version")], collapse = " "), 
[17:48:00.031]                             hostname = base::Sys.info()[["nodename"]])
[17:48:00.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:00.031]                             info)
[17:48:00.031]                           info <- base::paste(info, collapse = "; ")
[17:48:00.031]                           if (!has_future) {
[17:48:00.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:00.031]                               info)
[17:48:00.031]                           }
[17:48:00.031]                           else {
[17:48:00.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:00.031]                               info, version)
[17:48:00.031]                           }
[17:48:00.031]                           base::stop(msg)
[17:48:00.031]                         }
[17:48:00.031]                       })
[17:48:00.031]                     }
[17:48:00.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:00.031]                     base::options(mc.cores = 1L)
[17:48:00.031]                   }
[17:48:00.031]                   ...future.strategy.old <- future::plan("list")
[17:48:00.031]                   options(future.plan = NULL)
[17:48:00.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:00.031]                 }
[17:48:00.031]                 ...future.workdir <- getwd()
[17:48:00.031]             }
[17:48:00.031]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:00.031]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:00.031]         }
[17:48:00.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:00.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:00.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:00.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:00.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:00.031]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:00.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:00.031]             base::names(...future.oldOptions))
[17:48:00.031]     }
[17:48:00.031]     if (FALSE) {
[17:48:00.031]     }
[17:48:00.031]     else {
[17:48:00.031]         if (TRUE) {
[17:48:00.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:00.031]                 open = "w")
[17:48:00.031]         }
[17:48:00.031]         else {
[17:48:00.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:00.031]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:00.031]         }
[17:48:00.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:00.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:00.031]             base::sink(type = "output", split = FALSE)
[17:48:00.031]             base::close(...future.stdout)
[17:48:00.031]         }, add = TRUE)
[17:48:00.031]     }
[17:48:00.031]     ...future.frame <- base::sys.nframe()
[17:48:00.031]     ...future.conditions <- base::list()
[17:48:00.031]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:00.031]     if (FALSE) {
[17:48:00.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:00.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:00.031]     }
[17:48:00.031]     ...future.result <- base::tryCatch({
[17:48:00.031]         base::withCallingHandlers({
[17:48:00.031]             ...future.value <- base::withVisible(base::local({
[17:48:00.031]                 ...future.makeSendCondition <- base::local({
[17:48:00.031]                   sendCondition <- NULL
[17:48:00.031]                   function(frame = 1L) {
[17:48:00.031]                     if (is.function(sendCondition)) 
[17:48:00.031]                       return(sendCondition)
[17:48:00.031]                     ns <- getNamespace("parallel")
[17:48:00.031]                     if (exists("sendData", mode = "function", 
[17:48:00.031]                       envir = ns)) {
[17:48:00.031]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:00.031]                         envir = ns)
[17:48:00.031]                       envir <- sys.frame(frame)
[17:48:00.031]                       master <- NULL
[17:48:00.031]                       while (!identical(envir, .GlobalEnv) && 
[17:48:00.031]                         !identical(envir, emptyenv())) {
[17:48:00.031]                         if (exists("master", mode = "list", envir = envir, 
[17:48:00.031]                           inherits = FALSE)) {
[17:48:00.031]                           master <- get("master", mode = "list", 
[17:48:00.031]                             envir = envir, inherits = FALSE)
[17:48:00.031]                           if (inherits(master, c("SOCKnode", 
[17:48:00.031]                             "SOCK0node"))) {
[17:48:00.031]                             sendCondition <<- function(cond) {
[17:48:00.031]                               data <- list(type = "VALUE", value = cond, 
[17:48:00.031]                                 success = TRUE)
[17:48:00.031]                               parallel_sendData(master, data)
[17:48:00.031]                             }
[17:48:00.031]                             return(sendCondition)
[17:48:00.031]                           }
[17:48:00.031]                         }
[17:48:00.031]                         frame <- frame + 1L
[17:48:00.031]                         envir <- sys.frame(frame)
[17:48:00.031]                       }
[17:48:00.031]                     }
[17:48:00.031]                     sendCondition <<- function(cond) NULL
[17:48:00.031]                   }
[17:48:00.031]                 })
[17:48:00.031]                 withCallingHandlers({
[17:48:00.031]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:00.031]                 }, immediateCondition = function(cond) {
[17:48:00.031]                   sendCondition <- ...future.makeSendCondition()
[17:48:00.031]                   sendCondition(cond)
[17:48:00.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.031]                   {
[17:48:00.031]                     inherits <- base::inherits
[17:48:00.031]                     invokeRestart <- base::invokeRestart
[17:48:00.031]                     is.null <- base::is.null
[17:48:00.031]                     muffled <- FALSE
[17:48:00.031]                     if (inherits(cond, "message")) {
[17:48:00.031]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:00.031]                       if (muffled) 
[17:48:00.031]                         invokeRestart("muffleMessage")
[17:48:00.031]                     }
[17:48:00.031]                     else if (inherits(cond, "warning")) {
[17:48:00.031]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:00.031]                       if (muffled) 
[17:48:00.031]                         invokeRestart("muffleWarning")
[17:48:00.031]                     }
[17:48:00.031]                     else if (inherits(cond, "condition")) {
[17:48:00.031]                       if (!is.null(pattern)) {
[17:48:00.031]                         computeRestarts <- base::computeRestarts
[17:48:00.031]                         grepl <- base::grepl
[17:48:00.031]                         restarts <- computeRestarts(cond)
[17:48:00.031]                         for (restart in restarts) {
[17:48:00.031]                           name <- restart$name
[17:48:00.031]                           if (is.null(name)) 
[17:48:00.031]                             next
[17:48:00.031]                           if (!grepl(pattern, name)) 
[17:48:00.031]                             next
[17:48:00.031]                           invokeRestart(restart)
[17:48:00.031]                           muffled <- TRUE
[17:48:00.031]                           break
[17:48:00.031]                         }
[17:48:00.031]                       }
[17:48:00.031]                     }
[17:48:00.031]                     invisible(muffled)
[17:48:00.031]                   }
[17:48:00.031]                   muffleCondition(cond)
[17:48:00.031]                 })
[17:48:00.031]             }))
[17:48:00.031]             future::FutureResult(value = ...future.value$value, 
[17:48:00.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.031]                   ...future.rng), globalenv = if (FALSE) 
[17:48:00.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:00.031]                     ...future.globalenv.names))
[17:48:00.031]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:00.031]         }, condition = base::local({
[17:48:00.031]             c <- base::c
[17:48:00.031]             inherits <- base::inherits
[17:48:00.031]             invokeRestart <- base::invokeRestart
[17:48:00.031]             length <- base::length
[17:48:00.031]             list <- base::list
[17:48:00.031]             seq.int <- base::seq.int
[17:48:00.031]             signalCondition <- base::signalCondition
[17:48:00.031]             sys.calls <- base::sys.calls
[17:48:00.031]             `[[` <- base::`[[`
[17:48:00.031]             `+` <- base::`+`
[17:48:00.031]             `<<-` <- base::`<<-`
[17:48:00.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:00.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:00.031]                   3L)]
[17:48:00.031]             }
[17:48:00.031]             function(cond) {
[17:48:00.031]                 is_error <- inherits(cond, "error")
[17:48:00.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:00.031]                   NULL)
[17:48:00.031]                 if (is_error) {
[17:48:00.031]                   sessionInformation <- function() {
[17:48:00.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:00.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:00.031]                       search = base::search(), system = base::Sys.info())
[17:48:00.031]                   }
[17:48:00.031]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:00.031]                     cond$call), session = sessionInformation(), 
[17:48:00.031]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:00.031]                   signalCondition(cond)
[17:48:00.031]                 }
[17:48:00.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:00.031]                 "immediateCondition"))) {
[17:48:00.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:00.031]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:00.031]                   if (TRUE && !signal) {
[17:48:00.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.031]                     {
[17:48:00.031]                       inherits <- base::inherits
[17:48:00.031]                       invokeRestart <- base::invokeRestart
[17:48:00.031]                       is.null <- base::is.null
[17:48:00.031]                       muffled <- FALSE
[17:48:00.031]                       if (inherits(cond, "message")) {
[17:48:00.031]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.031]                         if (muffled) 
[17:48:00.031]                           invokeRestart("muffleMessage")
[17:48:00.031]                       }
[17:48:00.031]                       else if (inherits(cond, "warning")) {
[17:48:00.031]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.031]                         if (muffled) 
[17:48:00.031]                           invokeRestart("muffleWarning")
[17:48:00.031]                       }
[17:48:00.031]                       else if (inherits(cond, "condition")) {
[17:48:00.031]                         if (!is.null(pattern)) {
[17:48:00.031]                           computeRestarts <- base::computeRestarts
[17:48:00.031]                           grepl <- base::grepl
[17:48:00.031]                           restarts <- computeRestarts(cond)
[17:48:00.031]                           for (restart in restarts) {
[17:48:00.031]                             name <- restart$name
[17:48:00.031]                             if (is.null(name)) 
[17:48:00.031]                               next
[17:48:00.031]                             if (!grepl(pattern, name)) 
[17:48:00.031]                               next
[17:48:00.031]                             invokeRestart(restart)
[17:48:00.031]                             muffled <- TRUE
[17:48:00.031]                             break
[17:48:00.031]                           }
[17:48:00.031]                         }
[17:48:00.031]                       }
[17:48:00.031]                       invisible(muffled)
[17:48:00.031]                     }
[17:48:00.031]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.031]                   }
[17:48:00.031]                 }
[17:48:00.031]                 else {
[17:48:00.031]                   if (TRUE) {
[17:48:00.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.031]                     {
[17:48:00.031]                       inherits <- base::inherits
[17:48:00.031]                       invokeRestart <- base::invokeRestart
[17:48:00.031]                       is.null <- base::is.null
[17:48:00.031]                       muffled <- FALSE
[17:48:00.031]                       if (inherits(cond, "message")) {
[17:48:00.031]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.031]                         if (muffled) 
[17:48:00.031]                           invokeRestart("muffleMessage")
[17:48:00.031]                       }
[17:48:00.031]                       else if (inherits(cond, "warning")) {
[17:48:00.031]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.031]                         if (muffled) 
[17:48:00.031]                           invokeRestart("muffleWarning")
[17:48:00.031]                       }
[17:48:00.031]                       else if (inherits(cond, "condition")) {
[17:48:00.031]                         if (!is.null(pattern)) {
[17:48:00.031]                           computeRestarts <- base::computeRestarts
[17:48:00.031]                           grepl <- base::grepl
[17:48:00.031]                           restarts <- computeRestarts(cond)
[17:48:00.031]                           for (restart in restarts) {
[17:48:00.031]                             name <- restart$name
[17:48:00.031]                             if (is.null(name)) 
[17:48:00.031]                               next
[17:48:00.031]                             if (!grepl(pattern, name)) 
[17:48:00.031]                               next
[17:48:00.031]                             invokeRestart(restart)
[17:48:00.031]                             muffled <- TRUE
[17:48:00.031]                             break
[17:48:00.031]                           }
[17:48:00.031]                         }
[17:48:00.031]                       }
[17:48:00.031]                       invisible(muffled)
[17:48:00.031]                     }
[17:48:00.031]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.031]                   }
[17:48:00.031]                 }
[17:48:00.031]             }
[17:48:00.031]         }))
[17:48:00.031]     }, error = function(ex) {
[17:48:00.031]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:00.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.031]                 ...future.rng), started = ...future.startTime, 
[17:48:00.031]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:00.031]             version = "1.8"), class = "FutureResult")
[17:48:00.031]     }, finally = {
[17:48:00.031]         if (!identical(...future.workdir, getwd())) 
[17:48:00.031]             setwd(...future.workdir)
[17:48:00.031]         {
[17:48:00.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:00.031]                 ...future.oldOptions$nwarnings <- NULL
[17:48:00.031]             }
[17:48:00.031]             base::options(...future.oldOptions)
[17:48:00.031]             if (.Platform$OS.type == "windows") {
[17:48:00.031]                 old_names <- names(...future.oldEnvVars)
[17:48:00.031]                 envs <- base::Sys.getenv()
[17:48:00.031]                 names <- names(envs)
[17:48:00.031]                 common <- intersect(names, old_names)
[17:48:00.031]                 added <- setdiff(names, old_names)
[17:48:00.031]                 removed <- setdiff(old_names, names)
[17:48:00.031]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:00.031]                   envs[common]]
[17:48:00.031]                 NAMES <- toupper(changed)
[17:48:00.031]                 args <- list()
[17:48:00.031]                 for (kk in seq_along(NAMES)) {
[17:48:00.031]                   name <- changed[[kk]]
[17:48:00.031]                   NAME <- NAMES[[kk]]
[17:48:00.031]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.031]                     next
[17:48:00.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.031]                 }
[17:48:00.031]                 NAMES <- toupper(added)
[17:48:00.031]                 for (kk in seq_along(NAMES)) {
[17:48:00.031]                   name <- added[[kk]]
[17:48:00.031]                   NAME <- NAMES[[kk]]
[17:48:00.031]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.031]                     next
[17:48:00.031]                   args[[name]] <- ""
[17:48:00.031]                 }
[17:48:00.031]                 NAMES <- toupper(removed)
[17:48:00.031]                 for (kk in seq_along(NAMES)) {
[17:48:00.031]                   name <- removed[[kk]]
[17:48:00.031]                   NAME <- NAMES[[kk]]
[17:48:00.031]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.031]                     next
[17:48:00.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.031]                 }
[17:48:00.031]                 if (length(args) > 0) 
[17:48:00.031]                   base::do.call(base::Sys.setenv, args = args)
[17:48:00.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:00.031]             }
[17:48:00.031]             else {
[17:48:00.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:00.031]             }
[17:48:00.031]             {
[17:48:00.031]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:00.031]                   0L) {
[17:48:00.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:00.031]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:00.031]                   base::options(opts)
[17:48:00.031]                 }
[17:48:00.031]                 {
[17:48:00.031]                   {
[17:48:00.031]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:00.031]                     NULL
[17:48:00.031]                   }
[17:48:00.031]                   options(future.plan = NULL)
[17:48:00.031]                   if (is.na(NA_character_)) 
[17:48:00.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:00.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:00.031]                     .init = FALSE)
[17:48:00.031]                 }
[17:48:00.031]             }
[17:48:00.031]         }
[17:48:00.031]     })
[17:48:00.031]     if (TRUE) {
[17:48:00.031]         base::sink(type = "output", split = FALSE)
[17:48:00.031]         if (TRUE) {
[17:48:00.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:00.031]         }
[17:48:00.031]         else {
[17:48:00.031]             ...future.result["stdout"] <- base::list(NULL)
[17:48:00.031]         }
[17:48:00.031]         base::close(...future.stdout)
[17:48:00.031]         ...future.stdout <- NULL
[17:48:00.031]     }
[17:48:00.031]     ...future.result$conditions <- ...future.conditions
[17:48:00.031]     ...future.result$finished <- base::Sys.time()
[17:48:00.031]     ...future.result
[17:48:00.031] }
[17:48:00.034] MultisessionFuture started
[17:48:00.034] - Launch lazy future ... done
[17:48:00.034] run() for ‘MultisessionFuture’ ... done
[17:48:00.036] receiveMessageFromWorker() for ClusterFuture ...
[17:48:00.036] - Validating connection of MultisessionFuture
[17:48:00.039] - received message: FutureResult
[17:48:00.039] - Received FutureResult
[17:48:00.039] - Erased future from FutureRegistry
[17:48:00.039] result() for ClusterFuture ...
[17:48:00.039] - result already collected: FutureResult
[17:48:00.039] result() for ClusterFuture ... done
[17:48:00.039] signalConditions() ...
[17:48:00.039]  - include = ‘immediateCondition’
[17:48:00.039]  - exclude = 
[17:48:00.040]  - resignal = FALSE
[17:48:00.040]  - Number of conditions: 1
[17:48:00.040] signalConditions() ... done
[17:48:00.040] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:00.040] A MultisessionFuture was resolved (result was not collected)
[17:48:00.040] getGlobalsAndPackages() ...
[17:48:00.040] Searching for globals...
[17:48:00.041] - globals found: [2] ‘list’, ‘stop’
[17:48:00.041] Searching for globals ... DONE
[17:48:00.041] Resolving globals: FALSE
[17:48:00.041] 
[17:48:00.041] 
[17:48:00.041] getGlobalsAndPackages() ... DONE
[17:48:00.042] run() for ‘Future’ ...
[17:48:00.042] - state: ‘created’
[17:48:00.042] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:00.056] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:00.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:00.056]   - Field: ‘node’
[17:48:00.056]   - Field: ‘label’
[17:48:00.056]   - Field: ‘local’
[17:48:00.056]   - Field: ‘owner’
[17:48:00.056]   - Field: ‘envir’
[17:48:00.056]   - Field: ‘workers’
[17:48:00.056]   - Field: ‘packages’
[17:48:00.057]   - Field: ‘gc’
[17:48:00.057]   - Field: ‘conditions’
[17:48:00.057]   - Field: ‘persistent’
[17:48:00.057]   - Field: ‘expr’
[17:48:00.057]   - Field: ‘uuid’
[17:48:00.057]   - Field: ‘seed’
[17:48:00.057]   - Field: ‘version’
[17:48:00.057]   - Field: ‘result’
[17:48:00.057]   - Field: ‘asynchronous’
[17:48:00.057]   - Field: ‘calls’
[17:48:00.057]   - Field: ‘globals’
[17:48:00.057]   - Field: ‘stdout’
[17:48:00.058]   - Field: ‘earlySignal’
[17:48:00.058]   - Field: ‘lazy’
[17:48:00.058]   - Field: ‘state’
[17:48:00.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:00.058] - Launch lazy future ...
[17:48:00.058] Packages needed by the future expression (n = 0): <none>
[17:48:00.058] Packages needed by future strategies (n = 0): <none>
[17:48:00.059] {
[17:48:00.059]     {
[17:48:00.059]         {
[17:48:00.059]             ...future.startTime <- base::Sys.time()
[17:48:00.059]             {
[17:48:00.059]                 {
[17:48:00.059]                   {
[17:48:00.059]                     {
[17:48:00.059]                       base::local({
[17:48:00.059]                         has_future <- base::requireNamespace("future", 
[17:48:00.059]                           quietly = TRUE)
[17:48:00.059]                         if (has_future) {
[17:48:00.059]                           ns <- base::getNamespace("future")
[17:48:00.059]                           version <- ns[[".package"]][["version"]]
[17:48:00.059]                           if (is.null(version)) 
[17:48:00.059]                             version <- utils::packageVersion("future")
[17:48:00.059]                         }
[17:48:00.059]                         else {
[17:48:00.059]                           version <- NULL
[17:48:00.059]                         }
[17:48:00.059]                         if (!has_future || version < "1.8.0") {
[17:48:00.059]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:00.059]                             "", base::R.version$version.string), 
[17:48:00.059]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:00.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:00.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:00.059]                               "release", "version")], collapse = " "), 
[17:48:00.059]                             hostname = base::Sys.info()[["nodename"]])
[17:48:00.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:00.059]                             info)
[17:48:00.059]                           info <- base::paste(info, collapse = "; ")
[17:48:00.059]                           if (!has_future) {
[17:48:00.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:00.059]                               info)
[17:48:00.059]                           }
[17:48:00.059]                           else {
[17:48:00.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:00.059]                               info, version)
[17:48:00.059]                           }
[17:48:00.059]                           base::stop(msg)
[17:48:00.059]                         }
[17:48:00.059]                       })
[17:48:00.059]                     }
[17:48:00.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:00.059]                     base::options(mc.cores = 1L)
[17:48:00.059]                   }
[17:48:00.059]                   ...future.strategy.old <- future::plan("list")
[17:48:00.059]                   options(future.plan = NULL)
[17:48:00.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:00.059]                 }
[17:48:00.059]                 ...future.workdir <- getwd()
[17:48:00.059]             }
[17:48:00.059]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:00.059]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:00.059]         }
[17:48:00.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:00.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:00.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:00.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:00.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:00.059]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:00.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:00.059]             base::names(...future.oldOptions))
[17:48:00.059]     }
[17:48:00.059]     if (FALSE) {
[17:48:00.059]     }
[17:48:00.059]     else {
[17:48:00.059]         if (TRUE) {
[17:48:00.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:00.059]                 open = "w")
[17:48:00.059]         }
[17:48:00.059]         else {
[17:48:00.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:00.059]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:00.059]         }
[17:48:00.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:00.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:00.059]             base::sink(type = "output", split = FALSE)
[17:48:00.059]             base::close(...future.stdout)
[17:48:00.059]         }, add = TRUE)
[17:48:00.059]     }
[17:48:00.059]     ...future.frame <- base::sys.nframe()
[17:48:00.059]     ...future.conditions <- base::list()
[17:48:00.059]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:00.059]     if (FALSE) {
[17:48:00.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:00.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:00.059]     }
[17:48:00.059]     ...future.result <- base::tryCatch({
[17:48:00.059]         base::withCallingHandlers({
[17:48:00.059]             ...future.value <- base::withVisible(base::local({
[17:48:00.059]                 ...future.makeSendCondition <- base::local({
[17:48:00.059]                   sendCondition <- NULL
[17:48:00.059]                   function(frame = 1L) {
[17:48:00.059]                     if (is.function(sendCondition)) 
[17:48:00.059]                       return(sendCondition)
[17:48:00.059]                     ns <- getNamespace("parallel")
[17:48:00.059]                     if (exists("sendData", mode = "function", 
[17:48:00.059]                       envir = ns)) {
[17:48:00.059]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:00.059]                         envir = ns)
[17:48:00.059]                       envir <- sys.frame(frame)
[17:48:00.059]                       master <- NULL
[17:48:00.059]                       while (!identical(envir, .GlobalEnv) && 
[17:48:00.059]                         !identical(envir, emptyenv())) {
[17:48:00.059]                         if (exists("master", mode = "list", envir = envir, 
[17:48:00.059]                           inherits = FALSE)) {
[17:48:00.059]                           master <- get("master", mode = "list", 
[17:48:00.059]                             envir = envir, inherits = FALSE)
[17:48:00.059]                           if (inherits(master, c("SOCKnode", 
[17:48:00.059]                             "SOCK0node"))) {
[17:48:00.059]                             sendCondition <<- function(cond) {
[17:48:00.059]                               data <- list(type = "VALUE", value = cond, 
[17:48:00.059]                                 success = TRUE)
[17:48:00.059]                               parallel_sendData(master, data)
[17:48:00.059]                             }
[17:48:00.059]                             return(sendCondition)
[17:48:00.059]                           }
[17:48:00.059]                         }
[17:48:00.059]                         frame <- frame + 1L
[17:48:00.059]                         envir <- sys.frame(frame)
[17:48:00.059]                       }
[17:48:00.059]                     }
[17:48:00.059]                     sendCondition <<- function(cond) NULL
[17:48:00.059]                   }
[17:48:00.059]                 })
[17:48:00.059]                 withCallingHandlers({
[17:48:00.059]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:00.059]                 }, immediateCondition = function(cond) {
[17:48:00.059]                   sendCondition <- ...future.makeSendCondition()
[17:48:00.059]                   sendCondition(cond)
[17:48:00.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.059]                   {
[17:48:00.059]                     inherits <- base::inherits
[17:48:00.059]                     invokeRestart <- base::invokeRestart
[17:48:00.059]                     is.null <- base::is.null
[17:48:00.059]                     muffled <- FALSE
[17:48:00.059]                     if (inherits(cond, "message")) {
[17:48:00.059]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:00.059]                       if (muffled) 
[17:48:00.059]                         invokeRestart("muffleMessage")
[17:48:00.059]                     }
[17:48:00.059]                     else if (inherits(cond, "warning")) {
[17:48:00.059]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:00.059]                       if (muffled) 
[17:48:00.059]                         invokeRestart("muffleWarning")
[17:48:00.059]                     }
[17:48:00.059]                     else if (inherits(cond, "condition")) {
[17:48:00.059]                       if (!is.null(pattern)) {
[17:48:00.059]                         computeRestarts <- base::computeRestarts
[17:48:00.059]                         grepl <- base::grepl
[17:48:00.059]                         restarts <- computeRestarts(cond)
[17:48:00.059]                         for (restart in restarts) {
[17:48:00.059]                           name <- restart$name
[17:48:00.059]                           if (is.null(name)) 
[17:48:00.059]                             next
[17:48:00.059]                           if (!grepl(pattern, name)) 
[17:48:00.059]                             next
[17:48:00.059]                           invokeRestart(restart)
[17:48:00.059]                           muffled <- TRUE
[17:48:00.059]                           break
[17:48:00.059]                         }
[17:48:00.059]                       }
[17:48:00.059]                     }
[17:48:00.059]                     invisible(muffled)
[17:48:00.059]                   }
[17:48:00.059]                   muffleCondition(cond)
[17:48:00.059]                 })
[17:48:00.059]             }))
[17:48:00.059]             future::FutureResult(value = ...future.value$value, 
[17:48:00.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.059]                   ...future.rng), globalenv = if (FALSE) 
[17:48:00.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:00.059]                     ...future.globalenv.names))
[17:48:00.059]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:00.059]         }, condition = base::local({
[17:48:00.059]             c <- base::c
[17:48:00.059]             inherits <- base::inherits
[17:48:00.059]             invokeRestart <- base::invokeRestart
[17:48:00.059]             length <- base::length
[17:48:00.059]             list <- base::list
[17:48:00.059]             seq.int <- base::seq.int
[17:48:00.059]             signalCondition <- base::signalCondition
[17:48:00.059]             sys.calls <- base::sys.calls
[17:48:00.059]             `[[` <- base::`[[`
[17:48:00.059]             `+` <- base::`+`
[17:48:00.059]             `<<-` <- base::`<<-`
[17:48:00.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:00.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:00.059]                   3L)]
[17:48:00.059]             }
[17:48:00.059]             function(cond) {
[17:48:00.059]                 is_error <- inherits(cond, "error")
[17:48:00.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:00.059]                   NULL)
[17:48:00.059]                 if (is_error) {
[17:48:00.059]                   sessionInformation <- function() {
[17:48:00.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:00.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:00.059]                       search = base::search(), system = base::Sys.info())
[17:48:00.059]                   }
[17:48:00.059]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:00.059]                     cond$call), session = sessionInformation(), 
[17:48:00.059]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:00.059]                   signalCondition(cond)
[17:48:00.059]                 }
[17:48:00.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:00.059]                 "immediateCondition"))) {
[17:48:00.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:00.059]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:00.059]                   if (TRUE && !signal) {
[17:48:00.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.059]                     {
[17:48:00.059]                       inherits <- base::inherits
[17:48:00.059]                       invokeRestart <- base::invokeRestart
[17:48:00.059]                       is.null <- base::is.null
[17:48:00.059]                       muffled <- FALSE
[17:48:00.059]                       if (inherits(cond, "message")) {
[17:48:00.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.059]                         if (muffled) 
[17:48:00.059]                           invokeRestart("muffleMessage")
[17:48:00.059]                       }
[17:48:00.059]                       else if (inherits(cond, "warning")) {
[17:48:00.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.059]                         if (muffled) 
[17:48:00.059]                           invokeRestart("muffleWarning")
[17:48:00.059]                       }
[17:48:00.059]                       else if (inherits(cond, "condition")) {
[17:48:00.059]                         if (!is.null(pattern)) {
[17:48:00.059]                           computeRestarts <- base::computeRestarts
[17:48:00.059]                           grepl <- base::grepl
[17:48:00.059]                           restarts <- computeRestarts(cond)
[17:48:00.059]                           for (restart in restarts) {
[17:48:00.059]                             name <- restart$name
[17:48:00.059]                             if (is.null(name)) 
[17:48:00.059]                               next
[17:48:00.059]                             if (!grepl(pattern, name)) 
[17:48:00.059]                               next
[17:48:00.059]                             invokeRestart(restart)
[17:48:00.059]                             muffled <- TRUE
[17:48:00.059]                             break
[17:48:00.059]                           }
[17:48:00.059]                         }
[17:48:00.059]                       }
[17:48:00.059]                       invisible(muffled)
[17:48:00.059]                     }
[17:48:00.059]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.059]                   }
[17:48:00.059]                 }
[17:48:00.059]                 else {
[17:48:00.059]                   if (TRUE) {
[17:48:00.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.059]                     {
[17:48:00.059]                       inherits <- base::inherits
[17:48:00.059]                       invokeRestart <- base::invokeRestart
[17:48:00.059]                       is.null <- base::is.null
[17:48:00.059]                       muffled <- FALSE
[17:48:00.059]                       if (inherits(cond, "message")) {
[17:48:00.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.059]                         if (muffled) 
[17:48:00.059]                           invokeRestart("muffleMessage")
[17:48:00.059]                       }
[17:48:00.059]                       else if (inherits(cond, "warning")) {
[17:48:00.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.059]                         if (muffled) 
[17:48:00.059]                           invokeRestart("muffleWarning")
[17:48:00.059]                       }
[17:48:00.059]                       else if (inherits(cond, "condition")) {
[17:48:00.059]                         if (!is.null(pattern)) {
[17:48:00.059]                           computeRestarts <- base::computeRestarts
[17:48:00.059]                           grepl <- base::grepl
[17:48:00.059]                           restarts <- computeRestarts(cond)
[17:48:00.059]                           for (restart in restarts) {
[17:48:00.059]                             name <- restart$name
[17:48:00.059]                             if (is.null(name)) 
[17:48:00.059]                               next
[17:48:00.059]                             if (!grepl(pattern, name)) 
[17:48:00.059]                               next
[17:48:00.059]                             invokeRestart(restart)
[17:48:00.059]                             muffled <- TRUE
[17:48:00.059]                             break
[17:48:00.059]                           }
[17:48:00.059]                         }
[17:48:00.059]                       }
[17:48:00.059]                       invisible(muffled)
[17:48:00.059]                     }
[17:48:00.059]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.059]                   }
[17:48:00.059]                 }
[17:48:00.059]             }
[17:48:00.059]         }))
[17:48:00.059]     }, error = function(ex) {
[17:48:00.059]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:00.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.059]                 ...future.rng), started = ...future.startTime, 
[17:48:00.059]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:00.059]             version = "1.8"), class = "FutureResult")
[17:48:00.059]     }, finally = {
[17:48:00.059]         if (!identical(...future.workdir, getwd())) 
[17:48:00.059]             setwd(...future.workdir)
[17:48:00.059]         {
[17:48:00.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:00.059]                 ...future.oldOptions$nwarnings <- NULL
[17:48:00.059]             }
[17:48:00.059]             base::options(...future.oldOptions)
[17:48:00.059]             if (.Platform$OS.type == "windows") {
[17:48:00.059]                 old_names <- names(...future.oldEnvVars)
[17:48:00.059]                 envs <- base::Sys.getenv()
[17:48:00.059]                 names <- names(envs)
[17:48:00.059]                 common <- intersect(names, old_names)
[17:48:00.059]                 added <- setdiff(names, old_names)
[17:48:00.059]                 removed <- setdiff(old_names, names)
[17:48:00.059]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:00.059]                   envs[common]]
[17:48:00.059]                 NAMES <- toupper(changed)
[17:48:00.059]                 args <- list()
[17:48:00.059]                 for (kk in seq_along(NAMES)) {
[17:48:00.059]                   name <- changed[[kk]]
[17:48:00.059]                   NAME <- NAMES[[kk]]
[17:48:00.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.059]                     next
[17:48:00.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.059]                 }
[17:48:00.059]                 NAMES <- toupper(added)
[17:48:00.059]                 for (kk in seq_along(NAMES)) {
[17:48:00.059]                   name <- added[[kk]]
[17:48:00.059]                   NAME <- NAMES[[kk]]
[17:48:00.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.059]                     next
[17:48:00.059]                   args[[name]] <- ""
[17:48:00.059]                 }
[17:48:00.059]                 NAMES <- toupper(removed)
[17:48:00.059]                 for (kk in seq_along(NAMES)) {
[17:48:00.059]                   name <- removed[[kk]]
[17:48:00.059]                   NAME <- NAMES[[kk]]
[17:48:00.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.059]                     next
[17:48:00.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.059]                 }
[17:48:00.059]                 if (length(args) > 0) 
[17:48:00.059]                   base::do.call(base::Sys.setenv, args = args)
[17:48:00.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:00.059]             }
[17:48:00.059]             else {
[17:48:00.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:00.059]             }
[17:48:00.059]             {
[17:48:00.059]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:00.059]                   0L) {
[17:48:00.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:00.059]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:00.059]                   base::options(opts)
[17:48:00.059]                 }
[17:48:00.059]                 {
[17:48:00.059]                   {
[17:48:00.059]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:00.059]                     NULL
[17:48:00.059]                   }
[17:48:00.059]                   options(future.plan = NULL)
[17:48:00.059]                   if (is.na(NA_character_)) 
[17:48:00.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:00.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:00.059]                     .init = FALSE)
[17:48:00.059]                 }
[17:48:00.059]             }
[17:48:00.059]         }
[17:48:00.059]     })
[17:48:00.059]     if (TRUE) {
[17:48:00.059]         base::sink(type = "output", split = FALSE)
[17:48:00.059]         if (TRUE) {
[17:48:00.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:00.059]         }
[17:48:00.059]         else {
[17:48:00.059]             ...future.result["stdout"] <- base::list(NULL)
[17:48:00.059]         }
[17:48:00.059]         base::close(...future.stdout)
[17:48:00.059]         ...future.stdout <- NULL
[17:48:00.059]     }
[17:48:00.059]     ...future.result$conditions <- ...future.conditions
[17:48:00.059]     ...future.result$finished <- base::Sys.time()
[17:48:00.059]     ...future.result
[17:48:00.059] }
[17:48:00.061] MultisessionFuture started
[17:48:00.062] - Launch lazy future ... done
[17:48:00.062] run() for ‘MultisessionFuture’ ... done
[17:48:00.064] receiveMessageFromWorker() for ClusterFuture ...
[17:48:00.064] - Validating connection of MultisessionFuture
[17:48:00.064] - received message: FutureResult
[17:48:00.064] - Received FutureResult
[17:48:00.064] - Erased future from FutureRegistry
[17:48:00.065] result() for ClusterFuture ...
[17:48:00.065] - result already collected: FutureResult
[17:48:00.065] result() for ClusterFuture ... done
[17:48:00.065] signalConditions() ...
[17:48:00.065]  - include = ‘immediateCondition’
[17:48:00.065]  - exclude = 
[17:48:00.065]  - resignal = FALSE
[17:48:00.065]  - Number of conditions: 1
[17:48:00.065] signalConditions() ... done
[17:48:00.065] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:00.065] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[17:48:00.066] getGlobalsAndPackages() ...
[17:48:00.066] Searching for globals...
[17:48:00.067] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:00.067] Searching for globals ... DONE
[17:48:00.067] Resolving globals: FALSE
[17:48:00.067] 
[17:48:00.068] 
[17:48:00.068] getGlobalsAndPackages() ... DONE
[17:48:00.068] run() for ‘Future’ ...
[17:48:00.068] - state: ‘created’
[17:48:00.068] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:00.082] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:00.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:00.082]   - Field: ‘node’
[17:48:00.082]   - Field: ‘label’
[17:48:00.082]   - Field: ‘local’
[17:48:00.082]   - Field: ‘owner’
[17:48:00.082]   - Field: ‘envir’
[17:48:00.082]   - Field: ‘workers’
[17:48:00.082]   - Field: ‘packages’
[17:48:00.082]   - Field: ‘gc’
[17:48:00.083]   - Field: ‘conditions’
[17:48:00.083]   - Field: ‘persistent’
[17:48:00.083]   - Field: ‘expr’
[17:48:00.083]   - Field: ‘uuid’
[17:48:00.083]   - Field: ‘seed’
[17:48:00.083]   - Field: ‘version’
[17:48:00.083]   - Field: ‘result’
[17:48:00.083]   - Field: ‘asynchronous’
[17:48:00.083]   - Field: ‘calls’
[17:48:00.083]   - Field: ‘globals’
[17:48:00.084]   - Field: ‘stdout’
[17:48:00.084]   - Field: ‘earlySignal’
[17:48:00.084]   - Field: ‘lazy’
[17:48:00.084]   - Field: ‘state’
[17:48:00.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:00.084] - Launch lazy future ...
[17:48:00.084] Packages needed by the future expression (n = 0): <none>
[17:48:00.084] Packages needed by future strategies (n = 0): <none>
[17:48:00.085] {
[17:48:00.085]     {
[17:48:00.085]         {
[17:48:00.085]             ...future.startTime <- base::Sys.time()
[17:48:00.085]             {
[17:48:00.085]                 {
[17:48:00.085]                   {
[17:48:00.085]                     {
[17:48:00.085]                       base::local({
[17:48:00.085]                         has_future <- base::requireNamespace("future", 
[17:48:00.085]                           quietly = TRUE)
[17:48:00.085]                         if (has_future) {
[17:48:00.085]                           ns <- base::getNamespace("future")
[17:48:00.085]                           version <- ns[[".package"]][["version"]]
[17:48:00.085]                           if (is.null(version)) 
[17:48:00.085]                             version <- utils::packageVersion("future")
[17:48:00.085]                         }
[17:48:00.085]                         else {
[17:48:00.085]                           version <- NULL
[17:48:00.085]                         }
[17:48:00.085]                         if (!has_future || version < "1.8.0") {
[17:48:00.085]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:00.085]                             "", base::R.version$version.string), 
[17:48:00.085]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:00.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:00.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:00.085]                               "release", "version")], collapse = " "), 
[17:48:00.085]                             hostname = base::Sys.info()[["nodename"]])
[17:48:00.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:00.085]                             info)
[17:48:00.085]                           info <- base::paste(info, collapse = "; ")
[17:48:00.085]                           if (!has_future) {
[17:48:00.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:00.085]                               info)
[17:48:00.085]                           }
[17:48:00.085]                           else {
[17:48:00.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:00.085]                               info, version)
[17:48:00.085]                           }
[17:48:00.085]                           base::stop(msg)
[17:48:00.085]                         }
[17:48:00.085]                       })
[17:48:00.085]                     }
[17:48:00.085]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:00.085]                     base::options(mc.cores = 1L)
[17:48:00.085]                   }
[17:48:00.085]                   ...future.strategy.old <- future::plan("list")
[17:48:00.085]                   options(future.plan = NULL)
[17:48:00.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:00.085]                 }
[17:48:00.085]                 ...future.workdir <- getwd()
[17:48:00.085]             }
[17:48:00.085]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:00.085]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:00.085]         }
[17:48:00.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:00.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:00.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:00.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:00.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:00.085]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:00.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:00.085]             base::names(...future.oldOptions))
[17:48:00.085]     }
[17:48:00.085]     if (FALSE) {
[17:48:00.085]     }
[17:48:00.085]     else {
[17:48:00.085]         if (TRUE) {
[17:48:00.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:00.085]                 open = "w")
[17:48:00.085]         }
[17:48:00.085]         else {
[17:48:00.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:00.085]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:00.085]         }
[17:48:00.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:00.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:00.085]             base::sink(type = "output", split = FALSE)
[17:48:00.085]             base::close(...future.stdout)
[17:48:00.085]         }, add = TRUE)
[17:48:00.085]     }
[17:48:00.085]     ...future.frame <- base::sys.nframe()
[17:48:00.085]     ...future.conditions <- base::list()
[17:48:00.085]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:00.085]     if (FALSE) {
[17:48:00.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:00.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:00.085]     }
[17:48:00.085]     ...future.result <- base::tryCatch({
[17:48:00.085]         base::withCallingHandlers({
[17:48:00.085]             ...future.value <- base::withVisible(base::local({
[17:48:00.085]                 ...future.makeSendCondition <- base::local({
[17:48:00.085]                   sendCondition <- NULL
[17:48:00.085]                   function(frame = 1L) {
[17:48:00.085]                     if (is.function(sendCondition)) 
[17:48:00.085]                       return(sendCondition)
[17:48:00.085]                     ns <- getNamespace("parallel")
[17:48:00.085]                     if (exists("sendData", mode = "function", 
[17:48:00.085]                       envir = ns)) {
[17:48:00.085]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:00.085]                         envir = ns)
[17:48:00.085]                       envir <- sys.frame(frame)
[17:48:00.085]                       master <- NULL
[17:48:00.085]                       while (!identical(envir, .GlobalEnv) && 
[17:48:00.085]                         !identical(envir, emptyenv())) {
[17:48:00.085]                         if (exists("master", mode = "list", envir = envir, 
[17:48:00.085]                           inherits = FALSE)) {
[17:48:00.085]                           master <- get("master", mode = "list", 
[17:48:00.085]                             envir = envir, inherits = FALSE)
[17:48:00.085]                           if (inherits(master, c("SOCKnode", 
[17:48:00.085]                             "SOCK0node"))) {
[17:48:00.085]                             sendCondition <<- function(cond) {
[17:48:00.085]                               data <- list(type = "VALUE", value = cond, 
[17:48:00.085]                                 success = TRUE)
[17:48:00.085]                               parallel_sendData(master, data)
[17:48:00.085]                             }
[17:48:00.085]                             return(sendCondition)
[17:48:00.085]                           }
[17:48:00.085]                         }
[17:48:00.085]                         frame <- frame + 1L
[17:48:00.085]                         envir <- sys.frame(frame)
[17:48:00.085]                       }
[17:48:00.085]                     }
[17:48:00.085]                     sendCondition <<- function(cond) NULL
[17:48:00.085]                   }
[17:48:00.085]                 })
[17:48:00.085]                 withCallingHandlers({
[17:48:00.085]                   {
[17:48:00.085]                     Sys.sleep(0.5)
[17:48:00.085]                     list(a = 1, b = 42L)
[17:48:00.085]                   }
[17:48:00.085]                 }, immediateCondition = function(cond) {
[17:48:00.085]                   sendCondition <- ...future.makeSendCondition()
[17:48:00.085]                   sendCondition(cond)
[17:48:00.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.085]                   {
[17:48:00.085]                     inherits <- base::inherits
[17:48:00.085]                     invokeRestart <- base::invokeRestart
[17:48:00.085]                     is.null <- base::is.null
[17:48:00.085]                     muffled <- FALSE
[17:48:00.085]                     if (inherits(cond, "message")) {
[17:48:00.085]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:00.085]                       if (muffled) 
[17:48:00.085]                         invokeRestart("muffleMessage")
[17:48:00.085]                     }
[17:48:00.085]                     else if (inherits(cond, "warning")) {
[17:48:00.085]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:00.085]                       if (muffled) 
[17:48:00.085]                         invokeRestart("muffleWarning")
[17:48:00.085]                     }
[17:48:00.085]                     else if (inherits(cond, "condition")) {
[17:48:00.085]                       if (!is.null(pattern)) {
[17:48:00.085]                         computeRestarts <- base::computeRestarts
[17:48:00.085]                         grepl <- base::grepl
[17:48:00.085]                         restarts <- computeRestarts(cond)
[17:48:00.085]                         for (restart in restarts) {
[17:48:00.085]                           name <- restart$name
[17:48:00.085]                           if (is.null(name)) 
[17:48:00.085]                             next
[17:48:00.085]                           if (!grepl(pattern, name)) 
[17:48:00.085]                             next
[17:48:00.085]                           invokeRestart(restart)
[17:48:00.085]                           muffled <- TRUE
[17:48:00.085]                           break
[17:48:00.085]                         }
[17:48:00.085]                       }
[17:48:00.085]                     }
[17:48:00.085]                     invisible(muffled)
[17:48:00.085]                   }
[17:48:00.085]                   muffleCondition(cond)
[17:48:00.085]                 })
[17:48:00.085]             }))
[17:48:00.085]             future::FutureResult(value = ...future.value$value, 
[17:48:00.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.085]                   ...future.rng), globalenv = if (FALSE) 
[17:48:00.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:00.085]                     ...future.globalenv.names))
[17:48:00.085]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:00.085]         }, condition = base::local({
[17:48:00.085]             c <- base::c
[17:48:00.085]             inherits <- base::inherits
[17:48:00.085]             invokeRestart <- base::invokeRestart
[17:48:00.085]             length <- base::length
[17:48:00.085]             list <- base::list
[17:48:00.085]             seq.int <- base::seq.int
[17:48:00.085]             signalCondition <- base::signalCondition
[17:48:00.085]             sys.calls <- base::sys.calls
[17:48:00.085]             `[[` <- base::`[[`
[17:48:00.085]             `+` <- base::`+`
[17:48:00.085]             `<<-` <- base::`<<-`
[17:48:00.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:00.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:00.085]                   3L)]
[17:48:00.085]             }
[17:48:00.085]             function(cond) {
[17:48:00.085]                 is_error <- inherits(cond, "error")
[17:48:00.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:00.085]                   NULL)
[17:48:00.085]                 if (is_error) {
[17:48:00.085]                   sessionInformation <- function() {
[17:48:00.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:00.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:00.085]                       search = base::search(), system = base::Sys.info())
[17:48:00.085]                   }
[17:48:00.085]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:00.085]                     cond$call), session = sessionInformation(), 
[17:48:00.085]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:00.085]                   signalCondition(cond)
[17:48:00.085]                 }
[17:48:00.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:00.085]                 "immediateCondition"))) {
[17:48:00.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:00.085]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:00.085]                   if (TRUE && !signal) {
[17:48:00.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.085]                     {
[17:48:00.085]                       inherits <- base::inherits
[17:48:00.085]                       invokeRestart <- base::invokeRestart
[17:48:00.085]                       is.null <- base::is.null
[17:48:00.085]                       muffled <- FALSE
[17:48:00.085]                       if (inherits(cond, "message")) {
[17:48:00.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.085]                         if (muffled) 
[17:48:00.085]                           invokeRestart("muffleMessage")
[17:48:00.085]                       }
[17:48:00.085]                       else if (inherits(cond, "warning")) {
[17:48:00.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.085]                         if (muffled) 
[17:48:00.085]                           invokeRestart("muffleWarning")
[17:48:00.085]                       }
[17:48:00.085]                       else if (inherits(cond, "condition")) {
[17:48:00.085]                         if (!is.null(pattern)) {
[17:48:00.085]                           computeRestarts <- base::computeRestarts
[17:48:00.085]                           grepl <- base::grepl
[17:48:00.085]                           restarts <- computeRestarts(cond)
[17:48:00.085]                           for (restart in restarts) {
[17:48:00.085]                             name <- restart$name
[17:48:00.085]                             if (is.null(name)) 
[17:48:00.085]                               next
[17:48:00.085]                             if (!grepl(pattern, name)) 
[17:48:00.085]                               next
[17:48:00.085]                             invokeRestart(restart)
[17:48:00.085]                             muffled <- TRUE
[17:48:00.085]                             break
[17:48:00.085]                           }
[17:48:00.085]                         }
[17:48:00.085]                       }
[17:48:00.085]                       invisible(muffled)
[17:48:00.085]                     }
[17:48:00.085]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.085]                   }
[17:48:00.085]                 }
[17:48:00.085]                 else {
[17:48:00.085]                   if (TRUE) {
[17:48:00.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.085]                     {
[17:48:00.085]                       inherits <- base::inherits
[17:48:00.085]                       invokeRestart <- base::invokeRestart
[17:48:00.085]                       is.null <- base::is.null
[17:48:00.085]                       muffled <- FALSE
[17:48:00.085]                       if (inherits(cond, "message")) {
[17:48:00.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.085]                         if (muffled) 
[17:48:00.085]                           invokeRestart("muffleMessage")
[17:48:00.085]                       }
[17:48:00.085]                       else if (inherits(cond, "warning")) {
[17:48:00.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.085]                         if (muffled) 
[17:48:00.085]                           invokeRestart("muffleWarning")
[17:48:00.085]                       }
[17:48:00.085]                       else if (inherits(cond, "condition")) {
[17:48:00.085]                         if (!is.null(pattern)) {
[17:48:00.085]                           computeRestarts <- base::computeRestarts
[17:48:00.085]                           grepl <- base::grepl
[17:48:00.085]                           restarts <- computeRestarts(cond)
[17:48:00.085]                           for (restart in restarts) {
[17:48:00.085]                             name <- restart$name
[17:48:00.085]                             if (is.null(name)) 
[17:48:00.085]                               next
[17:48:00.085]                             if (!grepl(pattern, name)) 
[17:48:00.085]                               next
[17:48:00.085]                             invokeRestart(restart)
[17:48:00.085]                             muffled <- TRUE
[17:48:00.085]                             break
[17:48:00.085]                           }
[17:48:00.085]                         }
[17:48:00.085]                       }
[17:48:00.085]                       invisible(muffled)
[17:48:00.085]                     }
[17:48:00.085]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.085]                   }
[17:48:00.085]                 }
[17:48:00.085]             }
[17:48:00.085]         }))
[17:48:00.085]     }, error = function(ex) {
[17:48:00.085]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:00.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.085]                 ...future.rng), started = ...future.startTime, 
[17:48:00.085]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:00.085]             version = "1.8"), class = "FutureResult")
[17:48:00.085]     }, finally = {
[17:48:00.085]         if (!identical(...future.workdir, getwd())) 
[17:48:00.085]             setwd(...future.workdir)
[17:48:00.085]         {
[17:48:00.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:00.085]                 ...future.oldOptions$nwarnings <- NULL
[17:48:00.085]             }
[17:48:00.085]             base::options(...future.oldOptions)
[17:48:00.085]             if (.Platform$OS.type == "windows") {
[17:48:00.085]                 old_names <- names(...future.oldEnvVars)
[17:48:00.085]                 envs <- base::Sys.getenv()
[17:48:00.085]                 names <- names(envs)
[17:48:00.085]                 common <- intersect(names, old_names)
[17:48:00.085]                 added <- setdiff(names, old_names)
[17:48:00.085]                 removed <- setdiff(old_names, names)
[17:48:00.085]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:00.085]                   envs[common]]
[17:48:00.085]                 NAMES <- toupper(changed)
[17:48:00.085]                 args <- list()
[17:48:00.085]                 for (kk in seq_along(NAMES)) {
[17:48:00.085]                   name <- changed[[kk]]
[17:48:00.085]                   NAME <- NAMES[[kk]]
[17:48:00.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.085]                     next
[17:48:00.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.085]                 }
[17:48:00.085]                 NAMES <- toupper(added)
[17:48:00.085]                 for (kk in seq_along(NAMES)) {
[17:48:00.085]                   name <- added[[kk]]
[17:48:00.085]                   NAME <- NAMES[[kk]]
[17:48:00.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.085]                     next
[17:48:00.085]                   args[[name]] <- ""
[17:48:00.085]                 }
[17:48:00.085]                 NAMES <- toupper(removed)
[17:48:00.085]                 for (kk in seq_along(NAMES)) {
[17:48:00.085]                   name <- removed[[kk]]
[17:48:00.085]                   NAME <- NAMES[[kk]]
[17:48:00.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.085]                     next
[17:48:00.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.085]                 }
[17:48:00.085]                 if (length(args) > 0) 
[17:48:00.085]                   base::do.call(base::Sys.setenv, args = args)
[17:48:00.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:00.085]             }
[17:48:00.085]             else {
[17:48:00.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:00.085]             }
[17:48:00.085]             {
[17:48:00.085]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:00.085]                   0L) {
[17:48:00.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:00.085]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:00.085]                   base::options(opts)
[17:48:00.085]                 }
[17:48:00.085]                 {
[17:48:00.085]                   {
[17:48:00.085]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:00.085]                     NULL
[17:48:00.085]                   }
[17:48:00.085]                   options(future.plan = NULL)
[17:48:00.085]                   if (is.na(NA_character_)) 
[17:48:00.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:00.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:00.085]                     .init = FALSE)
[17:48:00.085]                 }
[17:48:00.085]             }
[17:48:00.085]         }
[17:48:00.085]     })
[17:48:00.085]     if (TRUE) {
[17:48:00.085]         base::sink(type = "output", split = FALSE)
[17:48:00.085]         if (TRUE) {
[17:48:00.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:00.085]         }
[17:48:00.085]         else {
[17:48:00.085]             ...future.result["stdout"] <- base::list(NULL)
[17:48:00.085]         }
[17:48:00.085]         base::close(...future.stdout)
[17:48:00.085]         ...future.stdout <- NULL
[17:48:00.085]     }
[17:48:00.085]     ...future.result$conditions <- ...future.conditions
[17:48:00.085]     ...future.result$finished <- base::Sys.time()
[17:48:00.085]     ...future.result
[17:48:00.085] }
[17:48:00.088] MultisessionFuture started
[17:48:00.088] - Launch lazy future ... done
[17:48:00.088] run() for ‘MultisessionFuture’ ... done
[17:48:00.591] receiveMessageFromWorker() for ClusterFuture ...
[17:48:00.591] - Validating connection of MultisessionFuture
[17:48:00.591] - received message: FutureResult
[17:48:00.591] - Received FutureResult
[17:48:00.591] - Erased future from FutureRegistry
[17:48:00.591] result() for ClusterFuture ...
[17:48:00.591] - result already collected: FutureResult
[17:48:00.592] result() for ClusterFuture ... done
[17:48:00.592] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:00.592] A MultisessionFuture was resolved (result was not collected)
[17:48:00.592] getGlobalsAndPackages() ...
[17:48:00.592] Searching for globals...
[17:48:00.593] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:00.593] Searching for globals ... DONE
[17:48:00.593] Resolving globals: FALSE
[17:48:00.594] 
[17:48:00.594] 
[17:48:00.594] getGlobalsAndPackages() ... DONE
[17:48:00.594] run() for ‘Future’ ...
[17:48:00.594] - state: ‘created’
[17:48:00.594] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:00.608] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:00.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:00.608]   - Field: ‘node’
[17:48:00.608]   - Field: ‘label’
[17:48:00.608]   - Field: ‘local’
[17:48:00.609]   - Field: ‘owner’
[17:48:00.609]   - Field: ‘envir’
[17:48:00.609]   - Field: ‘workers’
[17:48:00.609]   - Field: ‘packages’
[17:48:00.609]   - Field: ‘gc’
[17:48:00.609]   - Field: ‘conditions’
[17:48:00.609]   - Field: ‘persistent’
[17:48:00.609]   - Field: ‘expr’
[17:48:00.609]   - Field: ‘uuid’
[17:48:00.609]   - Field: ‘seed’
[17:48:00.609]   - Field: ‘version’
[17:48:00.610]   - Field: ‘result’
[17:48:00.610]   - Field: ‘asynchronous’
[17:48:00.610]   - Field: ‘calls’
[17:48:00.610]   - Field: ‘globals’
[17:48:00.610]   - Field: ‘stdout’
[17:48:00.610]   - Field: ‘earlySignal’
[17:48:00.610]   - Field: ‘lazy’
[17:48:00.610]   - Field: ‘state’
[17:48:00.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:00.610] - Launch lazy future ...
[17:48:00.611] Packages needed by the future expression (n = 0): <none>
[17:48:00.611] Packages needed by future strategies (n = 0): <none>
[17:48:00.611] {
[17:48:00.611]     {
[17:48:00.611]         {
[17:48:00.611]             ...future.startTime <- base::Sys.time()
[17:48:00.611]             {
[17:48:00.611]                 {
[17:48:00.611]                   {
[17:48:00.611]                     {
[17:48:00.611]                       base::local({
[17:48:00.611]                         has_future <- base::requireNamespace("future", 
[17:48:00.611]                           quietly = TRUE)
[17:48:00.611]                         if (has_future) {
[17:48:00.611]                           ns <- base::getNamespace("future")
[17:48:00.611]                           version <- ns[[".package"]][["version"]]
[17:48:00.611]                           if (is.null(version)) 
[17:48:00.611]                             version <- utils::packageVersion("future")
[17:48:00.611]                         }
[17:48:00.611]                         else {
[17:48:00.611]                           version <- NULL
[17:48:00.611]                         }
[17:48:00.611]                         if (!has_future || version < "1.8.0") {
[17:48:00.611]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:00.611]                             "", base::R.version$version.string), 
[17:48:00.611]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:00.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:00.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:00.611]                               "release", "version")], collapse = " "), 
[17:48:00.611]                             hostname = base::Sys.info()[["nodename"]])
[17:48:00.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:00.611]                             info)
[17:48:00.611]                           info <- base::paste(info, collapse = "; ")
[17:48:00.611]                           if (!has_future) {
[17:48:00.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:00.611]                               info)
[17:48:00.611]                           }
[17:48:00.611]                           else {
[17:48:00.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:00.611]                               info, version)
[17:48:00.611]                           }
[17:48:00.611]                           base::stop(msg)
[17:48:00.611]                         }
[17:48:00.611]                       })
[17:48:00.611]                     }
[17:48:00.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:00.611]                     base::options(mc.cores = 1L)
[17:48:00.611]                   }
[17:48:00.611]                   ...future.strategy.old <- future::plan("list")
[17:48:00.611]                   options(future.plan = NULL)
[17:48:00.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:00.611]                 }
[17:48:00.611]                 ...future.workdir <- getwd()
[17:48:00.611]             }
[17:48:00.611]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:00.611]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:00.611]         }
[17:48:00.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:00.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:00.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:00.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:00.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:00.611]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:00.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:00.611]             base::names(...future.oldOptions))
[17:48:00.611]     }
[17:48:00.611]     if (FALSE) {
[17:48:00.611]     }
[17:48:00.611]     else {
[17:48:00.611]         if (TRUE) {
[17:48:00.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:00.611]                 open = "w")
[17:48:00.611]         }
[17:48:00.611]         else {
[17:48:00.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:00.611]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:00.611]         }
[17:48:00.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:00.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:00.611]             base::sink(type = "output", split = FALSE)
[17:48:00.611]             base::close(...future.stdout)
[17:48:00.611]         }, add = TRUE)
[17:48:00.611]     }
[17:48:00.611]     ...future.frame <- base::sys.nframe()
[17:48:00.611]     ...future.conditions <- base::list()
[17:48:00.611]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:00.611]     if (FALSE) {
[17:48:00.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:00.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:00.611]     }
[17:48:00.611]     ...future.result <- base::tryCatch({
[17:48:00.611]         base::withCallingHandlers({
[17:48:00.611]             ...future.value <- base::withVisible(base::local({
[17:48:00.611]                 ...future.makeSendCondition <- base::local({
[17:48:00.611]                   sendCondition <- NULL
[17:48:00.611]                   function(frame = 1L) {
[17:48:00.611]                     if (is.function(sendCondition)) 
[17:48:00.611]                       return(sendCondition)
[17:48:00.611]                     ns <- getNamespace("parallel")
[17:48:00.611]                     if (exists("sendData", mode = "function", 
[17:48:00.611]                       envir = ns)) {
[17:48:00.611]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:00.611]                         envir = ns)
[17:48:00.611]                       envir <- sys.frame(frame)
[17:48:00.611]                       master <- NULL
[17:48:00.611]                       while (!identical(envir, .GlobalEnv) && 
[17:48:00.611]                         !identical(envir, emptyenv())) {
[17:48:00.611]                         if (exists("master", mode = "list", envir = envir, 
[17:48:00.611]                           inherits = FALSE)) {
[17:48:00.611]                           master <- get("master", mode = "list", 
[17:48:00.611]                             envir = envir, inherits = FALSE)
[17:48:00.611]                           if (inherits(master, c("SOCKnode", 
[17:48:00.611]                             "SOCK0node"))) {
[17:48:00.611]                             sendCondition <<- function(cond) {
[17:48:00.611]                               data <- list(type = "VALUE", value = cond, 
[17:48:00.611]                                 success = TRUE)
[17:48:00.611]                               parallel_sendData(master, data)
[17:48:00.611]                             }
[17:48:00.611]                             return(sendCondition)
[17:48:00.611]                           }
[17:48:00.611]                         }
[17:48:00.611]                         frame <- frame + 1L
[17:48:00.611]                         envir <- sys.frame(frame)
[17:48:00.611]                       }
[17:48:00.611]                     }
[17:48:00.611]                     sendCondition <<- function(cond) NULL
[17:48:00.611]                   }
[17:48:00.611]                 })
[17:48:00.611]                 withCallingHandlers({
[17:48:00.611]                   {
[17:48:00.611]                     Sys.sleep(0.5)
[17:48:00.611]                     list(a = 1, b = 42L)
[17:48:00.611]                   }
[17:48:00.611]                 }, immediateCondition = function(cond) {
[17:48:00.611]                   sendCondition <- ...future.makeSendCondition()
[17:48:00.611]                   sendCondition(cond)
[17:48:00.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.611]                   {
[17:48:00.611]                     inherits <- base::inherits
[17:48:00.611]                     invokeRestart <- base::invokeRestart
[17:48:00.611]                     is.null <- base::is.null
[17:48:00.611]                     muffled <- FALSE
[17:48:00.611]                     if (inherits(cond, "message")) {
[17:48:00.611]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:00.611]                       if (muffled) 
[17:48:00.611]                         invokeRestart("muffleMessage")
[17:48:00.611]                     }
[17:48:00.611]                     else if (inherits(cond, "warning")) {
[17:48:00.611]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:00.611]                       if (muffled) 
[17:48:00.611]                         invokeRestart("muffleWarning")
[17:48:00.611]                     }
[17:48:00.611]                     else if (inherits(cond, "condition")) {
[17:48:00.611]                       if (!is.null(pattern)) {
[17:48:00.611]                         computeRestarts <- base::computeRestarts
[17:48:00.611]                         grepl <- base::grepl
[17:48:00.611]                         restarts <- computeRestarts(cond)
[17:48:00.611]                         for (restart in restarts) {
[17:48:00.611]                           name <- restart$name
[17:48:00.611]                           if (is.null(name)) 
[17:48:00.611]                             next
[17:48:00.611]                           if (!grepl(pattern, name)) 
[17:48:00.611]                             next
[17:48:00.611]                           invokeRestart(restart)
[17:48:00.611]                           muffled <- TRUE
[17:48:00.611]                           break
[17:48:00.611]                         }
[17:48:00.611]                       }
[17:48:00.611]                     }
[17:48:00.611]                     invisible(muffled)
[17:48:00.611]                   }
[17:48:00.611]                   muffleCondition(cond)
[17:48:00.611]                 })
[17:48:00.611]             }))
[17:48:00.611]             future::FutureResult(value = ...future.value$value, 
[17:48:00.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.611]                   ...future.rng), globalenv = if (FALSE) 
[17:48:00.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:00.611]                     ...future.globalenv.names))
[17:48:00.611]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:00.611]         }, condition = base::local({
[17:48:00.611]             c <- base::c
[17:48:00.611]             inherits <- base::inherits
[17:48:00.611]             invokeRestart <- base::invokeRestart
[17:48:00.611]             length <- base::length
[17:48:00.611]             list <- base::list
[17:48:00.611]             seq.int <- base::seq.int
[17:48:00.611]             signalCondition <- base::signalCondition
[17:48:00.611]             sys.calls <- base::sys.calls
[17:48:00.611]             `[[` <- base::`[[`
[17:48:00.611]             `+` <- base::`+`
[17:48:00.611]             `<<-` <- base::`<<-`
[17:48:00.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:00.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:00.611]                   3L)]
[17:48:00.611]             }
[17:48:00.611]             function(cond) {
[17:48:00.611]                 is_error <- inherits(cond, "error")
[17:48:00.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:00.611]                   NULL)
[17:48:00.611]                 if (is_error) {
[17:48:00.611]                   sessionInformation <- function() {
[17:48:00.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:00.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:00.611]                       search = base::search(), system = base::Sys.info())
[17:48:00.611]                   }
[17:48:00.611]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:00.611]                     cond$call), session = sessionInformation(), 
[17:48:00.611]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:00.611]                   signalCondition(cond)
[17:48:00.611]                 }
[17:48:00.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:00.611]                 "immediateCondition"))) {
[17:48:00.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:00.611]                   ...future.conditions[[length(...future.conditions) + 
[17:48:00.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:00.611]                   if (TRUE && !signal) {
[17:48:00.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.611]                     {
[17:48:00.611]                       inherits <- base::inherits
[17:48:00.611]                       invokeRestart <- base::invokeRestart
[17:48:00.611]                       is.null <- base::is.null
[17:48:00.611]                       muffled <- FALSE
[17:48:00.611]                       if (inherits(cond, "message")) {
[17:48:00.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.611]                         if (muffled) 
[17:48:00.611]                           invokeRestart("muffleMessage")
[17:48:00.611]                       }
[17:48:00.611]                       else if (inherits(cond, "warning")) {
[17:48:00.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.611]                         if (muffled) 
[17:48:00.611]                           invokeRestart("muffleWarning")
[17:48:00.611]                       }
[17:48:00.611]                       else if (inherits(cond, "condition")) {
[17:48:00.611]                         if (!is.null(pattern)) {
[17:48:00.611]                           computeRestarts <- base::computeRestarts
[17:48:00.611]                           grepl <- base::grepl
[17:48:00.611]                           restarts <- computeRestarts(cond)
[17:48:00.611]                           for (restart in restarts) {
[17:48:00.611]                             name <- restart$name
[17:48:00.611]                             if (is.null(name)) 
[17:48:00.611]                               next
[17:48:00.611]                             if (!grepl(pattern, name)) 
[17:48:00.611]                               next
[17:48:00.611]                             invokeRestart(restart)
[17:48:00.611]                             muffled <- TRUE
[17:48:00.611]                             break
[17:48:00.611]                           }
[17:48:00.611]                         }
[17:48:00.611]                       }
[17:48:00.611]                       invisible(muffled)
[17:48:00.611]                     }
[17:48:00.611]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.611]                   }
[17:48:00.611]                 }
[17:48:00.611]                 else {
[17:48:00.611]                   if (TRUE) {
[17:48:00.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:00.611]                     {
[17:48:00.611]                       inherits <- base::inherits
[17:48:00.611]                       invokeRestart <- base::invokeRestart
[17:48:00.611]                       is.null <- base::is.null
[17:48:00.611]                       muffled <- FALSE
[17:48:00.611]                       if (inherits(cond, "message")) {
[17:48:00.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:00.611]                         if (muffled) 
[17:48:00.611]                           invokeRestart("muffleMessage")
[17:48:00.611]                       }
[17:48:00.611]                       else if (inherits(cond, "warning")) {
[17:48:00.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:00.611]                         if (muffled) 
[17:48:00.611]                           invokeRestart("muffleWarning")
[17:48:00.611]                       }
[17:48:00.611]                       else if (inherits(cond, "condition")) {
[17:48:00.611]                         if (!is.null(pattern)) {
[17:48:00.611]                           computeRestarts <- base::computeRestarts
[17:48:00.611]                           grepl <- base::grepl
[17:48:00.611]                           restarts <- computeRestarts(cond)
[17:48:00.611]                           for (restart in restarts) {
[17:48:00.611]                             name <- restart$name
[17:48:00.611]                             if (is.null(name)) 
[17:48:00.611]                               next
[17:48:00.611]                             if (!grepl(pattern, name)) 
[17:48:00.611]                               next
[17:48:00.611]                             invokeRestart(restart)
[17:48:00.611]                             muffled <- TRUE
[17:48:00.611]                             break
[17:48:00.611]                           }
[17:48:00.611]                         }
[17:48:00.611]                       }
[17:48:00.611]                       invisible(muffled)
[17:48:00.611]                     }
[17:48:00.611]                     muffleCondition(cond, pattern = "^muffle")
[17:48:00.611]                   }
[17:48:00.611]                 }
[17:48:00.611]             }
[17:48:00.611]         }))
[17:48:00.611]     }, error = function(ex) {
[17:48:00.611]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:00.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:00.611]                 ...future.rng), started = ...future.startTime, 
[17:48:00.611]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:00.611]             version = "1.8"), class = "FutureResult")
[17:48:00.611]     }, finally = {
[17:48:00.611]         if (!identical(...future.workdir, getwd())) 
[17:48:00.611]             setwd(...future.workdir)
[17:48:00.611]         {
[17:48:00.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:00.611]                 ...future.oldOptions$nwarnings <- NULL
[17:48:00.611]             }
[17:48:00.611]             base::options(...future.oldOptions)
[17:48:00.611]             if (.Platform$OS.type == "windows") {
[17:48:00.611]                 old_names <- names(...future.oldEnvVars)
[17:48:00.611]                 envs <- base::Sys.getenv()
[17:48:00.611]                 names <- names(envs)
[17:48:00.611]                 common <- intersect(names, old_names)
[17:48:00.611]                 added <- setdiff(names, old_names)
[17:48:00.611]                 removed <- setdiff(old_names, names)
[17:48:00.611]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:00.611]                   envs[common]]
[17:48:00.611]                 NAMES <- toupper(changed)
[17:48:00.611]                 args <- list()
[17:48:00.611]                 for (kk in seq_along(NAMES)) {
[17:48:00.611]                   name <- changed[[kk]]
[17:48:00.611]                   NAME <- NAMES[[kk]]
[17:48:00.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.611]                     next
[17:48:00.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.611]                 }
[17:48:00.611]                 NAMES <- toupper(added)
[17:48:00.611]                 for (kk in seq_along(NAMES)) {
[17:48:00.611]                   name <- added[[kk]]
[17:48:00.611]                   NAME <- NAMES[[kk]]
[17:48:00.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.611]                     next
[17:48:00.611]                   args[[name]] <- ""
[17:48:00.611]                 }
[17:48:00.611]                 NAMES <- toupper(removed)
[17:48:00.611]                 for (kk in seq_along(NAMES)) {
[17:48:00.611]                   name <- removed[[kk]]
[17:48:00.611]                   NAME <- NAMES[[kk]]
[17:48:00.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:00.611]                     next
[17:48:00.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:00.611]                 }
[17:48:00.611]                 if (length(args) > 0) 
[17:48:00.611]                   base::do.call(base::Sys.setenv, args = args)
[17:48:00.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:00.611]             }
[17:48:00.611]             else {
[17:48:00.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:00.611]             }
[17:48:00.611]             {
[17:48:00.611]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:00.611]                   0L) {
[17:48:00.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:00.611]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:00.611]                   base::options(opts)
[17:48:00.611]                 }
[17:48:00.611]                 {
[17:48:00.611]                   {
[17:48:00.611]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:00.611]                     NULL
[17:48:00.611]                   }
[17:48:00.611]                   options(future.plan = NULL)
[17:48:00.611]                   if (is.na(NA_character_)) 
[17:48:00.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:00.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:00.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:00.611]                     .init = FALSE)
[17:48:00.611]                 }
[17:48:00.611]             }
[17:48:00.611]         }
[17:48:00.611]     })
[17:48:00.611]     if (TRUE) {
[17:48:00.611]         base::sink(type = "output", split = FALSE)
[17:48:00.611]         if (TRUE) {
[17:48:00.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:00.611]         }
[17:48:00.611]         else {
[17:48:00.611]             ...future.result["stdout"] <- base::list(NULL)
[17:48:00.611]         }
[17:48:00.611]         base::close(...future.stdout)
[17:48:00.611]         ...future.stdout <- NULL
[17:48:00.611]     }
[17:48:00.611]     ...future.result$conditions <- ...future.conditions
[17:48:00.611]     ...future.result$finished <- base::Sys.time()
[17:48:00.611]     ...future.result
[17:48:00.611] }
[17:48:00.614] MultisessionFuture started
[17:48:00.614] - Launch lazy future ... done
[17:48:00.614] run() for ‘MultisessionFuture’ ... done
[17:48:01.117] receiveMessageFromWorker() for ClusterFuture ...
[17:48:01.117] - Validating connection of MultisessionFuture
[17:48:01.118] - received message: FutureResult
[17:48:01.118] - Received FutureResult
[17:48:01.118] - Erased future from FutureRegistry
[17:48:01.118] result() for ClusterFuture ...
[17:48:01.118] - result already collected: FutureResult
[17:48:01.118] result() for ClusterFuture ... done
[17:48:01.118] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:01.119] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:48:01.119] getGlobalsAndPackages() ...
[17:48:01.119] Searching for globals...
[17:48:01.119] - globals found: [2] ‘list’, ‘stop’
[17:48:01.120] Searching for globals ... DONE
[17:48:01.120] Resolving globals: FALSE
[17:48:01.120] 
[17:48:01.120] 
[17:48:01.120] getGlobalsAndPackages() ... DONE
[17:48:01.120] run() for ‘Future’ ...
[17:48:01.121] - state: ‘created’
[17:48:01.121] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:01.135] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:01.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:01.135]   - Field: ‘node’
[17:48:01.135]   - Field: ‘label’
[17:48:01.135]   - Field: ‘local’
[17:48:01.135]   - Field: ‘owner’
[17:48:01.135]   - Field: ‘envir’
[17:48:01.136]   - Field: ‘workers’
[17:48:01.136]   - Field: ‘packages’
[17:48:01.136]   - Field: ‘gc’
[17:48:01.136]   - Field: ‘conditions’
[17:48:01.136]   - Field: ‘persistent’
[17:48:01.136]   - Field: ‘expr’
[17:48:01.136]   - Field: ‘uuid’
[17:48:01.136]   - Field: ‘seed’
[17:48:01.136]   - Field: ‘version’
[17:48:01.136]   - Field: ‘result’
[17:48:01.136]   - Field: ‘asynchronous’
[17:48:01.137]   - Field: ‘calls’
[17:48:01.137]   - Field: ‘globals’
[17:48:01.137]   - Field: ‘stdout’
[17:48:01.137]   - Field: ‘earlySignal’
[17:48:01.137]   - Field: ‘lazy’
[17:48:01.137]   - Field: ‘state’
[17:48:01.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:01.137] - Launch lazy future ...
[17:48:01.137] Packages needed by the future expression (n = 0): <none>
[17:48:01.138] Packages needed by future strategies (n = 0): <none>
[17:48:01.138] {
[17:48:01.138]     {
[17:48:01.138]         {
[17:48:01.138]             ...future.startTime <- base::Sys.time()
[17:48:01.138]             {
[17:48:01.138]                 {
[17:48:01.138]                   {
[17:48:01.138]                     {
[17:48:01.138]                       base::local({
[17:48:01.138]                         has_future <- base::requireNamespace("future", 
[17:48:01.138]                           quietly = TRUE)
[17:48:01.138]                         if (has_future) {
[17:48:01.138]                           ns <- base::getNamespace("future")
[17:48:01.138]                           version <- ns[[".package"]][["version"]]
[17:48:01.138]                           if (is.null(version)) 
[17:48:01.138]                             version <- utils::packageVersion("future")
[17:48:01.138]                         }
[17:48:01.138]                         else {
[17:48:01.138]                           version <- NULL
[17:48:01.138]                         }
[17:48:01.138]                         if (!has_future || version < "1.8.0") {
[17:48:01.138]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:01.138]                             "", base::R.version$version.string), 
[17:48:01.138]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:01.138]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:01.138]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:01.138]                               "release", "version")], collapse = " "), 
[17:48:01.138]                             hostname = base::Sys.info()[["nodename"]])
[17:48:01.138]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:01.138]                             info)
[17:48:01.138]                           info <- base::paste(info, collapse = "; ")
[17:48:01.138]                           if (!has_future) {
[17:48:01.138]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:01.138]                               info)
[17:48:01.138]                           }
[17:48:01.138]                           else {
[17:48:01.138]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:01.138]                               info, version)
[17:48:01.138]                           }
[17:48:01.138]                           base::stop(msg)
[17:48:01.138]                         }
[17:48:01.138]                       })
[17:48:01.138]                     }
[17:48:01.138]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:01.138]                     base::options(mc.cores = 1L)
[17:48:01.138]                   }
[17:48:01.138]                   ...future.strategy.old <- future::plan("list")
[17:48:01.138]                   options(future.plan = NULL)
[17:48:01.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:01.138]                 }
[17:48:01.138]                 ...future.workdir <- getwd()
[17:48:01.138]             }
[17:48:01.138]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:01.138]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:01.138]         }
[17:48:01.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:01.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:01.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:01.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:01.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:01.138]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:01.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:01.138]             base::names(...future.oldOptions))
[17:48:01.138]     }
[17:48:01.138]     if (FALSE) {
[17:48:01.138]     }
[17:48:01.138]     else {
[17:48:01.138]         if (TRUE) {
[17:48:01.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:01.138]                 open = "w")
[17:48:01.138]         }
[17:48:01.138]         else {
[17:48:01.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:01.138]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:01.138]         }
[17:48:01.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:01.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:01.138]             base::sink(type = "output", split = FALSE)
[17:48:01.138]             base::close(...future.stdout)
[17:48:01.138]         }, add = TRUE)
[17:48:01.138]     }
[17:48:01.138]     ...future.frame <- base::sys.nframe()
[17:48:01.138]     ...future.conditions <- base::list()
[17:48:01.138]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:01.138]     if (FALSE) {
[17:48:01.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:01.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:01.138]     }
[17:48:01.138]     ...future.result <- base::tryCatch({
[17:48:01.138]         base::withCallingHandlers({
[17:48:01.138]             ...future.value <- base::withVisible(base::local({
[17:48:01.138]                 ...future.makeSendCondition <- base::local({
[17:48:01.138]                   sendCondition <- NULL
[17:48:01.138]                   function(frame = 1L) {
[17:48:01.138]                     if (is.function(sendCondition)) 
[17:48:01.138]                       return(sendCondition)
[17:48:01.138]                     ns <- getNamespace("parallel")
[17:48:01.138]                     if (exists("sendData", mode = "function", 
[17:48:01.138]                       envir = ns)) {
[17:48:01.138]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:01.138]                         envir = ns)
[17:48:01.138]                       envir <- sys.frame(frame)
[17:48:01.138]                       master <- NULL
[17:48:01.138]                       while (!identical(envir, .GlobalEnv) && 
[17:48:01.138]                         !identical(envir, emptyenv())) {
[17:48:01.138]                         if (exists("master", mode = "list", envir = envir, 
[17:48:01.138]                           inherits = FALSE)) {
[17:48:01.138]                           master <- get("master", mode = "list", 
[17:48:01.138]                             envir = envir, inherits = FALSE)
[17:48:01.138]                           if (inherits(master, c("SOCKnode", 
[17:48:01.138]                             "SOCK0node"))) {
[17:48:01.138]                             sendCondition <<- function(cond) {
[17:48:01.138]                               data <- list(type = "VALUE", value = cond, 
[17:48:01.138]                                 success = TRUE)
[17:48:01.138]                               parallel_sendData(master, data)
[17:48:01.138]                             }
[17:48:01.138]                             return(sendCondition)
[17:48:01.138]                           }
[17:48:01.138]                         }
[17:48:01.138]                         frame <- frame + 1L
[17:48:01.138]                         envir <- sys.frame(frame)
[17:48:01.138]                       }
[17:48:01.138]                     }
[17:48:01.138]                     sendCondition <<- function(cond) NULL
[17:48:01.138]                   }
[17:48:01.138]                 })
[17:48:01.138]                 withCallingHandlers({
[17:48:01.138]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:01.138]                 }, immediateCondition = function(cond) {
[17:48:01.138]                   sendCondition <- ...future.makeSendCondition()
[17:48:01.138]                   sendCondition(cond)
[17:48:01.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.138]                   {
[17:48:01.138]                     inherits <- base::inherits
[17:48:01.138]                     invokeRestart <- base::invokeRestart
[17:48:01.138]                     is.null <- base::is.null
[17:48:01.138]                     muffled <- FALSE
[17:48:01.138]                     if (inherits(cond, "message")) {
[17:48:01.138]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:01.138]                       if (muffled) 
[17:48:01.138]                         invokeRestart("muffleMessage")
[17:48:01.138]                     }
[17:48:01.138]                     else if (inherits(cond, "warning")) {
[17:48:01.138]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:01.138]                       if (muffled) 
[17:48:01.138]                         invokeRestart("muffleWarning")
[17:48:01.138]                     }
[17:48:01.138]                     else if (inherits(cond, "condition")) {
[17:48:01.138]                       if (!is.null(pattern)) {
[17:48:01.138]                         computeRestarts <- base::computeRestarts
[17:48:01.138]                         grepl <- base::grepl
[17:48:01.138]                         restarts <- computeRestarts(cond)
[17:48:01.138]                         for (restart in restarts) {
[17:48:01.138]                           name <- restart$name
[17:48:01.138]                           if (is.null(name)) 
[17:48:01.138]                             next
[17:48:01.138]                           if (!grepl(pattern, name)) 
[17:48:01.138]                             next
[17:48:01.138]                           invokeRestart(restart)
[17:48:01.138]                           muffled <- TRUE
[17:48:01.138]                           break
[17:48:01.138]                         }
[17:48:01.138]                       }
[17:48:01.138]                     }
[17:48:01.138]                     invisible(muffled)
[17:48:01.138]                   }
[17:48:01.138]                   muffleCondition(cond)
[17:48:01.138]                 })
[17:48:01.138]             }))
[17:48:01.138]             future::FutureResult(value = ...future.value$value, 
[17:48:01.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.138]                   ...future.rng), globalenv = if (FALSE) 
[17:48:01.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:01.138]                     ...future.globalenv.names))
[17:48:01.138]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:01.138]         }, condition = base::local({
[17:48:01.138]             c <- base::c
[17:48:01.138]             inherits <- base::inherits
[17:48:01.138]             invokeRestart <- base::invokeRestart
[17:48:01.138]             length <- base::length
[17:48:01.138]             list <- base::list
[17:48:01.138]             seq.int <- base::seq.int
[17:48:01.138]             signalCondition <- base::signalCondition
[17:48:01.138]             sys.calls <- base::sys.calls
[17:48:01.138]             `[[` <- base::`[[`
[17:48:01.138]             `+` <- base::`+`
[17:48:01.138]             `<<-` <- base::`<<-`
[17:48:01.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:01.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:01.138]                   3L)]
[17:48:01.138]             }
[17:48:01.138]             function(cond) {
[17:48:01.138]                 is_error <- inherits(cond, "error")
[17:48:01.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:01.138]                   NULL)
[17:48:01.138]                 if (is_error) {
[17:48:01.138]                   sessionInformation <- function() {
[17:48:01.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:01.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:01.138]                       search = base::search(), system = base::Sys.info())
[17:48:01.138]                   }
[17:48:01.138]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:01.138]                     cond$call), session = sessionInformation(), 
[17:48:01.138]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:01.138]                   signalCondition(cond)
[17:48:01.138]                 }
[17:48:01.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:01.138]                 "immediateCondition"))) {
[17:48:01.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:01.138]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:01.138]                   if (TRUE && !signal) {
[17:48:01.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.138]                     {
[17:48:01.138]                       inherits <- base::inherits
[17:48:01.138]                       invokeRestart <- base::invokeRestart
[17:48:01.138]                       is.null <- base::is.null
[17:48:01.138]                       muffled <- FALSE
[17:48:01.138]                       if (inherits(cond, "message")) {
[17:48:01.138]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.138]                         if (muffled) 
[17:48:01.138]                           invokeRestart("muffleMessage")
[17:48:01.138]                       }
[17:48:01.138]                       else if (inherits(cond, "warning")) {
[17:48:01.138]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.138]                         if (muffled) 
[17:48:01.138]                           invokeRestart("muffleWarning")
[17:48:01.138]                       }
[17:48:01.138]                       else if (inherits(cond, "condition")) {
[17:48:01.138]                         if (!is.null(pattern)) {
[17:48:01.138]                           computeRestarts <- base::computeRestarts
[17:48:01.138]                           grepl <- base::grepl
[17:48:01.138]                           restarts <- computeRestarts(cond)
[17:48:01.138]                           for (restart in restarts) {
[17:48:01.138]                             name <- restart$name
[17:48:01.138]                             if (is.null(name)) 
[17:48:01.138]                               next
[17:48:01.138]                             if (!grepl(pattern, name)) 
[17:48:01.138]                               next
[17:48:01.138]                             invokeRestart(restart)
[17:48:01.138]                             muffled <- TRUE
[17:48:01.138]                             break
[17:48:01.138]                           }
[17:48:01.138]                         }
[17:48:01.138]                       }
[17:48:01.138]                       invisible(muffled)
[17:48:01.138]                     }
[17:48:01.138]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.138]                   }
[17:48:01.138]                 }
[17:48:01.138]                 else {
[17:48:01.138]                   if (TRUE) {
[17:48:01.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.138]                     {
[17:48:01.138]                       inherits <- base::inherits
[17:48:01.138]                       invokeRestart <- base::invokeRestart
[17:48:01.138]                       is.null <- base::is.null
[17:48:01.138]                       muffled <- FALSE
[17:48:01.138]                       if (inherits(cond, "message")) {
[17:48:01.138]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.138]                         if (muffled) 
[17:48:01.138]                           invokeRestart("muffleMessage")
[17:48:01.138]                       }
[17:48:01.138]                       else if (inherits(cond, "warning")) {
[17:48:01.138]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.138]                         if (muffled) 
[17:48:01.138]                           invokeRestart("muffleWarning")
[17:48:01.138]                       }
[17:48:01.138]                       else if (inherits(cond, "condition")) {
[17:48:01.138]                         if (!is.null(pattern)) {
[17:48:01.138]                           computeRestarts <- base::computeRestarts
[17:48:01.138]                           grepl <- base::grepl
[17:48:01.138]                           restarts <- computeRestarts(cond)
[17:48:01.138]                           for (restart in restarts) {
[17:48:01.138]                             name <- restart$name
[17:48:01.138]                             if (is.null(name)) 
[17:48:01.138]                               next
[17:48:01.138]                             if (!grepl(pattern, name)) 
[17:48:01.138]                               next
[17:48:01.138]                             invokeRestart(restart)
[17:48:01.138]                             muffled <- TRUE
[17:48:01.138]                             break
[17:48:01.138]                           }
[17:48:01.138]                         }
[17:48:01.138]                       }
[17:48:01.138]                       invisible(muffled)
[17:48:01.138]                     }
[17:48:01.138]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.138]                   }
[17:48:01.138]                 }
[17:48:01.138]             }
[17:48:01.138]         }))
[17:48:01.138]     }, error = function(ex) {
[17:48:01.138]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:01.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.138]                 ...future.rng), started = ...future.startTime, 
[17:48:01.138]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:01.138]             version = "1.8"), class = "FutureResult")
[17:48:01.138]     }, finally = {
[17:48:01.138]         if (!identical(...future.workdir, getwd())) 
[17:48:01.138]             setwd(...future.workdir)
[17:48:01.138]         {
[17:48:01.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:01.138]                 ...future.oldOptions$nwarnings <- NULL
[17:48:01.138]             }
[17:48:01.138]             base::options(...future.oldOptions)
[17:48:01.138]             if (.Platform$OS.type == "windows") {
[17:48:01.138]                 old_names <- names(...future.oldEnvVars)
[17:48:01.138]                 envs <- base::Sys.getenv()
[17:48:01.138]                 names <- names(envs)
[17:48:01.138]                 common <- intersect(names, old_names)
[17:48:01.138]                 added <- setdiff(names, old_names)
[17:48:01.138]                 removed <- setdiff(old_names, names)
[17:48:01.138]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:01.138]                   envs[common]]
[17:48:01.138]                 NAMES <- toupper(changed)
[17:48:01.138]                 args <- list()
[17:48:01.138]                 for (kk in seq_along(NAMES)) {
[17:48:01.138]                   name <- changed[[kk]]
[17:48:01.138]                   NAME <- NAMES[[kk]]
[17:48:01.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.138]                     next
[17:48:01.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.138]                 }
[17:48:01.138]                 NAMES <- toupper(added)
[17:48:01.138]                 for (kk in seq_along(NAMES)) {
[17:48:01.138]                   name <- added[[kk]]
[17:48:01.138]                   NAME <- NAMES[[kk]]
[17:48:01.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.138]                     next
[17:48:01.138]                   args[[name]] <- ""
[17:48:01.138]                 }
[17:48:01.138]                 NAMES <- toupper(removed)
[17:48:01.138]                 for (kk in seq_along(NAMES)) {
[17:48:01.138]                   name <- removed[[kk]]
[17:48:01.138]                   NAME <- NAMES[[kk]]
[17:48:01.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.138]                     next
[17:48:01.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.138]                 }
[17:48:01.138]                 if (length(args) > 0) 
[17:48:01.138]                   base::do.call(base::Sys.setenv, args = args)
[17:48:01.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:01.138]             }
[17:48:01.138]             else {
[17:48:01.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:01.138]             }
[17:48:01.138]             {
[17:48:01.138]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:01.138]                   0L) {
[17:48:01.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:01.138]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:01.138]                   base::options(opts)
[17:48:01.138]                 }
[17:48:01.138]                 {
[17:48:01.138]                   {
[17:48:01.138]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:01.138]                     NULL
[17:48:01.138]                   }
[17:48:01.138]                   options(future.plan = NULL)
[17:48:01.138]                   if (is.na(NA_character_)) 
[17:48:01.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:01.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:01.138]                     .init = FALSE)
[17:48:01.138]                 }
[17:48:01.138]             }
[17:48:01.138]         }
[17:48:01.138]     })
[17:48:01.138]     if (TRUE) {
[17:48:01.138]         base::sink(type = "output", split = FALSE)
[17:48:01.138]         if (TRUE) {
[17:48:01.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:01.138]         }
[17:48:01.138]         else {
[17:48:01.138]             ...future.result["stdout"] <- base::list(NULL)
[17:48:01.138]         }
[17:48:01.138]         base::close(...future.stdout)
[17:48:01.138]         ...future.stdout <- NULL
[17:48:01.138]     }
[17:48:01.138]     ...future.result$conditions <- ...future.conditions
[17:48:01.138]     ...future.result$finished <- base::Sys.time()
[17:48:01.138]     ...future.result
[17:48:01.138] }
[17:48:01.141] MultisessionFuture started
[17:48:01.141] - Launch lazy future ... done
[17:48:01.141] run() for ‘MultisessionFuture’ ... done
[17:48:01.143] receiveMessageFromWorker() for ClusterFuture ...
[17:48:01.143] - Validating connection of MultisessionFuture
[17:48:01.144] - received message: FutureResult
[17:48:01.144] - Received FutureResult
[17:48:01.144] - Erased future from FutureRegistry
[17:48:01.144] result() for ClusterFuture ...
[17:48:01.144] - result already collected: FutureResult
[17:48:01.144] result() for ClusterFuture ... done
[17:48:01.144] signalConditions() ...
[17:48:01.144]  - include = ‘immediateCondition’
[17:48:01.144]  - exclude = 
[17:48:01.145]  - resignal = FALSE
[17:48:01.145]  - Number of conditions: 1
[17:48:01.145] signalConditions() ... done
[17:48:01.145] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:01.145] A MultisessionFuture was resolved (result was not collected)
[17:48:01.145] getGlobalsAndPackages() ...
[17:48:01.145] Searching for globals...
[17:48:01.146] - globals found: [2] ‘list’, ‘stop’
[17:48:01.146] Searching for globals ... DONE
[17:48:01.146] Resolving globals: FALSE
[17:48:01.146] 
[17:48:01.146] 
[17:48:01.146] getGlobalsAndPackages() ... DONE
[17:48:01.147] run() for ‘Future’ ...
[17:48:01.147] - state: ‘created’
[17:48:01.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:01.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:01.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:01.161]   - Field: ‘node’
[17:48:01.161]   - Field: ‘label’
[17:48:01.161]   - Field: ‘local’
[17:48:01.161]   - Field: ‘owner’
[17:48:01.161]   - Field: ‘envir’
[17:48:01.161]   - Field: ‘workers’
[17:48:01.161]   - Field: ‘packages’
[17:48:01.162]   - Field: ‘gc’
[17:48:01.162]   - Field: ‘conditions’
[17:48:01.162]   - Field: ‘persistent’
[17:48:01.162]   - Field: ‘expr’
[17:48:01.162]   - Field: ‘uuid’
[17:48:01.162]   - Field: ‘seed’
[17:48:01.162]   - Field: ‘version’
[17:48:01.162]   - Field: ‘result’
[17:48:01.162]   - Field: ‘asynchronous’
[17:48:01.162]   - Field: ‘calls’
[17:48:01.162]   - Field: ‘globals’
[17:48:01.163]   - Field: ‘stdout’
[17:48:01.163]   - Field: ‘earlySignal’
[17:48:01.163]   - Field: ‘lazy’
[17:48:01.163]   - Field: ‘state’
[17:48:01.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:01.163] - Launch lazy future ...
[17:48:01.163] Packages needed by the future expression (n = 0): <none>
[17:48:01.163] Packages needed by future strategies (n = 0): <none>
[17:48:01.164] {
[17:48:01.164]     {
[17:48:01.164]         {
[17:48:01.164]             ...future.startTime <- base::Sys.time()
[17:48:01.164]             {
[17:48:01.164]                 {
[17:48:01.164]                   {
[17:48:01.164]                     {
[17:48:01.164]                       base::local({
[17:48:01.164]                         has_future <- base::requireNamespace("future", 
[17:48:01.164]                           quietly = TRUE)
[17:48:01.164]                         if (has_future) {
[17:48:01.164]                           ns <- base::getNamespace("future")
[17:48:01.164]                           version <- ns[[".package"]][["version"]]
[17:48:01.164]                           if (is.null(version)) 
[17:48:01.164]                             version <- utils::packageVersion("future")
[17:48:01.164]                         }
[17:48:01.164]                         else {
[17:48:01.164]                           version <- NULL
[17:48:01.164]                         }
[17:48:01.164]                         if (!has_future || version < "1.8.0") {
[17:48:01.164]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:01.164]                             "", base::R.version$version.string), 
[17:48:01.164]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:01.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:01.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:01.164]                               "release", "version")], collapse = " "), 
[17:48:01.164]                             hostname = base::Sys.info()[["nodename"]])
[17:48:01.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:01.164]                             info)
[17:48:01.164]                           info <- base::paste(info, collapse = "; ")
[17:48:01.164]                           if (!has_future) {
[17:48:01.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:01.164]                               info)
[17:48:01.164]                           }
[17:48:01.164]                           else {
[17:48:01.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:01.164]                               info, version)
[17:48:01.164]                           }
[17:48:01.164]                           base::stop(msg)
[17:48:01.164]                         }
[17:48:01.164]                       })
[17:48:01.164]                     }
[17:48:01.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:01.164]                     base::options(mc.cores = 1L)
[17:48:01.164]                   }
[17:48:01.164]                   ...future.strategy.old <- future::plan("list")
[17:48:01.164]                   options(future.plan = NULL)
[17:48:01.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:01.164]                 }
[17:48:01.164]                 ...future.workdir <- getwd()
[17:48:01.164]             }
[17:48:01.164]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:01.164]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:01.164]         }
[17:48:01.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:01.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:01.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:01.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:01.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:01.164]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:01.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:01.164]             base::names(...future.oldOptions))
[17:48:01.164]     }
[17:48:01.164]     if (FALSE) {
[17:48:01.164]     }
[17:48:01.164]     else {
[17:48:01.164]         if (TRUE) {
[17:48:01.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:01.164]                 open = "w")
[17:48:01.164]         }
[17:48:01.164]         else {
[17:48:01.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:01.164]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:01.164]         }
[17:48:01.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:01.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:01.164]             base::sink(type = "output", split = FALSE)
[17:48:01.164]             base::close(...future.stdout)
[17:48:01.164]         }, add = TRUE)
[17:48:01.164]     }
[17:48:01.164]     ...future.frame <- base::sys.nframe()
[17:48:01.164]     ...future.conditions <- base::list()
[17:48:01.164]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:01.164]     if (FALSE) {
[17:48:01.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:01.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:01.164]     }
[17:48:01.164]     ...future.result <- base::tryCatch({
[17:48:01.164]         base::withCallingHandlers({
[17:48:01.164]             ...future.value <- base::withVisible(base::local({
[17:48:01.164]                 ...future.makeSendCondition <- base::local({
[17:48:01.164]                   sendCondition <- NULL
[17:48:01.164]                   function(frame = 1L) {
[17:48:01.164]                     if (is.function(sendCondition)) 
[17:48:01.164]                       return(sendCondition)
[17:48:01.164]                     ns <- getNamespace("parallel")
[17:48:01.164]                     if (exists("sendData", mode = "function", 
[17:48:01.164]                       envir = ns)) {
[17:48:01.164]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:01.164]                         envir = ns)
[17:48:01.164]                       envir <- sys.frame(frame)
[17:48:01.164]                       master <- NULL
[17:48:01.164]                       while (!identical(envir, .GlobalEnv) && 
[17:48:01.164]                         !identical(envir, emptyenv())) {
[17:48:01.164]                         if (exists("master", mode = "list", envir = envir, 
[17:48:01.164]                           inherits = FALSE)) {
[17:48:01.164]                           master <- get("master", mode = "list", 
[17:48:01.164]                             envir = envir, inherits = FALSE)
[17:48:01.164]                           if (inherits(master, c("SOCKnode", 
[17:48:01.164]                             "SOCK0node"))) {
[17:48:01.164]                             sendCondition <<- function(cond) {
[17:48:01.164]                               data <- list(type = "VALUE", value = cond, 
[17:48:01.164]                                 success = TRUE)
[17:48:01.164]                               parallel_sendData(master, data)
[17:48:01.164]                             }
[17:48:01.164]                             return(sendCondition)
[17:48:01.164]                           }
[17:48:01.164]                         }
[17:48:01.164]                         frame <- frame + 1L
[17:48:01.164]                         envir <- sys.frame(frame)
[17:48:01.164]                       }
[17:48:01.164]                     }
[17:48:01.164]                     sendCondition <<- function(cond) NULL
[17:48:01.164]                   }
[17:48:01.164]                 })
[17:48:01.164]                 withCallingHandlers({
[17:48:01.164]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:01.164]                 }, immediateCondition = function(cond) {
[17:48:01.164]                   sendCondition <- ...future.makeSendCondition()
[17:48:01.164]                   sendCondition(cond)
[17:48:01.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.164]                   {
[17:48:01.164]                     inherits <- base::inherits
[17:48:01.164]                     invokeRestart <- base::invokeRestart
[17:48:01.164]                     is.null <- base::is.null
[17:48:01.164]                     muffled <- FALSE
[17:48:01.164]                     if (inherits(cond, "message")) {
[17:48:01.164]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:01.164]                       if (muffled) 
[17:48:01.164]                         invokeRestart("muffleMessage")
[17:48:01.164]                     }
[17:48:01.164]                     else if (inherits(cond, "warning")) {
[17:48:01.164]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:01.164]                       if (muffled) 
[17:48:01.164]                         invokeRestart("muffleWarning")
[17:48:01.164]                     }
[17:48:01.164]                     else if (inherits(cond, "condition")) {
[17:48:01.164]                       if (!is.null(pattern)) {
[17:48:01.164]                         computeRestarts <- base::computeRestarts
[17:48:01.164]                         grepl <- base::grepl
[17:48:01.164]                         restarts <- computeRestarts(cond)
[17:48:01.164]                         for (restart in restarts) {
[17:48:01.164]                           name <- restart$name
[17:48:01.164]                           if (is.null(name)) 
[17:48:01.164]                             next
[17:48:01.164]                           if (!grepl(pattern, name)) 
[17:48:01.164]                             next
[17:48:01.164]                           invokeRestart(restart)
[17:48:01.164]                           muffled <- TRUE
[17:48:01.164]                           break
[17:48:01.164]                         }
[17:48:01.164]                       }
[17:48:01.164]                     }
[17:48:01.164]                     invisible(muffled)
[17:48:01.164]                   }
[17:48:01.164]                   muffleCondition(cond)
[17:48:01.164]                 })
[17:48:01.164]             }))
[17:48:01.164]             future::FutureResult(value = ...future.value$value, 
[17:48:01.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.164]                   ...future.rng), globalenv = if (FALSE) 
[17:48:01.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:01.164]                     ...future.globalenv.names))
[17:48:01.164]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:01.164]         }, condition = base::local({
[17:48:01.164]             c <- base::c
[17:48:01.164]             inherits <- base::inherits
[17:48:01.164]             invokeRestart <- base::invokeRestart
[17:48:01.164]             length <- base::length
[17:48:01.164]             list <- base::list
[17:48:01.164]             seq.int <- base::seq.int
[17:48:01.164]             signalCondition <- base::signalCondition
[17:48:01.164]             sys.calls <- base::sys.calls
[17:48:01.164]             `[[` <- base::`[[`
[17:48:01.164]             `+` <- base::`+`
[17:48:01.164]             `<<-` <- base::`<<-`
[17:48:01.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:01.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:01.164]                   3L)]
[17:48:01.164]             }
[17:48:01.164]             function(cond) {
[17:48:01.164]                 is_error <- inherits(cond, "error")
[17:48:01.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:01.164]                   NULL)
[17:48:01.164]                 if (is_error) {
[17:48:01.164]                   sessionInformation <- function() {
[17:48:01.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:01.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:01.164]                       search = base::search(), system = base::Sys.info())
[17:48:01.164]                   }
[17:48:01.164]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:01.164]                     cond$call), session = sessionInformation(), 
[17:48:01.164]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:01.164]                   signalCondition(cond)
[17:48:01.164]                 }
[17:48:01.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:01.164]                 "immediateCondition"))) {
[17:48:01.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:01.164]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:01.164]                   if (TRUE && !signal) {
[17:48:01.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.164]                     {
[17:48:01.164]                       inherits <- base::inherits
[17:48:01.164]                       invokeRestart <- base::invokeRestart
[17:48:01.164]                       is.null <- base::is.null
[17:48:01.164]                       muffled <- FALSE
[17:48:01.164]                       if (inherits(cond, "message")) {
[17:48:01.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.164]                         if (muffled) 
[17:48:01.164]                           invokeRestart("muffleMessage")
[17:48:01.164]                       }
[17:48:01.164]                       else if (inherits(cond, "warning")) {
[17:48:01.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.164]                         if (muffled) 
[17:48:01.164]                           invokeRestart("muffleWarning")
[17:48:01.164]                       }
[17:48:01.164]                       else if (inherits(cond, "condition")) {
[17:48:01.164]                         if (!is.null(pattern)) {
[17:48:01.164]                           computeRestarts <- base::computeRestarts
[17:48:01.164]                           grepl <- base::grepl
[17:48:01.164]                           restarts <- computeRestarts(cond)
[17:48:01.164]                           for (restart in restarts) {
[17:48:01.164]                             name <- restart$name
[17:48:01.164]                             if (is.null(name)) 
[17:48:01.164]                               next
[17:48:01.164]                             if (!grepl(pattern, name)) 
[17:48:01.164]                               next
[17:48:01.164]                             invokeRestart(restart)
[17:48:01.164]                             muffled <- TRUE
[17:48:01.164]                             break
[17:48:01.164]                           }
[17:48:01.164]                         }
[17:48:01.164]                       }
[17:48:01.164]                       invisible(muffled)
[17:48:01.164]                     }
[17:48:01.164]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.164]                   }
[17:48:01.164]                 }
[17:48:01.164]                 else {
[17:48:01.164]                   if (TRUE) {
[17:48:01.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.164]                     {
[17:48:01.164]                       inherits <- base::inherits
[17:48:01.164]                       invokeRestart <- base::invokeRestart
[17:48:01.164]                       is.null <- base::is.null
[17:48:01.164]                       muffled <- FALSE
[17:48:01.164]                       if (inherits(cond, "message")) {
[17:48:01.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.164]                         if (muffled) 
[17:48:01.164]                           invokeRestart("muffleMessage")
[17:48:01.164]                       }
[17:48:01.164]                       else if (inherits(cond, "warning")) {
[17:48:01.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.164]                         if (muffled) 
[17:48:01.164]                           invokeRestart("muffleWarning")
[17:48:01.164]                       }
[17:48:01.164]                       else if (inherits(cond, "condition")) {
[17:48:01.164]                         if (!is.null(pattern)) {
[17:48:01.164]                           computeRestarts <- base::computeRestarts
[17:48:01.164]                           grepl <- base::grepl
[17:48:01.164]                           restarts <- computeRestarts(cond)
[17:48:01.164]                           for (restart in restarts) {
[17:48:01.164]                             name <- restart$name
[17:48:01.164]                             if (is.null(name)) 
[17:48:01.164]                               next
[17:48:01.164]                             if (!grepl(pattern, name)) 
[17:48:01.164]                               next
[17:48:01.164]                             invokeRestart(restart)
[17:48:01.164]                             muffled <- TRUE
[17:48:01.164]                             break
[17:48:01.164]                           }
[17:48:01.164]                         }
[17:48:01.164]                       }
[17:48:01.164]                       invisible(muffled)
[17:48:01.164]                     }
[17:48:01.164]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.164]                   }
[17:48:01.164]                 }
[17:48:01.164]             }
[17:48:01.164]         }))
[17:48:01.164]     }, error = function(ex) {
[17:48:01.164]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:01.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.164]                 ...future.rng), started = ...future.startTime, 
[17:48:01.164]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:01.164]             version = "1.8"), class = "FutureResult")
[17:48:01.164]     }, finally = {
[17:48:01.164]         if (!identical(...future.workdir, getwd())) 
[17:48:01.164]             setwd(...future.workdir)
[17:48:01.164]         {
[17:48:01.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:01.164]                 ...future.oldOptions$nwarnings <- NULL
[17:48:01.164]             }
[17:48:01.164]             base::options(...future.oldOptions)
[17:48:01.164]             if (.Platform$OS.type == "windows") {
[17:48:01.164]                 old_names <- names(...future.oldEnvVars)
[17:48:01.164]                 envs <- base::Sys.getenv()
[17:48:01.164]                 names <- names(envs)
[17:48:01.164]                 common <- intersect(names, old_names)
[17:48:01.164]                 added <- setdiff(names, old_names)
[17:48:01.164]                 removed <- setdiff(old_names, names)
[17:48:01.164]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:01.164]                   envs[common]]
[17:48:01.164]                 NAMES <- toupper(changed)
[17:48:01.164]                 args <- list()
[17:48:01.164]                 for (kk in seq_along(NAMES)) {
[17:48:01.164]                   name <- changed[[kk]]
[17:48:01.164]                   NAME <- NAMES[[kk]]
[17:48:01.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.164]                     next
[17:48:01.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.164]                 }
[17:48:01.164]                 NAMES <- toupper(added)
[17:48:01.164]                 for (kk in seq_along(NAMES)) {
[17:48:01.164]                   name <- added[[kk]]
[17:48:01.164]                   NAME <- NAMES[[kk]]
[17:48:01.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.164]                     next
[17:48:01.164]                   args[[name]] <- ""
[17:48:01.164]                 }
[17:48:01.164]                 NAMES <- toupper(removed)
[17:48:01.164]                 for (kk in seq_along(NAMES)) {
[17:48:01.164]                   name <- removed[[kk]]
[17:48:01.164]                   NAME <- NAMES[[kk]]
[17:48:01.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.164]                     next
[17:48:01.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.164]                 }
[17:48:01.164]                 if (length(args) > 0) 
[17:48:01.164]                   base::do.call(base::Sys.setenv, args = args)
[17:48:01.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:01.164]             }
[17:48:01.164]             else {
[17:48:01.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:01.164]             }
[17:48:01.164]             {
[17:48:01.164]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:01.164]                   0L) {
[17:48:01.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:01.164]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:01.164]                   base::options(opts)
[17:48:01.164]                 }
[17:48:01.164]                 {
[17:48:01.164]                   {
[17:48:01.164]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:01.164]                     NULL
[17:48:01.164]                   }
[17:48:01.164]                   options(future.plan = NULL)
[17:48:01.164]                   if (is.na(NA_character_)) 
[17:48:01.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:01.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:01.164]                     .init = FALSE)
[17:48:01.164]                 }
[17:48:01.164]             }
[17:48:01.164]         }
[17:48:01.164]     })
[17:48:01.164]     if (TRUE) {
[17:48:01.164]         base::sink(type = "output", split = FALSE)
[17:48:01.164]         if (TRUE) {
[17:48:01.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:01.164]         }
[17:48:01.164]         else {
[17:48:01.164]             ...future.result["stdout"] <- base::list(NULL)
[17:48:01.164]         }
[17:48:01.164]         base::close(...future.stdout)
[17:48:01.164]         ...future.stdout <- NULL
[17:48:01.164]     }
[17:48:01.164]     ...future.result$conditions <- ...future.conditions
[17:48:01.164]     ...future.result$finished <- base::Sys.time()
[17:48:01.164]     ...future.result
[17:48:01.164] }
[17:48:01.167] MultisessionFuture started
[17:48:01.167] - Launch lazy future ... done
[17:48:01.167] run() for ‘MultisessionFuture’ ... done
[17:48:01.168] receiveMessageFromWorker() for ClusterFuture ...
[17:48:01.169] - Validating connection of MultisessionFuture
[17:48:01.169] - received message: FutureResult
[17:48:01.169] - Received FutureResult
[17:48:01.169] - Erased future from FutureRegistry
[17:48:01.169] result() for ClusterFuture ...
[17:48:01.170] - result already collected: FutureResult
[17:48:01.170] result() for ClusterFuture ... done
[17:48:01.170] signalConditions() ...
[17:48:01.170]  - include = ‘immediateCondition’
[17:48:01.170]  - exclude = 
[17:48:01.170]  - resignal = FALSE
[17:48:01.170]  - Number of conditions: 1
[17:48:01.170] signalConditions() ... done
[17:48:01.170] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:01.170] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[17:48:01.171] getGlobalsAndPackages() ...
[17:48:01.171] Searching for globals...
[17:48:01.172] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:01.172] Searching for globals ... DONE
[17:48:01.172] Resolving globals: FALSE
[17:48:01.172] 
[17:48:01.172] 
[17:48:01.172] getGlobalsAndPackages() ... DONE
[17:48:01.175] run() for ‘Future’ ...
[17:48:01.175] - state: ‘created’
[17:48:01.175] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:01.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:01.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:01.189]   - Field: ‘node’
[17:48:01.189]   - Field: ‘label’
[17:48:01.189]   - Field: ‘local’
[17:48:01.189]   - Field: ‘owner’
[17:48:01.189]   - Field: ‘envir’
[17:48:01.190]   - Field: ‘workers’
[17:48:01.190]   - Field: ‘packages’
[17:48:01.190]   - Field: ‘gc’
[17:48:01.190]   - Field: ‘conditions’
[17:48:01.190]   - Field: ‘persistent’
[17:48:01.190]   - Field: ‘expr’
[17:48:01.190]   - Field: ‘uuid’
[17:48:01.190]   - Field: ‘seed’
[17:48:01.190]   - Field: ‘version’
[17:48:01.190]   - Field: ‘result’
[17:48:01.190]   - Field: ‘asynchronous’
[17:48:01.191]   - Field: ‘calls’
[17:48:01.191]   - Field: ‘globals’
[17:48:01.191]   - Field: ‘stdout’
[17:48:01.191]   - Field: ‘earlySignal’
[17:48:01.191]   - Field: ‘lazy’
[17:48:01.191]   - Field: ‘state’
[17:48:01.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:01.191] - Launch lazy future ...
[17:48:01.191] Packages needed by the future expression (n = 0): <none>
[17:48:01.192] Packages needed by future strategies (n = 0): <none>
[17:48:01.192] {
[17:48:01.192]     {
[17:48:01.192]         {
[17:48:01.192]             ...future.startTime <- base::Sys.time()
[17:48:01.192]             {
[17:48:01.192]                 {
[17:48:01.192]                   {
[17:48:01.192]                     {
[17:48:01.192]                       base::local({
[17:48:01.192]                         has_future <- base::requireNamespace("future", 
[17:48:01.192]                           quietly = TRUE)
[17:48:01.192]                         if (has_future) {
[17:48:01.192]                           ns <- base::getNamespace("future")
[17:48:01.192]                           version <- ns[[".package"]][["version"]]
[17:48:01.192]                           if (is.null(version)) 
[17:48:01.192]                             version <- utils::packageVersion("future")
[17:48:01.192]                         }
[17:48:01.192]                         else {
[17:48:01.192]                           version <- NULL
[17:48:01.192]                         }
[17:48:01.192]                         if (!has_future || version < "1.8.0") {
[17:48:01.192]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:01.192]                             "", base::R.version$version.string), 
[17:48:01.192]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:01.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:01.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:01.192]                               "release", "version")], collapse = " "), 
[17:48:01.192]                             hostname = base::Sys.info()[["nodename"]])
[17:48:01.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:01.192]                             info)
[17:48:01.192]                           info <- base::paste(info, collapse = "; ")
[17:48:01.192]                           if (!has_future) {
[17:48:01.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:01.192]                               info)
[17:48:01.192]                           }
[17:48:01.192]                           else {
[17:48:01.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:01.192]                               info, version)
[17:48:01.192]                           }
[17:48:01.192]                           base::stop(msg)
[17:48:01.192]                         }
[17:48:01.192]                       })
[17:48:01.192]                     }
[17:48:01.192]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:01.192]                     base::options(mc.cores = 1L)
[17:48:01.192]                   }
[17:48:01.192]                   ...future.strategy.old <- future::plan("list")
[17:48:01.192]                   options(future.plan = NULL)
[17:48:01.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:01.192]                 }
[17:48:01.192]                 ...future.workdir <- getwd()
[17:48:01.192]             }
[17:48:01.192]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:01.192]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:01.192]         }
[17:48:01.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:01.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:01.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:01.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:01.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:01.192]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:01.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:01.192]             base::names(...future.oldOptions))
[17:48:01.192]     }
[17:48:01.192]     if (FALSE) {
[17:48:01.192]     }
[17:48:01.192]     else {
[17:48:01.192]         if (TRUE) {
[17:48:01.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:01.192]                 open = "w")
[17:48:01.192]         }
[17:48:01.192]         else {
[17:48:01.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:01.192]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:01.192]         }
[17:48:01.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:01.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:01.192]             base::sink(type = "output", split = FALSE)
[17:48:01.192]             base::close(...future.stdout)
[17:48:01.192]         }, add = TRUE)
[17:48:01.192]     }
[17:48:01.192]     ...future.frame <- base::sys.nframe()
[17:48:01.192]     ...future.conditions <- base::list()
[17:48:01.192]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:01.192]     if (FALSE) {
[17:48:01.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:01.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:01.192]     }
[17:48:01.192]     ...future.result <- base::tryCatch({
[17:48:01.192]         base::withCallingHandlers({
[17:48:01.192]             ...future.value <- base::withVisible(base::local({
[17:48:01.192]                 ...future.makeSendCondition <- base::local({
[17:48:01.192]                   sendCondition <- NULL
[17:48:01.192]                   function(frame = 1L) {
[17:48:01.192]                     if (is.function(sendCondition)) 
[17:48:01.192]                       return(sendCondition)
[17:48:01.192]                     ns <- getNamespace("parallel")
[17:48:01.192]                     if (exists("sendData", mode = "function", 
[17:48:01.192]                       envir = ns)) {
[17:48:01.192]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:01.192]                         envir = ns)
[17:48:01.192]                       envir <- sys.frame(frame)
[17:48:01.192]                       master <- NULL
[17:48:01.192]                       while (!identical(envir, .GlobalEnv) && 
[17:48:01.192]                         !identical(envir, emptyenv())) {
[17:48:01.192]                         if (exists("master", mode = "list", envir = envir, 
[17:48:01.192]                           inherits = FALSE)) {
[17:48:01.192]                           master <- get("master", mode = "list", 
[17:48:01.192]                             envir = envir, inherits = FALSE)
[17:48:01.192]                           if (inherits(master, c("SOCKnode", 
[17:48:01.192]                             "SOCK0node"))) {
[17:48:01.192]                             sendCondition <<- function(cond) {
[17:48:01.192]                               data <- list(type = "VALUE", value = cond, 
[17:48:01.192]                                 success = TRUE)
[17:48:01.192]                               parallel_sendData(master, data)
[17:48:01.192]                             }
[17:48:01.192]                             return(sendCondition)
[17:48:01.192]                           }
[17:48:01.192]                         }
[17:48:01.192]                         frame <- frame + 1L
[17:48:01.192]                         envir <- sys.frame(frame)
[17:48:01.192]                       }
[17:48:01.192]                     }
[17:48:01.192]                     sendCondition <<- function(cond) NULL
[17:48:01.192]                   }
[17:48:01.192]                 })
[17:48:01.192]                 withCallingHandlers({
[17:48:01.192]                   {
[17:48:01.192]                     Sys.sleep(0.5)
[17:48:01.192]                     list(a = 1, b = 42L)
[17:48:01.192]                   }
[17:48:01.192]                 }, immediateCondition = function(cond) {
[17:48:01.192]                   sendCondition <- ...future.makeSendCondition()
[17:48:01.192]                   sendCondition(cond)
[17:48:01.192]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.192]                   {
[17:48:01.192]                     inherits <- base::inherits
[17:48:01.192]                     invokeRestart <- base::invokeRestart
[17:48:01.192]                     is.null <- base::is.null
[17:48:01.192]                     muffled <- FALSE
[17:48:01.192]                     if (inherits(cond, "message")) {
[17:48:01.192]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:01.192]                       if (muffled) 
[17:48:01.192]                         invokeRestart("muffleMessage")
[17:48:01.192]                     }
[17:48:01.192]                     else if (inherits(cond, "warning")) {
[17:48:01.192]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:01.192]                       if (muffled) 
[17:48:01.192]                         invokeRestart("muffleWarning")
[17:48:01.192]                     }
[17:48:01.192]                     else if (inherits(cond, "condition")) {
[17:48:01.192]                       if (!is.null(pattern)) {
[17:48:01.192]                         computeRestarts <- base::computeRestarts
[17:48:01.192]                         grepl <- base::grepl
[17:48:01.192]                         restarts <- computeRestarts(cond)
[17:48:01.192]                         for (restart in restarts) {
[17:48:01.192]                           name <- restart$name
[17:48:01.192]                           if (is.null(name)) 
[17:48:01.192]                             next
[17:48:01.192]                           if (!grepl(pattern, name)) 
[17:48:01.192]                             next
[17:48:01.192]                           invokeRestart(restart)
[17:48:01.192]                           muffled <- TRUE
[17:48:01.192]                           break
[17:48:01.192]                         }
[17:48:01.192]                       }
[17:48:01.192]                     }
[17:48:01.192]                     invisible(muffled)
[17:48:01.192]                   }
[17:48:01.192]                   muffleCondition(cond)
[17:48:01.192]                 })
[17:48:01.192]             }))
[17:48:01.192]             future::FutureResult(value = ...future.value$value, 
[17:48:01.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.192]                   ...future.rng), globalenv = if (FALSE) 
[17:48:01.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:01.192]                     ...future.globalenv.names))
[17:48:01.192]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:01.192]         }, condition = base::local({
[17:48:01.192]             c <- base::c
[17:48:01.192]             inherits <- base::inherits
[17:48:01.192]             invokeRestart <- base::invokeRestart
[17:48:01.192]             length <- base::length
[17:48:01.192]             list <- base::list
[17:48:01.192]             seq.int <- base::seq.int
[17:48:01.192]             signalCondition <- base::signalCondition
[17:48:01.192]             sys.calls <- base::sys.calls
[17:48:01.192]             `[[` <- base::`[[`
[17:48:01.192]             `+` <- base::`+`
[17:48:01.192]             `<<-` <- base::`<<-`
[17:48:01.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:01.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:01.192]                   3L)]
[17:48:01.192]             }
[17:48:01.192]             function(cond) {
[17:48:01.192]                 is_error <- inherits(cond, "error")
[17:48:01.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:01.192]                   NULL)
[17:48:01.192]                 if (is_error) {
[17:48:01.192]                   sessionInformation <- function() {
[17:48:01.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:01.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:01.192]                       search = base::search(), system = base::Sys.info())
[17:48:01.192]                   }
[17:48:01.192]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:01.192]                     cond$call), session = sessionInformation(), 
[17:48:01.192]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:01.192]                   signalCondition(cond)
[17:48:01.192]                 }
[17:48:01.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:01.192]                 "immediateCondition"))) {
[17:48:01.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:01.192]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:01.192]                   if (TRUE && !signal) {
[17:48:01.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.192]                     {
[17:48:01.192]                       inherits <- base::inherits
[17:48:01.192]                       invokeRestart <- base::invokeRestart
[17:48:01.192]                       is.null <- base::is.null
[17:48:01.192]                       muffled <- FALSE
[17:48:01.192]                       if (inherits(cond, "message")) {
[17:48:01.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.192]                         if (muffled) 
[17:48:01.192]                           invokeRestart("muffleMessage")
[17:48:01.192]                       }
[17:48:01.192]                       else if (inherits(cond, "warning")) {
[17:48:01.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.192]                         if (muffled) 
[17:48:01.192]                           invokeRestart("muffleWarning")
[17:48:01.192]                       }
[17:48:01.192]                       else if (inherits(cond, "condition")) {
[17:48:01.192]                         if (!is.null(pattern)) {
[17:48:01.192]                           computeRestarts <- base::computeRestarts
[17:48:01.192]                           grepl <- base::grepl
[17:48:01.192]                           restarts <- computeRestarts(cond)
[17:48:01.192]                           for (restart in restarts) {
[17:48:01.192]                             name <- restart$name
[17:48:01.192]                             if (is.null(name)) 
[17:48:01.192]                               next
[17:48:01.192]                             if (!grepl(pattern, name)) 
[17:48:01.192]                               next
[17:48:01.192]                             invokeRestart(restart)
[17:48:01.192]                             muffled <- TRUE
[17:48:01.192]                             break
[17:48:01.192]                           }
[17:48:01.192]                         }
[17:48:01.192]                       }
[17:48:01.192]                       invisible(muffled)
[17:48:01.192]                     }
[17:48:01.192]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.192]                   }
[17:48:01.192]                 }
[17:48:01.192]                 else {
[17:48:01.192]                   if (TRUE) {
[17:48:01.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.192]                     {
[17:48:01.192]                       inherits <- base::inherits
[17:48:01.192]                       invokeRestart <- base::invokeRestart
[17:48:01.192]                       is.null <- base::is.null
[17:48:01.192]                       muffled <- FALSE
[17:48:01.192]                       if (inherits(cond, "message")) {
[17:48:01.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.192]                         if (muffled) 
[17:48:01.192]                           invokeRestart("muffleMessage")
[17:48:01.192]                       }
[17:48:01.192]                       else if (inherits(cond, "warning")) {
[17:48:01.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.192]                         if (muffled) 
[17:48:01.192]                           invokeRestart("muffleWarning")
[17:48:01.192]                       }
[17:48:01.192]                       else if (inherits(cond, "condition")) {
[17:48:01.192]                         if (!is.null(pattern)) {
[17:48:01.192]                           computeRestarts <- base::computeRestarts
[17:48:01.192]                           grepl <- base::grepl
[17:48:01.192]                           restarts <- computeRestarts(cond)
[17:48:01.192]                           for (restart in restarts) {
[17:48:01.192]                             name <- restart$name
[17:48:01.192]                             if (is.null(name)) 
[17:48:01.192]                               next
[17:48:01.192]                             if (!grepl(pattern, name)) 
[17:48:01.192]                               next
[17:48:01.192]                             invokeRestart(restart)
[17:48:01.192]                             muffled <- TRUE
[17:48:01.192]                             break
[17:48:01.192]                           }
[17:48:01.192]                         }
[17:48:01.192]                       }
[17:48:01.192]                       invisible(muffled)
[17:48:01.192]                     }
[17:48:01.192]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.192]                   }
[17:48:01.192]                 }
[17:48:01.192]             }
[17:48:01.192]         }))
[17:48:01.192]     }, error = function(ex) {
[17:48:01.192]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:01.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.192]                 ...future.rng), started = ...future.startTime, 
[17:48:01.192]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:01.192]             version = "1.8"), class = "FutureResult")
[17:48:01.192]     }, finally = {
[17:48:01.192]         if (!identical(...future.workdir, getwd())) 
[17:48:01.192]             setwd(...future.workdir)
[17:48:01.192]         {
[17:48:01.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:01.192]                 ...future.oldOptions$nwarnings <- NULL
[17:48:01.192]             }
[17:48:01.192]             base::options(...future.oldOptions)
[17:48:01.192]             if (.Platform$OS.type == "windows") {
[17:48:01.192]                 old_names <- names(...future.oldEnvVars)
[17:48:01.192]                 envs <- base::Sys.getenv()
[17:48:01.192]                 names <- names(envs)
[17:48:01.192]                 common <- intersect(names, old_names)
[17:48:01.192]                 added <- setdiff(names, old_names)
[17:48:01.192]                 removed <- setdiff(old_names, names)
[17:48:01.192]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:01.192]                   envs[common]]
[17:48:01.192]                 NAMES <- toupper(changed)
[17:48:01.192]                 args <- list()
[17:48:01.192]                 for (kk in seq_along(NAMES)) {
[17:48:01.192]                   name <- changed[[kk]]
[17:48:01.192]                   NAME <- NAMES[[kk]]
[17:48:01.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.192]                     next
[17:48:01.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.192]                 }
[17:48:01.192]                 NAMES <- toupper(added)
[17:48:01.192]                 for (kk in seq_along(NAMES)) {
[17:48:01.192]                   name <- added[[kk]]
[17:48:01.192]                   NAME <- NAMES[[kk]]
[17:48:01.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.192]                     next
[17:48:01.192]                   args[[name]] <- ""
[17:48:01.192]                 }
[17:48:01.192]                 NAMES <- toupper(removed)
[17:48:01.192]                 for (kk in seq_along(NAMES)) {
[17:48:01.192]                   name <- removed[[kk]]
[17:48:01.192]                   NAME <- NAMES[[kk]]
[17:48:01.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.192]                     next
[17:48:01.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.192]                 }
[17:48:01.192]                 if (length(args) > 0) 
[17:48:01.192]                   base::do.call(base::Sys.setenv, args = args)
[17:48:01.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:01.192]             }
[17:48:01.192]             else {
[17:48:01.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:01.192]             }
[17:48:01.192]             {
[17:48:01.192]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:01.192]                   0L) {
[17:48:01.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:01.192]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:01.192]                   base::options(opts)
[17:48:01.192]                 }
[17:48:01.192]                 {
[17:48:01.192]                   {
[17:48:01.192]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:01.192]                     NULL
[17:48:01.192]                   }
[17:48:01.192]                   options(future.plan = NULL)
[17:48:01.192]                   if (is.na(NA_character_)) 
[17:48:01.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:01.192]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:01.192]                     .init = FALSE)
[17:48:01.192]                 }
[17:48:01.192]             }
[17:48:01.192]         }
[17:48:01.192]     })
[17:48:01.192]     if (TRUE) {
[17:48:01.192]         base::sink(type = "output", split = FALSE)
[17:48:01.192]         if (TRUE) {
[17:48:01.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:01.192]         }
[17:48:01.192]         else {
[17:48:01.192]             ...future.result["stdout"] <- base::list(NULL)
[17:48:01.192]         }
[17:48:01.192]         base::close(...future.stdout)
[17:48:01.192]         ...future.stdout <- NULL
[17:48:01.192]     }
[17:48:01.192]     ...future.result$conditions <- ...future.conditions
[17:48:01.192]     ...future.result$finished <- base::Sys.time()
[17:48:01.192]     ...future.result
[17:48:01.192] }
[17:48:01.195] MultisessionFuture started
[17:48:01.195] - Launch lazy future ... done
[17:48:01.195] run() for ‘MultisessionFuture’ ... done
[17:48:01.697] receiveMessageFromWorker() for ClusterFuture ...
[17:48:01.697] - Validating connection of MultisessionFuture
[17:48:01.698] - received message: FutureResult
[17:48:01.698] - Received FutureResult
[17:48:01.698] - Erased future from FutureRegistry
[17:48:01.698] result() for ClusterFuture ...
[17:48:01.698] - result already collected: FutureResult
[17:48:01.698] result() for ClusterFuture ... done
[17:48:01.698] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:01.698] A MultisessionFuture was resolved (result was not collected)
[17:48:01.699] getGlobalsAndPackages() ...
[17:48:01.699] Searching for globals...
[17:48:01.700] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:01.700] Searching for globals ... DONE
[17:48:01.700] Resolving globals: FALSE
[17:48:01.700] 
[17:48:01.700] 
[17:48:01.700] getGlobalsAndPackages() ... DONE
[17:48:01.701] run() for ‘Future’ ...
[17:48:01.701] - state: ‘created’
[17:48:01.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:01.715] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:01.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:01.715]   - Field: ‘node’
[17:48:01.715]   - Field: ‘label’
[17:48:01.715]   - Field: ‘local’
[17:48:01.716]   - Field: ‘owner’
[17:48:01.716]   - Field: ‘envir’
[17:48:01.716]   - Field: ‘workers’
[17:48:01.716]   - Field: ‘packages’
[17:48:01.716]   - Field: ‘gc’
[17:48:01.716]   - Field: ‘conditions’
[17:48:01.716]   - Field: ‘persistent’
[17:48:01.716]   - Field: ‘expr’
[17:48:01.716]   - Field: ‘uuid’
[17:48:01.716]   - Field: ‘seed’
[17:48:01.716]   - Field: ‘version’
[17:48:01.717]   - Field: ‘result’
[17:48:01.717]   - Field: ‘asynchronous’
[17:48:01.717]   - Field: ‘calls’
[17:48:01.717]   - Field: ‘globals’
[17:48:01.717]   - Field: ‘stdout’
[17:48:01.717]   - Field: ‘earlySignal’
[17:48:01.717]   - Field: ‘lazy’
[17:48:01.717]   - Field: ‘state’
[17:48:01.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:01.717] - Launch lazy future ...
[17:48:01.718] Packages needed by the future expression (n = 0): <none>
[17:48:01.718] Packages needed by future strategies (n = 0): <none>
[17:48:01.718] {
[17:48:01.718]     {
[17:48:01.718]         {
[17:48:01.718]             ...future.startTime <- base::Sys.time()
[17:48:01.718]             {
[17:48:01.718]                 {
[17:48:01.718]                   {
[17:48:01.718]                     {
[17:48:01.718]                       base::local({
[17:48:01.718]                         has_future <- base::requireNamespace("future", 
[17:48:01.718]                           quietly = TRUE)
[17:48:01.718]                         if (has_future) {
[17:48:01.718]                           ns <- base::getNamespace("future")
[17:48:01.718]                           version <- ns[[".package"]][["version"]]
[17:48:01.718]                           if (is.null(version)) 
[17:48:01.718]                             version <- utils::packageVersion("future")
[17:48:01.718]                         }
[17:48:01.718]                         else {
[17:48:01.718]                           version <- NULL
[17:48:01.718]                         }
[17:48:01.718]                         if (!has_future || version < "1.8.0") {
[17:48:01.718]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:01.718]                             "", base::R.version$version.string), 
[17:48:01.718]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:01.718]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:01.718]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:01.718]                               "release", "version")], collapse = " "), 
[17:48:01.718]                             hostname = base::Sys.info()[["nodename"]])
[17:48:01.718]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:01.718]                             info)
[17:48:01.718]                           info <- base::paste(info, collapse = "; ")
[17:48:01.718]                           if (!has_future) {
[17:48:01.718]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:01.718]                               info)
[17:48:01.718]                           }
[17:48:01.718]                           else {
[17:48:01.718]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:01.718]                               info, version)
[17:48:01.718]                           }
[17:48:01.718]                           base::stop(msg)
[17:48:01.718]                         }
[17:48:01.718]                       })
[17:48:01.718]                     }
[17:48:01.718]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:01.718]                     base::options(mc.cores = 1L)
[17:48:01.718]                   }
[17:48:01.718]                   ...future.strategy.old <- future::plan("list")
[17:48:01.718]                   options(future.plan = NULL)
[17:48:01.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:01.718]                 }
[17:48:01.718]                 ...future.workdir <- getwd()
[17:48:01.718]             }
[17:48:01.718]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:01.718]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:01.718]         }
[17:48:01.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:01.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:01.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:01.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:01.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:01.718]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:01.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:01.718]             base::names(...future.oldOptions))
[17:48:01.718]     }
[17:48:01.718]     if (FALSE) {
[17:48:01.718]     }
[17:48:01.718]     else {
[17:48:01.718]         if (TRUE) {
[17:48:01.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:01.718]                 open = "w")
[17:48:01.718]         }
[17:48:01.718]         else {
[17:48:01.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:01.718]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:01.718]         }
[17:48:01.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:01.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:01.718]             base::sink(type = "output", split = FALSE)
[17:48:01.718]             base::close(...future.stdout)
[17:48:01.718]         }, add = TRUE)
[17:48:01.718]     }
[17:48:01.718]     ...future.frame <- base::sys.nframe()
[17:48:01.718]     ...future.conditions <- base::list()
[17:48:01.718]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:01.718]     if (FALSE) {
[17:48:01.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:01.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:01.718]     }
[17:48:01.718]     ...future.result <- base::tryCatch({
[17:48:01.718]         base::withCallingHandlers({
[17:48:01.718]             ...future.value <- base::withVisible(base::local({
[17:48:01.718]                 ...future.makeSendCondition <- base::local({
[17:48:01.718]                   sendCondition <- NULL
[17:48:01.718]                   function(frame = 1L) {
[17:48:01.718]                     if (is.function(sendCondition)) 
[17:48:01.718]                       return(sendCondition)
[17:48:01.718]                     ns <- getNamespace("parallel")
[17:48:01.718]                     if (exists("sendData", mode = "function", 
[17:48:01.718]                       envir = ns)) {
[17:48:01.718]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:01.718]                         envir = ns)
[17:48:01.718]                       envir <- sys.frame(frame)
[17:48:01.718]                       master <- NULL
[17:48:01.718]                       while (!identical(envir, .GlobalEnv) && 
[17:48:01.718]                         !identical(envir, emptyenv())) {
[17:48:01.718]                         if (exists("master", mode = "list", envir = envir, 
[17:48:01.718]                           inherits = FALSE)) {
[17:48:01.718]                           master <- get("master", mode = "list", 
[17:48:01.718]                             envir = envir, inherits = FALSE)
[17:48:01.718]                           if (inherits(master, c("SOCKnode", 
[17:48:01.718]                             "SOCK0node"))) {
[17:48:01.718]                             sendCondition <<- function(cond) {
[17:48:01.718]                               data <- list(type = "VALUE", value = cond, 
[17:48:01.718]                                 success = TRUE)
[17:48:01.718]                               parallel_sendData(master, data)
[17:48:01.718]                             }
[17:48:01.718]                             return(sendCondition)
[17:48:01.718]                           }
[17:48:01.718]                         }
[17:48:01.718]                         frame <- frame + 1L
[17:48:01.718]                         envir <- sys.frame(frame)
[17:48:01.718]                       }
[17:48:01.718]                     }
[17:48:01.718]                     sendCondition <<- function(cond) NULL
[17:48:01.718]                   }
[17:48:01.718]                 })
[17:48:01.718]                 withCallingHandlers({
[17:48:01.718]                   {
[17:48:01.718]                     Sys.sleep(0.5)
[17:48:01.718]                     list(a = 1, b = 42L)
[17:48:01.718]                   }
[17:48:01.718]                 }, immediateCondition = function(cond) {
[17:48:01.718]                   sendCondition <- ...future.makeSendCondition()
[17:48:01.718]                   sendCondition(cond)
[17:48:01.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.718]                   {
[17:48:01.718]                     inherits <- base::inherits
[17:48:01.718]                     invokeRestart <- base::invokeRestart
[17:48:01.718]                     is.null <- base::is.null
[17:48:01.718]                     muffled <- FALSE
[17:48:01.718]                     if (inherits(cond, "message")) {
[17:48:01.718]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:01.718]                       if (muffled) 
[17:48:01.718]                         invokeRestart("muffleMessage")
[17:48:01.718]                     }
[17:48:01.718]                     else if (inherits(cond, "warning")) {
[17:48:01.718]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:01.718]                       if (muffled) 
[17:48:01.718]                         invokeRestart("muffleWarning")
[17:48:01.718]                     }
[17:48:01.718]                     else if (inherits(cond, "condition")) {
[17:48:01.718]                       if (!is.null(pattern)) {
[17:48:01.718]                         computeRestarts <- base::computeRestarts
[17:48:01.718]                         grepl <- base::grepl
[17:48:01.718]                         restarts <- computeRestarts(cond)
[17:48:01.718]                         for (restart in restarts) {
[17:48:01.718]                           name <- restart$name
[17:48:01.718]                           if (is.null(name)) 
[17:48:01.718]                             next
[17:48:01.718]                           if (!grepl(pattern, name)) 
[17:48:01.718]                             next
[17:48:01.718]                           invokeRestart(restart)
[17:48:01.718]                           muffled <- TRUE
[17:48:01.718]                           break
[17:48:01.718]                         }
[17:48:01.718]                       }
[17:48:01.718]                     }
[17:48:01.718]                     invisible(muffled)
[17:48:01.718]                   }
[17:48:01.718]                   muffleCondition(cond)
[17:48:01.718]                 })
[17:48:01.718]             }))
[17:48:01.718]             future::FutureResult(value = ...future.value$value, 
[17:48:01.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.718]                   ...future.rng), globalenv = if (FALSE) 
[17:48:01.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:01.718]                     ...future.globalenv.names))
[17:48:01.718]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:01.718]         }, condition = base::local({
[17:48:01.718]             c <- base::c
[17:48:01.718]             inherits <- base::inherits
[17:48:01.718]             invokeRestart <- base::invokeRestart
[17:48:01.718]             length <- base::length
[17:48:01.718]             list <- base::list
[17:48:01.718]             seq.int <- base::seq.int
[17:48:01.718]             signalCondition <- base::signalCondition
[17:48:01.718]             sys.calls <- base::sys.calls
[17:48:01.718]             `[[` <- base::`[[`
[17:48:01.718]             `+` <- base::`+`
[17:48:01.718]             `<<-` <- base::`<<-`
[17:48:01.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:01.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:01.718]                   3L)]
[17:48:01.718]             }
[17:48:01.718]             function(cond) {
[17:48:01.718]                 is_error <- inherits(cond, "error")
[17:48:01.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:01.718]                   NULL)
[17:48:01.718]                 if (is_error) {
[17:48:01.718]                   sessionInformation <- function() {
[17:48:01.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:01.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:01.718]                       search = base::search(), system = base::Sys.info())
[17:48:01.718]                   }
[17:48:01.718]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:01.718]                     cond$call), session = sessionInformation(), 
[17:48:01.718]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:01.718]                   signalCondition(cond)
[17:48:01.718]                 }
[17:48:01.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:01.718]                 "immediateCondition"))) {
[17:48:01.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:01.718]                   ...future.conditions[[length(...future.conditions) + 
[17:48:01.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:01.718]                   if (TRUE && !signal) {
[17:48:01.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.718]                     {
[17:48:01.718]                       inherits <- base::inherits
[17:48:01.718]                       invokeRestart <- base::invokeRestart
[17:48:01.718]                       is.null <- base::is.null
[17:48:01.718]                       muffled <- FALSE
[17:48:01.718]                       if (inherits(cond, "message")) {
[17:48:01.718]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.718]                         if (muffled) 
[17:48:01.718]                           invokeRestart("muffleMessage")
[17:48:01.718]                       }
[17:48:01.718]                       else if (inherits(cond, "warning")) {
[17:48:01.718]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.718]                         if (muffled) 
[17:48:01.718]                           invokeRestart("muffleWarning")
[17:48:01.718]                       }
[17:48:01.718]                       else if (inherits(cond, "condition")) {
[17:48:01.718]                         if (!is.null(pattern)) {
[17:48:01.718]                           computeRestarts <- base::computeRestarts
[17:48:01.718]                           grepl <- base::grepl
[17:48:01.718]                           restarts <- computeRestarts(cond)
[17:48:01.718]                           for (restart in restarts) {
[17:48:01.718]                             name <- restart$name
[17:48:01.718]                             if (is.null(name)) 
[17:48:01.718]                               next
[17:48:01.718]                             if (!grepl(pattern, name)) 
[17:48:01.718]                               next
[17:48:01.718]                             invokeRestart(restart)
[17:48:01.718]                             muffled <- TRUE
[17:48:01.718]                             break
[17:48:01.718]                           }
[17:48:01.718]                         }
[17:48:01.718]                       }
[17:48:01.718]                       invisible(muffled)
[17:48:01.718]                     }
[17:48:01.718]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.718]                   }
[17:48:01.718]                 }
[17:48:01.718]                 else {
[17:48:01.718]                   if (TRUE) {
[17:48:01.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:01.718]                     {
[17:48:01.718]                       inherits <- base::inherits
[17:48:01.718]                       invokeRestart <- base::invokeRestart
[17:48:01.718]                       is.null <- base::is.null
[17:48:01.718]                       muffled <- FALSE
[17:48:01.718]                       if (inherits(cond, "message")) {
[17:48:01.718]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:01.718]                         if (muffled) 
[17:48:01.718]                           invokeRestart("muffleMessage")
[17:48:01.718]                       }
[17:48:01.718]                       else if (inherits(cond, "warning")) {
[17:48:01.718]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:01.718]                         if (muffled) 
[17:48:01.718]                           invokeRestart("muffleWarning")
[17:48:01.718]                       }
[17:48:01.718]                       else if (inherits(cond, "condition")) {
[17:48:01.718]                         if (!is.null(pattern)) {
[17:48:01.718]                           computeRestarts <- base::computeRestarts
[17:48:01.718]                           grepl <- base::grepl
[17:48:01.718]                           restarts <- computeRestarts(cond)
[17:48:01.718]                           for (restart in restarts) {
[17:48:01.718]                             name <- restart$name
[17:48:01.718]                             if (is.null(name)) 
[17:48:01.718]                               next
[17:48:01.718]                             if (!grepl(pattern, name)) 
[17:48:01.718]                               next
[17:48:01.718]                             invokeRestart(restart)
[17:48:01.718]                             muffled <- TRUE
[17:48:01.718]                             break
[17:48:01.718]                           }
[17:48:01.718]                         }
[17:48:01.718]                       }
[17:48:01.718]                       invisible(muffled)
[17:48:01.718]                     }
[17:48:01.718]                     muffleCondition(cond, pattern = "^muffle")
[17:48:01.718]                   }
[17:48:01.718]                 }
[17:48:01.718]             }
[17:48:01.718]         }))
[17:48:01.718]     }, error = function(ex) {
[17:48:01.718]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:01.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:01.718]                 ...future.rng), started = ...future.startTime, 
[17:48:01.718]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:01.718]             version = "1.8"), class = "FutureResult")
[17:48:01.718]     }, finally = {
[17:48:01.718]         if (!identical(...future.workdir, getwd())) 
[17:48:01.718]             setwd(...future.workdir)
[17:48:01.718]         {
[17:48:01.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:01.718]                 ...future.oldOptions$nwarnings <- NULL
[17:48:01.718]             }
[17:48:01.718]             base::options(...future.oldOptions)
[17:48:01.718]             if (.Platform$OS.type == "windows") {
[17:48:01.718]                 old_names <- names(...future.oldEnvVars)
[17:48:01.718]                 envs <- base::Sys.getenv()
[17:48:01.718]                 names <- names(envs)
[17:48:01.718]                 common <- intersect(names, old_names)
[17:48:01.718]                 added <- setdiff(names, old_names)
[17:48:01.718]                 removed <- setdiff(old_names, names)
[17:48:01.718]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:01.718]                   envs[common]]
[17:48:01.718]                 NAMES <- toupper(changed)
[17:48:01.718]                 args <- list()
[17:48:01.718]                 for (kk in seq_along(NAMES)) {
[17:48:01.718]                   name <- changed[[kk]]
[17:48:01.718]                   NAME <- NAMES[[kk]]
[17:48:01.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.718]                     next
[17:48:01.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.718]                 }
[17:48:01.718]                 NAMES <- toupper(added)
[17:48:01.718]                 for (kk in seq_along(NAMES)) {
[17:48:01.718]                   name <- added[[kk]]
[17:48:01.718]                   NAME <- NAMES[[kk]]
[17:48:01.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.718]                     next
[17:48:01.718]                   args[[name]] <- ""
[17:48:01.718]                 }
[17:48:01.718]                 NAMES <- toupper(removed)
[17:48:01.718]                 for (kk in seq_along(NAMES)) {
[17:48:01.718]                   name <- removed[[kk]]
[17:48:01.718]                   NAME <- NAMES[[kk]]
[17:48:01.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:01.718]                     next
[17:48:01.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:01.718]                 }
[17:48:01.718]                 if (length(args) > 0) 
[17:48:01.718]                   base::do.call(base::Sys.setenv, args = args)
[17:48:01.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:01.718]             }
[17:48:01.718]             else {
[17:48:01.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:01.718]             }
[17:48:01.718]             {
[17:48:01.718]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:01.718]                   0L) {
[17:48:01.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:01.718]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:01.718]                   base::options(opts)
[17:48:01.718]                 }
[17:48:01.718]                 {
[17:48:01.718]                   {
[17:48:01.718]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:01.718]                     NULL
[17:48:01.718]                   }
[17:48:01.718]                   options(future.plan = NULL)
[17:48:01.718]                   if (is.na(NA_character_)) 
[17:48:01.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:01.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:01.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:01.718]                     .init = FALSE)
[17:48:01.718]                 }
[17:48:01.718]             }
[17:48:01.718]         }
[17:48:01.718]     })
[17:48:01.718]     if (TRUE) {
[17:48:01.718]         base::sink(type = "output", split = FALSE)
[17:48:01.718]         if (TRUE) {
[17:48:01.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:01.718]         }
[17:48:01.718]         else {
[17:48:01.718]             ...future.result["stdout"] <- base::list(NULL)
[17:48:01.718]         }
[17:48:01.718]         base::close(...future.stdout)
[17:48:01.718]         ...future.stdout <- NULL
[17:48:01.718]     }
[17:48:01.718]     ...future.result$conditions <- ...future.conditions
[17:48:01.718]     ...future.result$finished <- base::Sys.time()
[17:48:01.718]     ...future.result
[17:48:01.718] }
[17:48:01.721] MultisessionFuture started
[17:48:01.721] - Launch lazy future ... done
[17:48:01.721] run() for ‘MultisessionFuture’ ... done
[17:48:02.224] receiveMessageFromWorker() for ClusterFuture ...
[17:48:02.224] - Validating connection of MultisessionFuture
[17:48:02.224] - received message: FutureResult
[17:48:02.224] - Received FutureResult
[17:48:02.225] - Erased future from FutureRegistry
[17:48:02.225] result() for ClusterFuture ...
[17:48:02.225] - result already collected: FutureResult
[17:48:02.225] result() for ClusterFuture ... done
[17:48:02.225] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:02.225] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:48:02.225] getGlobalsAndPackages() ...
[17:48:02.225] Searching for globals...
[17:48:02.226] - globals found: [2] ‘list’, ‘stop’
[17:48:02.226] Searching for globals ... DONE
[17:48:02.226] Resolving globals: FALSE
[17:48:02.227] 
[17:48:02.227] 
[17:48:02.227] getGlobalsAndPackages() ... DONE
[17:48:02.227] run() for ‘Future’ ...
[17:48:02.227] - state: ‘created’
[17:48:02.227] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:02.241] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:02.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:02.241]   - Field: ‘node’
[17:48:02.241]   - Field: ‘label’
[17:48:02.241]   - Field: ‘local’
[17:48:02.241]   - Field: ‘owner’
[17:48:02.242]   - Field: ‘envir’
[17:48:02.242]   - Field: ‘workers’
[17:48:02.242]   - Field: ‘packages’
[17:48:02.242]   - Field: ‘gc’
[17:48:02.242]   - Field: ‘conditions’
[17:48:02.242]   - Field: ‘persistent’
[17:48:02.242]   - Field: ‘expr’
[17:48:02.242]   - Field: ‘uuid’
[17:48:02.242]   - Field: ‘seed’
[17:48:02.242]   - Field: ‘version’
[17:48:02.242]   - Field: ‘result’
[17:48:02.243]   - Field: ‘asynchronous’
[17:48:02.243]   - Field: ‘calls’
[17:48:02.243]   - Field: ‘globals’
[17:48:02.243]   - Field: ‘stdout’
[17:48:02.243]   - Field: ‘earlySignal’
[17:48:02.243]   - Field: ‘lazy’
[17:48:02.243]   - Field: ‘state’
[17:48:02.243] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:02.243] - Launch lazy future ...
[17:48:02.244] Packages needed by the future expression (n = 0): <none>
[17:48:02.244] Packages needed by future strategies (n = 0): <none>
[17:48:02.244] {
[17:48:02.244]     {
[17:48:02.244]         {
[17:48:02.244]             ...future.startTime <- base::Sys.time()
[17:48:02.244]             {
[17:48:02.244]                 {
[17:48:02.244]                   {
[17:48:02.244]                     {
[17:48:02.244]                       base::local({
[17:48:02.244]                         has_future <- base::requireNamespace("future", 
[17:48:02.244]                           quietly = TRUE)
[17:48:02.244]                         if (has_future) {
[17:48:02.244]                           ns <- base::getNamespace("future")
[17:48:02.244]                           version <- ns[[".package"]][["version"]]
[17:48:02.244]                           if (is.null(version)) 
[17:48:02.244]                             version <- utils::packageVersion("future")
[17:48:02.244]                         }
[17:48:02.244]                         else {
[17:48:02.244]                           version <- NULL
[17:48:02.244]                         }
[17:48:02.244]                         if (!has_future || version < "1.8.0") {
[17:48:02.244]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:02.244]                             "", base::R.version$version.string), 
[17:48:02.244]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:02.244]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:02.244]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:02.244]                               "release", "version")], collapse = " "), 
[17:48:02.244]                             hostname = base::Sys.info()[["nodename"]])
[17:48:02.244]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:02.244]                             info)
[17:48:02.244]                           info <- base::paste(info, collapse = "; ")
[17:48:02.244]                           if (!has_future) {
[17:48:02.244]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:02.244]                               info)
[17:48:02.244]                           }
[17:48:02.244]                           else {
[17:48:02.244]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:02.244]                               info, version)
[17:48:02.244]                           }
[17:48:02.244]                           base::stop(msg)
[17:48:02.244]                         }
[17:48:02.244]                       })
[17:48:02.244]                     }
[17:48:02.244]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:02.244]                     base::options(mc.cores = 1L)
[17:48:02.244]                   }
[17:48:02.244]                   ...future.strategy.old <- future::plan("list")
[17:48:02.244]                   options(future.plan = NULL)
[17:48:02.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:02.244]                 }
[17:48:02.244]                 ...future.workdir <- getwd()
[17:48:02.244]             }
[17:48:02.244]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:02.244]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:02.244]         }
[17:48:02.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:02.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:02.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:02.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:02.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:02.244]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:02.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:02.244]             base::names(...future.oldOptions))
[17:48:02.244]     }
[17:48:02.244]     if (FALSE) {
[17:48:02.244]     }
[17:48:02.244]     else {
[17:48:02.244]         if (TRUE) {
[17:48:02.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:02.244]                 open = "w")
[17:48:02.244]         }
[17:48:02.244]         else {
[17:48:02.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:02.244]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:02.244]         }
[17:48:02.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:02.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:02.244]             base::sink(type = "output", split = FALSE)
[17:48:02.244]             base::close(...future.stdout)
[17:48:02.244]         }, add = TRUE)
[17:48:02.244]     }
[17:48:02.244]     ...future.frame <- base::sys.nframe()
[17:48:02.244]     ...future.conditions <- base::list()
[17:48:02.244]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:02.244]     if (FALSE) {
[17:48:02.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:02.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:02.244]     }
[17:48:02.244]     ...future.result <- base::tryCatch({
[17:48:02.244]         base::withCallingHandlers({
[17:48:02.244]             ...future.value <- base::withVisible(base::local({
[17:48:02.244]                 ...future.makeSendCondition <- base::local({
[17:48:02.244]                   sendCondition <- NULL
[17:48:02.244]                   function(frame = 1L) {
[17:48:02.244]                     if (is.function(sendCondition)) 
[17:48:02.244]                       return(sendCondition)
[17:48:02.244]                     ns <- getNamespace("parallel")
[17:48:02.244]                     if (exists("sendData", mode = "function", 
[17:48:02.244]                       envir = ns)) {
[17:48:02.244]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:02.244]                         envir = ns)
[17:48:02.244]                       envir <- sys.frame(frame)
[17:48:02.244]                       master <- NULL
[17:48:02.244]                       while (!identical(envir, .GlobalEnv) && 
[17:48:02.244]                         !identical(envir, emptyenv())) {
[17:48:02.244]                         if (exists("master", mode = "list", envir = envir, 
[17:48:02.244]                           inherits = FALSE)) {
[17:48:02.244]                           master <- get("master", mode = "list", 
[17:48:02.244]                             envir = envir, inherits = FALSE)
[17:48:02.244]                           if (inherits(master, c("SOCKnode", 
[17:48:02.244]                             "SOCK0node"))) {
[17:48:02.244]                             sendCondition <<- function(cond) {
[17:48:02.244]                               data <- list(type = "VALUE", value = cond, 
[17:48:02.244]                                 success = TRUE)
[17:48:02.244]                               parallel_sendData(master, data)
[17:48:02.244]                             }
[17:48:02.244]                             return(sendCondition)
[17:48:02.244]                           }
[17:48:02.244]                         }
[17:48:02.244]                         frame <- frame + 1L
[17:48:02.244]                         envir <- sys.frame(frame)
[17:48:02.244]                       }
[17:48:02.244]                     }
[17:48:02.244]                     sendCondition <<- function(cond) NULL
[17:48:02.244]                   }
[17:48:02.244]                 })
[17:48:02.244]                 withCallingHandlers({
[17:48:02.244]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:02.244]                 }, immediateCondition = function(cond) {
[17:48:02.244]                   sendCondition <- ...future.makeSendCondition()
[17:48:02.244]                   sendCondition(cond)
[17:48:02.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.244]                   {
[17:48:02.244]                     inherits <- base::inherits
[17:48:02.244]                     invokeRestart <- base::invokeRestart
[17:48:02.244]                     is.null <- base::is.null
[17:48:02.244]                     muffled <- FALSE
[17:48:02.244]                     if (inherits(cond, "message")) {
[17:48:02.244]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:02.244]                       if (muffled) 
[17:48:02.244]                         invokeRestart("muffleMessage")
[17:48:02.244]                     }
[17:48:02.244]                     else if (inherits(cond, "warning")) {
[17:48:02.244]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:02.244]                       if (muffled) 
[17:48:02.244]                         invokeRestart("muffleWarning")
[17:48:02.244]                     }
[17:48:02.244]                     else if (inherits(cond, "condition")) {
[17:48:02.244]                       if (!is.null(pattern)) {
[17:48:02.244]                         computeRestarts <- base::computeRestarts
[17:48:02.244]                         grepl <- base::grepl
[17:48:02.244]                         restarts <- computeRestarts(cond)
[17:48:02.244]                         for (restart in restarts) {
[17:48:02.244]                           name <- restart$name
[17:48:02.244]                           if (is.null(name)) 
[17:48:02.244]                             next
[17:48:02.244]                           if (!grepl(pattern, name)) 
[17:48:02.244]                             next
[17:48:02.244]                           invokeRestart(restart)
[17:48:02.244]                           muffled <- TRUE
[17:48:02.244]                           break
[17:48:02.244]                         }
[17:48:02.244]                       }
[17:48:02.244]                     }
[17:48:02.244]                     invisible(muffled)
[17:48:02.244]                   }
[17:48:02.244]                   muffleCondition(cond)
[17:48:02.244]                 })
[17:48:02.244]             }))
[17:48:02.244]             future::FutureResult(value = ...future.value$value, 
[17:48:02.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.244]                   ...future.rng), globalenv = if (FALSE) 
[17:48:02.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:02.244]                     ...future.globalenv.names))
[17:48:02.244]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:02.244]         }, condition = base::local({
[17:48:02.244]             c <- base::c
[17:48:02.244]             inherits <- base::inherits
[17:48:02.244]             invokeRestart <- base::invokeRestart
[17:48:02.244]             length <- base::length
[17:48:02.244]             list <- base::list
[17:48:02.244]             seq.int <- base::seq.int
[17:48:02.244]             signalCondition <- base::signalCondition
[17:48:02.244]             sys.calls <- base::sys.calls
[17:48:02.244]             `[[` <- base::`[[`
[17:48:02.244]             `+` <- base::`+`
[17:48:02.244]             `<<-` <- base::`<<-`
[17:48:02.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:02.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:02.244]                   3L)]
[17:48:02.244]             }
[17:48:02.244]             function(cond) {
[17:48:02.244]                 is_error <- inherits(cond, "error")
[17:48:02.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:02.244]                   NULL)
[17:48:02.244]                 if (is_error) {
[17:48:02.244]                   sessionInformation <- function() {
[17:48:02.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:02.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:02.244]                       search = base::search(), system = base::Sys.info())
[17:48:02.244]                   }
[17:48:02.244]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:02.244]                     cond$call), session = sessionInformation(), 
[17:48:02.244]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:02.244]                   signalCondition(cond)
[17:48:02.244]                 }
[17:48:02.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:02.244]                 "immediateCondition"))) {
[17:48:02.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:02.244]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:02.244]                   if (TRUE && !signal) {
[17:48:02.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.244]                     {
[17:48:02.244]                       inherits <- base::inherits
[17:48:02.244]                       invokeRestart <- base::invokeRestart
[17:48:02.244]                       is.null <- base::is.null
[17:48:02.244]                       muffled <- FALSE
[17:48:02.244]                       if (inherits(cond, "message")) {
[17:48:02.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.244]                         if (muffled) 
[17:48:02.244]                           invokeRestart("muffleMessage")
[17:48:02.244]                       }
[17:48:02.244]                       else if (inherits(cond, "warning")) {
[17:48:02.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.244]                         if (muffled) 
[17:48:02.244]                           invokeRestart("muffleWarning")
[17:48:02.244]                       }
[17:48:02.244]                       else if (inherits(cond, "condition")) {
[17:48:02.244]                         if (!is.null(pattern)) {
[17:48:02.244]                           computeRestarts <- base::computeRestarts
[17:48:02.244]                           grepl <- base::grepl
[17:48:02.244]                           restarts <- computeRestarts(cond)
[17:48:02.244]                           for (restart in restarts) {
[17:48:02.244]                             name <- restart$name
[17:48:02.244]                             if (is.null(name)) 
[17:48:02.244]                               next
[17:48:02.244]                             if (!grepl(pattern, name)) 
[17:48:02.244]                               next
[17:48:02.244]                             invokeRestart(restart)
[17:48:02.244]                             muffled <- TRUE
[17:48:02.244]                             break
[17:48:02.244]                           }
[17:48:02.244]                         }
[17:48:02.244]                       }
[17:48:02.244]                       invisible(muffled)
[17:48:02.244]                     }
[17:48:02.244]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.244]                   }
[17:48:02.244]                 }
[17:48:02.244]                 else {
[17:48:02.244]                   if (TRUE) {
[17:48:02.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.244]                     {
[17:48:02.244]                       inherits <- base::inherits
[17:48:02.244]                       invokeRestart <- base::invokeRestart
[17:48:02.244]                       is.null <- base::is.null
[17:48:02.244]                       muffled <- FALSE
[17:48:02.244]                       if (inherits(cond, "message")) {
[17:48:02.244]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.244]                         if (muffled) 
[17:48:02.244]                           invokeRestart("muffleMessage")
[17:48:02.244]                       }
[17:48:02.244]                       else if (inherits(cond, "warning")) {
[17:48:02.244]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.244]                         if (muffled) 
[17:48:02.244]                           invokeRestart("muffleWarning")
[17:48:02.244]                       }
[17:48:02.244]                       else if (inherits(cond, "condition")) {
[17:48:02.244]                         if (!is.null(pattern)) {
[17:48:02.244]                           computeRestarts <- base::computeRestarts
[17:48:02.244]                           grepl <- base::grepl
[17:48:02.244]                           restarts <- computeRestarts(cond)
[17:48:02.244]                           for (restart in restarts) {
[17:48:02.244]                             name <- restart$name
[17:48:02.244]                             if (is.null(name)) 
[17:48:02.244]                               next
[17:48:02.244]                             if (!grepl(pattern, name)) 
[17:48:02.244]                               next
[17:48:02.244]                             invokeRestart(restart)
[17:48:02.244]                             muffled <- TRUE
[17:48:02.244]                             break
[17:48:02.244]                           }
[17:48:02.244]                         }
[17:48:02.244]                       }
[17:48:02.244]                       invisible(muffled)
[17:48:02.244]                     }
[17:48:02.244]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.244]                   }
[17:48:02.244]                 }
[17:48:02.244]             }
[17:48:02.244]         }))
[17:48:02.244]     }, error = function(ex) {
[17:48:02.244]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:02.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.244]                 ...future.rng), started = ...future.startTime, 
[17:48:02.244]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:02.244]             version = "1.8"), class = "FutureResult")
[17:48:02.244]     }, finally = {
[17:48:02.244]         if (!identical(...future.workdir, getwd())) 
[17:48:02.244]             setwd(...future.workdir)
[17:48:02.244]         {
[17:48:02.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:02.244]                 ...future.oldOptions$nwarnings <- NULL
[17:48:02.244]             }
[17:48:02.244]             base::options(...future.oldOptions)
[17:48:02.244]             if (.Platform$OS.type == "windows") {
[17:48:02.244]                 old_names <- names(...future.oldEnvVars)
[17:48:02.244]                 envs <- base::Sys.getenv()
[17:48:02.244]                 names <- names(envs)
[17:48:02.244]                 common <- intersect(names, old_names)
[17:48:02.244]                 added <- setdiff(names, old_names)
[17:48:02.244]                 removed <- setdiff(old_names, names)
[17:48:02.244]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:02.244]                   envs[common]]
[17:48:02.244]                 NAMES <- toupper(changed)
[17:48:02.244]                 args <- list()
[17:48:02.244]                 for (kk in seq_along(NAMES)) {
[17:48:02.244]                   name <- changed[[kk]]
[17:48:02.244]                   NAME <- NAMES[[kk]]
[17:48:02.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.244]                     next
[17:48:02.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.244]                 }
[17:48:02.244]                 NAMES <- toupper(added)
[17:48:02.244]                 for (kk in seq_along(NAMES)) {
[17:48:02.244]                   name <- added[[kk]]
[17:48:02.244]                   NAME <- NAMES[[kk]]
[17:48:02.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.244]                     next
[17:48:02.244]                   args[[name]] <- ""
[17:48:02.244]                 }
[17:48:02.244]                 NAMES <- toupper(removed)
[17:48:02.244]                 for (kk in seq_along(NAMES)) {
[17:48:02.244]                   name <- removed[[kk]]
[17:48:02.244]                   NAME <- NAMES[[kk]]
[17:48:02.244]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.244]                     next
[17:48:02.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.244]                 }
[17:48:02.244]                 if (length(args) > 0) 
[17:48:02.244]                   base::do.call(base::Sys.setenv, args = args)
[17:48:02.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:02.244]             }
[17:48:02.244]             else {
[17:48:02.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:02.244]             }
[17:48:02.244]             {
[17:48:02.244]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:02.244]                   0L) {
[17:48:02.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:02.244]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:02.244]                   base::options(opts)
[17:48:02.244]                 }
[17:48:02.244]                 {
[17:48:02.244]                   {
[17:48:02.244]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:02.244]                     NULL
[17:48:02.244]                   }
[17:48:02.244]                   options(future.plan = NULL)
[17:48:02.244]                   if (is.na(NA_character_)) 
[17:48:02.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:02.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:02.244]                     .init = FALSE)
[17:48:02.244]                 }
[17:48:02.244]             }
[17:48:02.244]         }
[17:48:02.244]     })
[17:48:02.244]     if (TRUE) {
[17:48:02.244]         base::sink(type = "output", split = FALSE)
[17:48:02.244]         if (TRUE) {
[17:48:02.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:02.244]         }
[17:48:02.244]         else {
[17:48:02.244]             ...future.result["stdout"] <- base::list(NULL)
[17:48:02.244]         }
[17:48:02.244]         base::close(...future.stdout)
[17:48:02.244]         ...future.stdout <- NULL
[17:48:02.244]     }
[17:48:02.244]     ...future.result$conditions <- ...future.conditions
[17:48:02.244]     ...future.result$finished <- base::Sys.time()
[17:48:02.244]     ...future.result
[17:48:02.244] }
[17:48:02.247] MultisessionFuture started
[17:48:02.247] - Launch lazy future ... done
[17:48:02.247] run() for ‘MultisessionFuture’ ... done
[17:48:02.249] receiveMessageFromWorker() for ClusterFuture ...
[17:48:02.249] - Validating connection of MultisessionFuture
[17:48:02.250] - received message: FutureResult
[17:48:02.250] - Received FutureResult
[17:48:02.250] - Erased future from FutureRegistry
[17:48:02.250] result() for ClusterFuture ...
[17:48:02.250] - result already collected: FutureResult
[17:48:02.250] result() for ClusterFuture ... done
[17:48:02.250] signalConditions() ...
[17:48:02.250]  - include = ‘immediateCondition’
[17:48:02.251]  - exclude = 
[17:48:02.251]  - resignal = FALSE
[17:48:02.251]  - Number of conditions: 1
[17:48:02.251] signalConditions() ... done
[17:48:02.251] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:02.251] A MultisessionFuture was resolved (result was not collected)
[17:48:02.251] getGlobalsAndPackages() ...
[17:48:02.251] Searching for globals...
[17:48:02.252] - globals found: [2] ‘list’, ‘stop’
[17:48:02.252] Searching for globals ... DONE
[17:48:02.252] Resolving globals: FALSE
[17:48:02.252] 
[17:48:02.252] 
[17:48:02.252] getGlobalsAndPackages() ... DONE
[17:48:02.253] run() for ‘Future’ ...
[17:48:02.253] - state: ‘created’
[17:48:02.253] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:02.266] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:02.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:02.267]   - Field: ‘node’
[17:48:02.267]   - Field: ‘label’
[17:48:02.267]   - Field: ‘local’
[17:48:02.267]   - Field: ‘owner’
[17:48:02.267]   - Field: ‘envir’
[17:48:02.267]   - Field: ‘workers’
[17:48:02.267]   - Field: ‘packages’
[17:48:02.267]   - Field: ‘gc’
[17:48:02.267]   - Field: ‘conditions’
[17:48:02.267]   - Field: ‘persistent’
[17:48:02.268]   - Field: ‘expr’
[17:48:02.268]   - Field: ‘uuid’
[17:48:02.268]   - Field: ‘seed’
[17:48:02.268]   - Field: ‘version’
[17:48:02.268]   - Field: ‘result’
[17:48:02.268]   - Field: ‘asynchronous’
[17:48:02.268]   - Field: ‘calls’
[17:48:02.268]   - Field: ‘globals’
[17:48:02.268]   - Field: ‘stdout’
[17:48:02.268]   - Field: ‘earlySignal’
[17:48:02.268]   - Field: ‘lazy’
[17:48:02.269]   - Field: ‘state’
[17:48:02.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:02.269] - Launch lazy future ...
[17:48:02.269] Packages needed by the future expression (n = 0): <none>
[17:48:02.269] Packages needed by future strategies (n = 0): <none>
[17:48:02.270] {
[17:48:02.270]     {
[17:48:02.270]         {
[17:48:02.270]             ...future.startTime <- base::Sys.time()
[17:48:02.270]             {
[17:48:02.270]                 {
[17:48:02.270]                   {
[17:48:02.270]                     {
[17:48:02.270]                       base::local({
[17:48:02.270]                         has_future <- base::requireNamespace("future", 
[17:48:02.270]                           quietly = TRUE)
[17:48:02.270]                         if (has_future) {
[17:48:02.270]                           ns <- base::getNamespace("future")
[17:48:02.270]                           version <- ns[[".package"]][["version"]]
[17:48:02.270]                           if (is.null(version)) 
[17:48:02.270]                             version <- utils::packageVersion("future")
[17:48:02.270]                         }
[17:48:02.270]                         else {
[17:48:02.270]                           version <- NULL
[17:48:02.270]                         }
[17:48:02.270]                         if (!has_future || version < "1.8.0") {
[17:48:02.270]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:02.270]                             "", base::R.version$version.string), 
[17:48:02.270]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:02.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:02.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:02.270]                               "release", "version")], collapse = " "), 
[17:48:02.270]                             hostname = base::Sys.info()[["nodename"]])
[17:48:02.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:02.270]                             info)
[17:48:02.270]                           info <- base::paste(info, collapse = "; ")
[17:48:02.270]                           if (!has_future) {
[17:48:02.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:02.270]                               info)
[17:48:02.270]                           }
[17:48:02.270]                           else {
[17:48:02.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:02.270]                               info, version)
[17:48:02.270]                           }
[17:48:02.270]                           base::stop(msg)
[17:48:02.270]                         }
[17:48:02.270]                       })
[17:48:02.270]                     }
[17:48:02.270]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:02.270]                     base::options(mc.cores = 1L)
[17:48:02.270]                   }
[17:48:02.270]                   ...future.strategy.old <- future::plan("list")
[17:48:02.270]                   options(future.plan = NULL)
[17:48:02.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:02.270]                 }
[17:48:02.270]                 ...future.workdir <- getwd()
[17:48:02.270]             }
[17:48:02.270]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:02.270]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:02.270]         }
[17:48:02.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:02.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:02.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:02.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:02.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:02.270]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:02.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:02.270]             base::names(...future.oldOptions))
[17:48:02.270]     }
[17:48:02.270]     if (FALSE) {
[17:48:02.270]     }
[17:48:02.270]     else {
[17:48:02.270]         if (TRUE) {
[17:48:02.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:02.270]                 open = "w")
[17:48:02.270]         }
[17:48:02.270]         else {
[17:48:02.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:02.270]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:02.270]         }
[17:48:02.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:02.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:02.270]             base::sink(type = "output", split = FALSE)
[17:48:02.270]             base::close(...future.stdout)
[17:48:02.270]         }, add = TRUE)
[17:48:02.270]     }
[17:48:02.270]     ...future.frame <- base::sys.nframe()
[17:48:02.270]     ...future.conditions <- base::list()
[17:48:02.270]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:02.270]     if (FALSE) {
[17:48:02.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:02.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:02.270]     }
[17:48:02.270]     ...future.result <- base::tryCatch({
[17:48:02.270]         base::withCallingHandlers({
[17:48:02.270]             ...future.value <- base::withVisible(base::local({
[17:48:02.270]                 ...future.makeSendCondition <- base::local({
[17:48:02.270]                   sendCondition <- NULL
[17:48:02.270]                   function(frame = 1L) {
[17:48:02.270]                     if (is.function(sendCondition)) 
[17:48:02.270]                       return(sendCondition)
[17:48:02.270]                     ns <- getNamespace("parallel")
[17:48:02.270]                     if (exists("sendData", mode = "function", 
[17:48:02.270]                       envir = ns)) {
[17:48:02.270]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:02.270]                         envir = ns)
[17:48:02.270]                       envir <- sys.frame(frame)
[17:48:02.270]                       master <- NULL
[17:48:02.270]                       while (!identical(envir, .GlobalEnv) && 
[17:48:02.270]                         !identical(envir, emptyenv())) {
[17:48:02.270]                         if (exists("master", mode = "list", envir = envir, 
[17:48:02.270]                           inherits = FALSE)) {
[17:48:02.270]                           master <- get("master", mode = "list", 
[17:48:02.270]                             envir = envir, inherits = FALSE)
[17:48:02.270]                           if (inherits(master, c("SOCKnode", 
[17:48:02.270]                             "SOCK0node"))) {
[17:48:02.270]                             sendCondition <<- function(cond) {
[17:48:02.270]                               data <- list(type = "VALUE", value = cond, 
[17:48:02.270]                                 success = TRUE)
[17:48:02.270]                               parallel_sendData(master, data)
[17:48:02.270]                             }
[17:48:02.270]                             return(sendCondition)
[17:48:02.270]                           }
[17:48:02.270]                         }
[17:48:02.270]                         frame <- frame + 1L
[17:48:02.270]                         envir <- sys.frame(frame)
[17:48:02.270]                       }
[17:48:02.270]                     }
[17:48:02.270]                     sendCondition <<- function(cond) NULL
[17:48:02.270]                   }
[17:48:02.270]                 })
[17:48:02.270]                 withCallingHandlers({
[17:48:02.270]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:02.270]                 }, immediateCondition = function(cond) {
[17:48:02.270]                   sendCondition <- ...future.makeSendCondition()
[17:48:02.270]                   sendCondition(cond)
[17:48:02.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.270]                   {
[17:48:02.270]                     inherits <- base::inherits
[17:48:02.270]                     invokeRestart <- base::invokeRestart
[17:48:02.270]                     is.null <- base::is.null
[17:48:02.270]                     muffled <- FALSE
[17:48:02.270]                     if (inherits(cond, "message")) {
[17:48:02.270]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:02.270]                       if (muffled) 
[17:48:02.270]                         invokeRestart("muffleMessage")
[17:48:02.270]                     }
[17:48:02.270]                     else if (inherits(cond, "warning")) {
[17:48:02.270]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:02.270]                       if (muffled) 
[17:48:02.270]                         invokeRestart("muffleWarning")
[17:48:02.270]                     }
[17:48:02.270]                     else if (inherits(cond, "condition")) {
[17:48:02.270]                       if (!is.null(pattern)) {
[17:48:02.270]                         computeRestarts <- base::computeRestarts
[17:48:02.270]                         grepl <- base::grepl
[17:48:02.270]                         restarts <- computeRestarts(cond)
[17:48:02.270]                         for (restart in restarts) {
[17:48:02.270]                           name <- restart$name
[17:48:02.270]                           if (is.null(name)) 
[17:48:02.270]                             next
[17:48:02.270]                           if (!grepl(pattern, name)) 
[17:48:02.270]                             next
[17:48:02.270]                           invokeRestart(restart)
[17:48:02.270]                           muffled <- TRUE
[17:48:02.270]                           break
[17:48:02.270]                         }
[17:48:02.270]                       }
[17:48:02.270]                     }
[17:48:02.270]                     invisible(muffled)
[17:48:02.270]                   }
[17:48:02.270]                   muffleCondition(cond)
[17:48:02.270]                 })
[17:48:02.270]             }))
[17:48:02.270]             future::FutureResult(value = ...future.value$value, 
[17:48:02.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.270]                   ...future.rng), globalenv = if (FALSE) 
[17:48:02.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:02.270]                     ...future.globalenv.names))
[17:48:02.270]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:02.270]         }, condition = base::local({
[17:48:02.270]             c <- base::c
[17:48:02.270]             inherits <- base::inherits
[17:48:02.270]             invokeRestart <- base::invokeRestart
[17:48:02.270]             length <- base::length
[17:48:02.270]             list <- base::list
[17:48:02.270]             seq.int <- base::seq.int
[17:48:02.270]             signalCondition <- base::signalCondition
[17:48:02.270]             sys.calls <- base::sys.calls
[17:48:02.270]             `[[` <- base::`[[`
[17:48:02.270]             `+` <- base::`+`
[17:48:02.270]             `<<-` <- base::`<<-`
[17:48:02.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:02.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:02.270]                   3L)]
[17:48:02.270]             }
[17:48:02.270]             function(cond) {
[17:48:02.270]                 is_error <- inherits(cond, "error")
[17:48:02.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:02.270]                   NULL)
[17:48:02.270]                 if (is_error) {
[17:48:02.270]                   sessionInformation <- function() {
[17:48:02.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:02.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:02.270]                       search = base::search(), system = base::Sys.info())
[17:48:02.270]                   }
[17:48:02.270]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:02.270]                     cond$call), session = sessionInformation(), 
[17:48:02.270]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:02.270]                   signalCondition(cond)
[17:48:02.270]                 }
[17:48:02.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:02.270]                 "immediateCondition"))) {
[17:48:02.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:02.270]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:02.270]                   if (TRUE && !signal) {
[17:48:02.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.270]                     {
[17:48:02.270]                       inherits <- base::inherits
[17:48:02.270]                       invokeRestart <- base::invokeRestart
[17:48:02.270]                       is.null <- base::is.null
[17:48:02.270]                       muffled <- FALSE
[17:48:02.270]                       if (inherits(cond, "message")) {
[17:48:02.270]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.270]                         if (muffled) 
[17:48:02.270]                           invokeRestart("muffleMessage")
[17:48:02.270]                       }
[17:48:02.270]                       else if (inherits(cond, "warning")) {
[17:48:02.270]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.270]                         if (muffled) 
[17:48:02.270]                           invokeRestart("muffleWarning")
[17:48:02.270]                       }
[17:48:02.270]                       else if (inherits(cond, "condition")) {
[17:48:02.270]                         if (!is.null(pattern)) {
[17:48:02.270]                           computeRestarts <- base::computeRestarts
[17:48:02.270]                           grepl <- base::grepl
[17:48:02.270]                           restarts <- computeRestarts(cond)
[17:48:02.270]                           for (restart in restarts) {
[17:48:02.270]                             name <- restart$name
[17:48:02.270]                             if (is.null(name)) 
[17:48:02.270]                               next
[17:48:02.270]                             if (!grepl(pattern, name)) 
[17:48:02.270]                               next
[17:48:02.270]                             invokeRestart(restart)
[17:48:02.270]                             muffled <- TRUE
[17:48:02.270]                             break
[17:48:02.270]                           }
[17:48:02.270]                         }
[17:48:02.270]                       }
[17:48:02.270]                       invisible(muffled)
[17:48:02.270]                     }
[17:48:02.270]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.270]                   }
[17:48:02.270]                 }
[17:48:02.270]                 else {
[17:48:02.270]                   if (TRUE) {
[17:48:02.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.270]                     {
[17:48:02.270]                       inherits <- base::inherits
[17:48:02.270]                       invokeRestart <- base::invokeRestart
[17:48:02.270]                       is.null <- base::is.null
[17:48:02.270]                       muffled <- FALSE
[17:48:02.270]                       if (inherits(cond, "message")) {
[17:48:02.270]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.270]                         if (muffled) 
[17:48:02.270]                           invokeRestart("muffleMessage")
[17:48:02.270]                       }
[17:48:02.270]                       else if (inherits(cond, "warning")) {
[17:48:02.270]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.270]                         if (muffled) 
[17:48:02.270]                           invokeRestart("muffleWarning")
[17:48:02.270]                       }
[17:48:02.270]                       else if (inherits(cond, "condition")) {
[17:48:02.270]                         if (!is.null(pattern)) {
[17:48:02.270]                           computeRestarts <- base::computeRestarts
[17:48:02.270]                           grepl <- base::grepl
[17:48:02.270]                           restarts <- computeRestarts(cond)
[17:48:02.270]                           for (restart in restarts) {
[17:48:02.270]                             name <- restart$name
[17:48:02.270]                             if (is.null(name)) 
[17:48:02.270]                               next
[17:48:02.270]                             if (!grepl(pattern, name)) 
[17:48:02.270]                               next
[17:48:02.270]                             invokeRestart(restart)
[17:48:02.270]                             muffled <- TRUE
[17:48:02.270]                             break
[17:48:02.270]                           }
[17:48:02.270]                         }
[17:48:02.270]                       }
[17:48:02.270]                       invisible(muffled)
[17:48:02.270]                     }
[17:48:02.270]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.270]                   }
[17:48:02.270]                 }
[17:48:02.270]             }
[17:48:02.270]         }))
[17:48:02.270]     }, error = function(ex) {
[17:48:02.270]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:02.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.270]                 ...future.rng), started = ...future.startTime, 
[17:48:02.270]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:02.270]             version = "1.8"), class = "FutureResult")
[17:48:02.270]     }, finally = {
[17:48:02.270]         if (!identical(...future.workdir, getwd())) 
[17:48:02.270]             setwd(...future.workdir)
[17:48:02.270]         {
[17:48:02.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:02.270]                 ...future.oldOptions$nwarnings <- NULL
[17:48:02.270]             }
[17:48:02.270]             base::options(...future.oldOptions)
[17:48:02.270]             if (.Platform$OS.type == "windows") {
[17:48:02.270]                 old_names <- names(...future.oldEnvVars)
[17:48:02.270]                 envs <- base::Sys.getenv()
[17:48:02.270]                 names <- names(envs)
[17:48:02.270]                 common <- intersect(names, old_names)
[17:48:02.270]                 added <- setdiff(names, old_names)
[17:48:02.270]                 removed <- setdiff(old_names, names)
[17:48:02.270]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:02.270]                   envs[common]]
[17:48:02.270]                 NAMES <- toupper(changed)
[17:48:02.270]                 args <- list()
[17:48:02.270]                 for (kk in seq_along(NAMES)) {
[17:48:02.270]                   name <- changed[[kk]]
[17:48:02.270]                   NAME <- NAMES[[kk]]
[17:48:02.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.270]                     next
[17:48:02.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.270]                 }
[17:48:02.270]                 NAMES <- toupper(added)
[17:48:02.270]                 for (kk in seq_along(NAMES)) {
[17:48:02.270]                   name <- added[[kk]]
[17:48:02.270]                   NAME <- NAMES[[kk]]
[17:48:02.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.270]                     next
[17:48:02.270]                   args[[name]] <- ""
[17:48:02.270]                 }
[17:48:02.270]                 NAMES <- toupper(removed)
[17:48:02.270]                 for (kk in seq_along(NAMES)) {
[17:48:02.270]                   name <- removed[[kk]]
[17:48:02.270]                   NAME <- NAMES[[kk]]
[17:48:02.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.270]                     next
[17:48:02.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.270]                 }
[17:48:02.270]                 if (length(args) > 0) 
[17:48:02.270]                   base::do.call(base::Sys.setenv, args = args)
[17:48:02.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:02.270]             }
[17:48:02.270]             else {
[17:48:02.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:02.270]             }
[17:48:02.270]             {
[17:48:02.270]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:02.270]                   0L) {
[17:48:02.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:02.270]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:02.270]                   base::options(opts)
[17:48:02.270]                 }
[17:48:02.270]                 {
[17:48:02.270]                   {
[17:48:02.270]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:02.270]                     NULL
[17:48:02.270]                   }
[17:48:02.270]                   options(future.plan = NULL)
[17:48:02.270]                   if (is.na(NA_character_)) 
[17:48:02.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:02.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:02.270]                     .init = FALSE)
[17:48:02.270]                 }
[17:48:02.270]             }
[17:48:02.270]         }
[17:48:02.270]     })
[17:48:02.270]     if (TRUE) {
[17:48:02.270]         base::sink(type = "output", split = FALSE)
[17:48:02.270]         if (TRUE) {
[17:48:02.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:02.270]         }
[17:48:02.270]         else {
[17:48:02.270]             ...future.result["stdout"] <- base::list(NULL)
[17:48:02.270]         }
[17:48:02.270]         base::close(...future.stdout)
[17:48:02.270]         ...future.stdout <- NULL
[17:48:02.270]     }
[17:48:02.270]     ...future.result$conditions <- ...future.conditions
[17:48:02.270]     ...future.result$finished <- base::Sys.time()
[17:48:02.270]     ...future.result
[17:48:02.270] }
[17:48:02.272] MultisessionFuture started
[17:48:02.272] - Launch lazy future ... done
[17:48:02.273] run() for ‘MultisessionFuture’ ... done
[17:48:02.274] receiveMessageFromWorker() for ClusterFuture ...
[17:48:02.274] - Validating connection of MultisessionFuture
[17:48:02.275] - received message: FutureResult
[17:48:02.275] - Received FutureResult
[17:48:02.275] - Erased future from FutureRegistry
[17:48:02.275] result() for ClusterFuture ...
[17:48:02.275] - result already collected: FutureResult
[17:48:02.275] result() for ClusterFuture ... done
[17:48:02.275] signalConditions() ...
[17:48:02.276]  - include = ‘immediateCondition’
[17:48:02.276]  - exclude = 
[17:48:02.276]  - resignal = FALSE
[17:48:02.276]  - Number of conditions: 1
[17:48:02.276] signalConditions() ... done
[17:48:02.276] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:02.276] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[17:48:02.276] getGlobalsAndPackages() ...
[17:48:02.276] Searching for globals...
[17:48:02.278] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:02.278] Searching for globals ... DONE
[17:48:02.278] Resolving globals: FALSE
[17:48:02.278] 
[17:48:02.278] 
[17:48:02.278] getGlobalsAndPackages() ... DONE
[17:48:02.278] run() for ‘Future’ ...
[17:48:02.279] - state: ‘created’
[17:48:02.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:02.292] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:02.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:02.292]   - Field: ‘node’
[17:48:02.292]   - Field: ‘label’
[17:48:02.292]   - Field: ‘local’
[17:48:02.292]   - Field: ‘owner’
[17:48:02.293]   - Field: ‘envir’
[17:48:02.293]   - Field: ‘workers’
[17:48:02.293]   - Field: ‘packages’
[17:48:02.293]   - Field: ‘gc’
[17:48:02.293]   - Field: ‘conditions’
[17:48:02.293]   - Field: ‘persistent’
[17:48:02.293]   - Field: ‘expr’
[17:48:02.293]   - Field: ‘uuid’
[17:48:02.293]   - Field: ‘seed’
[17:48:02.293]   - Field: ‘version’
[17:48:02.293]   - Field: ‘result’
[17:48:02.294]   - Field: ‘asynchronous’
[17:48:02.294]   - Field: ‘calls’
[17:48:02.294]   - Field: ‘globals’
[17:48:02.294]   - Field: ‘stdout’
[17:48:02.294]   - Field: ‘earlySignal’
[17:48:02.294]   - Field: ‘lazy’
[17:48:02.294]   - Field: ‘state’
[17:48:02.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:02.294] - Launch lazy future ...
[17:48:02.294] Packages needed by the future expression (n = 0): <none>
[17:48:02.295] Packages needed by future strategies (n = 0): <none>
[17:48:02.295] {
[17:48:02.295]     {
[17:48:02.295]         {
[17:48:02.295]             ...future.startTime <- base::Sys.time()
[17:48:02.295]             {
[17:48:02.295]                 {
[17:48:02.295]                   {
[17:48:02.295]                     {
[17:48:02.295]                       base::local({
[17:48:02.295]                         has_future <- base::requireNamespace("future", 
[17:48:02.295]                           quietly = TRUE)
[17:48:02.295]                         if (has_future) {
[17:48:02.295]                           ns <- base::getNamespace("future")
[17:48:02.295]                           version <- ns[[".package"]][["version"]]
[17:48:02.295]                           if (is.null(version)) 
[17:48:02.295]                             version <- utils::packageVersion("future")
[17:48:02.295]                         }
[17:48:02.295]                         else {
[17:48:02.295]                           version <- NULL
[17:48:02.295]                         }
[17:48:02.295]                         if (!has_future || version < "1.8.0") {
[17:48:02.295]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:02.295]                             "", base::R.version$version.string), 
[17:48:02.295]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:02.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:02.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:02.295]                               "release", "version")], collapse = " "), 
[17:48:02.295]                             hostname = base::Sys.info()[["nodename"]])
[17:48:02.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:02.295]                             info)
[17:48:02.295]                           info <- base::paste(info, collapse = "; ")
[17:48:02.295]                           if (!has_future) {
[17:48:02.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:02.295]                               info)
[17:48:02.295]                           }
[17:48:02.295]                           else {
[17:48:02.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:02.295]                               info, version)
[17:48:02.295]                           }
[17:48:02.295]                           base::stop(msg)
[17:48:02.295]                         }
[17:48:02.295]                       })
[17:48:02.295]                     }
[17:48:02.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:02.295]                     base::options(mc.cores = 1L)
[17:48:02.295]                   }
[17:48:02.295]                   ...future.strategy.old <- future::plan("list")
[17:48:02.295]                   options(future.plan = NULL)
[17:48:02.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:02.295]                 }
[17:48:02.295]                 ...future.workdir <- getwd()
[17:48:02.295]             }
[17:48:02.295]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:02.295]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:02.295]         }
[17:48:02.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:02.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:02.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:02.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:02.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:02.295]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:02.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:02.295]             base::names(...future.oldOptions))
[17:48:02.295]     }
[17:48:02.295]     if (FALSE) {
[17:48:02.295]     }
[17:48:02.295]     else {
[17:48:02.295]         if (TRUE) {
[17:48:02.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:02.295]                 open = "w")
[17:48:02.295]         }
[17:48:02.295]         else {
[17:48:02.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:02.295]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:02.295]         }
[17:48:02.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:02.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:02.295]             base::sink(type = "output", split = FALSE)
[17:48:02.295]             base::close(...future.stdout)
[17:48:02.295]         }, add = TRUE)
[17:48:02.295]     }
[17:48:02.295]     ...future.frame <- base::sys.nframe()
[17:48:02.295]     ...future.conditions <- base::list()
[17:48:02.295]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:02.295]     if (FALSE) {
[17:48:02.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:02.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:02.295]     }
[17:48:02.295]     ...future.result <- base::tryCatch({
[17:48:02.295]         base::withCallingHandlers({
[17:48:02.295]             ...future.value <- base::withVisible(base::local({
[17:48:02.295]                 ...future.makeSendCondition <- base::local({
[17:48:02.295]                   sendCondition <- NULL
[17:48:02.295]                   function(frame = 1L) {
[17:48:02.295]                     if (is.function(sendCondition)) 
[17:48:02.295]                       return(sendCondition)
[17:48:02.295]                     ns <- getNamespace("parallel")
[17:48:02.295]                     if (exists("sendData", mode = "function", 
[17:48:02.295]                       envir = ns)) {
[17:48:02.295]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:02.295]                         envir = ns)
[17:48:02.295]                       envir <- sys.frame(frame)
[17:48:02.295]                       master <- NULL
[17:48:02.295]                       while (!identical(envir, .GlobalEnv) && 
[17:48:02.295]                         !identical(envir, emptyenv())) {
[17:48:02.295]                         if (exists("master", mode = "list", envir = envir, 
[17:48:02.295]                           inherits = FALSE)) {
[17:48:02.295]                           master <- get("master", mode = "list", 
[17:48:02.295]                             envir = envir, inherits = FALSE)
[17:48:02.295]                           if (inherits(master, c("SOCKnode", 
[17:48:02.295]                             "SOCK0node"))) {
[17:48:02.295]                             sendCondition <<- function(cond) {
[17:48:02.295]                               data <- list(type = "VALUE", value = cond, 
[17:48:02.295]                                 success = TRUE)
[17:48:02.295]                               parallel_sendData(master, data)
[17:48:02.295]                             }
[17:48:02.295]                             return(sendCondition)
[17:48:02.295]                           }
[17:48:02.295]                         }
[17:48:02.295]                         frame <- frame + 1L
[17:48:02.295]                         envir <- sys.frame(frame)
[17:48:02.295]                       }
[17:48:02.295]                     }
[17:48:02.295]                     sendCondition <<- function(cond) NULL
[17:48:02.295]                   }
[17:48:02.295]                 })
[17:48:02.295]                 withCallingHandlers({
[17:48:02.295]                   {
[17:48:02.295]                     Sys.sleep(0.5)
[17:48:02.295]                     list(a = 1, b = 42L)
[17:48:02.295]                   }
[17:48:02.295]                 }, immediateCondition = function(cond) {
[17:48:02.295]                   sendCondition <- ...future.makeSendCondition()
[17:48:02.295]                   sendCondition(cond)
[17:48:02.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.295]                   {
[17:48:02.295]                     inherits <- base::inherits
[17:48:02.295]                     invokeRestart <- base::invokeRestart
[17:48:02.295]                     is.null <- base::is.null
[17:48:02.295]                     muffled <- FALSE
[17:48:02.295]                     if (inherits(cond, "message")) {
[17:48:02.295]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:02.295]                       if (muffled) 
[17:48:02.295]                         invokeRestart("muffleMessage")
[17:48:02.295]                     }
[17:48:02.295]                     else if (inherits(cond, "warning")) {
[17:48:02.295]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:02.295]                       if (muffled) 
[17:48:02.295]                         invokeRestart("muffleWarning")
[17:48:02.295]                     }
[17:48:02.295]                     else if (inherits(cond, "condition")) {
[17:48:02.295]                       if (!is.null(pattern)) {
[17:48:02.295]                         computeRestarts <- base::computeRestarts
[17:48:02.295]                         grepl <- base::grepl
[17:48:02.295]                         restarts <- computeRestarts(cond)
[17:48:02.295]                         for (restart in restarts) {
[17:48:02.295]                           name <- restart$name
[17:48:02.295]                           if (is.null(name)) 
[17:48:02.295]                             next
[17:48:02.295]                           if (!grepl(pattern, name)) 
[17:48:02.295]                             next
[17:48:02.295]                           invokeRestart(restart)
[17:48:02.295]                           muffled <- TRUE
[17:48:02.295]                           break
[17:48:02.295]                         }
[17:48:02.295]                       }
[17:48:02.295]                     }
[17:48:02.295]                     invisible(muffled)
[17:48:02.295]                   }
[17:48:02.295]                   muffleCondition(cond)
[17:48:02.295]                 })
[17:48:02.295]             }))
[17:48:02.295]             future::FutureResult(value = ...future.value$value, 
[17:48:02.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.295]                   ...future.rng), globalenv = if (FALSE) 
[17:48:02.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:02.295]                     ...future.globalenv.names))
[17:48:02.295]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:02.295]         }, condition = base::local({
[17:48:02.295]             c <- base::c
[17:48:02.295]             inherits <- base::inherits
[17:48:02.295]             invokeRestart <- base::invokeRestart
[17:48:02.295]             length <- base::length
[17:48:02.295]             list <- base::list
[17:48:02.295]             seq.int <- base::seq.int
[17:48:02.295]             signalCondition <- base::signalCondition
[17:48:02.295]             sys.calls <- base::sys.calls
[17:48:02.295]             `[[` <- base::`[[`
[17:48:02.295]             `+` <- base::`+`
[17:48:02.295]             `<<-` <- base::`<<-`
[17:48:02.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:02.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:02.295]                   3L)]
[17:48:02.295]             }
[17:48:02.295]             function(cond) {
[17:48:02.295]                 is_error <- inherits(cond, "error")
[17:48:02.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:02.295]                   NULL)
[17:48:02.295]                 if (is_error) {
[17:48:02.295]                   sessionInformation <- function() {
[17:48:02.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:02.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:02.295]                       search = base::search(), system = base::Sys.info())
[17:48:02.295]                   }
[17:48:02.295]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:02.295]                     cond$call), session = sessionInformation(), 
[17:48:02.295]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:02.295]                   signalCondition(cond)
[17:48:02.295]                 }
[17:48:02.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:02.295]                 "immediateCondition"))) {
[17:48:02.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:02.295]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:02.295]                   if (TRUE && !signal) {
[17:48:02.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.295]                     {
[17:48:02.295]                       inherits <- base::inherits
[17:48:02.295]                       invokeRestart <- base::invokeRestart
[17:48:02.295]                       is.null <- base::is.null
[17:48:02.295]                       muffled <- FALSE
[17:48:02.295]                       if (inherits(cond, "message")) {
[17:48:02.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.295]                         if (muffled) 
[17:48:02.295]                           invokeRestart("muffleMessage")
[17:48:02.295]                       }
[17:48:02.295]                       else if (inherits(cond, "warning")) {
[17:48:02.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.295]                         if (muffled) 
[17:48:02.295]                           invokeRestart("muffleWarning")
[17:48:02.295]                       }
[17:48:02.295]                       else if (inherits(cond, "condition")) {
[17:48:02.295]                         if (!is.null(pattern)) {
[17:48:02.295]                           computeRestarts <- base::computeRestarts
[17:48:02.295]                           grepl <- base::grepl
[17:48:02.295]                           restarts <- computeRestarts(cond)
[17:48:02.295]                           for (restart in restarts) {
[17:48:02.295]                             name <- restart$name
[17:48:02.295]                             if (is.null(name)) 
[17:48:02.295]                               next
[17:48:02.295]                             if (!grepl(pattern, name)) 
[17:48:02.295]                               next
[17:48:02.295]                             invokeRestart(restart)
[17:48:02.295]                             muffled <- TRUE
[17:48:02.295]                             break
[17:48:02.295]                           }
[17:48:02.295]                         }
[17:48:02.295]                       }
[17:48:02.295]                       invisible(muffled)
[17:48:02.295]                     }
[17:48:02.295]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.295]                   }
[17:48:02.295]                 }
[17:48:02.295]                 else {
[17:48:02.295]                   if (TRUE) {
[17:48:02.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.295]                     {
[17:48:02.295]                       inherits <- base::inherits
[17:48:02.295]                       invokeRestart <- base::invokeRestart
[17:48:02.295]                       is.null <- base::is.null
[17:48:02.295]                       muffled <- FALSE
[17:48:02.295]                       if (inherits(cond, "message")) {
[17:48:02.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.295]                         if (muffled) 
[17:48:02.295]                           invokeRestart("muffleMessage")
[17:48:02.295]                       }
[17:48:02.295]                       else if (inherits(cond, "warning")) {
[17:48:02.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.295]                         if (muffled) 
[17:48:02.295]                           invokeRestart("muffleWarning")
[17:48:02.295]                       }
[17:48:02.295]                       else if (inherits(cond, "condition")) {
[17:48:02.295]                         if (!is.null(pattern)) {
[17:48:02.295]                           computeRestarts <- base::computeRestarts
[17:48:02.295]                           grepl <- base::grepl
[17:48:02.295]                           restarts <- computeRestarts(cond)
[17:48:02.295]                           for (restart in restarts) {
[17:48:02.295]                             name <- restart$name
[17:48:02.295]                             if (is.null(name)) 
[17:48:02.295]                               next
[17:48:02.295]                             if (!grepl(pattern, name)) 
[17:48:02.295]                               next
[17:48:02.295]                             invokeRestart(restart)
[17:48:02.295]                             muffled <- TRUE
[17:48:02.295]                             break
[17:48:02.295]                           }
[17:48:02.295]                         }
[17:48:02.295]                       }
[17:48:02.295]                       invisible(muffled)
[17:48:02.295]                     }
[17:48:02.295]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.295]                   }
[17:48:02.295]                 }
[17:48:02.295]             }
[17:48:02.295]         }))
[17:48:02.295]     }, error = function(ex) {
[17:48:02.295]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:02.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.295]                 ...future.rng), started = ...future.startTime, 
[17:48:02.295]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:02.295]             version = "1.8"), class = "FutureResult")
[17:48:02.295]     }, finally = {
[17:48:02.295]         if (!identical(...future.workdir, getwd())) 
[17:48:02.295]             setwd(...future.workdir)
[17:48:02.295]         {
[17:48:02.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:02.295]                 ...future.oldOptions$nwarnings <- NULL
[17:48:02.295]             }
[17:48:02.295]             base::options(...future.oldOptions)
[17:48:02.295]             if (.Platform$OS.type == "windows") {
[17:48:02.295]                 old_names <- names(...future.oldEnvVars)
[17:48:02.295]                 envs <- base::Sys.getenv()
[17:48:02.295]                 names <- names(envs)
[17:48:02.295]                 common <- intersect(names, old_names)
[17:48:02.295]                 added <- setdiff(names, old_names)
[17:48:02.295]                 removed <- setdiff(old_names, names)
[17:48:02.295]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:02.295]                   envs[common]]
[17:48:02.295]                 NAMES <- toupper(changed)
[17:48:02.295]                 args <- list()
[17:48:02.295]                 for (kk in seq_along(NAMES)) {
[17:48:02.295]                   name <- changed[[kk]]
[17:48:02.295]                   NAME <- NAMES[[kk]]
[17:48:02.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.295]                     next
[17:48:02.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.295]                 }
[17:48:02.295]                 NAMES <- toupper(added)
[17:48:02.295]                 for (kk in seq_along(NAMES)) {
[17:48:02.295]                   name <- added[[kk]]
[17:48:02.295]                   NAME <- NAMES[[kk]]
[17:48:02.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.295]                     next
[17:48:02.295]                   args[[name]] <- ""
[17:48:02.295]                 }
[17:48:02.295]                 NAMES <- toupper(removed)
[17:48:02.295]                 for (kk in seq_along(NAMES)) {
[17:48:02.295]                   name <- removed[[kk]]
[17:48:02.295]                   NAME <- NAMES[[kk]]
[17:48:02.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.295]                     next
[17:48:02.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.295]                 }
[17:48:02.295]                 if (length(args) > 0) 
[17:48:02.295]                   base::do.call(base::Sys.setenv, args = args)
[17:48:02.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:02.295]             }
[17:48:02.295]             else {
[17:48:02.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:02.295]             }
[17:48:02.295]             {
[17:48:02.295]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:02.295]                   0L) {
[17:48:02.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:02.295]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:02.295]                   base::options(opts)
[17:48:02.295]                 }
[17:48:02.295]                 {
[17:48:02.295]                   {
[17:48:02.295]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:02.295]                     NULL
[17:48:02.295]                   }
[17:48:02.295]                   options(future.plan = NULL)
[17:48:02.295]                   if (is.na(NA_character_)) 
[17:48:02.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:02.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:02.295]                     .init = FALSE)
[17:48:02.295]                 }
[17:48:02.295]             }
[17:48:02.295]         }
[17:48:02.295]     })
[17:48:02.295]     if (TRUE) {
[17:48:02.295]         base::sink(type = "output", split = FALSE)
[17:48:02.295]         if (TRUE) {
[17:48:02.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:02.295]         }
[17:48:02.295]         else {
[17:48:02.295]             ...future.result["stdout"] <- base::list(NULL)
[17:48:02.295]         }
[17:48:02.295]         base::close(...future.stdout)
[17:48:02.295]         ...future.stdout <- NULL
[17:48:02.295]     }
[17:48:02.295]     ...future.result$conditions <- ...future.conditions
[17:48:02.295]     ...future.result$finished <- base::Sys.time()
[17:48:02.295]     ...future.result
[17:48:02.295] }
[17:48:02.298] MultisessionFuture started
[17:48:02.298] - Launch lazy future ... done
[17:48:02.298] run() for ‘MultisessionFuture’ ... done
[17:48:02.800] receiveMessageFromWorker() for ClusterFuture ...
[17:48:02.801] - Validating connection of MultisessionFuture
[17:48:02.801] - received message: FutureResult
[17:48:02.801] - Received FutureResult
[17:48:02.801] - Erased future from FutureRegistry
[17:48:02.801] result() for ClusterFuture ...
[17:48:02.804] - result already collected: FutureResult
[17:48:02.804] result() for ClusterFuture ... done
[17:48:02.804] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:02.804] A MultisessionFuture was resolved (result was not collected)
[17:48:02.804] getGlobalsAndPackages() ...
[17:48:02.804] Searching for globals...
[17:48:02.805] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:02.805] Searching for globals ... DONE
[17:48:02.805] Resolving globals: FALSE
[17:48:02.806] 
[17:48:02.806] 
[17:48:02.806] getGlobalsAndPackages() ... DONE
[17:48:02.806] run() for ‘Future’ ...
[17:48:02.806] - state: ‘created’
[17:48:02.806] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:02.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:02.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:02.821]   - Field: ‘node’
[17:48:02.821]   - Field: ‘label’
[17:48:02.821]   - Field: ‘local’
[17:48:02.821]   - Field: ‘owner’
[17:48:02.821]   - Field: ‘envir’
[17:48:02.821]   - Field: ‘workers’
[17:48:02.821]   - Field: ‘packages’
[17:48:02.821]   - Field: ‘gc’
[17:48:02.821]   - Field: ‘conditions’
[17:48:02.821]   - Field: ‘persistent’
[17:48:02.821]   - Field: ‘expr’
[17:48:02.821]   - Field: ‘uuid’
[17:48:02.822]   - Field: ‘seed’
[17:48:02.822]   - Field: ‘version’
[17:48:02.822]   - Field: ‘result’
[17:48:02.822]   - Field: ‘asynchronous’
[17:48:02.822]   - Field: ‘calls’
[17:48:02.822]   - Field: ‘globals’
[17:48:02.822]   - Field: ‘stdout’
[17:48:02.822]   - Field: ‘earlySignal’
[17:48:02.822]   - Field: ‘lazy’
[17:48:02.822]   - Field: ‘state’
[17:48:02.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:02.823] - Launch lazy future ...
[17:48:02.823] Packages needed by the future expression (n = 0): <none>
[17:48:02.823] Packages needed by future strategies (n = 0): <none>
[17:48:02.823] {
[17:48:02.823]     {
[17:48:02.823]         {
[17:48:02.823]             ...future.startTime <- base::Sys.time()
[17:48:02.823]             {
[17:48:02.823]                 {
[17:48:02.823]                   {
[17:48:02.823]                     {
[17:48:02.823]                       base::local({
[17:48:02.823]                         has_future <- base::requireNamespace("future", 
[17:48:02.823]                           quietly = TRUE)
[17:48:02.823]                         if (has_future) {
[17:48:02.823]                           ns <- base::getNamespace("future")
[17:48:02.823]                           version <- ns[[".package"]][["version"]]
[17:48:02.823]                           if (is.null(version)) 
[17:48:02.823]                             version <- utils::packageVersion("future")
[17:48:02.823]                         }
[17:48:02.823]                         else {
[17:48:02.823]                           version <- NULL
[17:48:02.823]                         }
[17:48:02.823]                         if (!has_future || version < "1.8.0") {
[17:48:02.823]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:02.823]                             "", base::R.version$version.string), 
[17:48:02.823]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:02.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:02.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:02.823]                               "release", "version")], collapse = " "), 
[17:48:02.823]                             hostname = base::Sys.info()[["nodename"]])
[17:48:02.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:02.823]                             info)
[17:48:02.823]                           info <- base::paste(info, collapse = "; ")
[17:48:02.823]                           if (!has_future) {
[17:48:02.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:02.823]                               info)
[17:48:02.823]                           }
[17:48:02.823]                           else {
[17:48:02.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:02.823]                               info, version)
[17:48:02.823]                           }
[17:48:02.823]                           base::stop(msg)
[17:48:02.823]                         }
[17:48:02.823]                       })
[17:48:02.823]                     }
[17:48:02.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:02.823]                     base::options(mc.cores = 1L)
[17:48:02.823]                   }
[17:48:02.823]                   ...future.strategy.old <- future::plan("list")
[17:48:02.823]                   options(future.plan = NULL)
[17:48:02.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:02.823]                 }
[17:48:02.823]                 ...future.workdir <- getwd()
[17:48:02.823]             }
[17:48:02.823]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:02.823]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:02.823]         }
[17:48:02.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:02.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:02.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:02.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:02.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:02.823]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:02.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:02.823]             base::names(...future.oldOptions))
[17:48:02.823]     }
[17:48:02.823]     if (FALSE) {
[17:48:02.823]     }
[17:48:02.823]     else {
[17:48:02.823]         if (TRUE) {
[17:48:02.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:02.823]                 open = "w")
[17:48:02.823]         }
[17:48:02.823]         else {
[17:48:02.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:02.823]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:02.823]         }
[17:48:02.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:02.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:02.823]             base::sink(type = "output", split = FALSE)
[17:48:02.823]             base::close(...future.stdout)
[17:48:02.823]         }, add = TRUE)
[17:48:02.823]     }
[17:48:02.823]     ...future.frame <- base::sys.nframe()
[17:48:02.823]     ...future.conditions <- base::list()
[17:48:02.823]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:02.823]     if (FALSE) {
[17:48:02.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:02.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:02.823]     }
[17:48:02.823]     ...future.result <- base::tryCatch({
[17:48:02.823]         base::withCallingHandlers({
[17:48:02.823]             ...future.value <- base::withVisible(base::local({
[17:48:02.823]                 ...future.makeSendCondition <- base::local({
[17:48:02.823]                   sendCondition <- NULL
[17:48:02.823]                   function(frame = 1L) {
[17:48:02.823]                     if (is.function(sendCondition)) 
[17:48:02.823]                       return(sendCondition)
[17:48:02.823]                     ns <- getNamespace("parallel")
[17:48:02.823]                     if (exists("sendData", mode = "function", 
[17:48:02.823]                       envir = ns)) {
[17:48:02.823]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:02.823]                         envir = ns)
[17:48:02.823]                       envir <- sys.frame(frame)
[17:48:02.823]                       master <- NULL
[17:48:02.823]                       while (!identical(envir, .GlobalEnv) && 
[17:48:02.823]                         !identical(envir, emptyenv())) {
[17:48:02.823]                         if (exists("master", mode = "list", envir = envir, 
[17:48:02.823]                           inherits = FALSE)) {
[17:48:02.823]                           master <- get("master", mode = "list", 
[17:48:02.823]                             envir = envir, inherits = FALSE)
[17:48:02.823]                           if (inherits(master, c("SOCKnode", 
[17:48:02.823]                             "SOCK0node"))) {
[17:48:02.823]                             sendCondition <<- function(cond) {
[17:48:02.823]                               data <- list(type = "VALUE", value = cond, 
[17:48:02.823]                                 success = TRUE)
[17:48:02.823]                               parallel_sendData(master, data)
[17:48:02.823]                             }
[17:48:02.823]                             return(sendCondition)
[17:48:02.823]                           }
[17:48:02.823]                         }
[17:48:02.823]                         frame <- frame + 1L
[17:48:02.823]                         envir <- sys.frame(frame)
[17:48:02.823]                       }
[17:48:02.823]                     }
[17:48:02.823]                     sendCondition <<- function(cond) NULL
[17:48:02.823]                   }
[17:48:02.823]                 })
[17:48:02.823]                 withCallingHandlers({
[17:48:02.823]                   {
[17:48:02.823]                     Sys.sleep(0.5)
[17:48:02.823]                     list(a = 1, b = 42L)
[17:48:02.823]                   }
[17:48:02.823]                 }, immediateCondition = function(cond) {
[17:48:02.823]                   sendCondition <- ...future.makeSendCondition()
[17:48:02.823]                   sendCondition(cond)
[17:48:02.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.823]                   {
[17:48:02.823]                     inherits <- base::inherits
[17:48:02.823]                     invokeRestart <- base::invokeRestart
[17:48:02.823]                     is.null <- base::is.null
[17:48:02.823]                     muffled <- FALSE
[17:48:02.823]                     if (inherits(cond, "message")) {
[17:48:02.823]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:02.823]                       if (muffled) 
[17:48:02.823]                         invokeRestart("muffleMessage")
[17:48:02.823]                     }
[17:48:02.823]                     else if (inherits(cond, "warning")) {
[17:48:02.823]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:02.823]                       if (muffled) 
[17:48:02.823]                         invokeRestart("muffleWarning")
[17:48:02.823]                     }
[17:48:02.823]                     else if (inherits(cond, "condition")) {
[17:48:02.823]                       if (!is.null(pattern)) {
[17:48:02.823]                         computeRestarts <- base::computeRestarts
[17:48:02.823]                         grepl <- base::grepl
[17:48:02.823]                         restarts <- computeRestarts(cond)
[17:48:02.823]                         for (restart in restarts) {
[17:48:02.823]                           name <- restart$name
[17:48:02.823]                           if (is.null(name)) 
[17:48:02.823]                             next
[17:48:02.823]                           if (!grepl(pattern, name)) 
[17:48:02.823]                             next
[17:48:02.823]                           invokeRestart(restart)
[17:48:02.823]                           muffled <- TRUE
[17:48:02.823]                           break
[17:48:02.823]                         }
[17:48:02.823]                       }
[17:48:02.823]                     }
[17:48:02.823]                     invisible(muffled)
[17:48:02.823]                   }
[17:48:02.823]                   muffleCondition(cond)
[17:48:02.823]                 })
[17:48:02.823]             }))
[17:48:02.823]             future::FutureResult(value = ...future.value$value, 
[17:48:02.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.823]                   ...future.rng), globalenv = if (FALSE) 
[17:48:02.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:02.823]                     ...future.globalenv.names))
[17:48:02.823]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:02.823]         }, condition = base::local({
[17:48:02.823]             c <- base::c
[17:48:02.823]             inherits <- base::inherits
[17:48:02.823]             invokeRestart <- base::invokeRestart
[17:48:02.823]             length <- base::length
[17:48:02.823]             list <- base::list
[17:48:02.823]             seq.int <- base::seq.int
[17:48:02.823]             signalCondition <- base::signalCondition
[17:48:02.823]             sys.calls <- base::sys.calls
[17:48:02.823]             `[[` <- base::`[[`
[17:48:02.823]             `+` <- base::`+`
[17:48:02.823]             `<<-` <- base::`<<-`
[17:48:02.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:02.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:02.823]                   3L)]
[17:48:02.823]             }
[17:48:02.823]             function(cond) {
[17:48:02.823]                 is_error <- inherits(cond, "error")
[17:48:02.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:02.823]                   NULL)
[17:48:02.823]                 if (is_error) {
[17:48:02.823]                   sessionInformation <- function() {
[17:48:02.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:02.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:02.823]                       search = base::search(), system = base::Sys.info())
[17:48:02.823]                   }
[17:48:02.823]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:02.823]                     cond$call), session = sessionInformation(), 
[17:48:02.823]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:02.823]                   signalCondition(cond)
[17:48:02.823]                 }
[17:48:02.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:02.823]                 "immediateCondition"))) {
[17:48:02.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:02.823]                   ...future.conditions[[length(...future.conditions) + 
[17:48:02.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:02.823]                   if (TRUE && !signal) {
[17:48:02.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.823]                     {
[17:48:02.823]                       inherits <- base::inherits
[17:48:02.823]                       invokeRestart <- base::invokeRestart
[17:48:02.823]                       is.null <- base::is.null
[17:48:02.823]                       muffled <- FALSE
[17:48:02.823]                       if (inherits(cond, "message")) {
[17:48:02.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.823]                         if (muffled) 
[17:48:02.823]                           invokeRestart("muffleMessage")
[17:48:02.823]                       }
[17:48:02.823]                       else if (inherits(cond, "warning")) {
[17:48:02.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.823]                         if (muffled) 
[17:48:02.823]                           invokeRestart("muffleWarning")
[17:48:02.823]                       }
[17:48:02.823]                       else if (inherits(cond, "condition")) {
[17:48:02.823]                         if (!is.null(pattern)) {
[17:48:02.823]                           computeRestarts <- base::computeRestarts
[17:48:02.823]                           grepl <- base::grepl
[17:48:02.823]                           restarts <- computeRestarts(cond)
[17:48:02.823]                           for (restart in restarts) {
[17:48:02.823]                             name <- restart$name
[17:48:02.823]                             if (is.null(name)) 
[17:48:02.823]                               next
[17:48:02.823]                             if (!grepl(pattern, name)) 
[17:48:02.823]                               next
[17:48:02.823]                             invokeRestart(restart)
[17:48:02.823]                             muffled <- TRUE
[17:48:02.823]                             break
[17:48:02.823]                           }
[17:48:02.823]                         }
[17:48:02.823]                       }
[17:48:02.823]                       invisible(muffled)
[17:48:02.823]                     }
[17:48:02.823]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.823]                   }
[17:48:02.823]                 }
[17:48:02.823]                 else {
[17:48:02.823]                   if (TRUE) {
[17:48:02.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:02.823]                     {
[17:48:02.823]                       inherits <- base::inherits
[17:48:02.823]                       invokeRestart <- base::invokeRestart
[17:48:02.823]                       is.null <- base::is.null
[17:48:02.823]                       muffled <- FALSE
[17:48:02.823]                       if (inherits(cond, "message")) {
[17:48:02.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:02.823]                         if (muffled) 
[17:48:02.823]                           invokeRestart("muffleMessage")
[17:48:02.823]                       }
[17:48:02.823]                       else if (inherits(cond, "warning")) {
[17:48:02.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:02.823]                         if (muffled) 
[17:48:02.823]                           invokeRestart("muffleWarning")
[17:48:02.823]                       }
[17:48:02.823]                       else if (inherits(cond, "condition")) {
[17:48:02.823]                         if (!is.null(pattern)) {
[17:48:02.823]                           computeRestarts <- base::computeRestarts
[17:48:02.823]                           grepl <- base::grepl
[17:48:02.823]                           restarts <- computeRestarts(cond)
[17:48:02.823]                           for (restart in restarts) {
[17:48:02.823]                             name <- restart$name
[17:48:02.823]                             if (is.null(name)) 
[17:48:02.823]                               next
[17:48:02.823]                             if (!grepl(pattern, name)) 
[17:48:02.823]                               next
[17:48:02.823]                             invokeRestart(restart)
[17:48:02.823]                             muffled <- TRUE
[17:48:02.823]                             break
[17:48:02.823]                           }
[17:48:02.823]                         }
[17:48:02.823]                       }
[17:48:02.823]                       invisible(muffled)
[17:48:02.823]                     }
[17:48:02.823]                     muffleCondition(cond, pattern = "^muffle")
[17:48:02.823]                   }
[17:48:02.823]                 }
[17:48:02.823]             }
[17:48:02.823]         }))
[17:48:02.823]     }, error = function(ex) {
[17:48:02.823]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:02.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:02.823]                 ...future.rng), started = ...future.startTime, 
[17:48:02.823]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:02.823]             version = "1.8"), class = "FutureResult")
[17:48:02.823]     }, finally = {
[17:48:02.823]         if (!identical(...future.workdir, getwd())) 
[17:48:02.823]             setwd(...future.workdir)
[17:48:02.823]         {
[17:48:02.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:02.823]                 ...future.oldOptions$nwarnings <- NULL
[17:48:02.823]             }
[17:48:02.823]             base::options(...future.oldOptions)
[17:48:02.823]             if (.Platform$OS.type == "windows") {
[17:48:02.823]                 old_names <- names(...future.oldEnvVars)
[17:48:02.823]                 envs <- base::Sys.getenv()
[17:48:02.823]                 names <- names(envs)
[17:48:02.823]                 common <- intersect(names, old_names)
[17:48:02.823]                 added <- setdiff(names, old_names)
[17:48:02.823]                 removed <- setdiff(old_names, names)
[17:48:02.823]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:02.823]                   envs[common]]
[17:48:02.823]                 NAMES <- toupper(changed)
[17:48:02.823]                 args <- list()
[17:48:02.823]                 for (kk in seq_along(NAMES)) {
[17:48:02.823]                   name <- changed[[kk]]
[17:48:02.823]                   NAME <- NAMES[[kk]]
[17:48:02.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.823]                     next
[17:48:02.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.823]                 }
[17:48:02.823]                 NAMES <- toupper(added)
[17:48:02.823]                 for (kk in seq_along(NAMES)) {
[17:48:02.823]                   name <- added[[kk]]
[17:48:02.823]                   NAME <- NAMES[[kk]]
[17:48:02.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.823]                     next
[17:48:02.823]                   args[[name]] <- ""
[17:48:02.823]                 }
[17:48:02.823]                 NAMES <- toupper(removed)
[17:48:02.823]                 for (kk in seq_along(NAMES)) {
[17:48:02.823]                   name <- removed[[kk]]
[17:48:02.823]                   NAME <- NAMES[[kk]]
[17:48:02.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:02.823]                     next
[17:48:02.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:02.823]                 }
[17:48:02.823]                 if (length(args) > 0) 
[17:48:02.823]                   base::do.call(base::Sys.setenv, args = args)
[17:48:02.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:02.823]             }
[17:48:02.823]             else {
[17:48:02.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:02.823]             }
[17:48:02.823]             {
[17:48:02.823]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:02.823]                   0L) {
[17:48:02.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:02.823]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:02.823]                   base::options(opts)
[17:48:02.823]                 }
[17:48:02.823]                 {
[17:48:02.823]                   {
[17:48:02.823]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:02.823]                     NULL
[17:48:02.823]                   }
[17:48:02.823]                   options(future.plan = NULL)
[17:48:02.823]                   if (is.na(NA_character_)) 
[17:48:02.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:02.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:02.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:02.823]                     .init = FALSE)
[17:48:02.823]                 }
[17:48:02.823]             }
[17:48:02.823]         }
[17:48:02.823]     })
[17:48:02.823]     if (TRUE) {
[17:48:02.823]         base::sink(type = "output", split = FALSE)
[17:48:02.823]         if (TRUE) {
[17:48:02.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:02.823]         }
[17:48:02.823]         else {
[17:48:02.823]             ...future.result["stdout"] <- base::list(NULL)
[17:48:02.823]         }
[17:48:02.823]         base::close(...future.stdout)
[17:48:02.823]         ...future.stdout <- NULL
[17:48:02.823]     }
[17:48:02.823]     ...future.result$conditions <- ...future.conditions
[17:48:02.823]     ...future.result$finished <- base::Sys.time()
[17:48:02.823]     ...future.result
[17:48:02.823] }
[17:48:02.826] MultisessionFuture started
[17:48:02.826] - Launch lazy future ... done
[17:48:02.827] run() for ‘MultisessionFuture’ ... done
[17:48:03.329] receiveMessageFromWorker() for ClusterFuture ...
[17:48:03.329] - Validating connection of MultisessionFuture
[17:48:03.330] - received message: FutureResult
[17:48:03.330] - Received FutureResult
[17:48:03.330] - Erased future from FutureRegistry
[17:48:03.330] result() for ClusterFuture ...
[17:48:03.330] - result already collected: FutureResult
[17:48:03.330] result() for ClusterFuture ... done
[17:48:03.330] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:03.330] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:48:03.330] getGlobalsAndPackages() ...
[17:48:03.331] Searching for globals...
[17:48:03.331] - globals found: [2] ‘list’, ‘stop’
[17:48:03.331] Searching for globals ... DONE
[17:48:03.331] Resolving globals: FALSE
[17:48:03.332] 
[17:48:03.332] 
[17:48:03.332] getGlobalsAndPackages() ... DONE
[17:48:03.332] run() for ‘Future’ ...
[17:48:03.332] - state: ‘created’
[17:48:03.332] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:03.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:03.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:03.349]   - Field: ‘node’
[17:48:03.349]   - Field: ‘label’
[17:48:03.349]   - Field: ‘local’
[17:48:03.349]   - Field: ‘owner’
[17:48:03.349]   - Field: ‘envir’
[17:48:03.349]   - Field: ‘workers’
[17:48:03.349]   - Field: ‘packages’
[17:48:03.349]   - Field: ‘gc’
[17:48:03.349]   - Field: ‘conditions’
[17:48:03.349]   - Field: ‘persistent’
[17:48:03.350]   - Field: ‘expr’
[17:48:03.350]   - Field: ‘uuid’
[17:48:03.350]   - Field: ‘seed’
[17:48:03.350]   - Field: ‘version’
[17:48:03.350]   - Field: ‘result’
[17:48:03.350]   - Field: ‘asynchronous’
[17:48:03.350]   - Field: ‘calls’
[17:48:03.350]   - Field: ‘globals’
[17:48:03.350]   - Field: ‘stdout’
[17:48:03.350]   - Field: ‘earlySignal’
[17:48:03.350]   - Field: ‘lazy’
[17:48:03.350]   - Field: ‘state’
[17:48:03.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:03.351] - Launch lazy future ...
[17:48:03.351] Packages needed by the future expression (n = 0): <none>
[17:48:03.351] Packages needed by future strategies (n = 0): <none>
[17:48:03.352] {
[17:48:03.352]     {
[17:48:03.352]         {
[17:48:03.352]             ...future.startTime <- base::Sys.time()
[17:48:03.352]             {
[17:48:03.352]                 {
[17:48:03.352]                   {
[17:48:03.352]                     {
[17:48:03.352]                       base::local({
[17:48:03.352]                         has_future <- base::requireNamespace("future", 
[17:48:03.352]                           quietly = TRUE)
[17:48:03.352]                         if (has_future) {
[17:48:03.352]                           ns <- base::getNamespace("future")
[17:48:03.352]                           version <- ns[[".package"]][["version"]]
[17:48:03.352]                           if (is.null(version)) 
[17:48:03.352]                             version <- utils::packageVersion("future")
[17:48:03.352]                         }
[17:48:03.352]                         else {
[17:48:03.352]                           version <- NULL
[17:48:03.352]                         }
[17:48:03.352]                         if (!has_future || version < "1.8.0") {
[17:48:03.352]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:03.352]                             "", base::R.version$version.string), 
[17:48:03.352]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:03.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:03.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:03.352]                               "release", "version")], collapse = " "), 
[17:48:03.352]                             hostname = base::Sys.info()[["nodename"]])
[17:48:03.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:03.352]                             info)
[17:48:03.352]                           info <- base::paste(info, collapse = "; ")
[17:48:03.352]                           if (!has_future) {
[17:48:03.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:03.352]                               info)
[17:48:03.352]                           }
[17:48:03.352]                           else {
[17:48:03.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:03.352]                               info, version)
[17:48:03.352]                           }
[17:48:03.352]                           base::stop(msg)
[17:48:03.352]                         }
[17:48:03.352]                       })
[17:48:03.352]                     }
[17:48:03.352]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:03.352]                     base::options(mc.cores = 1L)
[17:48:03.352]                   }
[17:48:03.352]                   ...future.strategy.old <- future::plan("list")
[17:48:03.352]                   options(future.plan = NULL)
[17:48:03.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:03.352]                 }
[17:48:03.352]                 ...future.workdir <- getwd()
[17:48:03.352]             }
[17:48:03.352]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:03.352]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:03.352]         }
[17:48:03.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:03.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:03.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:03.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:03.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:03.352]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:03.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:03.352]             base::names(...future.oldOptions))
[17:48:03.352]     }
[17:48:03.352]     if (FALSE) {
[17:48:03.352]     }
[17:48:03.352]     else {
[17:48:03.352]         if (TRUE) {
[17:48:03.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:03.352]                 open = "w")
[17:48:03.352]         }
[17:48:03.352]         else {
[17:48:03.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:03.352]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:03.352]         }
[17:48:03.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:03.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:03.352]             base::sink(type = "output", split = FALSE)
[17:48:03.352]             base::close(...future.stdout)
[17:48:03.352]         }, add = TRUE)
[17:48:03.352]     }
[17:48:03.352]     ...future.frame <- base::sys.nframe()
[17:48:03.352]     ...future.conditions <- base::list()
[17:48:03.352]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:03.352]     if (FALSE) {
[17:48:03.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:03.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:03.352]     }
[17:48:03.352]     ...future.result <- base::tryCatch({
[17:48:03.352]         base::withCallingHandlers({
[17:48:03.352]             ...future.value <- base::withVisible(base::local({
[17:48:03.352]                 ...future.makeSendCondition <- base::local({
[17:48:03.352]                   sendCondition <- NULL
[17:48:03.352]                   function(frame = 1L) {
[17:48:03.352]                     if (is.function(sendCondition)) 
[17:48:03.352]                       return(sendCondition)
[17:48:03.352]                     ns <- getNamespace("parallel")
[17:48:03.352]                     if (exists("sendData", mode = "function", 
[17:48:03.352]                       envir = ns)) {
[17:48:03.352]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:03.352]                         envir = ns)
[17:48:03.352]                       envir <- sys.frame(frame)
[17:48:03.352]                       master <- NULL
[17:48:03.352]                       while (!identical(envir, .GlobalEnv) && 
[17:48:03.352]                         !identical(envir, emptyenv())) {
[17:48:03.352]                         if (exists("master", mode = "list", envir = envir, 
[17:48:03.352]                           inherits = FALSE)) {
[17:48:03.352]                           master <- get("master", mode = "list", 
[17:48:03.352]                             envir = envir, inherits = FALSE)
[17:48:03.352]                           if (inherits(master, c("SOCKnode", 
[17:48:03.352]                             "SOCK0node"))) {
[17:48:03.352]                             sendCondition <<- function(cond) {
[17:48:03.352]                               data <- list(type = "VALUE", value = cond, 
[17:48:03.352]                                 success = TRUE)
[17:48:03.352]                               parallel_sendData(master, data)
[17:48:03.352]                             }
[17:48:03.352]                             return(sendCondition)
[17:48:03.352]                           }
[17:48:03.352]                         }
[17:48:03.352]                         frame <- frame + 1L
[17:48:03.352]                         envir <- sys.frame(frame)
[17:48:03.352]                       }
[17:48:03.352]                     }
[17:48:03.352]                     sendCondition <<- function(cond) NULL
[17:48:03.352]                   }
[17:48:03.352]                 })
[17:48:03.352]                 withCallingHandlers({
[17:48:03.352]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:03.352]                 }, immediateCondition = function(cond) {
[17:48:03.352]                   sendCondition <- ...future.makeSendCondition()
[17:48:03.352]                   sendCondition(cond)
[17:48:03.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.352]                   {
[17:48:03.352]                     inherits <- base::inherits
[17:48:03.352]                     invokeRestart <- base::invokeRestart
[17:48:03.352]                     is.null <- base::is.null
[17:48:03.352]                     muffled <- FALSE
[17:48:03.352]                     if (inherits(cond, "message")) {
[17:48:03.352]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:03.352]                       if (muffled) 
[17:48:03.352]                         invokeRestart("muffleMessage")
[17:48:03.352]                     }
[17:48:03.352]                     else if (inherits(cond, "warning")) {
[17:48:03.352]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:03.352]                       if (muffled) 
[17:48:03.352]                         invokeRestart("muffleWarning")
[17:48:03.352]                     }
[17:48:03.352]                     else if (inherits(cond, "condition")) {
[17:48:03.352]                       if (!is.null(pattern)) {
[17:48:03.352]                         computeRestarts <- base::computeRestarts
[17:48:03.352]                         grepl <- base::grepl
[17:48:03.352]                         restarts <- computeRestarts(cond)
[17:48:03.352]                         for (restart in restarts) {
[17:48:03.352]                           name <- restart$name
[17:48:03.352]                           if (is.null(name)) 
[17:48:03.352]                             next
[17:48:03.352]                           if (!grepl(pattern, name)) 
[17:48:03.352]                             next
[17:48:03.352]                           invokeRestart(restart)
[17:48:03.352]                           muffled <- TRUE
[17:48:03.352]                           break
[17:48:03.352]                         }
[17:48:03.352]                       }
[17:48:03.352]                     }
[17:48:03.352]                     invisible(muffled)
[17:48:03.352]                   }
[17:48:03.352]                   muffleCondition(cond)
[17:48:03.352]                 })
[17:48:03.352]             }))
[17:48:03.352]             future::FutureResult(value = ...future.value$value, 
[17:48:03.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.352]                   ...future.rng), globalenv = if (FALSE) 
[17:48:03.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:03.352]                     ...future.globalenv.names))
[17:48:03.352]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:03.352]         }, condition = base::local({
[17:48:03.352]             c <- base::c
[17:48:03.352]             inherits <- base::inherits
[17:48:03.352]             invokeRestart <- base::invokeRestart
[17:48:03.352]             length <- base::length
[17:48:03.352]             list <- base::list
[17:48:03.352]             seq.int <- base::seq.int
[17:48:03.352]             signalCondition <- base::signalCondition
[17:48:03.352]             sys.calls <- base::sys.calls
[17:48:03.352]             `[[` <- base::`[[`
[17:48:03.352]             `+` <- base::`+`
[17:48:03.352]             `<<-` <- base::`<<-`
[17:48:03.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:03.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:03.352]                   3L)]
[17:48:03.352]             }
[17:48:03.352]             function(cond) {
[17:48:03.352]                 is_error <- inherits(cond, "error")
[17:48:03.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:03.352]                   NULL)
[17:48:03.352]                 if (is_error) {
[17:48:03.352]                   sessionInformation <- function() {
[17:48:03.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:03.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:03.352]                       search = base::search(), system = base::Sys.info())
[17:48:03.352]                   }
[17:48:03.352]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:03.352]                     cond$call), session = sessionInformation(), 
[17:48:03.352]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:03.352]                   signalCondition(cond)
[17:48:03.352]                 }
[17:48:03.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:03.352]                 "immediateCondition"))) {
[17:48:03.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:03.352]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:03.352]                   if (TRUE && !signal) {
[17:48:03.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.352]                     {
[17:48:03.352]                       inherits <- base::inherits
[17:48:03.352]                       invokeRestart <- base::invokeRestart
[17:48:03.352]                       is.null <- base::is.null
[17:48:03.352]                       muffled <- FALSE
[17:48:03.352]                       if (inherits(cond, "message")) {
[17:48:03.352]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.352]                         if (muffled) 
[17:48:03.352]                           invokeRestart("muffleMessage")
[17:48:03.352]                       }
[17:48:03.352]                       else if (inherits(cond, "warning")) {
[17:48:03.352]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.352]                         if (muffled) 
[17:48:03.352]                           invokeRestart("muffleWarning")
[17:48:03.352]                       }
[17:48:03.352]                       else if (inherits(cond, "condition")) {
[17:48:03.352]                         if (!is.null(pattern)) {
[17:48:03.352]                           computeRestarts <- base::computeRestarts
[17:48:03.352]                           grepl <- base::grepl
[17:48:03.352]                           restarts <- computeRestarts(cond)
[17:48:03.352]                           for (restart in restarts) {
[17:48:03.352]                             name <- restart$name
[17:48:03.352]                             if (is.null(name)) 
[17:48:03.352]                               next
[17:48:03.352]                             if (!grepl(pattern, name)) 
[17:48:03.352]                               next
[17:48:03.352]                             invokeRestart(restart)
[17:48:03.352]                             muffled <- TRUE
[17:48:03.352]                             break
[17:48:03.352]                           }
[17:48:03.352]                         }
[17:48:03.352]                       }
[17:48:03.352]                       invisible(muffled)
[17:48:03.352]                     }
[17:48:03.352]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.352]                   }
[17:48:03.352]                 }
[17:48:03.352]                 else {
[17:48:03.352]                   if (TRUE) {
[17:48:03.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.352]                     {
[17:48:03.352]                       inherits <- base::inherits
[17:48:03.352]                       invokeRestart <- base::invokeRestart
[17:48:03.352]                       is.null <- base::is.null
[17:48:03.352]                       muffled <- FALSE
[17:48:03.352]                       if (inherits(cond, "message")) {
[17:48:03.352]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.352]                         if (muffled) 
[17:48:03.352]                           invokeRestart("muffleMessage")
[17:48:03.352]                       }
[17:48:03.352]                       else if (inherits(cond, "warning")) {
[17:48:03.352]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.352]                         if (muffled) 
[17:48:03.352]                           invokeRestart("muffleWarning")
[17:48:03.352]                       }
[17:48:03.352]                       else if (inherits(cond, "condition")) {
[17:48:03.352]                         if (!is.null(pattern)) {
[17:48:03.352]                           computeRestarts <- base::computeRestarts
[17:48:03.352]                           grepl <- base::grepl
[17:48:03.352]                           restarts <- computeRestarts(cond)
[17:48:03.352]                           for (restart in restarts) {
[17:48:03.352]                             name <- restart$name
[17:48:03.352]                             if (is.null(name)) 
[17:48:03.352]                               next
[17:48:03.352]                             if (!grepl(pattern, name)) 
[17:48:03.352]                               next
[17:48:03.352]                             invokeRestart(restart)
[17:48:03.352]                             muffled <- TRUE
[17:48:03.352]                             break
[17:48:03.352]                           }
[17:48:03.352]                         }
[17:48:03.352]                       }
[17:48:03.352]                       invisible(muffled)
[17:48:03.352]                     }
[17:48:03.352]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.352]                   }
[17:48:03.352]                 }
[17:48:03.352]             }
[17:48:03.352]         }))
[17:48:03.352]     }, error = function(ex) {
[17:48:03.352]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:03.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.352]                 ...future.rng), started = ...future.startTime, 
[17:48:03.352]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:03.352]             version = "1.8"), class = "FutureResult")
[17:48:03.352]     }, finally = {
[17:48:03.352]         if (!identical(...future.workdir, getwd())) 
[17:48:03.352]             setwd(...future.workdir)
[17:48:03.352]         {
[17:48:03.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:03.352]                 ...future.oldOptions$nwarnings <- NULL
[17:48:03.352]             }
[17:48:03.352]             base::options(...future.oldOptions)
[17:48:03.352]             if (.Platform$OS.type == "windows") {
[17:48:03.352]                 old_names <- names(...future.oldEnvVars)
[17:48:03.352]                 envs <- base::Sys.getenv()
[17:48:03.352]                 names <- names(envs)
[17:48:03.352]                 common <- intersect(names, old_names)
[17:48:03.352]                 added <- setdiff(names, old_names)
[17:48:03.352]                 removed <- setdiff(old_names, names)
[17:48:03.352]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:03.352]                   envs[common]]
[17:48:03.352]                 NAMES <- toupper(changed)
[17:48:03.352]                 args <- list()
[17:48:03.352]                 for (kk in seq_along(NAMES)) {
[17:48:03.352]                   name <- changed[[kk]]
[17:48:03.352]                   NAME <- NAMES[[kk]]
[17:48:03.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.352]                     next
[17:48:03.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.352]                 }
[17:48:03.352]                 NAMES <- toupper(added)
[17:48:03.352]                 for (kk in seq_along(NAMES)) {
[17:48:03.352]                   name <- added[[kk]]
[17:48:03.352]                   NAME <- NAMES[[kk]]
[17:48:03.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.352]                     next
[17:48:03.352]                   args[[name]] <- ""
[17:48:03.352]                 }
[17:48:03.352]                 NAMES <- toupper(removed)
[17:48:03.352]                 for (kk in seq_along(NAMES)) {
[17:48:03.352]                   name <- removed[[kk]]
[17:48:03.352]                   NAME <- NAMES[[kk]]
[17:48:03.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.352]                     next
[17:48:03.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.352]                 }
[17:48:03.352]                 if (length(args) > 0) 
[17:48:03.352]                   base::do.call(base::Sys.setenv, args = args)
[17:48:03.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:03.352]             }
[17:48:03.352]             else {
[17:48:03.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:03.352]             }
[17:48:03.352]             {
[17:48:03.352]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:03.352]                   0L) {
[17:48:03.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:03.352]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:03.352]                   base::options(opts)
[17:48:03.352]                 }
[17:48:03.352]                 {
[17:48:03.352]                   {
[17:48:03.352]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:03.352]                     NULL
[17:48:03.352]                   }
[17:48:03.352]                   options(future.plan = NULL)
[17:48:03.352]                   if (is.na(NA_character_)) 
[17:48:03.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:03.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:03.352]                     .init = FALSE)
[17:48:03.352]                 }
[17:48:03.352]             }
[17:48:03.352]         }
[17:48:03.352]     })
[17:48:03.352]     if (TRUE) {
[17:48:03.352]         base::sink(type = "output", split = FALSE)
[17:48:03.352]         if (TRUE) {
[17:48:03.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:03.352]         }
[17:48:03.352]         else {
[17:48:03.352]             ...future.result["stdout"] <- base::list(NULL)
[17:48:03.352]         }
[17:48:03.352]         base::close(...future.stdout)
[17:48:03.352]         ...future.stdout <- NULL
[17:48:03.352]     }
[17:48:03.352]     ...future.result$conditions <- ...future.conditions
[17:48:03.352]     ...future.result$finished <- base::Sys.time()
[17:48:03.352]     ...future.result
[17:48:03.352] }
[17:48:03.354] MultisessionFuture started
[17:48:03.355] - Launch lazy future ... done
[17:48:03.355] run() for ‘MultisessionFuture’ ... done
[17:48:03.357] receiveMessageFromWorker() for ClusterFuture ...
[17:48:03.357] - Validating connection of MultisessionFuture
[17:48:03.357] - received message: FutureResult
[17:48:03.357] - Received FutureResult
[17:48:03.357] - Erased future from FutureRegistry
[17:48:03.358] result() for ClusterFuture ...
[17:48:03.358] - result already collected: FutureResult
[17:48:03.358] result() for ClusterFuture ... done
[17:48:03.358] signalConditions() ...
[17:48:03.358]  - include = ‘immediateCondition’
[17:48:03.358]  - exclude = 
[17:48:03.358]  - resignal = FALSE
[17:48:03.358]  - Number of conditions: 1
[17:48:03.358] signalConditions() ... done
[17:48:03.358] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:03.358] A MultisessionFuture was resolved (result was not collected)
[17:48:03.359] getGlobalsAndPackages() ...
[17:48:03.359] Searching for globals...
[17:48:03.359] - globals found: [2] ‘list’, ‘stop’
[17:48:03.359] Searching for globals ... DONE
[17:48:03.360] Resolving globals: FALSE
[17:48:03.360] 
[17:48:03.360] 
[17:48:03.360] getGlobalsAndPackages() ... DONE
[17:48:03.360] run() for ‘Future’ ...
[17:48:03.360] - state: ‘created’
[17:48:03.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:03.374] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:03.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:03.374]   - Field: ‘node’
[17:48:03.374]   - Field: ‘label’
[17:48:03.374]   - Field: ‘local’
[17:48:03.374]   - Field: ‘owner’
[17:48:03.374]   - Field: ‘envir’
[17:48:03.374]   - Field: ‘workers’
[17:48:03.375]   - Field: ‘packages’
[17:48:03.375]   - Field: ‘gc’
[17:48:03.375]   - Field: ‘conditions’
[17:48:03.375]   - Field: ‘persistent’
[17:48:03.375]   - Field: ‘expr’
[17:48:03.375]   - Field: ‘uuid’
[17:48:03.375]   - Field: ‘seed’
[17:48:03.375]   - Field: ‘version’
[17:48:03.375]   - Field: ‘result’
[17:48:03.375]   - Field: ‘asynchronous’
[17:48:03.375]   - Field: ‘calls’
[17:48:03.376]   - Field: ‘globals’
[17:48:03.376]   - Field: ‘stdout’
[17:48:03.376]   - Field: ‘earlySignal’
[17:48:03.376]   - Field: ‘lazy’
[17:48:03.376]   - Field: ‘state’
[17:48:03.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:03.376] - Launch lazy future ...
[17:48:03.376] Packages needed by the future expression (n = 0): <none>
[17:48:03.376] Packages needed by future strategies (n = 0): <none>
[17:48:03.377] {
[17:48:03.377]     {
[17:48:03.377]         {
[17:48:03.377]             ...future.startTime <- base::Sys.time()
[17:48:03.377]             {
[17:48:03.377]                 {
[17:48:03.377]                   {
[17:48:03.377]                     {
[17:48:03.377]                       base::local({
[17:48:03.377]                         has_future <- base::requireNamespace("future", 
[17:48:03.377]                           quietly = TRUE)
[17:48:03.377]                         if (has_future) {
[17:48:03.377]                           ns <- base::getNamespace("future")
[17:48:03.377]                           version <- ns[[".package"]][["version"]]
[17:48:03.377]                           if (is.null(version)) 
[17:48:03.377]                             version <- utils::packageVersion("future")
[17:48:03.377]                         }
[17:48:03.377]                         else {
[17:48:03.377]                           version <- NULL
[17:48:03.377]                         }
[17:48:03.377]                         if (!has_future || version < "1.8.0") {
[17:48:03.377]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:03.377]                             "", base::R.version$version.string), 
[17:48:03.377]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:03.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:03.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:03.377]                               "release", "version")], collapse = " "), 
[17:48:03.377]                             hostname = base::Sys.info()[["nodename"]])
[17:48:03.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:03.377]                             info)
[17:48:03.377]                           info <- base::paste(info, collapse = "; ")
[17:48:03.377]                           if (!has_future) {
[17:48:03.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:03.377]                               info)
[17:48:03.377]                           }
[17:48:03.377]                           else {
[17:48:03.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:03.377]                               info, version)
[17:48:03.377]                           }
[17:48:03.377]                           base::stop(msg)
[17:48:03.377]                         }
[17:48:03.377]                       })
[17:48:03.377]                     }
[17:48:03.377]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:03.377]                     base::options(mc.cores = 1L)
[17:48:03.377]                   }
[17:48:03.377]                   ...future.strategy.old <- future::plan("list")
[17:48:03.377]                   options(future.plan = NULL)
[17:48:03.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:03.377]                 }
[17:48:03.377]                 ...future.workdir <- getwd()
[17:48:03.377]             }
[17:48:03.377]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:03.377]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:03.377]         }
[17:48:03.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:03.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:03.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:03.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:03.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:03.377]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:03.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:03.377]             base::names(...future.oldOptions))
[17:48:03.377]     }
[17:48:03.377]     if (FALSE) {
[17:48:03.377]     }
[17:48:03.377]     else {
[17:48:03.377]         if (TRUE) {
[17:48:03.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:03.377]                 open = "w")
[17:48:03.377]         }
[17:48:03.377]         else {
[17:48:03.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:03.377]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:03.377]         }
[17:48:03.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:03.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:03.377]             base::sink(type = "output", split = FALSE)
[17:48:03.377]             base::close(...future.stdout)
[17:48:03.377]         }, add = TRUE)
[17:48:03.377]     }
[17:48:03.377]     ...future.frame <- base::sys.nframe()
[17:48:03.377]     ...future.conditions <- base::list()
[17:48:03.377]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:03.377]     if (FALSE) {
[17:48:03.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:03.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:03.377]     }
[17:48:03.377]     ...future.result <- base::tryCatch({
[17:48:03.377]         base::withCallingHandlers({
[17:48:03.377]             ...future.value <- base::withVisible(base::local({
[17:48:03.377]                 ...future.makeSendCondition <- base::local({
[17:48:03.377]                   sendCondition <- NULL
[17:48:03.377]                   function(frame = 1L) {
[17:48:03.377]                     if (is.function(sendCondition)) 
[17:48:03.377]                       return(sendCondition)
[17:48:03.377]                     ns <- getNamespace("parallel")
[17:48:03.377]                     if (exists("sendData", mode = "function", 
[17:48:03.377]                       envir = ns)) {
[17:48:03.377]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:03.377]                         envir = ns)
[17:48:03.377]                       envir <- sys.frame(frame)
[17:48:03.377]                       master <- NULL
[17:48:03.377]                       while (!identical(envir, .GlobalEnv) && 
[17:48:03.377]                         !identical(envir, emptyenv())) {
[17:48:03.377]                         if (exists("master", mode = "list", envir = envir, 
[17:48:03.377]                           inherits = FALSE)) {
[17:48:03.377]                           master <- get("master", mode = "list", 
[17:48:03.377]                             envir = envir, inherits = FALSE)
[17:48:03.377]                           if (inherits(master, c("SOCKnode", 
[17:48:03.377]                             "SOCK0node"))) {
[17:48:03.377]                             sendCondition <<- function(cond) {
[17:48:03.377]                               data <- list(type = "VALUE", value = cond, 
[17:48:03.377]                                 success = TRUE)
[17:48:03.377]                               parallel_sendData(master, data)
[17:48:03.377]                             }
[17:48:03.377]                             return(sendCondition)
[17:48:03.377]                           }
[17:48:03.377]                         }
[17:48:03.377]                         frame <- frame + 1L
[17:48:03.377]                         envir <- sys.frame(frame)
[17:48:03.377]                       }
[17:48:03.377]                     }
[17:48:03.377]                     sendCondition <<- function(cond) NULL
[17:48:03.377]                   }
[17:48:03.377]                 })
[17:48:03.377]                 withCallingHandlers({
[17:48:03.377]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:03.377]                 }, immediateCondition = function(cond) {
[17:48:03.377]                   sendCondition <- ...future.makeSendCondition()
[17:48:03.377]                   sendCondition(cond)
[17:48:03.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.377]                   {
[17:48:03.377]                     inherits <- base::inherits
[17:48:03.377]                     invokeRestart <- base::invokeRestart
[17:48:03.377]                     is.null <- base::is.null
[17:48:03.377]                     muffled <- FALSE
[17:48:03.377]                     if (inherits(cond, "message")) {
[17:48:03.377]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:03.377]                       if (muffled) 
[17:48:03.377]                         invokeRestart("muffleMessage")
[17:48:03.377]                     }
[17:48:03.377]                     else if (inherits(cond, "warning")) {
[17:48:03.377]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:03.377]                       if (muffled) 
[17:48:03.377]                         invokeRestart("muffleWarning")
[17:48:03.377]                     }
[17:48:03.377]                     else if (inherits(cond, "condition")) {
[17:48:03.377]                       if (!is.null(pattern)) {
[17:48:03.377]                         computeRestarts <- base::computeRestarts
[17:48:03.377]                         grepl <- base::grepl
[17:48:03.377]                         restarts <- computeRestarts(cond)
[17:48:03.377]                         for (restart in restarts) {
[17:48:03.377]                           name <- restart$name
[17:48:03.377]                           if (is.null(name)) 
[17:48:03.377]                             next
[17:48:03.377]                           if (!grepl(pattern, name)) 
[17:48:03.377]                             next
[17:48:03.377]                           invokeRestart(restart)
[17:48:03.377]                           muffled <- TRUE
[17:48:03.377]                           break
[17:48:03.377]                         }
[17:48:03.377]                       }
[17:48:03.377]                     }
[17:48:03.377]                     invisible(muffled)
[17:48:03.377]                   }
[17:48:03.377]                   muffleCondition(cond)
[17:48:03.377]                 })
[17:48:03.377]             }))
[17:48:03.377]             future::FutureResult(value = ...future.value$value, 
[17:48:03.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.377]                   ...future.rng), globalenv = if (FALSE) 
[17:48:03.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:03.377]                     ...future.globalenv.names))
[17:48:03.377]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:03.377]         }, condition = base::local({
[17:48:03.377]             c <- base::c
[17:48:03.377]             inherits <- base::inherits
[17:48:03.377]             invokeRestart <- base::invokeRestart
[17:48:03.377]             length <- base::length
[17:48:03.377]             list <- base::list
[17:48:03.377]             seq.int <- base::seq.int
[17:48:03.377]             signalCondition <- base::signalCondition
[17:48:03.377]             sys.calls <- base::sys.calls
[17:48:03.377]             `[[` <- base::`[[`
[17:48:03.377]             `+` <- base::`+`
[17:48:03.377]             `<<-` <- base::`<<-`
[17:48:03.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:03.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:03.377]                   3L)]
[17:48:03.377]             }
[17:48:03.377]             function(cond) {
[17:48:03.377]                 is_error <- inherits(cond, "error")
[17:48:03.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:03.377]                   NULL)
[17:48:03.377]                 if (is_error) {
[17:48:03.377]                   sessionInformation <- function() {
[17:48:03.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:03.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:03.377]                       search = base::search(), system = base::Sys.info())
[17:48:03.377]                   }
[17:48:03.377]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:03.377]                     cond$call), session = sessionInformation(), 
[17:48:03.377]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:03.377]                   signalCondition(cond)
[17:48:03.377]                 }
[17:48:03.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:03.377]                 "immediateCondition"))) {
[17:48:03.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:03.377]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:03.377]                   if (TRUE && !signal) {
[17:48:03.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.377]                     {
[17:48:03.377]                       inherits <- base::inherits
[17:48:03.377]                       invokeRestart <- base::invokeRestart
[17:48:03.377]                       is.null <- base::is.null
[17:48:03.377]                       muffled <- FALSE
[17:48:03.377]                       if (inherits(cond, "message")) {
[17:48:03.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.377]                         if (muffled) 
[17:48:03.377]                           invokeRestart("muffleMessage")
[17:48:03.377]                       }
[17:48:03.377]                       else if (inherits(cond, "warning")) {
[17:48:03.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.377]                         if (muffled) 
[17:48:03.377]                           invokeRestart("muffleWarning")
[17:48:03.377]                       }
[17:48:03.377]                       else if (inherits(cond, "condition")) {
[17:48:03.377]                         if (!is.null(pattern)) {
[17:48:03.377]                           computeRestarts <- base::computeRestarts
[17:48:03.377]                           grepl <- base::grepl
[17:48:03.377]                           restarts <- computeRestarts(cond)
[17:48:03.377]                           for (restart in restarts) {
[17:48:03.377]                             name <- restart$name
[17:48:03.377]                             if (is.null(name)) 
[17:48:03.377]                               next
[17:48:03.377]                             if (!grepl(pattern, name)) 
[17:48:03.377]                               next
[17:48:03.377]                             invokeRestart(restart)
[17:48:03.377]                             muffled <- TRUE
[17:48:03.377]                             break
[17:48:03.377]                           }
[17:48:03.377]                         }
[17:48:03.377]                       }
[17:48:03.377]                       invisible(muffled)
[17:48:03.377]                     }
[17:48:03.377]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.377]                   }
[17:48:03.377]                 }
[17:48:03.377]                 else {
[17:48:03.377]                   if (TRUE) {
[17:48:03.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.377]                     {
[17:48:03.377]                       inherits <- base::inherits
[17:48:03.377]                       invokeRestart <- base::invokeRestart
[17:48:03.377]                       is.null <- base::is.null
[17:48:03.377]                       muffled <- FALSE
[17:48:03.377]                       if (inherits(cond, "message")) {
[17:48:03.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.377]                         if (muffled) 
[17:48:03.377]                           invokeRestart("muffleMessage")
[17:48:03.377]                       }
[17:48:03.377]                       else if (inherits(cond, "warning")) {
[17:48:03.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.377]                         if (muffled) 
[17:48:03.377]                           invokeRestart("muffleWarning")
[17:48:03.377]                       }
[17:48:03.377]                       else if (inherits(cond, "condition")) {
[17:48:03.377]                         if (!is.null(pattern)) {
[17:48:03.377]                           computeRestarts <- base::computeRestarts
[17:48:03.377]                           grepl <- base::grepl
[17:48:03.377]                           restarts <- computeRestarts(cond)
[17:48:03.377]                           for (restart in restarts) {
[17:48:03.377]                             name <- restart$name
[17:48:03.377]                             if (is.null(name)) 
[17:48:03.377]                               next
[17:48:03.377]                             if (!grepl(pattern, name)) 
[17:48:03.377]                               next
[17:48:03.377]                             invokeRestart(restart)
[17:48:03.377]                             muffled <- TRUE
[17:48:03.377]                             break
[17:48:03.377]                           }
[17:48:03.377]                         }
[17:48:03.377]                       }
[17:48:03.377]                       invisible(muffled)
[17:48:03.377]                     }
[17:48:03.377]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.377]                   }
[17:48:03.377]                 }
[17:48:03.377]             }
[17:48:03.377]         }))
[17:48:03.377]     }, error = function(ex) {
[17:48:03.377]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:03.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.377]                 ...future.rng), started = ...future.startTime, 
[17:48:03.377]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:03.377]             version = "1.8"), class = "FutureResult")
[17:48:03.377]     }, finally = {
[17:48:03.377]         if (!identical(...future.workdir, getwd())) 
[17:48:03.377]             setwd(...future.workdir)
[17:48:03.377]         {
[17:48:03.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:03.377]                 ...future.oldOptions$nwarnings <- NULL
[17:48:03.377]             }
[17:48:03.377]             base::options(...future.oldOptions)
[17:48:03.377]             if (.Platform$OS.type == "windows") {
[17:48:03.377]                 old_names <- names(...future.oldEnvVars)
[17:48:03.377]                 envs <- base::Sys.getenv()
[17:48:03.377]                 names <- names(envs)
[17:48:03.377]                 common <- intersect(names, old_names)
[17:48:03.377]                 added <- setdiff(names, old_names)
[17:48:03.377]                 removed <- setdiff(old_names, names)
[17:48:03.377]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:03.377]                   envs[common]]
[17:48:03.377]                 NAMES <- toupper(changed)
[17:48:03.377]                 args <- list()
[17:48:03.377]                 for (kk in seq_along(NAMES)) {
[17:48:03.377]                   name <- changed[[kk]]
[17:48:03.377]                   NAME <- NAMES[[kk]]
[17:48:03.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.377]                     next
[17:48:03.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.377]                 }
[17:48:03.377]                 NAMES <- toupper(added)
[17:48:03.377]                 for (kk in seq_along(NAMES)) {
[17:48:03.377]                   name <- added[[kk]]
[17:48:03.377]                   NAME <- NAMES[[kk]]
[17:48:03.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.377]                     next
[17:48:03.377]                   args[[name]] <- ""
[17:48:03.377]                 }
[17:48:03.377]                 NAMES <- toupper(removed)
[17:48:03.377]                 for (kk in seq_along(NAMES)) {
[17:48:03.377]                   name <- removed[[kk]]
[17:48:03.377]                   NAME <- NAMES[[kk]]
[17:48:03.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.377]                     next
[17:48:03.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.377]                 }
[17:48:03.377]                 if (length(args) > 0) 
[17:48:03.377]                   base::do.call(base::Sys.setenv, args = args)
[17:48:03.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:03.377]             }
[17:48:03.377]             else {
[17:48:03.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:03.377]             }
[17:48:03.377]             {
[17:48:03.377]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:03.377]                   0L) {
[17:48:03.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:03.377]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:03.377]                   base::options(opts)
[17:48:03.377]                 }
[17:48:03.377]                 {
[17:48:03.377]                   {
[17:48:03.377]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:03.377]                     NULL
[17:48:03.377]                   }
[17:48:03.377]                   options(future.plan = NULL)
[17:48:03.377]                   if (is.na(NA_character_)) 
[17:48:03.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:03.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:03.377]                     .init = FALSE)
[17:48:03.377]                 }
[17:48:03.377]             }
[17:48:03.377]         }
[17:48:03.377]     })
[17:48:03.377]     if (TRUE) {
[17:48:03.377]         base::sink(type = "output", split = FALSE)
[17:48:03.377]         if (TRUE) {
[17:48:03.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:03.377]         }
[17:48:03.377]         else {
[17:48:03.377]             ...future.result["stdout"] <- base::list(NULL)
[17:48:03.377]         }
[17:48:03.377]         base::close(...future.stdout)
[17:48:03.377]         ...future.stdout <- NULL
[17:48:03.377]     }
[17:48:03.377]     ...future.result$conditions <- ...future.conditions
[17:48:03.377]     ...future.result$finished <- base::Sys.time()
[17:48:03.377]     ...future.result
[17:48:03.377] }
[17:48:03.380] MultisessionFuture started
[17:48:03.380] - Launch lazy future ... done
[17:48:03.380] run() for ‘MultisessionFuture’ ... done
[17:48:03.381] receiveMessageFromWorker() for ClusterFuture ...
[17:48:03.381] - Validating connection of MultisessionFuture
[17:48:03.382] - received message: FutureResult
[17:48:03.382] - Received FutureResult
[17:48:03.382] - Erased future from FutureRegistry
[17:48:03.382] result() for ClusterFuture ...
[17:48:03.382] - result already collected: FutureResult
[17:48:03.382] result() for ClusterFuture ... done
[17:48:03.382] signalConditions() ...
[17:48:03.382]  - include = ‘immediateCondition’
[17:48:03.382]  - exclude = 
[17:48:03.383]  - resignal = FALSE
[17:48:03.383]  - Number of conditions: 1
[17:48:03.383] signalConditions() ... done
[17:48:03.383] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:03.383] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[17:48:03.383] getGlobalsAndPackages() ...
[17:48:03.383] Searching for globals...
[17:48:03.384] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:03.384] Searching for globals ... DONE
[17:48:03.384] Resolving globals: FALSE
[17:48:03.385] 
[17:48:03.385] 
[17:48:03.385] getGlobalsAndPackages() ... DONE
[17:48:03.385] run() for ‘Future’ ...
[17:48:03.385] - state: ‘created’
[17:48:03.385] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:03.399] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:03.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:03.400]   - Field: ‘node’
[17:48:03.400]   - Field: ‘label’
[17:48:03.400]   - Field: ‘local’
[17:48:03.400]   - Field: ‘owner’
[17:48:03.400]   - Field: ‘envir’
[17:48:03.400]   - Field: ‘workers’
[17:48:03.400]   - Field: ‘packages’
[17:48:03.400]   - Field: ‘gc’
[17:48:03.400]   - Field: ‘conditions’
[17:48:03.400]   - Field: ‘persistent’
[17:48:03.401]   - Field: ‘expr’
[17:48:03.401]   - Field: ‘uuid’
[17:48:03.401]   - Field: ‘seed’
[17:48:03.401]   - Field: ‘version’
[17:48:03.401]   - Field: ‘result’
[17:48:03.401]   - Field: ‘asynchronous’
[17:48:03.401]   - Field: ‘calls’
[17:48:03.401]   - Field: ‘globals’
[17:48:03.401]   - Field: ‘stdout’
[17:48:03.401]   - Field: ‘earlySignal’
[17:48:03.401]   - Field: ‘lazy’
[17:48:03.402]   - Field: ‘state’
[17:48:03.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:03.402] - Launch lazy future ...
[17:48:03.402] Packages needed by the future expression (n = 0): <none>
[17:48:03.402] Packages needed by future strategies (n = 0): <none>
[17:48:03.403] {
[17:48:03.403]     {
[17:48:03.403]         {
[17:48:03.403]             ...future.startTime <- base::Sys.time()
[17:48:03.403]             {
[17:48:03.403]                 {
[17:48:03.403]                   {
[17:48:03.403]                     {
[17:48:03.403]                       base::local({
[17:48:03.403]                         has_future <- base::requireNamespace("future", 
[17:48:03.403]                           quietly = TRUE)
[17:48:03.403]                         if (has_future) {
[17:48:03.403]                           ns <- base::getNamespace("future")
[17:48:03.403]                           version <- ns[[".package"]][["version"]]
[17:48:03.403]                           if (is.null(version)) 
[17:48:03.403]                             version <- utils::packageVersion("future")
[17:48:03.403]                         }
[17:48:03.403]                         else {
[17:48:03.403]                           version <- NULL
[17:48:03.403]                         }
[17:48:03.403]                         if (!has_future || version < "1.8.0") {
[17:48:03.403]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:03.403]                             "", base::R.version$version.string), 
[17:48:03.403]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:03.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:03.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:03.403]                               "release", "version")], collapse = " "), 
[17:48:03.403]                             hostname = base::Sys.info()[["nodename"]])
[17:48:03.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:03.403]                             info)
[17:48:03.403]                           info <- base::paste(info, collapse = "; ")
[17:48:03.403]                           if (!has_future) {
[17:48:03.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:03.403]                               info)
[17:48:03.403]                           }
[17:48:03.403]                           else {
[17:48:03.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:03.403]                               info, version)
[17:48:03.403]                           }
[17:48:03.403]                           base::stop(msg)
[17:48:03.403]                         }
[17:48:03.403]                       })
[17:48:03.403]                     }
[17:48:03.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:03.403]                     base::options(mc.cores = 1L)
[17:48:03.403]                   }
[17:48:03.403]                   ...future.strategy.old <- future::plan("list")
[17:48:03.403]                   options(future.plan = NULL)
[17:48:03.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:03.403]                 }
[17:48:03.403]                 ...future.workdir <- getwd()
[17:48:03.403]             }
[17:48:03.403]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:03.403]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:03.403]         }
[17:48:03.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:03.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:03.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:03.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:03.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:03.403]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:03.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:03.403]             base::names(...future.oldOptions))
[17:48:03.403]     }
[17:48:03.403]     if (FALSE) {
[17:48:03.403]     }
[17:48:03.403]     else {
[17:48:03.403]         if (TRUE) {
[17:48:03.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:03.403]                 open = "w")
[17:48:03.403]         }
[17:48:03.403]         else {
[17:48:03.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:03.403]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:03.403]         }
[17:48:03.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:03.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:03.403]             base::sink(type = "output", split = FALSE)
[17:48:03.403]             base::close(...future.stdout)
[17:48:03.403]         }, add = TRUE)
[17:48:03.403]     }
[17:48:03.403]     ...future.frame <- base::sys.nframe()
[17:48:03.403]     ...future.conditions <- base::list()
[17:48:03.403]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:03.403]     if (FALSE) {
[17:48:03.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:03.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:03.403]     }
[17:48:03.403]     ...future.result <- base::tryCatch({
[17:48:03.403]         base::withCallingHandlers({
[17:48:03.403]             ...future.value <- base::withVisible(base::local({
[17:48:03.403]                 ...future.makeSendCondition <- base::local({
[17:48:03.403]                   sendCondition <- NULL
[17:48:03.403]                   function(frame = 1L) {
[17:48:03.403]                     if (is.function(sendCondition)) 
[17:48:03.403]                       return(sendCondition)
[17:48:03.403]                     ns <- getNamespace("parallel")
[17:48:03.403]                     if (exists("sendData", mode = "function", 
[17:48:03.403]                       envir = ns)) {
[17:48:03.403]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:03.403]                         envir = ns)
[17:48:03.403]                       envir <- sys.frame(frame)
[17:48:03.403]                       master <- NULL
[17:48:03.403]                       while (!identical(envir, .GlobalEnv) && 
[17:48:03.403]                         !identical(envir, emptyenv())) {
[17:48:03.403]                         if (exists("master", mode = "list", envir = envir, 
[17:48:03.403]                           inherits = FALSE)) {
[17:48:03.403]                           master <- get("master", mode = "list", 
[17:48:03.403]                             envir = envir, inherits = FALSE)
[17:48:03.403]                           if (inherits(master, c("SOCKnode", 
[17:48:03.403]                             "SOCK0node"))) {
[17:48:03.403]                             sendCondition <<- function(cond) {
[17:48:03.403]                               data <- list(type = "VALUE", value = cond, 
[17:48:03.403]                                 success = TRUE)
[17:48:03.403]                               parallel_sendData(master, data)
[17:48:03.403]                             }
[17:48:03.403]                             return(sendCondition)
[17:48:03.403]                           }
[17:48:03.403]                         }
[17:48:03.403]                         frame <- frame + 1L
[17:48:03.403]                         envir <- sys.frame(frame)
[17:48:03.403]                       }
[17:48:03.403]                     }
[17:48:03.403]                     sendCondition <<- function(cond) NULL
[17:48:03.403]                   }
[17:48:03.403]                 })
[17:48:03.403]                 withCallingHandlers({
[17:48:03.403]                   {
[17:48:03.403]                     Sys.sleep(0.5)
[17:48:03.403]                     list(a = 1, b = 42L)
[17:48:03.403]                   }
[17:48:03.403]                 }, immediateCondition = function(cond) {
[17:48:03.403]                   sendCondition <- ...future.makeSendCondition()
[17:48:03.403]                   sendCondition(cond)
[17:48:03.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.403]                   {
[17:48:03.403]                     inherits <- base::inherits
[17:48:03.403]                     invokeRestart <- base::invokeRestart
[17:48:03.403]                     is.null <- base::is.null
[17:48:03.403]                     muffled <- FALSE
[17:48:03.403]                     if (inherits(cond, "message")) {
[17:48:03.403]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:03.403]                       if (muffled) 
[17:48:03.403]                         invokeRestart("muffleMessage")
[17:48:03.403]                     }
[17:48:03.403]                     else if (inherits(cond, "warning")) {
[17:48:03.403]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:03.403]                       if (muffled) 
[17:48:03.403]                         invokeRestart("muffleWarning")
[17:48:03.403]                     }
[17:48:03.403]                     else if (inherits(cond, "condition")) {
[17:48:03.403]                       if (!is.null(pattern)) {
[17:48:03.403]                         computeRestarts <- base::computeRestarts
[17:48:03.403]                         grepl <- base::grepl
[17:48:03.403]                         restarts <- computeRestarts(cond)
[17:48:03.403]                         for (restart in restarts) {
[17:48:03.403]                           name <- restart$name
[17:48:03.403]                           if (is.null(name)) 
[17:48:03.403]                             next
[17:48:03.403]                           if (!grepl(pattern, name)) 
[17:48:03.403]                             next
[17:48:03.403]                           invokeRestart(restart)
[17:48:03.403]                           muffled <- TRUE
[17:48:03.403]                           break
[17:48:03.403]                         }
[17:48:03.403]                       }
[17:48:03.403]                     }
[17:48:03.403]                     invisible(muffled)
[17:48:03.403]                   }
[17:48:03.403]                   muffleCondition(cond)
[17:48:03.403]                 })
[17:48:03.403]             }))
[17:48:03.403]             future::FutureResult(value = ...future.value$value, 
[17:48:03.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.403]                   ...future.rng), globalenv = if (FALSE) 
[17:48:03.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:03.403]                     ...future.globalenv.names))
[17:48:03.403]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:03.403]         }, condition = base::local({
[17:48:03.403]             c <- base::c
[17:48:03.403]             inherits <- base::inherits
[17:48:03.403]             invokeRestart <- base::invokeRestart
[17:48:03.403]             length <- base::length
[17:48:03.403]             list <- base::list
[17:48:03.403]             seq.int <- base::seq.int
[17:48:03.403]             signalCondition <- base::signalCondition
[17:48:03.403]             sys.calls <- base::sys.calls
[17:48:03.403]             `[[` <- base::`[[`
[17:48:03.403]             `+` <- base::`+`
[17:48:03.403]             `<<-` <- base::`<<-`
[17:48:03.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:03.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:03.403]                   3L)]
[17:48:03.403]             }
[17:48:03.403]             function(cond) {
[17:48:03.403]                 is_error <- inherits(cond, "error")
[17:48:03.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:03.403]                   NULL)
[17:48:03.403]                 if (is_error) {
[17:48:03.403]                   sessionInformation <- function() {
[17:48:03.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:03.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:03.403]                       search = base::search(), system = base::Sys.info())
[17:48:03.403]                   }
[17:48:03.403]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:03.403]                     cond$call), session = sessionInformation(), 
[17:48:03.403]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:03.403]                   signalCondition(cond)
[17:48:03.403]                 }
[17:48:03.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:03.403]                 "immediateCondition"))) {
[17:48:03.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:03.403]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:03.403]                   if (TRUE && !signal) {
[17:48:03.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.403]                     {
[17:48:03.403]                       inherits <- base::inherits
[17:48:03.403]                       invokeRestart <- base::invokeRestart
[17:48:03.403]                       is.null <- base::is.null
[17:48:03.403]                       muffled <- FALSE
[17:48:03.403]                       if (inherits(cond, "message")) {
[17:48:03.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.403]                         if (muffled) 
[17:48:03.403]                           invokeRestart("muffleMessage")
[17:48:03.403]                       }
[17:48:03.403]                       else if (inherits(cond, "warning")) {
[17:48:03.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.403]                         if (muffled) 
[17:48:03.403]                           invokeRestart("muffleWarning")
[17:48:03.403]                       }
[17:48:03.403]                       else if (inherits(cond, "condition")) {
[17:48:03.403]                         if (!is.null(pattern)) {
[17:48:03.403]                           computeRestarts <- base::computeRestarts
[17:48:03.403]                           grepl <- base::grepl
[17:48:03.403]                           restarts <- computeRestarts(cond)
[17:48:03.403]                           for (restart in restarts) {
[17:48:03.403]                             name <- restart$name
[17:48:03.403]                             if (is.null(name)) 
[17:48:03.403]                               next
[17:48:03.403]                             if (!grepl(pattern, name)) 
[17:48:03.403]                               next
[17:48:03.403]                             invokeRestart(restart)
[17:48:03.403]                             muffled <- TRUE
[17:48:03.403]                             break
[17:48:03.403]                           }
[17:48:03.403]                         }
[17:48:03.403]                       }
[17:48:03.403]                       invisible(muffled)
[17:48:03.403]                     }
[17:48:03.403]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.403]                   }
[17:48:03.403]                 }
[17:48:03.403]                 else {
[17:48:03.403]                   if (TRUE) {
[17:48:03.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.403]                     {
[17:48:03.403]                       inherits <- base::inherits
[17:48:03.403]                       invokeRestart <- base::invokeRestart
[17:48:03.403]                       is.null <- base::is.null
[17:48:03.403]                       muffled <- FALSE
[17:48:03.403]                       if (inherits(cond, "message")) {
[17:48:03.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.403]                         if (muffled) 
[17:48:03.403]                           invokeRestart("muffleMessage")
[17:48:03.403]                       }
[17:48:03.403]                       else if (inherits(cond, "warning")) {
[17:48:03.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.403]                         if (muffled) 
[17:48:03.403]                           invokeRestart("muffleWarning")
[17:48:03.403]                       }
[17:48:03.403]                       else if (inherits(cond, "condition")) {
[17:48:03.403]                         if (!is.null(pattern)) {
[17:48:03.403]                           computeRestarts <- base::computeRestarts
[17:48:03.403]                           grepl <- base::grepl
[17:48:03.403]                           restarts <- computeRestarts(cond)
[17:48:03.403]                           for (restart in restarts) {
[17:48:03.403]                             name <- restart$name
[17:48:03.403]                             if (is.null(name)) 
[17:48:03.403]                               next
[17:48:03.403]                             if (!grepl(pattern, name)) 
[17:48:03.403]                               next
[17:48:03.403]                             invokeRestart(restart)
[17:48:03.403]                             muffled <- TRUE
[17:48:03.403]                             break
[17:48:03.403]                           }
[17:48:03.403]                         }
[17:48:03.403]                       }
[17:48:03.403]                       invisible(muffled)
[17:48:03.403]                     }
[17:48:03.403]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.403]                   }
[17:48:03.403]                 }
[17:48:03.403]             }
[17:48:03.403]         }))
[17:48:03.403]     }, error = function(ex) {
[17:48:03.403]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:03.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.403]                 ...future.rng), started = ...future.startTime, 
[17:48:03.403]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:03.403]             version = "1.8"), class = "FutureResult")
[17:48:03.403]     }, finally = {
[17:48:03.403]         if (!identical(...future.workdir, getwd())) 
[17:48:03.403]             setwd(...future.workdir)
[17:48:03.403]         {
[17:48:03.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:03.403]                 ...future.oldOptions$nwarnings <- NULL
[17:48:03.403]             }
[17:48:03.403]             base::options(...future.oldOptions)
[17:48:03.403]             if (.Platform$OS.type == "windows") {
[17:48:03.403]                 old_names <- names(...future.oldEnvVars)
[17:48:03.403]                 envs <- base::Sys.getenv()
[17:48:03.403]                 names <- names(envs)
[17:48:03.403]                 common <- intersect(names, old_names)
[17:48:03.403]                 added <- setdiff(names, old_names)
[17:48:03.403]                 removed <- setdiff(old_names, names)
[17:48:03.403]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:03.403]                   envs[common]]
[17:48:03.403]                 NAMES <- toupper(changed)
[17:48:03.403]                 args <- list()
[17:48:03.403]                 for (kk in seq_along(NAMES)) {
[17:48:03.403]                   name <- changed[[kk]]
[17:48:03.403]                   NAME <- NAMES[[kk]]
[17:48:03.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.403]                     next
[17:48:03.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.403]                 }
[17:48:03.403]                 NAMES <- toupper(added)
[17:48:03.403]                 for (kk in seq_along(NAMES)) {
[17:48:03.403]                   name <- added[[kk]]
[17:48:03.403]                   NAME <- NAMES[[kk]]
[17:48:03.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.403]                     next
[17:48:03.403]                   args[[name]] <- ""
[17:48:03.403]                 }
[17:48:03.403]                 NAMES <- toupper(removed)
[17:48:03.403]                 for (kk in seq_along(NAMES)) {
[17:48:03.403]                   name <- removed[[kk]]
[17:48:03.403]                   NAME <- NAMES[[kk]]
[17:48:03.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.403]                     next
[17:48:03.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.403]                 }
[17:48:03.403]                 if (length(args) > 0) 
[17:48:03.403]                   base::do.call(base::Sys.setenv, args = args)
[17:48:03.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:03.403]             }
[17:48:03.403]             else {
[17:48:03.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:03.403]             }
[17:48:03.403]             {
[17:48:03.403]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:03.403]                   0L) {
[17:48:03.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:03.403]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:03.403]                   base::options(opts)
[17:48:03.403]                 }
[17:48:03.403]                 {
[17:48:03.403]                   {
[17:48:03.403]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:03.403]                     NULL
[17:48:03.403]                   }
[17:48:03.403]                   options(future.plan = NULL)
[17:48:03.403]                   if (is.na(NA_character_)) 
[17:48:03.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:03.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:03.403]                     .init = FALSE)
[17:48:03.403]                 }
[17:48:03.403]             }
[17:48:03.403]         }
[17:48:03.403]     })
[17:48:03.403]     if (TRUE) {
[17:48:03.403]         base::sink(type = "output", split = FALSE)
[17:48:03.403]         if (TRUE) {
[17:48:03.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:03.403]         }
[17:48:03.403]         else {
[17:48:03.403]             ...future.result["stdout"] <- base::list(NULL)
[17:48:03.403]         }
[17:48:03.403]         base::close(...future.stdout)
[17:48:03.403]         ...future.stdout <- NULL
[17:48:03.403]     }
[17:48:03.403]     ...future.result$conditions <- ...future.conditions
[17:48:03.403]     ...future.result$finished <- base::Sys.time()
[17:48:03.403]     ...future.result
[17:48:03.403] }
[17:48:03.405] MultisessionFuture started
[17:48:03.406] - Launch lazy future ... done
[17:48:03.406] run() for ‘MultisessionFuture’ ... done
[17:48:03.908] receiveMessageFromWorker() for ClusterFuture ...
[17:48:03.908] - Validating connection of MultisessionFuture
[17:48:03.909] - received message: FutureResult
[17:48:03.909] - Received FutureResult
[17:48:03.909] - Erased future from FutureRegistry
[17:48:03.909] result() for ClusterFuture ...
[17:48:03.909] - result already collected: FutureResult
[17:48:03.909] result() for ClusterFuture ... done
[17:48:03.909] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:03.909] A MultisessionFuture was resolved
[17:48:03.909] getGlobalsAndPackages() ...
[17:48:03.910] Searching for globals...
[17:48:03.911] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:03.911] Searching for globals ... DONE
[17:48:03.911] Resolving globals: FALSE
[17:48:03.911] 
[17:48:03.911] 
[17:48:03.911] getGlobalsAndPackages() ... DONE
[17:48:03.912] run() for ‘Future’ ...
[17:48:03.912] - state: ‘created’
[17:48:03.912] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:03.926] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:03.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:03.926]   - Field: ‘node’
[17:48:03.926]   - Field: ‘label’
[17:48:03.926]   - Field: ‘local’
[17:48:03.927]   - Field: ‘owner’
[17:48:03.927]   - Field: ‘envir’
[17:48:03.927]   - Field: ‘workers’
[17:48:03.927]   - Field: ‘packages’
[17:48:03.927]   - Field: ‘gc’
[17:48:03.927]   - Field: ‘conditions’
[17:48:03.927]   - Field: ‘persistent’
[17:48:03.927]   - Field: ‘expr’
[17:48:03.927]   - Field: ‘uuid’
[17:48:03.927]   - Field: ‘seed’
[17:48:03.928]   - Field: ‘version’
[17:48:03.928]   - Field: ‘result’
[17:48:03.928]   - Field: ‘asynchronous’
[17:48:03.928]   - Field: ‘calls’
[17:48:03.928]   - Field: ‘globals’
[17:48:03.928]   - Field: ‘stdout’
[17:48:03.928]   - Field: ‘earlySignal’
[17:48:03.928]   - Field: ‘lazy’
[17:48:03.928]   - Field: ‘state’
[17:48:03.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:03.928] - Launch lazy future ...
[17:48:03.929] Packages needed by the future expression (n = 0): <none>
[17:48:03.929] Packages needed by future strategies (n = 0): <none>
[17:48:03.929] {
[17:48:03.929]     {
[17:48:03.929]         {
[17:48:03.929]             ...future.startTime <- base::Sys.time()
[17:48:03.929]             {
[17:48:03.929]                 {
[17:48:03.929]                   {
[17:48:03.929]                     {
[17:48:03.929]                       base::local({
[17:48:03.929]                         has_future <- base::requireNamespace("future", 
[17:48:03.929]                           quietly = TRUE)
[17:48:03.929]                         if (has_future) {
[17:48:03.929]                           ns <- base::getNamespace("future")
[17:48:03.929]                           version <- ns[[".package"]][["version"]]
[17:48:03.929]                           if (is.null(version)) 
[17:48:03.929]                             version <- utils::packageVersion("future")
[17:48:03.929]                         }
[17:48:03.929]                         else {
[17:48:03.929]                           version <- NULL
[17:48:03.929]                         }
[17:48:03.929]                         if (!has_future || version < "1.8.0") {
[17:48:03.929]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:03.929]                             "", base::R.version$version.string), 
[17:48:03.929]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:03.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:03.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:03.929]                               "release", "version")], collapse = " "), 
[17:48:03.929]                             hostname = base::Sys.info()[["nodename"]])
[17:48:03.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:03.929]                             info)
[17:48:03.929]                           info <- base::paste(info, collapse = "; ")
[17:48:03.929]                           if (!has_future) {
[17:48:03.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:03.929]                               info)
[17:48:03.929]                           }
[17:48:03.929]                           else {
[17:48:03.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:03.929]                               info, version)
[17:48:03.929]                           }
[17:48:03.929]                           base::stop(msg)
[17:48:03.929]                         }
[17:48:03.929]                       })
[17:48:03.929]                     }
[17:48:03.929]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:03.929]                     base::options(mc.cores = 1L)
[17:48:03.929]                   }
[17:48:03.929]                   ...future.strategy.old <- future::plan("list")
[17:48:03.929]                   options(future.plan = NULL)
[17:48:03.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:03.929]                 }
[17:48:03.929]                 ...future.workdir <- getwd()
[17:48:03.929]             }
[17:48:03.929]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:03.929]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:03.929]         }
[17:48:03.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:03.929]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:03.929]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:03.929]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:03.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:03.929]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:03.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:03.929]             base::names(...future.oldOptions))
[17:48:03.929]     }
[17:48:03.929]     if (FALSE) {
[17:48:03.929]     }
[17:48:03.929]     else {
[17:48:03.929]         if (TRUE) {
[17:48:03.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:03.929]                 open = "w")
[17:48:03.929]         }
[17:48:03.929]         else {
[17:48:03.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:03.929]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:03.929]         }
[17:48:03.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:03.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:03.929]             base::sink(type = "output", split = FALSE)
[17:48:03.929]             base::close(...future.stdout)
[17:48:03.929]         }, add = TRUE)
[17:48:03.929]     }
[17:48:03.929]     ...future.frame <- base::sys.nframe()
[17:48:03.929]     ...future.conditions <- base::list()
[17:48:03.929]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:03.929]     if (FALSE) {
[17:48:03.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:03.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:03.929]     }
[17:48:03.929]     ...future.result <- base::tryCatch({
[17:48:03.929]         base::withCallingHandlers({
[17:48:03.929]             ...future.value <- base::withVisible(base::local({
[17:48:03.929]                 ...future.makeSendCondition <- base::local({
[17:48:03.929]                   sendCondition <- NULL
[17:48:03.929]                   function(frame = 1L) {
[17:48:03.929]                     if (is.function(sendCondition)) 
[17:48:03.929]                       return(sendCondition)
[17:48:03.929]                     ns <- getNamespace("parallel")
[17:48:03.929]                     if (exists("sendData", mode = "function", 
[17:48:03.929]                       envir = ns)) {
[17:48:03.929]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:03.929]                         envir = ns)
[17:48:03.929]                       envir <- sys.frame(frame)
[17:48:03.929]                       master <- NULL
[17:48:03.929]                       while (!identical(envir, .GlobalEnv) && 
[17:48:03.929]                         !identical(envir, emptyenv())) {
[17:48:03.929]                         if (exists("master", mode = "list", envir = envir, 
[17:48:03.929]                           inherits = FALSE)) {
[17:48:03.929]                           master <- get("master", mode = "list", 
[17:48:03.929]                             envir = envir, inherits = FALSE)
[17:48:03.929]                           if (inherits(master, c("SOCKnode", 
[17:48:03.929]                             "SOCK0node"))) {
[17:48:03.929]                             sendCondition <<- function(cond) {
[17:48:03.929]                               data <- list(type = "VALUE", value = cond, 
[17:48:03.929]                                 success = TRUE)
[17:48:03.929]                               parallel_sendData(master, data)
[17:48:03.929]                             }
[17:48:03.929]                             return(sendCondition)
[17:48:03.929]                           }
[17:48:03.929]                         }
[17:48:03.929]                         frame <- frame + 1L
[17:48:03.929]                         envir <- sys.frame(frame)
[17:48:03.929]                       }
[17:48:03.929]                     }
[17:48:03.929]                     sendCondition <<- function(cond) NULL
[17:48:03.929]                   }
[17:48:03.929]                 })
[17:48:03.929]                 withCallingHandlers({
[17:48:03.929]                   {
[17:48:03.929]                     Sys.sleep(0.5)
[17:48:03.929]                     list(a = 1, b = 42L)
[17:48:03.929]                   }
[17:48:03.929]                 }, immediateCondition = function(cond) {
[17:48:03.929]                   sendCondition <- ...future.makeSendCondition()
[17:48:03.929]                   sendCondition(cond)
[17:48:03.929]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.929]                   {
[17:48:03.929]                     inherits <- base::inherits
[17:48:03.929]                     invokeRestart <- base::invokeRestart
[17:48:03.929]                     is.null <- base::is.null
[17:48:03.929]                     muffled <- FALSE
[17:48:03.929]                     if (inherits(cond, "message")) {
[17:48:03.929]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:03.929]                       if (muffled) 
[17:48:03.929]                         invokeRestart("muffleMessage")
[17:48:03.929]                     }
[17:48:03.929]                     else if (inherits(cond, "warning")) {
[17:48:03.929]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:03.929]                       if (muffled) 
[17:48:03.929]                         invokeRestart("muffleWarning")
[17:48:03.929]                     }
[17:48:03.929]                     else if (inherits(cond, "condition")) {
[17:48:03.929]                       if (!is.null(pattern)) {
[17:48:03.929]                         computeRestarts <- base::computeRestarts
[17:48:03.929]                         grepl <- base::grepl
[17:48:03.929]                         restarts <- computeRestarts(cond)
[17:48:03.929]                         for (restart in restarts) {
[17:48:03.929]                           name <- restart$name
[17:48:03.929]                           if (is.null(name)) 
[17:48:03.929]                             next
[17:48:03.929]                           if (!grepl(pattern, name)) 
[17:48:03.929]                             next
[17:48:03.929]                           invokeRestart(restart)
[17:48:03.929]                           muffled <- TRUE
[17:48:03.929]                           break
[17:48:03.929]                         }
[17:48:03.929]                       }
[17:48:03.929]                     }
[17:48:03.929]                     invisible(muffled)
[17:48:03.929]                   }
[17:48:03.929]                   muffleCondition(cond)
[17:48:03.929]                 })
[17:48:03.929]             }))
[17:48:03.929]             future::FutureResult(value = ...future.value$value, 
[17:48:03.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.929]                   ...future.rng), globalenv = if (FALSE) 
[17:48:03.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:03.929]                     ...future.globalenv.names))
[17:48:03.929]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:03.929]         }, condition = base::local({
[17:48:03.929]             c <- base::c
[17:48:03.929]             inherits <- base::inherits
[17:48:03.929]             invokeRestart <- base::invokeRestart
[17:48:03.929]             length <- base::length
[17:48:03.929]             list <- base::list
[17:48:03.929]             seq.int <- base::seq.int
[17:48:03.929]             signalCondition <- base::signalCondition
[17:48:03.929]             sys.calls <- base::sys.calls
[17:48:03.929]             `[[` <- base::`[[`
[17:48:03.929]             `+` <- base::`+`
[17:48:03.929]             `<<-` <- base::`<<-`
[17:48:03.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:03.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:03.929]                   3L)]
[17:48:03.929]             }
[17:48:03.929]             function(cond) {
[17:48:03.929]                 is_error <- inherits(cond, "error")
[17:48:03.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:03.929]                   NULL)
[17:48:03.929]                 if (is_error) {
[17:48:03.929]                   sessionInformation <- function() {
[17:48:03.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:03.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:03.929]                       search = base::search(), system = base::Sys.info())
[17:48:03.929]                   }
[17:48:03.929]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:03.929]                     cond$call), session = sessionInformation(), 
[17:48:03.929]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:03.929]                   signalCondition(cond)
[17:48:03.929]                 }
[17:48:03.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:03.929]                 "immediateCondition"))) {
[17:48:03.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:03.929]                   ...future.conditions[[length(...future.conditions) + 
[17:48:03.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:03.929]                   if (TRUE && !signal) {
[17:48:03.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.929]                     {
[17:48:03.929]                       inherits <- base::inherits
[17:48:03.929]                       invokeRestart <- base::invokeRestart
[17:48:03.929]                       is.null <- base::is.null
[17:48:03.929]                       muffled <- FALSE
[17:48:03.929]                       if (inherits(cond, "message")) {
[17:48:03.929]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.929]                         if (muffled) 
[17:48:03.929]                           invokeRestart("muffleMessage")
[17:48:03.929]                       }
[17:48:03.929]                       else if (inherits(cond, "warning")) {
[17:48:03.929]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.929]                         if (muffled) 
[17:48:03.929]                           invokeRestart("muffleWarning")
[17:48:03.929]                       }
[17:48:03.929]                       else if (inherits(cond, "condition")) {
[17:48:03.929]                         if (!is.null(pattern)) {
[17:48:03.929]                           computeRestarts <- base::computeRestarts
[17:48:03.929]                           grepl <- base::grepl
[17:48:03.929]                           restarts <- computeRestarts(cond)
[17:48:03.929]                           for (restart in restarts) {
[17:48:03.929]                             name <- restart$name
[17:48:03.929]                             if (is.null(name)) 
[17:48:03.929]                               next
[17:48:03.929]                             if (!grepl(pattern, name)) 
[17:48:03.929]                               next
[17:48:03.929]                             invokeRestart(restart)
[17:48:03.929]                             muffled <- TRUE
[17:48:03.929]                             break
[17:48:03.929]                           }
[17:48:03.929]                         }
[17:48:03.929]                       }
[17:48:03.929]                       invisible(muffled)
[17:48:03.929]                     }
[17:48:03.929]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.929]                   }
[17:48:03.929]                 }
[17:48:03.929]                 else {
[17:48:03.929]                   if (TRUE) {
[17:48:03.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:03.929]                     {
[17:48:03.929]                       inherits <- base::inherits
[17:48:03.929]                       invokeRestart <- base::invokeRestart
[17:48:03.929]                       is.null <- base::is.null
[17:48:03.929]                       muffled <- FALSE
[17:48:03.929]                       if (inherits(cond, "message")) {
[17:48:03.929]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:03.929]                         if (muffled) 
[17:48:03.929]                           invokeRestart("muffleMessage")
[17:48:03.929]                       }
[17:48:03.929]                       else if (inherits(cond, "warning")) {
[17:48:03.929]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:03.929]                         if (muffled) 
[17:48:03.929]                           invokeRestart("muffleWarning")
[17:48:03.929]                       }
[17:48:03.929]                       else if (inherits(cond, "condition")) {
[17:48:03.929]                         if (!is.null(pattern)) {
[17:48:03.929]                           computeRestarts <- base::computeRestarts
[17:48:03.929]                           grepl <- base::grepl
[17:48:03.929]                           restarts <- computeRestarts(cond)
[17:48:03.929]                           for (restart in restarts) {
[17:48:03.929]                             name <- restart$name
[17:48:03.929]                             if (is.null(name)) 
[17:48:03.929]                               next
[17:48:03.929]                             if (!grepl(pattern, name)) 
[17:48:03.929]                               next
[17:48:03.929]                             invokeRestart(restart)
[17:48:03.929]                             muffled <- TRUE
[17:48:03.929]                             break
[17:48:03.929]                           }
[17:48:03.929]                         }
[17:48:03.929]                       }
[17:48:03.929]                       invisible(muffled)
[17:48:03.929]                     }
[17:48:03.929]                     muffleCondition(cond, pattern = "^muffle")
[17:48:03.929]                   }
[17:48:03.929]                 }
[17:48:03.929]             }
[17:48:03.929]         }))
[17:48:03.929]     }, error = function(ex) {
[17:48:03.929]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:03.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:03.929]                 ...future.rng), started = ...future.startTime, 
[17:48:03.929]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:03.929]             version = "1.8"), class = "FutureResult")
[17:48:03.929]     }, finally = {
[17:48:03.929]         if (!identical(...future.workdir, getwd())) 
[17:48:03.929]             setwd(...future.workdir)
[17:48:03.929]         {
[17:48:03.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:03.929]                 ...future.oldOptions$nwarnings <- NULL
[17:48:03.929]             }
[17:48:03.929]             base::options(...future.oldOptions)
[17:48:03.929]             if (.Platform$OS.type == "windows") {
[17:48:03.929]                 old_names <- names(...future.oldEnvVars)
[17:48:03.929]                 envs <- base::Sys.getenv()
[17:48:03.929]                 names <- names(envs)
[17:48:03.929]                 common <- intersect(names, old_names)
[17:48:03.929]                 added <- setdiff(names, old_names)
[17:48:03.929]                 removed <- setdiff(old_names, names)
[17:48:03.929]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:03.929]                   envs[common]]
[17:48:03.929]                 NAMES <- toupper(changed)
[17:48:03.929]                 args <- list()
[17:48:03.929]                 for (kk in seq_along(NAMES)) {
[17:48:03.929]                   name <- changed[[kk]]
[17:48:03.929]                   NAME <- NAMES[[kk]]
[17:48:03.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.929]                     next
[17:48:03.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.929]                 }
[17:48:03.929]                 NAMES <- toupper(added)
[17:48:03.929]                 for (kk in seq_along(NAMES)) {
[17:48:03.929]                   name <- added[[kk]]
[17:48:03.929]                   NAME <- NAMES[[kk]]
[17:48:03.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.929]                     next
[17:48:03.929]                   args[[name]] <- ""
[17:48:03.929]                 }
[17:48:03.929]                 NAMES <- toupper(removed)
[17:48:03.929]                 for (kk in seq_along(NAMES)) {
[17:48:03.929]                   name <- removed[[kk]]
[17:48:03.929]                   NAME <- NAMES[[kk]]
[17:48:03.929]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:03.929]                     next
[17:48:03.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:03.929]                 }
[17:48:03.929]                 if (length(args) > 0) 
[17:48:03.929]                   base::do.call(base::Sys.setenv, args = args)
[17:48:03.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:03.929]             }
[17:48:03.929]             else {
[17:48:03.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:03.929]             }
[17:48:03.929]             {
[17:48:03.929]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:03.929]                   0L) {
[17:48:03.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:03.929]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:03.929]                   base::options(opts)
[17:48:03.929]                 }
[17:48:03.929]                 {
[17:48:03.929]                   {
[17:48:03.929]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:03.929]                     NULL
[17:48:03.929]                   }
[17:48:03.929]                   options(future.plan = NULL)
[17:48:03.929]                   if (is.na(NA_character_)) 
[17:48:03.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:03.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:03.929]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:03.929]                     .init = FALSE)
[17:48:03.929]                 }
[17:48:03.929]             }
[17:48:03.929]         }
[17:48:03.929]     })
[17:48:03.929]     if (TRUE) {
[17:48:03.929]         base::sink(type = "output", split = FALSE)
[17:48:03.929]         if (TRUE) {
[17:48:03.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:03.929]         }
[17:48:03.929]         else {
[17:48:03.929]             ...future.result["stdout"] <- base::list(NULL)
[17:48:03.929]         }
[17:48:03.929]         base::close(...future.stdout)
[17:48:03.929]         ...future.stdout <- NULL
[17:48:03.929]     }
[17:48:03.929]     ...future.result$conditions <- ...future.conditions
[17:48:03.929]     ...future.result$finished <- base::Sys.time()
[17:48:03.929]     ...future.result
[17:48:03.929] }
[17:48:03.932] MultisessionFuture started
[17:48:03.932] - Launch lazy future ... done
[17:48:03.933] run() for ‘MultisessionFuture’ ... done
[17:48:04.435] receiveMessageFromWorker() for ClusterFuture ...
[17:48:04.435] - Validating connection of MultisessionFuture
[17:48:04.436] - received message: FutureResult
[17:48:04.436] - Received FutureResult
[17:48:04.436] - Erased future from FutureRegistry
[17:48:04.436] result() for ClusterFuture ...
[17:48:04.436] - result already collected: FutureResult
[17:48:04.436] result() for ClusterFuture ... done
[17:48:04.436] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:04.436] A MultisessionFuture was resolved
- w/ exception ...
[17:48:04.436] getGlobalsAndPackages() ...
[17:48:04.436] Searching for globals...
[17:48:04.437] - globals found: [2] ‘list’, ‘stop’
[17:48:04.437] Searching for globals ... DONE
[17:48:04.437] Resolving globals: FALSE
[17:48:04.438] 
[17:48:04.438] 
[17:48:04.438] getGlobalsAndPackages() ... DONE
[17:48:04.438] run() for ‘Future’ ...
[17:48:04.438] - state: ‘created’
[17:48:04.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:04.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:04.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:04.452]   - Field: ‘node’
[17:48:04.452]   - Field: ‘label’
[17:48:04.453]   - Field: ‘local’
[17:48:04.453]   - Field: ‘owner’
[17:48:04.453]   - Field: ‘envir’
[17:48:04.453]   - Field: ‘workers’
[17:48:04.453]   - Field: ‘packages’
[17:48:04.453]   - Field: ‘gc’
[17:48:04.453]   - Field: ‘conditions’
[17:48:04.453]   - Field: ‘persistent’
[17:48:04.453]   - Field: ‘expr’
[17:48:04.453]   - Field: ‘uuid’
[17:48:04.453]   - Field: ‘seed’
[17:48:04.454]   - Field: ‘version’
[17:48:04.454]   - Field: ‘result’
[17:48:04.454]   - Field: ‘asynchronous’
[17:48:04.454]   - Field: ‘calls’
[17:48:04.454]   - Field: ‘globals’
[17:48:04.454]   - Field: ‘stdout’
[17:48:04.454]   - Field: ‘earlySignal’
[17:48:04.454]   - Field: ‘lazy’
[17:48:04.454]   - Field: ‘state’
[17:48:04.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:04.454] - Launch lazy future ...
[17:48:04.455] Packages needed by the future expression (n = 0): <none>
[17:48:04.455] Packages needed by future strategies (n = 0): <none>
[17:48:04.455] {
[17:48:04.455]     {
[17:48:04.455]         {
[17:48:04.455]             ...future.startTime <- base::Sys.time()
[17:48:04.455]             {
[17:48:04.455]                 {
[17:48:04.455]                   {
[17:48:04.455]                     {
[17:48:04.455]                       base::local({
[17:48:04.455]                         has_future <- base::requireNamespace("future", 
[17:48:04.455]                           quietly = TRUE)
[17:48:04.455]                         if (has_future) {
[17:48:04.455]                           ns <- base::getNamespace("future")
[17:48:04.455]                           version <- ns[[".package"]][["version"]]
[17:48:04.455]                           if (is.null(version)) 
[17:48:04.455]                             version <- utils::packageVersion("future")
[17:48:04.455]                         }
[17:48:04.455]                         else {
[17:48:04.455]                           version <- NULL
[17:48:04.455]                         }
[17:48:04.455]                         if (!has_future || version < "1.8.0") {
[17:48:04.455]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:04.455]                             "", base::R.version$version.string), 
[17:48:04.455]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:04.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:04.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:04.455]                               "release", "version")], collapse = " "), 
[17:48:04.455]                             hostname = base::Sys.info()[["nodename"]])
[17:48:04.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:04.455]                             info)
[17:48:04.455]                           info <- base::paste(info, collapse = "; ")
[17:48:04.455]                           if (!has_future) {
[17:48:04.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:04.455]                               info)
[17:48:04.455]                           }
[17:48:04.455]                           else {
[17:48:04.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:04.455]                               info, version)
[17:48:04.455]                           }
[17:48:04.455]                           base::stop(msg)
[17:48:04.455]                         }
[17:48:04.455]                       })
[17:48:04.455]                     }
[17:48:04.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:04.455]                     base::options(mc.cores = 1L)
[17:48:04.455]                   }
[17:48:04.455]                   ...future.strategy.old <- future::plan("list")
[17:48:04.455]                   options(future.plan = NULL)
[17:48:04.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:04.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:04.455]                 }
[17:48:04.455]                 ...future.workdir <- getwd()
[17:48:04.455]             }
[17:48:04.455]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:04.455]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:04.455]         }
[17:48:04.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:04.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:04.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:04.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:04.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:04.455]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:04.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:04.455]             base::names(...future.oldOptions))
[17:48:04.455]     }
[17:48:04.455]     if (FALSE) {
[17:48:04.455]     }
[17:48:04.455]     else {
[17:48:04.455]         if (TRUE) {
[17:48:04.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:04.455]                 open = "w")
[17:48:04.455]         }
[17:48:04.455]         else {
[17:48:04.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:04.455]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:04.455]         }
[17:48:04.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:04.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:04.455]             base::sink(type = "output", split = FALSE)
[17:48:04.455]             base::close(...future.stdout)
[17:48:04.455]         }, add = TRUE)
[17:48:04.455]     }
[17:48:04.455]     ...future.frame <- base::sys.nframe()
[17:48:04.455]     ...future.conditions <- base::list()
[17:48:04.455]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:04.455]     if (FALSE) {
[17:48:04.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:04.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:04.455]     }
[17:48:04.455]     ...future.result <- base::tryCatch({
[17:48:04.455]         base::withCallingHandlers({
[17:48:04.455]             ...future.value <- base::withVisible(base::local({
[17:48:04.455]                 ...future.makeSendCondition <- base::local({
[17:48:04.455]                   sendCondition <- NULL
[17:48:04.455]                   function(frame = 1L) {
[17:48:04.455]                     if (is.function(sendCondition)) 
[17:48:04.455]                       return(sendCondition)
[17:48:04.455]                     ns <- getNamespace("parallel")
[17:48:04.455]                     if (exists("sendData", mode = "function", 
[17:48:04.455]                       envir = ns)) {
[17:48:04.455]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:04.455]                         envir = ns)
[17:48:04.455]                       envir <- sys.frame(frame)
[17:48:04.455]                       master <- NULL
[17:48:04.455]                       while (!identical(envir, .GlobalEnv) && 
[17:48:04.455]                         !identical(envir, emptyenv())) {
[17:48:04.455]                         if (exists("master", mode = "list", envir = envir, 
[17:48:04.455]                           inherits = FALSE)) {
[17:48:04.455]                           master <- get("master", mode = "list", 
[17:48:04.455]                             envir = envir, inherits = FALSE)
[17:48:04.455]                           if (inherits(master, c("SOCKnode", 
[17:48:04.455]                             "SOCK0node"))) {
[17:48:04.455]                             sendCondition <<- function(cond) {
[17:48:04.455]                               data <- list(type = "VALUE", value = cond, 
[17:48:04.455]                                 success = TRUE)
[17:48:04.455]                               parallel_sendData(master, data)
[17:48:04.455]                             }
[17:48:04.455]                             return(sendCondition)
[17:48:04.455]                           }
[17:48:04.455]                         }
[17:48:04.455]                         frame <- frame + 1L
[17:48:04.455]                         envir <- sys.frame(frame)
[17:48:04.455]                       }
[17:48:04.455]                     }
[17:48:04.455]                     sendCondition <<- function(cond) NULL
[17:48:04.455]                   }
[17:48:04.455]                 })
[17:48:04.455]                 withCallingHandlers({
[17:48:04.455]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:04.455]                 }, immediateCondition = function(cond) {
[17:48:04.455]                   sendCondition <- ...future.makeSendCondition()
[17:48:04.455]                   sendCondition(cond)
[17:48:04.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.455]                   {
[17:48:04.455]                     inherits <- base::inherits
[17:48:04.455]                     invokeRestart <- base::invokeRestart
[17:48:04.455]                     is.null <- base::is.null
[17:48:04.455]                     muffled <- FALSE
[17:48:04.455]                     if (inherits(cond, "message")) {
[17:48:04.455]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:04.455]                       if (muffled) 
[17:48:04.455]                         invokeRestart("muffleMessage")
[17:48:04.455]                     }
[17:48:04.455]                     else if (inherits(cond, "warning")) {
[17:48:04.455]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:04.455]                       if (muffled) 
[17:48:04.455]                         invokeRestart("muffleWarning")
[17:48:04.455]                     }
[17:48:04.455]                     else if (inherits(cond, "condition")) {
[17:48:04.455]                       if (!is.null(pattern)) {
[17:48:04.455]                         computeRestarts <- base::computeRestarts
[17:48:04.455]                         grepl <- base::grepl
[17:48:04.455]                         restarts <- computeRestarts(cond)
[17:48:04.455]                         for (restart in restarts) {
[17:48:04.455]                           name <- restart$name
[17:48:04.455]                           if (is.null(name)) 
[17:48:04.455]                             next
[17:48:04.455]                           if (!grepl(pattern, name)) 
[17:48:04.455]                             next
[17:48:04.455]                           invokeRestart(restart)
[17:48:04.455]                           muffled <- TRUE
[17:48:04.455]                           break
[17:48:04.455]                         }
[17:48:04.455]                       }
[17:48:04.455]                     }
[17:48:04.455]                     invisible(muffled)
[17:48:04.455]                   }
[17:48:04.455]                   muffleCondition(cond)
[17:48:04.455]                 })
[17:48:04.455]             }))
[17:48:04.455]             future::FutureResult(value = ...future.value$value, 
[17:48:04.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:04.455]                   ...future.rng), globalenv = if (FALSE) 
[17:48:04.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:04.455]                     ...future.globalenv.names))
[17:48:04.455]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:04.455]         }, condition = base::local({
[17:48:04.455]             c <- base::c
[17:48:04.455]             inherits <- base::inherits
[17:48:04.455]             invokeRestart <- base::invokeRestart
[17:48:04.455]             length <- base::length
[17:48:04.455]             list <- base::list
[17:48:04.455]             seq.int <- base::seq.int
[17:48:04.455]             signalCondition <- base::signalCondition
[17:48:04.455]             sys.calls <- base::sys.calls
[17:48:04.455]             `[[` <- base::`[[`
[17:48:04.455]             `+` <- base::`+`
[17:48:04.455]             `<<-` <- base::`<<-`
[17:48:04.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:04.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:04.455]                   3L)]
[17:48:04.455]             }
[17:48:04.455]             function(cond) {
[17:48:04.455]                 is_error <- inherits(cond, "error")
[17:48:04.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:04.455]                   NULL)
[17:48:04.455]                 if (is_error) {
[17:48:04.455]                   sessionInformation <- function() {
[17:48:04.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:04.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:04.455]                       search = base::search(), system = base::Sys.info())
[17:48:04.455]                   }
[17:48:04.455]                   ...future.conditions[[length(...future.conditions) + 
[17:48:04.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:04.455]                     cond$call), session = sessionInformation(), 
[17:48:04.455]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:04.455]                   signalCondition(cond)
[17:48:04.455]                 }
[17:48:04.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:04.455]                 "immediateCondition"))) {
[17:48:04.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:04.455]                   ...future.conditions[[length(...future.conditions) + 
[17:48:04.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:04.455]                   if (TRUE && !signal) {
[17:48:04.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.455]                     {
[17:48:04.455]                       inherits <- base::inherits
[17:48:04.455]                       invokeRestart <- base::invokeRestart
[17:48:04.455]                       is.null <- base::is.null
[17:48:04.455]                       muffled <- FALSE
[17:48:04.455]                       if (inherits(cond, "message")) {
[17:48:04.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:04.455]                         if (muffled) 
[17:48:04.455]                           invokeRestart("muffleMessage")
[17:48:04.455]                       }
[17:48:04.455]                       else if (inherits(cond, "warning")) {
[17:48:04.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:04.455]                         if (muffled) 
[17:48:04.455]                           invokeRestart("muffleWarning")
[17:48:04.455]                       }
[17:48:04.455]                       else if (inherits(cond, "condition")) {
[17:48:04.455]                         if (!is.null(pattern)) {
[17:48:04.455]                           computeRestarts <- base::computeRestarts
[17:48:04.455]                           grepl <- base::grepl
[17:48:04.455]                           restarts <- computeRestarts(cond)
[17:48:04.455]                           for (restart in restarts) {
[17:48:04.455]                             name <- restart$name
[17:48:04.455]                             if (is.null(name)) 
[17:48:04.455]                               next
[17:48:04.455]                             if (!grepl(pattern, name)) 
[17:48:04.455]                               next
[17:48:04.455]                             invokeRestart(restart)
[17:48:04.455]                             muffled <- TRUE
[17:48:04.455]                             break
[17:48:04.455]                           }
[17:48:04.455]                         }
[17:48:04.455]                       }
[17:48:04.455]                       invisible(muffled)
[17:48:04.455]                     }
[17:48:04.455]                     muffleCondition(cond, pattern = "^muffle")
[17:48:04.455]                   }
[17:48:04.455]                 }
[17:48:04.455]                 else {
[17:48:04.455]                   if (TRUE) {
[17:48:04.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.455]                     {
[17:48:04.455]                       inherits <- base::inherits
[17:48:04.455]                       invokeRestart <- base::invokeRestart
[17:48:04.455]                       is.null <- base::is.null
[17:48:04.455]                       muffled <- FALSE
[17:48:04.455]                       if (inherits(cond, "message")) {
[17:48:04.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:04.455]                         if (muffled) 
[17:48:04.455]                           invokeRestart("muffleMessage")
[17:48:04.455]                       }
[17:48:04.455]                       else if (inherits(cond, "warning")) {
[17:48:04.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:04.455]                         if (muffled) 
[17:48:04.455]                           invokeRestart("muffleWarning")
[17:48:04.455]                       }
[17:48:04.455]                       else if (inherits(cond, "condition")) {
[17:48:04.455]                         if (!is.null(pattern)) {
[17:48:04.455]                           computeRestarts <- base::computeRestarts
[17:48:04.455]                           grepl <- base::grepl
[17:48:04.455]                           restarts <- computeRestarts(cond)
[17:48:04.455]                           for (restart in restarts) {
[17:48:04.455]                             name <- restart$name
[17:48:04.455]                             if (is.null(name)) 
[17:48:04.455]                               next
[17:48:04.455]                             if (!grepl(pattern, name)) 
[17:48:04.455]                               next
[17:48:04.455]                             invokeRestart(restart)
[17:48:04.455]                             muffled <- TRUE
[17:48:04.455]                             break
[17:48:04.455]                           }
[17:48:04.455]                         }
[17:48:04.455]                       }
[17:48:04.455]                       invisible(muffled)
[17:48:04.455]                     }
[17:48:04.455]                     muffleCondition(cond, pattern = "^muffle")
[17:48:04.455]                   }
[17:48:04.455]                 }
[17:48:04.455]             }
[17:48:04.455]         }))
[17:48:04.455]     }, error = function(ex) {
[17:48:04.455]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:04.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:04.455]                 ...future.rng), started = ...future.startTime, 
[17:48:04.455]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:04.455]             version = "1.8"), class = "FutureResult")
[17:48:04.455]     }, finally = {
[17:48:04.455]         if (!identical(...future.workdir, getwd())) 
[17:48:04.455]             setwd(...future.workdir)
[17:48:04.455]         {
[17:48:04.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:04.455]                 ...future.oldOptions$nwarnings <- NULL
[17:48:04.455]             }
[17:48:04.455]             base::options(...future.oldOptions)
[17:48:04.455]             if (.Platform$OS.type == "windows") {
[17:48:04.455]                 old_names <- names(...future.oldEnvVars)
[17:48:04.455]                 envs <- base::Sys.getenv()
[17:48:04.455]                 names <- names(envs)
[17:48:04.455]                 common <- intersect(names, old_names)
[17:48:04.455]                 added <- setdiff(names, old_names)
[17:48:04.455]                 removed <- setdiff(old_names, names)
[17:48:04.455]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:04.455]                   envs[common]]
[17:48:04.455]                 NAMES <- toupper(changed)
[17:48:04.455]                 args <- list()
[17:48:04.455]                 for (kk in seq_along(NAMES)) {
[17:48:04.455]                   name <- changed[[kk]]
[17:48:04.455]                   NAME <- NAMES[[kk]]
[17:48:04.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.455]                     next
[17:48:04.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:04.455]                 }
[17:48:04.455]                 NAMES <- toupper(added)
[17:48:04.455]                 for (kk in seq_along(NAMES)) {
[17:48:04.455]                   name <- added[[kk]]
[17:48:04.455]                   NAME <- NAMES[[kk]]
[17:48:04.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.455]                     next
[17:48:04.455]                   args[[name]] <- ""
[17:48:04.455]                 }
[17:48:04.455]                 NAMES <- toupper(removed)
[17:48:04.455]                 for (kk in seq_along(NAMES)) {
[17:48:04.455]                   name <- removed[[kk]]
[17:48:04.455]                   NAME <- NAMES[[kk]]
[17:48:04.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.455]                     next
[17:48:04.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:04.455]                 }
[17:48:04.455]                 if (length(args) > 0) 
[17:48:04.455]                   base::do.call(base::Sys.setenv, args = args)
[17:48:04.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:04.455]             }
[17:48:04.455]             else {
[17:48:04.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:04.455]             }
[17:48:04.455]             {
[17:48:04.455]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:04.455]                   0L) {
[17:48:04.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:04.455]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:04.455]                   base::options(opts)
[17:48:04.455]                 }
[17:48:04.455]                 {
[17:48:04.455]                   {
[17:48:04.455]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:04.455]                     NULL
[17:48:04.455]                   }
[17:48:04.455]                   options(future.plan = NULL)
[17:48:04.455]                   if (is.na(NA_character_)) 
[17:48:04.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:04.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:04.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:04.455]                     .init = FALSE)
[17:48:04.455]                 }
[17:48:04.455]             }
[17:48:04.455]         }
[17:48:04.455]     })
[17:48:04.455]     if (TRUE) {
[17:48:04.455]         base::sink(type = "output", split = FALSE)
[17:48:04.455]         if (TRUE) {
[17:48:04.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:04.455]         }
[17:48:04.455]         else {
[17:48:04.455]             ...future.result["stdout"] <- base::list(NULL)
[17:48:04.455]         }
[17:48:04.455]         base::close(...future.stdout)
[17:48:04.455]         ...future.stdout <- NULL
[17:48:04.455]     }
[17:48:04.455]     ...future.result$conditions <- ...future.conditions
[17:48:04.455]     ...future.result$finished <- base::Sys.time()
[17:48:04.455]     ...future.result
[17:48:04.455] }
[17:48:04.458] MultisessionFuture started
[17:48:04.458] - Launch lazy future ... done
[17:48:04.458] run() for ‘MultisessionFuture’ ... done
[17:48:04.460] receiveMessageFromWorker() for ClusterFuture ...
[17:48:04.460] - Validating connection of MultisessionFuture
[17:48:04.461] - received message: FutureResult
[17:48:04.461] - Received FutureResult
[17:48:04.461] - Erased future from FutureRegistry
[17:48:04.461] result() for ClusterFuture ...
[17:48:04.461] - result already collected: FutureResult
[17:48:04.461] result() for ClusterFuture ... done
[17:48:04.462] signalConditions() ...
[17:48:04.462]  - include = ‘immediateCondition’
[17:48:04.462]  - exclude = 
[17:48:04.462]  - resignal = FALSE
[17:48:04.462]  - Number of conditions: 1
[17:48:04.462] signalConditions() ... done
[17:48:04.462] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:04.462] A MultisessionFuture was resolved
[17:48:04.462] getGlobalsAndPackages() ...
[17:48:04.462] Searching for globals...
[17:48:04.463] - globals found: [2] ‘list’, ‘stop’
[17:48:04.463] Searching for globals ... DONE
[17:48:04.463] Resolving globals: FALSE
[17:48:04.464] 
[17:48:04.464] 
[17:48:04.464] getGlobalsAndPackages() ... DONE
[17:48:04.464] run() for ‘Future’ ...
[17:48:04.464] - state: ‘created’
[17:48:04.464] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:04.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:04.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:04.478]   - Field: ‘node’
[17:48:04.478]   - Field: ‘label’
[17:48:04.478]   - Field: ‘local’
[17:48:04.478]   - Field: ‘owner’
[17:48:04.478]   - Field: ‘envir’
[17:48:04.479]   - Field: ‘workers’
[17:48:04.479]   - Field: ‘packages’
[17:48:04.479]   - Field: ‘gc’
[17:48:04.479]   - Field: ‘conditions’
[17:48:04.479]   - Field: ‘persistent’
[17:48:04.479]   - Field: ‘expr’
[17:48:04.479]   - Field: ‘uuid’
[17:48:04.479]   - Field: ‘seed’
[17:48:04.479]   - Field: ‘version’
[17:48:04.479]   - Field: ‘result’
[17:48:04.479]   - Field: ‘asynchronous’
[17:48:04.480]   - Field: ‘calls’
[17:48:04.480]   - Field: ‘globals’
[17:48:04.480]   - Field: ‘stdout’
[17:48:04.480]   - Field: ‘earlySignal’
[17:48:04.480]   - Field: ‘lazy’
[17:48:04.480]   - Field: ‘state’
[17:48:04.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:04.480] - Launch lazy future ...
[17:48:04.480] Packages needed by the future expression (n = 0): <none>
[17:48:04.481] Packages needed by future strategies (n = 0): <none>
[17:48:04.481] {
[17:48:04.481]     {
[17:48:04.481]         {
[17:48:04.481]             ...future.startTime <- base::Sys.time()
[17:48:04.481]             {
[17:48:04.481]                 {
[17:48:04.481]                   {
[17:48:04.481]                     {
[17:48:04.481]                       base::local({
[17:48:04.481]                         has_future <- base::requireNamespace("future", 
[17:48:04.481]                           quietly = TRUE)
[17:48:04.481]                         if (has_future) {
[17:48:04.481]                           ns <- base::getNamespace("future")
[17:48:04.481]                           version <- ns[[".package"]][["version"]]
[17:48:04.481]                           if (is.null(version)) 
[17:48:04.481]                             version <- utils::packageVersion("future")
[17:48:04.481]                         }
[17:48:04.481]                         else {
[17:48:04.481]                           version <- NULL
[17:48:04.481]                         }
[17:48:04.481]                         if (!has_future || version < "1.8.0") {
[17:48:04.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:04.481]                             "", base::R.version$version.string), 
[17:48:04.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:04.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:04.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:04.481]                               "release", "version")], collapse = " "), 
[17:48:04.481]                             hostname = base::Sys.info()[["nodename"]])
[17:48:04.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:04.481]                             info)
[17:48:04.481]                           info <- base::paste(info, collapse = "; ")
[17:48:04.481]                           if (!has_future) {
[17:48:04.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:04.481]                               info)
[17:48:04.481]                           }
[17:48:04.481]                           else {
[17:48:04.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:04.481]                               info, version)
[17:48:04.481]                           }
[17:48:04.481]                           base::stop(msg)
[17:48:04.481]                         }
[17:48:04.481]                       })
[17:48:04.481]                     }
[17:48:04.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:04.481]                     base::options(mc.cores = 1L)
[17:48:04.481]                   }
[17:48:04.481]                   ...future.strategy.old <- future::plan("list")
[17:48:04.481]                   options(future.plan = NULL)
[17:48:04.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:04.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:04.481]                 }
[17:48:04.481]                 ...future.workdir <- getwd()
[17:48:04.481]             }
[17:48:04.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:04.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:04.481]         }
[17:48:04.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:04.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:04.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:04.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:04.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:04.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:04.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:04.481]             base::names(...future.oldOptions))
[17:48:04.481]     }
[17:48:04.481]     if (FALSE) {
[17:48:04.481]     }
[17:48:04.481]     else {
[17:48:04.481]         if (TRUE) {
[17:48:04.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:04.481]                 open = "w")
[17:48:04.481]         }
[17:48:04.481]         else {
[17:48:04.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:04.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:04.481]         }
[17:48:04.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:04.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:04.481]             base::sink(type = "output", split = FALSE)
[17:48:04.481]             base::close(...future.stdout)
[17:48:04.481]         }, add = TRUE)
[17:48:04.481]     }
[17:48:04.481]     ...future.frame <- base::sys.nframe()
[17:48:04.481]     ...future.conditions <- base::list()
[17:48:04.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:04.481]     if (FALSE) {
[17:48:04.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:04.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:04.481]     }
[17:48:04.481]     ...future.result <- base::tryCatch({
[17:48:04.481]         base::withCallingHandlers({
[17:48:04.481]             ...future.value <- base::withVisible(base::local({
[17:48:04.481]                 ...future.makeSendCondition <- base::local({
[17:48:04.481]                   sendCondition <- NULL
[17:48:04.481]                   function(frame = 1L) {
[17:48:04.481]                     if (is.function(sendCondition)) 
[17:48:04.481]                       return(sendCondition)
[17:48:04.481]                     ns <- getNamespace("parallel")
[17:48:04.481]                     if (exists("sendData", mode = "function", 
[17:48:04.481]                       envir = ns)) {
[17:48:04.481]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:04.481]                         envir = ns)
[17:48:04.481]                       envir <- sys.frame(frame)
[17:48:04.481]                       master <- NULL
[17:48:04.481]                       while (!identical(envir, .GlobalEnv) && 
[17:48:04.481]                         !identical(envir, emptyenv())) {
[17:48:04.481]                         if (exists("master", mode = "list", envir = envir, 
[17:48:04.481]                           inherits = FALSE)) {
[17:48:04.481]                           master <- get("master", mode = "list", 
[17:48:04.481]                             envir = envir, inherits = FALSE)
[17:48:04.481]                           if (inherits(master, c("SOCKnode", 
[17:48:04.481]                             "SOCK0node"))) {
[17:48:04.481]                             sendCondition <<- function(cond) {
[17:48:04.481]                               data <- list(type = "VALUE", value = cond, 
[17:48:04.481]                                 success = TRUE)
[17:48:04.481]                               parallel_sendData(master, data)
[17:48:04.481]                             }
[17:48:04.481]                             return(sendCondition)
[17:48:04.481]                           }
[17:48:04.481]                         }
[17:48:04.481]                         frame <- frame + 1L
[17:48:04.481]                         envir <- sys.frame(frame)
[17:48:04.481]                       }
[17:48:04.481]                     }
[17:48:04.481]                     sendCondition <<- function(cond) NULL
[17:48:04.481]                   }
[17:48:04.481]                 })
[17:48:04.481]                 withCallingHandlers({
[17:48:04.481]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:04.481]                 }, immediateCondition = function(cond) {
[17:48:04.481]                   sendCondition <- ...future.makeSendCondition()
[17:48:04.481]                   sendCondition(cond)
[17:48:04.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.481]                   {
[17:48:04.481]                     inherits <- base::inherits
[17:48:04.481]                     invokeRestart <- base::invokeRestart
[17:48:04.481]                     is.null <- base::is.null
[17:48:04.481]                     muffled <- FALSE
[17:48:04.481]                     if (inherits(cond, "message")) {
[17:48:04.481]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:04.481]                       if (muffled) 
[17:48:04.481]                         invokeRestart("muffleMessage")
[17:48:04.481]                     }
[17:48:04.481]                     else if (inherits(cond, "warning")) {
[17:48:04.481]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:04.481]                       if (muffled) 
[17:48:04.481]                         invokeRestart("muffleWarning")
[17:48:04.481]                     }
[17:48:04.481]                     else if (inherits(cond, "condition")) {
[17:48:04.481]                       if (!is.null(pattern)) {
[17:48:04.481]                         computeRestarts <- base::computeRestarts
[17:48:04.481]                         grepl <- base::grepl
[17:48:04.481]                         restarts <- computeRestarts(cond)
[17:48:04.481]                         for (restart in restarts) {
[17:48:04.481]                           name <- restart$name
[17:48:04.481]                           if (is.null(name)) 
[17:48:04.481]                             next
[17:48:04.481]                           if (!grepl(pattern, name)) 
[17:48:04.481]                             next
[17:48:04.481]                           invokeRestart(restart)
[17:48:04.481]                           muffled <- TRUE
[17:48:04.481]                           break
[17:48:04.481]                         }
[17:48:04.481]                       }
[17:48:04.481]                     }
[17:48:04.481]                     invisible(muffled)
[17:48:04.481]                   }
[17:48:04.481]                   muffleCondition(cond)
[17:48:04.481]                 })
[17:48:04.481]             }))
[17:48:04.481]             future::FutureResult(value = ...future.value$value, 
[17:48:04.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:04.481]                   ...future.rng), globalenv = if (FALSE) 
[17:48:04.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:04.481]                     ...future.globalenv.names))
[17:48:04.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:04.481]         }, condition = base::local({
[17:48:04.481]             c <- base::c
[17:48:04.481]             inherits <- base::inherits
[17:48:04.481]             invokeRestart <- base::invokeRestart
[17:48:04.481]             length <- base::length
[17:48:04.481]             list <- base::list
[17:48:04.481]             seq.int <- base::seq.int
[17:48:04.481]             signalCondition <- base::signalCondition
[17:48:04.481]             sys.calls <- base::sys.calls
[17:48:04.481]             `[[` <- base::`[[`
[17:48:04.481]             `+` <- base::`+`
[17:48:04.481]             `<<-` <- base::`<<-`
[17:48:04.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:04.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:04.481]                   3L)]
[17:48:04.481]             }
[17:48:04.481]             function(cond) {
[17:48:04.481]                 is_error <- inherits(cond, "error")
[17:48:04.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:04.481]                   NULL)
[17:48:04.481]                 if (is_error) {
[17:48:04.481]                   sessionInformation <- function() {
[17:48:04.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:04.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:04.481]                       search = base::search(), system = base::Sys.info())
[17:48:04.481]                   }
[17:48:04.481]                   ...future.conditions[[length(...future.conditions) + 
[17:48:04.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:04.481]                     cond$call), session = sessionInformation(), 
[17:48:04.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:04.481]                   signalCondition(cond)
[17:48:04.481]                 }
[17:48:04.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:04.481]                 "immediateCondition"))) {
[17:48:04.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:04.481]                   ...future.conditions[[length(...future.conditions) + 
[17:48:04.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:04.481]                   if (TRUE && !signal) {
[17:48:04.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.481]                     {
[17:48:04.481]                       inherits <- base::inherits
[17:48:04.481]                       invokeRestart <- base::invokeRestart
[17:48:04.481]                       is.null <- base::is.null
[17:48:04.481]                       muffled <- FALSE
[17:48:04.481]                       if (inherits(cond, "message")) {
[17:48:04.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:04.481]                         if (muffled) 
[17:48:04.481]                           invokeRestart("muffleMessage")
[17:48:04.481]                       }
[17:48:04.481]                       else if (inherits(cond, "warning")) {
[17:48:04.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:04.481]                         if (muffled) 
[17:48:04.481]                           invokeRestart("muffleWarning")
[17:48:04.481]                       }
[17:48:04.481]                       else if (inherits(cond, "condition")) {
[17:48:04.481]                         if (!is.null(pattern)) {
[17:48:04.481]                           computeRestarts <- base::computeRestarts
[17:48:04.481]                           grepl <- base::grepl
[17:48:04.481]                           restarts <- computeRestarts(cond)
[17:48:04.481]                           for (restart in restarts) {
[17:48:04.481]                             name <- restart$name
[17:48:04.481]                             if (is.null(name)) 
[17:48:04.481]                               next
[17:48:04.481]                             if (!grepl(pattern, name)) 
[17:48:04.481]                               next
[17:48:04.481]                             invokeRestart(restart)
[17:48:04.481]                             muffled <- TRUE
[17:48:04.481]                             break
[17:48:04.481]                           }
[17:48:04.481]                         }
[17:48:04.481]                       }
[17:48:04.481]                       invisible(muffled)
[17:48:04.481]                     }
[17:48:04.481]                     muffleCondition(cond, pattern = "^muffle")
[17:48:04.481]                   }
[17:48:04.481]                 }
[17:48:04.481]                 else {
[17:48:04.481]                   if (TRUE) {
[17:48:04.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.481]                     {
[17:48:04.481]                       inherits <- base::inherits
[17:48:04.481]                       invokeRestart <- base::invokeRestart
[17:48:04.481]                       is.null <- base::is.null
[17:48:04.481]                       muffled <- FALSE
[17:48:04.481]                       if (inherits(cond, "message")) {
[17:48:04.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:04.481]                         if (muffled) 
[17:48:04.481]                           invokeRestart("muffleMessage")
[17:48:04.481]                       }
[17:48:04.481]                       else if (inherits(cond, "warning")) {
[17:48:04.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:04.481]                         if (muffled) 
[17:48:04.481]                           invokeRestart("muffleWarning")
[17:48:04.481]                       }
[17:48:04.481]                       else if (inherits(cond, "condition")) {
[17:48:04.481]                         if (!is.null(pattern)) {
[17:48:04.481]                           computeRestarts <- base::computeRestarts
[17:48:04.481]                           grepl <- base::grepl
[17:48:04.481]                           restarts <- computeRestarts(cond)
[17:48:04.481]                           for (restart in restarts) {
[17:48:04.481]                             name <- restart$name
[17:48:04.481]                             if (is.null(name)) 
[17:48:04.481]                               next
[17:48:04.481]                             if (!grepl(pattern, name)) 
[17:48:04.481]                               next
[17:48:04.481]                             invokeRestart(restart)
[17:48:04.481]                             muffled <- TRUE
[17:48:04.481]                             break
[17:48:04.481]                           }
[17:48:04.481]                         }
[17:48:04.481]                       }
[17:48:04.481]                       invisible(muffled)
[17:48:04.481]                     }
[17:48:04.481]                     muffleCondition(cond, pattern = "^muffle")
[17:48:04.481]                   }
[17:48:04.481]                 }
[17:48:04.481]             }
[17:48:04.481]         }))
[17:48:04.481]     }, error = function(ex) {
[17:48:04.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:04.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:04.481]                 ...future.rng), started = ...future.startTime, 
[17:48:04.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:04.481]             version = "1.8"), class = "FutureResult")
[17:48:04.481]     }, finally = {
[17:48:04.481]         if (!identical(...future.workdir, getwd())) 
[17:48:04.481]             setwd(...future.workdir)
[17:48:04.481]         {
[17:48:04.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:04.481]                 ...future.oldOptions$nwarnings <- NULL
[17:48:04.481]             }
[17:48:04.481]             base::options(...future.oldOptions)
[17:48:04.481]             if (.Platform$OS.type == "windows") {
[17:48:04.481]                 old_names <- names(...future.oldEnvVars)
[17:48:04.481]                 envs <- base::Sys.getenv()
[17:48:04.481]                 names <- names(envs)
[17:48:04.481]                 common <- intersect(names, old_names)
[17:48:04.481]                 added <- setdiff(names, old_names)
[17:48:04.481]                 removed <- setdiff(old_names, names)
[17:48:04.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:04.481]                   envs[common]]
[17:48:04.481]                 NAMES <- toupper(changed)
[17:48:04.481]                 args <- list()
[17:48:04.481]                 for (kk in seq_along(NAMES)) {
[17:48:04.481]                   name <- changed[[kk]]
[17:48:04.481]                   NAME <- NAMES[[kk]]
[17:48:04.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.481]                     next
[17:48:04.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:04.481]                 }
[17:48:04.481]                 NAMES <- toupper(added)
[17:48:04.481]                 for (kk in seq_along(NAMES)) {
[17:48:04.481]                   name <- added[[kk]]
[17:48:04.481]                   NAME <- NAMES[[kk]]
[17:48:04.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.481]                     next
[17:48:04.481]                   args[[name]] <- ""
[17:48:04.481]                 }
[17:48:04.481]                 NAMES <- toupper(removed)
[17:48:04.481]                 for (kk in seq_along(NAMES)) {
[17:48:04.481]                   name <- removed[[kk]]
[17:48:04.481]                   NAME <- NAMES[[kk]]
[17:48:04.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.481]                     next
[17:48:04.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:04.481]                 }
[17:48:04.481]                 if (length(args) > 0) 
[17:48:04.481]                   base::do.call(base::Sys.setenv, args = args)
[17:48:04.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:04.481]             }
[17:48:04.481]             else {
[17:48:04.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:04.481]             }
[17:48:04.481]             {
[17:48:04.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:04.481]                   0L) {
[17:48:04.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:04.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:04.481]                   base::options(opts)
[17:48:04.481]                 }
[17:48:04.481]                 {
[17:48:04.481]                   {
[17:48:04.481]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:04.481]                     NULL
[17:48:04.481]                   }
[17:48:04.481]                   options(future.plan = NULL)
[17:48:04.481]                   if (is.na(NA_character_)) 
[17:48:04.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:04.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:04.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:04.481]                     .init = FALSE)
[17:48:04.481]                 }
[17:48:04.481]             }
[17:48:04.481]         }
[17:48:04.481]     })
[17:48:04.481]     if (TRUE) {
[17:48:04.481]         base::sink(type = "output", split = FALSE)
[17:48:04.481]         if (TRUE) {
[17:48:04.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:04.481]         }
[17:48:04.481]         else {
[17:48:04.481]             ...future.result["stdout"] <- base::list(NULL)
[17:48:04.481]         }
[17:48:04.481]         base::close(...future.stdout)
[17:48:04.481]         ...future.stdout <- NULL
[17:48:04.481]     }
[17:48:04.481]     ...future.result$conditions <- ...future.conditions
[17:48:04.481]     ...future.result$finished <- base::Sys.time()
[17:48:04.481]     ...future.result
[17:48:04.481] }
[17:48:04.484] MultisessionFuture started
[17:48:04.484] - Launch lazy future ... done
[17:48:04.484] run() for ‘MultisessionFuture’ ... done
[17:48:04.485] receiveMessageFromWorker() for ClusterFuture ...
[17:48:04.486] - Validating connection of MultisessionFuture
[17:48:04.486] - received message: FutureResult
[17:48:04.486] - Received FutureResult
[17:48:04.486] - Erased future from FutureRegistry
[17:48:04.486] result() for ClusterFuture ...
[17:48:04.486] - result already collected: FutureResult
[17:48:04.487] result() for ClusterFuture ... done
[17:48:04.487] signalConditions() ...
[17:48:04.487]  - include = ‘immediateCondition’
[17:48:04.487]  - exclude = 
[17:48:04.487]  - resignal = FALSE
[17:48:04.487]  - Number of conditions: 1
[17:48:04.487] signalConditions() ... done
[17:48:04.487] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:04.487] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[17:48:04.487] getGlobalsAndPackages() ...
[17:48:04.488] Searching for globals...
[17:48:04.489] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:04.489] Searching for globals ... DONE
[17:48:04.489] Resolving globals: FALSE
[17:48:04.489] 
[17:48:04.489] 
[17:48:04.489] getGlobalsAndPackages() ... DONE
[17:48:04.490] run() for ‘Future’ ...
[17:48:04.490] - state: ‘created’
[17:48:04.490] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:04.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:04.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:04.504]   - Field: ‘node’
[17:48:04.504]   - Field: ‘label’
[17:48:04.504]   - Field: ‘local’
[17:48:04.504]   - Field: ‘owner’
[17:48:04.504]   - Field: ‘envir’
[17:48:04.504]   - Field: ‘workers’
[17:48:04.505]   - Field: ‘packages’
[17:48:04.505]   - Field: ‘gc’
[17:48:04.505]   - Field: ‘conditions’
[17:48:04.505]   - Field: ‘persistent’
[17:48:04.505]   - Field: ‘expr’
[17:48:04.505]   - Field: ‘uuid’
[17:48:04.505]   - Field: ‘seed’
[17:48:04.505]   - Field: ‘version’
[17:48:04.505]   - Field: ‘result’
[17:48:04.505]   - Field: ‘asynchronous’
[17:48:04.505]   - Field: ‘calls’
[17:48:04.506]   - Field: ‘globals’
[17:48:04.506]   - Field: ‘stdout’
[17:48:04.506]   - Field: ‘earlySignal’
[17:48:04.506]   - Field: ‘lazy’
[17:48:04.506]   - Field: ‘state’
[17:48:04.506] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:04.506] - Launch lazy future ...
[17:48:04.506] Packages needed by the future expression (n = 0): <none>
[17:48:04.506] Packages needed by future strategies (n = 0): <none>
[17:48:04.507] {
[17:48:04.507]     {
[17:48:04.507]         {
[17:48:04.507]             ...future.startTime <- base::Sys.time()
[17:48:04.507]             {
[17:48:04.507]                 {
[17:48:04.507]                   {
[17:48:04.507]                     {
[17:48:04.507]                       base::local({
[17:48:04.507]                         has_future <- base::requireNamespace("future", 
[17:48:04.507]                           quietly = TRUE)
[17:48:04.507]                         if (has_future) {
[17:48:04.507]                           ns <- base::getNamespace("future")
[17:48:04.507]                           version <- ns[[".package"]][["version"]]
[17:48:04.507]                           if (is.null(version)) 
[17:48:04.507]                             version <- utils::packageVersion("future")
[17:48:04.507]                         }
[17:48:04.507]                         else {
[17:48:04.507]                           version <- NULL
[17:48:04.507]                         }
[17:48:04.507]                         if (!has_future || version < "1.8.0") {
[17:48:04.507]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:04.507]                             "", base::R.version$version.string), 
[17:48:04.507]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:04.507]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:04.507]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:04.507]                               "release", "version")], collapse = " "), 
[17:48:04.507]                             hostname = base::Sys.info()[["nodename"]])
[17:48:04.507]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:04.507]                             info)
[17:48:04.507]                           info <- base::paste(info, collapse = "; ")
[17:48:04.507]                           if (!has_future) {
[17:48:04.507]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:04.507]                               info)
[17:48:04.507]                           }
[17:48:04.507]                           else {
[17:48:04.507]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:04.507]                               info, version)
[17:48:04.507]                           }
[17:48:04.507]                           base::stop(msg)
[17:48:04.507]                         }
[17:48:04.507]                       })
[17:48:04.507]                     }
[17:48:04.507]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:04.507]                     base::options(mc.cores = 1L)
[17:48:04.507]                   }
[17:48:04.507]                   ...future.strategy.old <- future::plan("list")
[17:48:04.507]                   options(future.plan = NULL)
[17:48:04.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:04.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:04.507]                 }
[17:48:04.507]                 ...future.workdir <- getwd()
[17:48:04.507]             }
[17:48:04.507]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:04.507]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:04.507]         }
[17:48:04.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:04.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:04.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:04.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:04.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:04.507]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:04.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:04.507]             base::names(...future.oldOptions))
[17:48:04.507]     }
[17:48:04.507]     if (FALSE) {
[17:48:04.507]     }
[17:48:04.507]     else {
[17:48:04.507]         if (TRUE) {
[17:48:04.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:04.507]                 open = "w")
[17:48:04.507]         }
[17:48:04.507]         else {
[17:48:04.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:04.507]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:04.507]         }
[17:48:04.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:04.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:04.507]             base::sink(type = "output", split = FALSE)
[17:48:04.507]             base::close(...future.stdout)
[17:48:04.507]         }, add = TRUE)
[17:48:04.507]     }
[17:48:04.507]     ...future.frame <- base::sys.nframe()
[17:48:04.507]     ...future.conditions <- base::list()
[17:48:04.507]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:04.507]     if (FALSE) {
[17:48:04.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:04.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:04.507]     }
[17:48:04.507]     ...future.result <- base::tryCatch({
[17:48:04.507]         base::withCallingHandlers({
[17:48:04.507]             ...future.value <- base::withVisible(base::local({
[17:48:04.507]                 ...future.makeSendCondition <- base::local({
[17:48:04.507]                   sendCondition <- NULL
[17:48:04.507]                   function(frame = 1L) {
[17:48:04.507]                     if (is.function(sendCondition)) 
[17:48:04.507]                       return(sendCondition)
[17:48:04.507]                     ns <- getNamespace("parallel")
[17:48:04.507]                     if (exists("sendData", mode = "function", 
[17:48:04.507]                       envir = ns)) {
[17:48:04.507]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:04.507]                         envir = ns)
[17:48:04.507]                       envir <- sys.frame(frame)
[17:48:04.507]                       master <- NULL
[17:48:04.507]                       while (!identical(envir, .GlobalEnv) && 
[17:48:04.507]                         !identical(envir, emptyenv())) {
[17:48:04.507]                         if (exists("master", mode = "list", envir = envir, 
[17:48:04.507]                           inherits = FALSE)) {
[17:48:04.507]                           master <- get("master", mode = "list", 
[17:48:04.507]                             envir = envir, inherits = FALSE)
[17:48:04.507]                           if (inherits(master, c("SOCKnode", 
[17:48:04.507]                             "SOCK0node"))) {
[17:48:04.507]                             sendCondition <<- function(cond) {
[17:48:04.507]                               data <- list(type = "VALUE", value = cond, 
[17:48:04.507]                                 success = TRUE)
[17:48:04.507]                               parallel_sendData(master, data)
[17:48:04.507]                             }
[17:48:04.507]                             return(sendCondition)
[17:48:04.507]                           }
[17:48:04.507]                         }
[17:48:04.507]                         frame <- frame + 1L
[17:48:04.507]                         envir <- sys.frame(frame)
[17:48:04.507]                       }
[17:48:04.507]                     }
[17:48:04.507]                     sendCondition <<- function(cond) NULL
[17:48:04.507]                   }
[17:48:04.507]                 })
[17:48:04.507]                 withCallingHandlers({
[17:48:04.507]                   {
[17:48:04.507]                     Sys.sleep(0.5)
[17:48:04.507]                     list(a = 1, b = 42L)
[17:48:04.507]                   }
[17:48:04.507]                 }, immediateCondition = function(cond) {
[17:48:04.507]                   sendCondition <- ...future.makeSendCondition()
[17:48:04.507]                   sendCondition(cond)
[17:48:04.507]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.507]                   {
[17:48:04.507]                     inherits <- base::inherits
[17:48:04.507]                     invokeRestart <- base::invokeRestart
[17:48:04.507]                     is.null <- base::is.null
[17:48:04.507]                     muffled <- FALSE
[17:48:04.507]                     if (inherits(cond, "message")) {
[17:48:04.507]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:04.507]                       if (muffled) 
[17:48:04.507]                         invokeRestart("muffleMessage")
[17:48:04.507]                     }
[17:48:04.507]                     else if (inherits(cond, "warning")) {
[17:48:04.507]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:04.507]                       if (muffled) 
[17:48:04.507]                         invokeRestart("muffleWarning")
[17:48:04.507]                     }
[17:48:04.507]                     else if (inherits(cond, "condition")) {
[17:48:04.507]                       if (!is.null(pattern)) {
[17:48:04.507]                         computeRestarts <- base::computeRestarts
[17:48:04.507]                         grepl <- base::grepl
[17:48:04.507]                         restarts <- computeRestarts(cond)
[17:48:04.507]                         for (restart in restarts) {
[17:48:04.507]                           name <- restart$name
[17:48:04.507]                           if (is.null(name)) 
[17:48:04.507]                             next
[17:48:04.507]                           if (!grepl(pattern, name)) 
[17:48:04.507]                             next
[17:48:04.507]                           invokeRestart(restart)
[17:48:04.507]                           muffled <- TRUE
[17:48:04.507]                           break
[17:48:04.507]                         }
[17:48:04.507]                       }
[17:48:04.507]                     }
[17:48:04.507]                     invisible(muffled)
[17:48:04.507]                   }
[17:48:04.507]                   muffleCondition(cond)
[17:48:04.507]                 })
[17:48:04.507]             }))
[17:48:04.507]             future::FutureResult(value = ...future.value$value, 
[17:48:04.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:04.507]                   ...future.rng), globalenv = if (FALSE) 
[17:48:04.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:04.507]                     ...future.globalenv.names))
[17:48:04.507]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:04.507]         }, condition = base::local({
[17:48:04.507]             c <- base::c
[17:48:04.507]             inherits <- base::inherits
[17:48:04.507]             invokeRestart <- base::invokeRestart
[17:48:04.507]             length <- base::length
[17:48:04.507]             list <- base::list
[17:48:04.507]             seq.int <- base::seq.int
[17:48:04.507]             signalCondition <- base::signalCondition
[17:48:04.507]             sys.calls <- base::sys.calls
[17:48:04.507]             `[[` <- base::`[[`
[17:48:04.507]             `+` <- base::`+`
[17:48:04.507]             `<<-` <- base::`<<-`
[17:48:04.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:04.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:04.507]                   3L)]
[17:48:04.507]             }
[17:48:04.507]             function(cond) {
[17:48:04.507]                 is_error <- inherits(cond, "error")
[17:48:04.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:04.507]                   NULL)
[17:48:04.507]                 if (is_error) {
[17:48:04.507]                   sessionInformation <- function() {
[17:48:04.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:04.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:04.507]                       search = base::search(), system = base::Sys.info())
[17:48:04.507]                   }
[17:48:04.507]                   ...future.conditions[[length(...future.conditions) + 
[17:48:04.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:04.507]                     cond$call), session = sessionInformation(), 
[17:48:04.507]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:04.507]                   signalCondition(cond)
[17:48:04.507]                 }
[17:48:04.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:04.507]                 "immediateCondition"))) {
[17:48:04.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:04.507]                   ...future.conditions[[length(...future.conditions) + 
[17:48:04.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:04.507]                   if (TRUE && !signal) {
[17:48:04.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.507]                     {
[17:48:04.507]                       inherits <- base::inherits
[17:48:04.507]                       invokeRestart <- base::invokeRestart
[17:48:04.507]                       is.null <- base::is.null
[17:48:04.507]                       muffled <- FALSE
[17:48:04.507]                       if (inherits(cond, "message")) {
[17:48:04.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:04.507]                         if (muffled) 
[17:48:04.507]                           invokeRestart("muffleMessage")
[17:48:04.507]                       }
[17:48:04.507]                       else if (inherits(cond, "warning")) {
[17:48:04.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:04.507]                         if (muffled) 
[17:48:04.507]                           invokeRestart("muffleWarning")
[17:48:04.507]                       }
[17:48:04.507]                       else if (inherits(cond, "condition")) {
[17:48:04.507]                         if (!is.null(pattern)) {
[17:48:04.507]                           computeRestarts <- base::computeRestarts
[17:48:04.507]                           grepl <- base::grepl
[17:48:04.507]                           restarts <- computeRestarts(cond)
[17:48:04.507]                           for (restart in restarts) {
[17:48:04.507]                             name <- restart$name
[17:48:04.507]                             if (is.null(name)) 
[17:48:04.507]                               next
[17:48:04.507]                             if (!grepl(pattern, name)) 
[17:48:04.507]                               next
[17:48:04.507]                             invokeRestart(restart)
[17:48:04.507]                             muffled <- TRUE
[17:48:04.507]                             break
[17:48:04.507]                           }
[17:48:04.507]                         }
[17:48:04.507]                       }
[17:48:04.507]                       invisible(muffled)
[17:48:04.507]                     }
[17:48:04.507]                     muffleCondition(cond, pattern = "^muffle")
[17:48:04.507]                   }
[17:48:04.507]                 }
[17:48:04.507]                 else {
[17:48:04.507]                   if (TRUE) {
[17:48:04.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:04.507]                     {
[17:48:04.507]                       inherits <- base::inherits
[17:48:04.507]                       invokeRestart <- base::invokeRestart
[17:48:04.507]                       is.null <- base::is.null
[17:48:04.507]                       muffled <- FALSE
[17:48:04.507]                       if (inherits(cond, "message")) {
[17:48:04.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:04.507]                         if (muffled) 
[17:48:04.507]                           invokeRestart("muffleMessage")
[17:48:04.507]                       }
[17:48:04.507]                       else if (inherits(cond, "warning")) {
[17:48:04.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:04.507]                         if (muffled) 
[17:48:04.507]                           invokeRestart("muffleWarning")
[17:48:04.507]                       }
[17:48:04.507]                       else if (inherits(cond, "condition")) {
[17:48:04.507]                         if (!is.null(pattern)) {
[17:48:04.507]                           computeRestarts <- base::computeRestarts
[17:48:04.507]                           grepl <- base::grepl
[17:48:04.507]                           restarts <- computeRestarts(cond)
[17:48:04.507]                           for (restart in restarts) {
[17:48:04.507]                             name <- restart$name
[17:48:04.507]                             if (is.null(name)) 
[17:48:04.507]                               next
[17:48:04.507]                             if (!grepl(pattern, name)) 
[17:48:04.507]                               next
[17:48:04.507]                             invokeRestart(restart)
[17:48:04.507]                             muffled <- TRUE
[17:48:04.507]                             break
[17:48:04.507]                           }
[17:48:04.507]                         }
[17:48:04.507]                       }
[17:48:04.507]                       invisible(muffled)
[17:48:04.507]                     }
[17:48:04.507]                     muffleCondition(cond, pattern = "^muffle")
[17:48:04.507]                   }
[17:48:04.507]                 }
[17:48:04.507]             }
[17:48:04.507]         }))
[17:48:04.507]     }, error = function(ex) {
[17:48:04.507]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:04.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:04.507]                 ...future.rng), started = ...future.startTime, 
[17:48:04.507]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:04.507]             version = "1.8"), class = "FutureResult")
[17:48:04.507]     }, finally = {
[17:48:04.507]         if (!identical(...future.workdir, getwd())) 
[17:48:04.507]             setwd(...future.workdir)
[17:48:04.507]         {
[17:48:04.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:04.507]                 ...future.oldOptions$nwarnings <- NULL
[17:48:04.507]             }
[17:48:04.507]             base::options(...future.oldOptions)
[17:48:04.507]             if (.Platform$OS.type == "windows") {
[17:48:04.507]                 old_names <- names(...future.oldEnvVars)
[17:48:04.507]                 envs <- base::Sys.getenv()
[17:48:04.507]                 names <- names(envs)
[17:48:04.507]                 common <- intersect(names, old_names)
[17:48:04.507]                 added <- setdiff(names, old_names)
[17:48:04.507]                 removed <- setdiff(old_names, names)
[17:48:04.507]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:04.507]                   envs[common]]
[17:48:04.507]                 NAMES <- toupper(changed)
[17:48:04.507]                 args <- list()
[17:48:04.507]                 for (kk in seq_along(NAMES)) {
[17:48:04.507]                   name <- changed[[kk]]
[17:48:04.507]                   NAME <- NAMES[[kk]]
[17:48:04.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.507]                     next
[17:48:04.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:04.507]                 }
[17:48:04.507]                 NAMES <- toupper(added)
[17:48:04.507]                 for (kk in seq_along(NAMES)) {
[17:48:04.507]                   name <- added[[kk]]
[17:48:04.507]                   NAME <- NAMES[[kk]]
[17:48:04.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.507]                     next
[17:48:04.507]                   args[[name]] <- ""
[17:48:04.507]                 }
[17:48:04.507]                 NAMES <- toupper(removed)
[17:48:04.507]                 for (kk in seq_along(NAMES)) {
[17:48:04.507]                   name <- removed[[kk]]
[17:48:04.507]                   NAME <- NAMES[[kk]]
[17:48:04.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:04.507]                     next
[17:48:04.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:04.507]                 }
[17:48:04.507]                 if (length(args) > 0) 
[17:48:04.507]                   base::do.call(base::Sys.setenv, args = args)
[17:48:04.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:04.507]             }
[17:48:04.507]             else {
[17:48:04.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:04.507]             }
[17:48:04.507]             {
[17:48:04.507]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:04.507]                   0L) {
[17:48:04.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:04.507]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:04.507]                   base::options(opts)
[17:48:04.507]                 }
[17:48:04.507]                 {
[17:48:04.507]                   {
[17:48:04.507]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:04.507]                     NULL
[17:48:04.507]                   }
[17:48:04.507]                   options(future.plan = NULL)
[17:48:04.507]                   if (is.na(NA_character_)) 
[17:48:04.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:04.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:04.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:04.507]                     .init = FALSE)
[17:48:04.507]                 }
[17:48:04.507]             }
[17:48:04.507]         }
[17:48:04.507]     })
[17:48:04.507]     if (TRUE) {
[17:48:04.507]         base::sink(type = "output", split = FALSE)
[17:48:04.507]         if (TRUE) {
[17:48:04.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:04.507]         }
[17:48:04.507]         else {
[17:48:04.507]             ...future.result["stdout"] <- base::list(NULL)
[17:48:04.507]         }
[17:48:04.507]         base::close(...future.stdout)
[17:48:04.507]         ...future.stdout <- NULL
[17:48:04.507]     }
[17:48:04.507]     ...future.result$conditions <- ...future.conditions
[17:48:04.507]     ...future.result$finished <- base::Sys.time()
[17:48:04.507]     ...future.result
[17:48:04.507] }
[17:48:04.510] MultisessionFuture started
[17:48:04.510] - Launch lazy future ... done
[17:48:04.510] run() for ‘MultisessionFuture’ ... done
[17:48:05.012] receiveMessageFromWorker() for ClusterFuture ...
[17:48:05.012] - Validating connection of MultisessionFuture
[17:48:05.013] - received message: FutureResult
[17:48:05.013] - Received FutureResult
[17:48:05.013] - Erased future from FutureRegistry
[17:48:05.013] result() for ClusterFuture ...
[17:48:05.013] - result already collected: FutureResult
[17:48:05.013] result() for ClusterFuture ... done
[17:48:05.013] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:05.013] resolve() on list ...
[17:48:05.014]  recursive: 98
[17:48:05.014]  length: 2
[17:48:05.014]  elements: ‘a’, ‘b’
[17:48:05.014]  length: 1 (resolved future 1)
[17:48:05.014]  length: 0 (resolved future 2)
[17:48:05.014] resolve() on list ... DONE
[17:48:05.014] A MultisessionFuture was resolved (and resolved itself)
[17:48:05.014] getGlobalsAndPackages() ...
[17:48:05.014] Searching for globals...
[17:48:05.015] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:05.016] Searching for globals ... DONE
[17:48:05.016] Resolving globals: FALSE
[17:48:05.016] 
[17:48:05.016] 
[17:48:05.016] getGlobalsAndPackages() ... DONE
[17:48:05.016] run() for ‘Future’ ...
[17:48:05.017] - state: ‘created’
[17:48:05.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:05.030] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:05.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:05.031]   - Field: ‘node’
[17:48:05.031]   - Field: ‘label’
[17:48:05.031]   - Field: ‘local’
[17:48:05.031]   - Field: ‘owner’
[17:48:05.031]   - Field: ‘envir’
[17:48:05.031]   - Field: ‘workers’
[17:48:05.031]   - Field: ‘packages’
[17:48:05.031]   - Field: ‘gc’
[17:48:05.031]   - Field: ‘conditions’
[17:48:05.032]   - Field: ‘persistent’
[17:48:05.032]   - Field: ‘expr’
[17:48:05.032]   - Field: ‘uuid’
[17:48:05.032]   - Field: ‘seed’
[17:48:05.032]   - Field: ‘version’
[17:48:05.032]   - Field: ‘result’
[17:48:05.032]   - Field: ‘asynchronous’
[17:48:05.032]   - Field: ‘calls’
[17:48:05.032]   - Field: ‘globals’
[17:48:05.032]   - Field: ‘stdout’
[17:48:05.032]   - Field: ‘earlySignal’
[17:48:05.032]   - Field: ‘lazy’
[17:48:05.033]   - Field: ‘state’
[17:48:05.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:05.033] - Launch lazy future ...
[17:48:05.033] Packages needed by the future expression (n = 0): <none>
[17:48:05.033] Packages needed by future strategies (n = 0): <none>
[17:48:05.034] {
[17:48:05.034]     {
[17:48:05.034]         {
[17:48:05.034]             ...future.startTime <- base::Sys.time()
[17:48:05.034]             {
[17:48:05.034]                 {
[17:48:05.034]                   {
[17:48:05.034]                     {
[17:48:05.034]                       base::local({
[17:48:05.034]                         has_future <- base::requireNamespace("future", 
[17:48:05.034]                           quietly = TRUE)
[17:48:05.034]                         if (has_future) {
[17:48:05.034]                           ns <- base::getNamespace("future")
[17:48:05.034]                           version <- ns[[".package"]][["version"]]
[17:48:05.034]                           if (is.null(version)) 
[17:48:05.034]                             version <- utils::packageVersion("future")
[17:48:05.034]                         }
[17:48:05.034]                         else {
[17:48:05.034]                           version <- NULL
[17:48:05.034]                         }
[17:48:05.034]                         if (!has_future || version < "1.8.0") {
[17:48:05.034]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:05.034]                             "", base::R.version$version.string), 
[17:48:05.034]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:05.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:05.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:05.034]                               "release", "version")], collapse = " "), 
[17:48:05.034]                             hostname = base::Sys.info()[["nodename"]])
[17:48:05.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:05.034]                             info)
[17:48:05.034]                           info <- base::paste(info, collapse = "; ")
[17:48:05.034]                           if (!has_future) {
[17:48:05.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:05.034]                               info)
[17:48:05.034]                           }
[17:48:05.034]                           else {
[17:48:05.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:05.034]                               info, version)
[17:48:05.034]                           }
[17:48:05.034]                           base::stop(msg)
[17:48:05.034]                         }
[17:48:05.034]                       })
[17:48:05.034]                     }
[17:48:05.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:05.034]                     base::options(mc.cores = 1L)
[17:48:05.034]                   }
[17:48:05.034]                   ...future.strategy.old <- future::plan("list")
[17:48:05.034]                   options(future.plan = NULL)
[17:48:05.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:05.034]                 }
[17:48:05.034]                 ...future.workdir <- getwd()
[17:48:05.034]             }
[17:48:05.034]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:05.034]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:05.034]         }
[17:48:05.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:05.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:05.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:05.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:05.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:05.034]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:05.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:05.034]             base::names(...future.oldOptions))
[17:48:05.034]     }
[17:48:05.034]     if (FALSE) {
[17:48:05.034]     }
[17:48:05.034]     else {
[17:48:05.034]         if (TRUE) {
[17:48:05.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:05.034]                 open = "w")
[17:48:05.034]         }
[17:48:05.034]         else {
[17:48:05.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:05.034]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:05.034]         }
[17:48:05.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:05.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:05.034]             base::sink(type = "output", split = FALSE)
[17:48:05.034]             base::close(...future.stdout)
[17:48:05.034]         }, add = TRUE)
[17:48:05.034]     }
[17:48:05.034]     ...future.frame <- base::sys.nframe()
[17:48:05.034]     ...future.conditions <- base::list()
[17:48:05.034]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:05.034]     if (FALSE) {
[17:48:05.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:05.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:05.034]     }
[17:48:05.034]     ...future.result <- base::tryCatch({
[17:48:05.034]         base::withCallingHandlers({
[17:48:05.034]             ...future.value <- base::withVisible(base::local({
[17:48:05.034]                 ...future.makeSendCondition <- base::local({
[17:48:05.034]                   sendCondition <- NULL
[17:48:05.034]                   function(frame = 1L) {
[17:48:05.034]                     if (is.function(sendCondition)) 
[17:48:05.034]                       return(sendCondition)
[17:48:05.034]                     ns <- getNamespace("parallel")
[17:48:05.034]                     if (exists("sendData", mode = "function", 
[17:48:05.034]                       envir = ns)) {
[17:48:05.034]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:05.034]                         envir = ns)
[17:48:05.034]                       envir <- sys.frame(frame)
[17:48:05.034]                       master <- NULL
[17:48:05.034]                       while (!identical(envir, .GlobalEnv) && 
[17:48:05.034]                         !identical(envir, emptyenv())) {
[17:48:05.034]                         if (exists("master", mode = "list", envir = envir, 
[17:48:05.034]                           inherits = FALSE)) {
[17:48:05.034]                           master <- get("master", mode = "list", 
[17:48:05.034]                             envir = envir, inherits = FALSE)
[17:48:05.034]                           if (inherits(master, c("SOCKnode", 
[17:48:05.034]                             "SOCK0node"))) {
[17:48:05.034]                             sendCondition <<- function(cond) {
[17:48:05.034]                               data <- list(type = "VALUE", value = cond, 
[17:48:05.034]                                 success = TRUE)
[17:48:05.034]                               parallel_sendData(master, data)
[17:48:05.034]                             }
[17:48:05.034]                             return(sendCondition)
[17:48:05.034]                           }
[17:48:05.034]                         }
[17:48:05.034]                         frame <- frame + 1L
[17:48:05.034]                         envir <- sys.frame(frame)
[17:48:05.034]                       }
[17:48:05.034]                     }
[17:48:05.034]                     sendCondition <<- function(cond) NULL
[17:48:05.034]                   }
[17:48:05.034]                 })
[17:48:05.034]                 withCallingHandlers({
[17:48:05.034]                   {
[17:48:05.034]                     Sys.sleep(0.5)
[17:48:05.034]                     list(a = 1, b = 42L)
[17:48:05.034]                   }
[17:48:05.034]                 }, immediateCondition = function(cond) {
[17:48:05.034]                   sendCondition <- ...future.makeSendCondition()
[17:48:05.034]                   sendCondition(cond)
[17:48:05.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.034]                   {
[17:48:05.034]                     inherits <- base::inherits
[17:48:05.034]                     invokeRestart <- base::invokeRestart
[17:48:05.034]                     is.null <- base::is.null
[17:48:05.034]                     muffled <- FALSE
[17:48:05.034]                     if (inherits(cond, "message")) {
[17:48:05.034]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:05.034]                       if (muffled) 
[17:48:05.034]                         invokeRestart("muffleMessage")
[17:48:05.034]                     }
[17:48:05.034]                     else if (inherits(cond, "warning")) {
[17:48:05.034]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:05.034]                       if (muffled) 
[17:48:05.034]                         invokeRestart("muffleWarning")
[17:48:05.034]                     }
[17:48:05.034]                     else if (inherits(cond, "condition")) {
[17:48:05.034]                       if (!is.null(pattern)) {
[17:48:05.034]                         computeRestarts <- base::computeRestarts
[17:48:05.034]                         grepl <- base::grepl
[17:48:05.034]                         restarts <- computeRestarts(cond)
[17:48:05.034]                         for (restart in restarts) {
[17:48:05.034]                           name <- restart$name
[17:48:05.034]                           if (is.null(name)) 
[17:48:05.034]                             next
[17:48:05.034]                           if (!grepl(pattern, name)) 
[17:48:05.034]                             next
[17:48:05.034]                           invokeRestart(restart)
[17:48:05.034]                           muffled <- TRUE
[17:48:05.034]                           break
[17:48:05.034]                         }
[17:48:05.034]                       }
[17:48:05.034]                     }
[17:48:05.034]                     invisible(muffled)
[17:48:05.034]                   }
[17:48:05.034]                   muffleCondition(cond)
[17:48:05.034]                 })
[17:48:05.034]             }))
[17:48:05.034]             future::FutureResult(value = ...future.value$value, 
[17:48:05.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.034]                   ...future.rng), globalenv = if (FALSE) 
[17:48:05.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:05.034]                     ...future.globalenv.names))
[17:48:05.034]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:05.034]         }, condition = base::local({
[17:48:05.034]             c <- base::c
[17:48:05.034]             inherits <- base::inherits
[17:48:05.034]             invokeRestart <- base::invokeRestart
[17:48:05.034]             length <- base::length
[17:48:05.034]             list <- base::list
[17:48:05.034]             seq.int <- base::seq.int
[17:48:05.034]             signalCondition <- base::signalCondition
[17:48:05.034]             sys.calls <- base::sys.calls
[17:48:05.034]             `[[` <- base::`[[`
[17:48:05.034]             `+` <- base::`+`
[17:48:05.034]             `<<-` <- base::`<<-`
[17:48:05.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:05.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:05.034]                   3L)]
[17:48:05.034]             }
[17:48:05.034]             function(cond) {
[17:48:05.034]                 is_error <- inherits(cond, "error")
[17:48:05.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:05.034]                   NULL)
[17:48:05.034]                 if (is_error) {
[17:48:05.034]                   sessionInformation <- function() {
[17:48:05.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:05.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:05.034]                       search = base::search(), system = base::Sys.info())
[17:48:05.034]                   }
[17:48:05.034]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:05.034]                     cond$call), session = sessionInformation(), 
[17:48:05.034]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:05.034]                   signalCondition(cond)
[17:48:05.034]                 }
[17:48:05.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:05.034]                 "immediateCondition"))) {
[17:48:05.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:05.034]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:05.034]                   if (TRUE && !signal) {
[17:48:05.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.034]                     {
[17:48:05.034]                       inherits <- base::inherits
[17:48:05.034]                       invokeRestart <- base::invokeRestart
[17:48:05.034]                       is.null <- base::is.null
[17:48:05.034]                       muffled <- FALSE
[17:48:05.034]                       if (inherits(cond, "message")) {
[17:48:05.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.034]                         if (muffled) 
[17:48:05.034]                           invokeRestart("muffleMessage")
[17:48:05.034]                       }
[17:48:05.034]                       else if (inherits(cond, "warning")) {
[17:48:05.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.034]                         if (muffled) 
[17:48:05.034]                           invokeRestart("muffleWarning")
[17:48:05.034]                       }
[17:48:05.034]                       else if (inherits(cond, "condition")) {
[17:48:05.034]                         if (!is.null(pattern)) {
[17:48:05.034]                           computeRestarts <- base::computeRestarts
[17:48:05.034]                           grepl <- base::grepl
[17:48:05.034]                           restarts <- computeRestarts(cond)
[17:48:05.034]                           for (restart in restarts) {
[17:48:05.034]                             name <- restart$name
[17:48:05.034]                             if (is.null(name)) 
[17:48:05.034]                               next
[17:48:05.034]                             if (!grepl(pattern, name)) 
[17:48:05.034]                               next
[17:48:05.034]                             invokeRestart(restart)
[17:48:05.034]                             muffled <- TRUE
[17:48:05.034]                             break
[17:48:05.034]                           }
[17:48:05.034]                         }
[17:48:05.034]                       }
[17:48:05.034]                       invisible(muffled)
[17:48:05.034]                     }
[17:48:05.034]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.034]                   }
[17:48:05.034]                 }
[17:48:05.034]                 else {
[17:48:05.034]                   if (TRUE) {
[17:48:05.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.034]                     {
[17:48:05.034]                       inherits <- base::inherits
[17:48:05.034]                       invokeRestart <- base::invokeRestart
[17:48:05.034]                       is.null <- base::is.null
[17:48:05.034]                       muffled <- FALSE
[17:48:05.034]                       if (inherits(cond, "message")) {
[17:48:05.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.034]                         if (muffled) 
[17:48:05.034]                           invokeRestart("muffleMessage")
[17:48:05.034]                       }
[17:48:05.034]                       else if (inherits(cond, "warning")) {
[17:48:05.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.034]                         if (muffled) 
[17:48:05.034]                           invokeRestart("muffleWarning")
[17:48:05.034]                       }
[17:48:05.034]                       else if (inherits(cond, "condition")) {
[17:48:05.034]                         if (!is.null(pattern)) {
[17:48:05.034]                           computeRestarts <- base::computeRestarts
[17:48:05.034]                           grepl <- base::grepl
[17:48:05.034]                           restarts <- computeRestarts(cond)
[17:48:05.034]                           for (restart in restarts) {
[17:48:05.034]                             name <- restart$name
[17:48:05.034]                             if (is.null(name)) 
[17:48:05.034]                               next
[17:48:05.034]                             if (!grepl(pattern, name)) 
[17:48:05.034]                               next
[17:48:05.034]                             invokeRestart(restart)
[17:48:05.034]                             muffled <- TRUE
[17:48:05.034]                             break
[17:48:05.034]                           }
[17:48:05.034]                         }
[17:48:05.034]                       }
[17:48:05.034]                       invisible(muffled)
[17:48:05.034]                     }
[17:48:05.034]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.034]                   }
[17:48:05.034]                 }
[17:48:05.034]             }
[17:48:05.034]         }))
[17:48:05.034]     }, error = function(ex) {
[17:48:05.034]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:05.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.034]                 ...future.rng), started = ...future.startTime, 
[17:48:05.034]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:05.034]             version = "1.8"), class = "FutureResult")
[17:48:05.034]     }, finally = {
[17:48:05.034]         if (!identical(...future.workdir, getwd())) 
[17:48:05.034]             setwd(...future.workdir)
[17:48:05.034]         {
[17:48:05.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:05.034]                 ...future.oldOptions$nwarnings <- NULL
[17:48:05.034]             }
[17:48:05.034]             base::options(...future.oldOptions)
[17:48:05.034]             if (.Platform$OS.type == "windows") {
[17:48:05.034]                 old_names <- names(...future.oldEnvVars)
[17:48:05.034]                 envs <- base::Sys.getenv()
[17:48:05.034]                 names <- names(envs)
[17:48:05.034]                 common <- intersect(names, old_names)
[17:48:05.034]                 added <- setdiff(names, old_names)
[17:48:05.034]                 removed <- setdiff(old_names, names)
[17:48:05.034]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:05.034]                   envs[common]]
[17:48:05.034]                 NAMES <- toupper(changed)
[17:48:05.034]                 args <- list()
[17:48:05.034]                 for (kk in seq_along(NAMES)) {
[17:48:05.034]                   name <- changed[[kk]]
[17:48:05.034]                   NAME <- NAMES[[kk]]
[17:48:05.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.034]                     next
[17:48:05.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.034]                 }
[17:48:05.034]                 NAMES <- toupper(added)
[17:48:05.034]                 for (kk in seq_along(NAMES)) {
[17:48:05.034]                   name <- added[[kk]]
[17:48:05.034]                   NAME <- NAMES[[kk]]
[17:48:05.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.034]                     next
[17:48:05.034]                   args[[name]] <- ""
[17:48:05.034]                 }
[17:48:05.034]                 NAMES <- toupper(removed)
[17:48:05.034]                 for (kk in seq_along(NAMES)) {
[17:48:05.034]                   name <- removed[[kk]]
[17:48:05.034]                   NAME <- NAMES[[kk]]
[17:48:05.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.034]                     next
[17:48:05.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.034]                 }
[17:48:05.034]                 if (length(args) > 0) 
[17:48:05.034]                   base::do.call(base::Sys.setenv, args = args)
[17:48:05.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:05.034]             }
[17:48:05.034]             else {
[17:48:05.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:05.034]             }
[17:48:05.034]             {
[17:48:05.034]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:05.034]                   0L) {
[17:48:05.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:05.034]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:05.034]                   base::options(opts)
[17:48:05.034]                 }
[17:48:05.034]                 {
[17:48:05.034]                   {
[17:48:05.034]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:05.034]                     NULL
[17:48:05.034]                   }
[17:48:05.034]                   options(future.plan = NULL)
[17:48:05.034]                   if (is.na(NA_character_)) 
[17:48:05.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:05.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:05.034]                     .init = FALSE)
[17:48:05.034]                 }
[17:48:05.034]             }
[17:48:05.034]         }
[17:48:05.034]     })
[17:48:05.034]     if (TRUE) {
[17:48:05.034]         base::sink(type = "output", split = FALSE)
[17:48:05.034]         if (TRUE) {
[17:48:05.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:05.034]         }
[17:48:05.034]         else {
[17:48:05.034]             ...future.result["stdout"] <- base::list(NULL)
[17:48:05.034]         }
[17:48:05.034]         base::close(...future.stdout)
[17:48:05.034]         ...future.stdout <- NULL
[17:48:05.034]     }
[17:48:05.034]     ...future.result$conditions <- ...future.conditions
[17:48:05.034]     ...future.result$finished <- base::Sys.time()
[17:48:05.034]     ...future.result
[17:48:05.034] }
[17:48:05.036] MultisessionFuture started
[17:48:05.037] - Launch lazy future ... done
[17:48:05.037] run() for ‘MultisessionFuture’ ... done
[17:48:05.539] receiveMessageFromWorker() for ClusterFuture ...
[17:48:05.540] - Validating connection of MultisessionFuture
[17:48:05.540] - received message: FutureResult
[17:48:05.540] - Received FutureResult
[17:48:05.540] - Erased future from FutureRegistry
[17:48:05.540] result() for ClusterFuture ...
[17:48:05.540] - result already collected: FutureResult
[17:48:05.540] result() for ClusterFuture ... done
[17:48:05.540] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:05.540] resolve() on list ...
[17:48:05.541]  recursive: 98
[17:48:05.541]  length: 2
[17:48:05.541]  elements: ‘a’, ‘b’
[17:48:05.541]  length: 1 (resolved future 1)
[17:48:05.541]  length: 0 (resolved future 2)
[17:48:05.541] resolve() on list ... DONE
[17:48:05.541] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:48:05.541] getGlobalsAndPackages() ...
[17:48:05.541] Searching for globals...
[17:48:05.542] - globals found: [2] ‘list’, ‘stop’
[17:48:05.542] Searching for globals ... DONE
[17:48:05.542] Resolving globals: FALSE
[17:48:05.543] 
[17:48:05.543] 
[17:48:05.543] getGlobalsAndPackages() ... DONE
[17:48:05.543] run() for ‘Future’ ...
[17:48:05.543] - state: ‘created’
[17:48:05.543] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:05.557] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:05.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:05.557]   - Field: ‘node’
[17:48:05.558]   - Field: ‘label’
[17:48:05.558]   - Field: ‘local’
[17:48:05.558]   - Field: ‘owner’
[17:48:05.558]   - Field: ‘envir’
[17:48:05.558]   - Field: ‘workers’
[17:48:05.558]   - Field: ‘packages’
[17:48:05.558]   - Field: ‘gc’
[17:48:05.558]   - Field: ‘conditions’
[17:48:05.558]   - Field: ‘persistent’
[17:48:05.558]   - Field: ‘expr’
[17:48:05.558]   - Field: ‘uuid’
[17:48:05.559]   - Field: ‘seed’
[17:48:05.559]   - Field: ‘version’
[17:48:05.559]   - Field: ‘result’
[17:48:05.559]   - Field: ‘asynchronous’
[17:48:05.559]   - Field: ‘calls’
[17:48:05.559]   - Field: ‘globals’
[17:48:05.559]   - Field: ‘stdout’
[17:48:05.559]   - Field: ‘earlySignal’
[17:48:05.559]   - Field: ‘lazy’
[17:48:05.559]   - Field: ‘state’
[17:48:05.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:05.560] - Launch lazy future ...
[17:48:05.560] Packages needed by the future expression (n = 0): <none>
[17:48:05.560] Packages needed by future strategies (n = 0): <none>
[17:48:05.560] {
[17:48:05.560]     {
[17:48:05.560]         {
[17:48:05.560]             ...future.startTime <- base::Sys.time()
[17:48:05.560]             {
[17:48:05.560]                 {
[17:48:05.560]                   {
[17:48:05.560]                     {
[17:48:05.560]                       base::local({
[17:48:05.560]                         has_future <- base::requireNamespace("future", 
[17:48:05.560]                           quietly = TRUE)
[17:48:05.560]                         if (has_future) {
[17:48:05.560]                           ns <- base::getNamespace("future")
[17:48:05.560]                           version <- ns[[".package"]][["version"]]
[17:48:05.560]                           if (is.null(version)) 
[17:48:05.560]                             version <- utils::packageVersion("future")
[17:48:05.560]                         }
[17:48:05.560]                         else {
[17:48:05.560]                           version <- NULL
[17:48:05.560]                         }
[17:48:05.560]                         if (!has_future || version < "1.8.0") {
[17:48:05.560]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:05.560]                             "", base::R.version$version.string), 
[17:48:05.560]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:05.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:05.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:05.560]                               "release", "version")], collapse = " "), 
[17:48:05.560]                             hostname = base::Sys.info()[["nodename"]])
[17:48:05.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:05.560]                             info)
[17:48:05.560]                           info <- base::paste(info, collapse = "; ")
[17:48:05.560]                           if (!has_future) {
[17:48:05.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:05.560]                               info)
[17:48:05.560]                           }
[17:48:05.560]                           else {
[17:48:05.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:05.560]                               info, version)
[17:48:05.560]                           }
[17:48:05.560]                           base::stop(msg)
[17:48:05.560]                         }
[17:48:05.560]                       })
[17:48:05.560]                     }
[17:48:05.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:05.560]                     base::options(mc.cores = 1L)
[17:48:05.560]                   }
[17:48:05.560]                   ...future.strategy.old <- future::plan("list")
[17:48:05.560]                   options(future.plan = NULL)
[17:48:05.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:05.560]                 }
[17:48:05.560]                 ...future.workdir <- getwd()
[17:48:05.560]             }
[17:48:05.560]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:05.560]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:05.560]         }
[17:48:05.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:05.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:05.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:05.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:05.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:05.560]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:05.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:05.560]             base::names(...future.oldOptions))
[17:48:05.560]     }
[17:48:05.560]     if (FALSE) {
[17:48:05.560]     }
[17:48:05.560]     else {
[17:48:05.560]         if (TRUE) {
[17:48:05.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:05.560]                 open = "w")
[17:48:05.560]         }
[17:48:05.560]         else {
[17:48:05.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:05.560]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:05.560]         }
[17:48:05.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:05.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:05.560]             base::sink(type = "output", split = FALSE)
[17:48:05.560]             base::close(...future.stdout)
[17:48:05.560]         }, add = TRUE)
[17:48:05.560]     }
[17:48:05.560]     ...future.frame <- base::sys.nframe()
[17:48:05.560]     ...future.conditions <- base::list()
[17:48:05.560]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:05.560]     if (FALSE) {
[17:48:05.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:05.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:05.560]     }
[17:48:05.560]     ...future.result <- base::tryCatch({
[17:48:05.560]         base::withCallingHandlers({
[17:48:05.560]             ...future.value <- base::withVisible(base::local({
[17:48:05.560]                 ...future.makeSendCondition <- base::local({
[17:48:05.560]                   sendCondition <- NULL
[17:48:05.560]                   function(frame = 1L) {
[17:48:05.560]                     if (is.function(sendCondition)) 
[17:48:05.560]                       return(sendCondition)
[17:48:05.560]                     ns <- getNamespace("parallel")
[17:48:05.560]                     if (exists("sendData", mode = "function", 
[17:48:05.560]                       envir = ns)) {
[17:48:05.560]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:05.560]                         envir = ns)
[17:48:05.560]                       envir <- sys.frame(frame)
[17:48:05.560]                       master <- NULL
[17:48:05.560]                       while (!identical(envir, .GlobalEnv) && 
[17:48:05.560]                         !identical(envir, emptyenv())) {
[17:48:05.560]                         if (exists("master", mode = "list", envir = envir, 
[17:48:05.560]                           inherits = FALSE)) {
[17:48:05.560]                           master <- get("master", mode = "list", 
[17:48:05.560]                             envir = envir, inherits = FALSE)
[17:48:05.560]                           if (inherits(master, c("SOCKnode", 
[17:48:05.560]                             "SOCK0node"))) {
[17:48:05.560]                             sendCondition <<- function(cond) {
[17:48:05.560]                               data <- list(type = "VALUE", value = cond, 
[17:48:05.560]                                 success = TRUE)
[17:48:05.560]                               parallel_sendData(master, data)
[17:48:05.560]                             }
[17:48:05.560]                             return(sendCondition)
[17:48:05.560]                           }
[17:48:05.560]                         }
[17:48:05.560]                         frame <- frame + 1L
[17:48:05.560]                         envir <- sys.frame(frame)
[17:48:05.560]                       }
[17:48:05.560]                     }
[17:48:05.560]                     sendCondition <<- function(cond) NULL
[17:48:05.560]                   }
[17:48:05.560]                 })
[17:48:05.560]                 withCallingHandlers({
[17:48:05.560]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:05.560]                 }, immediateCondition = function(cond) {
[17:48:05.560]                   sendCondition <- ...future.makeSendCondition()
[17:48:05.560]                   sendCondition(cond)
[17:48:05.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.560]                   {
[17:48:05.560]                     inherits <- base::inherits
[17:48:05.560]                     invokeRestart <- base::invokeRestart
[17:48:05.560]                     is.null <- base::is.null
[17:48:05.560]                     muffled <- FALSE
[17:48:05.560]                     if (inherits(cond, "message")) {
[17:48:05.560]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:05.560]                       if (muffled) 
[17:48:05.560]                         invokeRestart("muffleMessage")
[17:48:05.560]                     }
[17:48:05.560]                     else if (inherits(cond, "warning")) {
[17:48:05.560]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:05.560]                       if (muffled) 
[17:48:05.560]                         invokeRestart("muffleWarning")
[17:48:05.560]                     }
[17:48:05.560]                     else if (inherits(cond, "condition")) {
[17:48:05.560]                       if (!is.null(pattern)) {
[17:48:05.560]                         computeRestarts <- base::computeRestarts
[17:48:05.560]                         grepl <- base::grepl
[17:48:05.560]                         restarts <- computeRestarts(cond)
[17:48:05.560]                         for (restart in restarts) {
[17:48:05.560]                           name <- restart$name
[17:48:05.560]                           if (is.null(name)) 
[17:48:05.560]                             next
[17:48:05.560]                           if (!grepl(pattern, name)) 
[17:48:05.560]                             next
[17:48:05.560]                           invokeRestart(restart)
[17:48:05.560]                           muffled <- TRUE
[17:48:05.560]                           break
[17:48:05.560]                         }
[17:48:05.560]                       }
[17:48:05.560]                     }
[17:48:05.560]                     invisible(muffled)
[17:48:05.560]                   }
[17:48:05.560]                   muffleCondition(cond)
[17:48:05.560]                 })
[17:48:05.560]             }))
[17:48:05.560]             future::FutureResult(value = ...future.value$value, 
[17:48:05.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.560]                   ...future.rng), globalenv = if (FALSE) 
[17:48:05.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:05.560]                     ...future.globalenv.names))
[17:48:05.560]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:05.560]         }, condition = base::local({
[17:48:05.560]             c <- base::c
[17:48:05.560]             inherits <- base::inherits
[17:48:05.560]             invokeRestart <- base::invokeRestart
[17:48:05.560]             length <- base::length
[17:48:05.560]             list <- base::list
[17:48:05.560]             seq.int <- base::seq.int
[17:48:05.560]             signalCondition <- base::signalCondition
[17:48:05.560]             sys.calls <- base::sys.calls
[17:48:05.560]             `[[` <- base::`[[`
[17:48:05.560]             `+` <- base::`+`
[17:48:05.560]             `<<-` <- base::`<<-`
[17:48:05.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:05.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:05.560]                   3L)]
[17:48:05.560]             }
[17:48:05.560]             function(cond) {
[17:48:05.560]                 is_error <- inherits(cond, "error")
[17:48:05.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:05.560]                   NULL)
[17:48:05.560]                 if (is_error) {
[17:48:05.560]                   sessionInformation <- function() {
[17:48:05.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:05.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:05.560]                       search = base::search(), system = base::Sys.info())
[17:48:05.560]                   }
[17:48:05.560]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:05.560]                     cond$call), session = sessionInformation(), 
[17:48:05.560]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:05.560]                   signalCondition(cond)
[17:48:05.560]                 }
[17:48:05.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:05.560]                 "immediateCondition"))) {
[17:48:05.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:05.560]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:05.560]                   if (TRUE && !signal) {
[17:48:05.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.560]                     {
[17:48:05.560]                       inherits <- base::inherits
[17:48:05.560]                       invokeRestart <- base::invokeRestart
[17:48:05.560]                       is.null <- base::is.null
[17:48:05.560]                       muffled <- FALSE
[17:48:05.560]                       if (inherits(cond, "message")) {
[17:48:05.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.560]                         if (muffled) 
[17:48:05.560]                           invokeRestart("muffleMessage")
[17:48:05.560]                       }
[17:48:05.560]                       else if (inherits(cond, "warning")) {
[17:48:05.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.560]                         if (muffled) 
[17:48:05.560]                           invokeRestart("muffleWarning")
[17:48:05.560]                       }
[17:48:05.560]                       else if (inherits(cond, "condition")) {
[17:48:05.560]                         if (!is.null(pattern)) {
[17:48:05.560]                           computeRestarts <- base::computeRestarts
[17:48:05.560]                           grepl <- base::grepl
[17:48:05.560]                           restarts <- computeRestarts(cond)
[17:48:05.560]                           for (restart in restarts) {
[17:48:05.560]                             name <- restart$name
[17:48:05.560]                             if (is.null(name)) 
[17:48:05.560]                               next
[17:48:05.560]                             if (!grepl(pattern, name)) 
[17:48:05.560]                               next
[17:48:05.560]                             invokeRestart(restart)
[17:48:05.560]                             muffled <- TRUE
[17:48:05.560]                             break
[17:48:05.560]                           }
[17:48:05.560]                         }
[17:48:05.560]                       }
[17:48:05.560]                       invisible(muffled)
[17:48:05.560]                     }
[17:48:05.560]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.560]                   }
[17:48:05.560]                 }
[17:48:05.560]                 else {
[17:48:05.560]                   if (TRUE) {
[17:48:05.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.560]                     {
[17:48:05.560]                       inherits <- base::inherits
[17:48:05.560]                       invokeRestart <- base::invokeRestart
[17:48:05.560]                       is.null <- base::is.null
[17:48:05.560]                       muffled <- FALSE
[17:48:05.560]                       if (inherits(cond, "message")) {
[17:48:05.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.560]                         if (muffled) 
[17:48:05.560]                           invokeRestart("muffleMessage")
[17:48:05.560]                       }
[17:48:05.560]                       else if (inherits(cond, "warning")) {
[17:48:05.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.560]                         if (muffled) 
[17:48:05.560]                           invokeRestart("muffleWarning")
[17:48:05.560]                       }
[17:48:05.560]                       else if (inherits(cond, "condition")) {
[17:48:05.560]                         if (!is.null(pattern)) {
[17:48:05.560]                           computeRestarts <- base::computeRestarts
[17:48:05.560]                           grepl <- base::grepl
[17:48:05.560]                           restarts <- computeRestarts(cond)
[17:48:05.560]                           for (restart in restarts) {
[17:48:05.560]                             name <- restart$name
[17:48:05.560]                             if (is.null(name)) 
[17:48:05.560]                               next
[17:48:05.560]                             if (!grepl(pattern, name)) 
[17:48:05.560]                               next
[17:48:05.560]                             invokeRestart(restart)
[17:48:05.560]                             muffled <- TRUE
[17:48:05.560]                             break
[17:48:05.560]                           }
[17:48:05.560]                         }
[17:48:05.560]                       }
[17:48:05.560]                       invisible(muffled)
[17:48:05.560]                     }
[17:48:05.560]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.560]                   }
[17:48:05.560]                 }
[17:48:05.560]             }
[17:48:05.560]         }))
[17:48:05.560]     }, error = function(ex) {
[17:48:05.560]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:05.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.560]                 ...future.rng), started = ...future.startTime, 
[17:48:05.560]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:05.560]             version = "1.8"), class = "FutureResult")
[17:48:05.560]     }, finally = {
[17:48:05.560]         if (!identical(...future.workdir, getwd())) 
[17:48:05.560]             setwd(...future.workdir)
[17:48:05.560]         {
[17:48:05.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:05.560]                 ...future.oldOptions$nwarnings <- NULL
[17:48:05.560]             }
[17:48:05.560]             base::options(...future.oldOptions)
[17:48:05.560]             if (.Platform$OS.type == "windows") {
[17:48:05.560]                 old_names <- names(...future.oldEnvVars)
[17:48:05.560]                 envs <- base::Sys.getenv()
[17:48:05.560]                 names <- names(envs)
[17:48:05.560]                 common <- intersect(names, old_names)
[17:48:05.560]                 added <- setdiff(names, old_names)
[17:48:05.560]                 removed <- setdiff(old_names, names)
[17:48:05.560]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:05.560]                   envs[common]]
[17:48:05.560]                 NAMES <- toupper(changed)
[17:48:05.560]                 args <- list()
[17:48:05.560]                 for (kk in seq_along(NAMES)) {
[17:48:05.560]                   name <- changed[[kk]]
[17:48:05.560]                   NAME <- NAMES[[kk]]
[17:48:05.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.560]                     next
[17:48:05.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.560]                 }
[17:48:05.560]                 NAMES <- toupper(added)
[17:48:05.560]                 for (kk in seq_along(NAMES)) {
[17:48:05.560]                   name <- added[[kk]]
[17:48:05.560]                   NAME <- NAMES[[kk]]
[17:48:05.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.560]                     next
[17:48:05.560]                   args[[name]] <- ""
[17:48:05.560]                 }
[17:48:05.560]                 NAMES <- toupper(removed)
[17:48:05.560]                 for (kk in seq_along(NAMES)) {
[17:48:05.560]                   name <- removed[[kk]]
[17:48:05.560]                   NAME <- NAMES[[kk]]
[17:48:05.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.560]                     next
[17:48:05.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.560]                 }
[17:48:05.560]                 if (length(args) > 0) 
[17:48:05.560]                   base::do.call(base::Sys.setenv, args = args)
[17:48:05.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:05.560]             }
[17:48:05.560]             else {
[17:48:05.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:05.560]             }
[17:48:05.560]             {
[17:48:05.560]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:05.560]                   0L) {
[17:48:05.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:05.560]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:05.560]                   base::options(opts)
[17:48:05.560]                 }
[17:48:05.560]                 {
[17:48:05.560]                   {
[17:48:05.560]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:05.560]                     NULL
[17:48:05.560]                   }
[17:48:05.560]                   options(future.plan = NULL)
[17:48:05.560]                   if (is.na(NA_character_)) 
[17:48:05.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:05.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:05.560]                     .init = FALSE)
[17:48:05.560]                 }
[17:48:05.560]             }
[17:48:05.560]         }
[17:48:05.560]     })
[17:48:05.560]     if (TRUE) {
[17:48:05.560]         base::sink(type = "output", split = FALSE)
[17:48:05.560]         if (TRUE) {
[17:48:05.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:05.560]         }
[17:48:05.560]         else {
[17:48:05.560]             ...future.result["stdout"] <- base::list(NULL)
[17:48:05.560]         }
[17:48:05.560]         base::close(...future.stdout)
[17:48:05.560]         ...future.stdout <- NULL
[17:48:05.560]     }
[17:48:05.560]     ...future.result$conditions <- ...future.conditions
[17:48:05.560]     ...future.result$finished <- base::Sys.time()
[17:48:05.560]     ...future.result
[17:48:05.560] }
[17:48:05.566] MultisessionFuture started
[17:48:05.566] - Launch lazy future ... done
[17:48:05.566] run() for ‘MultisessionFuture’ ... done
[17:48:05.568] receiveMessageFromWorker() for ClusterFuture ...
[17:48:05.568] - Validating connection of MultisessionFuture
[17:48:05.568] - received message: FutureResult
[17:48:05.568] - Received FutureResult
[17:48:05.569] - Erased future from FutureRegistry
[17:48:05.569] result() for ClusterFuture ...
[17:48:05.569] - result already collected: FutureResult
[17:48:05.569] result() for ClusterFuture ... done
[17:48:05.569] signalConditions() ...
[17:48:05.569]  - include = ‘immediateCondition’
[17:48:05.569]  - exclude = 
[17:48:05.569]  - resignal = FALSE
[17:48:05.569]  - Number of conditions: 1
[17:48:05.569] signalConditions() ... done
[17:48:05.569] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:05.569] A MultisessionFuture was resolved (and resolved itself)
[17:48:05.570] getGlobalsAndPackages() ...
[17:48:05.570] Searching for globals...
[17:48:05.570] - globals found: [2] ‘list’, ‘stop’
[17:48:05.570] Searching for globals ... DONE
[17:48:05.571] Resolving globals: FALSE
[17:48:05.571] 
[17:48:05.571] 
[17:48:05.571] getGlobalsAndPackages() ... DONE
[17:48:05.571] run() for ‘Future’ ...
[17:48:05.571] - state: ‘created’
[17:48:05.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:05.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:05.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:05.585]   - Field: ‘node’
[17:48:05.585]   - Field: ‘label’
[17:48:05.585]   - Field: ‘local’
[17:48:05.585]   - Field: ‘owner’
[17:48:05.585]   - Field: ‘envir’
[17:48:05.585]   - Field: ‘workers’
[17:48:05.585]   - Field: ‘packages’
[17:48:05.586]   - Field: ‘gc’
[17:48:05.586]   - Field: ‘conditions’
[17:48:05.586]   - Field: ‘persistent’
[17:48:05.586]   - Field: ‘expr’
[17:48:05.586]   - Field: ‘uuid’
[17:48:05.586]   - Field: ‘seed’
[17:48:05.586]   - Field: ‘version’
[17:48:05.586]   - Field: ‘result’
[17:48:05.586]   - Field: ‘asynchronous’
[17:48:05.586]   - Field: ‘calls’
[17:48:05.586]   - Field: ‘globals’
[17:48:05.586]   - Field: ‘stdout’
[17:48:05.587]   - Field: ‘earlySignal’
[17:48:05.587]   - Field: ‘lazy’
[17:48:05.587]   - Field: ‘state’
[17:48:05.587] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:05.587] - Launch lazy future ...
[17:48:05.587] Packages needed by the future expression (n = 0): <none>
[17:48:05.587] Packages needed by future strategies (n = 0): <none>
[17:48:05.588] {
[17:48:05.588]     {
[17:48:05.588]         {
[17:48:05.588]             ...future.startTime <- base::Sys.time()
[17:48:05.588]             {
[17:48:05.588]                 {
[17:48:05.588]                   {
[17:48:05.588]                     {
[17:48:05.588]                       base::local({
[17:48:05.588]                         has_future <- base::requireNamespace("future", 
[17:48:05.588]                           quietly = TRUE)
[17:48:05.588]                         if (has_future) {
[17:48:05.588]                           ns <- base::getNamespace("future")
[17:48:05.588]                           version <- ns[[".package"]][["version"]]
[17:48:05.588]                           if (is.null(version)) 
[17:48:05.588]                             version <- utils::packageVersion("future")
[17:48:05.588]                         }
[17:48:05.588]                         else {
[17:48:05.588]                           version <- NULL
[17:48:05.588]                         }
[17:48:05.588]                         if (!has_future || version < "1.8.0") {
[17:48:05.588]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:05.588]                             "", base::R.version$version.string), 
[17:48:05.588]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:05.588]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:05.588]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:05.588]                               "release", "version")], collapse = " "), 
[17:48:05.588]                             hostname = base::Sys.info()[["nodename"]])
[17:48:05.588]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:05.588]                             info)
[17:48:05.588]                           info <- base::paste(info, collapse = "; ")
[17:48:05.588]                           if (!has_future) {
[17:48:05.588]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:05.588]                               info)
[17:48:05.588]                           }
[17:48:05.588]                           else {
[17:48:05.588]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:05.588]                               info, version)
[17:48:05.588]                           }
[17:48:05.588]                           base::stop(msg)
[17:48:05.588]                         }
[17:48:05.588]                       })
[17:48:05.588]                     }
[17:48:05.588]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:05.588]                     base::options(mc.cores = 1L)
[17:48:05.588]                   }
[17:48:05.588]                   ...future.strategy.old <- future::plan("list")
[17:48:05.588]                   options(future.plan = NULL)
[17:48:05.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:05.588]                 }
[17:48:05.588]                 ...future.workdir <- getwd()
[17:48:05.588]             }
[17:48:05.588]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:05.588]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:05.588]         }
[17:48:05.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:05.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:05.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:05.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:05.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:05.588]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:05.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:05.588]             base::names(...future.oldOptions))
[17:48:05.588]     }
[17:48:05.588]     if (FALSE) {
[17:48:05.588]     }
[17:48:05.588]     else {
[17:48:05.588]         if (TRUE) {
[17:48:05.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:05.588]                 open = "w")
[17:48:05.588]         }
[17:48:05.588]         else {
[17:48:05.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:05.588]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:05.588]         }
[17:48:05.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:05.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:05.588]             base::sink(type = "output", split = FALSE)
[17:48:05.588]             base::close(...future.stdout)
[17:48:05.588]         }, add = TRUE)
[17:48:05.588]     }
[17:48:05.588]     ...future.frame <- base::sys.nframe()
[17:48:05.588]     ...future.conditions <- base::list()
[17:48:05.588]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:05.588]     if (FALSE) {
[17:48:05.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:05.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:05.588]     }
[17:48:05.588]     ...future.result <- base::tryCatch({
[17:48:05.588]         base::withCallingHandlers({
[17:48:05.588]             ...future.value <- base::withVisible(base::local({
[17:48:05.588]                 ...future.makeSendCondition <- base::local({
[17:48:05.588]                   sendCondition <- NULL
[17:48:05.588]                   function(frame = 1L) {
[17:48:05.588]                     if (is.function(sendCondition)) 
[17:48:05.588]                       return(sendCondition)
[17:48:05.588]                     ns <- getNamespace("parallel")
[17:48:05.588]                     if (exists("sendData", mode = "function", 
[17:48:05.588]                       envir = ns)) {
[17:48:05.588]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:05.588]                         envir = ns)
[17:48:05.588]                       envir <- sys.frame(frame)
[17:48:05.588]                       master <- NULL
[17:48:05.588]                       while (!identical(envir, .GlobalEnv) && 
[17:48:05.588]                         !identical(envir, emptyenv())) {
[17:48:05.588]                         if (exists("master", mode = "list", envir = envir, 
[17:48:05.588]                           inherits = FALSE)) {
[17:48:05.588]                           master <- get("master", mode = "list", 
[17:48:05.588]                             envir = envir, inherits = FALSE)
[17:48:05.588]                           if (inherits(master, c("SOCKnode", 
[17:48:05.588]                             "SOCK0node"))) {
[17:48:05.588]                             sendCondition <<- function(cond) {
[17:48:05.588]                               data <- list(type = "VALUE", value = cond, 
[17:48:05.588]                                 success = TRUE)
[17:48:05.588]                               parallel_sendData(master, data)
[17:48:05.588]                             }
[17:48:05.588]                             return(sendCondition)
[17:48:05.588]                           }
[17:48:05.588]                         }
[17:48:05.588]                         frame <- frame + 1L
[17:48:05.588]                         envir <- sys.frame(frame)
[17:48:05.588]                       }
[17:48:05.588]                     }
[17:48:05.588]                     sendCondition <<- function(cond) NULL
[17:48:05.588]                   }
[17:48:05.588]                 })
[17:48:05.588]                 withCallingHandlers({
[17:48:05.588]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:05.588]                 }, immediateCondition = function(cond) {
[17:48:05.588]                   sendCondition <- ...future.makeSendCondition()
[17:48:05.588]                   sendCondition(cond)
[17:48:05.588]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.588]                   {
[17:48:05.588]                     inherits <- base::inherits
[17:48:05.588]                     invokeRestart <- base::invokeRestart
[17:48:05.588]                     is.null <- base::is.null
[17:48:05.588]                     muffled <- FALSE
[17:48:05.588]                     if (inherits(cond, "message")) {
[17:48:05.588]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:05.588]                       if (muffled) 
[17:48:05.588]                         invokeRestart("muffleMessage")
[17:48:05.588]                     }
[17:48:05.588]                     else if (inherits(cond, "warning")) {
[17:48:05.588]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:05.588]                       if (muffled) 
[17:48:05.588]                         invokeRestart("muffleWarning")
[17:48:05.588]                     }
[17:48:05.588]                     else if (inherits(cond, "condition")) {
[17:48:05.588]                       if (!is.null(pattern)) {
[17:48:05.588]                         computeRestarts <- base::computeRestarts
[17:48:05.588]                         grepl <- base::grepl
[17:48:05.588]                         restarts <- computeRestarts(cond)
[17:48:05.588]                         for (restart in restarts) {
[17:48:05.588]                           name <- restart$name
[17:48:05.588]                           if (is.null(name)) 
[17:48:05.588]                             next
[17:48:05.588]                           if (!grepl(pattern, name)) 
[17:48:05.588]                             next
[17:48:05.588]                           invokeRestart(restart)
[17:48:05.588]                           muffled <- TRUE
[17:48:05.588]                           break
[17:48:05.588]                         }
[17:48:05.588]                       }
[17:48:05.588]                     }
[17:48:05.588]                     invisible(muffled)
[17:48:05.588]                   }
[17:48:05.588]                   muffleCondition(cond)
[17:48:05.588]                 })
[17:48:05.588]             }))
[17:48:05.588]             future::FutureResult(value = ...future.value$value, 
[17:48:05.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.588]                   ...future.rng), globalenv = if (FALSE) 
[17:48:05.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:05.588]                     ...future.globalenv.names))
[17:48:05.588]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:05.588]         }, condition = base::local({
[17:48:05.588]             c <- base::c
[17:48:05.588]             inherits <- base::inherits
[17:48:05.588]             invokeRestart <- base::invokeRestart
[17:48:05.588]             length <- base::length
[17:48:05.588]             list <- base::list
[17:48:05.588]             seq.int <- base::seq.int
[17:48:05.588]             signalCondition <- base::signalCondition
[17:48:05.588]             sys.calls <- base::sys.calls
[17:48:05.588]             `[[` <- base::`[[`
[17:48:05.588]             `+` <- base::`+`
[17:48:05.588]             `<<-` <- base::`<<-`
[17:48:05.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:05.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:05.588]                   3L)]
[17:48:05.588]             }
[17:48:05.588]             function(cond) {
[17:48:05.588]                 is_error <- inherits(cond, "error")
[17:48:05.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:05.588]                   NULL)
[17:48:05.588]                 if (is_error) {
[17:48:05.588]                   sessionInformation <- function() {
[17:48:05.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:05.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:05.588]                       search = base::search(), system = base::Sys.info())
[17:48:05.588]                   }
[17:48:05.588]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:05.588]                     cond$call), session = sessionInformation(), 
[17:48:05.588]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:05.588]                   signalCondition(cond)
[17:48:05.588]                 }
[17:48:05.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:05.588]                 "immediateCondition"))) {
[17:48:05.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:05.588]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:05.588]                   if (TRUE && !signal) {
[17:48:05.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.588]                     {
[17:48:05.588]                       inherits <- base::inherits
[17:48:05.588]                       invokeRestart <- base::invokeRestart
[17:48:05.588]                       is.null <- base::is.null
[17:48:05.588]                       muffled <- FALSE
[17:48:05.588]                       if (inherits(cond, "message")) {
[17:48:05.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.588]                         if (muffled) 
[17:48:05.588]                           invokeRestart("muffleMessage")
[17:48:05.588]                       }
[17:48:05.588]                       else if (inherits(cond, "warning")) {
[17:48:05.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.588]                         if (muffled) 
[17:48:05.588]                           invokeRestart("muffleWarning")
[17:48:05.588]                       }
[17:48:05.588]                       else if (inherits(cond, "condition")) {
[17:48:05.588]                         if (!is.null(pattern)) {
[17:48:05.588]                           computeRestarts <- base::computeRestarts
[17:48:05.588]                           grepl <- base::grepl
[17:48:05.588]                           restarts <- computeRestarts(cond)
[17:48:05.588]                           for (restart in restarts) {
[17:48:05.588]                             name <- restart$name
[17:48:05.588]                             if (is.null(name)) 
[17:48:05.588]                               next
[17:48:05.588]                             if (!grepl(pattern, name)) 
[17:48:05.588]                               next
[17:48:05.588]                             invokeRestart(restart)
[17:48:05.588]                             muffled <- TRUE
[17:48:05.588]                             break
[17:48:05.588]                           }
[17:48:05.588]                         }
[17:48:05.588]                       }
[17:48:05.588]                       invisible(muffled)
[17:48:05.588]                     }
[17:48:05.588]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.588]                   }
[17:48:05.588]                 }
[17:48:05.588]                 else {
[17:48:05.588]                   if (TRUE) {
[17:48:05.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.588]                     {
[17:48:05.588]                       inherits <- base::inherits
[17:48:05.588]                       invokeRestart <- base::invokeRestart
[17:48:05.588]                       is.null <- base::is.null
[17:48:05.588]                       muffled <- FALSE
[17:48:05.588]                       if (inherits(cond, "message")) {
[17:48:05.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.588]                         if (muffled) 
[17:48:05.588]                           invokeRestart("muffleMessage")
[17:48:05.588]                       }
[17:48:05.588]                       else if (inherits(cond, "warning")) {
[17:48:05.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.588]                         if (muffled) 
[17:48:05.588]                           invokeRestart("muffleWarning")
[17:48:05.588]                       }
[17:48:05.588]                       else if (inherits(cond, "condition")) {
[17:48:05.588]                         if (!is.null(pattern)) {
[17:48:05.588]                           computeRestarts <- base::computeRestarts
[17:48:05.588]                           grepl <- base::grepl
[17:48:05.588]                           restarts <- computeRestarts(cond)
[17:48:05.588]                           for (restart in restarts) {
[17:48:05.588]                             name <- restart$name
[17:48:05.588]                             if (is.null(name)) 
[17:48:05.588]                               next
[17:48:05.588]                             if (!grepl(pattern, name)) 
[17:48:05.588]                               next
[17:48:05.588]                             invokeRestart(restart)
[17:48:05.588]                             muffled <- TRUE
[17:48:05.588]                             break
[17:48:05.588]                           }
[17:48:05.588]                         }
[17:48:05.588]                       }
[17:48:05.588]                       invisible(muffled)
[17:48:05.588]                     }
[17:48:05.588]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.588]                   }
[17:48:05.588]                 }
[17:48:05.588]             }
[17:48:05.588]         }))
[17:48:05.588]     }, error = function(ex) {
[17:48:05.588]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:05.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.588]                 ...future.rng), started = ...future.startTime, 
[17:48:05.588]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:05.588]             version = "1.8"), class = "FutureResult")
[17:48:05.588]     }, finally = {
[17:48:05.588]         if (!identical(...future.workdir, getwd())) 
[17:48:05.588]             setwd(...future.workdir)
[17:48:05.588]         {
[17:48:05.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:05.588]                 ...future.oldOptions$nwarnings <- NULL
[17:48:05.588]             }
[17:48:05.588]             base::options(...future.oldOptions)
[17:48:05.588]             if (.Platform$OS.type == "windows") {
[17:48:05.588]                 old_names <- names(...future.oldEnvVars)
[17:48:05.588]                 envs <- base::Sys.getenv()
[17:48:05.588]                 names <- names(envs)
[17:48:05.588]                 common <- intersect(names, old_names)
[17:48:05.588]                 added <- setdiff(names, old_names)
[17:48:05.588]                 removed <- setdiff(old_names, names)
[17:48:05.588]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:05.588]                   envs[common]]
[17:48:05.588]                 NAMES <- toupper(changed)
[17:48:05.588]                 args <- list()
[17:48:05.588]                 for (kk in seq_along(NAMES)) {
[17:48:05.588]                   name <- changed[[kk]]
[17:48:05.588]                   NAME <- NAMES[[kk]]
[17:48:05.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.588]                     next
[17:48:05.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.588]                 }
[17:48:05.588]                 NAMES <- toupper(added)
[17:48:05.588]                 for (kk in seq_along(NAMES)) {
[17:48:05.588]                   name <- added[[kk]]
[17:48:05.588]                   NAME <- NAMES[[kk]]
[17:48:05.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.588]                     next
[17:48:05.588]                   args[[name]] <- ""
[17:48:05.588]                 }
[17:48:05.588]                 NAMES <- toupper(removed)
[17:48:05.588]                 for (kk in seq_along(NAMES)) {
[17:48:05.588]                   name <- removed[[kk]]
[17:48:05.588]                   NAME <- NAMES[[kk]]
[17:48:05.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.588]                     next
[17:48:05.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.588]                 }
[17:48:05.588]                 if (length(args) > 0) 
[17:48:05.588]                   base::do.call(base::Sys.setenv, args = args)
[17:48:05.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:05.588]             }
[17:48:05.588]             else {
[17:48:05.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:05.588]             }
[17:48:05.588]             {
[17:48:05.588]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:05.588]                   0L) {
[17:48:05.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:05.588]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:05.588]                   base::options(opts)
[17:48:05.588]                 }
[17:48:05.588]                 {
[17:48:05.588]                   {
[17:48:05.588]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:05.588]                     NULL
[17:48:05.588]                   }
[17:48:05.588]                   options(future.plan = NULL)
[17:48:05.588]                   if (is.na(NA_character_)) 
[17:48:05.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:05.588]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:05.588]                     .init = FALSE)
[17:48:05.588]                 }
[17:48:05.588]             }
[17:48:05.588]         }
[17:48:05.588]     })
[17:48:05.588]     if (TRUE) {
[17:48:05.588]         base::sink(type = "output", split = FALSE)
[17:48:05.588]         if (TRUE) {
[17:48:05.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:05.588]         }
[17:48:05.588]         else {
[17:48:05.588]             ...future.result["stdout"] <- base::list(NULL)
[17:48:05.588]         }
[17:48:05.588]         base::close(...future.stdout)
[17:48:05.588]         ...future.stdout <- NULL
[17:48:05.588]     }
[17:48:05.588]     ...future.result$conditions <- ...future.conditions
[17:48:05.588]     ...future.result$finished <- base::Sys.time()
[17:48:05.588]     ...future.result
[17:48:05.588] }
[17:48:05.590] MultisessionFuture started
[17:48:05.591] - Launch lazy future ... done
[17:48:05.591] run() for ‘MultisessionFuture’ ... done
[17:48:05.592] receiveMessageFromWorker() for ClusterFuture ...
[17:48:05.593] - Validating connection of MultisessionFuture
[17:48:05.593] - received message: FutureResult
[17:48:05.593] - Received FutureResult
[17:48:05.593] - Erased future from FutureRegistry
[17:48:05.593] result() for ClusterFuture ...
[17:48:05.594] - result already collected: FutureResult
[17:48:05.594] result() for ClusterFuture ... done
[17:48:05.594] signalConditions() ...
[17:48:05.594]  - include = ‘immediateCondition’
[17:48:05.594]  - exclude = 
[17:48:05.594]  - resignal = FALSE
[17:48:05.594]  - Number of conditions: 1
[17:48:05.594] signalConditions() ... done
[17:48:05.594] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:05.594] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[17:48:05.595] getGlobalsAndPackages() ...
[17:48:05.595] Searching for globals...
[17:48:05.596] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:05.596] Searching for globals ... DONE
[17:48:05.596] Resolving globals: FALSE
[17:48:05.596] 
[17:48:05.596] 
[17:48:05.596] getGlobalsAndPackages() ... DONE
[17:48:05.597] run() for ‘Future’ ...
[17:48:05.597] - state: ‘created’
[17:48:05.597] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:05.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:05.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:05.611]   - Field: ‘node’
[17:48:05.611]   - Field: ‘label’
[17:48:05.611]   - Field: ‘local’
[17:48:05.611]   - Field: ‘owner’
[17:48:05.611]   - Field: ‘envir’
[17:48:05.611]   - Field: ‘workers’
[17:48:05.611]   - Field: ‘packages’
[17:48:05.611]   - Field: ‘gc’
[17:48:05.612]   - Field: ‘conditions’
[17:48:05.612]   - Field: ‘persistent’
[17:48:05.612]   - Field: ‘expr’
[17:48:05.612]   - Field: ‘uuid’
[17:48:05.612]   - Field: ‘seed’
[17:48:05.612]   - Field: ‘version’
[17:48:05.612]   - Field: ‘result’
[17:48:05.612]   - Field: ‘asynchronous’
[17:48:05.612]   - Field: ‘calls’
[17:48:05.612]   - Field: ‘globals’
[17:48:05.612]   - Field: ‘stdout’
[17:48:05.612]   - Field: ‘earlySignal’
[17:48:05.613]   - Field: ‘lazy’
[17:48:05.613]   - Field: ‘state’
[17:48:05.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:05.613] - Launch lazy future ...
[17:48:05.613] Packages needed by the future expression (n = 0): <none>
[17:48:05.613] Packages needed by future strategies (n = 0): <none>
[17:48:05.614] {
[17:48:05.614]     {
[17:48:05.614]         {
[17:48:05.614]             ...future.startTime <- base::Sys.time()
[17:48:05.614]             {
[17:48:05.614]                 {
[17:48:05.614]                   {
[17:48:05.614]                     {
[17:48:05.614]                       base::local({
[17:48:05.614]                         has_future <- base::requireNamespace("future", 
[17:48:05.614]                           quietly = TRUE)
[17:48:05.614]                         if (has_future) {
[17:48:05.614]                           ns <- base::getNamespace("future")
[17:48:05.614]                           version <- ns[[".package"]][["version"]]
[17:48:05.614]                           if (is.null(version)) 
[17:48:05.614]                             version <- utils::packageVersion("future")
[17:48:05.614]                         }
[17:48:05.614]                         else {
[17:48:05.614]                           version <- NULL
[17:48:05.614]                         }
[17:48:05.614]                         if (!has_future || version < "1.8.0") {
[17:48:05.614]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:05.614]                             "", base::R.version$version.string), 
[17:48:05.614]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:05.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:05.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:05.614]                               "release", "version")], collapse = " "), 
[17:48:05.614]                             hostname = base::Sys.info()[["nodename"]])
[17:48:05.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:05.614]                             info)
[17:48:05.614]                           info <- base::paste(info, collapse = "; ")
[17:48:05.614]                           if (!has_future) {
[17:48:05.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:05.614]                               info)
[17:48:05.614]                           }
[17:48:05.614]                           else {
[17:48:05.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:05.614]                               info, version)
[17:48:05.614]                           }
[17:48:05.614]                           base::stop(msg)
[17:48:05.614]                         }
[17:48:05.614]                       })
[17:48:05.614]                     }
[17:48:05.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:05.614]                     base::options(mc.cores = 1L)
[17:48:05.614]                   }
[17:48:05.614]                   ...future.strategy.old <- future::plan("list")
[17:48:05.614]                   options(future.plan = NULL)
[17:48:05.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:05.614]                 }
[17:48:05.614]                 ...future.workdir <- getwd()
[17:48:05.614]             }
[17:48:05.614]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:05.614]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:05.614]         }
[17:48:05.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:05.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:05.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:05.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:05.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:05.614]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:05.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:05.614]             base::names(...future.oldOptions))
[17:48:05.614]     }
[17:48:05.614]     if (FALSE) {
[17:48:05.614]     }
[17:48:05.614]     else {
[17:48:05.614]         if (TRUE) {
[17:48:05.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:05.614]                 open = "w")
[17:48:05.614]         }
[17:48:05.614]         else {
[17:48:05.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:05.614]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:05.614]         }
[17:48:05.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:05.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:05.614]             base::sink(type = "output", split = FALSE)
[17:48:05.614]             base::close(...future.stdout)
[17:48:05.614]         }, add = TRUE)
[17:48:05.614]     }
[17:48:05.614]     ...future.frame <- base::sys.nframe()
[17:48:05.614]     ...future.conditions <- base::list()
[17:48:05.614]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:05.614]     if (FALSE) {
[17:48:05.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:05.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:05.614]     }
[17:48:05.614]     ...future.result <- base::tryCatch({
[17:48:05.614]         base::withCallingHandlers({
[17:48:05.614]             ...future.value <- base::withVisible(base::local({
[17:48:05.614]                 ...future.makeSendCondition <- base::local({
[17:48:05.614]                   sendCondition <- NULL
[17:48:05.614]                   function(frame = 1L) {
[17:48:05.614]                     if (is.function(sendCondition)) 
[17:48:05.614]                       return(sendCondition)
[17:48:05.614]                     ns <- getNamespace("parallel")
[17:48:05.614]                     if (exists("sendData", mode = "function", 
[17:48:05.614]                       envir = ns)) {
[17:48:05.614]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:05.614]                         envir = ns)
[17:48:05.614]                       envir <- sys.frame(frame)
[17:48:05.614]                       master <- NULL
[17:48:05.614]                       while (!identical(envir, .GlobalEnv) && 
[17:48:05.614]                         !identical(envir, emptyenv())) {
[17:48:05.614]                         if (exists("master", mode = "list", envir = envir, 
[17:48:05.614]                           inherits = FALSE)) {
[17:48:05.614]                           master <- get("master", mode = "list", 
[17:48:05.614]                             envir = envir, inherits = FALSE)
[17:48:05.614]                           if (inherits(master, c("SOCKnode", 
[17:48:05.614]                             "SOCK0node"))) {
[17:48:05.614]                             sendCondition <<- function(cond) {
[17:48:05.614]                               data <- list(type = "VALUE", value = cond, 
[17:48:05.614]                                 success = TRUE)
[17:48:05.614]                               parallel_sendData(master, data)
[17:48:05.614]                             }
[17:48:05.614]                             return(sendCondition)
[17:48:05.614]                           }
[17:48:05.614]                         }
[17:48:05.614]                         frame <- frame + 1L
[17:48:05.614]                         envir <- sys.frame(frame)
[17:48:05.614]                       }
[17:48:05.614]                     }
[17:48:05.614]                     sendCondition <<- function(cond) NULL
[17:48:05.614]                   }
[17:48:05.614]                 })
[17:48:05.614]                 withCallingHandlers({
[17:48:05.614]                   {
[17:48:05.614]                     Sys.sleep(0.5)
[17:48:05.614]                     list(a = 1, b = 42L)
[17:48:05.614]                   }
[17:48:05.614]                 }, immediateCondition = function(cond) {
[17:48:05.614]                   sendCondition <- ...future.makeSendCondition()
[17:48:05.614]                   sendCondition(cond)
[17:48:05.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.614]                   {
[17:48:05.614]                     inherits <- base::inherits
[17:48:05.614]                     invokeRestart <- base::invokeRestart
[17:48:05.614]                     is.null <- base::is.null
[17:48:05.614]                     muffled <- FALSE
[17:48:05.614]                     if (inherits(cond, "message")) {
[17:48:05.614]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:05.614]                       if (muffled) 
[17:48:05.614]                         invokeRestart("muffleMessage")
[17:48:05.614]                     }
[17:48:05.614]                     else if (inherits(cond, "warning")) {
[17:48:05.614]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:05.614]                       if (muffled) 
[17:48:05.614]                         invokeRestart("muffleWarning")
[17:48:05.614]                     }
[17:48:05.614]                     else if (inherits(cond, "condition")) {
[17:48:05.614]                       if (!is.null(pattern)) {
[17:48:05.614]                         computeRestarts <- base::computeRestarts
[17:48:05.614]                         grepl <- base::grepl
[17:48:05.614]                         restarts <- computeRestarts(cond)
[17:48:05.614]                         for (restart in restarts) {
[17:48:05.614]                           name <- restart$name
[17:48:05.614]                           if (is.null(name)) 
[17:48:05.614]                             next
[17:48:05.614]                           if (!grepl(pattern, name)) 
[17:48:05.614]                             next
[17:48:05.614]                           invokeRestart(restart)
[17:48:05.614]                           muffled <- TRUE
[17:48:05.614]                           break
[17:48:05.614]                         }
[17:48:05.614]                       }
[17:48:05.614]                     }
[17:48:05.614]                     invisible(muffled)
[17:48:05.614]                   }
[17:48:05.614]                   muffleCondition(cond)
[17:48:05.614]                 })
[17:48:05.614]             }))
[17:48:05.614]             future::FutureResult(value = ...future.value$value, 
[17:48:05.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.614]                   ...future.rng), globalenv = if (FALSE) 
[17:48:05.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:05.614]                     ...future.globalenv.names))
[17:48:05.614]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:05.614]         }, condition = base::local({
[17:48:05.614]             c <- base::c
[17:48:05.614]             inherits <- base::inherits
[17:48:05.614]             invokeRestart <- base::invokeRestart
[17:48:05.614]             length <- base::length
[17:48:05.614]             list <- base::list
[17:48:05.614]             seq.int <- base::seq.int
[17:48:05.614]             signalCondition <- base::signalCondition
[17:48:05.614]             sys.calls <- base::sys.calls
[17:48:05.614]             `[[` <- base::`[[`
[17:48:05.614]             `+` <- base::`+`
[17:48:05.614]             `<<-` <- base::`<<-`
[17:48:05.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:05.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:05.614]                   3L)]
[17:48:05.614]             }
[17:48:05.614]             function(cond) {
[17:48:05.614]                 is_error <- inherits(cond, "error")
[17:48:05.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:05.614]                   NULL)
[17:48:05.614]                 if (is_error) {
[17:48:05.614]                   sessionInformation <- function() {
[17:48:05.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:05.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:05.614]                       search = base::search(), system = base::Sys.info())
[17:48:05.614]                   }
[17:48:05.614]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:05.614]                     cond$call), session = sessionInformation(), 
[17:48:05.614]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:05.614]                   signalCondition(cond)
[17:48:05.614]                 }
[17:48:05.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:05.614]                 "immediateCondition"))) {
[17:48:05.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:05.614]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:05.614]                   if (TRUE && !signal) {
[17:48:05.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.614]                     {
[17:48:05.614]                       inherits <- base::inherits
[17:48:05.614]                       invokeRestart <- base::invokeRestart
[17:48:05.614]                       is.null <- base::is.null
[17:48:05.614]                       muffled <- FALSE
[17:48:05.614]                       if (inherits(cond, "message")) {
[17:48:05.614]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.614]                         if (muffled) 
[17:48:05.614]                           invokeRestart("muffleMessage")
[17:48:05.614]                       }
[17:48:05.614]                       else if (inherits(cond, "warning")) {
[17:48:05.614]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.614]                         if (muffled) 
[17:48:05.614]                           invokeRestart("muffleWarning")
[17:48:05.614]                       }
[17:48:05.614]                       else if (inherits(cond, "condition")) {
[17:48:05.614]                         if (!is.null(pattern)) {
[17:48:05.614]                           computeRestarts <- base::computeRestarts
[17:48:05.614]                           grepl <- base::grepl
[17:48:05.614]                           restarts <- computeRestarts(cond)
[17:48:05.614]                           for (restart in restarts) {
[17:48:05.614]                             name <- restart$name
[17:48:05.614]                             if (is.null(name)) 
[17:48:05.614]                               next
[17:48:05.614]                             if (!grepl(pattern, name)) 
[17:48:05.614]                               next
[17:48:05.614]                             invokeRestart(restart)
[17:48:05.614]                             muffled <- TRUE
[17:48:05.614]                             break
[17:48:05.614]                           }
[17:48:05.614]                         }
[17:48:05.614]                       }
[17:48:05.614]                       invisible(muffled)
[17:48:05.614]                     }
[17:48:05.614]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.614]                   }
[17:48:05.614]                 }
[17:48:05.614]                 else {
[17:48:05.614]                   if (TRUE) {
[17:48:05.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.614]                     {
[17:48:05.614]                       inherits <- base::inherits
[17:48:05.614]                       invokeRestart <- base::invokeRestart
[17:48:05.614]                       is.null <- base::is.null
[17:48:05.614]                       muffled <- FALSE
[17:48:05.614]                       if (inherits(cond, "message")) {
[17:48:05.614]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.614]                         if (muffled) 
[17:48:05.614]                           invokeRestart("muffleMessage")
[17:48:05.614]                       }
[17:48:05.614]                       else if (inherits(cond, "warning")) {
[17:48:05.614]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.614]                         if (muffled) 
[17:48:05.614]                           invokeRestart("muffleWarning")
[17:48:05.614]                       }
[17:48:05.614]                       else if (inherits(cond, "condition")) {
[17:48:05.614]                         if (!is.null(pattern)) {
[17:48:05.614]                           computeRestarts <- base::computeRestarts
[17:48:05.614]                           grepl <- base::grepl
[17:48:05.614]                           restarts <- computeRestarts(cond)
[17:48:05.614]                           for (restart in restarts) {
[17:48:05.614]                             name <- restart$name
[17:48:05.614]                             if (is.null(name)) 
[17:48:05.614]                               next
[17:48:05.614]                             if (!grepl(pattern, name)) 
[17:48:05.614]                               next
[17:48:05.614]                             invokeRestart(restart)
[17:48:05.614]                             muffled <- TRUE
[17:48:05.614]                             break
[17:48:05.614]                           }
[17:48:05.614]                         }
[17:48:05.614]                       }
[17:48:05.614]                       invisible(muffled)
[17:48:05.614]                     }
[17:48:05.614]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.614]                   }
[17:48:05.614]                 }
[17:48:05.614]             }
[17:48:05.614]         }))
[17:48:05.614]     }, error = function(ex) {
[17:48:05.614]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:05.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.614]                 ...future.rng), started = ...future.startTime, 
[17:48:05.614]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:05.614]             version = "1.8"), class = "FutureResult")
[17:48:05.614]     }, finally = {
[17:48:05.614]         if (!identical(...future.workdir, getwd())) 
[17:48:05.614]             setwd(...future.workdir)
[17:48:05.614]         {
[17:48:05.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:05.614]                 ...future.oldOptions$nwarnings <- NULL
[17:48:05.614]             }
[17:48:05.614]             base::options(...future.oldOptions)
[17:48:05.614]             if (.Platform$OS.type == "windows") {
[17:48:05.614]                 old_names <- names(...future.oldEnvVars)
[17:48:05.614]                 envs <- base::Sys.getenv()
[17:48:05.614]                 names <- names(envs)
[17:48:05.614]                 common <- intersect(names, old_names)
[17:48:05.614]                 added <- setdiff(names, old_names)
[17:48:05.614]                 removed <- setdiff(old_names, names)
[17:48:05.614]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:05.614]                   envs[common]]
[17:48:05.614]                 NAMES <- toupper(changed)
[17:48:05.614]                 args <- list()
[17:48:05.614]                 for (kk in seq_along(NAMES)) {
[17:48:05.614]                   name <- changed[[kk]]
[17:48:05.614]                   NAME <- NAMES[[kk]]
[17:48:05.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.614]                     next
[17:48:05.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.614]                 }
[17:48:05.614]                 NAMES <- toupper(added)
[17:48:05.614]                 for (kk in seq_along(NAMES)) {
[17:48:05.614]                   name <- added[[kk]]
[17:48:05.614]                   NAME <- NAMES[[kk]]
[17:48:05.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.614]                     next
[17:48:05.614]                   args[[name]] <- ""
[17:48:05.614]                 }
[17:48:05.614]                 NAMES <- toupper(removed)
[17:48:05.614]                 for (kk in seq_along(NAMES)) {
[17:48:05.614]                   name <- removed[[kk]]
[17:48:05.614]                   NAME <- NAMES[[kk]]
[17:48:05.614]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.614]                     next
[17:48:05.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.614]                 }
[17:48:05.614]                 if (length(args) > 0) 
[17:48:05.614]                   base::do.call(base::Sys.setenv, args = args)
[17:48:05.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:05.614]             }
[17:48:05.614]             else {
[17:48:05.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:05.614]             }
[17:48:05.614]             {
[17:48:05.614]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:05.614]                   0L) {
[17:48:05.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:05.614]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:05.614]                   base::options(opts)
[17:48:05.614]                 }
[17:48:05.614]                 {
[17:48:05.614]                   {
[17:48:05.614]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:05.614]                     NULL
[17:48:05.614]                   }
[17:48:05.614]                   options(future.plan = NULL)
[17:48:05.614]                   if (is.na(NA_character_)) 
[17:48:05.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:05.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:05.614]                     .init = FALSE)
[17:48:05.614]                 }
[17:48:05.614]             }
[17:48:05.614]         }
[17:48:05.614]     })
[17:48:05.614]     if (TRUE) {
[17:48:05.614]         base::sink(type = "output", split = FALSE)
[17:48:05.614]         if (TRUE) {
[17:48:05.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:05.614]         }
[17:48:05.614]         else {
[17:48:05.614]             ...future.result["stdout"] <- base::list(NULL)
[17:48:05.614]         }
[17:48:05.614]         base::close(...future.stdout)
[17:48:05.614]         ...future.stdout <- NULL
[17:48:05.614]     }
[17:48:05.614]     ...future.result$conditions <- ...future.conditions
[17:48:05.614]     ...future.result$finished <- base::Sys.time()
[17:48:05.614]     ...future.result
[17:48:05.614] }
[17:48:05.616] MultisessionFuture started
[17:48:05.617] - Launch lazy future ... done
[17:48:05.617] run() for ‘MultisessionFuture’ ... done
[17:48:05.617] getGlobalsAndPackages() ...
[17:48:05.617] Searching for globals...
[17:48:05.618] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:05.619] Searching for globals ... DONE
[17:48:05.619] Resolving globals: FALSE
[17:48:05.619] 
[17:48:05.619] 
[17:48:05.619] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:48:05.619] getGlobalsAndPackages() ...
[17:48:05.620] Searching for globals...
[17:48:05.620] - globals found: [2] ‘list’, ‘stop’
[17:48:05.620] Searching for globals ... DONE
[17:48:05.620] Resolving globals: FALSE
[17:48:05.621] 
[17:48:05.621] 
[17:48:05.621] getGlobalsAndPackages() ... DONE
[17:48:05.621] run() for ‘Future’ ...
[17:48:05.621] - state: ‘created’
[17:48:05.621] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:05.634] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:05.635] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:05.635]   - Field: ‘node’
[17:48:05.635]   - Field: ‘label’
[17:48:05.635]   - Field: ‘local’
[17:48:05.635]   - Field: ‘owner’
[17:48:05.635]   - Field: ‘envir’
[17:48:05.635]   - Field: ‘workers’
[17:48:05.635]   - Field: ‘packages’
[17:48:05.635]   - Field: ‘gc’
[17:48:05.636]   - Field: ‘conditions’
[17:48:05.636]   - Field: ‘persistent’
[17:48:05.636]   - Field: ‘expr’
[17:48:05.636]   - Field: ‘uuid’
[17:48:05.636]   - Field: ‘seed’
[17:48:05.636]   - Field: ‘version’
[17:48:05.636]   - Field: ‘result’
[17:48:05.636]   - Field: ‘asynchronous’
[17:48:05.636]   - Field: ‘calls’
[17:48:05.636]   - Field: ‘globals’
[17:48:05.636]   - Field: ‘stdout’
[17:48:05.636]   - Field: ‘earlySignal’
[17:48:05.637]   - Field: ‘lazy’
[17:48:05.637]   - Field: ‘state’
[17:48:05.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:05.637] - Launch lazy future ...
[17:48:05.637] Packages needed by the future expression (n = 0): <none>
[17:48:05.637] Packages needed by future strategies (n = 0): <none>
[17:48:05.638] {
[17:48:05.638]     {
[17:48:05.638]         {
[17:48:05.638]             ...future.startTime <- base::Sys.time()
[17:48:05.638]             {
[17:48:05.638]                 {
[17:48:05.638]                   {
[17:48:05.638]                     {
[17:48:05.638]                       base::local({
[17:48:05.638]                         has_future <- base::requireNamespace("future", 
[17:48:05.638]                           quietly = TRUE)
[17:48:05.638]                         if (has_future) {
[17:48:05.638]                           ns <- base::getNamespace("future")
[17:48:05.638]                           version <- ns[[".package"]][["version"]]
[17:48:05.638]                           if (is.null(version)) 
[17:48:05.638]                             version <- utils::packageVersion("future")
[17:48:05.638]                         }
[17:48:05.638]                         else {
[17:48:05.638]                           version <- NULL
[17:48:05.638]                         }
[17:48:05.638]                         if (!has_future || version < "1.8.0") {
[17:48:05.638]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:05.638]                             "", base::R.version$version.string), 
[17:48:05.638]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:05.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:05.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:05.638]                               "release", "version")], collapse = " "), 
[17:48:05.638]                             hostname = base::Sys.info()[["nodename"]])
[17:48:05.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:05.638]                             info)
[17:48:05.638]                           info <- base::paste(info, collapse = "; ")
[17:48:05.638]                           if (!has_future) {
[17:48:05.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:05.638]                               info)
[17:48:05.638]                           }
[17:48:05.638]                           else {
[17:48:05.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:05.638]                               info, version)
[17:48:05.638]                           }
[17:48:05.638]                           base::stop(msg)
[17:48:05.638]                         }
[17:48:05.638]                       })
[17:48:05.638]                     }
[17:48:05.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:05.638]                     base::options(mc.cores = 1L)
[17:48:05.638]                   }
[17:48:05.638]                   ...future.strategy.old <- future::plan("list")
[17:48:05.638]                   options(future.plan = NULL)
[17:48:05.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:05.638]                 }
[17:48:05.638]                 ...future.workdir <- getwd()
[17:48:05.638]             }
[17:48:05.638]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:05.638]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:05.638]         }
[17:48:05.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:05.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:05.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:05.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:05.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:05.638]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:05.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:05.638]             base::names(...future.oldOptions))
[17:48:05.638]     }
[17:48:05.638]     if (FALSE) {
[17:48:05.638]     }
[17:48:05.638]     else {
[17:48:05.638]         if (TRUE) {
[17:48:05.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:05.638]                 open = "w")
[17:48:05.638]         }
[17:48:05.638]         else {
[17:48:05.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:05.638]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:05.638]         }
[17:48:05.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:05.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:05.638]             base::sink(type = "output", split = FALSE)
[17:48:05.638]             base::close(...future.stdout)
[17:48:05.638]         }, add = TRUE)
[17:48:05.638]     }
[17:48:05.638]     ...future.frame <- base::sys.nframe()
[17:48:05.638]     ...future.conditions <- base::list()
[17:48:05.638]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:05.638]     if (FALSE) {
[17:48:05.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:05.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:05.638]     }
[17:48:05.638]     ...future.result <- base::tryCatch({
[17:48:05.638]         base::withCallingHandlers({
[17:48:05.638]             ...future.value <- base::withVisible(base::local({
[17:48:05.638]                 ...future.makeSendCondition <- base::local({
[17:48:05.638]                   sendCondition <- NULL
[17:48:05.638]                   function(frame = 1L) {
[17:48:05.638]                     if (is.function(sendCondition)) 
[17:48:05.638]                       return(sendCondition)
[17:48:05.638]                     ns <- getNamespace("parallel")
[17:48:05.638]                     if (exists("sendData", mode = "function", 
[17:48:05.638]                       envir = ns)) {
[17:48:05.638]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:05.638]                         envir = ns)
[17:48:05.638]                       envir <- sys.frame(frame)
[17:48:05.638]                       master <- NULL
[17:48:05.638]                       while (!identical(envir, .GlobalEnv) && 
[17:48:05.638]                         !identical(envir, emptyenv())) {
[17:48:05.638]                         if (exists("master", mode = "list", envir = envir, 
[17:48:05.638]                           inherits = FALSE)) {
[17:48:05.638]                           master <- get("master", mode = "list", 
[17:48:05.638]                             envir = envir, inherits = FALSE)
[17:48:05.638]                           if (inherits(master, c("SOCKnode", 
[17:48:05.638]                             "SOCK0node"))) {
[17:48:05.638]                             sendCondition <<- function(cond) {
[17:48:05.638]                               data <- list(type = "VALUE", value = cond, 
[17:48:05.638]                                 success = TRUE)
[17:48:05.638]                               parallel_sendData(master, data)
[17:48:05.638]                             }
[17:48:05.638]                             return(sendCondition)
[17:48:05.638]                           }
[17:48:05.638]                         }
[17:48:05.638]                         frame <- frame + 1L
[17:48:05.638]                         envir <- sys.frame(frame)
[17:48:05.638]                       }
[17:48:05.638]                     }
[17:48:05.638]                     sendCondition <<- function(cond) NULL
[17:48:05.638]                   }
[17:48:05.638]                 })
[17:48:05.638]                 withCallingHandlers({
[17:48:05.638]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:05.638]                 }, immediateCondition = function(cond) {
[17:48:05.638]                   sendCondition <- ...future.makeSendCondition()
[17:48:05.638]                   sendCondition(cond)
[17:48:05.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.638]                   {
[17:48:05.638]                     inherits <- base::inherits
[17:48:05.638]                     invokeRestart <- base::invokeRestart
[17:48:05.638]                     is.null <- base::is.null
[17:48:05.638]                     muffled <- FALSE
[17:48:05.638]                     if (inherits(cond, "message")) {
[17:48:05.638]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:05.638]                       if (muffled) 
[17:48:05.638]                         invokeRestart("muffleMessage")
[17:48:05.638]                     }
[17:48:05.638]                     else if (inherits(cond, "warning")) {
[17:48:05.638]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:05.638]                       if (muffled) 
[17:48:05.638]                         invokeRestart("muffleWarning")
[17:48:05.638]                     }
[17:48:05.638]                     else if (inherits(cond, "condition")) {
[17:48:05.638]                       if (!is.null(pattern)) {
[17:48:05.638]                         computeRestarts <- base::computeRestarts
[17:48:05.638]                         grepl <- base::grepl
[17:48:05.638]                         restarts <- computeRestarts(cond)
[17:48:05.638]                         for (restart in restarts) {
[17:48:05.638]                           name <- restart$name
[17:48:05.638]                           if (is.null(name)) 
[17:48:05.638]                             next
[17:48:05.638]                           if (!grepl(pattern, name)) 
[17:48:05.638]                             next
[17:48:05.638]                           invokeRestart(restart)
[17:48:05.638]                           muffled <- TRUE
[17:48:05.638]                           break
[17:48:05.638]                         }
[17:48:05.638]                       }
[17:48:05.638]                     }
[17:48:05.638]                     invisible(muffled)
[17:48:05.638]                   }
[17:48:05.638]                   muffleCondition(cond)
[17:48:05.638]                 })
[17:48:05.638]             }))
[17:48:05.638]             future::FutureResult(value = ...future.value$value, 
[17:48:05.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.638]                   ...future.rng), globalenv = if (FALSE) 
[17:48:05.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:05.638]                     ...future.globalenv.names))
[17:48:05.638]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:05.638]         }, condition = base::local({
[17:48:05.638]             c <- base::c
[17:48:05.638]             inherits <- base::inherits
[17:48:05.638]             invokeRestart <- base::invokeRestart
[17:48:05.638]             length <- base::length
[17:48:05.638]             list <- base::list
[17:48:05.638]             seq.int <- base::seq.int
[17:48:05.638]             signalCondition <- base::signalCondition
[17:48:05.638]             sys.calls <- base::sys.calls
[17:48:05.638]             `[[` <- base::`[[`
[17:48:05.638]             `+` <- base::`+`
[17:48:05.638]             `<<-` <- base::`<<-`
[17:48:05.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:05.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:05.638]                   3L)]
[17:48:05.638]             }
[17:48:05.638]             function(cond) {
[17:48:05.638]                 is_error <- inherits(cond, "error")
[17:48:05.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:05.638]                   NULL)
[17:48:05.638]                 if (is_error) {
[17:48:05.638]                   sessionInformation <- function() {
[17:48:05.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:05.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:05.638]                       search = base::search(), system = base::Sys.info())
[17:48:05.638]                   }
[17:48:05.638]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:05.638]                     cond$call), session = sessionInformation(), 
[17:48:05.638]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:05.638]                   signalCondition(cond)
[17:48:05.638]                 }
[17:48:05.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:05.638]                 "immediateCondition"))) {
[17:48:05.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:05.638]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:05.638]                   if (TRUE && !signal) {
[17:48:05.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.638]                     {
[17:48:05.638]                       inherits <- base::inherits
[17:48:05.638]                       invokeRestart <- base::invokeRestart
[17:48:05.638]                       is.null <- base::is.null
[17:48:05.638]                       muffled <- FALSE
[17:48:05.638]                       if (inherits(cond, "message")) {
[17:48:05.638]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.638]                         if (muffled) 
[17:48:05.638]                           invokeRestart("muffleMessage")
[17:48:05.638]                       }
[17:48:05.638]                       else if (inherits(cond, "warning")) {
[17:48:05.638]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.638]                         if (muffled) 
[17:48:05.638]                           invokeRestart("muffleWarning")
[17:48:05.638]                       }
[17:48:05.638]                       else if (inherits(cond, "condition")) {
[17:48:05.638]                         if (!is.null(pattern)) {
[17:48:05.638]                           computeRestarts <- base::computeRestarts
[17:48:05.638]                           grepl <- base::grepl
[17:48:05.638]                           restarts <- computeRestarts(cond)
[17:48:05.638]                           for (restart in restarts) {
[17:48:05.638]                             name <- restart$name
[17:48:05.638]                             if (is.null(name)) 
[17:48:05.638]                               next
[17:48:05.638]                             if (!grepl(pattern, name)) 
[17:48:05.638]                               next
[17:48:05.638]                             invokeRestart(restart)
[17:48:05.638]                             muffled <- TRUE
[17:48:05.638]                             break
[17:48:05.638]                           }
[17:48:05.638]                         }
[17:48:05.638]                       }
[17:48:05.638]                       invisible(muffled)
[17:48:05.638]                     }
[17:48:05.638]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.638]                   }
[17:48:05.638]                 }
[17:48:05.638]                 else {
[17:48:05.638]                   if (TRUE) {
[17:48:05.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.638]                     {
[17:48:05.638]                       inherits <- base::inherits
[17:48:05.638]                       invokeRestart <- base::invokeRestart
[17:48:05.638]                       is.null <- base::is.null
[17:48:05.638]                       muffled <- FALSE
[17:48:05.638]                       if (inherits(cond, "message")) {
[17:48:05.638]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.638]                         if (muffled) 
[17:48:05.638]                           invokeRestart("muffleMessage")
[17:48:05.638]                       }
[17:48:05.638]                       else if (inherits(cond, "warning")) {
[17:48:05.638]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.638]                         if (muffled) 
[17:48:05.638]                           invokeRestart("muffleWarning")
[17:48:05.638]                       }
[17:48:05.638]                       else if (inherits(cond, "condition")) {
[17:48:05.638]                         if (!is.null(pattern)) {
[17:48:05.638]                           computeRestarts <- base::computeRestarts
[17:48:05.638]                           grepl <- base::grepl
[17:48:05.638]                           restarts <- computeRestarts(cond)
[17:48:05.638]                           for (restart in restarts) {
[17:48:05.638]                             name <- restart$name
[17:48:05.638]                             if (is.null(name)) 
[17:48:05.638]                               next
[17:48:05.638]                             if (!grepl(pattern, name)) 
[17:48:05.638]                               next
[17:48:05.638]                             invokeRestart(restart)
[17:48:05.638]                             muffled <- TRUE
[17:48:05.638]                             break
[17:48:05.638]                           }
[17:48:05.638]                         }
[17:48:05.638]                       }
[17:48:05.638]                       invisible(muffled)
[17:48:05.638]                     }
[17:48:05.638]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.638]                   }
[17:48:05.638]                 }
[17:48:05.638]             }
[17:48:05.638]         }))
[17:48:05.638]     }, error = function(ex) {
[17:48:05.638]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:05.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.638]                 ...future.rng), started = ...future.startTime, 
[17:48:05.638]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:05.638]             version = "1.8"), class = "FutureResult")
[17:48:05.638]     }, finally = {
[17:48:05.638]         if (!identical(...future.workdir, getwd())) 
[17:48:05.638]             setwd(...future.workdir)
[17:48:05.638]         {
[17:48:05.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:05.638]                 ...future.oldOptions$nwarnings <- NULL
[17:48:05.638]             }
[17:48:05.638]             base::options(...future.oldOptions)
[17:48:05.638]             if (.Platform$OS.type == "windows") {
[17:48:05.638]                 old_names <- names(...future.oldEnvVars)
[17:48:05.638]                 envs <- base::Sys.getenv()
[17:48:05.638]                 names <- names(envs)
[17:48:05.638]                 common <- intersect(names, old_names)
[17:48:05.638]                 added <- setdiff(names, old_names)
[17:48:05.638]                 removed <- setdiff(old_names, names)
[17:48:05.638]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:05.638]                   envs[common]]
[17:48:05.638]                 NAMES <- toupper(changed)
[17:48:05.638]                 args <- list()
[17:48:05.638]                 for (kk in seq_along(NAMES)) {
[17:48:05.638]                   name <- changed[[kk]]
[17:48:05.638]                   NAME <- NAMES[[kk]]
[17:48:05.638]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.638]                     next
[17:48:05.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.638]                 }
[17:48:05.638]                 NAMES <- toupper(added)
[17:48:05.638]                 for (kk in seq_along(NAMES)) {
[17:48:05.638]                   name <- added[[kk]]
[17:48:05.638]                   NAME <- NAMES[[kk]]
[17:48:05.638]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.638]                     next
[17:48:05.638]                   args[[name]] <- ""
[17:48:05.638]                 }
[17:48:05.638]                 NAMES <- toupper(removed)
[17:48:05.638]                 for (kk in seq_along(NAMES)) {
[17:48:05.638]                   name <- removed[[kk]]
[17:48:05.638]                   NAME <- NAMES[[kk]]
[17:48:05.638]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.638]                     next
[17:48:05.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.638]                 }
[17:48:05.638]                 if (length(args) > 0) 
[17:48:05.638]                   base::do.call(base::Sys.setenv, args = args)
[17:48:05.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:05.638]             }
[17:48:05.638]             else {
[17:48:05.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:05.638]             }
[17:48:05.638]             {
[17:48:05.638]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:05.638]                   0L) {
[17:48:05.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:05.638]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:05.638]                   base::options(opts)
[17:48:05.638]                 }
[17:48:05.638]                 {
[17:48:05.638]                   {
[17:48:05.638]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:05.638]                     NULL
[17:48:05.638]                   }
[17:48:05.638]                   options(future.plan = NULL)
[17:48:05.638]                   if (is.na(NA_character_)) 
[17:48:05.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:05.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:05.638]                     .init = FALSE)
[17:48:05.638]                 }
[17:48:05.638]             }
[17:48:05.638]         }
[17:48:05.638]     })
[17:48:05.638]     if (TRUE) {
[17:48:05.638]         base::sink(type = "output", split = FALSE)
[17:48:05.638]         if (TRUE) {
[17:48:05.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:05.638]         }
[17:48:05.638]         else {
[17:48:05.638]             ...future.result["stdout"] <- base::list(NULL)
[17:48:05.638]         }
[17:48:05.638]         base::close(...future.stdout)
[17:48:05.638]         ...future.stdout <- NULL
[17:48:05.638]     }
[17:48:05.638]     ...future.result$conditions <- ...future.conditions
[17:48:05.638]     ...future.result$finished <- base::Sys.time()
[17:48:05.638]     ...future.result
[17:48:05.638] }
[17:48:05.640] Poll #1 (0): usedNodes() = 2, workers = 2
[17:48:05.650] receiveMessageFromWorker() for ClusterFuture ...
[17:48:05.650] - Validating connection of MultisessionFuture
[17:48:05.651] - received message: FutureResult
[17:48:05.651] - Received FutureResult
[17:48:05.651] - Erased future from FutureRegistry
[17:48:05.651] result() for ClusterFuture ...
[17:48:05.651] - result already collected: FutureResult
[17:48:05.651] result() for ClusterFuture ... done
[17:48:05.651] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:05.651] result() for ClusterFuture ...
[17:48:05.651] - result already collected: FutureResult
[17:48:05.652] result() for ClusterFuture ... done
[17:48:05.652] result() for ClusterFuture ...
[17:48:05.652] - result already collected: FutureResult
[17:48:05.652] result() for ClusterFuture ... done
[17:48:05.653] MultisessionFuture started
[17:48:05.653] - Launch lazy future ... done
[17:48:05.653] run() for ‘MultisessionFuture’ ... done
[17:48:05.653] getGlobalsAndPackages() ...
[17:48:05.653] Searching for globals...
[17:48:05.654] - globals found: [2] ‘list’, ‘stop’
[17:48:05.654] Searching for globals ... DONE
[17:48:05.654] Resolving globals: FALSE
[17:48:05.654] 
[17:48:05.654] 
[17:48:05.655] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[17:48:05.655] getGlobalsAndPackages() ...
[17:48:05.655] Searching for globals...
[17:48:05.656] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:05.656] Searching for globals ... DONE
[17:48:05.656] Resolving globals: FALSE
[17:48:05.657] 
[17:48:05.657] 
[17:48:05.657] getGlobalsAndPackages() ... DONE
[17:48:05.657] run() for ‘Future’ ...
[17:48:05.657] - state: ‘created’
[17:48:05.657] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:05.670] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:05.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:05.671]   - Field: ‘node’
[17:48:05.671]   - Field: ‘label’
[17:48:05.671]   - Field: ‘local’
[17:48:05.671]   - Field: ‘owner’
[17:48:05.671]   - Field: ‘envir’
[17:48:05.671]   - Field: ‘workers’
[17:48:05.671]   - Field: ‘packages’
[17:48:05.671]   - Field: ‘gc’
[17:48:05.671]   - Field: ‘conditions’
[17:48:05.672]   - Field: ‘persistent’
[17:48:05.672]   - Field: ‘expr’
[17:48:05.672]   - Field: ‘uuid’
[17:48:05.672]   - Field: ‘seed’
[17:48:05.672]   - Field: ‘version’
[17:48:05.672]   - Field: ‘result’
[17:48:05.672]   - Field: ‘asynchronous’
[17:48:05.672]   - Field: ‘calls’
[17:48:05.672]   - Field: ‘globals’
[17:48:05.672]   - Field: ‘stdout’
[17:48:05.672]   - Field: ‘earlySignal’
[17:48:05.673]   - Field: ‘lazy’
[17:48:05.673]   - Field: ‘state’
[17:48:05.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:05.673] - Launch lazy future ...
[17:48:05.673] Packages needed by the future expression (n = 0): <none>
[17:48:05.673] Packages needed by future strategies (n = 0): <none>
[17:48:05.674] {
[17:48:05.674]     {
[17:48:05.674]         {
[17:48:05.674]             ...future.startTime <- base::Sys.time()
[17:48:05.674]             {
[17:48:05.674]                 {
[17:48:05.674]                   {
[17:48:05.674]                     {
[17:48:05.674]                       base::local({
[17:48:05.674]                         has_future <- base::requireNamespace("future", 
[17:48:05.674]                           quietly = TRUE)
[17:48:05.674]                         if (has_future) {
[17:48:05.674]                           ns <- base::getNamespace("future")
[17:48:05.674]                           version <- ns[[".package"]][["version"]]
[17:48:05.674]                           if (is.null(version)) 
[17:48:05.674]                             version <- utils::packageVersion("future")
[17:48:05.674]                         }
[17:48:05.674]                         else {
[17:48:05.674]                           version <- NULL
[17:48:05.674]                         }
[17:48:05.674]                         if (!has_future || version < "1.8.0") {
[17:48:05.674]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:05.674]                             "", base::R.version$version.string), 
[17:48:05.674]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:05.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:05.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:05.674]                               "release", "version")], collapse = " "), 
[17:48:05.674]                             hostname = base::Sys.info()[["nodename"]])
[17:48:05.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:05.674]                             info)
[17:48:05.674]                           info <- base::paste(info, collapse = "; ")
[17:48:05.674]                           if (!has_future) {
[17:48:05.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:05.674]                               info)
[17:48:05.674]                           }
[17:48:05.674]                           else {
[17:48:05.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:05.674]                               info, version)
[17:48:05.674]                           }
[17:48:05.674]                           base::stop(msg)
[17:48:05.674]                         }
[17:48:05.674]                       })
[17:48:05.674]                     }
[17:48:05.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:05.674]                     base::options(mc.cores = 1L)
[17:48:05.674]                   }
[17:48:05.674]                   ...future.strategy.old <- future::plan("list")
[17:48:05.674]                   options(future.plan = NULL)
[17:48:05.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:05.674]                 }
[17:48:05.674]                 ...future.workdir <- getwd()
[17:48:05.674]             }
[17:48:05.674]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:05.674]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:05.674]         }
[17:48:05.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:05.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:05.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:05.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:05.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:05.674]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:05.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:05.674]             base::names(...future.oldOptions))
[17:48:05.674]     }
[17:48:05.674]     if (FALSE) {
[17:48:05.674]     }
[17:48:05.674]     else {
[17:48:05.674]         if (TRUE) {
[17:48:05.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:05.674]                 open = "w")
[17:48:05.674]         }
[17:48:05.674]         else {
[17:48:05.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:05.674]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:05.674]         }
[17:48:05.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:05.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:05.674]             base::sink(type = "output", split = FALSE)
[17:48:05.674]             base::close(...future.stdout)
[17:48:05.674]         }, add = TRUE)
[17:48:05.674]     }
[17:48:05.674]     ...future.frame <- base::sys.nframe()
[17:48:05.674]     ...future.conditions <- base::list()
[17:48:05.674]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:05.674]     if (FALSE) {
[17:48:05.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:05.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:05.674]     }
[17:48:05.674]     ...future.result <- base::tryCatch({
[17:48:05.674]         base::withCallingHandlers({
[17:48:05.674]             ...future.value <- base::withVisible(base::local({
[17:48:05.674]                 ...future.makeSendCondition <- base::local({
[17:48:05.674]                   sendCondition <- NULL
[17:48:05.674]                   function(frame = 1L) {
[17:48:05.674]                     if (is.function(sendCondition)) 
[17:48:05.674]                       return(sendCondition)
[17:48:05.674]                     ns <- getNamespace("parallel")
[17:48:05.674]                     if (exists("sendData", mode = "function", 
[17:48:05.674]                       envir = ns)) {
[17:48:05.674]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:05.674]                         envir = ns)
[17:48:05.674]                       envir <- sys.frame(frame)
[17:48:05.674]                       master <- NULL
[17:48:05.674]                       while (!identical(envir, .GlobalEnv) && 
[17:48:05.674]                         !identical(envir, emptyenv())) {
[17:48:05.674]                         if (exists("master", mode = "list", envir = envir, 
[17:48:05.674]                           inherits = FALSE)) {
[17:48:05.674]                           master <- get("master", mode = "list", 
[17:48:05.674]                             envir = envir, inherits = FALSE)
[17:48:05.674]                           if (inherits(master, c("SOCKnode", 
[17:48:05.674]                             "SOCK0node"))) {
[17:48:05.674]                             sendCondition <<- function(cond) {
[17:48:05.674]                               data <- list(type = "VALUE", value = cond, 
[17:48:05.674]                                 success = TRUE)
[17:48:05.674]                               parallel_sendData(master, data)
[17:48:05.674]                             }
[17:48:05.674]                             return(sendCondition)
[17:48:05.674]                           }
[17:48:05.674]                         }
[17:48:05.674]                         frame <- frame + 1L
[17:48:05.674]                         envir <- sys.frame(frame)
[17:48:05.674]                       }
[17:48:05.674]                     }
[17:48:05.674]                     sendCondition <<- function(cond) NULL
[17:48:05.674]                   }
[17:48:05.674]                 })
[17:48:05.674]                 withCallingHandlers({
[17:48:05.674]                   {
[17:48:05.674]                     Sys.sleep(0.5)
[17:48:05.674]                     list(a = 1, b = 42L)
[17:48:05.674]                   }
[17:48:05.674]                 }, immediateCondition = function(cond) {
[17:48:05.674]                   sendCondition <- ...future.makeSendCondition()
[17:48:05.674]                   sendCondition(cond)
[17:48:05.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.674]                   {
[17:48:05.674]                     inherits <- base::inherits
[17:48:05.674]                     invokeRestart <- base::invokeRestart
[17:48:05.674]                     is.null <- base::is.null
[17:48:05.674]                     muffled <- FALSE
[17:48:05.674]                     if (inherits(cond, "message")) {
[17:48:05.674]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:05.674]                       if (muffled) 
[17:48:05.674]                         invokeRestart("muffleMessage")
[17:48:05.674]                     }
[17:48:05.674]                     else if (inherits(cond, "warning")) {
[17:48:05.674]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:05.674]                       if (muffled) 
[17:48:05.674]                         invokeRestart("muffleWarning")
[17:48:05.674]                     }
[17:48:05.674]                     else if (inherits(cond, "condition")) {
[17:48:05.674]                       if (!is.null(pattern)) {
[17:48:05.674]                         computeRestarts <- base::computeRestarts
[17:48:05.674]                         grepl <- base::grepl
[17:48:05.674]                         restarts <- computeRestarts(cond)
[17:48:05.674]                         for (restart in restarts) {
[17:48:05.674]                           name <- restart$name
[17:48:05.674]                           if (is.null(name)) 
[17:48:05.674]                             next
[17:48:05.674]                           if (!grepl(pattern, name)) 
[17:48:05.674]                             next
[17:48:05.674]                           invokeRestart(restart)
[17:48:05.674]                           muffled <- TRUE
[17:48:05.674]                           break
[17:48:05.674]                         }
[17:48:05.674]                       }
[17:48:05.674]                     }
[17:48:05.674]                     invisible(muffled)
[17:48:05.674]                   }
[17:48:05.674]                   muffleCondition(cond)
[17:48:05.674]                 })
[17:48:05.674]             }))
[17:48:05.674]             future::FutureResult(value = ...future.value$value, 
[17:48:05.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.674]                   ...future.rng), globalenv = if (FALSE) 
[17:48:05.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:05.674]                     ...future.globalenv.names))
[17:48:05.674]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:05.674]         }, condition = base::local({
[17:48:05.674]             c <- base::c
[17:48:05.674]             inherits <- base::inherits
[17:48:05.674]             invokeRestart <- base::invokeRestart
[17:48:05.674]             length <- base::length
[17:48:05.674]             list <- base::list
[17:48:05.674]             seq.int <- base::seq.int
[17:48:05.674]             signalCondition <- base::signalCondition
[17:48:05.674]             sys.calls <- base::sys.calls
[17:48:05.674]             `[[` <- base::`[[`
[17:48:05.674]             `+` <- base::`+`
[17:48:05.674]             `<<-` <- base::`<<-`
[17:48:05.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:05.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:05.674]                   3L)]
[17:48:05.674]             }
[17:48:05.674]             function(cond) {
[17:48:05.674]                 is_error <- inherits(cond, "error")
[17:48:05.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:05.674]                   NULL)
[17:48:05.674]                 if (is_error) {
[17:48:05.674]                   sessionInformation <- function() {
[17:48:05.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:05.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:05.674]                       search = base::search(), system = base::Sys.info())
[17:48:05.674]                   }
[17:48:05.674]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:05.674]                     cond$call), session = sessionInformation(), 
[17:48:05.674]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:05.674]                   signalCondition(cond)
[17:48:05.674]                 }
[17:48:05.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:05.674]                 "immediateCondition"))) {
[17:48:05.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:05.674]                   ...future.conditions[[length(...future.conditions) + 
[17:48:05.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:05.674]                   if (TRUE && !signal) {
[17:48:05.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.674]                     {
[17:48:05.674]                       inherits <- base::inherits
[17:48:05.674]                       invokeRestart <- base::invokeRestart
[17:48:05.674]                       is.null <- base::is.null
[17:48:05.674]                       muffled <- FALSE
[17:48:05.674]                       if (inherits(cond, "message")) {
[17:48:05.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.674]                         if (muffled) 
[17:48:05.674]                           invokeRestart("muffleMessage")
[17:48:05.674]                       }
[17:48:05.674]                       else if (inherits(cond, "warning")) {
[17:48:05.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.674]                         if (muffled) 
[17:48:05.674]                           invokeRestart("muffleWarning")
[17:48:05.674]                       }
[17:48:05.674]                       else if (inherits(cond, "condition")) {
[17:48:05.674]                         if (!is.null(pattern)) {
[17:48:05.674]                           computeRestarts <- base::computeRestarts
[17:48:05.674]                           grepl <- base::grepl
[17:48:05.674]                           restarts <- computeRestarts(cond)
[17:48:05.674]                           for (restart in restarts) {
[17:48:05.674]                             name <- restart$name
[17:48:05.674]                             if (is.null(name)) 
[17:48:05.674]                               next
[17:48:05.674]                             if (!grepl(pattern, name)) 
[17:48:05.674]                               next
[17:48:05.674]                             invokeRestart(restart)
[17:48:05.674]                             muffled <- TRUE
[17:48:05.674]                             break
[17:48:05.674]                           }
[17:48:05.674]                         }
[17:48:05.674]                       }
[17:48:05.674]                       invisible(muffled)
[17:48:05.674]                     }
[17:48:05.674]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.674]                   }
[17:48:05.674]                 }
[17:48:05.674]                 else {
[17:48:05.674]                   if (TRUE) {
[17:48:05.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:05.674]                     {
[17:48:05.674]                       inherits <- base::inherits
[17:48:05.674]                       invokeRestart <- base::invokeRestart
[17:48:05.674]                       is.null <- base::is.null
[17:48:05.674]                       muffled <- FALSE
[17:48:05.674]                       if (inherits(cond, "message")) {
[17:48:05.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:05.674]                         if (muffled) 
[17:48:05.674]                           invokeRestart("muffleMessage")
[17:48:05.674]                       }
[17:48:05.674]                       else if (inherits(cond, "warning")) {
[17:48:05.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:05.674]                         if (muffled) 
[17:48:05.674]                           invokeRestart("muffleWarning")
[17:48:05.674]                       }
[17:48:05.674]                       else if (inherits(cond, "condition")) {
[17:48:05.674]                         if (!is.null(pattern)) {
[17:48:05.674]                           computeRestarts <- base::computeRestarts
[17:48:05.674]                           grepl <- base::grepl
[17:48:05.674]                           restarts <- computeRestarts(cond)
[17:48:05.674]                           for (restart in restarts) {
[17:48:05.674]                             name <- restart$name
[17:48:05.674]                             if (is.null(name)) 
[17:48:05.674]                               next
[17:48:05.674]                             if (!grepl(pattern, name)) 
[17:48:05.674]                               next
[17:48:05.674]                             invokeRestart(restart)
[17:48:05.674]                             muffled <- TRUE
[17:48:05.674]                             break
[17:48:05.674]                           }
[17:48:05.674]                         }
[17:48:05.674]                       }
[17:48:05.674]                       invisible(muffled)
[17:48:05.674]                     }
[17:48:05.674]                     muffleCondition(cond, pattern = "^muffle")
[17:48:05.674]                   }
[17:48:05.674]                 }
[17:48:05.674]             }
[17:48:05.674]         }))
[17:48:05.674]     }, error = function(ex) {
[17:48:05.674]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:05.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:05.674]                 ...future.rng), started = ...future.startTime, 
[17:48:05.674]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:05.674]             version = "1.8"), class = "FutureResult")
[17:48:05.674]     }, finally = {
[17:48:05.674]         if (!identical(...future.workdir, getwd())) 
[17:48:05.674]             setwd(...future.workdir)
[17:48:05.674]         {
[17:48:05.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:05.674]                 ...future.oldOptions$nwarnings <- NULL
[17:48:05.674]             }
[17:48:05.674]             base::options(...future.oldOptions)
[17:48:05.674]             if (.Platform$OS.type == "windows") {
[17:48:05.674]                 old_names <- names(...future.oldEnvVars)
[17:48:05.674]                 envs <- base::Sys.getenv()
[17:48:05.674]                 names <- names(envs)
[17:48:05.674]                 common <- intersect(names, old_names)
[17:48:05.674]                 added <- setdiff(names, old_names)
[17:48:05.674]                 removed <- setdiff(old_names, names)
[17:48:05.674]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:05.674]                   envs[common]]
[17:48:05.674]                 NAMES <- toupper(changed)
[17:48:05.674]                 args <- list()
[17:48:05.674]                 for (kk in seq_along(NAMES)) {
[17:48:05.674]                   name <- changed[[kk]]
[17:48:05.674]                   NAME <- NAMES[[kk]]
[17:48:05.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.674]                     next
[17:48:05.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.674]                 }
[17:48:05.674]                 NAMES <- toupper(added)
[17:48:05.674]                 for (kk in seq_along(NAMES)) {
[17:48:05.674]                   name <- added[[kk]]
[17:48:05.674]                   NAME <- NAMES[[kk]]
[17:48:05.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.674]                     next
[17:48:05.674]                   args[[name]] <- ""
[17:48:05.674]                 }
[17:48:05.674]                 NAMES <- toupper(removed)
[17:48:05.674]                 for (kk in seq_along(NAMES)) {
[17:48:05.674]                   name <- removed[[kk]]
[17:48:05.674]                   NAME <- NAMES[[kk]]
[17:48:05.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:05.674]                     next
[17:48:05.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:05.674]                 }
[17:48:05.674]                 if (length(args) > 0) 
[17:48:05.674]                   base::do.call(base::Sys.setenv, args = args)
[17:48:05.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:05.674]             }
[17:48:05.674]             else {
[17:48:05.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:05.674]             }
[17:48:05.674]             {
[17:48:05.674]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:05.674]                   0L) {
[17:48:05.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:05.674]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:05.674]                   base::options(opts)
[17:48:05.674]                 }
[17:48:05.674]                 {
[17:48:05.674]                   {
[17:48:05.674]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:05.674]                     NULL
[17:48:05.674]                   }
[17:48:05.674]                   options(future.plan = NULL)
[17:48:05.674]                   if (is.na(NA_character_)) 
[17:48:05.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:05.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:05.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:05.674]                     .init = FALSE)
[17:48:05.674]                 }
[17:48:05.674]             }
[17:48:05.674]         }
[17:48:05.674]     })
[17:48:05.674]     if (TRUE) {
[17:48:05.674]         base::sink(type = "output", split = FALSE)
[17:48:05.674]         if (TRUE) {
[17:48:05.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:05.674]         }
[17:48:05.674]         else {
[17:48:05.674]             ...future.result["stdout"] <- base::list(NULL)
[17:48:05.674]         }
[17:48:05.674]         base::close(...future.stdout)
[17:48:05.674]         ...future.stdout <- NULL
[17:48:05.674]     }
[17:48:05.674]     ...future.result$conditions <- ...future.conditions
[17:48:05.674]     ...future.result$finished <- base::Sys.time()
[17:48:05.674]     ...future.result
[17:48:05.674] }
[17:48:05.676] Poll #1 (0): usedNodes() = 2, workers = 2
[17:48:05.697] receiveMessageFromWorker() for ClusterFuture ...
[17:48:05.697] - Validating connection of MultisessionFuture
[17:48:05.697] - received message: FutureResult
[17:48:05.697] - Received FutureResult
[17:48:05.698] - Erased future from FutureRegistry
[17:48:05.698] result() for ClusterFuture ...
[17:48:05.698] - result already collected: FutureResult
[17:48:05.698] result() for ClusterFuture ... done
[17:48:05.698] signalConditions() ...
[17:48:05.698]  - include = ‘immediateCondition’
[17:48:05.698]  - exclude = 
[17:48:05.698]  - resignal = FALSE
[17:48:05.698]  - Number of conditions: 1
[17:48:05.698] signalConditions() ... done
[17:48:05.698] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:05.699] result() for ClusterFuture ...
[17:48:05.699] - result already collected: FutureResult
[17:48:05.699] result() for ClusterFuture ... done
[17:48:05.699] result() for ClusterFuture ...
[17:48:05.699] - result already collected: FutureResult
[17:48:05.699] result() for ClusterFuture ... done
[17:48:05.699] signalConditions() ...
[17:48:05.699]  - include = ‘immediateCondition’
[17:48:05.699]  - exclude = 
[17:48:05.699]  - resignal = FALSE
[17:48:05.699]  - Number of conditions: 1
[17:48:05.700] signalConditions() ... done
[17:48:05.701] MultisessionFuture started
[17:48:05.701] - Launch lazy future ... done
[17:48:05.701] run() for ‘MultisessionFuture’ ... done
[17:48:06.203] receiveMessageFromWorker() for ClusterFuture ...
[17:48:06.203] - Validating connection of MultisessionFuture
[17:48:06.204] - received message: FutureResult
[17:48:06.204] - Received FutureResult
[17:48:06.204] - Erased future from FutureRegistry
[17:48:06.204] result() for ClusterFuture ...
[17:48:06.204] - result already collected: FutureResult
[17:48:06.204] result() for ClusterFuture ... done
[17:48:06.204] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:06.204] A MultisessionFuture was resolved
[17:48:06.204] getGlobalsAndPackages() ...
[17:48:06.205] Searching for globals...
[17:48:06.206] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:06.206] Searching for globals ... DONE
[17:48:06.206] Resolving globals: FALSE
[17:48:06.206] 
[17:48:06.206] 
[17:48:06.206] getGlobalsAndPackages() ... DONE
[17:48:06.207] run() for ‘Future’ ...
[17:48:06.207] - state: ‘created’
[17:48:06.207] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:06.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:06.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:06.221]   - Field: ‘node’
[17:48:06.221]   - Field: ‘label’
[17:48:06.221]   - Field: ‘local’
[17:48:06.221]   - Field: ‘owner’
[17:48:06.221]   - Field: ‘envir’
[17:48:06.222]   - Field: ‘workers’
[17:48:06.222]   - Field: ‘packages’
[17:48:06.222]   - Field: ‘gc’
[17:48:06.222]   - Field: ‘conditions’
[17:48:06.222]   - Field: ‘persistent’
[17:48:06.222]   - Field: ‘expr’
[17:48:06.222]   - Field: ‘uuid’
[17:48:06.222]   - Field: ‘seed’
[17:48:06.222]   - Field: ‘version’
[17:48:06.222]   - Field: ‘result’
[17:48:06.222]   - Field: ‘asynchronous’
[17:48:06.223]   - Field: ‘calls’
[17:48:06.223]   - Field: ‘globals’
[17:48:06.223]   - Field: ‘stdout’
[17:48:06.223]   - Field: ‘earlySignal’
[17:48:06.223]   - Field: ‘lazy’
[17:48:06.223]   - Field: ‘state’
[17:48:06.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:06.223] - Launch lazy future ...
[17:48:06.223] Packages needed by the future expression (n = 0): <none>
[17:48:06.224] Packages needed by future strategies (n = 0): <none>
[17:48:06.224] {
[17:48:06.224]     {
[17:48:06.224]         {
[17:48:06.224]             ...future.startTime <- base::Sys.time()
[17:48:06.224]             {
[17:48:06.224]                 {
[17:48:06.224]                   {
[17:48:06.224]                     {
[17:48:06.224]                       base::local({
[17:48:06.224]                         has_future <- base::requireNamespace("future", 
[17:48:06.224]                           quietly = TRUE)
[17:48:06.224]                         if (has_future) {
[17:48:06.224]                           ns <- base::getNamespace("future")
[17:48:06.224]                           version <- ns[[".package"]][["version"]]
[17:48:06.224]                           if (is.null(version)) 
[17:48:06.224]                             version <- utils::packageVersion("future")
[17:48:06.224]                         }
[17:48:06.224]                         else {
[17:48:06.224]                           version <- NULL
[17:48:06.224]                         }
[17:48:06.224]                         if (!has_future || version < "1.8.0") {
[17:48:06.224]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:06.224]                             "", base::R.version$version.string), 
[17:48:06.224]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:06.224]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:06.224]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:06.224]                               "release", "version")], collapse = " "), 
[17:48:06.224]                             hostname = base::Sys.info()[["nodename"]])
[17:48:06.224]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:06.224]                             info)
[17:48:06.224]                           info <- base::paste(info, collapse = "; ")
[17:48:06.224]                           if (!has_future) {
[17:48:06.224]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:06.224]                               info)
[17:48:06.224]                           }
[17:48:06.224]                           else {
[17:48:06.224]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:06.224]                               info, version)
[17:48:06.224]                           }
[17:48:06.224]                           base::stop(msg)
[17:48:06.224]                         }
[17:48:06.224]                       })
[17:48:06.224]                     }
[17:48:06.224]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:06.224]                     base::options(mc.cores = 1L)
[17:48:06.224]                   }
[17:48:06.224]                   ...future.strategy.old <- future::plan("list")
[17:48:06.224]                   options(future.plan = NULL)
[17:48:06.224]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.224]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:06.224]                 }
[17:48:06.224]                 ...future.workdir <- getwd()
[17:48:06.224]             }
[17:48:06.224]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:06.224]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:06.224]         }
[17:48:06.224]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:06.224]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:06.224]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:06.224]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:06.224]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:06.224]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:06.224]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:06.224]             base::names(...future.oldOptions))
[17:48:06.224]     }
[17:48:06.224]     if (FALSE) {
[17:48:06.224]     }
[17:48:06.224]     else {
[17:48:06.224]         if (TRUE) {
[17:48:06.224]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:06.224]                 open = "w")
[17:48:06.224]         }
[17:48:06.224]         else {
[17:48:06.224]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:06.224]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:06.224]         }
[17:48:06.224]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:06.224]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:06.224]             base::sink(type = "output", split = FALSE)
[17:48:06.224]             base::close(...future.stdout)
[17:48:06.224]         }, add = TRUE)
[17:48:06.224]     }
[17:48:06.224]     ...future.frame <- base::sys.nframe()
[17:48:06.224]     ...future.conditions <- base::list()
[17:48:06.224]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:06.224]     if (FALSE) {
[17:48:06.224]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:06.224]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:06.224]     }
[17:48:06.224]     ...future.result <- base::tryCatch({
[17:48:06.224]         base::withCallingHandlers({
[17:48:06.224]             ...future.value <- base::withVisible(base::local({
[17:48:06.224]                 ...future.makeSendCondition <- base::local({
[17:48:06.224]                   sendCondition <- NULL
[17:48:06.224]                   function(frame = 1L) {
[17:48:06.224]                     if (is.function(sendCondition)) 
[17:48:06.224]                       return(sendCondition)
[17:48:06.224]                     ns <- getNamespace("parallel")
[17:48:06.224]                     if (exists("sendData", mode = "function", 
[17:48:06.224]                       envir = ns)) {
[17:48:06.224]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:06.224]                         envir = ns)
[17:48:06.224]                       envir <- sys.frame(frame)
[17:48:06.224]                       master <- NULL
[17:48:06.224]                       while (!identical(envir, .GlobalEnv) && 
[17:48:06.224]                         !identical(envir, emptyenv())) {
[17:48:06.224]                         if (exists("master", mode = "list", envir = envir, 
[17:48:06.224]                           inherits = FALSE)) {
[17:48:06.224]                           master <- get("master", mode = "list", 
[17:48:06.224]                             envir = envir, inherits = FALSE)
[17:48:06.224]                           if (inherits(master, c("SOCKnode", 
[17:48:06.224]                             "SOCK0node"))) {
[17:48:06.224]                             sendCondition <<- function(cond) {
[17:48:06.224]                               data <- list(type = "VALUE", value = cond, 
[17:48:06.224]                                 success = TRUE)
[17:48:06.224]                               parallel_sendData(master, data)
[17:48:06.224]                             }
[17:48:06.224]                             return(sendCondition)
[17:48:06.224]                           }
[17:48:06.224]                         }
[17:48:06.224]                         frame <- frame + 1L
[17:48:06.224]                         envir <- sys.frame(frame)
[17:48:06.224]                       }
[17:48:06.224]                     }
[17:48:06.224]                     sendCondition <<- function(cond) NULL
[17:48:06.224]                   }
[17:48:06.224]                 })
[17:48:06.224]                 withCallingHandlers({
[17:48:06.224]                   {
[17:48:06.224]                     Sys.sleep(0.5)
[17:48:06.224]                     list(a = 1, b = 42L)
[17:48:06.224]                   }
[17:48:06.224]                 }, immediateCondition = function(cond) {
[17:48:06.224]                   sendCondition <- ...future.makeSendCondition()
[17:48:06.224]                   sendCondition(cond)
[17:48:06.224]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.224]                   {
[17:48:06.224]                     inherits <- base::inherits
[17:48:06.224]                     invokeRestart <- base::invokeRestart
[17:48:06.224]                     is.null <- base::is.null
[17:48:06.224]                     muffled <- FALSE
[17:48:06.224]                     if (inherits(cond, "message")) {
[17:48:06.224]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:06.224]                       if (muffled) 
[17:48:06.224]                         invokeRestart("muffleMessage")
[17:48:06.224]                     }
[17:48:06.224]                     else if (inherits(cond, "warning")) {
[17:48:06.224]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:06.224]                       if (muffled) 
[17:48:06.224]                         invokeRestart("muffleWarning")
[17:48:06.224]                     }
[17:48:06.224]                     else if (inherits(cond, "condition")) {
[17:48:06.224]                       if (!is.null(pattern)) {
[17:48:06.224]                         computeRestarts <- base::computeRestarts
[17:48:06.224]                         grepl <- base::grepl
[17:48:06.224]                         restarts <- computeRestarts(cond)
[17:48:06.224]                         for (restart in restarts) {
[17:48:06.224]                           name <- restart$name
[17:48:06.224]                           if (is.null(name)) 
[17:48:06.224]                             next
[17:48:06.224]                           if (!grepl(pattern, name)) 
[17:48:06.224]                             next
[17:48:06.224]                           invokeRestart(restart)
[17:48:06.224]                           muffled <- TRUE
[17:48:06.224]                           break
[17:48:06.224]                         }
[17:48:06.224]                       }
[17:48:06.224]                     }
[17:48:06.224]                     invisible(muffled)
[17:48:06.224]                   }
[17:48:06.224]                   muffleCondition(cond)
[17:48:06.224]                 })
[17:48:06.224]             }))
[17:48:06.224]             future::FutureResult(value = ...future.value$value, 
[17:48:06.224]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.224]                   ...future.rng), globalenv = if (FALSE) 
[17:48:06.224]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:06.224]                     ...future.globalenv.names))
[17:48:06.224]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:06.224]         }, condition = base::local({
[17:48:06.224]             c <- base::c
[17:48:06.224]             inherits <- base::inherits
[17:48:06.224]             invokeRestart <- base::invokeRestart
[17:48:06.224]             length <- base::length
[17:48:06.224]             list <- base::list
[17:48:06.224]             seq.int <- base::seq.int
[17:48:06.224]             signalCondition <- base::signalCondition
[17:48:06.224]             sys.calls <- base::sys.calls
[17:48:06.224]             `[[` <- base::`[[`
[17:48:06.224]             `+` <- base::`+`
[17:48:06.224]             `<<-` <- base::`<<-`
[17:48:06.224]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:06.224]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:06.224]                   3L)]
[17:48:06.224]             }
[17:48:06.224]             function(cond) {
[17:48:06.224]                 is_error <- inherits(cond, "error")
[17:48:06.224]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:06.224]                   NULL)
[17:48:06.224]                 if (is_error) {
[17:48:06.224]                   sessionInformation <- function() {
[17:48:06.224]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:06.224]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:06.224]                       search = base::search(), system = base::Sys.info())
[17:48:06.224]                   }
[17:48:06.224]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.224]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:06.224]                     cond$call), session = sessionInformation(), 
[17:48:06.224]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:06.224]                   signalCondition(cond)
[17:48:06.224]                 }
[17:48:06.224]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:06.224]                 "immediateCondition"))) {
[17:48:06.224]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:06.224]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.224]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:06.224]                   if (TRUE && !signal) {
[17:48:06.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.224]                     {
[17:48:06.224]                       inherits <- base::inherits
[17:48:06.224]                       invokeRestart <- base::invokeRestart
[17:48:06.224]                       is.null <- base::is.null
[17:48:06.224]                       muffled <- FALSE
[17:48:06.224]                       if (inherits(cond, "message")) {
[17:48:06.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.224]                         if (muffled) 
[17:48:06.224]                           invokeRestart("muffleMessage")
[17:48:06.224]                       }
[17:48:06.224]                       else if (inherits(cond, "warning")) {
[17:48:06.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.224]                         if (muffled) 
[17:48:06.224]                           invokeRestart("muffleWarning")
[17:48:06.224]                       }
[17:48:06.224]                       else if (inherits(cond, "condition")) {
[17:48:06.224]                         if (!is.null(pattern)) {
[17:48:06.224]                           computeRestarts <- base::computeRestarts
[17:48:06.224]                           grepl <- base::grepl
[17:48:06.224]                           restarts <- computeRestarts(cond)
[17:48:06.224]                           for (restart in restarts) {
[17:48:06.224]                             name <- restart$name
[17:48:06.224]                             if (is.null(name)) 
[17:48:06.224]                               next
[17:48:06.224]                             if (!grepl(pattern, name)) 
[17:48:06.224]                               next
[17:48:06.224]                             invokeRestart(restart)
[17:48:06.224]                             muffled <- TRUE
[17:48:06.224]                             break
[17:48:06.224]                           }
[17:48:06.224]                         }
[17:48:06.224]                       }
[17:48:06.224]                       invisible(muffled)
[17:48:06.224]                     }
[17:48:06.224]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.224]                   }
[17:48:06.224]                 }
[17:48:06.224]                 else {
[17:48:06.224]                   if (TRUE) {
[17:48:06.224]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.224]                     {
[17:48:06.224]                       inherits <- base::inherits
[17:48:06.224]                       invokeRestart <- base::invokeRestart
[17:48:06.224]                       is.null <- base::is.null
[17:48:06.224]                       muffled <- FALSE
[17:48:06.224]                       if (inherits(cond, "message")) {
[17:48:06.224]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.224]                         if (muffled) 
[17:48:06.224]                           invokeRestart("muffleMessage")
[17:48:06.224]                       }
[17:48:06.224]                       else if (inherits(cond, "warning")) {
[17:48:06.224]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.224]                         if (muffled) 
[17:48:06.224]                           invokeRestart("muffleWarning")
[17:48:06.224]                       }
[17:48:06.224]                       else if (inherits(cond, "condition")) {
[17:48:06.224]                         if (!is.null(pattern)) {
[17:48:06.224]                           computeRestarts <- base::computeRestarts
[17:48:06.224]                           grepl <- base::grepl
[17:48:06.224]                           restarts <- computeRestarts(cond)
[17:48:06.224]                           for (restart in restarts) {
[17:48:06.224]                             name <- restart$name
[17:48:06.224]                             if (is.null(name)) 
[17:48:06.224]                               next
[17:48:06.224]                             if (!grepl(pattern, name)) 
[17:48:06.224]                               next
[17:48:06.224]                             invokeRestart(restart)
[17:48:06.224]                             muffled <- TRUE
[17:48:06.224]                             break
[17:48:06.224]                           }
[17:48:06.224]                         }
[17:48:06.224]                       }
[17:48:06.224]                       invisible(muffled)
[17:48:06.224]                     }
[17:48:06.224]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.224]                   }
[17:48:06.224]                 }
[17:48:06.224]             }
[17:48:06.224]         }))
[17:48:06.224]     }, error = function(ex) {
[17:48:06.224]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:06.224]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.224]                 ...future.rng), started = ...future.startTime, 
[17:48:06.224]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:06.224]             version = "1.8"), class = "FutureResult")
[17:48:06.224]     }, finally = {
[17:48:06.224]         if (!identical(...future.workdir, getwd())) 
[17:48:06.224]             setwd(...future.workdir)
[17:48:06.224]         {
[17:48:06.224]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:06.224]                 ...future.oldOptions$nwarnings <- NULL
[17:48:06.224]             }
[17:48:06.224]             base::options(...future.oldOptions)
[17:48:06.224]             if (.Platform$OS.type == "windows") {
[17:48:06.224]                 old_names <- names(...future.oldEnvVars)
[17:48:06.224]                 envs <- base::Sys.getenv()
[17:48:06.224]                 names <- names(envs)
[17:48:06.224]                 common <- intersect(names, old_names)
[17:48:06.224]                 added <- setdiff(names, old_names)
[17:48:06.224]                 removed <- setdiff(old_names, names)
[17:48:06.224]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:06.224]                   envs[common]]
[17:48:06.224]                 NAMES <- toupper(changed)
[17:48:06.224]                 args <- list()
[17:48:06.224]                 for (kk in seq_along(NAMES)) {
[17:48:06.224]                   name <- changed[[kk]]
[17:48:06.224]                   NAME <- NAMES[[kk]]
[17:48:06.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.224]                     next
[17:48:06.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.224]                 }
[17:48:06.224]                 NAMES <- toupper(added)
[17:48:06.224]                 for (kk in seq_along(NAMES)) {
[17:48:06.224]                   name <- added[[kk]]
[17:48:06.224]                   NAME <- NAMES[[kk]]
[17:48:06.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.224]                     next
[17:48:06.224]                   args[[name]] <- ""
[17:48:06.224]                 }
[17:48:06.224]                 NAMES <- toupper(removed)
[17:48:06.224]                 for (kk in seq_along(NAMES)) {
[17:48:06.224]                   name <- removed[[kk]]
[17:48:06.224]                   NAME <- NAMES[[kk]]
[17:48:06.224]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.224]                     next
[17:48:06.224]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.224]                 }
[17:48:06.224]                 if (length(args) > 0) 
[17:48:06.224]                   base::do.call(base::Sys.setenv, args = args)
[17:48:06.224]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:06.224]             }
[17:48:06.224]             else {
[17:48:06.224]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:06.224]             }
[17:48:06.224]             {
[17:48:06.224]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:06.224]                   0L) {
[17:48:06.224]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:06.224]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:06.224]                   base::options(opts)
[17:48:06.224]                 }
[17:48:06.224]                 {
[17:48:06.224]                   {
[17:48:06.224]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:06.224]                     NULL
[17:48:06.224]                   }
[17:48:06.224]                   options(future.plan = NULL)
[17:48:06.224]                   if (is.na(NA_character_)) 
[17:48:06.224]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.224]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:06.224]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:06.224]                     .init = FALSE)
[17:48:06.224]                 }
[17:48:06.224]             }
[17:48:06.224]         }
[17:48:06.224]     })
[17:48:06.224]     if (TRUE) {
[17:48:06.224]         base::sink(type = "output", split = FALSE)
[17:48:06.224]         if (TRUE) {
[17:48:06.224]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:06.224]         }
[17:48:06.224]         else {
[17:48:06.224]             ...future.result["stdout"] <- base::list(NULL)
[17:48:06.224]         }
[17:48:06.224]         base::close(...future.stdout)
[17:48:06.224]         ...future.stdout <- NULL
[17:48:06.224]     }
[17:48:06.224]     ...future.result$conditions <- ...future.conditions
[17:48:06.224]     ...future.result$finished <- base::Sys.time()
[17:48:06.224]     ...future.result
[17:48:06.224] }
[17:48:06.227] MultisessionFuture started
[17:48:06.227] - Launch lazy future ... done
[17:48:06.227] run() for ‘MultisessionFuture’ ... done
[17:48:06.729] receiveMessageFromWorker() for ClusterFuture ...
[17:48:06.730] - Validating connection of MultisessionFuture
[17:48:06.730] - received message: FutureResult
[17:48:06.730] - Received FutureResult
[17:48:06.730] - Erased future from FutureRegistry
[17:48:06.730] result() for ClusterFuture ...
[17:48:06.730] - result already collected: FutureResult
[17:48:06.731] result() for ClusterFuture ... done
[17:48:06.731] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:06.731] A MultisessionFuture was resolved
- w/ exception ...
[17:48:06.731] getGlobalsAndPackages() ...
[17:48:06.731] Searching for globals...
[17:48:06.732] - globals found: [2] ‘list’, ‘stop’
[17:48:06.732] Searching for globals ... DONE
[17:48:06.732] Resolving globals: FALSE
[17:48:06.732] 
[17:48:06.732] 
[17:48:06.732] getGlobalsAndPackages() ... DONE
[17:48:06.733] run() for ‘Future’ ...
[17:48:06.733] - state: ‘created’
[17:48:06.733] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:06.747] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:06.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:06.747]   - Field: ‘node’
[17:48:06.747]   - Field: ‘label’
[17:48:06.748]   - Field: ‘local’
[17:48:06.748]   - Field: ‘owner’
[17:48:06.748]   - Field: ‘envir’
[17:48:06.748]   - Field: ‘workers’
[17:48:06.748]   - Field: ‘packages’
[17:48:06.748]   - Field: ‘gc’
[17:48:06.748]   - Field: ‘conditions’
[17:48:06.748]   - Field: ‘persistent’
[17:48:06.748]   - Field: ‘expr’
[17:48:06.748]   - Field: ‘uuid’
[17:48:06.748]   - Field: ‘seed’
[17:48:06.749]   - Field: ‘version’
[17:48:06.749]   - Field: ‘result’
[17:48:06.749]   - Field: ‘asynchronous’
[17:48:06.749]   - Field: ‘calls’
[17:48:06.749]   - Field: ‘globals’
[17:48:06.749]   - Field: ‘stdout’
[17:48:06.749]   - Field: ‘earlySignal’
[17:48:06.749]   - Field: ‘lazy’
[17:48:06.749]   - Field: ‘state’
[17:48:06.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:06.749] - Launch lazy future ...
[17:48:06.750] Packages needed by the future expression (n = 0): <none>
[17:48:06.750] Packages needed by future strategies (n = 0): <none>
[17:48:06.750] {
[17:48:06.750]     {
[17:48:06.750]         {
[17:48:06.750]             ...future.startTime <- base::Sys.time()
[17:48:06.750]             {
[17:48:06.750]                 {
[17:48:06.750]                   {
[17:48:06.750]                     {
[17:48:06.750]                       base::local({
[17:48:06.750]                         has_future <- base::requireNamespace("future", 
[17:48:06.750]                           quietly = TRUE)
[17:48:06.750]                         if (has_future) {
[17:48:06.750]                           ns <- base::getNamespace("future")
[17:48:06.750]                           version <- ns[[".package"]][["version"]]
[17:48:06.750]                           if (is.null(version)) 
[17:48:06.750]                             version <- utils::packageVersion("future")
[17:48:06.750]                         }
[17:48:06.750]                         else {
[17:48:06.750]                           version <- NULL
[17:48:06.750]                         }
[17:48:06.750]                         if (!has_future || version < "1.8.0") {
[17:48:06.750]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:06.750]                             "", base::R.version$version.string), 
[17:48:06.750]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:06.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:06.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:06.750]                               "release", "version")], collapse = " "), 
[17:48:06.750]                             hostname = base::Sys.info()[["nodename"]])
[17:48:06.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:06.750]                             info)
[17:48:06.750]                           info <- base::paste(info, collapse = "; ")
[17:48:06.750]                           if (!has_future) {
[17:48:06.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:06.750]                               info)
[17:48:06.750]                           }
[17:48:06.750]                           else {
[17:48:06.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:06.750]                               info, version)
[17:48:06.750]                           }
[17:48:06.750]                           base::stop(msg)
[17:48:06.750]                         }
[17:48:06.750]                       })
[17:48:06.750]                     }
[17:48:06.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:06.750]                     base::options(mc.cores = 1L)
[17:48:06.750]                   }
[17:48:06.750]                   ...future.strategy.old <- future::plan("list")
[17:48:06.750]                   options(future.plan = NULL)
[17:48:06.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:06.750]                 }
[17:48:06.750]                 ...future.workdir <- getwd()
[17:48:06.750]             }
[17:48:06.750]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:06.750]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:06.750]         }
[17:48:06.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:06.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:06.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:06.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:06.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:06.750]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:06.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:06.750]             base::names(...future.oldOptions))
[17:48:06.750]     }
[17:48:06.750]     if (FALSE) {
[17:48:06.750]     }
[17:48:06.750]     else {
[17:48:06.750]         if (TRUE) {
[17:48:06.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:06.750]                 open = "w")
[17:48:06.750]         }
[17:48:06.750]         else {
[17:48:06.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:06.750]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:06.750]         }
[17:48:06.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:06.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:06.750]             base::sink(type = "output", split = FALSE)
[17:48:06.750]             base::close(...future.stdout)
[17:48:06.750]         }, add = TRUE)
[17:48:06.750]     }
[17:48:06.750]     ...future.frame <- base::sys.nframe()
[17:48:06.750]     ...future.conditions <- base::list()
[17:48:06.750]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:06.750]     if (FALSE) {
[17:48:06.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:06.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:06.750]     }
[17:48:06.750]     ...future.result <- base::tryCatch({
[17:48:06.750]         base::withCallingHandlers({
[17:48:06.750]             ...future.value <- base::withVisible(base::local({
[17:48:06.750]                 ...future.makeSendCondition <- base::local({
[17:48:06.750]                   sendCondition <- NULL
[17:48:06.750]                   function(frame = 1L) {
[17:48:06.750]                     if (is.function(sendCondition)) 
[17:48:06.750]                       return(sendCondition)
[17:48:06.750]                     ns <- getNamespace("parallel")
[17:48:06.750]                     if (exists("sendData", mode = "function", 
[17:48:06.750]                       envir = ns)) {
[17:48:06.750]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:06.750]                         envir = ns)
[17:48:06.750]                       envir <- sys.frame(frame)
[17:48:06.750]                       master <- NULL
[17:48:06.750]                       while (!identical(envir, .GlobalEnv) && 
[17:48:06.750]                         !identical(envir, emptyenv())) {
[17:48:06.750]                         if (exists("master", mode = "list", envir = envir, 
[17:48:06.750]                           inherits = FALSE)) {
[17:48:06.750]                           master <- get("master", mode = "list", 
[17:48:06.750]                             envir = envir, inherits = FALSE)
[17:48:06.750]                           if (inherits(master, c("SOCKnode", 
[17:48:06.750]                             "SOCK0node"))) {
[17:48:06.750]                             sendCondition <<- function(cond) {
[17:48:06.750]                               data <- list(type = "VALUE", value = cond, 
[17:48:06.750]                                 success = TRUE)
[17:48:06.750]                               parallel_sendData(master, data)
[17:48:06.750]                             }
[17:48:06.750]                             return(sendCondition)
[17:48:06.750]                           }
[17:48:06.750]                         }
[17:48:06.750]                         frame <- frame + 1L
[17:48:06.750]                         envir <- sys.frame(frame)
[17:48:06.750]                       }
[17:48:06.750]                     }
[17:48:06.750]                     sendCondition <<- function(cond) NULL
[17:48:06.750]                   }
[17:48:06.750]                 })
[17:48:06.750]                 withCallingHandlers({
[17:48:06.750]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:06.750]                 }, immediateCondition = function(cond) {
[17:48:06.750]                   sendCondition <- ...future.makeSendCondition()
[17:48:06.750]                   sendCondition(cond)
[17:48:06.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.750]                   {
[17:48:06.750]                     inherits <- base::inherits
[17:48:06.750]                     invokeRestart <- base::invokeRestart
[17:48:06.750]                     is.null <- base::is.null
[17:48:06.750]                     muffled <- FALSE
[17:48:06.750]                     if (inherits(cond, "message")) {
[17:48:06.750]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:06.750]                       if (muffled) 
[17:48:06.750]                         invokeRestart("muffleMessage")
[17:48:06.750]                     }
[17:48:06.750]                     else if (inherits(cond, "warning")) {
[17:48:06.750]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:06.750]                       if (muffled) 
[17:48:06.750]                         invokeRestart("muffleWarning")
[17:48:06.750]                     }
[17:48:06.750]                     else if (inherits(cond, "condition")) {
[17:48:06.750]                       if (!is.null(pattern)) {
[17:48:06.750]                         computeRestarts <- base::computeRestarts
[17:48:06.750]                         grepl <- base::grepl
[17:48:06.750]                         restarts <- computeRestarts(cond)
[17:48:06.750]                         for (restart in restarts) {
[17:48:06.750]                           name <- restart$name
[17:48:06.750]                           if (is.null(name)) 
[17:48:06.750]                             next
[17:48:06.750]                           if (!grepl(pattern, name)) 
[17:48:06.750]                             next
[17:48:06.750]                           invokeRestart(restart)
[17:48:06.750]                           muffled <- TRUE
[17:48:06.750]                           break
[17:48:06.750]                         }
[17:48:06.750]                       }
[17:48:06.750]                     }
[17:48:06.750]                     invisible(muffled)
[17:48:06.750]                   }
[17:48:06.750]                   muffleCondition(cond)
[17:48:06.750]                 })
[17:48:06.750]             }))
[17:48:06.750]             future::FutureResult(value = ...future.value$value, 
[17:48:06.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.750]                   ...future.rng), globalenv = if (FALSE) 
[17:48:06.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:06.750]                     ...future.globalenv.names))
[17:48:06.750]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:06.750]         }, condition = base::local({
[17:48:06.750]             c <- base::c
[17:48:06.750]             inherits <- base::inherits
[17:48:06.750]             invokeRestart <- base::invokeRestart
[17:48:06.750]             length <- base::length
[17:48:06.750]             list <- base::list
[17:48:06.750]             seq.int <- base::seq.int
[17:48:06.750]             signalCondition <- base::signalCondition
[17:48:06.750]             sys.calls <- base::sys.calls
[17:48:06.750]             `[[` <- base::`[[`
[17:48:06.750]             `+` <- base::`+`
[17:48:06.750]             `<<-` <- base::`<<-`
[17:48:06.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:06.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:06.750]                   3L)]
[17:48:06.750]             }
[17:48:06.750]             function(cond) {
[17:48:06.750]                 is_error <- inherits(cond, "error")
[17:48:06.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:06.750]                   NULL)
[17:48:06.750]                 if (is_error) {
[17:48:06.750]                   sessionInformation <- function() {
[17:48:06.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:06.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:06.750]                       search = base::search(), system = base::Sys.info())
[17:48:06.750]                   }
[17:48:06.750]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:06.750]                     cond$call), session = sessionInformation(), 
[17:48:06.750]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:06.750]                   signalCondition(cond)
[17:48:06.750]                 }
[17:48:06.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:06.750]                 "immediateCondition"))) {
[17:48:06.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:06.750]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:06.750]                   if (TRUE && !signal) {
[17:48:06.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.750]                     {
[17:48:06.750]                       inherits <- base::inherits
[17:48:06.750]                       invokeRestart <- base::invokeRestart
[17:48:06.750]                       is.null <- base::is.null
[17:48:06.750]                       muffled <- FALSE
[17:48:06.750]                       if (inherits(cond, "message")) {
[17:48:06.750]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.750]                         if (muffled) 
[17:48:06.750]                           invokeRestart("muffleMessage")
[17:48:06.750]                       }
[17:48:06.750]                       else if (inherits(cond, "warning")) {
[17:48:06.750]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.750]                         if (muffled) 
[17:48:06.750]                           invokeRestart("muffleWarning")
[17:48:06.750]                       }
[17:48:06.750]                       else if (inherits(cond, "condition")) {
[17:48:06.750]                         if (!is.null(pattern)) {
[17:48:06.750]                           computeRestarts <- base::computeRestarts
[17:48:06.750]                           grepl <- base::grepl
[17:48:06.750]                           restarts <- computeRestarts(cond)
[17:48:06.750]                           for (restart in restarts) {
[17:48:06.750]                             name <- restart$name
[17:48:06.750]                             if (is.null(name)) 
[17:48:06.750]                               next
[17:48:06.750]                             if (!grepl(pattern, name)) 
[17:48:06.750]                               next
[17:48:06.750]                             invokeRestart(restart)
[17:48:06.750]                             muffled <- TRUE
[17:48:06.750]                             break
[17:48:06.750]                           }
[17:48:06.750]                         }
[17:48:06.750]                       }
[17:48:06.750]                       invisible(muffled)
[17:48:06.750]                     }
[17:48:06.750]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.750]                   }
[17:48:06.750]                 }
[17:48:06.750]                 else {
[17:48:06.750]                   if (TRUE) {
[17:48:06.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.750]                     {
[17:48:06.750]                       inherits <- base::inherits
[17:48:06.750]                       invokeRestart <- base::invokeRestart
[17:48:06.750]                       is.null <- base::is.null
[17:48:06.750]                       muffled <- FALSE
[17:48:06.750]                       if (inherits(cond, "message")) {
[17:48:06.750]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.750]                         if (muffled) 
[17:48:06.750]                           invokeRestart("muffleMessage")
[17:48:06.750]                       }
[17:48:06.750]                       else if (inherits(cond, "warning")) {
[17:48:06.750]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.750]                         if (muffled) 
[17:48:06.750]                           invokeRestart("muffleWarning")
[17:48:06.750]                       }
[17:48:06.750]                       else if (inherits(cond, "condition")) {
[17:48:06.750]                         if (!is.null(pattern)) {
[17:48:06.750]                           computeRestarts <- base::computeRestarts
[17:48:06.750]                           grepl <- base::grepl
[17:48:06.750]                           restarts <- computeRestarts(cond)
[17:48:06.750]                           for (restart in restarts) {
[17:48:06.750]                             name <- restart$name
[17:48:06.750]                             if (is.null(name)) 
[17:48:06.750]                               next
[17:48:06.750]                             if (!grepl(pattern, name)) 
[17:48:06.750]                               next
[17:48:06.750]                             invokeRestart(restart)
[17:48:06.750]                             muffled <- TRUE
[17:48:06.750]                             break
[17:48:06.750]                           }
[17:48:06.750]                         }
[17:48:06.750]                       }
[17:48:06.750]                       invisible(muffled)
[17:48:06.750]                     }
[17:48:06.750]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.750]                   }
[17:48:06.750]                 }
[17:48:06.750]             }
[17:48:06.750]         }))
[17:48:06.750]     }, error = function(ex) {
[17:48:06.750]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:06.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.750]                 ...future.rng), started = ...future.startTime, 
[17:48:06.750]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:06.750]             version = "1.8"), class = "FutureResult")
[17:48:06.750]     }, finally = {
[17:48:06.750]         if (!identical(...future.workdir, getwd())) 
[17:48:06.750]             setwd(...future.workdir)
[17:48:06.750]         {
[17:48:06.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:06.750]                 ...future.oldOptions$nwarnings <- NULL
[17:48:06.750]             }
[17:48:06.750]             base::options(...future.oldOptions)
[17:48:06.750]             if (.Platform$OS.type == "windows") {
[17:48:06.750]                 old_names <- names(...future.oldEnvVars)
[17:48:06.750]                 envs <- base::Sys.getenv()
[17:48:06.750]                 names <- names(envs)
[17:48:06.750]                 common <- intersect(names, old_names)
[17:48:06.750]                 added <- setdiff(names, old_names)
[17:48:06.750]                 removed <- setdiff(old_names, names)
[17:48:06.750]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:06.750]                   envs[common]]
[17:48:06.750]                 NAMES <- toupper(changed)
[17:48:06.750]                 args <- list()
[17:48:06.750]                 for (kk in seq_along(NAMES)) {
[17:48:06.750]                   name <- changed[[kk]]
[17:48:06.750]                   NAME <- NAMES[[kk]]
[17:48:06.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.750]                     next
[17:48:06.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.750]                 }
[17:48:06.750]                 NAMES <- toupper(added)
[17:48:06.750]                 for (kk in seq_along(NAMES)) {
[17:48:06.750]                   name <- added[[kk]]
[17:48:06.750]                   NAME <- NAMES[[kk]]
[17:48:06.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.750]                     next
[17:48:06.750]                   args[[name]] <- ""
[17:48:06.750]                 }
[17:48:06.750]                 NAMES <- toupper(removed)
[17:48:06.750]                 for (kk in seq_along(NAMES)) {
[17:48:06.750]                   name <- removed[[kk]]
[17:48:06.750]                   NAME <- NAMES[[kk]]
[17:48:06.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.750]                     next
[17:48:06.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.750]                 }
[17:48:06.750]                 if (length(args) > 0) 
[17:48:06.750]                   base::do.call(base::Sys.setenv, args = args)
[17:48:06.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:06.750]             }
[17:48:06.750]             else {
[17:48:06.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:06.750]             }
[17:48:06.750]             {
[17:48:06.750]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:06.750]                   0L) {
[17:48:06.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:06.750]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:06.750]                   base::options(opts)
[17:48:06.750]                 }
[17:48:06.750]                 {
[17:48:06.750]                   {
[17:48:06.750]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:06.750]                     NULL
[17:48:06.750]                   }
[17:48:06.750]                   options(future.plan = NULL)
[17:48:06.750]                   if (is.na(NA_character_)) 
[17:48:06.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:06.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:06.750]                     .init = FALSE)
[17:48:06.750]                 }
[17:48:06.750]             }
[17:48:06.750]         }
[17:48:06.750]     })
[17:48:06.750]     if (TRUE) {
[17:48:06.750]         base::sink(type = "output", split = FALSE)
[17:48:06.750]         if (TRUE) {
[17:48:06.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:06.750]         }
[17:48:06.750]         else {
[17:48:06.750]             ...future.result["stdout"] <- base::list(NULL)
[17:48:06.750]         }
[17:48:06.750]         base::close(...future.stdout)
[17:48:06.750]         ...future.stdout <- NULL
[17:48:06.750]     }
[17:48:06.750]     ...future.result$conditions <- ...future.conditions
[17:48:06.750]     ...future.result$finished <- base::Sys.time()
[17:48:06.750]     ...future.result
[17:48:06.750] }
[17:48:06.753] MultisessionFuture started
[17:48:06.753] - Launch lazy future ... done
[17:48:06.753] run() for ‘MultisessionFuture’ ... done
[17:48:06.755] receiveMessageFromWorker() for ClusterFuture ...
[17:48:06.755] - Validating connection of MultisessionFuture
[17:48:06.755] - received message: FutureResult
[17:48:06.756] - Received FutureResult
[17:48:06.756] - Erased future from FutureRegistry
[17:48:06.756] result() for ClusterFuture ...
[17:48:06.756] - result already collected: FutureResult
[17:48:06.756] result() for ClusterFuture ... done
[17:48:06.756] signalConditions() ...
[17:48:06.756]  - include = ‘immediateCondition’
[17:48:06.756]  - exclude = 
[17:48:06.756]  - resignal = FALSE
[17:48:06.756]  - Number of conditions: 1
[17:48:06.756] signalConditions() ... done
[17:48:06.756] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:06.757] A MultisessionFuture was resolved
[17:48:06.757] getGlobalsAndPackages() ...
[17:48:06.757] Searching for globals...
[17:48:06.757] - globals found: [2] ‘list’, ‘stop’
[17:48:06.757] Searching for globals ... DONE
[17:48:06.758] Resolving globals: FALSE
[17:48:06.758] 
[17:48:06.758] 
[17:48:06.758] getGlobalsAndPackages() ... DONE
[17:48:06.758] run() for ‘Future’ ...
[17:48:06.758] - state: ‘created’
[17:48:06.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:06.774] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:06.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:06.774]   - Field: ‘node’
[17:48:06.774]   - Field: ‘label’
[17:48:06.774]   - Field: ‘local’
[17:48:06.774]   - Field: ‘owner’
[17:48:06.774]   - Field: ‘envir’
[17:48:06.774]   - Field: ‘workers’
[17:48:06.775]   - Field: ‘packages’
[17:48:06.775]   - Field: ‘gc’
[17:48:06.775]   - Field: ‘conditions’
[17:48:06.775]   - Field: ‘persistent’
[17:48:06.775]   - Field: ‘expr’
[17:48:06.775]   - Field: ‘uuid’
[17:48:06.775]   - Field: ‘seed’
[17:48:06.775]   - Field: ‘version’
[17:48:06.775]   - Field: ‘result’
[17:48:06.775]   - Field: ‘asynchronous’
[17:48:06.775]   - Field: ‘calls’
[17:48:06.776]   - Field: ‘globals’
[17:48:06.776]   - Field: ‘stdout’
[17:48:06.776]   - Field: ‘earlySignal’
[17:48:06.776]   - Field: ‘lazy’
[17:48:06.776]   - Field: ‘state’
[17:48:06.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:06.776] - Launch lazy future ...
[17:48:06.776] Packages needed by the future expression (n = 0): <none>
[17:48:06.776] Packages needed by future strategies (n = 0): <none>
[17:48:06.777] {
[17:48:06.777]     {
[17:48:06.777]         {
[17:48:06.777]             ...future.startTime <- base::Sys.time()
[17:48:06.777]             {
[17:48:06.777]                 {
[17:48:06.777]                   {
[17:48:06.777]                     {
[17:48:06.777]                       base::local({
[17:48:06.777]                         has_future <- base::requireNamespace("future", 
[17:48:06.777]                           quietly = TRUE)
[17:48:06.777]                         if (has_future) {
[17:48:06.777]                           ns <- base::getNamespace("future")
[17:48:06.777]                           version <- ns[[".package"]][["version"]]
[17:48:06.777]                           if (is.null(version)) 
[17:48:06.777]                             version <- utils::packageVersion("future")
[17:48:06.777]                         }
[17:48:06.777]                         else {
[17:48:06.777]                           version <- NULL
[17:48:06.777]                         }
[17:48:06.777]                         if (!has_future || version < "1.8.0") {
[17:48:06.777]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:06.777]                             "", base::R.version$version.string), 
[17:48:06.777]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:06.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:06.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:06.777]                               "release", "version")], collapse = " "), 
[17:48:06.777]                             hostname = base::Sys.info()[["nodename"]])
[17:48:06.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:06.777]                             info)
[17:48:06.777]                           info <- base::paste(info, collapse = "; ")
[17:48:06.777]                           if (!has_future) {
[17:48:06.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:06.777]                               info)
[17:48:06.777]                           }
[17:48:06.777]                           else {
[17:48:06.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:06.777]                               info, version)
[17:48:06.777]                           }
[17:48:06.777]                           base::stop(msg)
[17:48:06.777]                         }
[17:48:06.777]                       })
[17:48:06.777]                     }
[17:48:06.777]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:06.777]                     base::options(mc.cores = 1L)
[17:48:06.777]                   }
[17:48:06.777]                   ...future.strategy.old <- future::plan("list")
[17:48:06.777]                   options(future.plan = NULL)
[17:48:06.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:06.777]                 }
[17:48:06.777]                 ...future.workdir <- getwd()
[17:48:06.777]             }
[17:48:06.777]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:06.777]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:06.777]         }
[17:48:06.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:06.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:06.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:06.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:06.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:06.777]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:06.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:06.777]             base::names(...future.oldOptions))
[17:48:06.777]     }
[17:48:06.777]     if (FALSE) {
[17:48:06.777]     }
[17:48:06.777]     else {
[17:48:06.777]         if (TRUE) {
[17:48:06.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:06.777]                 open = "w")
[17:48:06.777]         }
[17:48:06.777]         else {
[17:48:06.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:06.777]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:06.777]         }
[17:48:06.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:06.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:06.777]             base::sink(type = "output", split = FALSE)
[17:48:06.777]             base::close(...future.stdout)
[17:48:06.777]         }, add = TRUE)
[17:48:06.777]     }
[17:48:06.777]     ...future.frame <- base::sys.nframe()
[17:48:06.777]     ...future.conditions <- base::list()
[17:48:06.777]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:06.777]     if (FALSE) {
[17:48:06.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:06.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:06.777]     }
[17:48:06.777]     ...future.result <- base::tryCatch({
[17:48:06.777]         base::withCallingHandlers({
[17:48:06.777]             ...future.value <- base::withVisible(base::local({
[17:48:06.777]                 ...future.makeSendCondition <- base::local({
[17:48:06.777]                   sendCondition <- NULL
[17:48:06.777]                   function(frame = 1L) {
[17:48:06.777]                     if (is.function(sendCondition)) 
[17:48:06.777]                       return(sendCondition)
[17:48:06.777]                     ns <- getNamespace("parallel")
[17:48:06.777]                     if (exists("sendData", mode = "function", 
[17:48:06.777]                       envir = ns)) {
[17:48:06.777]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:06.777]                         envir = ns)
[17:48:06.777]                       envir <- sys.frame(frame)
[17:48:06.777]                       master <- NULL
[17:48:06.777]                       while (!identical(envir, .GlobalEnv) && 
[17:48:06.777]                         !identical(envir, emptyenv())) {
[17:48:06.777]                         if (exists("master", mode = "list", envir = envir, 
[17:48:06.777]                           inherits = FALSE)) {
[17:48:06.777]                           master <- get("master", mode = "list", 
[17:48:06.777]                             envir = envir, inherits = FALSE)
[17:48:06.777]                           if (inherits(master, c("SOCKnode", 
[17:48:06.777]                             "SOCK0node"))) {
[17:48:06.777]                             sendCondition <<- function(cond) {
[17:48:06.777]                               data <- list(type = "VALUE", value = cond, 
[17:48:06.777]                                 success = TRUE)
[17:48:06.777]                               parallel_sendData(master, data)
[17:48:06.777]                             }
[17:48:06.777]                             return(sendCondition)
[17:48:06.777]                           }
[17:48:06.777]                         }
[17:48:06.777]                         frame <- frame + 1L
[17:48:06.777]                         envir <- sys.frame(frame)
[17:48:06.777]                       }
[17:48:06.777]                     }
[17:48:06.777]                     sendCondition <<- function(cond) NULL
[17:48:06.777]                   }
[17:48:06.777]                 })
[17:48:06.777]                 withCallingHandlers({
[17:48:06.777]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:06.777]                 }, immediateCondition = function(cond) {
[17:48:06.777]                   sendCondition <- ...future.makeSendCondition()
[17:48:06.777]                   sendCondition(cond)
[17:48:06.777]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.777]                   {
[17:48:06.777]                     inherits <- base::inherits
[17:48:06.777]                     invokeRestart <- base::invokeRestart
[17:48:06.777]                     is.null <- base::is.null
[17:48:06.777]                     muffled <- FALSE
[17:48:06.777]                     if (inherits(cond, "message")) {
[17:48:06.777]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:06.777]                       if (muffled) 
[17:48:06.777]                         invokeRestart("muffleMessage")
[17:48:06.777]                     }
[17:48:06.777]                     else if (inherits(cond, "warning")) {
[17:48:06.777]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:06.777]                       if (muffled) 
[17:48:06.777]                         invokeRestart("muffleWarning")
[17:48:06.777]                     }
[17:48:06.777]                     else if (inherits(cond, "condition")) {
[17:48:06.777]                       if (!is.null(pattern)) {
[17:48:06.777]                         computeRestarts <- base::computeRestarts
[17:48:06.777]                         grepl <- base::grepl
[17:48:06.777]                         restarts <- computeRestarts(cond)
[17:48:06.777]                         for (restart in restarts) {
[17:48:06.777]                           name <- restart$name
[17:48:06.777]                           if (is.null(name)) 
[17:48:06.777]                             next
[17:48:06.777]                           if (!grepl(pattern, name)) 
[17:48:06.777]                             next
[17:48:06.777]                           invokeRestart(restart)
[17:48:06.777]                           muffled <- TRUE
[17:48:06.777]                           break
[17:48:06.777]                         }
[17:48:06.777]                       }
[17:48:06.777]                     }
[17:48:06.777]                     invisible(muffled)
[17:48:06.777]                   }
[17:48:06.777]                   muffleCondition(cond)
[17:48:06.777]                 })
[17:48:06.777]             }))
[17:48:06.777]             future::FutureResult(value = ...future.value$value, 
[17:48:06.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.777]                   ...future.rng), globalenv = if (FALSE) 
[17:48:06.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:06.777]                     ...future.globalenv.names))
[17:48:06.777]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:06.777]         }, condition = base::local({
[17:48:06.777]             c <- base::c
[17:48:06.777]             inherits <- base::inherits
[17:48:06.777]             invokeRestart <- base::invokeRestart
[17:48:06.777]             length <- base::length
[17:48:06.777]             list <- base::list
[17:48:06.777]             seq.int <- base::seq.int
[17:48:06.777]             signalCondition <- base::signalCondition
[17:48:06.777]             sys.calls <- base::sys.calls
[17:48:06.777]             `[[` <- base::`[[`
[17:48:06.777]             `+` <- base::`+`
[17:48:06.777]             `<<-` <- base::`<<-`
[17:48:06.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:06.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:06.777]                   3L)]
[17:48:06.777]             }
[17:48:06.777]             function(cond) {
[17:48:06.777]                 is_error <- inherits(cond, "error")
[17:48:06.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:06.777]                   NULL)
[17:48:06.777]                 if (is_error) {
[17:48:06.777]                   sessionInformation <- function() {
[17:48:06.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:06.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:06.777]                       search = base::search(), system = base::Sys.info())
[17:48:06.777]                   }
[17:48:06.777]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:06.777]                     cond$call), session = sessionInformation(), 
[17:48:06.777]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:06.777]                   signalCondition(cond)
[17:48:06.777]                 }
[17:48:06.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:06.777]                 "immediateCondition"))) {
[17:48:06.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:06.777]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:06.777]                   if (TRUE && !signal) {
[17:48:06.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.777]                     {
[17:48:06.777]                       inherits <- base::inherits
[17:48:06.777]                       invokeRestart <- base::invokeRestart
[17:48:06.777]                       is.null <- base::is.null
[17:48:06.777]                       muffled <- FALSE
[17:48:06.777]                       if (inherits(cond, "message")) {
[17:48:06.777]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.777]                         if (muffled) 
[17:48:06.777]                           invokeRestart("muffleMessage")
[17:48:06.777]                       }
[17:48:06.777]                       else if (inherits(cond, "warning")) {
[17:48:06.777]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.777]                         if (muffled) 
[17:48:06.777]                           invokeRestart("muffleWarning")
[17:48:06.777]                       }
[17:48:06.777]                       else if (inherits(cond, "condition")) {
[17:48:06.777]                         if (!is.null(pattern)) {
[17:48:06.777]                           computeRestarts <- base::computeRestarts
[17:48:06.777]                           grepl <- base::grepl
[17:48:06.777]                           restarts <- computeRestarts(cond)
[17:48:06.777]                           for (restart in restarts) {
[17:48:06.777]                             name <- restart$name
[17:48:06.777]                             if (is.null(name)) 
[17:48:06.777]                               next
[17:48:06.777]                             if (!grepl(pattern, name)) 
[17:48:06.777]                               next
[17:48:06.777]                             invokeRestart(restart)
[17:48:06.777]                             muffled <- TRUE
[17:48:06.777]                             break
[17:48:06.777]                           }
[17:48:06.777]                         }
[17:48:06.777]                       }
[17:48:06.777]                       invisible(muffled)
[17:48:06.777]                     }
[17:48:06.777]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.777]                   }
[17:48:06.777]                 }
[17:48:06.777]                 else {
[17:48:06.777]                   if (TRUE) {
[17:48:06.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.777]                     {
[17:48:06.777]                       inherits <- base::inherits
[17:48:06.777]                       invokeRestart <- base::invokeRestart
[17:48:06.777]                       is.null <- base::is.null
[17:48:06.777]                       muffled <- FALSE
[17:48:06.777]                       if (inherits(cond, "message")) {
[17:48:06.777]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.777]                         if (muffled) 
[17:48:06.777]                           invokeRestart("muffleMessage")
[17:48:06.777]                       }
[17:48:06.777]                       else if (inherits(cond, "warning")) {
[17:48:06.777]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.777]                         if (muffled) 
[17:48:06.777]                           invokeRestart("muffleWarning")
[17:48:06.777]                       }
[17:48:06.777]                       else if (inherits(cond, "condition")) {
[17:48:06.777]                         if (!is.null(pattern)) {
[17:48:06.777]                           computeRestarts <- base::computeRestarts
[17:48:06.777]                           grepl <- base::grepl
[17:48:06.777]                           restarts <- computeRestarts(cond)
[17:48:06.777]                           for (restart in restarts) {
[17:48:06.777]                             name <- restart$name
[17:48:06.777]                             if (is.null(name)) 
[17:48:06.777]                               next
[17:48:06.777]                             if (!grepl(pattern, name)) 
[17:48:06.777]                               next
[17:48:06.777]                             invokeRestart(restart)
[17:48:06.777]                             muffled <- TRUE
[17:48:06.777]                             break
[17:48:06.777]                           }
[17:48:06.777]                         }
[17:48:06.777]                       }
[17:48:06.777]                       invisible(muffled)
[17:48:06.777]                     }
[17:48:06.777]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.777]                   }
[17:48:06.777]                 }
[17:48:06.777]             }
[17:48:06.777]         }))
[17:48:06.777]     }, error = function(ex) {
[17:48:06.777]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:06.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.777]                 ...future.rng), started = ...future.startTime, 
[17:48:06.777]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:06.777]             version = "1.8"), class = "FutureResult")
[17:48:06.777]     }, finally = {
[17:48:06.777]         if (!identical(...future.workdir, getwd())) 
[17:48:06.777]             setwd(...future.workdir)
[17:48:06.777]         {
[17:48:06.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:06.777]                 ...future.oldOptions$nwarnings <- NULL
[17:48:06.777]             }
[17:48:06.777]             base::options(...future.oldOptions)
[17:48:06.777]             if (.Platform$OS.type == "windows") {
[17:48:06.777]                 old_names <- names(...future.oldEnvVars)
[17:48:06.777]                 envs <- base::Sys.getenv()
[17:48:06.777]                 names <- names(envs)
[17:48:06.777]                 common <- intersect(names, old_names)
[17:48:06.777]                 added <- setdiff(names, old_names)
[17:48:06.777]                 removed <- setdiff(old_names, names)
[17:48:06.777]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:06.777]                   envs[common]]
[17:48:06.777]                 NAMES <- toupper(changed)
[17:48:06.777]                 args <- list()
[17:48:06.777]                 for (kk in seq_along(NAMES)) {
[17:48:06.777]                   name <- changed[[kk]]
[17:48:06.777]                   NAME <- NAMES[[kk]]
[17:48:06.777]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.777]                     next
[17:48:06.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.777]                 }
[17:48:06.777]                 NAMES <- toupper(added)
[17:48:06.777]                 for (kk in seq_along(NAMES)) {
[17:48:06.777]                   name <- added[[kk]]
[17:48:06.777]                   NAME <- NAMES[[kk]]
[17:48:06.777]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.777]                     next
[17:48:06.777]                   args[[name]] <- ""
[17:48:06.777]                 }
[17:48:06.777]                 NAMES <- toupper(removed)
[17:48:06.777]                 for (kk in seq_along(NAMES)) {
[17:48:06.777]                   name <- removed[[kk]]
[17:48:06.777]                   NAME <- NAMES[[kk]]
[17:48:06.777]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.777]                     next
[17:48:06.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.777]                 }
[17:48:06.777]                 if (length(args) > 0) 
[17:48:06.777]                   base::do.call(base::Sys.setenv, args = args)
[17:48:06.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:06.777]             }
[17:48:06.777]             else {
[17:48:06.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:06.777]             }
[17:48:06.777]             {
[17:48:06.777]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:06.777]                   0L) {
[17:48:06.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:06.777]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:06.777]                   base::options(opts)
[17:48:06.777]                 }
[17:48:06.777]                 {
[17:48:06.777]                   {
[17:48:06.777]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:06.777]                     NULL
[17:48:06.777]                   }
[17:48:06.777]                   options(future.plan = NULL)
[17:48:06.777]                   if (is.na(NA_character_)) 
[17:48:06.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:06.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:06.777]                     .init = FALSE)
[17:48:06.777]                 }
[17:48:06.777]             }
[17:48:06.777]         }
[17:48:06.777]     })
[17:48:06.777]     if (TRUE) {
[17:48:06.777]         base::sink(type = "output", split = FALSE)
[17:48:06.777]         if (TRUE) {
[17:48:06.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:06.777]         }
[17:48:06.777]         else {
[17:48:06.777]             ...future.result["stdout"] <- base::list(NULL)
[17:48:06.777]         }
[17:48:06.777]         base::close(...future.stdout)
[17:48:06.777]         ...future.stdout <- NULL
[17:48:06.777]     }
[17:48:06.777]     ...future.result$conditions <- ...future.conditions
[17:48:06.777]     ...future.result$finished <- base::Sys.time()
[17:48:06.777]     ...future.result
[17:48:06.777] }
[17:48:06.780] MultisessionFuture started
[17:48:06.780] - Launch lazy future ... done
[17:48:06.780] run() for ‘MultisessionFuture’ ... done
[17:48:06.781] receiveMessageFromWorker() for ClusterFuture ...
[17:48:06.781] - Validating connection of MultisessionFuture
[17:48:06.782] - received message: FutureResult
[17:48:06.782] - Received FutureResult
[17:48:06.782] - Erased future from FutureRegistry
[17:48:06.782] result() for ClusterFuture ...
[17:48:06.782] - result already collected: FutureResult
[17:48:06.782] result() for ClusterFuture ... done
[17:48:06.782] signalConditions() ...
[17:48:06.782]  - include = ‘immediateCondition’
[17:48:06.782]  - exclude = 
[17:48:06.783]  - resignal = FALSE
[17:48:06.783]  - Number of conditions: 1
[17:48:06.783] signalConditions() ... done
[17:48:06.783] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:06.783] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[17:48:06.783] getGlobalsAndPackages() ...
[17:48:06.783] Searching for globals...
[17:48:06.784] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:06.784] Searching for globals ... DONE
[17:48:06.784] Resolving globals: FALSE
[17:48:06.785] 
[17:48:06.785] 
[17:48:06.785] getGlobalsAndPackages() ... DONE
[17:48:06.785] run() for ‘Future’ ...
[17:48:06.785] - state: ‘created’
[17:48:06.785] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:06.799] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:06.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:06.799]   - Field: ‘node’
[17:48:06.799]   - Field: ‘label’
[17:48:06.799]   - Field: ‘local’
[17:48:06.799]   - Field: ‘owner’
[17:48:06.799]   - Field: ‘envir’
[17:48:06.799]   - Field: ‘workers’
[17:48:06.799]   - Field: ‘packages’
[17:48:06.800]   - Field: ‘gc’
[17:48:06.800]   - Field: ‘conditions’
[17:48:06.800]   - Field: ‘persistent’
[17:48:06.800]   - Field: ‘expr’
[17:48:06.800]   - Field: ‘uuid’
[17:48:06.800]   - Field: ‘seed’
[17:48:06.800]   - Field: ‘version’
[17:48:06.800]   - Field: ‘result’
[17:48:06.800]   - Field: ‘asynchronous’
[17:48:06.800]   - Field: ‘calls’
[17:48:06.800]   - Field: ‘globals’
[17:48:06.801]   - Field: ‘stdout’
[17:48:06.801]   - Field: ‘earlySignal’
[17:48:06.801]   - Field: ‘lazy’
[17:48:06.801]   - Field: ‘state’
[17:48:06.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:06.801] - Launch lazy future ...
[17:48:06.801] Packages needed by the future expression (n = 0): <none>
[17:48:06.801] Packages needed by future strategies (n = 0): <none>
[17:48:06.802] {
[17:48:06.802]     {
[17:48:06.802]         {
[17:48:06.802]             ...future.startTime <- base::Sys.time()
[17:48:06.802]             {
[17:48:06.802]                 {
[17:48:06.802]                   {
[17:48:06.802]                     {
[17:48:06.802]                       base::local({
[17:48:06.802]                         has_future <- base::requireNamespace("future", 
[17:48:06.802]                           quietly = TRUE)
[17:48:06.802]                         if (has_future) {
[17:48:06.802]                           ns <- base::getNamespace("future")
[17:48:06.802]                           version <- ns[[".package"]][["version"]]
[17:48:06.802]                           if (is.null(version)) 
[17:48:06.802]                             version <- utils::packageVersion("future")
[17:48:06.802]                         }
[17:48:06.802]                         else {
[17:48:06.802]                           version <- NULL
[17:48:06.802]                         }
[17:48:06.802]                         if (!has_future || version < "1.8.0") {
[17:48:06.802]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:06.802]                             "", base::R.version$version.string), 
[17:48:06.802]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:06.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:06.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:06.802]                               "release", "version")], collapse = " "), 
[17:48:06.802]                             hostname = base::Sys.info()[["nodename"]])
[17:48:06.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:06.802]                             info)
[17:48:06.802]                           info <- base::paste(info, collapse = "; ")
[17:48:06.802]                           if (!has_future) {
[17:48:06.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:06.802]                               info)
[17:48:06.802]                           }
[17:48:06.802]                           else {
[17:48:06.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:06.802]                               info, version)
[17:48:06.802]                           }
[17:48:06.802]                           base::stop(msg)
[17:48:06.802]                         }
[17:48:06.802]                       })
[17:48:06.802]                     }
[17:48:06.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:06.802]                     base::options(mc.cores = 1L)
[17:48:06.802]                   }
[17:48:06.802]                   ...future.strategy.old <- future::plan("list")
[17:48:06.802]                   options(future.plan = NULL)
[17:48:06.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:06.802]                 }
[17:48:06.802]                 ...future.workdir <- getwd()
[17:48:06.802]             }
[17:48:06.802]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:06.802]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:06.802]         }
[17:48:06.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:06.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:06.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:06.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:06.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:06.802]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:06.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:06.802]             base::names(...future.oldOptions))
[17:48:06.802]     }
[17:48:06.802]     if (FALSE) {
[17:48:06.802]     }
[17:48:06.802]     else {
[17:48:06.802]         if (TRUE) {
[17:48:06.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:06.802]                 open = "w")
[17:48:06.802]         }
[17:48:06.802]         else {
[17:48:06.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:06.802]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:06.802]         }
[17:48:06.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:06.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:06.802]             base::sink(type = "output", split = FALSE)
[17:48:06.802]             base::close(...future.stdout)
[17:48:06.802]         }, add = TRUE)
[17:48:06.802]     }
[17:48:06.802]     ...future.frame <- base::sys.nframe()
[17:48:06.802]     ...future.conditions <- base::list()
[17:48:06.802]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:06.802]     if (FALSE) {
[17:48:06.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:06.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:06.802]     }
[17:48:06.802]     ...future.result <- base::tryCatch({
[17:48:06.802]         base::withCallingHandlers({
[17:48:06.802]             ...future.value <- base::withVisible(base::local({
[17:48:06.802]                 ...future.makeSendCondition <- base::local({
[17:48:06.802]                   sendCondition <- NULL
[17:48:06.802]                   function(frame = 1L) {
[17:48:06.802]                     if (is.function(sendCondition)) 
[17:48:06.802]                       return(sendCondition)
[17:48:06.802]                     ns <- getNamespace("parallel")
[17:48:06.802]                     if (exists("sendData", mode = "function", 
[17:48:06.802]                       envir = ns)) {
[17:48:06.802]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:06.802]                         envir = ns)
[17:48:06.802]                       envir <- sys.frame(frame)
[17:48:06.802]                       master <- NULL
[17:48:06.802]                       while (!identical(envir, .GlobalEnv) && 
[17:48:06.802]                         !identical(envir, emptyenv())) {
[17:48:06.802]                         if (exists("master", mode = "list", envir = envir, 
[17:48:06.802]                           inherits = FALSE)) {
[17:48:06.802]                           master <- get("master", mode = "list", 
[17:48:06.802]                             envir = envir, inherits = FALSE)
[17:48:06.802]                           if (inherits(master, c("SOCKnode", 
[17:48:06.802]                             "SOCK0node"))) {
[17:48:06.802]                             sendCondition <<- function(cond) {
[17:48:06.802]                               data <- list(type = "VALUE", value = cond, 
[17:48:06.802]                                 success = TRUE)
[17:48:06.802]                               parallel_sendData(master, data)
[17:48:06.802]                             }
[17:48:06.802]                             return(sendCondition)
[17:48:06.802]                           }
[17:48:06.802]                         }
[17:48:06.802]                         frame <- frame + 1L
[17:48:06.802]                         envir <- sys.frame(frame)
[17:48:06.802]                       }
[17:48:06.802]                     }
[17:48:06.802]                     sendCondition <<- function(cond) NULL
[17:48:06.802]                   }
[17:48:06.802]                 })
[17:48:06.802]                 withCallingHandlers({
[17:48:06.802]                   {
[17:48:06.802]                     Sys.sleep(0.5)
[17:48:06.802]                     list(a = 1, b = 42L)
[17:48:06.802]                   }
[17:48:06.802]                 }, immediateCondition = function(cond) {
[17:48:06.802]                   sendCondition <- ...future.makeSendCondition()
[17:48:06.802]                   sendCondition(cond)
[17:48:06.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.802]                   {
[17:48:06.802]                     inherits <- base::inherits
[17:48:06.802]                     invokeRestart <- base::invokeRestart
[17:48:06.802]                     is.null <- base::is.null
[17:48:06.802]                     muffled <- FALSE
[17:48:06.802]                     if (inherits(cond, "message")) {
[17:48:06.802]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:06.802]                       if (muffled) 
[17:48:06.802]                         invokeRestart("muffleMessage")
[17:48:06.802]                     }
[17:48:06.802]                     else if (inherits(cond, "warning")) {
[17:48:06.802]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:06.802]                       if (muffled) 
[17:48:06.802]                         invokeRestart("muffleWarning")
[17:48:06.802]                     }
[17:48:06.802]                     else if (inherits(cond, "condition")) {
[17:48:06.802]                       if (!is.null(pattern)) {
[17:48:06.802]                         computeRestarts <- base::computeRestarts
[17:48:06.802]                         grepl <- base::grepl
[17:48:06.802]                         restarts <- computeRestarts(cond)
[17:48:06.802]                         for (restart in restarts) {
[17:48:06.802]                           name <- restart$name
[17:48:06.802]                           if (is.null(name)) 
[17:48:06.802]                             next
[17:48:06.802]                           if (!grepl(pattern, name)) 
[17:48:06.802]                             next
[17:48:06.802]                           invokeRestart(restart)
[17:48:06.802]                           muffled <- TRUE
[17:48:06.802]                           break
[17:48:06.802]                         }
[17:48:06.802]                       }
[17:48:06.802]                     }
[17:48:06.802]                     invisible(muffled)
[17:48:06.802]                   }
[17:48:06.802]                   muffleCondition(cond)
[17:48:06.802]                 })
[17:48:06.802]             }))
[17:48:06.802]             future::FutureResult(value = ...future.value$value, 
[17:48:06.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.802]                   ...future.rng), globalenv = if (FALSE) 
[17:48:06.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:06.802]                     ...future.globalenv.names))
[17:48:06.802]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:06.802]         }, condition = base::local({
[17:48:06.802]             c <- base::c
[17:48:06.802]             inherits <- base::inherits
[17:48:06.802]             invokeRestart <- base::invokeRestart
[17:48:06.802]             length <- base::length
[17:48:06.802]             list <- base::list
[17:48:06.802]             seq.int <- base::seq.int
[17:48:06.802]             signalCondition <- base::signalCondition
[17:48:06.802]             sys.calls <- base::sys.calls
[17:48:06.802]             `[[` <- base::`[[`
[17:48:06.802]             `+` <- base::`+`
[17:48:06.802]             `<<-` <- base::`<<-`
[17:48:06.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:06.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:06.802]                   3L)]
[17:48:06.802]             }
[17:48:06.802]             function(cond) {
[17:48:06.802]                 is_error <- inherits(cond, "error")
[17:48:06.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:06.802]                   NULL)
[17:48:06.802]                 if (is_error) {
[17:48:06.802]                   sessionInformation <- function() {
[17:48:06.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:06.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:06.802]                       search = base::search(), system = base::Sys.info())
[17:48:06.802]                   }
[17:48:06.802]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:06.802]                     cond$call), session = sessionInformation(), 
[17:48:06.802]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:06.802]                   signalCondition(cond)
[17:48:06.802]                 }
[17:48:06.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:06.802]                 "immediateCondition"))) {
[17:48:06.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:06.802]                   ...future.conditions[[length(...future.conditions) + 
[17:48:06.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:06.802]                   if (TRUE && !signal) {
[17:48:06.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.802]                     {
[17:48:06.802]                       inherits <- base::inherits
[17:48:06.802]                       invokeRestart <- base::invokeRestart
[17:48:06.802]                       is.null <- base::is.null
[17:48:06.802]                       muffled <- FALSE
[17:48:06.802]                       if (inherits(cond, "message")) {
[17:48:06.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.802]                         if (muffled) 
[17:48:06.802]                           invokeRestart("muffleMessage")
[17:48:06.802]                       }
[17:48:06.802]                       else if (inherits(cond, "warning")) {
[17:48:06.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.802]                         if (muffled) 
[17:48:06.802]                           invokeRestart("muffleWarning")
[17:48:06.802]                       }
[17:48:06.802]                       else if (inherits(cond, "condition")) {
[17:48:06.802]                         if (!is.null(pattern)) {
[17:48:06.802]                           computeRestarts <- base::computeRestarts
[17:48:06.802]                           grepl <- base::grepl
[17:48:06.802]                           restarts <- computeRestarts(cond)
[17:48:06.802]                           for (restart in restarts) {
[17:48:06.802]                             name <- restart$name
[17:48:06.802]                             if (is.null(name)) 
[17:48:06.802]                               next
[17:48:06.802]                             if (!grepl(pattern, name)) 
[17:48:06.802]                               next
[17:48:06.802]                             invokeRestart(restart)
[17:48:06.802]                             muffled <- TRUE
[17:48:06.802]                             break
[17:48:06.802]                           }
[17:48:06.802]                         }
[17:48:06.802]                       }
[17:48:06.802]                       invisible(muffled)
[17:48:06.802]                     }
[17:48:06.802]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.802]                   }
[17:48:06.802]                 }
[17:48:06.802]                 else {
[17:48:06.802]                   if (TRUE) {
[17:48:06.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:06.802]                     {
[17:48:06.802]                       inherits <- base::inherits
[17:48:06.802]                       invokeRestart <- base::invokeRestart
[17:48:06.802]                       is.null <- base::is.null
[17:48:06.802]                       muffled <- FALSE
[17:48:06.802]                       if (inherits(cond, "message")) {
[17:48:06.802]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:06.802]                         if (muffled) 
[17:48:06.802]                           invokeRestart("muffleMessage")
[17:48:06.802]                       }
[17:48:06.802]                       else if (inherits(cond, "warning")) {
[17:48:06.802]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:06.802]                         if (muffled) 
[17:48:06.802]                           invokeRestart("muffleWarning")
[17:48:06.802]                       }
[17:48:06.802]                       else if (inherits(cond, "condition")) {
[17:48:06.802]                         if (!is.null(pattern)) {
[17:48:06.802]                           computeRestarts <- base::computeRestarts
[17:48:06.802]                           grepl <- base::grepl
[17:48:06.802]                           restarts <- computeRestarts(cond)
[17:48:06.802]                           for (restart in restarts) {
[17:48:06.802]                             name <- restart$name
[17:48:06.802]                             if (is.null(name)) 
[17:48:06.802]                               next
[17:48:06.802]                             if (!grepl(pattern, name)) 
[17:48:06.802]                               next
[17:48:06.802]                             invokeRestart(restart)
[17:48:06.802]                             muffled <- TRUE
[17:48:06.802]                             break
[17:48:06.802]                           }
[17:48:06.802]                         }
[17:48:06.802]                       }
[17:48:06.802]                       invisible(muffled)
[17:48:06.802]                     }
[17:48:06.802]                     muffleCondition(cond, pattern = "^muffle")
[17:48:06.802]                   }
[17:48:06.802]                 }
[17:48:06.802]             }
[17:48:06.802]         }))
[17:48:06.802]     }, error = function(ex) {
[17:48:06.802]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:06.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:06.802]                 ...future.rng), started = ...future.startTime, 
[17:48:06.802]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:06.802]             version = "1.8"), class = "FutureResult")
[17:48:06.802]     }, finally = {
[17:48:06.802]         if (!identical(...future.workdir, getwd())) 
[17:48:06.802]             setwd(...future.workdir)
[17:48:06.802]         {
[17:48:06.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:06.802]                 ...future.oldOptions$nwarnings <- NULL
[17:48:06.802]             }
[17:48:06.802]             base::options(...future.oldOptions)
[17:48:06.802]             if (.Platform$OS.type == "windows") {
[17:48:06.802]                 old_names <- names(...future.oldEnvVars)
[17:48:06.802]                 envs <- base::Sys.getenv()
[17:48:06.802]                 names <- names(envs)
[17:48:06.802]                 common <- intersect(names, old_names)
[17:48:06.802]                 added <- setdiff(names, old_names)
[17:48:06.802]                 removed <- setdiff(old_names, names)
[17:48:06.802]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:06.802]                   envs[common]]
[17:48:06.802]                 NAMES <- toupper(changed)
[17:48:06.802]                 args <- list()
[17:48:06.802]                 for (kk in seq_along(NAMES)) {
[17:48:06.802]                   name <- changed[[kk]]
[17:48:06.802]                   NAME <- NAMES[[kk]]
[17:48:06.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.802]                     next
[17:48:06.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.802]                 }
[17:48:06.802]                 NAMES <- toupper(added)
[17:48:06.802]                 for (kk in seq_along(NAMES)) {
[17:48:06.802]                   name <- added[[kk]]
[17:48:06.802]                   NAME <- NAMES[[kk]]
[17:48:06.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.802]                     next
[17:48:06.802]                   args[[name]] <- ""
[17:48:06.802]                 }
[17:48:06.802]                 NAMES <- toupper(removed)
[17:48:06.802]                 for (kk in seq_along(NAMES)) {
[17:48:06.802]                   name <- removed[[kk]]
[17:48:06.802]                   NAME <- NAMES[[kk]]
[17:48:06.802]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:06.802]                     next
[17:48:06.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:06.802]                 }
[17:48:06.802]                 if (length(args) > 0) 
[17:48:06.802]                   base::do.call(base::Sys.setenv, args = args)
[17:48:06.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:06.802]             }
[17:48:06.802]             else {
[17:48:06.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:06.802]             }
[17:48:06.802]             {
[17:48:06.802]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:06.802]                   0L) {
[17:48:06.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:06.802]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:06.802]                   base::options(opts)
[17:48:06.802]                 }
[17:48:06.802]                 {
[17:48:06.802]                   {
[17:48:06.802]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:06.802]                     NULL
[17:48:06.802]                   }
[17:48:06.802]                   options(future.plan = NULL)
[17:48:06.802]                   if (is.na(NA_character_)) 
[17:48:06.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:06.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:06.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:06.802]                     .init = FALSE)
[17:48:06.802]                 }
[17:48:06.802]             }
[17:48:06.802]         }
[17:48:06.802]     })
[17:48:06.802]     if (TRUE) {
[17:48:06.802]         base::sink(type = "output", split = FALSE)
[17:48:06.802]         if (TRUE) {
[17:48:06.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:06.802]         }
[17:48:06.802]         else {
[17:48:06.802]             ...future.result["stdout"] <- base::list(NULL)
[17:48:06.802]         }
[17:48:06.802]         base::close(...future.stdout)
[17:48:06.802]         ...future.stdout <- NULL
[17:48:06.802]     }
[17:48:06.802]     ...future.result$conditions <- ...future.conditions
[17:48:06.802]     ...future.result$finished <- base::Sys.time()
[17:48:06.802]     ...future.result
[17:48:06.802] }
[17:48:06.804] MultisessionFuture started
[17:48:06.805] - Launch lazy future ... done
[17:48:06.805] run() for ‘MultisessionFuture’ ... done
[17:48:07.307] receiveMessageFromWorker() for ClusterFuture ...
[17:48:07.307] - Validating connection of MultisessionFuture
[17:48:07.307] - received message: FutureResult
[17:48:07.307] - Received FutureResult
[17:48:07.308] - Erased future from FutureRegistry
[17:48:07.308] result() for ClusterFuture ...
[17:48:07.308] - result already collected: FutureResult
[17:48:07.308] result() for ClusterFuture ... done
[17:48:07.308] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:07.308] resolve() on list ...
[17:48:07.308]  recursive: 0
[17:48:07.308]  length: 2
[17:48:07.308]  elements: ‘a’, ‘b’
[17:48:07.309]  length: 1 (resolved future 1)
[17:48:07.309]  length: 0 (resolved future 2)
[17:48:07.309] resolve() on list ... DONE
[17:48:07.309] A MultisessionFuture was resolved (and resolved itself)
[17:48:07.309] getGlobalsAndPackages() ...
[17:48:07.309] Searching for globals...
[17:48:07.310] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:07.310] Searching for globals ... DONE
[17:48:07.310] Resolving globals: FALSE
[17:48:07.311] 
[17:48:07.311] 
[17:48:07.311] getGlobalsAndPackages() ... DONE
[17:48:07.311] run() for ‘Future’ ...
[17:48:07.311] - state: ‘created’
[17:48:07.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:07.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:07.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:07.325]   - Field: ‘node’
[17:48:07.326]   - Field: ‘label’
[17:48:07.326]   - Field: ‘local’
[17:48:07.326]   - Field: ‘owner’
[17:48:07.326]   - Field: ‘envir’
[17:48:07.326]   - Field: ‘workers’
[17:48:07.326]   - Field: ‘packages’
[17:48:07.326]   - Field: ‘gc’
[17:48:07.326]   - Field: ‘conditions’
[17:48:07.326]   - Field: ‘persistent’
[17:48:07.326]   - Field: ‘expr’
[17:48:07.326]   - Field: ‘uuid’
[17:48:07.327]   - Field: ‘seed’
[17:48:07.327]   - Field: ‘version’
[17:48:07.327]   - Field: ‘result’
[17:48:07.327]   - Field: ‘asynchronous’
[17:48:07.327]   - Field: ‘calls’
[17:48:07.327]   - Field: ‘globals’
[17:48:07.327]   - Field: ‘stdout’
[17:48:07.327]   - Field: ‘earlySignal’
[17:48:07.327]   - Field: ‘lazy’
[17:48:07.327]   - Field: ‘state’
[17:48:07.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:07.328] - Launch lazy future ...
[17:48:07.328] Packages needed by the future expression (n = 0): <none>
[17:48:07.328] Packages needed by future strategies (n = 0): <none>
[17:48:07.328] {
[17:48:07.328]     {
[17:48:07.328]         {
[17:48:07.328]             ...future.startTime <- base::Sys.time()
[17:48:07.328]             {
[17:48:07.328]                 {
[17:48:07.328]                   {
[17:48:07.328]                     {
[17:48:07.328]                       base::local({
[17:48:07.328]                         has_future <- base::requireNamespace("future", 
[17:48:07.328]                           quietly = TRUE)
[17:48:07.328]                         if (has_future) {
[17:48:07.328]                           ns <- base::getNamespace("future")
[17:48:07.328]                           version <- ns[[".package"]][["version"]]
[17:48:07.328]                           if (is.null(version)) 
[17:48:07.328]                             version <- utils::packageVersion("future")
[17:48:07.328]                         }
[17:48:07.328]                         else {
[17:48:07.328]                           version <- NULL
[17:48:07.328]                         }
[17:48:07.328]                         if (!has_future || version < "1.8.0") {
[17:48:07.328]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:07.328]                             "", base::R.version$version.string), 
[17:48:07.328]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:07.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:07.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:07.328]                               "release", "version")], collapse = " "), 
[17:48:07.328]                             hostname = base::Sys.info()[["nodename"]])
[17:48:07.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:07.328]                             info)
[17:48:07.328]                           info <- base::paste(info, collapse = "; ")
[17:48:07.328]                           if (!has_future) {
[17:48:07.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:07.328]                               info)
[17:48:07.328]                           }
[17:48:07.328]                           else {
[17:48:07.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:07.328]                               info, version)
[17:48:07.328]                           }
[17:48:07.328]                           base::stop(msg)
[17:48:07.328]                         }
[17:48:07.328]                       })
[17:48:07.328]                     }
[17:48:07.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:07.328]                     base::options(mc.cores = 1L)
[17:48:07.328]                   }
[17:48:07.328]                   ...future.strategy.old <- future::plan("list")
[17:48:07.328]                   options(future.plan = NULL)
[17:48:07.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:07.328]                 }
[17:48:07.328]                 ...future.workdir <- getwd()
[17:48:07.328]             }
[17:48:07.328]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:07.328]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:07.328]         }
[17:48:07.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:07.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:07.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:07.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:07.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:07.328]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:07.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:07.328]             base::names(...future.oldOptions))
[17:48:07.328]     }
[17:48:07.328]     if (FALSE) {
[17:48:07.328]     }
[17:48:07.328]     else {
[17:48:07.328]         if (TRUE) {
[17:48:07.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:07.328]                 open = "w")
[17:48:07.328]         }
[17:48:07.328]         else {
[17:48:07.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:07.328]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:07.328]         }
[17:48:07.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:07.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:07.328]             base::sink(type = "output", split = FALSE)
[17:48:07.328]             base::close(...future.stdout)
[17:48:07.328]         }, add = TRUE)
[17:48:07.328]     }
[17:48:07.328]     ...future.frame <- base::sys.nframe()
[17:48:07.328]     ...future.conditions <- base::list()
[17:48:07.328]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:07.328]     if (FALSE) {
[17:48:07.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:07.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:07.328]     }
[17:48:07.328]     ...future.result <- base::tryCatch({
[17:48:07.328]         base::withCallingHandlers({
[17:48:07.328]             ...future.value <- base::withVisible(base::local({
[17:48:07.328]                 ...future.makeSendCondition <- base::local({
[17:48:07.328]                   sendCondition <- NULL
[17:48:07.328]                   function(frame = 1L) {
[17:48:07.328]                     if (is.function(sendCondition)) 
[17:48:07.328]                       return(sendCondition)
[17:48:07.328]                     ns <- getNamespace("parallel")
[17:48:07.328]                     if (exists("sendData", mode = "function", 
[17:48:07.328]                       envir = ns)) {
[17:48:07.328]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:07.328]                         envir = ns)
[17:48:07.328]                       envir <- sys.frame(frame)
[17:48:07.328]                       master <- NULL
[17:48:07.328]                       while (!identical(envir, .GlobalEnv) && 
[17:48:07.328]                         !identical(envir, emptyenv())) {
[17:48:07.328]                         if (exists("master", mode = "list", envir = envir, 
[17:48:07.328]                           inherits = FALSE)) {
[17:48:07.328]                           master <- get("master", mode = "list", 
[17:48:07.328]                             envir = envir, inherits = FALSE)
[17:48:07.328]                           if (inherits(master, c("SOCKnode", 
[17:48:07.328]                             "SOCK0node"))) {
[17:48:07.328]                             sendCondition <<- function(cond) {
[17:48:07.328]                               data <- list(type = "VALUE", value = cond, 
[17:48:07.328]                                 success = TRUE)
[17:48:07.328]                               parallel_sendData(master, data)
[17:48:07.328]                             }
[17:48:07.328]                             return(sendCondition)
[17:48:07.328]                           }
[17:48:07.328]                         }
[17:48:07.328]                         frame <- frame + 1L
[17:48:07.328]                         envir <- sys.frame(frame)
[17:48:07.328]                       }
[17:48:07.328]                     }
[17:48:07.328]                     sendCondition <<- function(cond) NULL
[17:48:07.328]                   }
[17:48:07.328]                 })
[17:48:07.328]                 withCallingHandlers({
[17:48:07.328]                   {
[17:48:07.328]                     Sys.sleep(0.5)
[17:48:07.328]                     list(a = 1, b = 42L)
[17:48:07.328]                   }
[17:48:07.328]                 }, immediateCondition = function(cond) {
[17:48:07.328]                   sendCondition <- ...future.makeSendCondition()
[17:48:07.328]                   sendCondition(cond)
[17:48:07.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.328]                   {
[17:48:07.328]                     inherits <- base::inherits
[17:48:07.328]                     invokeRestart <- base::invokeRestart
[17:48:07.328]                     is.null <- base::is.null
[17:48:07.328]                     muffled <- FALSE
[17:48:07.328]                     if (inherits(cond, "message")) {
[17:48:07.328]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:07.328]                       if (muffled) 
[17:48:07.328]                         invokeRestart("muffleMessage")
[17:48:07.328]                     }
[17:48:07.328]                     else if (inherits(cond, "warning")) {
[17:48:07.328]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:07.328]                       if (muffled) 
[17:48:07.328]                         invokeRestart("muffleWarning")
[17:48:07.328]                     }
[17:48:07.328]                     else if (inherits(cond, "condition")) {
[17:48:07.328]                       if (!is.null(pattern)) {
[17:48:07.328]                         computeRestarts <- base::computeRestarts
[17:48:07.328]                         grepl <- base::grepl
[17:48:07.328]                         restarts <- computeRestarts(cond)
[17:48:07.328]                         for (restart in restarts) {
[17:48:07.328]                           name <- restart$name
[17:48:07.328]                           if (is.null(name)) 
[17:48:07.328]                             next
[17:48:07.328]                           if (!grepl(pattern, name)) 
[17:48:07.328]                             next
[17:48:07.328]                           invokeRestart(restart)
[17:48:07.328]                           muffled <- TRUE
[17:48:07.328]                           break
[17:48:07.328]                         }
[17:48:07.328]                       }
[17:48:07.328]                     }
[17:48:07.328]                     invisible(muffled)
[17:48:07.328]                   }
[17:48:07.328]                   muffleCondition(cond)
[17:48:07.328]                 })
[17:48:07.328]             }))
[17:48:07.328]             future::FutureResult(value = ...future.value$value, 
[17:48:07.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.328]                   ...future.rng), globalenv = if (FALSE) 
[17:48:07.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:07.328]                     ...future.globalenv.names))
[17:48:07.328]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:07.328]         }, condition = base::local({
[17:48:07.328]             c <- base::c
[17:48:07.328]             inherits <- base::inherits
[17:48:07.328]             invokeRestart <- base::invokeRestart
[17:48:07.328]             length <- base::length
[17:48:07.328]             list <- base::list
[17:48:07.328]             seq.int <- base::seq.int
[17:48:07.328]             signalCondition <- base::signalCondition
[17:48:07.328]             sys.calls <- base::sys.calls
[17:48:07.328]             `[[` <- base::`[[`
[17:48:07.328]             `+` <- base::`+`
[17:48:07.328]             `<<-` <- base::`<<-`
[17:48:07.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:07.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:07.328]                   3L)]
[17:48:07.328]             }
[17:48:07.328]             function(cond) {
[17:48:07.328]                 is_error <- inherits(cond, "error")
[17:48:07.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:07.328]                   NULL)
[17:48:07.328]                 if (is_error) {
[17:48:07.328]                   sessionInformation <- function() {
[17:48:07.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:07.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:07.328]                       search = base::search(), system = base::Sys.info())
[17:48:07.328]                   }
[17:48:07.328]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:07.328]                     cond$call), session = sessionInformation(), 
[17:48:07.328]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:07.328]                   signalCondition(cond)
[17:48:07.328]                 }
[17:48:07.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:07.328]                 "immediateCondition"))) {
[17:48:07.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:07.328]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:07.328]                   if (TRUE && !signal) {
[17:48:07.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.328]                     {
[17:48:07.328]                       inherits <- base::inherits
[17:48:07.328]                       invokeRestart <- base::invokeRestart
[17:48:07.328]                       is.null <- base::is.null
[17:48:07.328]                       muffled <- FALSE
[17:48:07.328]                       if (inherits(cond, "message")) {
[17:48:07.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.328]                         if (muffled) 
[17:48:07.328]                           invokeRestart("muffleMessage")
[17:48:07.328]                       }
[17:48:07.328]                       else if (inherits(cond, "warning")) {
[17:48:07.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.328]                         if (muffled) 
[17:48:07.328]                           invokeRestart("muffleWarning")
[17:48:07.328]                       }
[17:48:07.328]                       else if (inherits(cond, "condition")) {
[17:48:07.328]                         if (!is.null(pattern)) {
[17:48:07.328]                           computeRestarts <- base::computeRestarts
[17:48:07.328]                           grepl <- base::grepl
[17:48:07.328]                           restarts <- computeRestarts(cond)
[17:48:07.328]                           for (restart in restarts) {
[17:48:07.328]                             name <- restart$name
[17:48:07.328]                             if (is.null(name)) 
[17:48:07.328]                               next
[17:48:07.328]                             if (!grepl(pattern, name)) 
[17:48:07.328]                               next
[17:48:07.328]                             invokeRestart(restart)
[17:48:07.328]                             muffled <- TRUE
[17:48:07.328]                             break
[17:48:07.328]                           }
[17:48:07.328]                         }
[17:48:07.328]                       }
[17:48:07.328]                       invisible(muffled)
[17:48:07.328]                     }
[17:48:07.328]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.328]                   }
[17:48:07.328]                 }
[17:48:07.328]                 else {
[17:48:07.328]                   if (TRUE) {
[17:48:07.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.328]                     {
[17:48:07.328]                       inherits <- base::inherits
[17:48:07.328]                       invokeRestart <- base::invokeRestart
[17:48:07.328]                       is.null <- base::is.null
[17:48:07.328]                       muffled <- FALSE
[17:48:07.328]                       if (inherits(cond, "message")) {
[17:48:07.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.328]                         if (muffled) 
[17:48:07.328]                           invokeRestart("muffleMessage")
[17:48:07.328]                       }
[17:48:07.328]                       else if (inherits(cond, "warning")) {
[17:48:07.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.328]                         if (muffled) 
[17:48:07.328]                           invokeRestart("muffleWarning")
[17:48:07.328]                       }
[17:48:07.328]                       else if (inherits(cond, "condition")) {
[17:48:07.328]                         if (!is.null(pattern)) {
[17:48:07.328]                           computeRestarts <- base::computeRestarts
[17:48:07.328]                           grepl <- base::grepl
[17:48:07.328]                           restarts <- computeRestarts(cond)
[17:48:07.328]                           for (restart in restarts) {
[17:48:07.328]                             name <- restart$name
[17:48:07.328]                             if (is.null(name)) 
[17:48:07.328]                               next
[17:48:07.328]                             if (!grepl(pattern, name)) 
[17:48:07.328]                               next
[17:48:07.328]                             invokeRestart(restart)
[17:48:07.328]                             muffled <- TRUE
[17:48:07.328]                             break
[17:48:07.328]                           }
[17:48:07.328]                         }
[17:48:07.328]                       }
[17:48:07.328]                       invisible(muffled)
[17:48:07.328]                     }
[17:48:07.328]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.328]                   }
[17:48:07.328]                 }
[17:48:07.328]             }
[17:48:07.328]         }))
[17:48:07.328]     }, error = function(ex) {
[17:48:07.328]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:07.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.328]                 ...future.rng), started = ...future.startTime, 
[17:48:07.328]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:07.328]             version = "1.8"), class = "FutureResult")
[17:48:07.328]     }, finally = {
[17:48:07.328]         if (!identical(...future.workdir, getwd())) 
[17:48:07.328]             setwd(...future.workdir)
[17:48:07.328]         {
[17:48:07.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:07.328]                 ...future.oldOptions$nwarnings <- NULL
[17:48:07.328]             }
[17:48:07.328]             base::options(...future.oldOptions)
[17:48:07.328]             if (.Platform$OS.type == "windows") {
[17:48:07.328]                 old_names <- names(...future.oldEnvVars)
[17:48:07.328]                 envs <- base::Sys.getenv()
[17:48:07.328]                 names <- names(envs)
[17:48:07.328]                 common <- intersect(names, old_names)
[17:48:07.328]                 added <- setdiff(names, old_names)
[17:48:07.328]                 removed <- setdiff(old_names, names)
[17:48:07.328]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:07.328]                   envs[common]]
[17:48:07.328]                 NAMES <- toupper(changed)
[17:48:07.328]                 args <- list()
[17:48:07.328]                 for (kk in seq_along(NAMES)) {
[17:48:07.328]                   name <- changed[[kk]]
[17:48:07.328]                   NAME <- NAMES[[kk]]
[17:48:07.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.328]                     next
[17:48:07.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.328]                 }
[17:48:07.328]                 NAMES <- toupper(added)
[17:48:07.328]                 for (kk in seq_along(NAMES)) {
[17:48:07.328]                   name <- added[[kk]]
[17:48:07.328]                   NAME <- NAMES[[kk]]
[17:48:07.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.328]                     next
[17:48:07.328]                   args[[name]] <- ""
[17:48:07.328]                 }
[17:48:07.328]                 NAMES <- toupper(removed)
[17:48:07.328]                 for (kk in seq_along(NAMES)) {
[17:48:07.328]                   name <- removed[[kk]]
[17:48:07.328]                   NAME <- NAMES[[kk]]
[17:48:07.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.328]                     next
[17:48:07.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.328]                 }
[17:48:07.328]                 if (length(args) > 0) 
[17:48:07.328]                   base::do.call(base::Sys.setenv, args = args)
[17:48:07.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:07.328]             }
[17:48:07.328]             else {
[17:48:07.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:07.328]             }
[17:48:07.328]             {
[17:48:07.328]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:07.328]                   0L) {
[17:48:07.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:07.328]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:07.328]                   base::options(opts)
[17:48:07.328]                 }
[17:48:07.328]                 {
[17:48:07.328]                   {
[17:48:07.328]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:07.328]                     NULL
[17:48:07.328]                   }
[17:48:07.328]                   options(future.plan = NULL)
[17:48:07.328]                   if (is.na(NA_character_)) 
[17:48:07.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:07.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:07.328]                     .init = FALSE)
[17:48:07.328]                 }
[17:48:07.328]             }
[17:48:07.328]         }
[17:48:07.328]     })
[17:48:07.328]     if (TRUE) {
[17:48:07.328]         base::sink(type = "output", split = FALSE)
[17:48:07.328]         if (TRUE) {
[17:48:07.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:07.328]         }
[17:48:07.328]         else {
[17:48:07.328]             ...future.result["stdout"] <- base::list(NULL)
[17:48:07.328]         }
[17:48:07.328]         base::close(...future.stdout)
[17:48:07.328]         ...future.stdout <- NULL
[17:48:07.328]     }
[17:48:07.328]     ...future.result$conditions <- ...future.conditions
[17:48:07.328]     ...future.result$finished <- base::Sys.time()
[17:48:07.328]     ...future.result
[17:48:07.328] }
[17:48:07.331] MultisessionFuture started
[17:48:07.331] - Launch lazy future ... done
[17:48:07.332] run() for ‘MultisessionFuture’ ... done
[17:48:07.834] receiveMessageFromWorker() for ClusterFuture ...
[17:48:07.834] - Validating connection of MultisessionFuture
[17:48:07.834] - received message: FutureResult
[17:48:07.834] - Received FutureResult
[17:48:07.835] - Erased future from FutureRegistry
[17:48:07.835] result() for ClusterFuture ...
[17:48:07.835] - result already collected: FutureResult
[17:48:07.835] result() for ClusterFuture ... done
[17:48:07.835] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:07.835] resolve() on list ...
[17:48:07.835]  recursive: 0
[17:48:07.835]  length: 2
[17:48:07.835]  elements: ‘a’, ‘b’
[17:48:07.836]  length: 1 (resolved future 1)
[17:48:07.836]  length: 0 (resolved future 2)
[17:48:07.836] resolve() on list ... DONE
[17:48:07.836] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:48:07.836] getGlobalsAndPackages() ...
[17:48:07.836] Searching for globals...
[17:48:07.837] - globals found: [2] ‘list’, ‘stop’
[17:48:07.837] Searching for globals ... DONE
[17:48:07.837] Resolving globals: FALSE
[17:48:07.837] 
[17:48:07.837] 
[17:48:07.837] getGlobalsAndPackages() ... DONE
[17:48:07.838] run() for ‘Future’ ...
[17:48:07.838] - state: ‘created’
[17:48:07.838] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:07.861] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:07.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:07.861]   - Field: ‘node’
[17:48:07.861]   - Field: ‘label’
[17:48:07.861]   - Field: ‘local’
[17:48:07.861]   - Field: ‘owner’
[17:48:07.861]   - Field: ‘envir’
[17:48:07.861]   - Field: ‘workers’
[17:48:07.861]   - Field: ‘packages’
[17:48:07.862]   - Field: ‘gc’
[17:48:07.862]   - Field: ‘conditions’
[17:48:07.862]   - Field: ‘persistent’
[17:48:07.862]   - Field: ‘expr’
[17:48:07.862]   - Field: ‘uuid’
[17:48:07.862]   - Field: ‘seed’
[17:48:07.862]   - Field: ‘version’
[17:48:07.862]   - Field: ‘result’
[17:48:07.862]   - Field: ‘asynchronous’
[17:48:07.862]   - Field: ‘calls’
[17:48:07.862]   - Field: ‘globals’
[17:48:07.863]   - Field: ‘stdout’
[17:48:07.863]   - Field: ‘earlySignal’
[17:48:07.863]   - Field: ‘lazy’
[17:48:07.863]   - Field: ‘state’
[17:48:07.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:07.863] - Launch lazy future ...
[17:48:07.863] Packages needed by the future expression (n = 0): <none>
[17:48:07.863] Packages needed by future strategies (n = 0): <none>
[17:48:07.864] {
[17:48:07.864]     {
[17:48:07.864]         {
[17:48:07.864]             ...future.startTime <- base::Sys.time()
[17:48:07.864]             {
[17:48:07.864]                 {
[17:48:07.864]                   {
[17:48:07.864]                     {
[17:48:07.864]                       base::local({
[17:48:07.864]                         has_future <- base::requireNamespace("future", 
[17:48:07.864]                           quietly = TRUE)
[17:48:07.864]                         if (has_future) {
[17:48:07.864]                           ns <- base::getNamespace("future")
[17:48:07.864]                           version <- ns[[".package"]][["version"]]
[17:48:07.864]                           if (is.null(version)) 
[17:48:07.864]                             version <- utils::packageVersion("future")
[17:48:07.864]                         }
[17:48:07.864]                         else {
[17:48:07.864]                           version <- NULL
[17:48:07.864]                         }
[17:48:07.864]                         if (!has_future || version < "1.8.0") {
[17:48:07.864]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:07.864]                             "", base::R.version$version.string), 
[17:48:07.864]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:07.864]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:07.864]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:07.864]                               "release", "version")], collapse = " "), 
[17:48:07.864]                             hostname = base::Sys.info()[["nodename"]])
[17:48:07.864]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:07.864]                             info)
[17:48:07.864]                           info <- base::paste(info, collapse = "; ")
[17:48:07.864]                           if (!has_future) {
[17:48:07.864]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:07.864]                               info)
[17:48:07.864]                           }
[17:48:07.864]                           else {
[17:48:07.864]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:07.864]                               info, version)
[17:48:07.864]                           }
[17:48:07.864]                           base::stop(msg)
[17:48:07.864]                         }
[17:48:07.864]                       })
[17:48:07.864]                     }
[17:48:07.864]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:07.864]                     base::options(mc.cores = 1L)
[17:48:07.864]                   }
[17:48:07.864]                   ...future.strategy.old <- future::plan("list")
[17:48:07.864]                   options(future.plan = NULL)
[17:48:07.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:07.864]                 }
[17:48:07.864]                 ...future.workdir <- getwd()
[17:48:07.864]             }
[17:48:07.864]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:07.864]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:07.864]         }
[17:48:07.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:07.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:07.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:07.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:07.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:07.864]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:07.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:07.864]             base::names(...future.oldOptions))
[17:48:07.864]     }
[17:48:07.864]     if (FALSE) {
[17:48:07.864]     }
[17:48:07.864]     else {
[17:48:07.864]         if (TRUE) {
[17:48:07.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:07.864]                 open = "w")
[17:48:07.864]         }
[17:48:07.864]         else {
[17:48:07.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:07.864]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:07.864]         }
[17:48:07.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:07.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:07.864]             base::sink(type = "output", split = FALSE)
[17:48:07.864]             base::close(...future.stdout)
[17:48:07.864]         }, add = TRUE)
[17:48:07.864]     }
[17:48:07.864]     ...future.frame <- base::sys.nframe()
[17:48:07.864]     ...future.conditions <- base::list()
[17:48:07.864]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:07.864]     if (FALSE) {
[17:48:07.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:07.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:07.864]     }
[17:48:07.864]     ...future.result <- base::tryCatch({
[17:48:07.864]         base::withCallingHandlers({
[17:48:07.864]             ...future.value <- base::withVisible(base::local({
[17:48:07.864]                 ...future.makeSendCondition <- base::local({
[17:48:07.864]                   sendCondition <- NULL
[17:48:07.864]                   function(frame = 1L) {
[17:48:07.864]                     if (is.function(sendCondition)) 
[17:48:07.864]                       return(sendCondition)
[17:48:07.864]                     ns <- getNamespace("parallel")
[17:48:07.864]                     if (exists("sendData", mode = "function", 
[17:48:07.864]                       envir = ns)) {
[17:48:07.864]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:07.864]                         envir = ns)
[17:48:07.864]                       envir <- sys.frame(frame)
[17:48:07.864]                       master <- NULL
[17:48:07.864]                       while (!identical(envir, .GlobalEnv) && 
[17:48:07.864]                         !identical(envir, emptyenv())) {
[17:48:07.864]                         if (exists("master", mode = "list", envir = envir, 
[17:48:07.864]                           inherits = FALSE)) {
[17:48:07.864]                           master <- get("master", mode = "list", 
[17:48:07.864]                             envir = envir, inherits = FALSE)
[17:48:07.864]                           if (inherits(master, c("SOCKnode", 
[17:48:07.864]                             "SOCK0node"))) {
[17:48:07.864]                             sendCondition <<- function(cond) {
[17:48:07.864]                               data <- list(type = "VALUE", value = cond, 
[17:48:07.864]                                 success = TRUE)
[17:48:07.864]                               parallel_sendData(master, data)
[17:48:07.864]                             }
[17:48:07.864]                             return(sendCondition)
[17:48:07.864]                           }
[17:48:07.864]                         }
[17:48:07.864]                         frame <- frame + 1L
[17:48:07.864]                         envir <- sys.frame(frame)
[17:48:07.864]                       }
[17:48:07.864]                     }
[17:48:07.864]                     sendCondition <<- function(cond) NULL
[17:48:07.864]                   }
[17:48:07.864]                 })
[17:48:07.864]                 withCallingHandlers({
[17:48:07.864]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:07.864]                 }, immediateCondition = function(cond) {
[17:48:07.864]                   sendCondition <- ...future.makeSendCondition()
[17:48:07.864]                   sendCondition(cond)
[17:48:07.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.864]                   {
[17:48:07.864]                     inherits <- base::inherits
[17:48:07.864]                     invokeRestart <- base::invokeRestart
[17:48:07.864]                     is.null <- base::is.null
[17:48:07.864]                     muffled <- FALSE
[17:48:07.864]                     if (inherits(cond, "message")) {
[17:48:07.864]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:07.864]                       if (muffled) 
[17:48:07.864]                         invokeRestart("muffleMessage")
[17:48:07.864]                     }
[17:48:07.864]                     else if (inherits(cond, "warning")) {
[17:48:07.864]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:07.864]                       if (muffled) 
[17:48:07.864]                         invokeRestart("muffleWarning")
[17:48:07.864]                     }
[17:48:07.864]                     else if (inherits(cond, "condition")) {
[17:48:07.864]                       if (!is.null(pattern)) {
[17:48:07.864]                         computeRestarts <- base::computeRestarts
[17:48:07.864]                         grepl <- base::grepl
[17:48:07.864]                         restarts <- computeRestarts(cond)
[17:48:07.864]                         for (restart in restarts) {
[17:48:07.864]                           name <- restart$name
[17:48:07.864]                           if (is.null(name)) 
[17:48:07.864]                             next
[17:48:07.864]                           if (!grepl(pattern, name)) 
[17:48:07.864]                             next
[17:48:07.864]                           invokeRestart(restart)
[17:48:07.864]                           muffled <- TRUE
[17:48:07.864]                           break
[17:48:07.864]                         }
[17:48:07.864]                       }
[17:48:07.864]                     }
[17:48:07.864]                     invisible(muffled)
[17:48:07.864]                   }
[17:48:07.864]                   muffleCondition(cond)
[17:48:07.864]                 })
[17:48:07.864]             }))
[17:48:07.864]             future::FutureResult(value = ...future.value$value, 
[17:48:07.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.864]                   ...future.rng), globalenv = if (FALSE) 
[17:48:07.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:07.864]                     ...future.globalenv.names))
[17:48:07.864]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:07.864]         }, condition = base::local({
[17:48:07.864]             c <- base::c
[17:48:07.864]             inherits <- base::inherits
[17:48:07.864]             invokeRestart <- base::invokeRestart
[17:48:07.864]             length <- base::length
[17:48:07.864]             list <- base::list
[17:48:07.864]             seq.int <- base::seq.int
[17:48:07.864]             signalCondition <- base::signalCondition
[17:48:07.864]             sys.calls <- base::sys.calls
[17:48:07.864]             `[[` <- base::`[[`
[17:48:07.864]             `+` <- base::`+`
[17:48:07.864]             `<<-` <- base::`<<-`
[17:48:07.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:07.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:07.864]                   3L)]
[17:48:07.864]             }
[17:48:07.864]             function(cond) {
[17:48:07.864]                 is_error <- inherits(cond, "error")
[17:48:07.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:07.864]                   NULL)
[17:48:07.864]                 if (is_error) {
[17:48:07.864]                   sessionInformation <- function() {
[17:48:07.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:07.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:07.864]                       search = base::search(), system = base::Sys.info())
[17:48:07.864]                   }
[17:48:07.864]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:07.864]                     cond$call), session = sessionInformation(), 
[17:48:07.864]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:07.864]                   signalCondition(cond)
[17:48:07.864]                 }
[17:48:07.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:07.864]                 "immediateCondition"))) {
[17:48:07.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:07.864]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:07.864]                   if (TRUE && !signal) {
[17:48:07.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.864]                     {
[17:48:07.864]                       inherits <- base::inherits
[17:48:07.864]                       invokeRestart <- base::invokeRestart
[17:48:07.864]                       is.null <- base::is.null
[17:48:07.864]                       muffled <- FALSE
[17:48:07.864]                       if (inherits(cond, "message")) {
[17:48:07.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.864]                         if (muffled) 
[17:48:07.864]                           invokeRestart("muffleMessage")
[17:48:07.864]                       }
[17:48:07.864]                       else if (inherits(cond, "warning")) {
[17:48:07.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.864]                         if (muffled) 
[17:48:07.864]                           invokeRestart("muffleWarning")
[17:48:07.864]                       }
[17:48:07.864]                       else if (inherits(cond, "condition")) {
[17:48:07.864]                         if (!is.null(pattern)) {
[17:48:07.864]                           computeRestarts <- base::computeRestarts
[17:48:07.864]                           grepl <- base::grepl
[17:48:07.864]                           restarts <- computeRestarts(cond)
[17:48:07.864]                           for (restart in restarts) {
[17:48:07.864]                             name <- restart$name
[17:48:07.864]                             if (is.null(name)) 
[17:48:07.864]                               next
[17:48:07.864]                             if (!grepl(pattern, name)) 
[17:48:07.864]                               next
[17:48:07.864]                             invokeRestart(restart)
[17:48:07.864]                             muffled <- TRUE
[17:48:07.864]                             break
[17:48:07.864]                           }
[17:48:07.864]                         }
[17:48:07.864]                       }
[17:48:07.864]                       invisible(muffled)
[17:48:07.864]                     }
[17:48:07.864]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.864]                   }
[17:48:07.864]                 }
[17:48:07.864]                 else {
[17:48:07.864]                   if (TRUE) {
[17:48:07.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.864]                     {
[17:48:07.864]                       inherits <- base::inherits
[17:48:07.864]                       invokeRestart <- base::invokeRestart
[17:48:07.864]                       is.null <- base::is.null
[17:48:07.864]                       muffled <- FALSE
[17:48:07.864]                       if (inherits(cond, "message")) {
[17:48:07.864]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.864]                         if (muffled) 
[17:48:07.864]                           invokeRestart("muffleMessage")
[17:48:07.864]                       }
[17:48:07.864]                       else if (inherits(cond, "warning")) {
[17:48:07.864]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.864]                         if (muffled) 
[17:48:07.864]                           invokeRestart("muffleWarning")
[17:48:07.864]                       }
[17:48:07.864]                       else if (inherits(cond, "condition")) {
[17:48:07.864]                         if (!is.null(pattern)) {
[17:48:07.864]                           computeRestarts <- base::computeRestarts
[17:48:07.864]                           grepl <- base::grepl
[17:48:07.864]                           restarts <- computeRestarts(cond)
[17:48:07.864]                           for (restart in restarts) {
[17:48:07.864]                             name <- restart$name
[17:48:07.864]                             if (is.null(name)) 
[17:48:07.864]                               next
[17:48:07.864]                             if (!grepl(pattern, name)) 
[17:48:07.864]                               next
[17:48:07.864]                             invokeRestart(restart)
[17:48:07.864]                             muffled <- TRUE
[17:48:07.864]                             break
[17:48:07.864]                           }
[17:48:07.864]                         }
[17:48:07.864]                       }
[17:48:07.864]                       invisible(muffled)
[17:48:07.864]                     }
[17:48:07.864]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.864]                   }
[17:48:07.864]                 }
[17:48:07.864]             }
[17:48:07.864]         }))
[17:48:07.864]     }, error = function(ex) {
[17:48:07.864]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:07.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.864]                 ...future.rng), started = ...future.startTime, 
[17:48:07.864]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:07.864]             version = "1.8"), class = "FutureResult")
[17:48:07.864]     }, finally = {
[17:48:07.864]         if (!identical(...future.workdir, getwd())) 
[17:48:07.864]             setwd(...future.workdir)
[17:48:07.864]         {
[17:48:07.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:07.864]                 ...future.oldOptions$nwarnings <- NULL
[17:48:07.864]             }
[17:48:07.864]             base::options(...future.oldOptions)
[17:48:07.864]             if (.Platform$OS.type == "windows") {
[17:48:07.864]                 old_names <- names(...future.oldEnvVars)
[17:48:07.864]                 envs <- base::Sys.getenv()
[17:48:07.864]                 names <- names(envs)
[17:48:07.864]                 common <- intersect(names, old_names)
[17:48:07.864]                 added <- setdiff(names, old_names)
[17:48:07.864]                 removed <- setdiff(old_names, names)
[17:48:07.864]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:07.864]                   envs[common]]
[17:48:07.864]                 NAMES <- toupper(changed)
[17:48:07.864]                 args <- list()
[17:48:07.864]                 for (kk in seq_along(NAMES)) {
[17:48:07.864]                   name <- changed[[kk]]
[17:48:07.864]                   NAME <- NAMES[[kk]]
[17:48:07.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.864]                     next
[17:48:07.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.864]                 }
[17:48:07.864]                 NAMES <- toupper(added)
[17:48:07.864]                 for (kk in seq_along(NAMES)) {
[17:48:07.864]                   name <- added[[kk]]
[17:48:07.864]                   NAME <- NAMES[[kk]]
[17:48:07.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.864]                     next
[17:48:07.864]                   args[[name]] <- ""
[17:48:07.864]                 }
[17:48:07.864]                 NAMES <- toupper(removed)
[17:48:07.864]                 for (kk in seq_along(NAMES)) {
[17:48:07.864]                   name <- removed[[kk]]
[17:48:07.864]                   NAME <- NAMES[[kk]]
[17:48:07.864]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.864]                     next
[17:48:07.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.864]                 }
[17:48:07.864]                 if (length(args) > 0) 
[17:48:07.864]                   base::do.call(base::Sys.setenv, args = args)
[17:48:07.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:07.864]             }
[17:48:07.864]             else {
[17:48:07.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:07.864]             }
[17:48:07.864]             {
[17:48:07.864]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:07.864]                   0L) {
[17:48:07.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:07.864]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:07.864]                   base::options(opts)
[17:48:07.864]                 }
[17:48:07.864]                 {
[17:48:07.864]                   {
[17:48:07.864]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:07.864]                     NULL
[17:48:07.864]                   }
[17:48:07.864]                   options(future.plan = NULL)
[17:48:07.864]                   if (is.na(NA_character_)) 
[17:48:07.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:07.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:07.864]                     .init = FALSE)
[17:48:07.864]                 }
[17:48:07.864]             }
[17:48:07.864]         }
[17:48:07.864]     })
[17:48:07.864]     if (TRUE) {
[17:48:07.864]         base::sink(type = "output", split = FALSE)
[17:48:07.864]         if (TRUE) {
[17:48:07.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:07.864]         }
[17:48:07.864]         else {
[17:48:07.864]             ...future.result["stdout"] <- base::list(NULL)
[17:48:07.864]         }
[17:48:07.864]         base::close(...future.stdout)
[17:48:07.864]         ...future.stdout <- NULL
[17:48:07.864]     }
[17:48:07.864]     ...future.result$conditions <- ...future.conditions
[17:48:07.864]     ...future.result$finished <- base::Sys.time()
[17:48:07.864]     ...future.result
[17:48:07.864] }
[17:48:07.867] MultisessionFuture started
[17:48:07.867] - Launch lazy future ... done
[17:48:07.867] run() for ‘MultisessionFuture’ ... done
[17:48:07.868] receiveMessageFromWorker() for ClusterFuture ...
[17:48:07.868] - Validating connection of MultisessionFuture
[17:48:07.869] - received message: FutureResult
[17:48:07.869] - Received FutureResult
[17:48:07.869] - Erased future from FutureRegistry
[17:48:07.869] result() for ClusterFuture ...
[17:48:07.869] - result already collected: FutureResult
[17:48:07.869] result() for ClusterFuture ... done
[17:48:07.869] signalConditions() ...
[17:48:07.869]  - include = ‘immediateCondition’
[17:48:07.870]  - exclude = 
[17:48:07.870]  - resignal = FALSE
[17:48:07.870]  - Number of conditions: 1
[17:48:07.870] signalConditions() ... done
[17:48:07.870] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:07.870] A MultisessionFuture was resolved (and resolved itself)
[17:48:07.870] getGlobalsAndPackages() ...
[17:48:07.870] Searching for globals...
[17:48:07.871] - globals found: [2] ‘list’, ‘stop’
[17:48:07.871] Searching for globals ... DONE
[17:48:07.871] Resolving globals: FALSE
[17:48:07.871] 
[17:48:07.871] 
[17:48:07.871] getGlobalsAndPackages() ... DONE
[17:48:07.872] run() for ‘Future’ ...
[17:48:07.872] - state: ‘created’
[17:48:07.872] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:07.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:07.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:07.886]   - Field: ‘node’
[17:48:07.886]   - Field: ‘label’
[17:48:07.886]   - Field: ‘local’
[17:48:07.886]   - Field: ‘owner’
[17:48:07.886]   - Field: ‘envir’
[17:48:07.886]   - Field: ‘workers’
[17:48:07.886]   - Field: ‘packages’
[17:48:07.886]   - Field: ‘gc’
[17:48:07.886]   - Field: ‘conditions’
[17:48:07.886]   - Field: ‘persistent’
[17:48:07.886]   - Field: ‘expr’
[17:48:07.887]   - Field: ‘uuid’
[17:48:07.887]   - Field: ‘seed’
[17:48:07.887]   - Field: ‘version’
[17:48:07.887]   - Field: ‘result’
[17:48:07.887]   - Field: ‘asynchronous’
[17:48:07.887]   - Field: ‘calls’
[17:48:07.887]   - Field: ‘globals’
[17:48:07.887]   - Field: ‘stdout’
[17:48:07.887]   - Field: ‘earlySignal’
[17:48:07.887]   - Field: ‘lazy’
[17:48:07.887]   - Field: ‘state’
[17:48:07.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:07.888] - Launch lazy future ...
[17:48:07.888] Packages needed by the future expression (n = 0): <none>
[17:48:07.888] Packages needed by future strategies (n = 0): <none>
[17:48:07.888] {
[17:48:07.888]     {
[17:48:07.888]         {
[17:48:07.888]             ...future.startTime <- base::Sys.time()
[17:48:07.888]             {
[17:48:07.888]                 {
[17:48:07.888]                   {
[17:48:07.888]                     {
[17:48:07.888]                       base::local({
[17:48:07.888]                         has_future <- base::requireNamespace("future", 
[17:48:07.888]                           quietly = TRUE)
[17:48:07.888]                         if (has_future) {
[17:48:07.888]                           ns <- base::getNamespace("future")
[17:48:07.888]                           version <- ns[[".package"]][["version"]]
[17:48:07.888]                           if (is.null(version)) 
[17:48:07.888]                             version <- utils::packageVersion("future")
[17:48:07.888]                         }
[17:48:07.888]                         else {
[17:48:07.888]                           version <- NULL
[17:48:07.888]                         }
[17:48:07.888]                         if (!has_future || version < "1.8.0") {
[17:48:07.888]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:07.888]                             "", base::R.version$version.string), 
[17:48:07.888]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:07.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:07.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:07.888]                               "release", "version")], collapse = " "), 
[17:48:07.888]                             hostname = base::Sys.info()[["nodename"]])
[17:48:07.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:07.888]                             info)
[17:48:07.888]                           info <- base::paste(info, collapse = "; ")
[17:48:07.888]                           if (!has_future) {
[17:48:07.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:07.888]                               info)
[17:48:07.888]                           }
[17:48:07.888]                           else {
[17:48:07.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:07.888]                               info, version)
[17:48:07.888]                           }
[17:48:07.888]                           base::stop(msg)
[17:48:07.888]                         }
[17:48:07.888]                       })
[17:48:07.888]                     }
[17:48:07.888]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:07.888]                     base::options(mc.cores = 1L)
[17:48:07.888]                   }
[17:48:07.888]                   ...future.strategy.old <- future::plan("list")
[17:48:07.888]                   options(future.plan = NULL)
[17:48:07.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:07.888]                 }
[17:48:07.888]                 ...future.workdir <- getwd()
[17:48:07.888]             }
[17:48:07.888]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:07.888]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:07.888]         }
[17:48:07.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:07.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:07.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:07.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:07.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:07.888]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:07.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:07.888]             base::names(...future.oldOptions))
[17:48:07.888]     }
[17:48:07.888]     if (FALSE) {
[17:48:07.888]     }
[17:48:07.888]     else {
[17:48:07.888]         if (TRUE) {
[17:48:07.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:07.888]                 open = "w")
[17:48:07.888]         }
[17:48:07.888]         else {
[17:48:07.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:07.888]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:07.888]         }
[17:48:07.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:07.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:07.888]             base::sink(type = "output", split = FALSE)
[17:48:07.888]             base::close(...future.stdout)
[17:48:07.888]         }, add = TRUE)
[17:48:07.888]     }
[17:48:07.888]     ...future.frame <- base::sys.nframe()
[17:48:07.888]     ...future.conditions <- base::list()
[17:48:07.888]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:07.888]     if (FALSE) {
[17:48:07.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:07.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:07.888]     }
[17:48:07.888]     ...future.result <- base::tryCatch({
[17:48:07.888]         base::withCallingHandlers({
[17:48:07.888]             ...future.value <- base::withVisible(base::local({
[17:48:07.888]                 ...future.makeSendCondition <- base::local({
[17:48:07.888]                   sendCondition <- NULL
[17:48:07.888]                   function(frame = 1L) {
[17:48:07.888]                     if (is.function(sendCondition)) 
[17:48:07.888]                       return(sendCondition)
[17:48:07.888]                     ns <- getNamespace("parallel")
[17:48:07.888]                     if (exists("sendData", mode = "function", 
[17:48:07.888]                       envir = ns)) {
[17:48:07.888]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:07.888]                         envir = ns)
[17:48:07.888]                       envir <- sys.frame(frame)
[17:48:07.888]                       master <- NULL
[17:48:07.888]                       while (!identical(envir, .GlobalEnv) && 
[17:48:07.888]                         !identical(envir, emptyenv())) {
[17:48:07.888]                         if (exists("master", mode = "list", envir = envir, 
[17:48:07.888]                           inherits = FALSE)) {
[17:48:07.888]                           master <- get("master", mode = "list", 
[17:48:07.888]                             envir = envir, inherits = FALSE)
[17:48:07.888]                           if (inherits(master, c("SOCKnode", 
[17:48:07.888]                             "SOCK0node"))) {
[17:48:07.888]                             sendCondition <<- function(cond) {
[17:48:07.888]                               data <- list(type = "VALUE", value = cond, 
[17:48:07.888]                                 success = TRUE)
[17:48:07.888]                               parallel_sendData(master, data)
[17:48:07.888]                             }
[17:48:07.888]                             return(sendCondition)
[17:48:07.888]                           }
[17:48:07.888]                         }
[17:48:07.888]                         frame <- frame + 1L
[17:48:07.888]                         envir <- sys.frame(frame)
[17:48:07.888]                       }
[17:48:07.888]                     }
[17:48:07.888]                     sendCondition <<- function(cond) NULL
[17:48:07.888]                   }
[17:48:07.888]                 })
[17:48:07.888]                 withCallingHandlers({
[17:48:07.888]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:07.888]                 }, immediateCondition = function(cond) {
[17:48:07.888]                   sendCondition <- ...future.makeSendCondition()
[17:48:07.888]                   sendCondition(cond)
[17:48:07.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.888]                   {
[17:48:07.888]                     inherits <- base::inherits
[17:48:07.888]                     invokeRestart <- base::invokeRestart
[17:48:07.888]                     is.null <- base::is.null
[17:48:07.888]                     muffled <- FALSE
[17:48:07.888]                     if (inherits(cond, "message")) {
[17:48:07.888]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:07.888]                       if (muffled) 
[17:48:07.888]                         invokeRestart("muffleMessage")
[17:48:07.888]                     }
[17:48:07.888]                     else if (inherits(cond, "warning")) {
[17:48:07.888]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:07.888]                       if (muffled) 
[17:48:07.888]                         invokeRestart("muffleWarning")
[17:48:07.888]                     }
[17:48:07.888]                     else if (inherits(cond, "condition")) {
[17:48:07.888]                       if (!is.null(pattern)) {
[17:48:07.888]                         computeRestarts <- base::computeRestarts
[17:48:07.888]                         grepl <- base::grepl
[17:48:07.888]                         restarts <- computeRestarts(cond)
[17:48:07.888]                         for (restart in restarts) {
[17:48:07.888]                           name <- restart$name
[17:48:07.888]                           if (is.null(name)) 
[17:48:07.888]                             next
[17:48:07.888]                           if (!grepl(pattern, name)) 
[17:48:07.888]                             next
[17:48:07.888]                           invokeRestart(restart)
[17:48:07.888]                           muffled <- TRUE
[17:48:07.888]                           break
[17:48:07.888]                         }
[17:48:07.888]                       }
[17:48:07.888]                     }
[17:48:07.888]                     invisible(muffled)
[17:48:07.888]                   }
[17:48:07.888]                   muffleCondition(cond)
[17:48:07.888]                 })
[17:48:07.888]             }))
[17:48:07.888]             future::FutureResult(value = ...future.value$value, 
[17:48:07.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.888]                   ...future.rng), globalenv = if (FALSE) 
[17:48:07.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:07.888]                     ...future.globalenv.names))
[17:48:07.888]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:07.888]         }, condition = base::local({
[17:48:07.888]             c <- base::c
[17:48:07.888]             inherits <- base::inherits
[17:48:07.888]             invokeRestart <- base::invokeRestart
[17:48:07.888]             length <- base::length
[17:48:07.888]             list <- base::list
[17:48:07.888]             seq.int <- base::seq.int
[17:48:07.888]             signalCondition <- base::signalCondition
[17:48:07.888]             sys.calls <- base::sys.calls
[17:48:07.888]             `[[` <- base::`[[`
[17:48:07.888]             `+` <- base::`+`
[17:48:07.888]             `<<-` <- base::`<<-`
[17:48:07.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:07.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:07.888]                   3L)]
[17:48:07.888]             }
[17:48:07.888]             function(cond) {
[17:48:07.888]                 is_error <- inherits(cond, "error")
[17:48:07.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:07.888]                   NULL)
[17:48:07.888]                 if (is_error) {
[17:48:07.888]                   sessionInformation <- function() {
[17:48:07.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:07.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:07.888]                       search = base::search(), system = base::Sys.info())
[17:48:07.888]                   }
[17:48:07.888]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:07.888]                     cond$call), session = sessionInformation(), 
[17:48:07.888]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:07.888]                   signalCondition(cond)
[17:48:07.888]                 }
[17:48:07.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:07.888]                 "immediateCondition"))) {
[17:48:07.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:07.888]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:07.888]                   if (TRUE && !signal) {
[17:48:07.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.888]                     {
[17:48:07.888]                       inherits <- base::inherits
[17:48:07.888]                       invokeRestart <- base::invokeRestart
[17:48:07.888]                       is.null <- base::is.null
[17:48:07.888]                       muffled <- FALSE
[17:48:07.888]                       if (inherits(cond, "message")) {
[17:48:07.888]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.888]                         if (muffled) 
[17:48:07.888]                           invokeRestart("muffleMessage")
[17:48:07.888]                       }
[17:48:07.888]                       else if (inherits(cond, "warning")) {
[17:48:07.888]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.888]                         if (muffled) 
[17:48:07.888]                           invokeRestart("muffleWarning")
[17:48:07.888]                       }
[17:48:07.888]                       else if (inherits(cond, "condition")) {
[17:48:07.888]                         if (!is.null(pattern)) {
[17:48:07.888]                           computeRestarts <- base::computeRestarts
[17:48:07.888]                           grepl <- base::grepl
[17:48:07.888]                           restarts <- computeRestarts(cond)
[17:48:07.888]                           for (restart in restarts) {
[17:48:07.888]                             name <- restart$name
[17:48:07.888]                             if (is.null(name)) 
[17:48:07.888]                               next
[17:48:07.888]                             if (!grepl(pattern, name)) 
[17:48:07.888]                               next
[17:48:07.888]                             invokeRestart(restart)
[17:48:07.888]                             muffled <- TRUE
[17:48:07.888]                             break
[17:48:07.888]                           }
[17:48:07.888]                         }
[17:48:07.888]                       }
[17:48:07.888]                       invisible(muffled)
[17:48:07.888]                     }
[17:48:07.888]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.888]                   }
[17:48:07.888]                 }
[17:48:07.888]                 else {
[17:48:07.888]                   if (TRUE) {
[17:48:07.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.888]                     {
[17:48:07.888]                       inherits <- base::inherits
[17:48:07.888]                       invokeRestart <- base::invokeRestart
[17:48:07.888]                       is.null <- base::is.null
[17:48:07.888]                       muffled <- FALSE
[17:48:07.888]                       if (inherits(cond, "message")) {
[17:48:07.888]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.888]                         if (muffled) 
[17:48:07.888]                           invokeRestart("muffleMessage")
[17:48:07.888]                       }
[17:48:07.888]                       else if (inherits(cond, "warning")) {
[17:48:07.888]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.888]                         if (muffled) 
[17:48:07.888]                           invokeRestart("muffleWarning")
[17:48:07.888]                       }
[17:48:07.888]                       else if (inherits(cond, "condition")) {
[17:48:07.888]                         if (!is.null(pattern)) {
[17:48:07.888]                           computeRestarts <- base::computeRestarts
[17:48:07.888]                           grepl <- base::grepl
[17:48:07.888]                           restarts <- computeRestarts(cond)
[17:48:07.888]                           for (restart in restarts) {
[17:48:07.888]                             name <- restart$name
[17:48:07.888]                             if (is.null(name)) 
[17:48:07.888]                               next
[17:48:07.888]                             if (!grepl(pattern, name)) 
[17:48:07.888]                               next
[17:48:07.888]                             invokeRestart(restart)
[17:48:07.888]                             muffled <- TRUE
[17:48:07.888]                             break
[17:48:07.888]                           }
[17:48:07.888]                         }
[17:48:07.888]                       }
[17:48:07.888]                       invisible(muffled)
[17:48:07.888]                     }
[17:48:07.888]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.888]                   }
[17:48:07.888]                 }
[17:48:07.888]             }
[17:48:07.888]         }))
[17:48:07.888]     }, error = function(ex) {
[17:48:07.888]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:07.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.888]                 ...future.rng), started = ...future.startTime, 
[17:48:07.888]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:07.888]             version = "1.8"), class = "FutureResult")
[17:48:07.888]     }, finally = {
[17:48:07.888]         if (!identical(...future.workdir, getwd())) 
[17:48:07.888]             setwd(...future.workdir)
[17:48:07.888]         {
[17:48:07.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:07.888]                 ...future.oldOptions$nwarnings <- NULL
[17:48:07.888]             }
[17:48:07.888]             base::options(...future.oldOptions)
[17:48:07.888]             if (.Platform$OS.type == "windows") {
[17:48:07.888]                 old_names <- names(...future.oldEnvVars)
[17:48:07.888]                 envs <- base::Sys.getenv()
[17:48:07.888]                 names <- names(envs)
[17:48:07.888]                 common <- intersect(names, old_names)
[17:48:07.888]                 added <- setdiff(names, old_names)
[17:48:07.888]                 removed <- setdiff(old_names, names)
[17:48:07.888]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:07.888]                   envs[common]]
[17:48:07.888]                 NAMES <- toupper(changed)
[17:48:07.888]                 args <- list()
[17:48:07.888]                 for (kk in seq_along(NAMES)) {
[17:48:07.888]                   name <- changed[[kk]]
[17:48:07.888]                   NAME <- NAMES[[kk]]
[17:48:07.888]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.888]                     next
[17:48:07.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.888]                 }
[17:48:07.888]                 NAMES <- toupper(added)
[17:48:07.888]                 for (kk in seq_along(NAMES)) {
[17:48:07.888]                   name <- added[[kk]]
[17:48:07.888]                   NAME <- NAMES[[kk]]
[17:48:07.888]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.888]                     next
[17:48:07.888]                   args[[name]] <- ""
[17:48:07.888]                 }
[17:48:07.888]                 NAMES <- toupper(removed)
[17:48:07.888]                 for (kk in seq_along(NAMES)) {
[17:48:07.888]                   name <- removed[[kk]]
[17:48:07.888]                   NAME <- NAMES[[kk]]
[17:48:07.888]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.888]                     next
[17:48:07.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.888]                 }
[17:48:07.888]                 if (length(args) > 0) 
[17:48:07.888]                   base::do.call(base::Sys.setenv, args = args)
[17:48:07.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:07.888]             }
[17:48:07.888]             else {
[17:48:07.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:07.888]             }
[17:48:07.888]             {
[17:48:07.888]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:07.888]                   0L) {
[17:48:07.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:07.888]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:07.888]                   base::options(opts)
[17:48:07.888]                 }
[17:48:07.888]                 {
[17:48:07.888]                   {
[17:48:07.888]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:07.888]                     NULL
[17:48:07.888]                   }
[17:48:07.888]                   options(future.plan = NULL)
[17:48:07.888]                   if (is.na(NA_character_)) 
[17:48:07.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:07.888]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:07.888]                     .init = FALSE)
[17:48:07.888]                 }
[17:48:07.888]             }
[17:48:07.888]         }
[17:48:07.888]     })
[17:48:07.888]     if (TRUE) {
[17:48:07.888]         base::sink(type = "output", split = FALSE)
[17:48:07.888]         if (TRUE) {
[17:48:07.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:07.888]         }
[17:48:07.888]         else {
[17:48:07.888]             ...future.result["stdout"] <- base::list(NULL)
[17:48:07.888]         }
[17:48:07.888]         base::close(...future.stdout)
[17:48:07.888]         ...future.stdout <- NULL
[17:48:07.888]     }
[17:48:07.888]     ...future.result$conditions <- ...future.conditions
[17:48:07.888]     ...future.result$finished <- base::Sys.time()
[17:48:07.888]     ...future.result
[17:48:07.888] }
[17:48:07.891] MultisessionFuture started
[17:48:07.891] - Launch lazy future ... done
[17:48:07.891] run() for ‘MultisessionFuture’ ... done
[17:48:07.893] receiveMessageFromWorker() for ClusterFuture ...
[17:48:07.893] - Validating connection of MultisessionFuture
[17:48:07.893] - received message: FutureResult
[17:48:07.893] - Received FutureResult
[17:48:07.894] - Erased future from FutureRegistry
[17:48:07.894] result() for ClusterFuture ...
[17:48:07.894] - result already collected: FutureResult
[17:48:07.894] result() for ClusterFuture ... done
[17:48:07.894] signalConditions() ...
[17:48:07.894]  - include = ‘immediateCondition’
[17:48:07.894]  - exclude = 
[17:48:07.894]  - resignal = FALSE
[17:48:07.894]  - Number of conditions: 1
[17:48:07.894] signalConditions() ... done
[17:48:07.894] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:07.894] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[17:48:07.895] getGlobalsAndPackages() ...
[17:48:07.895] Searching for globals...
[17:48:07.896] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:07.896] Searching for globals ... DONE
[17:48:07.896] Resolving globals: FALSE
[17:48:07.896] 
[17:48:07.896] 
[17:48:07.897] getGlobalsAndPackages() ... DONE
[17:48:07.897] run() for ‘Future’ ...
[17:48:07.897] - state: ‘created’
[17:48:07.897] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:07.911] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:07.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:07.911]   - Field: ‘node’
[17:48:07.911]   - Field: ‘label’
[17:48:07.911]   - Field: ‘local’
[17:48:07.911]   - Field: ‘owner’
[17:48:07.911]   - Field: ‘envir’
[17:48:07.911]   - Field: ‘workers’
[17:48:07.912]   - Field: ‘packages’
[17:48:07.912]   - Field: ‘gc’
[17:48:07.912]   - Field: ‘conditions’
[17:48:07.912]   - Field: ‘persistent’
[17:48:07.912]   - Field: ‘expr’
[17:48:07.912]   - Field: ‘uuid’
[17:48:07.912]   - Field: ‘seed’
[17:48:07.912]   - Field: ‘version’
[17:48:07.912]   - Field: ‘result’
[17:48:07.912]   - Field: ‘asynchronous’
[17:48:07.913]   - Field: ‘calls’
[17:48:07.913]   - Field: ‘globals’
[17:48:07.913]   - Field: ‘stdout’
[17:48:07.913]   - Field: ‘earlySignal’
[17:48:07.913]   - Field: ‘lazy’
[17:48:07.913]   - Field: ‘state’
[17:48:07.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:07.913] - Launch lazy future ...
[17:48:07.914] Packages needed by the future expression (n = 0): <none>
[17:48:07.914] Packages needed by future strategies (n = 0): <none>
[17:48:07.914] {
[17:48:07.914]     {
[17:48:07.914]         {
[17:48:07.914]             ...future.startTime <- base::Sys.time()
[17:48:07.914]             {
[17:48:07.914]                 {
[17:48:07.914]                   {
[17:48:07.914]                     {
[17:48:07.914]                       base::local({
[17:48:07.914]                         has_future <- base::requireNamespace("future", 
[17:48:07.914]                           quietly = TRUE)
[17:48:07.914]                         if (has_future) {
[17:48:07.914]                           ns <- base::getNamespace("future")
[17:48:07.914]                           version <- ns[[".package"]][["version"]]
[17:48:07.914]                           if (is.null(version)) 
[17:48:07.914]                             version <- utils::packageVersion("future")
[17:48:07.914]                         }
[17:48:07.914]                         else {
[17:48:07.914]                           version <- NULL
[17:48:07.914]                         }
[17:48:07.914]                         if (!has_future || version < "1.8.0") {
[17:48:07.914]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:07.914]                             "", base::R.version$version.string), 
[17:48:07.914]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:07.914]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:07.914]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:07.914]                               "release", "version")], collapse = " "), 
[17:48:07.914]                             hostname = base::Sys.info()[["nodename"]])
[17:48:07.914]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:07.914]                             info)
[17:48:07.914]                           info <- base::paste(info, collapse = "; ")
[17:48:07.914]                           if (!has_future) {
[17:48:07.914]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:07.914]                               info)
[17:48:07.914]                           }
[17:48:07.914]                           else {
[17:48:07.914]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:07.914]                               info, version)
[17:48:07.914]                           }
[17:48:07.914]                           base::stop(msg)
[17:48:07.914]                         }
[17:48:07.914]                       })
[17:48:07.914]                     }
[17:48:07.914]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:07.914]                     base::options(mc.cores = 1L)
[17:48:07.914]                   }
[17:48:07.914]                   ...future.strategy.old <- future::plan("list")
[17:48:07.914]                   options(future.plan = NULL)
[17:48:07.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:07.914]                 }
[17:48:07.914]                 ...future.workdir <- getwd()
[17:48:07.914]             }
[17:48:07.914]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:07.914]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:07.914]         }
[17:48:07.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:07.914]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:07.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:07.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:07.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:07.914]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:07.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:07.914]             base::names(...future.oldOptions))
[17:48:07.914]     }
[17:48:07.914]     if (FALSE) {
[17:48:07.914]     }
[17:48:07.914]     else {
[17:48:07.914]         if (TRUE) {
[17:48:07.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:07.914]                 open = "w")
[17:48:07.914]         }
[17:48:07.914]         else {
[17:48:07.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:07.914]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:07.914]         }
[17:48:07.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:07.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:07.914]             base::sink(type = "output", split = FALSE)
[17:48:07.914]             base::close(...future.stdout)
[17:48:07.914]         }, add = TRUE)
[17:48:07.914]     }
[17:48:07.914]     ...future.frame <- base::sys.nframe()
[17:48:07.914]     ...future.conditions <- base::list()
[17:48:07.914]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:07.914]     if (FALSE) {
[17:48:07.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:07.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:07.914]     }
[17:48:07.914]     ...future.result <- base::tryCatch({
[17:48:07.914]         base::withCallingHandlers({
[17:48:07.914]             ...future.value <- base::withVisible(base::local({
[17:48:07.914]                 ...future.makeSendCondition <- base::local({
[17:48:07.914]                   sendCondition <- NULL
[17:48:07.914]                   function(frame = 1L) {
[17:48:07.914]                     if (is.function(sendCondition)) 
[17:48:07.914]                       return(sendCondition)
[17:48:07.914]                     ns <- getNamespace("parallel")
[17:48:07.914]                     if (exists("sendData", mode = "function", 
[17:48:07.914]                       envir = ns)) {
[17:48:07.914]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:07.914]                         envir = ns)
[17:48:07.914]                       envir <- sys.frame(frame)
[17:48:07.914]                       master <- NULL
[17:48:07.914]                       while (!identical(envir, .GlobalEnv) && 
[17:48:07.914]                         !identical(envir, emptyenv())) {
[17:48:07.914]                         if (exists("master", mode = "list", envir = envir, 
[17:48:07.914]                           inherits = FALSE)) {
[17:48:07.914]                           master <- get("master", mode = "list", 
[17:48:07.914]                             envir = envir, inherits = FALSE)
[17:48:07.914]                           if (inherits(master, c("SOCKnode", 
[17:48:07.914]                             "SOCK0node"))) {
[17:48:07.914]                             sendCondition <<- function(cond) {
[17:48:07.914]                               data <- list(type = "VALUE", value = cond, 
[17:48:07.914]                                 success = TRUE)
[17:48:07.914]                               parallel_sendData(master, data)
[17:48:07.914]                             }
[17:48:07.914]                             return(sendCondition)
[17:48:07.914]                           }
[17:48:07.914]                         }
[17:48:07.914]                         frame <- frame + 1L
[17:48:07.914]                         envir <- sys.frame(frame)
[17:48:07.914]                       }
[17:48:07.914]                     }
[17:48:07.914]                     sendCondition <<- function(cond) NULL
[17:48:07.914]                   }
[17:48:07.914]                 })
[17:48:07.914]                 withCallingHandlers({
[17:48:07.914]                   {
[17:48:07.914]                     Sys.sleep(0.5)
[17:48:07.914]                     list(a = 1, b = 42L)
[17:48:07.914]                   }
[17:48:07.914]                 }, immediateCondition = function(cond) {
[17:48:07.914]                   sendCondition <- ...future.makeSendCondition()
[17:48:07.914]                   sendCondition(cond)
[17:48:07.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.914]                   {
[17:48:07.914]                     inherits <- base::inherits
[17:48:07.914]                     invokeRestart <- base::invokeRestart
[17:48:07.914]                     is.null <- base::is.null
[17:48:07.914]                     muffled <- FALSE
[17:48:07.914]                     if (inherits(cond, "message")) {
[17:48:07.914]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:07.914]                       if (muffled) 
[17:48:07.914]                         invokeRestart("muffleMessage")
[17:48:07.914]                     }
[17:48:07.914]                     else if (inherits(cond, "warning")) {
[17:48:07.914]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:07.914]                       if (muffled) 
[17:48:07.914]                         invokeRestart("muffleWarning")
[17:48:07.914]                     }
[17:48:07.914]                     else if (inherits(cond, "condition")) {
[17:48:07.914]                       if (!is.null(pattern)) {
[17:48:07.914]                         computeRestarts <- base::computeRestarts
[17:48:07.914]                         grepl <- base::grepl
[17:48:07.914]                         restarts <- computeRestarts(cond)
[17:48:07.914]                         for (restart in restarts) {
[17:48:07.914]                           name <- restart$name
[17:48:07.914]                           if (is.null(name)) 
[17:48:07.914]                             next
[17:48:07.914]                           if (!grepl(pattern, name)) 
[17:48:07.914]                             next
[17:48:07.914]                           invokeRestart(restart)
[17:48:07.914]                           muffled <- TRUE
[17:48:07.914]                           break
[17:48:07.914]                         }
[17:48:07.914]                       }
[17:48:07.914]                     }
[17:48:07.914]                     invisible(muffled)
[17:48:07.914]                   }
[17:48:07.914]                   muffleCondition(cond)
[17:48:07.914]                 })
[17:48:07.914]             }))
[17:48:07.914]             future::FutureResult(value = ...future.value$value, 
[17:48:07.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.914]                   ...future.rng), globalenv = if (FALSE) 
[17:48:07.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:07.914]                     ...future.globalenv.names))
[17:48:07.914]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:07.914]         }, condition = base::local({
[17:48:07.914]             c <- base::c
[17:48:07.914]             inherits <- base::inherits
[17:48:07.914]             invokeRestart <- base::invokeRestart
[17:48:07.914]             length <- base::length
[17:48:07.914]             list <- base::list
[17:48:07.914]             seq.int <- base::seq.int
[17:48:07.914]             signalCondition <- base::signalCondition
[17:48:07.914]             sys.calls <- base::sys.calls
[17:48:07.914]             `[[` <- base::`[[`
[17:48:07.914]             `+` <- base::`+`
[17:48:07.914]             `<<-` <- base::`<<-`
[17:48:07.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:07.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:07.914]                   3L)]
[17:48:07.914]             }
[17:48:07.914]             function(cond) {
[17:48:07.914]                 is_error <- inherits(cond, "error")
[17:48:07.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:07.914]                   NULL)
[17:48:07.914]                 if (is_error) {
[17:48:07.914]                   sessionInformation <- function() {
[17:48:07.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:07.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:07.914]                       search = base::search(), system = base::Sys.info())
[17:48:07.914]                   }
[17:48:07.914]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:07.914]                     cond$call), session = sessionInformation(), 
[17:48:07.914]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:07.914]                   signalCondition(cond)
[17:48:07.914]                 }
[17:48:07.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:07.914]                 "immediateCondition"))) {
[17:48:07.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:07.914]                   ...future.conditions[[length(...future.conditions) + 
[17:48:07.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:07.914]                   if (TRUE && !signal) {
[17:48:07.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.914]                     {
[17:48:07.914]                       inherits <- base::inherits
[17:48:07.914]                       invokeRestart <- base::invokeRestart
[17:48:07.914]                       is.null <- base::is.null
[17:48:07.914]                       muffled <- FALSE
[17:48:07.914]                       if (inherits(cond, "message")) {
[17:48:07.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.914]                         if (muffled) 
[17:48:07.914]                           invokeRestart("muffleMessage")
[17:48:07.914]                       }
[17:48:07.914]                       else if (inherits(cond, "warning")) {
[17:48:07.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.914]                         if (muffled) 
[17:48:07.914]                           invokeRestart("muffleWarning")
[17:48:07.914]                       }
[17:48:07.914]                       else if (inherits(cond, "condition")) {
[17:48:07.914]                         if (!is.null(pattern)) {
[17:48:07.914]                           computeRestarts <- base::computeRestarts
[17:48:07.914]                           grepl <- base::grepl
[17:48:07.914]                           restarts <- computeRestarts(cond)
[17:48:07.914]                           for (restart in restarts) {
[17:48:07.914]                             name <- restart$name
[17:48:07.914]                             if (is.null(name)) 
[17:48:07.914]                               next
[17:48:07.914]                             if (!grepl(pattern, name)) 
[17:48:07.914]                               next
[17:48:07.914]                             invokeRestart(restart)
[17:48:07.914]                             muffled <- TRUE
[17:48:07.914]                             break
[17:48:07.914]                           }
[17:48:07.914]                         }
[17:48:07.914]                       }
[17:48:07.914]                       invisible(muffled)
[17:48:07.914]                     }
[17:48:07.914]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.914]                   }
[17:48:07.914]                 }
[17:48:07.914]                 else {
[17:48:07.914]                   if (TRUE) {
[17:48:07.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:07.914]                     {
[17:48:07.914]                       inherits <- base::inherits
[17:48:07.914]                       invokeRestart <- base::invokeRestart
[17:48:07.914]                       is.null <- base::is.null
[17:48:07.914]                       muffled <- FALSE
[17:48:07.914]                       if (inherits(cond, "message")) {
[17:48:07.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:07.914]                         if (muffled) 
[17:48:07.914]                           invokeRestart("muffleMessage")
[17:48:07.914]                       }
[17:48:07.914]                       else if (inherits(cond, "warning")) {
[17:48:07.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:07.914]                         if (muffled) 
[17:48:07.914]                           invokeRestart("muffleWarning")
[17:48:07.914]                       }
[17:48:07.914]                       else if (inherits(cond, "condition")) {
[17:48:07.914]                         if (!is.null(pattern)) {
[17:48:07.914]                           computeRestarts <- base::computeRestarts
[17:48:07.914]                           grepl <- base::grepl
[17:48:07.914]                           restarts <- computeRestarts(cond)
[17:48:07.914]                           for (restart in restarts) {
[17:48:07.914]                             name <- restart$name
[17:48:07.914]                             if (is.null(name)) 
[17:48:07.914]                               next
[17:48:07.914]                             if (!grepl(pattern, name)) 
[17:48:07.914]                               next
[17:48:07.914]                             invokeRestart(restart)
[17:48:07.914]                             muffled <- TRUE
[17:48:07.914]                             break
[17:48:07.914]                           }
[17:48:07.914]                         }
[17:48:07.914]                       }
[17:48:07.914]                       invisible(muffled)
[17:48:07.914]                     }
[17:48:07.914]                     muffleCondition(cond, pattern = "^muffle")
[17:48:07.914]                   }
[17:48:07.914]                 }
[17:48:07.914]             }
[17:48:07.914]         }))
[17:48:07.914]     }, error = function(ex) {
[17:48:07.914]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:07.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:07.914]                 ...future.rng), started = ...future.startTime, 
[17:48:07.914]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:07.914]             version = "1.8"), class = "FutureResult")
[17:48:07.914]     }, finally = {
[17:48:07.914]         if (!identical(...future.workdir, getwd())) 
[17:48:07.914]             setwd(...future.workdir)
[17:48:07.914]         {
[17:48:07.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:07.914]                 ...future.oldOptions$nwarnings <- NULL
[17:48:07.914]             }
[17:48:07.914]             base::options(...future.oldOptions)
[17:48:07.914]             if (.Platform$OS.type == "windows") {
[17:48:07.914]                 old_names <- names(...future.oldEnvVars)
[17:48:07.914]                 envs <- base::Sys.getenv()
[17:48:07.914]                 names <- names(envs)
[17:48:07.914]                 common <- intersect(names, old_names)
[17:48:07.914]                 added <- setdiff(names, old_names)
[17:48:07.914]                 removed <- setdiff(old_names, names)
[17:48:07.914]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:07.914]                   envs[common]]
[17:48:07.914]                 NAMES <- toupper(changed)
[17:48:07.914]                 args <- list()
[17:48:07.914]                 for (kk in seq_along(NAMES)) {
[17:48:07.914]                   name <- changed[[kk]]
[17:48:07.914]                   NAME <- NAMES[[kk]]
[17:48:07.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.914]                     next
[17:48:07.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.914]                 }
[17:48:07.914]                 NAMES <- toupper(added)
[17:48:07.914]                 for (kk in seq_along(NAMES)) {
[17:48:07.914]                   name <- added[[kk]]
[17:48:07.914]                   NAME <- NAMES[[kk]]
[17:48:07.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.914]                     next
[17:48:07.914]                   args[[name]] <- ""
[17:48:07.914]                 }
[17:48:07.914]                 NAMES <- toupper(removed)
[17:48:07.914]                 for (kk in seq_along(NAMES)) {
[17:48:07.914]                   name <- removed[[kk]]
[17:48:07.914]                   NAME <- NAMES[[kk]]
[17:48:07.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:07.914]                     next
[17:48:07.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:07.914]                 }
[17:48:07.914]                 if (length(args) > 0) 
[17:48:07.914]                   base::do.call(base::Sys.setenv, args = args)
[17:48:07.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:07.914]             }
[17:48:07.914]             else {
[17:48:07.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:07.914]             }
[17:48:07.914]             {
[17:48:07.914]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:07.914]                   0L) {
[17:48:07.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:07.914]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:07.914]                   base::options(opts)
[17:48:07.914]                 }
[17:48:07.914]                 {
[17:48:07.914]                   {
[17:48:07.914]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:07.914]                     NULL
[17:48:07.914]                   }
[17:48:07.914]                   options(future.plan = NULL)
[17:48:07.914]                   if (is.na(NA_character_)) 
[17:48:07.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:07.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:07.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:07.914]                     .init = FALSE)
[17:48:07.914]                 }
[17:48:07.914]             }
[17:48:07.914]         }
[17:48:07.914]     })
[17:48:07.914]     if (TRUE) {
[17:48:07.914]         base::sink(type = "output", split = FALSE)
[17:48:07.914]         if (TRUE) {
[17:48:07.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:07.914]         }
[17:48:07.914]         else {
[17:48:07.914]             ...future.result["stdout"] <- base::list(NULL)
[17:48:07.914]         }
[17:48:07.914]         base::close(...future.stdout)
[17:48:07.914]         ...future.stdout <- NULL
[17:48:07.914]     }
[17:48:07.914]     ...future.result$conditions <- ...future.conditions
[17:48:07.914]     ...future.result$finished <- base::Sys.time()
[17:48:07.914]     ...future.result
[17:48:07.914] }
[17:48:07.917] MultisessionFuture started
[17:48:07.917] - Launch lazy future ... done
[17:48:07.917] run() for ‘MultisessionFuture’ ... done
[17:48:08.419] receiveMessageFromWorker() for ClusterFuture ...
[17:48:08.419] - Validating connection of MultisessionFuture
[17:48:08.420] - received message: FutureResult
[17:48:08.420] - Received FutureResult
[17:48:08.420] - Erased future from FutureRegistry
[17:48:08.420] result() for ClusterFuture ...
[17:48:08.420] - result already collected: FutureResult
[17:48:08.420] result() for ClusterFuture ... done
[17:48:08.420] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:08.420] resolve() on list ...
[17:48:08.420]  recursive: 1
[17:48:08.420]  length: 2
[17:48:08.421]  elements: ‘a’, ‘b’
[17:48:08.421]  length: 1 (resolved future 1)
[17:48:08.421]  length: 0 (resolved future 2)
[17:48:08.421] resolve() on list ... DONE
[17:48:08.421] A MultisessionFuture was resolved (and resolved itself)
[17:48:08.421] getGlobalsAndPackages() ...
[17:48:08.421] Searching for globals...
[17:48:08.422] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:08.422] Searching for globals ... DONE
[17:48:08.423] Resolving globals: FALSE
[17:48:08.423] 
[17:48:08.423] 
[17:48:08.423] getGlobalsAndPackages() ... DONE
[17:48:08.423] run() for ‘Future’ ...
[17:48:08.423] - state: ‘created’
[17:48:08.424] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:08.437] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:08.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:08.438]   - Field: ‘node’
[17:48:08.438]   - Field: ‘label’
[17:48:08.438]   - Field: ‘local’
[17:48:08.438]   - Field: ‘owner’
[17:48:08.438]   - Field: ‘envir’
[17:48:08.438]   - Field: ‘workers’
[17:48:08.438]   - Field: ‘packages’
[17:48:08.438]   - Field: ‘gc’
[17:48:08.438]   - Field: ‘conditions’
[17:48:08.438]   - Field: ‘persistent’
[17:48:08.439]   - Field: ‘expr’
[17:48:08.439]   - Field: ‘uuid’
[17:48:08.439]   - Field: ‘seed’
[17:48:08.439]   - Field: ‘version’
[17:48:08.439]   - Field: ‘result’
[17:48:08.439]   - Field: ‘asynchronous’
[17:48:08.439]   - Field: ‘calls’
[17:48:08.439]   - Field: ‘globals’
[17:48:08.439]   - Field: ‘stdout’
[17:48:08.439]   - Field: ‘earlySignal’
[17:48:08.439]   - Field: ‘lazy’
[17:48:08.440]   - Field: ‘state’
[17:48:08.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:08.440] - Launch lazy future ...
[17:48:08.440] Packages needed by the future expression (n = 0): <none>
[17:48:08.440] Packages needed by future strategies (n = 0): <none>
[17:48:08.441] {
[17:48:08.441]     {
[17:48:08.441]         {
[17:48:08.441]             ...future.startTime <- base::Sys.time()
[17:48:08.441]             {
[17:48:08.441]                 {
[17:48:08.441]                   {
[17:48:08.441]                     {
[17:48:08.441]                       base::local({
[17:48:08.441]                         has_future <- base::requireNamespace("future", 
[17:48:08.441]                           quietly = TRUE)
[17:48:08.441]                         if (has_future) {
[17:48:08.441]                           ns <- base::getNamespace("future")
[17:48:08.441]                           version <- ns[[".package"]][["version"]]
[17:48:08.441]                           if (is.null(version)) 
[17:48:08.441]                             version <- utils::packageVersion("future")
[17:48:08.441]                         }
[17:48:08.441]                         else {
[17:48:08.441]                           version <- NULL
[17:48:08.441]                         }
[17:48:08.441]                         if (!has_future || version < "1.8.0") {
[17:48:08.441]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:08.441]                             "", base::R.version$version.string), 
[17:48:08.441]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:08.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:08.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:08.441]                               "release", "version")], collapse = " "), 
[17:48:08.441]                             hostname = base::Sys.info()[["nodename"]])
[17:48:08.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:08.441]                             info)
[17:48:08.441]                           info <- base::paste(info, collapse = "; ")
[17:48:08.441]                           if (!has_future) {
[17:48:08.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:08.441]                               info)
[17:48:08.441]                           }
[17:48:08.441]                           else {
[17:48:08.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:08.441]                               info, version)
[17:48:08.441]                           }
[17:48:08.441]                           base::stop(msg)
[17:48:08.441]                         }
[17:48:08.441]                       })
[17:48:08.441]                     }
[17:48:08.441]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:08.441]                     base::options(mc.cores = 1L)
[17:48:08.441]                   }
[17:48:08.441]                   ...future.strategy.old <- future::plan("list")
[17:48:08.441]                   options(future.plan = NULL)
[17:48:08.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:08.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:08.441]                 }
[17:48:08.441]                 ...future.workdir <- getwd()
[17:48:08.441]             }
[17:48:08.441]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:08.441]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:08.441]         }
[17:48:08.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:08.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:08.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:08.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:08.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:08.441]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:08.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:08.441]             base::names(...future.oldOptions))
[17:48:08.441]     }
[17:48:08.441]     if (FALSE) {
[17:48:08.441]     }
[17:48:08.441]     else {
[17:48:08.441]         if (TRUE) {
[17:48:08.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:08.441]                 open = "w")
[17:48:08.441]         }
[17:48:08.441]         else {
[17:48:08.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:08.441]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:08.441]         }
[17:48:08.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:08.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:08.441]             base::sink(type = "output", split = FALSE)
[17:48:08.441]             base::close(...future.stdout)
[17:48:08.441]         }, add = TRUE)
[17:48:08.441]     }
[17:48:08.441]     ...future.frame <- base::sys.nframe()
[17:48:08.441]     ...future.conditions <- base::list()
[17:48:08.441]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:08.441]     if (FALSE) {
[17:48:08.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:08.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:08.441]     }
[17:48:08.441]     ...future.result <- base::tryCatch({
[17:48:08.441]         base::withCallingHandlers({
[17:48:08.441]             ...future.value <- base::withVisible(base::local({
[17:48:08.441]                 ...future.makeSendCondition <- base::local({
[17:48:08.441]                   sendCondition <- NULL
[17:48:08.441]                   function(frame = 1L) {
[17:48:08.441]                     if (is.function(sendCondition)) 
[17:48:08.441]                       return(sendCondition)
[17:48:08.441]                     ns <- getNamespace("parallel")
[17:48:08.441]                     if (exists("sendData", mode = "function", 
[17:48:08.441]                       envir = ns)) {
[17:48:08.441]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:08.441]                         envir = ns)
[17:48:08.441]                       envir <- sys.frame(frame)
[17:48:08.441]                       master <- NULL
[17:48:08.441]                       while (!identical(envir, .GlobalEnv) && 
[17:48:08.441]                         !identical(envir, emptyenv())) {
[17:48:08.441]                         if (exists("master", mode = "list", envir = envir, 
[17:48:08.441]                           inherits = FALSE)) {
[17:48:08.441]                           master <- get("master", mode = "list", 
[17:48:08.441]                             envir = envir, inherits = FALSE)
[17:48:08.441]                           if (inherits(master, c("SOCKnode", 
[17:48:08.441]                             "SOCK0node"))) {
[17:48:08.441]                             sendCondition <<- function(cond) {
[17:48:08.441]                               data <- list(type = "VALUE", value = cond, 
[17:48:08.441]                                 success = TRUE)
[17:48:08.441]                               parallel_sendData(master, data)
[17:48:08.441]                             }
[17:48:08.441]                             return(sendCondition)
[17:48:08.441]                           }
[17:48:08.441]                         }
[17:48:08.441]                         frame <- frame + 1L
[17:48:08.441]                         envir <- sys.frame(frame)
[17:48:08.441]                       }
[17:48:08.441]                     }
[17:48:08.441]                     sendCondition <<- function(cond) NULL
[17:48:08.441]                   }
[17:48:08.441]                 })
[17:48:08.441]                 withCallingHandlers({
[17:48:08.441]                   {
[17:48:08.441]                     Sys.sleep(0.5)
[17:48:08.441]                     list(a = 1, b = 42L)
[17:48:08.441]                   }
[17:48:08.441]                 }, immediateCondition = function(cond) {
[17:48:08.441]                   sendCondition <- ...future.makeSendCondition()
[17:48:08.441]                   sendCondition(cond)
[17:48:08.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.441]                   {
[17:48:08.441]                     inherits <- base::inherits
[17:48:08.441]                     invokeRestart <- base::invokeRestart
[17:48:08.441]                     is.null <- base::is.null
[17:48:08.441]                     muffled <- FALSE
[17:48:08.441]                     if (inherits(cond, "message")) {
[17:48:08.441]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:08.441]                       if (muffled) 
[17:48:08.441]                         invokeRestart("muffleMessage")
[17:48:08.441]                     }
[17:48:08.441]                     else if (inherits(cond, "warning")) {
[17:48:08.441]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:08.441]                       if (muffled) 
[17:48:08.441]                         invokeRestart("muffleWarning")
[17:48:08.441]                     }
[17:48:08.441]                     else if (inherits(cond, "condition")) {
[17:48:08.441]                       if (!is.null(pattern)) {
[17:48:08.441]                         computeRestarts <- base::computeRestarts
[17:48:08.441]                         grepl <- base::grepl
[17:48:08.441]                         restarts <- computeRestarts(cond)
[17:48:08.441]                         for (restart in restarts) {
[17:48:08.441]                           name <- restart$name
[17:48:08.441]                           if (is.null(name)) 
[17:48:08.441]                             next
[17:48:08.441]                           if (!grepl(pattern, name)) 
[17:48:08.441]                             next
[17:48:08.441]                           invokeRestart(restart)
[17:48:08.441]                           muffled <- TRUE
[17:48:08.441]                           break
[17:48:08.441]                         }
[17:48:08.441]                       }
[17:48:08.441]                     }
[17:48:08.441]                     invisible(muffled)
[17:48:08.441]                   }
[17:48:08.441]                   muffleCondition(cond)
[17:48:08.441]                 })
[17:48:08.441]             }))
[17:48:08.441]             future::FutureResult(value = ...future.value$value, 
[17:48:08.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:08.441]                   ...future.rng), globalenv = if (FALSE) 
[17:48:08.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:08.441]                     ...future.globalenv.names))
[17:48:08.441]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:08.441]         }, condition = base::local({
[17:48:08.441]             c <- base::c
[17:48:08.441]             inherits <- base::inherits
[17:48:08.441]             invokeRestart <- base::invokeRestart
[17:48:08.441]             length <- base::length
[17:48:08.441]             list <- base::list
[17:48:08.441]             seq.int <- base::seq.int
[17:48:08.441]             signalCondition <- base::signalCondition
[17:48:08.441]             sys.calls <- base::sys.calls
[17:48:08.441]             `[[` <- base::`[[`
[17:48:08.441]             `+` <- base::`+`
[17:48:08.441]             `<<-` <- base::`<<-`
[17:48:08.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:08.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:08.441]                   3L)]
[17:48:08.441]             }
[17:48:08.441]             function(cond) {
[17:48:08.441]                 is_error <- inherits(cond, "error")
[17:48:08.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:08.441]                   NULL)
[17:48:08.441]                 if (is_error) {
[17:48:08.441]                   sessionInformation <- function() {
[17:48:08.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:08.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:08.441]                       search = base::search(), system = base::Sys.info())
[17:48:08.441]                   }
[17:48:08.441]                   ...future.conditions[[length(...future.conditions) + 
[17:48:08.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:08.441]                     cond$call), session = sessionInformation(), 
[17:48:08.441]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:08.441]                   signalCondition(cond)
[17:48:08.441]                 }
[17:48:08.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:08.441]                 "immediateCondition"))) {
[17:48:08.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:08.441]                   ...future.conditions[[length(...future.conditions) + 
[17:48:08.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:08.441]                   if (TRUE && !signal) {
[17:48:08.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.441]                     {
[17:48:08.441]                       inherits <- base::inherits
[17:48:08.441]                       invokeRestart <- base::invokeRestart
[17:48:08.441]                       is.null <- base::is.null
[17:48:08.441]                       muffled <- FALSE
[17:48:08.441]                       if (inherits(cond, "message")) {
[17:48:08.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:08.441]                         if (muffled) 
[17:48:08.441]                           invokeRestart("muffleMessage")
[17:48:08.441]                       }
[17:48:08.441]                       else if (inherits(cond, "warning")) {
[17:48:08.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:08.441]                         if (muffled) 
[17:48:08.441]                           invokeRestart("muffleWarning")
[17:48:08.441]                       }
[17:48:08.441]                       else if (inherits(cond, "condition")) {
[17:48:08.441]                         if (!is.null(pattern)) {
[17:48:08.441]                           computeRestarts <- base::computeRestarts
[17:48:08.441]                           grepl <- base::grepl
[17:48:08.441]                           restarts <- computeRestarts(cond)
[17:48:08.441]                           for (restart in restarts) {
[17:48:08.441]                             name <- restart$name
[17:48:08.441]                             if (is.null(name)) 
[17:48:08.441]                               next
[17:48:08.441]                             if (!grepl(pattern, name)) 
[17:48:08.441]                               next
[17:48:08.441]                             invokeRestart(restart)
[17:48:08.441]                             muffled <- TRUE
[17:48:08.441]                             break
[17:48:08.441]                           }
[17:48:08.441]                         }
[17:48:08.441]                       }
[17:48:08.441]                       invisible(muffled)
[17:48:08.441]                     }
[17:48:08.441]                     muffleCondition(cond, pattern = "^muffle")
[17:48:08.441]                   }
[17:48:08.441]                 }
[17:48:08.441]                 else {
[17:48:08.441]                   if (TRUE) {
[17:48:08.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.441]                     {
[17:48:08.441]                       inherits <- base::inherits
[17:48:08.441]                       invokeRestart <- base::invokeRestart
[17:48:08.441]                       is.null <- base::is.null
[17:48:08.441]                       muffled <- FALSE
[17:48:08.441]                       if (inherits(cond, "message")) {
[17:48:08.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:08.441]                         if (muffled) 
[17:48:08.441]                           invokeRestart("muffleMessage")
[17:48:08.441]                       }
[17:48:08.441]                       else if (inherits(cond, "warning")) {
[17:48:08.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:08.441]                         if (muffled) 
[17:48:08.441]                           invokeRestart("muffleWarning")
[17:48:08.441]                       }
[17:48:08.441]                       else if (inherits(cond, "condition")) {
[17:48:08.441]                         if (!is.null(pattern)) {
[17:48:08.441]                           computeRestarts <- base::computeRestarts
[17:48:08.441]                           grepl <- base::grepl
[17:48:08.441]                           restarts <- computeRestarts(cond)
[17:48:08.441]                           for (restart in restarts) {
[17:48:08.441]                             name <- restart$name
[17:48:08.441]                             if (is.null(name)) 
[17:48:08.441]                               next
[17:48:08.441]                             if (!grepl(pattern, name)) 
[17:48:08.441]                               next
[17:48:08.441]                             invokeRestart(restart)
[17:48:08.441]                             muffled <- TRUE
[17:48:08.441]                             break
[17:48:08.441]                           }
[17:48:08.441]                         }
[17:48:08.441]                       }
[17:48:08.441]                       invisible(muffled)
[17:48:08.441]                     }
[17:48:08.441]                     muffleCondition(cond, pattern = "^muffle")
[17:48:08.441]                   }
[17:48:08.441]                 }
[17:48:08.441]             }
[17:48:08.441]         }))
[17:48:08.441]     }, error = function(ex) {
[17:48:08.441]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:08.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:08.441]                 ...future.rng), started = ...future.startTime, 
[17:48:08.441]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:08.441]             version = "1.8"), class = "FutureResult")
[17:48:08.441]     }, finally = {
[17:48:08.441]         if (!identical(...future.workdir, getwd())) 
[17:48:08.441]             setwd(...future.workdir)
[17:48:08.441]         {
[17:48:08.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:08.441]                 ...future.oldOptions$nwarnings <- NULL
[17:48:08.441]             }
[17:48:08.441]             base::options(...future.oldOptions)
[17:48:08.441]             if (.Platform$OS.type == "windows") {
[17:48:08.441]                 old_names <- names(...future.oldEnvVars)
[17:48:08.441]                 envs <- base::Sys.getenv()
[17:48:08.441]                 names <- names(envs)
[17:48:08.441]                 common <- intersect(names, old_names)
[17:48:08.441]                 added <- setdiff(names, old_names)
[17:48:08.441]                 removed <- setdiff(old_names, names)
[17:48:08.441]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:08.441]                   envs[common]]
[17:48:08.441]                 NAMES <- toupper(changed)
[17:48:08.441]                 args <- list()
[17:48:08.441]                 for (kk in seq_along(NAMES)) {
[17:48:08.441]                   name <- changed[[kk]]
[17:48:08.441]                   NAME <- NAMES[[kk]]
[17:48:08.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.441]                     next
[17:48:08.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:08.441]                 }
[17:48:08.441]                 NAMES <- toupper(added)
[17:48:08.441]                 for (kk in seq_along(NAMES)) {
[17:48:08.441]                   name <- added[[kk]]
[17:48:08.441]                   NAME <- NAMES[[kk]]
[17:48:08.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.441]                     next
[17:48:08.441]                   args[[name]] <- ""
[17:48:08.441]                 }
[17:48:08.441]                 NAMES <- toupper(removed)
[17:48:08.441]                 for (kk in seq_along(NAMES)) {
[17:48:08.441]                   name <- removed[[kk]]
[17:48:08.441]                   NAME <- NAMES[[kk]]
[17:48:08.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.441]                     next
[17:48:08.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:08.441]                 }
[17:48:08.441]                 if (length(args) > 0) 
[17:48:08.441]                   base::do.call(base::Sys.setenv, args = args)
[17:48:08.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:08.441]             }
[17:48:08.441]             else {
[17:48:08.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:08.441]             }
[17:48:08.441]             {
[17:48:08.441]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:08.441]                   0L) {
[17:48:08.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:08.441]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:08.441]                   base::options(opts)
[17:48:08.441]                 }
[17:48:08.441]                 {
[17:48:08.441]                   {
[17:48:08.441]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:08.441]                     NULL
[17:48:08.441]                   }
[17:48:08.441]                   options(future.plan = NULL)
[17:48:08.441]                   if (is.na(NA_character_)) 
[17:48:08.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:08.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:08.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:08.441]                     .init = FALSE)
[17:48:08.441]                 }
[17:48:08.441]             }
[17:48:08.441]         }
[17:48:08.441]     })
[17:48:08.441]     if (TRUE) {
[17:48:08.441]         base::sink(type = "output", split = FALSE)
[17:48:08.441]         if (TRUE) {
[17:48:08.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:08.441]         }
[17:48:08.441]         else {
[17:48:08.441]             ...future.result["stdout"] <- base::list(NULL)
[17:48:08.441]         }
[17:48:08.441]         base::close(...future.stdout)
[17:48:08.441]         ...future.stdout <- NULL
[17:48:08.441]     }
[17:48:08.441]     ...future.result$conditions <- ...future.conditions
[17:48:08.441]     ...future.result$finished <- base::Sys.time()
[17:48:08.441]     ...future.result
[17:48:08.441] }
[17:48:08.444] MultisessionFuture started
[17:48:08.444] - Launch lazy future ... done
[17:48:08.444] run() for ‘MultisessionFuture’ ... done
[17:48:08.946] receiveMessageFromWorker() for ClusterFuture ...
[17:48:08.946] - Validating connection of MultisessionFuture
[17:48:08.946] - received message: FutureResult
[17:48:08.947] - Received FutureResult
[17:48:08.947] - Erased future from FutureRegistry
[17:48:08.947] result() for ClusterFuture ...
[17:48:08.947] - result already collected: FutureResult
[17:48:08.947] result() for ClusterFuture ... done
[17:48:08.947] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:08.947] resolve() on list ...
[17:48:08.947]  recursive: 1
[17:48:08.947]  length: 2
[17:48:08.948]  elements: ‘a’, ‘b’
[17:48:08.948]  length: 1 (resolved future 1)
[17:48:08.948]  length: 0 (resolved future 2)
[17:48:08.948] resolve() on list ... DONE
[17:48:08.948] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:48:08.948] getGlobalsAndPackages() ...
[17:48:08.948] Searching for globals...
[17:48:08.949] - globals found: [2] ‘list’, ‘stop’
[17:48:08.949] Searching for globals ... DONE
[17:48:08.949] Resolving globals: FALSE
[17:48:08.949] 
[17:48:08.949] 
[17:48:08.950] getGlobalsAndPackages() ... DONE
[17:48:08.950] run() for ‘Future’ ...
[17:48:08.950] - state: ‘created’
[17:48:08.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:08.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:08.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:08.964]   - Field: ‘node’
[17:48:08.964]   - Field: ‘label’
[17:48:08.964]   - Field: ‘local’
[17:48:08.964]   - Field: ‘owner’
[17:48:08.964]   - Field: ‘envir’
[17:48:08.964]   - Field: ‘workers’
[17:48:08.965]   - Field: ‘packages’
[17:48:08.965]   - Field: ‘gc’
[17:48:08.965]   - Field: ‘conditions’
[17:48:08.965]   - Field: ‘persistent’
[17:48:08.965]   - Field: ‘expr’
[17:48:08.965]   - Field: ‘uuid’
[17:48:08.965]   - Field: ‘seed’
[17:48:08.965]   - Field: ‘version’
[17:48:08.965]   - Field: ‘result’
[17:48:08.965]   - Field: ‘asynchronous’
[17:48:08.965]   - Field: ‘calls’
[17:48:08.966]   - Field: ‘globals’
[17:48:08.966]   - Field: ‘stdout’
[17:48:08.966]   - Field: ‘earlySignal’
[17:48:08.966]   - Field: ‘lazy’
[17:48:08.966]   - Field: ‘state’
[17:48:08.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:08.966] - Launch lazy future ...
[17:48:08.966] Packages needed by the future expression (n = 0): <none>
[17:48:08.966] Packages needed by future strategies (n = 0): <none>
[17:48:08.967] {
[17:48:08.967]     {
[17:48:08.967]         {
[17:48:08.967]             ...future.startTime <- base::Sys.time()
[17:48:08.967]             {
[17:48:08.967]                 {
[17:48:08.967]                   {
[17:48:08.967]                     {
[17:48:08.967]                       base::local({
[17:48:08.967]                         has_future <- base::requireNamespace("future", 
[17:48:08.967]                           quietly = TRUE)
[17:48:08.967]                         if (has_future) {
[17:48:08.967]                           ns <- base::getNamespace("future")
[17:48:08.967]                           version <- ns[[".package"]][["version"]]
[17:48:08.967]                           if (is.null(version)) 
[17:48:08.967]                             version <- utils::packageVersion("future")
[17:48:08.967]                         }
[17:48:08.967]                         else {
[17:48:08.967]                           version <- NULL
[17:48:08.967]                         }
[17:48:08.967]                         if (!has_future || version < "1.8.0") {
[17:48:08.967]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:08.967]                             "", base::R.version$version.string), 
[17:48:08.967]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:08.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:08.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:08.967]                               "release", "version")], collapse = " "), 
[17:48:08.967]                             hostname = base::Sys.info()[["nodename"]])
[17:48:08.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:08.967]                             info)
[17:48:08.967]                           info <- base::paste(info, collapse = "; ")
[17:48:08.967]                           if (!has_future) {
[17:48:08.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:08.967]                               info)
[17:48:08.967]                           }
[17:48:08.967]                           else {
[17:48:08.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:08.967]                               info, version)
[17:48:08.967]                           }
[17:48:08.967]                           base::stop(msg)
[17:48:08.967]                         }
[17:48:08.967]                       })
[17:48:08.967]                     }
[17:48:08.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:08.967]                     base::options(mc.cores = 1L)
[17:48:08.967]                   }
[17:48:08.967]                   ...future.strategy.old <- future::plan("list")
[17:48:08.967]                   options(future.plan = NULL)
[17:48:08.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:08.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:08.967]                 }
[17:48:08.967]                 ...future.workdir <- getwd()
[17:48:08.967]             }
[17:48:08.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:08.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:08.967]         }
[17:48:08.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:08.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:08.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:08.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:08.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:08.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:08.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:08.967]             base::names(...future.oldOptions))
[17:48:08.967]     }
[17:48:08.967]     if (FALSE) {
[17:48:08.967]     }
[17:48:08.967]     else {
[17:48:08.967]         if (TRUE) {
[17:48:08.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:08.967]                 open = "w")
[17:48:08.967]         }
[17:48:08.967]         else {
[17:48:08.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:08.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:08.967]         }
[17:48:08.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:08.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:08.967]             base::sink(type = "output", split = FALSE)
[17:48:08.967]             base::close(...future.stdout)
[17:48:08.967]         }, add = TRUE)
[17:48:08.967]     }
[17:48:08.967]     ...future.frame <- base::sys.nframe()
[17:48:08.967]     ...future.conditions <- base::list()
[17:48:08.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:08.967]     if (FALSE) {
[17:48:08.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:08.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:08.967]     }
[17:48:08.967]     ...future.result <- base::tryCatch({
[17:48:08.967]         base::withCallingHandlers({
[17:48:08.967]             ...future.value <- base::withVisible(base::local({
[17:48:08.967]                 ...future.makeSendCondition <- base::local({
[17:48:08.967]                   sendCondition <- NULL
[17:48:08.967]                   function(frame = 1L) {
[17:48:08.967]                     if (is.function(sendCondition)) 
[17:48:08.967]                       return(sendCondition)
[17:48:08.967]                     ns <- getNamespace("parallel")
[17:48:08.967]                     if (exists("sendData", mode = "function", 
[17:48:08.967]                       envir = ns)) {
[17:48:08.967]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:08.967]                         envir = ns)
[17:48:08.967]                       envir <- sys.frame(frame)
[17:48:08.967]                       master <- NULL
[17:48:08.967]                       while (!identical(envir, .GlobalEnv) && 
[17:48:08.967]                         !identical(envir, emptyenv())) {
[17:48:08.967]                         if (exists("master", mode = "list", envir = envir, 
[17:48:08.967]                           inherits = FALSE)) {
[17:48:08.967]                           master <- get("master", mode = "list", 
[17:48:08.967]                             envir = envir, inherits = FALSE)
[17:48:08.967]                           if (inherits(master, c("SOCKnode", 
[17:48:08.967]                             "SOCK0node"))) {
[17:48:08.967]                             sendCondition <<- function(cond) {
[17:48:08.967]                               data <- list(type = "VALUE", value = cond, 
[17:48:08.967]                                 success = TRUE)
[17:48:08.967]                               parallel_sendData(master, data)
[17:48:08.967]                             }
[17:48:08.967]                             return(sendCondition)
[17:48:08.967]                           }
[17:48:08.967]                         }
[17:48:08.967]                         frame <- frame + 1L
[17:48:08.967]                         envir <- sys.frame(frame)
[17:48:08.967]                       }
[17:48:08.967]                     }
[17:48:08.967]                     sendCondition <<- function(cond) NULL
[17:48:08.967]                   }
[17:48:08.967]                 })
[17:48:08.967]                 withCallingHandlers({
[17:48:08.967]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:08.967]                 }, immediateCondition = function(cond) {
[17:48:08.967]                   sendCondition <- ...future.makeSendCondition()
[17:48:08.967]                   sendCondition(cond)
[17:48:08.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.967]                   {
[17:48:08.967]                     inherits <- base::inherits
[17:48:08.967]                     invokeRestart <- base::invokeRestart
[17:48:08.967]                     is.null <- base::is.null
[17:48:08.967]                     muffled <- FALSE
[17:48:08.967]                     if (inherits(cond, "message")) {
[17:48:08.967]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:08.967]                       if (muffled) 
[17:48:08.967]                         invokeRestart("muffleMessage")
[17:48:08.967]                     }
[17:48:08.967]                     else if (inherits(cond, "warning")) {
[17:48:08.967]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:08.967]                       if (muffled) 
[17:48:08.967]                         invokeRestart("muffleWarning")
[17:48:08.967]                     }
[17:48:08.967]                     else if (inherits(cond, "condition")) {
[17:48:08.967]                       if (!is.null(pattern)) {
[17:48:08.967]                         computeRestarts <- base::computeRestarts
[17:48:08.967]                         grepl <- base::grepl
[17:48:08.967]                         restarts <- computeRestarts(cond)
[17:48:08.967]                         for (restart in restarts) {
[17:48:08.967]                           name <- restart$name
[17:48:08.967]                           if (is.null(name)) 
[17:48:08.967]                             next
[17:48:08.967]                           if (!grepl(pattern, name)) 
[17:48:08.967]                             next
[17:48:08.967]                           invokeRestart(restart)
[17:48:08.967]                           muffled <- TRUE
[17:48:08.967]                           break
[17:48:08.967]                         }
[17:48:08.967]                       }
[17:48:08.967]                     }
[17:48:08.967]                     invisible(muffled)
[17:48:08.967]                   }
[17:48:08.967]                   muffleCondition(cond)
[17:48:08.967]                 })
[17:48:08.967]             }))
[17:48:08.967]             future::FutureResult(value = ...future.value$value, 
[17:48:08.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:08.967]                   ...future.rng), globalenv = if (FALSE) 
[17:48:08.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:08.967]                     ...future.globalenv.names))
[17:48:08.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:08.967]         }, condition = base::local({
[17:48:08.967]             c <- base::c
[17:48:08.967]             inherits <- base::inherits
[17:48:08.967]             invokeRestart <- base::invokeRestart
[17:48:08.967]             length <- base::length
[17:48:08.967]             list <- base::list
[17:48:08.967]             seq.int <- base::seq.int
[17:48:08.967]             signalCondition <- base::signalCondition
[17:48:08.967]             sys.calls <- base::sys.calls
[17:48:08.967]             `[[` <- base::`[[`
[17:48:08.967]             `+` <- base::`+`
[17:48:08.967]             `<<-` <- base::`<<-`
[17:48:08.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:08.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:08.967]                   3L)]
[17:48:08.967]             }
[17:48:08.967]             function(cond) {
[17:48:08.967]                 is_error <- inherits(cond, "error")
[17:48:08.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:08.967]                   NULL)
[17:48:08.967]                 if (is_error) {
[17:48:08.967]                   sessionInformation <- function() {
[17:48:08.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:08.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:08.967]                       search = base::search(), system = base::Sys.info())
[17:48:08.967]                   }
[17:48:08.967]                   ...future.conditions[[length(...future.conditions) + 
[17:48:08.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:08.967]                     cond$call), session = sessionInformation(), 
[17:48:08.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:08.967]                   signalCondition(cond)
[17:48:08.967]                 }
[17:48:08.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:08.967]                 "immediateCondition"))) {
[17:48:08.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:08.967]                   ...future.conditions[[length(...future.conditions) + 
[17:48:08.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:08.967]                   if (TRUE && !signal) {
[17:48:08.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.967]                     {
[17:48:08.967]                       inherits <- base::inherits
[17:48:08.967]                       invokeRestart <- base::invokeRestart
[17:48:08.967]                       is.null <- base::is.null
[17:48:08.967]                       muffled <- FALSE
[17:48:08.967]                       if (inherits(cond, "message")) {
[17:48:08.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:08.967]                         if (muffled) 
[17:48:08.967]                           invokeRestart("muffleMessage")
[17:48:08.967]                       }
[17:48:08.967]                       else if (inherits(cond, "warning")) {
[17:48:08.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:08.967]                         if (muffled) 
[17:48:08.967]                           invokeRestart("muffleWarning")
[17:48:08.967]                       }
[17:48:08.967]                       else if (inherits(cond, "condition")) {
[17:48:08.967]                         if (!is.null(pattern)) {
[17:48:08.967]                           computeRestarts <- base::computeRestarts
[17:48:08.967]                           grepl <- base::grepl
[17:48:08.967]                           restarts <- computeRestarts(cond)
[17:48:08.967]                           for (restart in restarts) {
[17:48:08.967]                             name <- restart$name
[17:48:08.967]                             if (is.null(name)) 
[17:48:08.967]                               next
[17:48:08.967]                             if (!grepl(pattern, name)) 
[17:48:08.967]                               next
[17:48:08.967]                             invokeRestart(restart)
[17:48:08.967]                             muffled <- TRUE
[17:48:08.967]                             break
[17:48:08.967]                           }
[17:48:08.967]                         }
[17:48:08.967]                       }
[17:48:08.967]                       invisible(muffled)
[17:48:08.967]                     }
[17:48:08.967]                     muffleCondition(cond, pattern = "^muffle")
[17:48:08.967]                   }
[17:48:08.967]                 }
[17:48:08.967]                 else {
[17:48:08.967]                   if (TRUE) {
[17:48:08.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.967]                     {
[17:48:08.967]                       inherits <- base::inherits
[17:48:08.967]                       invokeRestart <- base::invokeRestart
[17:48:08.967]                       is.null <- base::is.null
[17:48:08.967]                       muffled <- FALSE
[17:48:08.967]                       if (inherits(cond, "message")) {
[17:48:08.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:08.967]                         if (muffled) 
[17:48:08.967]                           invokeRestart("muffleMessage")
[17:48:08.967]                       }
[17:48:08.967]                       else if (inherits(cond, "warning")) {
[17:48:08.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:08.967]                         if (muffled) 
[17:48:08.967]                           invokeRestart("muffleWarning")
[17:48:08.967]                       }
[17:48:08.967]                       else if (inherits(cond, "condition")) {
[17:48:08.967]                         if (!is.null(pattern)) {
[17:48:08.967]                           computeRestarts <- base::computeRestarts
[17:48:08.967]                           grepl <- base::grepl
[17:48:08.967]                           restarts <- computeRestarts(cond)
[17:48:08.967]                           for (restart in restarts) {
[17:48:08.967]                             name <- restart$name
[17:48:08.967]                             if (is.null(name)) 
[17:48:08.967]                               next
[17:48:08.967]                             if (!grepl(pattern, name)) 
[17:48:08.967]                               next
[17:48:08.967]                             invokeRestart(restart)
[17:48:08.967]                             muffled <- TRUE
[17:48:08.967]                             break
[17:48:08.967]                           }
[17:48:08.967]                         }
[17:48:08.967]                       }
[17:48:08.967]                       invisible(muffled)
[17:48:08.967]                     }
[17:48:08.967]                     muffleCondition(cond, pattern = "^muffle")
[17:48:08.967]                   }
[17:48:08.967]                 }
[17:48:08.967]             }
[17:48:08.967]         }))
[17:48:08.967]     }, error = function(ex) {
[17:48:08.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:08.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:08.967]                 ...future.rng), started = ...future.startTime, 
[17:48:08.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:08.967]             version = "1.8"), class = "FutureResult")
[17:48:08.967]     }, finally = {
[17:48:08.967]         if (!identical(...future.workdir, getwd())) 
[17:48:08.967]             setwd(...future.workdir)
[17:48:08.967]         {
[17:48:08.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:08.967]                 ...future.oldOptions$nwarnings <- NULL
[17:48:08.967]             }
[17:48:08.967]             base::options(...future.oldOptions)
[17:48:08.967]             if (.Platform$OS.type == "windows") {
[17:48:08.967]                 old_names <- names(...future.oldEnvVars)
[17:48:08.967]                 envs <- base::Sys.getenv()
[17:48:08.967]                 names <- names(envs)
[17:48:08.967]                 common <- intersect(names, old_names)
[17:48:08.967]                 added <- setdiff(names, old_names)
[17:48:08.967]                 removed <- setdiff(old_names, names)
[17:48:08.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:08.967]                   envs[common]]
[17:48:08.967]                 NAMES <- toupper(changed)
[17:48:08.967]                 args <- list()
[17:48:08.967]                 for (kk in seq_along(NAMES)) {
[17:48:08.967]                   name <- changed[[kk]]
[17:48:08.967]                   NAME <- NAMES[[kk]]
[17:48:08.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.967]                     next
[17:48:08.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:08.967]                 }
[17:48:08.967]                 NAMES <- toupper(added)
[17:48:08.967]                 for (kk in seq_along(NAMES)) {
[17:48:08.967]                   name <- added[[kk]]
[17:48:08.967]                   NAME <- NAMES[[kk]]
[17:48:08.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.967]                     next
[17:48:08.967]                   args[[name]] <- ""
[17:48:08.967]                 }
[17:48:08.967]                 NAMES <- toupper(removed)
[17:48:08.967]                 for (kk in seq_along(NAMES)) {
[17:48:08.967]                   name <- removed[[kk]]
[17:48:08.967]                   NAME <- NAMES[[kk]]
[17:48:08.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.967]                     next
[17:48:08.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:08.967]                 }
[17:48:08.967]                 if (length(args) > 0) 
[17:48:08.967]                   base::do.call(base::Sys.setenv, args = args)
[17:48:08.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:08.967]             }
[17:48:08.967]             else {
[17:48:08.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:08.967]             }
[17:48:08.967]             {
[17:48:08.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:08.967]                   0L) {
[17:48:08.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:08.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:08.967]                   base::options(opts)
[17:48:08.967]                 }
[17:48:08.967]                 {
[17:48:08.967]                   {
[17:48:08.967]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:08.967]                     NULL
[17:48:08.967]                   }
[17:48:08.967]                   options(future.plan = NULL)
[17:48:08.967]                   if (is.na(NA_character_)) 
[17:48:08.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:08.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:08.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:08.967]                     .init = FALSE)
[17:48:08.967]                 }
[17:48:08.967]             }
[17:48:08.967]         }
[17:48:08.967]     })
[17:48:08.967]     if (TRUE) {
[17:48:08.967]         base::sink(type = "output", split = FALSE)
[17:48:08.967]         if (TRUE) {
[17:48:08.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:08.967]         }
[17:48:08.967]         else {
[17:48:08.967]             ...future.result["stdout"] <- base::list(NULL)
[17:48:08.967]         }
[17:48:08.967]         base::close(...future.stdout)
[17:48:08.967]         ...future.stdout <- NULL
[17:48:08.967]     }
[17:48:08.967]     ...future.result$conditions <- ...future.conditions
[17:48:08.967]     ...future.result$finished <- base::Sys.time()
[17:48:08.967]     ...future.result
[17:48:08.967] }
[17:48:08.970] MultisessionFuture started
[17:48:08.970] - Launch lazy future ... done
[17:48:08.970] run() for ‘MultisessionFuture’ ... done
[17:48:08.971] receiveMessageFromWorker() for ClusterFuture ...
[17:48:08.972] - Validating connection of MultisessionFuture
[17:48:08.972] - received message: FutureResult
[17:48:08.972] - Received FutureResult
[17:48:08.972] - Erased future from FutureRegistry
[17:48:08.972] result() for ClusterFuture ...
[17:48:08.972] - result already collected: FutureResult
[17:48:08.972] result() for ClusterFuture ... done
[17:48:08.972] signalConditions() ...
[17:48:08.973]  - include = ‘immediateCondition’
[17:48:08.973]  - exclude = 
[17:48:08.973]  - resignal = FALSE
[17:48:08.973]  - Number of conditions: 1
[17:48:08.973] signalConditions() ... done
[17:48:08.973] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:08.973] A MultisessionFuture was resolved (and resolved itself)
[17:48:08.973] getGlobalsAndPackages() ...
[17:48:08.973] Searching for globals...
[17:48:08.974] - globals found: [2] ‘list’, ‘stop’
[17:48:08.974] Searching for globals ... DONE
[17:48:08.974] Resolving globals: FALSE
[17:48:08.974] 
[17:48:08.974] 
[17:48:08.975] getGlobalsAndPackages() ... DONE
[17:48:08.975] run() for ‘Future’ ...
[17:48:08.975] - state: ‘created’
[17:48:08.975] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:08.988] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:08.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:08.989]   - Field: ‘node’
[17:48:08.989]   - Field: ‘label’
[17:48:08.989]   - Field: ‘local’
[17:48:08.989]   - Field: ‘owner’
[17:48:08.989]   - Field: ‘envir’
[17:48:08.989]   - Field: ‘workers’
[17:48:08.989]   - Field: ‘packages’
[17:48:08.989]   - Field: ‘gc’
[17:48:08.989]   - Field: ‘conditions’
[17:48:08.990]   - Field: ‘persistent’
[17:48:08.990]   - Field: ‘expr’
[17:48:08.990]   - Field: ‘uuid’
[17:48:08.992]   - Field: ‘seed’
[17:48:08.992]   - Field: ‘version’
[17:48:08.992]   - Field: ‘result’
[17:48:08.992]   - Field: ‘asynchronous’
[17:48:08.993]   - Field: ‘calls’
[17:48:08.993]   - Field: ‘globals’
[17:48:08.993]   - Field: ‘stdout’
[17:48:08.993]   - Field: ‘earlySignal’
[17:48:08.993]   - Field: ‘lazy’
[17:48:08.993]   - Field: ‘state’
[17:48:08.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:08.993] - Launch lazy future ...
[17:48:08.994] Packages needed by the future expression (n = 0): <none>
[17:48:08.994] Packages needed by future strategies (n = 0): <none>
[17:48:08.994] {
[17:48:08.994]     {
[17:48:08.994]         {
[17:48:08.994]             ...future.startTime <- base::Sys.time()
[17:48:08.994]             {
[17:48:08.994]                 {
[17:48:08.994]                   {
[17:48:08.994]                     {
[17:48:08.994]                       base::local({
[17:48:08.994]                         has_future <- base::requireNamespace("future", 
[17:48:08.994]                           quietly = TRUE)
[17:48:08.994]                         if (has_future) {
[17:48:08.994]                           ns <- base::getNamespace("future")
[17:48:08.994]                           version <- ns[[".package"]][["version"]]
[17:48:08.994]                           if (is.null(version)) 
[17:48:08.994]                             version <- utils::packageVersion("future")
[17:48:08.994]                         }
[17:48:08.994]                         else {
[17:48:08.994]                           version <- NULL
[17:48:08.994]                         }
[17:48:08.994]                         if (!has_future || version < "1.8.0") {
[17:48:08.994]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:08.994]                             "", base::R.version$version.string), 
[17:48:08.994]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:08.994]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:08.994]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:08.994]                               "release", "version")], collapse = " "), 
[17:48:08.994]                             hostname = base::Sys.info()[["nodename"]])
[17:48:08.994]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:08.994]                             info)
[17:48:08.994]                           info <- base::paste(info, collapse = "; ")
[17:48:08.994]                           if (!has_future) {
[17:48:08.994]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:08.994]                               info)
[17:48:08.994]                           }
[17:48:08.994]                           else {
[17:48:08.994]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:08.994]                               info, version)
[17:48:08.994]                           }
[17:48:08.994]                           base::stop(msg)
[17:48:08.994]                         }
[17:48:08.994]                       })
[17:48:08.994]                     }
[17:48:08.994]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:08.994]                     base::options(mc.cores = 1L)
[17:48:08.994]                   }
[17:48:08.994]                   ...future.strategy.old <- future::plan("list")
[17:48:08.994]                   options(future.plan = NULL)
[17:48:08.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:08.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:08.994]                 }
[17:48:08.994]                 ...future.workdir <- getwd()
[17:48:08.994]             }
[17:48:08.994]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:08.994]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:08.994]         }
[17:48:08.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:08.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:08.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:08.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:08.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:08.994]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:08.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:08.994]             base::names(...future.oldOptions))
[17:48:08.994]     }
[17:48:08.994]     if (FALSE) {
[17:48:08.994]     }
[17:48:08.994]     else {
[17:48:08.994]         if (TRUE) {
[17:48:08.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:08.994]                 open = "w")
[17:48:08.994]         }
[17:48:08.994]         else {
[17:48:08.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:08.994]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:08.994]         }
[17:48:08.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:08.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:08.994]             base::sink(type = "output", split = FALSE)
[17:48:08.994]             base::close(...future.stdout)
[17:48:08.994]         }, add = TRUE)
[17:48:08.994]     }
[17:48:08.994]     ...future.frame <- base::sys.nframe()
[17:48:08.994]     ...future.conditions <- base::list()
[17:48:08.994]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:08.994]     if (FALSE) {
[17:48:08.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:08.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:08.994]     }
[17:48:08.994]     ...future.result <- base::tryCatch({
[17:48:08.994]         base::withCallingHandlers({
[17:48:08.994]             ...future.value <- base::withVisible(base::local({
[17:48:08.994]                 ...future.makeSendCondition <- base::local({
[17:48:08.994]                   sendCondition <- NULL
[17:48:08.994]                   function(frame = 1L) {
[17:48:08.994]                     if (is.function(sendCondition)) 
[17:48:08.994]                       return(sendCondition)
[17:48:08.994]                     ns <- getNamespace("parallel")
[17:48:08.994]                     if (exists("sendData", mode = "function", 
[17:48:08.994]                       envir = ns)) {
[17:48:08.994]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:08.994]                         envir = ns)
[17:48:08.994]                       envir <- sys.frame(frame)
[17:48:08.994]                       master <- NULL
[17:48:08.994]                       while (!identical(envir, .GlobalEnv) && 
[17:48:08.994]                         !identical(envir, emptyenv())) {
[17:48:08.994]                         if (exists("master", mode = "list", envir = envir, 
[17:48:08.994]                           inherits = FALSE)) {
[17:48:08.994]                           master <- get("master", mode = "list", 
[17:48:08.994]                             envir = envir, inherits = FALSE)
[17:48:08.994]                           if (inherits(master, c("SOCKnode", 
[17:48:08.994]                             "SOCK0node"))) {
[17:48:08.994]                             sendCondition <<- function(cond) {
[17:48:08.994]                               data <- list(type = "VALUE", value = cond, 
[17:48:08.994]                                 success = TRUE)
[17:48:08.994]                               parallel_sendData(master, data)
[17:48:08.994]                             }
[17:48:08.994]                             return(sendCondition)
[17:48:08.994]                           }
[17:48:08.994]                         }
[17:48:08.994]                         frame <- frame + 1L
[17:48:08.994]                         envir <- sys.frame(frame)
[17:48:08.994]                       }
[17:48:08.994]                     }
[17:48:08.994]                     sendCondition <<- function(cond) NULL
[17:48:08.994]                   }
[17:48:08.994]                 })
[17:48:08.994]                 withCallingHandlers({
[17:48:08.994]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:08.994]                 }, immediateCondition = function(cond) {
[17:48:08.994]                   sendCondition <- ...future.makeSendCondition()
[17:48:08.994]                   sendCondition(cond)
[17:48:08.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.994]                   {
[17:48:08.994]                     inherits <- base::inherits
[17:48:08.994]                     invokeRestart <- base::invokeRestart
[17:48:08.994]                     is.null <- base::is.null
[17:48:08.994]                     muffled <- FALSE
[17:48:08.994]                     if (inherits(cond, "message")) {
[17:48:08.994]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:08.994]                       if (muffled) 
[17:48:08.994]                         invokeRestart("muffleMessage")
[17:48:08.994]                     }
[17:48:08.994]                     else if (inherits(cond, "warning")) {
[17:48:08.994]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:08.994]                       if (muffled) 
[17:48:08.994]                         invokeRestart("muffleWarning")
[17:48:08.994]                     }
[17:48:08.994]                     else if (inherits(cond, "condition")) {
[17:48:08.994]                       if (!is.null(pattern)) {
[17:48:08.994]                         computeRestarts <- base::computeRestarts
[17:48:08.994]                         grepl <- base::grepl
[17:48:08.994]                         restarts <- computeRestarts(cond)
[17:48:08.994]                         for (restart in restarts) {
[17:48:08.994]                           name <- restart$name
[17:48:08.994]                           if (is.null(name)) 
[17:48:08.994]                             next
[17:48:08.994]                           if (!grepl(pattern, name)) 
[17:48:08.994]                             next
[17:48:08.994]                           invokeRestart(restart)
[17:48:08.994]                           muffled <- TRUE
[17:48:08.994]                           break
[17:48:08.994]                         }
[17:48:08.994]                       }
[17:48:08.994]                     }
[17:48:08.994]                     invisible(muffled)
[17:48:08.994]                   }
[17:48:08.994]                   muffleCondition(cond)
[17:48:08.994]                 })
[17:48:08.994]             }))
[17:48:08.994]             future::FutureResult(value = ...future.value$value, 
[17:48:08.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:08.994]                   ...future.rng), globalenv = if (FALSE) 
[17:48:08.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:08.994]                     ...future.globalenv.names))
[17:48:08.994]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:08.994]         }, condition = base::local({
[17:48:08.994]             c <- base::c
[17:48:08.994]             inherits <- base::inherits
[17:48:08.994]             invokeRestart <- base::invokeRestart
[17:48:08.994]             length <- base::length
[17:48:08.994]             list <- base::list
[17:48:08.994]             seq.int <- base::seq.int
[17:48:08.994]             signalCondition <- base::signalCondition
[17:48:08.994]             sys.calls <- base::sys.calls
[17:48:08.994]             `[[` <- base::`[[`
[17:48:08.994]             `+` <- base::`+`
[17:48:08.994]             `<<-` <- base::`<<-`
[17:48:08.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:08.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:08.994]                   3L)]
[17:48:08.994]             }
[17:48:08.994]             function(cond) {
[17:48:08.994]                 is_error <- inherits(cond, "error")
[17:48:08.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:08.994]                   NULL)
[17:48:08.994]                 if (is_error) {
[17:48:08.994]                   sessionInformation <- function() {
[17:48:08.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:08.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:08.994]                       search = base::search(), system = base::Sys.info())
[17:48:08.994]                   }
[17:48:08.994]                   ...future.conditions[[length(...future.conditions) + 
[17:48:08.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:08.994]                     cond$call), session = sessionInformation(), 
[17:48:08.994]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:08.994]                   signalCondition(cond)
[17:48:08.994]                 }
[17:48:08.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:08.994]                 "immediateCondition"))) {
[17:48:08.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:08.994]                   ...future.conditions[[length(...future.conditions) + 
[17:48:08.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:08.994]                   if (TRUE && !signal) {
[17:48:08.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.994]                     {
[17:48:08.994]                       inherits <- base::inherits
[17:48:08.994]                       invokeRestart <- base::invokeRestart
[17:48:08.994]                       is.null <- base::is.null
[17:48:08.994]                       muffled <- FALSE
[17:48:08.994]                       if (inherits(cond, "message")) {
[17:48:08.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:08.994]                         if (muffled) 
[17:48:08.994]                           invokeRestart("muffleMessage")
[17:48:08.994]                       }
[17:48:08.994]                       else if (inherits(cond, "warning")) {
[17:48:08.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:08.994]                         if (muffled) 
[17:48:08.994]                           invokeRestart("muffleWarning")
[17:48:08.994]                       }
[17:48:08.994]                       else if (inherits(cond, "condition")) {
[17:48:08.994]                         if (!is.null(pattern)) {
[17:48:08.994]                           computeRestarts <- base::computeRestarts
[17:48:08.994]                           grepl <- base::grepl
[17:48:08.994]                           restarts <- computeRestarts(cond)
[17:48:08.994]                           for (restart in restarts) {
[17:48:08.994]                             name <- restart$name
[17:48:08.994]                             if (is.null(name)) 
[17:48:08.994]                               next
[17:48:08.994]                             if (!grepl(pattern, name)) 
[17:48:08.994]                               next
[17:48:08.994]                             invokeRestart(restart)
[17:48:08.994]                             muffled <- TRUE
[17:48:08.994]                             break
[17:48:08.994]                           }
[17:48:08.994]                         }
[17:48:08.994]                       }
[17:48:08.994]                       invisible(muffled)
[17:48:08.994]                     }
[17:48:08.994]                     muffleCondition(cond, pattern = "^muffle")
[17:48:08.994]                   }
[17:48:08.994]                 }
[17:48:08.994]                 else {
[17:48:08.994]                   if (TRUE) {
[17:48:08.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:08.994]                     {
[17:48:08.994]                       inherits <- base::inherits
[17:48:08.994]                       invokeRestart <- base::invokeRestart
[17:48:08.994]                       is.null <- base::is.null
[17:48:08.994]                       muffled <- FALSE
[17:48:08.994]                       if (inherits(cond, "message")) {
[17:48:08.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:08.994]                         if (muffled) 
[17:48:08.994]                           invokeRestart("muffleMessage")
[17:48:08.994]                       }
[17:48:08.994]                       else if (inherits(cond, "warning")) {
[17:48:08.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:08.994]                         if (muffled) 
[17:48:08.994]                           invokeRestart("muffleWarning")
[17:48:08.994]                       }
[17:48:08.994]                       else if (inherits(cond, "condition")) {
[17:48:08.994]                         if (!is.null(pattern)) {
[17:48:08.994]                           computeRestarts <- base::computeRestarts
[17:48:08.994]                           grepl <- base::grepl
[17:48:08.994]                           restarts <- computeRestarts(cond)
[17:48:08.994]                           for (restart in restarts) {
[17:48:08.994]                             name <- restart$name
[17:48:08.994]                             if (is.null(name)) 
[17:48:08.994]                               next
[17:48:08.994]                             if (!grepl(pattern, name)) 
[17:48:08.994]                               next
[17:48:08.994]                             invokeRestart(restart)
[17:48:08.994]                             muffled <- TRUE
[17:48:08.994]                             break
[17:48:08.994]                           }
[17:48:08.994]                         }
[17:48:08.994]                       }
[17:48:08.994]                       invisible(muffled)
[17:48:08.994]                     }
[17:48:08.994]                     muffleCondition(cond, pattern = "^muffle")
[17:48:08.994]                   }
[17:48:08.994]                 }
[17:48:08.994]             }
[17:48:08.994]         }))
[17:48:08.994]     }, error = function(ex) {
[17:48:08.994]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:08.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:08.994]                 ...future.rng), started = ...future.startTime, 
[17:48:08.994]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:08.994]             version = "1.8"), class = "FutureResult")
[17:48:08.994]     }, finally = {
[17:48:08.994]         if (!identical(...future.workdir, getwd())) 
[17:48:08.994]             setwd(...future.workdir)
[17:48:08.994]         {
[17:48:08.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:08.994]                 ...future.oldOptions$nwarnings <- NULL
[17:48:08.994]             }
[17:48:08.994]             base::options(...future.oldOptions)
[17:48:08.994]             if (.Platform$OS.type == "windows") {
[17:48:08.994]                 old_names <- names(...future.oldEnvVars)
[17:48:08.994]                 envs <- base::Sys.getenv()
[17:48:08.994]                 names <- names(envs)
[17:48:08.994]                 common <- intersect(names, old_names)
[17:48:08.994]                 added <- setdiff(names, old_names)
[17:48:08.994]                 removed <- setdiff(old_names, names)
[17:48:08.994]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:08.994]                   envs[common]]
[17:48:08.994]                 NAMES <- toupper(changed)
[17:48:08.994]                 args <- list()
[17:48:08.994]                 for (kk in seq_along(NAMES)) {
[17:48:08.994]                   name <- changed[[kk]]
[17:48:08.994]                   NAME <- NAMES[[kk]]
[17:48:08.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.994]                     next
[17:48:08.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:08.994]                 }
[17:48:08.994]                 NAMES <- toupper(added)
[17:48:08.994]                 for (kk in seq_along(NAMES)) {
[17:48:08.994]                   name <- added[[kk]]
[17:48:08.994]                   NAME <- NAMES[[kk]]
[17:48:08.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.994]                     next
[17:48:08.994]                   args[[name]] <- ""
[17:48:08.994]                 }
[17:48:08.994]                 NAMES <- toupper(removed)
[17:48:08.994]                 for (kk in seq_along(NAMES)) {
[17:48:08.994]                   name <- removed[[kk]]
[17:48:08.994]                   NAME <- NAMES[[kk]]
[17:48:08.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:08.994]                     next
[17:48:08.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:08.994]                 }
[17:48:08.994]                 if (length(args) > 0) 
[17:48:08.994]                   base::do.call(base::Sys.setenv, args = args)
[17:48:08.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:08.994]             }
[17:48:08.994]             else {
[17:48:08.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:08.994]             }
[17:48:08.994]             {
[17:48:08.994]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:08.994]                   0L) {
[17:48:08.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:08.994]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:08.994]                   base::options(opts)
[17:48:08.994]                 }
[17:48:08.994]                 {
[17:48:08.994]                   {
[17:48:08.994]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:08.994]                     NULL
[17:48:08.994]                   }
[17:48:08.994]                   options(future.plan = NULL)
[17:48:08.994]                   if (is.na(NA_character_)) 
[17:48:08.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:08.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:08.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:08.994]                     .init = FALSE)
[17:48:08.994]                 }
[17:48:08.994]             }
[17:48:08.994]         }
[17:48:08.994]     })
[17:48:08.994]     if (TRUE) {
[17:48:08.994]         base::sink(type = "output", split = FALSE)
[17:48:08.994]         if (TRUE) {
[17:48:08.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:08.994]         }
[17:48:08.994]         else {
[17:48:08.994]             ...future.result["stdout"] <- base::list(NULL)
[17:48:08.994]         }
[17:48:08.994]         base::close(...future.stdout)
[17:48:08.994]         ...future.stdout <- NULL
[17:48:08.994]     }
[17:48:08.994]     ...future.result$conditions <- ...future.conditions
[17:48:08.994]     ...future.result$finished <- base::Sys.time()
[17:48:08.994]     ...future.result
[17:48:08.994] }
[17:48:08.997] MultisessionFuture started
[17:48:08.997] - Launch lazy future ... done
[17:48:08.997] run() for ‘MultisessionFuture’ ... done
[17:48:08.998] receiveMessageFromWorker() for ClusterFuture ...
[17:48:08.999] - Validating connection of MultisessionFuture
[17:48:08.999] - received message: FutureResult
[17:48:08.999] - Received FutureResult
[17:48:08.999] - Erased future from FutureRegistry
[17:48:08.999] result() for ClusterFuture ...
[17:48:08.999] - result already collected: FutureResult
[17:48:09.000] result() for ClusterFuture ... done
[17:48:09.000] signalConditions() ...
[17:48:09.000]  - include = ‘immediateCondition’
[17:48:09.000]  - exclude = 
[17:48:09.000]  - resignal = FALSE
[17:48:09.000]  - Number of conditions: 1
[17:48:09.000] signalConditions() ... done
[17:48:09.000] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:09.000] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[17:48:09.000] getGlobalsAndPackages() ...
[17:48:09.001] Searching for globals...
[17:48:09.002] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:09.002] Searching for globals ... DONE
[17:48:09.002] Resolving globals: FALSE
[17:48:09.002] 
[17:48:09.002] 
[17:48:09.002] getGlobalsAndPackages() ... DONE
[17:48:09.003] run() for ‘Future’ ...
[17:48:09.003] - state: ‘created’
[17:48:09.003] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:09.016] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:09.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:09.016]   - Field: ‘node’
[17:48:09.016]   - Field: ‘label’
[17:48:09.016]   - Field: ‘local’
[17:48:09.017]   - Field: ‘owner’
[17:48:09.017]   - Field: ‘envir’
[17:48:09.017]   - Field: ‘workers’
[17:48:09.017]   - Field: ‘packages’
[17:48:09.017]   - Field: ‘gc’
[17:48:09.017]   - Field: ‘conditions’
[17:48:09.017]   - Field: ‘persistent’
[17:48:09.017]   - Field: ‘expr’
[17:48:09.017]   - Field: ‘uuid’
[17:48:09.017]   - Field: ‘seed’
[17:48:09.017]   - Field: ‘version’
[17:48:09.018]   - Field: ‘result’
[17:48:09.018]   - Field: ‘asynchronous’
[17:48:09.018]   - Field: ‘calls’
[17:48:09.018]   - Field: ‘globals’
[17:48:09.018]   - Field: ‘stdout’
[17:48:09.018]   - Field: ‘earlySignal’
[17:48:09.018]   - Field: ‘lazy’
[17:48:09.018]   - Field: ‘state’
[17:48:09.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:09.018] - Launch lazy future ...
[17:48:09.019] Packages needed by the future expression (n = 0): <none>
[17:48:09.019] Packages needed by future strategies (n = 0): <none>
[17:48:09.019] {
[17:48:09.019]     {
[17:48:09.019]         {
[17:48:09.019]             ...future.startTime <- base::Sys.time()
[17:48:09.019]             {
[17:48:09.019]                 {
[17:48:09.019]                   {
[17:48:09.019]                     {
[17:48:09.019]                       base::local({
[17:48:09.019]                         has_future <- base::requireNamespace("future", 
[17:48:09.019]                           quietly = TRUE)
[17:48:09.019]                         if (has_future) {
[17:48:09.019]                           ns <- base::getNamespace("future")
[17:48:09.019]                           version <- ns[[".package"]][["version"]]
[17:48:09.019]                           if (is.null(version)) 
[17:48:09.019]                             version <- utils::packageVersion("future")
[17:48:09.019]                         }
[17:48:09.019]                         else {
[17:48:09.019]                           version <- NULL
[17:48:09.019]                         }
[17:48:09.019]                         if (!has_future || version < "1.8.0") {
[17:48:09.019]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:09.019]                             "", base::R.version$version.string), 
[17:48:09.019]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:09.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:09.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:09.019]                               "release", "version")], collapse = " "), 
[17:48:09.019]                             hostname = base::Sys.info()[["nodename"]])
[17:48:09.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:09.019]                             info)
[17:48:09.019]                           info <- base::paste(info, collapse = "; ")
[17:48:09.019]                           if (!has_future) {
[17:48:09.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:09.019]                               info)
[17:48:09.019]                           }
[17:48:09.019]                           else {
[17:48:09.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:09.019]                               info, version)
[17:48:09.019]                           }
[17:48:09.019]                           base::stop(msg)
[17:48:09.019]                         }
[17:48:09.019]                       })
[17:48:09.019]                     }
[17:48:09.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:09.019]                     base::options(mc.cores = 1L)
[17:48:09.019]                   }
[17:48:09.019]                   ...future.strategy.old <- future::plan("list")
[17:48:09.019]                   options(future.plan = NULL)
[17:48:09.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:09.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:09.019]                 }
[17:48:09.019]                 ...future.workdir <- getwd()
[17:48:09.019]             }
[17:48:09.019]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:09.019]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:09.019]         }
[17:48:09.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:09.019]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:09.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:09.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:09.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:09.019]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:09.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:09.019]             base::names(...future.oldOptions))
[17:48:09.019]     }
[17:48:09.019]     if (FALSE) {
[17:48:09.019]     }
[17:48:09.019]     else {
[17:48:09.019]         if (TRUE) {
[17:48:09.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:09.019]                 open = "w")
[17:48:09.019]         }
[17:48:09.019]         else {
[17:48:09.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:09.019]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:09.019]         }
[17:48:09.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:09.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:09.019]             base::sink(type = "output", split = FALSE)
[17:48:09.019]             base::close(...future.stdout)
[17:48:09.019]         }, add = TRUE)
[17:48:09.019]     }
[17:48:09.019]     ...future.frame <- base::sys.nframe()
[17:48:09.019]     ...future.conditions <- base::list()
[17:48:09.019]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:09.019]     if (FALSE) {
[17:48:09.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:09.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:09.019]     }
[17:48:09.019]     ...future.result <- base::tryCatch({
[17:48:09.019]         base::withCallingHandlers({
[17:48:09.019]             ...future.value <- base::withVisible(base::local({
[17:48:09.019]                 ...future.makeSendCondition <- base::local({
[17:48:09.019]                   sendCondition <- NULL
[17:48:09.019]                   function(frame = 1L) {
[17:48:09.019]                     if (is.function(sendCondition)) 
[17:48:09.019]                       return(sendCondition)
[17:48:09.019]                     ns <- getNamespace("parallel")
[17:48:09.019]                     if (exists("sendData", mode = "function", 
[17:48:09.019]                       envir = ns)) {
[17:48:09.019]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:09.019]                         envir = ns)
[17:48:09.019]                       envir <- sys.frame(frame)
[17:48:09.019]                       master <- NULL
[17:48:09.019]                       while (!identical(envir, .GlobalEnv) && 
[17:48:09.019]                         !identical(envir, emptyenv())) {
[17:48:09.019]                         if (exists("master", mode = "list", envir = envir, 
[17:48:09.019]                           inherits = FALSE)) {
[17:48:09.019]                           master <- get("master", mode = "list", 
[17:48:09.019]                             envir = envir, inherits = FALSE)
[17:48:09.019]                           if (inherits(master, c("SOCKnode", 
[17:48:09.019]                             "SOCK0node"))) {
[17:48:09.019]                             sendCondition <<- function(cond) {
[17:48:09.019]                               data <- list(type = "VALUE", value = cond, 
[17:48:09.019]                                 success = TRUE)
[17:48:09.019]                               parallel_sendData(master, data)
[17:48:09.019]                             }
[17:48:09.019]                             return(sendCondition)
[17:48:09.019]                           }
[17:48:09.019]                         }
[17:48:09.019]                         frame <- frame + 1L
[17:48:09.019]                         envir <- sys.frame(frame)
[17:48:09.019]                       }
[17:48:09.019]                     }
[17:48:09.019]                     sendCondition <<- function(cond) NULL
[17:48:09.019]                   }
[17:48:09.019]                 })
[17:48:09.019]                 withCallingHandlers({
[17:48:09.019]                   {
[17:48:09.019]                     Sys.sleep(0.5)
[17:48:09.019]                     list(a = 1, b = 42L)
[17:48:09.019]                   }
[17:48:09.019]                 }, immediateCondition = function(cond) {
[17:48:09.019]                   sendCondition <- ...future.makeSendCondition()
[17:48:09.019]                   sendCondition(cond)
[17:48:09.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:09.019]                   {
[17:48:09.019]                     inherits <- base::inherits
[17:48:09.019]                     invokeRestart <- base::invokeRestart
[17:48:09.019]                     is.null <- base::is.null
[17:48:09.019]                     muffled <- FALSE
[17:48:09.019]                     if (inherits(cond, "message")) {
[17:48:09.019]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:09.019]                       if (muffled) 
[17:48:09.019]                         invokeRestart("muffleMessage")
[17:48:09.019]                     }
[17:48:09.019]                     else if (inherits(cond, "warning")) {
[17:48:09.019]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:09.019]                       if (muffled) 
[17:48:09.019]                         invokeRestart("muffleWarning")
[17:48:09.019]                     }
[17:48:09.019]                     else if (inherits(cond, "condition")) {
[17:48:09.019]                       if (!is.null(pattern)) {
[17:48:09.019]                         computeRestarts <- base::computeRestarts
[17:48:09.019]                         grepl <- base::grepl
[17:48:09.019]                         restarts <- computeRestarts(cond)
[17:48:09.019]                         for (restart in restarts) {
[17:48:09.019]                           name <- restart$name
[17:48:09.019]                           if (is.null(name)) 
[17:48:09.019]                             next
[17:48:09.019]                           if (!grepl(pattern, name)) 
[17:48:09.019]                             next
[17:48:09.019]                           invokeRestart(restart)
[17:48:09.019]                           muffled <- TRUE
[17:48:09.019]                           break
[17:48:09.019]                         }
[17:48:09.019]                       }
[17:48:09.019]                     }
[17:48:09.019]                     invisible(muffled)
[17:48:09.019]                   }
[17:48:09.019]                   muffleCondition(cond)
[17:48:09.019]                 })
[17:48:09.019]             }))
[17:48:09.019]             future::FutureResult(value = ...future.value$value, 
[17:48:09.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:09.019]                   ...future.rng), globalenv = if (FALSE) 
[17:48:09.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:09.019]                     ...future.globalenv.names))
[17:48:09.019]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:09.019]         }, condition = base::local({
[17:48:09.019]             c <- base::c
[17:48:09.019]             inherits <- base::inherits
[17:48:09.019]             invokeRestart <- base::invokeRestart
[17:48:09.019]             length <- base::length
[17:48:09.019]             list <- base::list
[17:48:09.019]             seq.int <- base::seq.int
[17:48:09.019]             signalCondition <- base::signalCondition
[17:48:09.019]             sys.calls <- base::sys.calls
[17:48:09.019]             `[[` <- base::`[[`
[17:48:09.019]             `+` <- base::`+`
[17:48:09.019]             `<<-` <- base::`<<-`
[17:48:09.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:09.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:09.019]                   3L)]
[17:48:09.019]             }
[17:48:09.019]             function(cond) {
[17:48:09.019]                 is_error <- inherits(cond, "error")
[17:48:09.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:09.019]                   NULL)
[17:48:09.019]                 if (is_error) {
[17:48:09.019]                   sessionInformation <- function() {
[17:48:09.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:09.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:09.019]                       search = base::search(), system = base::Sys.info())
[17:48:09.019]                   }
[17:48:09.019]                   ...future.conditions[[length(...future.conditions) + 
[17:48:09.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:09.019]                     cond$call), session = sessionInformation(), 
[17:48:09.019]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:09.019]                   signalCondition(cond)
[17:48:09.019]                 }
[17:48:09.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:09.019]                 "immediateCondition"))) {
[17:48:09.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:09.019]                   ...future.conditions[[length(...future.conditions) + 
[17:48:09.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:09.019]                   if (TRUE && !signal) {
[17:48:09.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:09.019]                     {
[17:48:09.019]                       inherits <- base::inherits
[17:48:09.019]                       invokeRestart <- base::invokeRestart
[17:48:09.019]                       is.null <- base::is.null
[17:48:09.019]                       muffled <- FALSE
[17:48:09.019]                       if (inherits(cond, "message")) {
[17:48:09.019]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:09.019]                         if (muffled) 
[17:48:09.019]                           invokeRestart("muffleMessage")
[17:48:09.019]                       }
[17:48:09.019]                       else if (inherits(cond, "warning")) {
[17:48:09.019]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:09.019]                         if (muffled) 
[17:48:09.019]                           invokeRestart("muffleWarning")
[17:48:09.019]                       }
[17:48:09.019]                       else if (inherits(cond, "condition")) {
[17:48:09.019]                         if (!is.null(pattern)) {
[17:48:09.019]                           computeRestarts <- base::computeRestarts
[17:48:09.019]                           grepl <- base::grepl
[17:48:09.019]                           restarts <- computeRestarts(cond)
[17:48:09.019]                           for (restart in restarts) {
[17:48:09.019]                             name <- restart$name
[17:48:09.019]                             if (is.null(name)) 
[17:48:09.019]                               next
[17:48:09.019]                             if (!grepl(pattern, name)) 
[17:48:09.019]                               next
[17:48:09.019]                             invokeRestart(restart)
[17:48:09.019]                             muffled <- TRUE
[17:48:09.019]                             break
[17:48:09.019]                           }
[17:48:09.019]                         }
[17:48:09.019]                       }
[17:48:09.019]                       invisible(muffled)
[17:48:09.019]                     }
[17:48:09.019]                     muffleCondition(cond, pattern = "^muffle")
[17:48:09.019]                   }
[17:48:09.019]                 }
[17:48:09.019]                 else {
[17:48:09.019]                   if (TRUE) {
[17:48:09.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:09.019]                     {
[17:48:09.019]                       inherits <- base::inherits
[17:48:09.019]                       invokeRestart <- base::invokeRestart
[17:48:09.019]                       is.null <- base::is.null
[17:48:09.019]                       muffled <- FALSE
[17:48:09.019]                       if (inherits(cond, "message")) {
[17:48:09.019]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:09.019]                         if (muffled) 
[17:48:09.019]                           invokeRestart("muffleMessage")
[17:48:09.019]                       }
[17:48:09.019]                       else if (inherits(cond, "warning")) {
[17:48:09.019]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:09.019]                         if (muffled) 
[17:48:09.019]                           invokeRestart("muffleWarning")
[17:48:09.019]                       }
[17:48:09.019]                       else if (inherits(cond, "condition")) {
[17:48:09.019]                         if (!is.null(pattern)) {
[17:48:09.019]                           computeRestarts <- base::computeRestarts
[17:48:09.019]                           grepl <- base::grepl
[17:48:09.019]                           restarts <- computeRestarts(cond)
[17:48:09.019]                           for (restart in restarts) {
[17:48:09.019]                             name <- restart$name
[17:48:09.019]                             if (is.null(name)) 
[17:48:09.019]                               next
[17:48:09.019]                             if (!grepl(pattern, name)) 
[17:48:09.019]                               next
[17:48:09.019]                             invokeRestart(restart)
[17:48:09.019]                             muffled <- TRUE
[17:48:09.019]                             break
[17:48:09.019]                           }
[17:48:09.019]                         }
[17:48:09.019]                       }
[17:48:09.019]                       invisible(muffled)
[17:48:09.019]                     }
[17:48:09.019]                     muffleCondition(cond, pattern = "^muffle")
[17:48:09.019]                   }
[17:48:09.019]                 }
[17:48:09.019]             }
[17:48:09.019]         }))
[17:48:09.019]     }, error = function(ex) {
[17:48:09.019]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:09.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:09.019]                 ...future.rng), started = ...future.startTime, 
[17:48:09.019]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:09.019]             version = "1.8"), class = "FutureResult")
[17:48:09.019]     }, finally = {
[17:48:09.019]         if (!identical(...future.workdir, getwd())) 
[17:48:09.019]             setwd(...future.workdir)
[17:48:09.019]         {
[17:48:09.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:09.019]                 ...future.oldOptions$nwarnings <- NULL
[17:48:09.019]             }
[17:48:09.019]             base::options(...future.oldOptions)
[17:48:09.019]             if (.Platform$OS.type == "windows") {
[17:48:09.019]                 old_names <- names(...future.oldEnvVars)
[17:48:09.019]                 envs <- base::Sys.getenv()
[17:48:09.019]                 names <- names(envs)
[17:48:09.019]                 common <- intersect(names, old_names)
[17:48:09.019]                 added <- setdiff(names, old_names)
[17:48:09.019]                 removed <- setdiff(old_names, names)
[17:48:09.019]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:09.019]                   envs[common]]
[17:48:09.019]                 NAMES <- toupper(changed)
[17:48:09.019]                 args <- list()
[17:48:09.019]                 for (kk in seq_along(NAMES)) {
[17:48:09.019]                   name <- changed[[kk]]
[17:48:09.019]                   NAME <- NAMES[[kk]]
[17:48:09.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:09.019]                     next
[17:48:09.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:09.019]                 }
[17:48:09.019]                 NAMES <- toupper(added)
[17:48:09.019]                 for (kk in seq_along(NAMES)) {
[17:48:09.019]                   name <- added[[kk]]
[17:48:09.019]                   NAME <- NAMES[[kk]]
[17:48:09.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:09.019]                     next
[17:48:09.019]                   args[[name]] <- ""
[17:48:09.019]                 }
[17:48:09.019]                 NAMES <- toupper(removed)
[17:48:09.019]                 for (kk in seq_along(NAMES)) {
[17:48:09.019]                   name <- removed[[kk]]
[17:48:09.019]                   NAME <- NAMES[[kk]]
[17:48:09.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:09.019]                     next
[17:48:09.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:09.019]                 }
[17:48:09.019]                 if (length(args) > 0) 
[17:48:09.019]                   base::do.call(base::Sys.setenv, args = args)
[17:48:09.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:09.019]             }
[17:48:09.019]             else {
[17:48:09.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:09.019]             }
[17:48:09.019]             {
[17:48:09.019]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:09.019]                   0L) {
[17:48:09.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:09.019]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:09.019]                   base::options(opts)
[17:48:09.019]                 }
[17:48:09.019]                 {
[17:48:09.019]                   {
[17:48:09.019]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:09.019]                     NULL
[17:48:09.019]                   }
[17:48:09.019]                   options(future.plan = NULL)
[17:48:09.019]                   if (is.na(NA_character_)) 
[17:48:09.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:09.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:09.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:09.019]                     .init = FALSE)
[17:48:09.019]                 }
[17:48:09.019]             }
[17:48:09.019]         }
[17:48:09.019]     })
[17:48:09.019]     if (TRUE) {
[17:48:09.019]         base::sink(type = "output", split = FALSE)
[17:48:09.019]         if (TRUE) {
[17:48:09.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:09.019]         }
[17:48:09.019]         else {
[17:48:09.019]             ...future.result["stdout"] <- base::list(NULL)
[17:48:09.019]         }
[17:48:09.019]         base::close(...future.stdout)
[17:48:09.019]         ...future.stdout <- NULL
[17:48:09.019]     }
[17:48:09.019]     ...future.result$conditions <- ...future.conditions
[17:48:09.019]     ...future.result$finished <- base::Sys.time()
[17:48:09.019]     ...future.result
[17:48:09.019] }
[17:48:09.022] MultisessionFuture started
[17:48:09.022] - Launch lazy future ... done
[17:48:09.022] run() for ‘MultisessionFuture’ ... done
[17:48:09.524] receiveMessageFromWorker() for ClusterFuture ...
[17:48:09.524] - Validating connection of MultisessionFuture
[17:48:09.525] - received message: FutureResult
[17:48:09.525] - Received FutureResult
[17:48:09.525] - Erased future from FutureRegistry
[17:48:09.525] result() for ClusterFuture ...
[17:48:09.525] - result already collected: FutureResult
[17:48:09.525] result() for ClusterFuture ... done
[17:48:09.525] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:09.525] resolve() on list ...
[17:48:09.525]  recursive: Inf
[17:48:09.525]  length: 2
[17:48:09.526]  elements: ‘a’, ‘b’
[17:48:09.526]  length: 1 (resolved future 1)
[17:48:09.526]  length: 0 (resolved future 2)
[17:48:09.526] resolve() on list ... DONE
[17:48:09.526] A MultisessionFuture was resolved (and resolved itself)
[17:48:09.526] getGlobalsAndPackages() ...
[17:48:09.526] Searching for globals...
[17:48:09.527] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:48:09.527] Searching for globals ... DONE
[17:48:09.528] Resolving globals: FALSE
[17:48:09.528] 
[17:48:09.528] 
[17:48:09.528] getGlobalsAndPackages() ... DONE
[17:48:09.528] run() for ‘Future’ ...
[17:48:09.528] - state: ‘created’
[17:48:09.529] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:09.542] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:09.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:09.542]   - Field: ‘node’
[17:48:09.543]   - Field: ‘label’
[17:48:09.543]   - Field: ‘local’
[17:48:09.543]   - Field: ‘owner’
[17:48:09.543]   - Field: ‘envir’
[17:48:09.543]   - Field: ‘workers’
[17:48:09.543]   - Field: ‘packages’
[17:48:09.543]   - Field: ‘gc’
[17:48:09.543]   - Field: ‘conditions’
[17:48:09.543]   - Field: ‘persistent’
[17:48:09.543]   - Field: ‘expr’
[17:48:09.544]   - Field: ‘uuid’
[17:48:09.544]   - Field: ‘seed’
[17:48:09.544]   - Field: ‘version’
[17:48:09.544]   - Field: ‘result’
[17:48:09.544]   - Field: ‘asynchronous’
[17:48:09.544]   - Field: ‘calls’
[17:48:09.544]   - Field: ‘globals’
[17:48:09.544]   - Field: ‘stdout’
[17:48:09.544]   - Field: ‘earlySignal’
[17:48:09.544]   - Field: ‘lazy’
[17:48:09.544]   - Field: ‘state’
[17:48:09.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:09.545] - Launch lazy future ...
[17:48:09.545] Packages needed by the future expression (n = 0): <none>
[17:48:09.545] Packages needed by future strategies (n = 0): <none>
[17:48:09.545] {
[17:48:09.545]     {
[17:48:09.545]         {
[17:48:09.545]             ...future.startTime <- base::Sys.time()
[17:48:09.545]             {
[17:48:09.545]                 {
[17:48:09.545]                   {
[17:48:09.545]                     {
[17:48:09.545]                       base::local({
[17:48:09.545]                         has_future <- base::requireNamespace("future", 
[17:48:09.545]                           quietly = TRUE)
[17:48:09.545]                         if (has_future) {
[17:48:09.545]                           ns <- base::getNamespace("future")
[17:48:09.545]                           version <- ns[[".package"]][["version"]]
[17:48:09.545]                           if (is.null(version)) 
[17:48:09.545]                             version <- utils::packageVersion("future")
[17:48:09.545]                         }
[17:48:09.545]                         else {
[17:48:09.545]                           version <- NULL
[17:48:09.545]                         }
[17:48:09.545]                         if (!has_future || version < "1.8.0") {
[17:48:09.545]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:09.545]                             "", base::R.version$version.string), 
[17:48:09.545]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:09.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:09.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:09.545]                               "release", "version")], collapse = " "), 
[17:48:09.545]                             hostname = base::Sys.info()[["nodename"]])
[17:48:09.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:09.545]                             info)
[17:48:09.545]                           info <- base::paste(info, collapse = "; ")
[17:48:09.545]                           if (!has_future) {
[17:48:09.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:09.545]                               info)
[17:48:09.545]                           }
[17:48:09.545]                           else {
[17:48:09.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:09.545]                               info, version)
[17:48:09.545]                           }
[17:48:09.545]                           base::stop(msg)
[17:48:09.545]                         }
[17:48:09.545]                       })
[17:48:09.545]                     }
[17:48:09.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:09.545]                     base::options(mc.cores = 1L)
[17:48:09.545]                   }
[17:48:09.545]                   ...future.strategy.old <- future::plan("list")
[17:48:09.545]                   options(future.plan = NULL)
[17:48:09.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:09.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:09.545]                 }
[17:48:09.545]                 ...future.workdir <- getwd()
[17:48:09.545]             }
[17:48:09.545]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:09.545]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:09.545]         }
[17:48:09.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:09.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:09.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:09.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:09.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:09.545]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:09.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:09.545]             base::names(...future.oldOptions))
[17:48:09.545]     }
[17:48:09.545]     if (FALSE) {
[17:48:09.545]     }
[17:48:09.545]     else {
[17:48:09.545]         if (TRUE) {
[17:48:09.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:09.545]                 open = "w")
[17:48:09.545]         }
[17:48:09.545]         else {
[17:48:09.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:09.545]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:09.545]         }
[17:48:09.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:09.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:09.545]             base::sink(type = "output", split = FALSE)
[17:48:09.545]             base::close(...future.stdout)
[17:48:09.545]         }, add = TRUE)
[17:48:09.545]     }
[17:48:09.545]     ...future.frame <- base::sys.nframe()
[17:48:09.545]     ...future.conditions <- base::list()
[17:48:09.545]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:09.545]     if (FALSE) {
[17:48:09.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:09.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:09.545]     }
[17:48:09.545]     ...future.result <- base::tryCatch({
[17:48:09.545]         base::withCallingHandlers({
[17:48:09.545]             ...future.value <- base::withVisible(base::local({
[17:48:09.545]                 ...future.makeSendCondition <- base::local({
[17:48:09.545]                   sendCondition <- NULL
[17:48:09.545]                   function(frame = 1L) {
[17:48:09.545]                     if (is.function(sendCondition)) 
[17:48:09.545]                       return(sendCondition)
[17:48:09.545]                     ns <- getNamespace("parallel")
[17:48:09.545]                     if (exists("sendData", mode = "function", 
[17:48:09.545]                       envir = ns)) {
[17:48:09.545]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:09.545]                         envir = ns)
[17:48:09.545]                       envir <- sys.frame(frame)
[17:48:09.545]                       master <- NULL
[17:48:09.545]                       while (!identical(envir, .GlobalEnv) && 
[17:48:09.545]                         !identical(envir, emptyenv())) {
[17:48:09.545]                         if (exists("master", mode = "list", envir = envir, 
[17:48:09.545]                           inherits = FALSE)) {
[17:48:09.545]                           master <- get("master", mode = "list", 
[17:48:09.545]                             envir = envir, inherits = FALSE)
[17:48:09.545]                           if (inherits(master, c("SOCKnode", 
[17:48:09.545]                             "SOCK0node"))) {
[17:48:09.545]                             sendCondition <<- function(cond) {
[17:48:09.545]                               data <- list(type = "VALUE", value = cond, 
[17:48:09.545]                                 success = TRUE)
[17:48:09.545]                               parallel_sendData(master, data)
[17:48:09.545]                             }
[17:48:09.545]                             return(sendCondition)
[17:48:09.545]                           }
[17:48:09.545]                         }
[17:48:09.545]                         frame <- frame + 1L
[17:48:09.545]                         envir <- sys.frame(frame)
[17:48:09.545]                       }
[17:48:09.545]                     }
[17:48:09.545]                     sendCondition <<- function(cond) NULL
[17:48:09.545]                   }
[17:48:09.545]                 })
[17:48:09.545]                 withCallingHandlers({
[17:48:09.545]                   {
[17:48:09.545]                     Sys.sleep(0.5)
[17:48:09.545]                     list(a = 1, b = 42L)
[17:48:09.545]                   }
[17:48:09.545]                 }, immediateCondition = function(cond) {
[17:48:09.545]                   sendCondition <- ...future.makeSendCondition()
[17:48:09.545]                   sendCondition(cond)
[17:48:09.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:09.545]                   {
[17:48:09.545]                     inherits <- base::inherits
[17:48:09.545]                     invokeRestart <- base::invokeRestart
[17:48:09.545]                     is.null <- base::is.null
[17:48:09.545]                     muffled <- FALSE
[17:48:09.545]                     if (inherits(cond, "message")) {
[17:48:09.545]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:09.545]                       if (muffled) 
[17:48:09.545]                         invokeRestart("muffleMessage")
[17:48:09.545]                     }
[17:48:09.545]                     else if (inherits(cond, "warning")) {
[17:48:09.545]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:09.545]                       if (muffled) 
[17:48:09.545]                         invokeRestart("muffleWarning")
[17:48:09.545]                     }
[17:48:09.545]                     else if (inherits(cond, "condition")) {
[17:48:09.545]                       if (!is.null(pattern)) {
[17:48:09.545]                         computeRestarts <- base::computeRestarts
[17:48:09.545]                         grepl <- base::grepl
[17:48:09.545]                         restarts <- computeRestarts(cond)
[17:48:09.545]                         for (restart in restarts) {
[17:48:09.545]                           name <- restart$name
[17:48:09.545]                           if (is.null(name)) 
[17:48:09.545]                             next
[17:48:09.545]                           if (!grepl(pattern, name)) 
[17:48:09.545]                             next
[17:48:09.545]                           invokeRestart(restart)
[17:48:09.545]                           muffled <- TRUE
[17:48:09.545]                           break
[17:48:09.545]                         }
[17:48:09.545]                       }
[17:48:09.545]                     }
[17:48:09.545]                     invisible(muffled)
[17:48:09.545]                   }
[17:48:09.545]                   muffleCondition(cond)
[17:48:09.545]                 })
[17:48:09.545]             }))
[17:48:09.545]             future::FutureResult(value = ...future.value$value, 
[17:48:09.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:09.545]                   ...future.rng), globalenv = if (FALSE) 
[17:48:09.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:09.545]                     ...future.globalenv.names))
[17:48:09.545]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:09.545]         }, condition = base::local({
[17:48:09.545]             c <- base::c
[17:48:09.545]             inherits <- base::inherits
[17:48:09.545]             invokeRestart <- base::invokeRestart
[17:48:09.545]             length <- base::length
[17:48:09.545]             list <- base::list
[17:48:09.545]             seq.int <- base::seq.int
[17:48:09.545]             signalCondition <- base::signalCondition
[17:48:09.545]             sys.calls <- base::sys.calls
[17:48:09.545]             `[[` <- base::`[[`
[17:48:09.545]             `+` <- base::`+`
[17:48:09.545]             `<<-` <- base::`<<-`
[17:48:09.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:09.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:09.545]                   3L)]
[17:48:09.545]             }
[17:48:09.545]             function(cond) {
[17:48:09.545]                 is_error <- inherits(cond, "error")
[17:48:09.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:09.545]                   NULL)
[17:48:09.545]                 if (is_error) {
[17:48:09.545]                   sessionInformation <- function() {
[17:48:09.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:09.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:09.545]                       search = base::search(), system = base::Sys.info())
[17:48:09.545]                   }
[17:48:09.545]                   ...future.conditions[[length(...future.conditions) + 
[17:48:09.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:09.545]                     cond$call), session = sessionInformation(), 
[17:48:09.545]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:09.545]                   signalCondition(cond)
[17:48:09.545]                 }
[17:48:09.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:09.545]                 "immediateCondition"))) {
[17:48:09.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:09.545]                   ...future.conditions[[length(...future.conditions) + 
[17:48:09.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:09.545]                   if (TRUE && !signal) {
[17:48:09.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:09.545]                     {
[17:48:09.545]                       inherits <- base::inherits
[17:48:09.545]                       invokeRestart <- base::invokeRestart
[17:48:09.545]                       is.null <- base::is.null
[17:48:09.545]                       muffled <- FALSE
[17:48:09.545]                       if (inherits(cond, "message")) {
[17:48:09.545]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:09.545]                         if (muffled) 
[17:48:09.545]                           invokeRestart("muffleMessage")
[17:48:09.545]                       }
[17:48:09.545]                       else if (inherits(cond, "warning")) {
[17:48:09.545]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:09.545]                         if (muffled) 
[17:48:09.545]                           invokeRestart("muffleWarning")
[17:48:09.545]                       }
[17:48:09.545]                       else if (inherits(cond, "condition")) {
[17:48:09.545]                         if (!is.null(pattern)) {
[17:48:09.545]                           computeRestarts <- base::computeRestarts
[17:48:09.545]                           grepl <- base::grepl
[17:48:09.545]                           restarts <- computeRestarts(cond)
[17:48:09.545]                           for (restart in restarts) {
[17:48:09.545]                             name <- restart$name
[17:48:09.545]                             if (is.null(name)) 
[17:48:09.545]                               next
[17:48:09.545]                             if (!grepl(pattern, name)) 
[17:48:09.545]                               next
[17:48:09.545]                             invokeRestart(restart)
[17:48:09.545]                             muffled <- TRUE
[17:48:09.545]                             break
[17:48:09.545]                           }
[17:48:09.545]                         }
[17:48:09.545]                       }
[17:48:09.545]                       invisible(muffled)
[17:48:09.545]                     }
[17:48:09.545]                     muffleCondition(cond, pattern = "^muffle")
[17:48:09.545]                   }
[17:48:09.545]                 }
[17:48:09.545]                 else {
[17:48:09.545]                   if (TRUE) {
[17:48:09.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:09.545]                     {
[17:48:09.545]                       inherits <- base::inherits
[17:48:09.545]                       invokeRestart <- base::invokeRestart
[17:48:09.545]                       is.null <- base::is.null
[17:48:09.545]                       muffled <- FALSE
[17:48:09.545]                       if (inherits(cond, "message")) {
[17:48:09.545]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:09.545]                         if (muffled) 
[17:48:09.545]                           invokeRestart("muffleMessage")
[17:48:09.545]                       }
[17:48:09.545]                       else if (inherits(cond, "warning")) {
[17:48:09.545]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:09.545]                         if (muffled) 
[17:48:09.545]                           invokeRestart("muffleWarning")
[17:48:09.545]                       }
[17:48:09.545]                       else if (inherits(cond, "condition")) {
[17:48:09.545]                         if (!is.null(pattern)) {
[17:48:09.545]                           computeRestarts <- base::computeRestarts
[17:48:09.545]                           grepl <- base::grepl
[17:48:09.545]                           restarts <- computeRestarts(cond)
[17:48:09.545]                           for (restart in restarts) {
[17:48:09.545]                             name <- restart$name
[17:48:09.545]                             if (is.null(name)) 
[17:48:09.545]                               next
[17:48:09.545]                             if (!grepl(pattern, name)) 
[17:48:09.545]                               next
[17:48:09.545]                             invokeRestart(restart)
[17:48:09.545]                             muffled <- TRUE
[17:48:09.545]                             break
[17:48:09.545]                           }
[17:48:09.545]                         }
[17:48:09.545]                       }
[17:48:09.545]                       invisible(muffled)
[17:48:09.545]                     }
[17:48:09.545]                     muffleCondition(cond, pattern = "^muffle")
[17:48:09.545]                   }
[17:48:09.545]                 }
[17:48:09.545]             }
[17:48:09.545]         }))
[17:48:09.545]     }, error = function(ex) {
[17:48:09.545]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:09.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:09.545]                 ...future.rng), started = ...future.startTime, 
[17:48:09.545]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:09.545]             version = "1.8"), class = "FutureResult")
[17:48:09.545]     }, finally = {
[17:48:09.545]         if (!identical(...future.workdir, getwd())) 
[17:48:09.545]             setwd(...future.workdir)
[17:48:09.545]         {
[17:48:09.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:09.545]                 ...future.oldOptions$nwarnings <- NULL
[17:48:09.545]             }
[17:48:09.545]             base::options(...future.oldOptions)
[17:48:09.545]             if (.Platform$OS.type == "windows") {
[17:48:09.545]                 old_names <- names(...future.oldEnvVars)
[17:48:09.545]                 envs <- base::Sys.getenv()
[17:48:09.545]                 names <- names(envs)
[17:48:09.545]                 common <- intersect(names, old_names)
[17:48:09.545]                 added <- setdiff(names, old_names)
[17:48:09.545]                 removed <- setdiff(old_names, names)
[17:48:09.545]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:09.545]                   envs[common]]
[17:48:09.545]                 NAMES <- toupper(changed)
[17:48:09.545]                 args <- list()
[17:48:09.545]                 for (kk in seq_along(NAMES)) {
[17:48:09.545]                   name <- changed[[kk]]
[17:48:09.545]                   NAME <- NAMES[[kk]]
[17:48:09.545]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:09.545]                     next
[17:48:09.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:09.545]                 }
[17:48:09.545]                 NAMES <- toupper(added)
[17:48:09.545]                 for (kk in seq_along(NAMES)) {
[17:48:09.545]                   name <- added[[kk]]
[17:48:09.545]                   NAME <- NAMES[[kk]]
[17:48:09.545]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:09.545]                     next
[17:48:09.545]                   args[[name]] <- ""
[17:48:09.545]                 }
[17:48:09.545]                 NAMES <- toupper(removed)
[17:48:09.545]                 for (kk in seq_along(NAMES)) {
[17:48:09.545]                   name <- removed[[kk]]
[17:48:09.545]                   NAME <- NAMES[[kk]]
[17:48:09.545]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:09.545]                     next
[17:48:09.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:09.545]                 }
[17:48:09.545]                 if (length(args) > 0) 
[17:48:09.545]                   base::do.call(base::Sys.setenv, args = args)
[17:48:09.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:09.545]             }
[17:48:09.545]             else {
[17:48:09.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:09.545]             }
[17:48:09.545]             {
[17:48:09.545]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:09.545]                   0L) {
[17:48:09.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:09.545]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:09.545]                   base::options(opts)
[17:48:09.545]                 }
[17:48:09.545]                 {
[17:48:09.545]                   {
[17:48:09.545]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:09.545]                     NULL
[17:48:09.545]                   }
[17:48:09.545]                   options(future.plan = NULL)
[17:48:09.545]                   if (is.na(NA_character_)) 
[17:48:09.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:09.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:09.545]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:09.545]                     .init = FALSE)
[17:48:09.545]                 }
[17:48:09.545]             }
[17:48:09.545]         }
[17:48:09.545]     })
[17:48:09.545]     if (TRUE) {
[17:48:09.545]         base::sink(type = "output", split = FALSE)
[17:48:09.545]         if (TRUE) {
[17:48:09.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:09.545]         }
[17:48:09.545]         else {
[17:48:09.545]             ...future.result["stdout"] <- base::list(NULL)
[17:48:09.545]         }
[17:48:09.545]         base::close(...future.stdout)
[17:48:09.545]         ...future.stdout <- NULL
[17:48:09.545]     }
[17:48:09.545]     ...future.result$conditions <- ...future.conditions
[17:48:09.545]     ...future.result$finished <- base::Sys.time()
[17:48:09.545]     ...future.result
[17:48:09.545] }
[17:48:09.548] MultisessionFuture started
[17:48:09.548] - Launch lazy future ... done
[17:48:09.549] run() for ‘MultisessionFuture’ ... done
[17:48:10.051] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.051] - Validating connection of MultisessionFuture
[17:48:10.052] - received message: FutureResult
[17:48:10.052] - Received FutureResult
[17:48:10.052] - Erased future from FutureRegistry
[17:48:10.052] result() for ClusterFuture ...
[17:48:10.052] - result already collected: FutureResult
[17:48:10.052] result() for ClusterFuture ... done
[17:48:10.052] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.053] resolve() on list ...
[17:48:10.053]  recursive: Inf
[17:48:10.053]  length: 2
[17:48:10.053]  elements: ‘a’, ‘b’
[17:48:10.053]  length: 1 (resolved future 1)
[17:48:10.053]  length: 0 (resolved future 2)
[17:48:10.053] resolve() on list ... DONE
[17:48:10.053] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:48:10.053] getGlobalsAndPackages() ...
[17:48:10.053] Searching for globals...
[17:48:10.054] - globals found: [2] ‘list’, ‘stop’
[17:48:10.054] Searching for globals ... DONE
[17:48:10.054] Resolving globals: FALSE
[17:48:10.055] 
[17:48:10.055] 
[17:48:10.055] getGlobalsAndPackages() ... DONE
[17:48:10.055] run() for ‘Future’ ...
[17:48:10.055] - state: ‘created’
[17:48:10.055] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.070]   - Field: ‘node’
[17:48:10.070]   - Field: ‘label’
[17:48:10.070]   - Field: ‘local’
[17:48:10.070]   - Field: ‘owner’
[17:48:10.070]   - Field: ‘envir’
[17:48:10.070]   - Field: ‘workers’
[17:48:10.071]   - Field: ‘packages’
[17:48:10.071]   - Field: ‘gc’
[17:48:10.071]   - Field: ‘conditions’
[17:48:10.071]   - Field: ‘persistent’
[17:48:10.071]   - Field: ‘expr’
[17:48:10.071]   - Field: ‘uuid’
[17:48:10.071]   - Field: ‘seed’
[17:48:10.071]   - Field: ‘version’
[17:48:10.071]   - Field: ‘result’
[17:48:10.071]   - Field: ‘asynchronous’
[17:48:10.072]   - Field: ‘calls’
[17:48:10.072]   - Field: ‘globals’
[17:48:10.072]   - Field: ‘stdout’
[17:48:10.072]   - Field: ‘earlySignal’
[17:48:10.072]   - Field: ‘lazy’
[17:48:10.072]   - Field: ‘state’
[17:48:10.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.072] - Launch lazy future ...
[17:48:10.072] Packages needed by the future expression (n = 0): <none>
[17:48:10.073] Packages needed by future strategies (n = 0): <none>
[17:48:10.073] {
[17:48:10.073]     {
[17:48:10.073]         {
[17:48:10.073]             ...future.startTime <- base::Sys.time()
[17:48:10.073]             {
[17:48:10.073]                 {
[17:48:10.073]                   {
[17:48:10.073]                     {
[17:48:10.073]                       base::local({
[17:48:10.073]                         has_future <- base::requireNamespace("future", 
[17:48:10.073]                           quietly = TRUE)
[17:48:10.073]                         if (has_future) {
[17:48:10.073]                           ns <- base::getNamespace("future")
[17:48:10.073]                           version <- ns[[".package"]][["version"]]
[17:48:10.073]                           if (is.null(version)) 
[17:48:10.073]                             version <- utils::packageVersion("future")
[17:48:10.073]                         }
[17:48:10.073]                         else {
[17:48:10.073]                           version <- NULL
[17:48:10.073]                         }
[17:48:10.073]                         if (!has_future || version < "1.8.0") {
[17:48:10.073]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.073]                             "", base::R.version$version.string), 
[17:48:10.073]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.073]                               "release", "version")], collapse = " "), 
[17:48:10.073]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.073]                             info)
[17:48:10.073]                           info <- base::paste(info, collapse = "; ")
[17:48:10.073]                           if (!has_future) {
[17:48:10.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.073]                               info)
[17:48:10.073]                           }
[17:48:10.073]                           else {
[17:48:10.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.073]                               info, version)
[17:48:10.073]                           }
[17:48:10.073]                           base::stop(msg)
[17:48:10.073]                         }
[17:48:10.073]                       })
[17:48:10.073]                     }
[17:48:10.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.073]                     base::options(mc.cores = 1L)
[17:48:10.073]                   }
[17:48:10.073]                   ...future.strategy.old <- future::plan("list")
[17:48:10.073]                   options(future.plan = NULL)
[17:48:10.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.073]                 }
[17:48:10.073]                 ...future.workdir <- getwd()
[17:48:10.073]             }
[17:48:10.073]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.073]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.073]         }
[17:48:10.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.073]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.073]             base::names(...future.oldOptions))
[17:48:10.073]     }
[17:48:10.073]     if (FALSE) {
[17:48:10.073]     }
[17:48:10.073]     else {
[17:48:10.073]         if (TRUE) {
[17:48:10.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.073]                 open = "w")
[17:48:10.073]         }
[17:48:10.073]         else {
[17:48:10.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.073]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.073]         }
[17:48:10.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.073]             base::sink(type = "output", split = FALSE)
[17:48:10.073]             base::close(...future.stdout)
[17:48:10.073]         }, add = TRUE)
[17:48:10.073]     }
[17:48:10.073]     ...future.frame <- base::sys.nframe()
[17:48:10.073]     ...future.conditions <- base::list()
[17:48:10.073]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.073]     if (FALSE) {
[17:48:10.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.073]     }
[17:48:10.073]     ...future.result <- base::tryCatch({
[17:48:10.073]         base::withCallingHandlers({
[17:48:10.073]             ...future.value <- base::withVisible(base::local({
[17:48:10.073]                 ...future.makeSendCondition <- base::local({
[17:48:10.073]                   sendCondition <- NULL
[17:48:10.073]                   function(frame = 1L) {
[17:48:10.073]                     if (is.function(sendCondition)) 
[17:48:10.073]                       return(sendCondition)
[17:48:10.073]                     ns <- getNamespace("parallel")
[17:48:10.073]                     if (exists("sendData", mode = "function", 
[17:48:10.073]                       envir = ns)) {
[17:48:10.073]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.073]                         envir = ns)
[17:48:10.073]                       envir <- sys.frame(frame)
[17:48:10.073]                       master <- NULL
[17:48:10.073]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.073]                         !identical(envir, emptyenv())) {
[17:48:10.073]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.073]                           inherits = FALSE)) {
[17:48:10.073]                           master <- get("master", mode = "list", 
[17:48:10.073]                             envir = envir, inherits = FALSE)
[17:48:10.073]                           if (inherits(master, c("SOCKnode", 
[17:48:10.073]                             "SOCK0node"))) {
[17:48:10.073]                             sendCondition <<- function(cond) {
[17:48:10.073]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.073]                                 success = TRUE)
[17:48:10.073]                               parallel_sendData(master, data)
[17:48:10.073]                             }
[17:48:10.073]                             return(sendCondition)
[17:48:10.073]                           }
[17:48:10.073]                         }
[17:48:10.073]                         frame <- frame + 1L
[17:48:10.073]                         envir <- sys.frame(frame)
[17:48:10.073]                       }
[17:48:10.073]                     }
[17:48:10.073]                     sendCondition <<- function(cond) NULL
[17:48:10.073]                   }
[17:48:10.073]                 })
[17:48:10.073]                 withCallingHandlers({
[17:48:10.073]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:10.073]                 }, immediateCondition = function(cond) {
[17:48:10.073]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.073]                   sendCondition(cond)
[17:48:10.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.073]                   {
[17:48:10.073]                     inherits <- base::inherits
[17:48:10.073]                     invokeRestart <- base::invokeRestart
[17:48:10.073]                     is.null <- base::is.null
[17:48:10.073]                     muffled <- FALSE
[17:48:10.073]                     if (inherits(cond, "message")) {
[17:48:10.073]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.073]                       if (muffled) 
[17:48:10.073]                         invokeRestart("muffleMessage")
[17:48:10.073]                     }
[17:48:10.073]                     else if (inherits(cond, "warning")) {
[17:48:10.073]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.073]                       if (muffled) 
[17:48:10.073]                         invokeRestart("muffleWarning")
[17:48:10.073]                     }
[17:48:10.073]                     else if (inherits(cond, "condition")) {
[17:48:10.073]                       if (!is.null(pattern)) {
[17:48:10.073]                         computeRestarts <- base::computeRestarts
[17:48:10.073]                         grepl <- base::grepl
[17:48:10.073]                         restarts <- computeRestarts(cond)
[17:48:10.073]                         for (restart in restarts) {
[17:48:10.073]                           name <- restart$name
[17:48:10.073]                           if (is.null(name)) 
[17:48:10.073]                             next
[17:48:10.073]                           if (!grepl(pattern, name)) 
[17:48:10.073]                             next
[17:48:10.073]                           invokeRestart(restart)
[17:48:10.073]                           muffled <- TRUE
[17:48:10.073]                           break
[17:48:10.073]                         }
[17:48:10.073]                       }
[17:48:10.073]                     }
[17:48:10.073]                     invisible(muffled)
[17:48:10.073]                   }
[17:48:10.073]                   muffleCondition(cond)
[17:48:10.073]                 })
[17:48:10.073]             }))
[17:48:10.073]             future::FutureResult(value = ...future.value$value, 
[17:48:10.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.073]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.073]                     ...future.globalenv.names))
[17:48:10.073]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.073]         }, condition = base::local({
[17:48:10.073]             c <- base::c
[17:48:10.073]             inherits <- base::inherits
[17:48:10.073]             invokeRestart <- base::invokeRestart
[17:48:10.073]             length <- base::length
[17:48:10.073]             list <- base::list
[17:48:10.073]             seq.int <- base::seq.int
[17:48:10.073]             signalCondition <- base::signalCondition
[17:48:10.073]             sys.calls <- base::sys.calls
[17:48:10.073]             `[[` <- base::`[[`
[17:48:10.073]             `+` <- base::`+`
[17:48:10.073]             `<<-` <- base::`<<-`
[17:48:10.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.073]                   3L)]
[17:48:10.073]             }
[17:48:10.073]             function(cond) {
[17:48:10.073]                 is_error <- inherits(cond, "error")
[17:48:10.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.073]                   NULL)
[17:48:10.073]                 if (is_error) {
[17:48:10.073]                   sessionInformation <- function() {
[17:48:10.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.073]                       search = base::search(), system = base::Sys.info())
[17:48:10.073]                   }
[17:48:10.073]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.073]                     cond$call), session = sessionInformation(), 
[17:48:10.073]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.073]                   signalCondition(cond)
[17:48:10.073]                 }
[17:48:10.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.073]                 "immediateCondition"))) {
[17:48:10.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.073]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.073]                   if (TRUE && !signal) {
[17:48:10.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.073]                     {
[17:48:10.073]                       inherits <- base::inherits
[17:48:10.073]                       invokeRestart <- base::invokeRestart
[17:48:10.073]                       is.null <- base::is.null
[17:48:10.073]                       muffled <- FALSE
[17:48:10.073]                       if (inherits(cond, "message")) {
[17:48:10.073]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.073]                         if (muffled) 
[17:48:10.073]                           invokeRestart("muffleMessage")
[17:48:10.073]                       }
[17:48:10.073]                       else if (inherits(cond, "warning")) {
[17:48:10.073]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.073]                         if (muffled) 
[17:48:10.073]                           invokeRestart("muffleWarning")
[17:48:10.073]                       }
[17:48:10.073]                       else if (inherits(cond, "condition")) {
[17:48:10.073]                         if (!is.null(pattern)) {
[17:48:10.073]                           computeRestarts <- base::computeRestarts
[17:48:10.073]                           grepl <- base::grepl
[17:48:10.073]                           restarts <- computeRestarts(cond)
[17:48:10.073]                           for (restart in restarts) {
[17:48:10.073]                             name <- restart$name
[17:48:10.073]                             if (is.null(name)) 
[17:48:10.073]                               next
[17:48:10.073]                             if (!grepl(pattern, name)) 
[17:48:10.073]                               next
[17:48:10.073]                             invokeRestart(restart)
[17:48:10.073]                             muffled <- TRUE
[17:48:10.073]                             break
[17:48:10.073]                           }
[17:48:10.073]                         }
[17:48:10.073]                       }
[17:48:10.073]                       invisible(muffled)
[17:48:10.073]                     }
[17:48:10.073]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.073]                   }
[17:48:10.073]                 }
[17:48:10.073]                 else {
[17:48:10.073]                   if (TRUE) {
[17:48:10.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.073]                     {
[17:48:10.073]                       inherits <- base::inherits
[17:48:10.073]                       invokeRestart <- base::invokeRestart
[17:48:10.073]                       is.null <- base::is.null
[17:48:10.073]                       muffled <- FALSE
[17:48:10.073]                       if (inherits(cond, "message")) {
[17:48:10.073]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.073]                         if (muffled) 
[17:48:10.073]                           invokeRestart("muffleMessage")
[17:48:10.073]                       }
[17:48:10.073]                       else if (inherits(cond, "warning")) {
[17:48:10.073]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.073]                         if (muffled) 
[17:48:10.073]                           invokeRestart("muffleWarning")
[17:48:10.073]                       }
[17:48:10.073]                       else if (inherits(cond, "condition")) {
[17:48:10.073]                         if (!is.null(pattern)) {
[17:48:10.073]                           computeRestarts <- base::computeRestarts
[17:48:10.073]                           grepl <- base::grepl
[17:48:10.073]                           restarts <- computeRestarts(cond)
[17:48:10.073]                           for (restart in restarts) {
[17:48:10.073]                             name <- restart$name
[17:48:10.073]                             if (is.null(name)) 
[17:48:10.073]                               next
[17:48:10.073]                             if (!grepl(pattern, name)) 
[17:48:10.073]                               next
[17:48:10.073]                             invokeRestart(restart)
[17:48:10.073]                             muffled <- TRUE
[17:48:10.073]                             break
[17:48:10.073]                           }
[17:48:10.073]                         }
[17:48:10.073]                       }
[17:48:10.073]                       invisible(muffled)
[17:48:10.073]                     }
[17:48:10.073]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.073]                   }
[17:48:10.073]                 }
[17:48:10.073]             }
[17:48:10.073]         }))
[17:48:10.073]     }, error = function(ex) {
[17:48:10.073]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.073]                 ...future.rng), started = ...future.startTime, 
[17:48:10.073]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.073]             version = "1.8"), class = "FutureResult")
[17:48:10.073]     }, finally = {
[17:48:10.073]         if (!identical(...future.workdir, getwd())) 
[17:48:10.073]             setwd(...future.workdir)
[17:48:10.073]         {
[17:48:10.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.073]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.073]             }
[17:48:10.073]             base::options(...future.oldOptions)
[17:48:10.073]             if (.Platform$OS.type == "windows") {
[17:48:10.073]                 old_names <- names(...future.oldEnvVars)
[17:48:10.073]                 envs <- base::Sys.getenv()
[17:48:10.073]                 names <- names(envs)
[17:48:10.073]                 common <- intersect(names, old_names)
[17:48:10.073]                 added <- setdiff(names, old_names)
[17:48:10.073]                 removed <- setdiff(old_names, names)
[17:48:10.073]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.073]                   envs[common]]
[17:48:10.073]                 NAMES <- toupper(changed)
[17:48:10.073]                 args <- list()
[17:48:10.073]                 for (kk in seq_along(NAMES)) {
[17:48:10.073]                   name <- changed[[kk]]
[17:48:10.073]                   NAME <- NAMES[[kk]]
[17:48:10.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.073]                     next
[17:48:10.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.073]                 }
[17:48:10.073]                 NAMES <- toupper(added)
[17:48:10.073]                 for (kk in seq_along(NAMES)) {
[17:48:10.073]                   name <- added[[kk]]
[17:48:10.073]                   NAME <- NAMES[[kk]]
[17:48:10.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.073]                     next
[17:48:10.073]                   args[[name]] <- ""
[17:48:10.073]                 }
[17:48:10.073]                 NAMES <- toupper(removed)
[17:48:10.073]                 for (kk in seq_along(NAMES)) {
[17:48:10.073]                   name <- removed[[kk]]
[17:48:10.073]                   NAME <- NAMES[[kk]]
[17:48:10.073]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.073]                     next
[17:48:10.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.073]                 }
[17:48:10.073]                 if (length(args) > 0) 
[17:48:10.073]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.073]             }
[17:48:10.073]             else {
[17:48:10.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.073]             }
[17:48:10.073]             {
[17:48:10.073]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.073]                   0L) {
[17:48:10.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.073]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.073]                   base::options(opts)
[17:48:10.073]                 }
[17:48:10.073]                 {
[17:48:10.073]                   {
[17:48:10.073]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.073]                     NULL
[17:48:10.073]                   }
[17:48:10.073]                   options(future.plan = NULL)
[17:48:10.073]                   if (is.na(NA_character_)) 
[17:48:10.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.073]                     .init = FALSE)
[17:48:10.073]                 }
[17:48:10.073]             }
[17:48:10.073]         }
[17:48:10.073]     })
[17:48:10.073]     if (TRUE) {
[17:48:10.073]         base::sink(type = "output", split = FALSE)
[17:48:10.073]         if (TRUE) {
[17:48:10.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.073]         }
[17:48:10.073]         else {
[17:48:10.073]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.073]         }
[17:48:10.073]         base::close(...future.stdout)
[17:48:10.073]         ...future.stdout <- NULL
[17:48:10.073]     }
[17:48:10.073]     ...future.result$conditions <- ...future.conditions
[17:48:10.073]     ...future.result$finished <- base::Sys.time()
[17:48:10.073]     ...future.result
[17:48:10.073] }
[17:48:10.076] MultisessionFuture started
[17:48:10.076] - Launch lazy future ... done
[17:48:10.076] run() for ‘MultisessionFuture’ ... done
[17:48:10.078] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.078] - Validating connection of MultisessionFuture
[17:48:10.078] - received message: FutureResult
[17:48:10.079] - Received FutureResult
[17:48:10.079] - Erased future from FutureRegistry
[17:48:10.079] result() for ClusterFuture ...
[17:48:10.079] - result already collected: FutureResult
[17:48:10.079] result() for ClusterFuture ... done
[17:48:10.079] signalConditions() ...
[17:48:10.079]  - include = ‘immediateCondition’
[17:48:10.079]  - exclude = 
[17:48:10.079]  - resignal = FALSE
[17:48:10.079]  - Number of conditions: 1
[17:48:10.080] signalConditions() ... done
[17:48:10.080] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.080] A MultisessionFuture was resolved (and resolved itself)
[17:48:10.080] getGlobalsAndPackages() ...
[17:48:10.080] Searching for globals...
[17:48:10.081] - globals found: [2] ‘list’, ‘stop’
[17:48:10.081] Searching for globals ... DONE
[17:48:10.081] Resolving globals: FALSE
[17:48:10.081] 
[17:48:10.081] 
[17:48:10.081] getGlobalsAndPackages() ... DONE
[17:48:10.081] run() for ‘Future’ ...
[17:48:10.082] - state: ‘created’
[17:48:10.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.096]   - Field: ‘node’
[17:48:10.096]   - Field: ‘label’
[17:48:10.096]   - Field: ‘local’
[17:48:10.096]   - Field: ‘owner’
[17:48:10.097]   - Field: ‘envir’
[17:48:10.097]   - Field: ‘workers’
[17:48:10.097]   - Field: ‘packages’
[17:48:10.097]   - Field: ‘gc’
[17:48:10.097]   - Field: ‘conditions’
[17:48:10.097]   - Field: ‘persistent’
[17:48:10.097]   - Field: ‘expr’
[17:48:10.097]   - Field: ‘uuid’
[17:48:10.097]   - Field: ‘seed’
[17:48:10.097]   - Field: ‘version’
[17:48:10.097]   - Field: ‘result’
[17:48:10.098]   - Field: ‘asynchronous’
[17:48:10.098]   - Field: ‘calls’
[17:48:10.098]   - Field: ‘globals’
[17:48:10.098]   - Field: ‘stdout’
[17:48:10.098]   - Field: ‘earlySignal’
[17:48:10.098]   - Field: ‘lazy’
[17:48:10.098]   - Field: ‘state’
[17:48:10.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.098] - Launch lazy future ...
[17:48:10.099] Packages needed by the future expression (n = 0): <none>
[17:48:10.099] Packages needed by future strategies (n = 0): <none>
[17:48:10.099] {
[17:48:10.099]     {
[17:48:10.099]         {
[17:48:10.099]             ...future.startTime <- base::Sys.time()
[17:48:10.099]             {
[17:48:10.099]                 {
[17:48:10.099]                   {
[17:48:10.099]                     {
[17:48:10.099]                       base::local({
[17:48:10.099]                         has_future <- base::requireNamespace("future", 
[17:48:10.099]                           quietly = TRUE)
[17:48:10.099]                         if (has_future) {
[17:48:10.099]                           ns <- base::getNamespace("future")
[17:48:10.099]                           version <- ns[[".package"]][["version"]]
[17:48:10.099]                           if (is.null(version)) 
[17:48:10.099]                             version <- utils::packageVersion("future")
[17:48:10.099]                         }
[17:48:10.099]                         else {
[17:48:10.099]                           version <- NULL
[17:48:10.099]                         }
[17:48:10.099]                         if (!has_future || version < "1.8.0") {
[17:48:10.099]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.099]                             "", base::R.version$version.string), 
[17:48:10.099]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.099]                               "release", "version")], collapse = " "), 
[17:48:10.099]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.099]                             info)
[17:48:10.099]                           info <- base::paste(info, collapse = "; ")
[17:48:10.099]                           if (!has_future) {
[17:48:10.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.099]                               info)
[17:48:10.099]                           }
[17:48:10.099]                           else {
[17:48:10.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.099]                               info, version)
[17:48:10.099]                           }
[17:48:10.099]                           base::stop(msg)
[17:48:10.099]                         }
[17:48:10.099]                       })
[17:48:10.099]                     }
[17:48:10.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.099]                     base::options(mc.cores = 1L)
[17:48:10.099]                   }
[17:48:10.099]                   ...future.strategy.old <- future::plan("list")
[17:48:10.099]                   options(future.plan = NULL)
[17:48:10.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.099]                 }
[17:48:10.099]                 ...future.workdir <- getwd()
[17:48:10.099]             }
[17:48:10.099]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.099]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.099]         }
[17:48:10.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.099]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.099]             base::names(...future.oldOptions))
[17:48:10.099]     }
[17:48:10.099]     if (FALSE) {
[17:48:10.099]     }
[17:48:10.099]     else {
[17:48:10.099]         if (TRUE) {
[17:48:10.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.099]                 open = "w")
[17:48:10.099]         }
[17:48:10.099]         else {
[17:48:10.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.099]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.099]         }
[17:48:10.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.099]             base::sink(type = "output", split = FALSE)
[17:48:10.099]             base::close(...future.stdout)
[17:48:10.099]         }, add = TRUE)
[17:48:10.099]     }
[17:48:10.099]     ...future.frame <- base::sys.nframe()
[17:48:10.099]     ...future.conditions <- base::list()
[17:48:10.099]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.099]     if (FALSE) {
[17:48:10.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.099]     }
[17:48:10.099]     ...future.result <- base::tryCatch({
[17:48:10.099]         base::withCallingHandlers({
[17:48:10.099]             ...future.value <- base::withVisible(base::local({
[17:48:10.099]                 ...future.makeSendCondition <- base::local({
[17:48:10.099]                   sendCondition <- NULL
[17:48:10.099]                   function(frame = 1L) {
[17:48:10.099]                     if (is.function(sendCondition)) 
[17:48:10.099]                       return(sendCondition)
[17:48:10.099]                     ns <- getNamespace("parallel")
[17:48:10.099]                     if (exists("sendData", mode = "function", 
[17:48:10.099]                       envir = ns)) {
[17:48:10.099]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.099]                         envir = ns)
[17:48:10.099]                       envir <- sys.frame(frame)
[17:48:10.099]                       master <- NULL
[17:48:10.099]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.099]                         !identical(envir, emptyenv())) {
[17:48:10.099]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.099]                           inherits = FALSE)) {
[17:48:10.099]                           master <- get("master", mode = "list", 
[17:48:10.099]                             envir = envir, inherits = FALSE)
[17:48:10.099]                           if (inherits(master, c("SOCKnode", 
[17:48:10.099]                             "SOCK0node"))) {
[17:48:10.099]                             sendCondition <<- function(cond) {
[17:48:10.099]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.099]                                 success = TRUE)
[17:48:10.099]                               parallel_sendData(master, data)
[17:48:10.099]                             }
[17:48:10.099]                             return(sendCondition)
[17:48:10.099]                           }
[17:48:10.099]                         }
[17:48:10.099]                         frame <- frame + 1L
[17:48:10.099]                         envir <- sys.frame(frame)
[17:48:10.099]                       }
[17:48:10.099]                     }
[17:48:10.099]                     sendCondition <<- function(cond) NULL
[17:48:10.099]                   }
[17:48:10.099]                 })
[17:48:10.099]                 withCallingHandlers({
[17:48:10.099]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:48:10.099]                 }, immediateCondition = function(cond) {
[17:48:10.099]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.099]                   sendCondition(cond)
[17:48:10.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.099]                   {
[17:48:10.099]                     inherits <- base::inherits
[17:48:10.099]                     invokeRestart <- base::invokeRestart
[17:48:10.099]                     is.null <- base::is.null
[17:48:10.099]                     muffled <- FALSE
[17:48:10.099]                     if (inherits(cond, "message")) {
[17:48:10.099]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.099]                       if (muffled) 
[17:48:10.099]                         invokeRestart("muffleMessage")
[17:48:10.099]                     }
[17:48:10.099]                     else if (inherits(cond, "warning")) {
[17:48:10.099]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.099]                       if (muffled) 
[17:48:10.099]                         invokeRestart("muffleWarning")
[17:48:10.099]                     }
[17:48:10.099]                     else if (inherits(cond, "condition")) {
[17:48:10.099]                       if (!is.null(pattern)) {
[17:48:10.099]                         computeRestarts <- base::computeRestarts
[17:48:10.099]                         grepl <- base::grepl
[17:48:10.099]                         restarts <- computeRestarts(cond)
[17:48:10.099]                         for (restart in restarts) {
[17:48:10.099]                           name <- restart$name
[17:48:10.099]                           if (is.null(name)) 
[17:48:10.099]                             next
[17:48:10.099]                           if (!grepl(pattern, name)) 
[17:48:10.099]                             next
[17:48:10.099]                           invokeRestart(restart)
[17:48:10.099]                           muffled <- TRUE
[17:48:10.099]                           break
[17:48:10.099]                         }
[17:48:10.099]                       }
[17:48:10.099]                     }
[17:48:10.099]                     invisible(muffled)
[17:48:10.099]                   }
[17:48:10.099]                   muffleCondition(cond)
[17:48:10.099]                 })
[17:48:10.099]             }))
[17:48:10.099]             future::FutureResult(value = ...future.value$value, 
[17:48:10.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.099]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.099]                     ...future.globalenv.names))
[17:48:10.099]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.099]         }, condition = base::local({
[17:48:10.099]             c <- base::c
[17:48:10.099]             inherits <- base::inherits
[17:48:10.099]             invokeRestart <- base::invokeRestart
[17:48:10.099]             length <- base::length
[17:48:10.099]             list <- base::list
[17:48:10.099]             seq.int <- base::seq.int
[17:48:10.099]             signalCondition <- base::signalCondition
[17:48:10.099]             sys.calls <- base::sys.calls
[17:48:10.099]             `[[` <- base::`[[`
[17:48:10.099]             `+` <- base::`+`
[17:48:10.099]             `<<-` <- base::`<<-`
[17:48:10.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.099]                   3L)]
[17:48:10.099]             }
[17:48:10.099]             function(cond) {
[17:48:10.099]                 is_error <- inherits(cond, "error")
[17:48:10.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.099]                   NULL)
[17:48:10.099]                 if (is_error) {
[17:48:10.099]                   sessionInformation <- function() {
[17:48:10.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.099]                       search = base::search(), system = base::Sys.info())
[17:48:10.099]                   }
[17:48:10.099]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.099]                     cond$call), session = sessionInformation(), 
[17:48:10.099]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.099]                   signalCondition(cond)
[17:48:10.099]                 }
[17:48:10.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.099]                 "immediateCondition"))) {
[17:48:10.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.099]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.099]                   if (TRUE && !signal) {
[17:48:10.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.099]                     {
[17:48:10.099]                       inherits <- base::inherits
[17:48:10.099]                       invokeRestart <- base::invokeRestart
[17:48:10.099]                       is.null <- base::is.null
[17:48:10.099]                       muffled <- FALSE
[17:48:10.099]                       if (inherits(cond, "message")) {
[17:48:10.099]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.099]                         if (muffled) 
[17:48:10.099]                           invokeRestart("muffleMessage")
[17:48:10.099]                       }
[17:48:10.099]                       else if (inherits(cond, "warning")) {
[17:48:10.099]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.099]                         if (muffled) 
[17:48:10.099]                           invokeRestart("muffleWarning")
[17:48:10.099]                       }
[17:48:10.099]                       else if (inherits(cond, "condition")) {
[17:48:10.099]                         if (!is.null(pattern)) {
[17:48:10.099]                           computeRestarts <- base::computeRestarts
[17:48:10.099]                           grepl <- base::grepl
[17:48:10.099]                           restarts <- computeRestarts(cond)
[17:48:10.099]                           for (restart in restarts) {
[17:48:10.099]                             name <- restart$name
[17:48:10.099]                             if (is.null(name)) 
[17:48:10.099]                               next
[17:48:10.099]                             if (!grepl(pattern, name)) 
[17:48:10.099]                               next
[17:48:10.099]                             invokeRestart(restart)
[17:48:10.099]                             muffled <- TRUE
[17:48:10.099]                             break
[17:48:10.099]                           }
[17:48:10.099]                         }
[17:48:10.099]                       }
[17:48:10.099]                       invisible(muffled)
[17:48:10.099]                     }
[17:48:10.099]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.099]                   }
[17:48:10.099]                 }
[17:48:10.099]                 else {
[17:48:10.099]                   if (TRUE) {
[17:48:10.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.099]                     {
[17:48:10.099]                       inherits <- base::inherits
[17:48:10.099]                       invokeRestart <- base::invokeRestart
[17:48:10.099]                       is.null <- base::is.null
[17:48:10.099]                       muffled <- FALSE
[17:48:10.099]                       if (inherits(cond, "message")) {
[17:48:10.099]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.099]                         if (muffled) 
[17:48:10.099]                           invokeRestart("muffleMessage")
[17:48:10.099]                       }
[17:48:10.099]                       else if (inherits(cond, "warning")) {
[17:48:10.099]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.099]                         if (muffled) 
[17:48:10.099]                           invokeRestart("muffleWarning")
[17:48:10.099]                       }
[17:48:10.099]                       else if (inherits(cond, "condition")) {
[17:48:10.099]                         if (!is.null(pattern)) {
[17:48:10.099]                           computeRestarts <- base::computeRestarts
[17:48:10.099]                           grepl <- base::grepl
[17:48:10.099]                           restarts <- computeRestarts(cond)
[17:48:10.099]                           for (restart in restarts) {
[17:48:10.099]                             name <- restart$name
[17:48:10.099]                             if (is.null(name)) 
[17:48:10.099]                               next
[17:48:10.099]                             if (!grepl(pattern, name)) 
[17:48:10.099]                               next
[17:48:10.099]                             invokeRestart(restart)
[17:48:10.099]                             muffled <- TRUE
[17:48:10.099]                             break
[17:48:10.099]                           }
[17:48:10.099]                         }
[17:48:10.099]                       }
[17:48:10.099]                       invisible(muffled)
[17:48:10.099]                     }
[17:48:10.099]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.099]                   }
[17:48:10.099]                 }
[17:48:10.099]             }
[17:48:10.099]         }))
[17:48:10.099]     }, error = function(ex) {
[17:48:10.099]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.099]                 ...future.rng), started = ...future.startTime, 
[17:48:10.099]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.099]             version = "1.8"), class = "FutureResult")
[17:48:10.099]     }, finally = {
[17:48:10.099]         if (!identical(...future.workdir, getwd())) 
[17:48:10.099]             setwd(...future.workdir)
[17:48:10.099]         {
[17:48:10.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.099]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.099]             }
[17:48:10.099]             base::options(...future.oldOptions)
[17:48:10.099]             if (.Platform$OS.type == "windows") {
[17:48:10.099]                 old_names <- names(...future.oldEnvVars)
[17:48:10.099]                 envs <- base::Sys.getenv()
[17:48:10.099]                 names <- names(envs)
[17:48:10.099]                 common <- intersect(names, old_names)
[17:48:10.099]                 added <- setdiff(names, old_names)
[17:48:10.099]                 removed <- setdiff(old_names, names)
[17:48:10.099]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.099]                   envs[common]]
[17:48:10.099]                 NAMES <- toupper(changed)
[17:48:10.099]                 args <- list()
[17:48:10.099]                 for (kk in seq_along(NAMES)) {
[17:48:10.099]                   name <- changed[[kk]]
[17:48:10.099]                   NAME <- NAMES[[kk]]
[17:48:10.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.099]                     next
[17:48:10.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.099]                 }
[17:48:10.099]                 NAMES <- toupper(added)
[17:48:10.099]                 for (kk in seq_along(NAMES)) {
[17:48:10.099]                   name <- added[[kk]]
[17:48:10.099]                   NAME <- NAMES[[kk]]
[17:48:10.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.099]                     next
[17:48:10.099]                   args[[name]] <- ""
[17:48:10.099]                 }
[17:48:10.099]                 NAMES <- toupper(removed)
[17:48:10.099]                 for (kk in seq_along(NAMES)) {
[17:48:10.099]                   name <- removed[[kk]]
[17:48:10.099]                   NAME <- NAMES[[kk]]
[17:48:10.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.099]                     next
[17:48:10.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.099]                 }
[17:48:10.099]                 if (length(args) > 0) 
[17:48:10.099]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.099]             }
[17:48:10.099]             else {
[17:48:10.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.099]             }
[17:48:10.099]             {
[17:48:10.099]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.099]                   0L) {
[17:48:10.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.099]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.099]                   base::options(opts)
[17:48:10.099]                 }
[17:48:10.099]                 {
[17:48:10.099]                   {
[17:48:10.099]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.099]                     NULL
[17:48:10.099]                   }
[17:48:10.099]                   options(future.plan = NULL)
[17:48:10.099]                   if (is.na(NA_character_)) 
[17:48:10.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.099]                     .init = FALSE)
[17:48:10.099]                 }
[17:48:10.099]             }
[17:48:10.099]         }
[17:48:10.099]     })
[17:48:10.099]     if (TRUE) {
[17:48:10.099]         base::sink(type = "output", split = FALSE)
[17:48:10.099]         if (TRUE) {
[17:48:10.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.099]         }
[17:48:10.099]         else {
[17:48:10.099]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.099]         }
[17:48:10.099]         base::close(...future.stdout)
[17:48:10.099]         ...future.stdout <- NULL
[17:48:10.099]     }
[17:48:10.099]     ...future.result$conditions <- ...future.conditions
[17:48:10.099]     ...future.result$finished <- base::Sys.time()
[17:48:10.099]     ...future.result
[17:48:10.099] }
[17:48:10.102] MultisessionFuture started
[17:48:10.102] - Launch lazy future ... done
[17:48:10.102] run() for ‘MultisessionFuture’ ... done
[17:48:10.104] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.104] - Validating connection of MultisessionFuture
[17:48:10.104] - received message: FutureResult
[17:48:10.104] - Received FutureResult
[17:48:10.104] - Erased future from FutureRegistry
[17:48:10.105] result() for ClusterFuture ...
[17:48:10.105] - result already collected: FutureResult
[17:48:10.105] result() for ClusterFuture ... done
[17:48:10.105] signalConditions() ...
[17:48:10.105]  - include = ‘immediateCondition’
[17:48:10.105]  - exclude = 
[17:48:10.105]  - resignal = FALSE
[17:48:10.105]  - Number of conditions: 1
[17:48:10.105] signalConditions() ... done
[17:48:10.105] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.105] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[17:48:10.106] resolve() on list ...
[17:48:10.106]  recursive: 0
[17:48:10.106]  length: 2
[17:48:10.106]  elements: ‘a’, ‘b’
[17:48:10.106]  length: 1 (resolved future 1)
[17:48:10.106]  length: 0 (resolved future 2)
[17:48:10.106] resolve() on list ... DONE
[17:48:10.106] getGlobalsAndPackages() ...
[17:48:10.106] Searching for globals...
[17:48:10.107] 
[17:48:10.107] Searching for globals ... DONE
[17:48:10.107] - globals: [0] <none>
[17:48:10.107] getGlobalsAndPackages() ... DONE
[17:48:10.107] run() for ‘Future’ ...
[17:48:10.107] - state: ‘created’
[17:48:10.108] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.121] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.121] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.121]   - Field: ‘node’
[17:48:10.121]   - Field: ‘label’
[17:48:10.121]   - Field: ‘local’
[17:48:10.121]   - Field: ‘owner’
[17:48:10.121]   - Field: ‘envir’
[17:48:10.122]   - Field: ‘workers’
[17:48:10.122]   - Field: ‘packages’
[17:48:10.122]   - Field: ‘gc’
[17:48:10.122]   - Field: ‘conditions’
[17:48:10.122]   - Field: ‘persistent’
[17:48:10.122]   - Field: ‘expr’
[17:48:10.122]   - Field: ‘uuid’
[17:48:10.122]   - Field: ‘seed’
[17:48:10.122]   - Field: ‘version’
[17:48:10.122]   - Field: ‘result’
[17:48:10.122]   - Field: ‘asynchronous’
[17:48:10.123]   - Field: ‘calls’
[17:48:10.123]   - Field: ‘globals’
[17:48:10.123]   - Field: ‘stdout’
[17:48:10.125]   - Field: ‘earlySignal’
[17:48:10.125]   - Field: ‘lazy’
[17:48:10.125]   - Field: ‘state’
[17:48:10.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.126] - Launch lazy future ...
[17:48:10.126] Packages needed by the future expression (n = 0): <none>
[17:48:10.126] Packages needed by future strategies (n = 0): <none>
[17:48:10.127] {
[17:48:10.127]     {
[17:48:10.127]         {
[17:48:10.127]             ...future.startTime <- base::Sys.time()
[17:48:10.127]             {
[17:48:10.127]                 {
[17:48:10.127]                   {
[17:48:10.127]                     {
[17:48:10.127]                       base::local({
[17:48:10.127]                         has_future <- base::requireNamespace("future", 
[17:48:10.127]                           quietly = TRUE)
[17:48:10.127]                         if (has_future) {
[17:48:10.127]                           ns <- base::getNamespace("future")
[17:48:10.127]                           version <- ns[[".package"]][["version"]]
[17:48:10.127]                           if (is.null(version)) 
[17:48:10.127]                             version <- utils::packageVersion("future")
[17:48:10.127]                         }
[17:48:10.127]                         else {
[17:48:10.127]                           version <- NULL
[17:48:10.127]                         }
[17:48:10.127]                         if (!has_future || version < "1.8.0") {
[17:48:10.127]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.127]                             "", base::R.version$version.string), 
[17:48:10.127]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.127]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.127]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.127]                               "release", "version")], collapse = " "), 
[17:48:10.127]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.127]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.127]                             info)
[17:48:10.127]                           info <- base::paste(info, collapse = "; ")
[17:48:10.127]                           if (!has_future) {
[17:48:10.127]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.127]                               info)
[17:48:10.127]                           }
[17:48:10.127]                           else {
[17:48:10.127]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.127]                               info, version)
[17:48:10.127]                           }
[17:48:10.127]                           base::stop(msg)
[17:48:10.127]                         }
[17:48:10.127]                       })
[17:48:10.127]                     }
[17:48:10.127]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.127]                     base::options(mc.cores = 1L)
[17:48:10.127]                   }
[17:48:10.127]                   ...future.strategy.old <- future::plan("list")
[17:48:10.127]                   options(future.plan = NULL)
[17:48:10.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.127]                 }
[17:48:10.127]                 ...future.workdir <- getwd()
[17:48:10.127]             }
[17:48:10.127]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.127]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.127]         }
[17:48:10.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.127]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.127]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.127]             base::names(...future.oldOptions))
[17:48:10.127]     }
[17:48:10.127]     if (FALSE) {
[17:48:10.127]     }
[17:48:10.127]     else {
[17:48:10.127]         if (TRUE) {
[17:48:10.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.127]                 open = "w")
[17:48:10.127]         }
[17:48:10.127]         else {
[17:48:10.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.127]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.127]         }
[17:48:10.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.127]             base::sink(type = "output", split = FALSE)
[17:48:10.127]             base::close(...future.stdout)
[17:48:10.127]         }, add = TRUE)
[17:48:10.127]     }
[17:48:10.127]     ...future.frame <- base::sys.nframe()
[17:48:10.127]     ...future.conditions <- base::list()
[17:48:10.127]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.127]     if (FALSE) {
[17:48:10.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.127]     }
[17:48:10.127]     ...future.result <- base::tryCatch({
[17:48:10.127]         base::withCallingHandlers({
[17:48:10.127]             ...future.value <- base::withVisible(base::local({
[17:48:10.127]                 ...future.makeSendCondition <- base::local({
[17:48:10.127]                   sendCondition <- NULL
[17:48:10.127]                   function(frame = 1L) {
[17:48:10.127]                     if (is.function(sendCondition)) 
[17:48:10.127]                       return(sendCondition)
[17:48:10.127]                     ns <- getNamespace("parallel")
[17:48:10.127]                     if (exists("sendData", mode = "function", 
[17:48:10.127]                       envir = ns)) {
[17:48:10.127]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.127]                         envir = ns)
[17:48:10.127]                       envir <- sys.frame(frame)
[17:48:10.127]                       master <- NULL
[17:48:10.127]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.127]                         !identical(envir, emptyenv())) {
[17:48:10.127]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.127]                           inherits = FALSE)) {
[17:48:10.127]                           master <- get("master", mode = "list", 
[17:48:10.127]                             envir = envir, inherits = FALSE)
[17:48:10.127]                           if (inherits(master, c("SOCKnode", 
[17:48:10.127]                             "SOCK0node"))) {
[17:48:10.127]                             sendCondition <<- function(cond) {
[17:48:10.127]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.127]                                 success = TRUE)
[17:48:10.127]                               parallel_sendData(master, data)
[17:48:10.127]                             }
[17:48:10.127]                             return(sendCondition)
[17:48:10.127]                           }
[17:48:10.127]                         }
[17:48:10.127]                         frame <- frame + 1L
[17:48:10.127]                         envir <- sys.frame(frame)
[17:48:10.127]                       }
[17:48:10.127]                     }
[17:48:10.127]                     sendCondition <<- function(cond) NULL
[17:48:10.127]                   }
[17:48:10.127]                 })
[17:48:10.127]                 withCallingHandlers({
[17:48:10.127]                   1
[17:48:10.127]                 }, immediateCondition = function(cond) {
[17:48:10.127]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.127]                   sendCondition(cond)
[17:48:10.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.127]                   {
[17:48:10.127]                     inherits <- base::inherits
[17:48:10.127]                     invokeRestart <- base::invokeRestart
[17:48:10.127]                     is.null <- base::is.null
[17:48:10.127]                     muffled <- FALSE
[17:48:10.127]                     if (inherits(cond, "message")) {
[17:48:10.127]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.127]                       if (muffled) 
[17:48:10.127]                         invokeRestart("muffleMessage")
[17:48:10.127]                     }
[17:48:10.127]                     else if (inherits(cond, "warning")) {
[17:48:10.127]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.127]                       if (muffled) 
[17:48:10.127]                         invokeRestart("muffleWarning")
[17:48:10.127]                     }
[17:48:10.127]                     else if (inherits(cond, "condition")) {
[17:48:10.127]                       if (!is.null(pattern)) {
[17:48:10.127]                         computeRestarts <- base::computeRestarts
[17:48:10.127]                         grepl <- base::grepl
[17:48:10.127]                         restarts <- computeRestarts(cond)
[17:48:10.127]                         for (restart in restarts) {
[17:48:10.127]                           name <- restart$name
[17:48:10.127]                           if (is.null(name)) 
[17:48:10.127]                             next
[17:48:10.127]                           if (!grepl(pattern, name)) 
[17:48:10.127]                             next
[17:48:10.127]                           invokeRestart(restart)
[17:48:10.127]                           muffled <- TRUE
[17:48:10.127]                           break
[17:48:10.127]                         }
[17:48:10.127]                       }
[17:48:10.127]                     }
[17:48:10.127]                     invisible(muffled)
[17:48:10.127]                   }
[17:48:10.127]                   muffleCondition(cond)
[17:48:10.127]                 })
[17:48:10.127]             }))
[17:48:10.127]             future::FutureResult(value = ...future.value$value, 
[17:48:10.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.127]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.127]                     ...future.globalenv.names))
[17:48:10.127]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.127]         }, condition = base::local({
[17:48:10.127]             c <- base::c
[17:48:10.127]             inherits <- base::inherits
[17:48:10.127]             invokeRestart <- base::invokeRestart
[17:48:10.127]             length <- base::length
[17:48:10.127]             list <- base::list
[17:48:10.127]             seq.int <- base::seq.int
[17:48:10.127]             signalCondition <- base::signalCondition
[17:48:10.127]             sys.calls <- base::sys.calls
[17:48:10.127]             `[[` <- base::`[[`
[17:48:10.127]             `+` <- base::`+`
[17:48:10.127]             `<<-` <- base::`<<-`
[17:48:10.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.127]                   3L)]
[17:48:10.127]             }
[17:48:10.127]             function(cond) {
[17:48:10.127]                 is_error <- inherits(cond, "error")
[17:48:10.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.127]                   NULL)
[17:48:10.127]                 if (is_error) {
[17:48:10.127]                   sessionInformation <- function() {
[17:48:10.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.127]                       search = base::search(), system = base::Sys.info())
[17:48:10.127]                   }
[17:48:10.127]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.127]                     cond$call), session = sessionInformation(), 
[17:48:10.127]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.127]                   signalCondition(cond)
[17:48:10.127]                 }
[17:48:10.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.127]                 "immediateCondition"))) {
[17:48:10.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.127]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.127]                   if (TRUE && !signal) {
[17:48:10.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.127]                     {
[17:48:10.127]                       inherits <- base::inherits
[17:48:10.127]                       invokeRestart <- base::invokeRestart
[17:48:10.127]                       is.null <- base::is.null
[17:48:10.127]                       muffled <- FALSE
[17:48:10.127]                       if (inherits(cond, "message")) {
[17:48:10.127]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.127]                         if (muffled) 
[17:48:10.127]                           invokeRestart("muffleMessage")
[17:48:10.127]                       }
[17:48:10.127]                       else if (inherits(cond, "warning")) {
[17:48:10.127]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.127]                         if (muffled) 
[17:48:10.127]                           invokeRestart("muffleWarning")
[17:48:10.127]                       }
[17:48:10.127]                       else if (inherits(cond, "condition")) {
[17:48:10.127]                         if (!is.null(pattern)) {
[17:48:10.127]                           computeRestarts <- base::computeRestarts
[17:48:10.127]                           grepl <- base::grepl
[17:48:10.127]                           restarts <- computeRestarts(cond)
[17:48:10.127]                           for (restart in restarts) {
[17:48:10.127]                             name <- restart$name
[17:48:10.127]                             if (is.null(name)) 
[17:48:10.127]                               next
[17:48:10.127]                             if (!grepl(pattern, name)) 
[17:48:10.127]                               next
[17:48:10.127]                             invokeRestart(restart)
[17:48:10.127]                             muffled <- TRUE
[17:48:10.127]                             break
[17:48:10.127]                           }
[17:48:10.127]                         }
[17:48:10.127]                       }
[17:48:10.127]                       invisible(muffled)
[17:48:10.127]                     }
[17:48:10.127]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.127]                   }
[17:48:10.127]                 }
[17:48:10.127]                 else {
[17:48:10.127]                   if (TRUE) {
[17:48:10.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.127]                     {
[17:48:10.127]                       inherits <- base::inherits
[17:48:10.127]                       invokeRestart <- base::invokeRestart
[17:48:10.127]                       is.null <- base::is.null
[17:48:10.127]                       muffled <- FALSE
[17:48:10.127]                       if (inherits(cond, "message")) {
[17:48:10.127]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.127]                         if (muffled) 
[17:48:10.127]                           invokeRestart("muffleMessage")
[17:48:10.127]                       }
[17:48:10.127]                       else if (inherits(cond, "warning")) {
[17:48:10.127]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.127]                         if (muffled) 
[17:48:10.127]                           invokeRestart("muffleWarning")
[17:48:10.127]                       }
[17:48:10.127]                       else if (inherits(cond, "condition")) {
[17:48:10.127]                         if (!is.null(pattern)) {
[17:48:10.127]                           computeRestarts <- base::computeRestarts
[17:48:10.127]                           grepl <- base::grepl
[17:48:10.127]                           restarts <- computeRestarts(cond)
[17:48:10.127]                           for (restart in restarts) {
[17:48:10.127]                             name <- restart$name
[17:48:10.127]                             if (is.null(name)) 
[17:48:10.127]                               next
[17:48:10.127]                             if (!grepl(pattern, name)) 
[17:48:10.127]                               next
[17:48:10.127]                             invokeRestart(restart)
[17:48:10.127]                             muffled <- TRUE
[17:48:10.127]                             break
[17:48:10.127]                           }
[17:48:10.127]                         }
[17:48:10.127]                       }
[17:48:10.127]                       invisible(muffled)
[17:48:10.127]                     }
[17:48:10.127]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.127]                   }
[17:48:10.127]                 }
[17:48:10.127]             }
[17:48:10.127]         }))
[17:48:10.127]     }, error = function(ex) {
[17:48:10.127]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.127]                 ...future.rng), started = ...future.startTime, 
[17:48:10.127]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.127]             version = "1.8"), class = "FutureResult")
[17:48:10.127]     }, finally = {
[17:48:10.127]         if (!identical(...future.workdir, getwd())) 
[17:48:10.127]             setwd(...future.workdir)
[17:48:10.127]         {
[17:48:10.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.127]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.127]             }
[17:48:10.127]             base::options(...future.oldOptions)
[17:48:10.127]             if (.Platform$OS.type == "windows") {
[17:48:10.127]                 old_names <- names(...future.oldEnvVars)
[17:48:10.127]                 envs <- base::Sys.getenv()
[17:48:10.127]                 names <- names(envs)
[17:48:10.127]                 common <- intersect(names, old_names)
[17:48:10.127]                 added <- setdiff(names, old_names)
[17:48:10.127]                 removed <- setdiff(old_names, names)
[17:48:10.127]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.127]                   envs[common]]
[17:48:10.127]                 NAMES <- toupper(changed)
[17:48:10.127]                 args <- list()
[17:48:10.127]                 for (kk in seq_along(NAMES)) {
[17:48:10.127]                   name <- changed[[kk]]
[17:48:10.127]                   NAME <- NAMES[[kk]]
[17:48:10.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.127]                     next
[17:48:10.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.127]                 }
[17:48:10.127]                 NAMES <- toupper(added)
[17:48:10.127]                 for (kk in seq_along(NAMES)) {
[17:48:10.127]                   name <- added[[kk]]
[17:48:10.127]                   NAME <- NAMES[[kk]]
[17:48:10.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.127]                     next
[17:48:10.127]                   args[[name]] <- ""
[17:48:10.127]                 }
[17:48:10.127]                 NAMES <- toupper(removed)
[17:48:10.127]                 for (kk in seq_along(NAMES)) {
[17:48:10.127]                   name <- removed[[kk]]
[17:48:10.127]                   NAME <- NAMES[[kk]]
[17:48:10.127]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.127]                     next
[17:48:10.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.127]                 }
[17:48:10.127]                 if (length(args) > 0) 
[17:48:10.127]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.127]             }
[17:48:10.127]             else {
[17:48:10.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.127]             }
[17:48:10.127]             {
[17:48:10.127]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.127]                   0L) {
[17:48:10.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.127]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.127]                   base::options(opts)
[17:48:10.127]                 }
[17:48:10.127]                 {
[17:48:10.127]                   {
[17:48:10.127]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.127]                     NULL
[17:48:10.127]                   }
[17:48:10.127]                   options(future.plan = NULL)
[17:48:10.127]                   if (is.na(NA_character_)) 
[17:48:10.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.127]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.127]                     .init = FALSE)
[17:48:10.127]                 }
[17:48:10.127]             }
[17:48:10.127]         }
[17:48:10.127]     })
[17:48:10.127]     if (TRUE) {
[17:48:10.127]         base::sink(type = "output", split = FALSE)
[17:48:10.127]         if (TRUE) {
[17:48:10.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.127]         }
[17:48:10.127]         else {
[17:48:10.127]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.127]         }
[17:48:10.127]         base::close(...future.stdout)
[17:48:10.127]         ...future.stdout <- NULL
[17:48:10.127]     }
[17:48:10.127]     ...future.result$conditions <- ...future.conditions
[17:48:10.127]     ...future.result$finished <- base::Sys.time()
[17:48:10.127]     ...future.result
[17:48:10.127] }
[17:48:10.130] MultisessionFuture started
[17:48:10.130] - Launch lazy future ... done
[17:48:10.130] run() for ‘MultisessionFuture’ ... done
[17:48:10.130] getGlobalsAndPackages() ...
[17:48:10.130] Searching for globals...
[17:48:10.131] 
[17:48:10.131] Searching for globals ... DONE
[17:48:10.131] - globals: [0] <none>
[17:48:10.131] getGlobalsAndPackages() ... DONE
[17:48:10.131] run() for ‘Future’ ...
[17:48:10.132] - state: ‘created’
[17:48:10.132] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.145] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.146] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.146]   - Field: ‘node’
[17:48:10.146]   - Field: ‘label’
[17:48:10.146]   - Field: ‘local’
[17:48:10.146]   - Field: ‘owner’
[17:48:10.146]   - Field: ‘envir’
[17:48:10.146]   - Field: ‘workers’
[17:48:10.146]   - Field: ‘packages’
[17:48:10.146]   - Field: ‘gc’
[17:48:10.146]   - Field: ‘conditions’
[17:48:10.147]   - Field: ‘persistent’
[17:48:10.147]   - Field: ‘expr’
[17:48:10.147]   - Field: ‘uuid’
[17:48:10.147]   - Field: ‘seed’
[17:48:10.147]   - Field: ‘version’
[17:48:10.147]   - Field: ‘result’
[17:48:10.147]   - Field: ‘asynchronous’
[17:48:10.147]   - Field: ‘calls’
[17:48:10.147]   - Field: ‘globals’
[17:48:10.147]   - Field: ‘stdout’
[17:48:10.147]   - Field: ‘earlySignal’
[17:48:10.148]   - Field: ‘lazy’
[17:48:10.148]   - Field: ‘state’
[17:48:10.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.148] - Launch lazy future ...
[17:48:10.148] Packages needed by the future expression (n = 0): <none>
[17:48:10.148] Packages needed by future strategies (n = 0): <none>
[17:48:10.149] {
[17:48:10.149]     {
[17:48:10.149]         {
[17:48:10.149]             ...future.startTime <- base::Sys.time()
[17:48:10.149]             {
[17:48:10.149]                 {
[17:48:10.149]                   {
[17:48:10.149]                     {
[17:48:10.149]                       base::local({
[17:48:10.149]                         has_future <- base::requireNamespace("future", 
[17:48:10.149]                           quietly = TRUE)
[17:48:10.149]                         if (has_future) {
[17:48:10.149]                           ns <- base::getNamespace("future")
[17:48:10.149]                           version <- ns[[".package"]][["version"]]
[17:48:10.149]                           if (is.null(version)) 
[17:48:10.149]                             version <- utils::packageVersion("future")
[17:48:10.149]                         }
[17:48:10.149]                         else {
[17:48:10.149]                           version <- NULL
[17:48:10.149]                         }
[17:48:10.149]                         if (!has_future || version < "1.8.0") {
[17:48:10.149]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.149]                             "", base::R.version$version.string), 
[17:48:10.149]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.149]                               "release", "version")], collapse = " "), 
[17:48:10.149]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.149]                             info)
[17:48:10.149]                           info <- base::paste(info, collapse = "; ")
[17:48:10.149]                           if (!has_future) {
[17:48:10.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.149]                               info)
[17:48:10.149]                           }
[17:48:10.149]                           else {
[17:48:10.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.149]                               info, version)
[17:48:10.149]                           }
[17:48:10.149]                           base::stop(msg)
[17:48:10.149]                         }
[17:48:10.149]                       })
[17:48:10.149]                     }
[17:48:10.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.149]                     base::options(mc.cores = 1L)
[17:48:10.149]                   }
[17:48:10.149]                   ...future.strategy.old <- future::plan("list")
[17:48:10.149]                   options(future.plan = NULL)
[17:48:10.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.149]                 }
[17:48:10.149]                 ...future.workdir <- getwd()
[17:48:10.149]             }
[17:48:10.149]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.149]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.149]         }
[17:48:10.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.149]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.149]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.149]             base::names(...future.oldOptions))
[17:48:10.149]     }
[17:48:10.149]     if (FALSE) {
[17:48:10.149]     }
[17:48:10.149]     else {
[17:48:10.149]         if (TRUE) {
[17:48:10.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.149]                 open = "w")
[17:48:10.149]         }
[17:48:10.149]         else {
[17:48:10.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.149]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.149]         }
[17:48:10.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.149]             base::sink(type = "output", split = FALSE)
[17:48:10.149]             base::close(...future.stdout)
[17:48:10.149]         }, add = TRUE)
[17:48:10.149]     }
[17:48:10.149]     ...future.frame <- base::sys.nframe()
[17:48:10.149]     ...future.conditions <- base::list()
[17:48:10.149]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.149]     if (FALSE) {
[17:48:10.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.149]     }
[17:48:10.149]     ...future.result <- base::tryCatch({
[17:48:10.149]         base::withCallingHandlers({
[17:48:10.149]             ...future.value <- base::withVisible(base::local({
[17:48:10.149]                 ...future.makeSendCondition <- base::local({
[17:48:10.149]                   sendCondition <- NULL
[17:48:10.149]                   function(frame = 1L) {
[17:48:10.149]                     if (is.function(sendCondition)) 
[17:48:10.149]                       return(sendCondition)
[17:48:10.149]                     ns <- getNamespace("parallel")
[17:48:10.149]                     if (exists("sendData", mode = "function", 
[17:48:10.149]                       envir = ns)) {
[17:48:10.149]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.149]                         envir = ns)
[17:48:10.149]                       envir <- sys.frame(frame)
[17:48:10.149]                       master <- NULL
[17:48:10.149]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.149]                         !identical(envir, emptyenv())) {
[17:48:10.149]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.149]                           inherits = FALSE)) {
[17:48:10.149]                           master <- get("master", mode = "list", 
[17:48:10.149]                             envir = envir, inherits = FALSE)
[17:48:10.149]                           if (inherits(master, c("SOCKnode", 
[17:48:10.149]                             "SOCK0node"))) {
[17:48:10.149]                             sendCondition <<- function(cond) {
[17:48:10.149]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.149]                                 success = TRUE)
[17:48:10.149]                               parallel_sendData(master, data)
[17:48:10.149]                             }
[17:48:10.149]                             return(sendCondition)
[17:48:10.149]                           }
[17:48:10.149]                         }
[17:48:10.149]                         frame <- frame + 1L
[17:48:10.149]                         envir <- sys.frame(frame)
[17:48:10.149]                       }
[17:48:10.149]                     }
[17:48:10.149]                     sendCondition <<- function(cond) NULL
[17:48:10.149]                   }
[17:48:10.149]                 })
[17:48:10.149]                 withCallingHandlers({
[17:48:10.149]                   2
[17:48:10.149]                 }, immediateCondition = function(cond) {
[17:48:10.149]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.149]                   sendCondition(cond)
[17:48:10.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.149]                   {
[17:48:10.149]                     inherits <- base::inherits
[17:48:10.149]                     invokeRestart <- base::invokeRestart
[17:48:10.149]                     is.null <- base::is.null
[17:48:10.149]                     muffled <- FALSE
[17:48:10.149]                     if (inherits(cond, "message")) {
[17:48:10.149]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.149]                       if (muffled) 
[17:48:10.149]                         invokeRestart("muffleMessage")
[17:48:10.149]                     }
[17:48:10.149]                     else if (inherits(cond, "warning")) {
[17:48:10.149]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.149]                       if (muffled) 
[17:48:10.149]                         invokeRestart("muffleWarning")
[17:48:10.149]                     }
[17:48:10.149]                     else if (inherits(cond, "condition")) {
[17:48:10.149]                       if (!is.null(pattern)) {
[17:48:10.149]                         computeRestarts <- base::computeRestarts
[17:48:10.149]                         grepl <- base::grepl
[17:48:10.149]                         restarts <- computeRestarts(cond)
[17:48:10.149]                         for (restart in restarts) {
[17:48:10.149]                           name <- restart$name
[17:48:10.149]                           if (is.null(name)) 
[17:48:10.149]                             next
[17:48:10.149]                           if (!grepl(pattern, name)) 
[17:48:10.149]                             next
[17:48:10.149]                           invokeRestart(restart)
[17:48:10.149]                           muffled <- TRUE
[17:48:10.149]                           break
[17:48:10.149]                         }
[17:48:10.149]                       }
[17:48:10.149]                     }
[17:48:10.149]                     invisible(muffled)
[17:48:10.149]                   }
[17:48:10.149]                   muffleCondition(cond)
[17:48:10.149]                 })
[17:48:10.149]             }))
[17:48:10.149]             future::FutureResult(value = ...future.value$value, 
[17:48:10.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.149]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.149]                     ...future.globalenv.names))
[17:48:10.149]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.149]         }, condition = base::local({
[17:48:10.149]             c <- base::c
[17:48:10.149]             inherits <- base::inherits
[17:48:10.149]             invokeRestart <- base::invokeRestart
[17:48:10.149]             length <- base::length
[17:48:10.149]             list <- base::list
[17:48:10.149]             seq.int <- base::seq.int
[17:48:10.149]             signalCondition <- base::signalCondition
[17:48:10.149]             sys.calls <- base::sys.calls
[17:48:10.149]             `[[` <- base::`[[`
[17:48:10.149]             `+` <- base::`+`
[17:48:10.149]             `<<-` <- base::`<<-`
[17:48:10.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.149]                   3L)]
[17:48:10.149]             }
[17:48:10.149]             function(cond) {
[17:48:10.149]                 is_error <- inherits(cond, "error")
[17:48:10.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.149]                   NULL)
[17:48:10.149]                 if (is_error) {
[17:48:10.149]                   sessionInformation <- function() {
[17:48:10.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.149]                       search = base::search(), system = base::Sys.info())
[17:48:10.149]                   }
[17:48:10.149]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.149]                     cond$call), session = sessionInformation(), 
[17:48:10.149]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.149]                   signalCondition(cond)
[17:48:10.149]                 }
[17:48:10.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.149]                 "immediateCondition"))) {
[17:48:10.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.149]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.149]                   if (TRUE && !signal) {
[17:48:10.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.149]                     {
[17:48:10.149]                       inherits <- base::inherits
[17:48:10.149]                       invokeRestart <- base::invokeRestart
[17:48:10.149]                       is.null <- base::is.null
[17:48:10.149]                       muffled <- FALSE
[17:48:10.149]                       if (inherits(cond, "message")) {
[17:48:10.149]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.149]                         if (muffled) 
[17:48:10.149]                           invokeRestart("muffleMessage")
[17:48:10.149]                       }
[17:48:10.149]                       else if (inherits(cond, "warning")) {
[17:48:10.149]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.149]                         if (muffled) 
[17:48:10.149]                           invokeRestart("muffleWarning")
[17:48:10.149]                       }
[17:48:10.149]                       else if (inherits(cond, "condition")) {
[17:48:10.149]                         if (!is.null(pattern)) {
[17:48:10.149]                           computeRestarts <- base::computeRestarts
[17:48:10.149]                           grepl <- base::grepl
[17:48:10.149]                           restarts <- computeRestarts(cond)
[17:48:10.149]                           for (restart in restarts) {
[17:48:10.149]                             name <- restart$name
[17:48:10.149]                             if (is.null(name)) 
[17:48:10.149]                               next
[17:48:10.149]                             if (!grepl(pattern, name)) 
[17:48:10.149]                               next
[17:48:10.149]                             invokeRestart(restart)
[17:48:10.149]                             muffled <- TRUE
[17:48:10.149]                             break
[17:48:10.149]                           }
[17:48:10.149]                         }
[17:48:10.149]                       }
[17:48:10.149]                       invisible(muffled)
[17:48:10.149]                     }
[17:48:10.149]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.149]                   }
[17:48:10.149]                 }
[17:48:10.149]                 else {
[17:48:10.149]                   if (TRUE) {
[17:48:10.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.149]                     {
[17:48:10.149]                       inherits <- base::inherits
[17:48:10.149]                       invokeRestart <- base::invokeRestart
[17:48:10.149]                       is.null <- base::is.null
[17:48:10.149]                       muffled <- FALSE
[17:48:10.149]                       if (inherits(cond, "message")) {
[17:48:10.149]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.149]                         if (muffled) 
[17:48:10.149]                           invokeRestart("muffleMessage")
[17:48:10.149]                       }
[17:48:10.149]                       else if (inherits(cond, "warning")) {
[17:48:10.149]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.149]                         if (muffled) 
[17:48:10.149]                           invokeRestart("muffleWarning")
[17:48:10.149]                       }
[17:48:10.149]                       else if (inherits(cond, "condition")) {
[17:48:10.149]                         if (!is.null(pattern)) {
[17:48:10.149]                           computeRestarts <- base::computeRestarts
[17:48:10.149]                           grepl <- base::grepl
[17:48:10.149]                           restarts <- computeRestarts(cond)
[17:48:10.149]                           for (restart in restarts) {
[17:48:10.149]                             name <- restart$name
[17:48:10.149]                             if (is.null(name)) 
[17:48:10.149]                               next
[17:48:10.149]                             if (!grepl(pattern, name)) 
[17:48:10.149]                               next
[17:48:10.149]                             invokeRestart(restart)
[17:48:10.149]                             muffled <- TRUE
[17:48:10.149]                             break
[17:48:10.149]                           }
[17:48:10.149]                         }
[17:48:10.149]                       }
[17:48:10.149]                       invisible(muffled)
[17:48:10.149]                     }
[17:48:10.149]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.149]                   }
[17:48:10.149]                 }
[17:48:10.149]             }
[17:48:10.149]         }))
[17:48:10.149]     }, error = function(ex) {
[17:48:10.149]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.149]                 ...future.rng), started = ...future.startTime, 
[17:48:10.149]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.149]             version = "1.8"), class = "FutureResult")
[17:48:10.149]     }, finally = {
[17:48:10.149]         if (!identical(...future.workdir, getwd())) 
[17:48:10.149]             setwd(...future.workdir)
[17:48:10.149]         {
[17:48:10.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.149]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.149]             }
[17:48:10.149]             base::options(...future.oldOptions)
[17:48:10.149]             if (.Platform$OS.type == "windows") {
[17:48:10.149]                 old_names <- names(...future.oldEnvVars)
[17:48:10.149]                 envs <- base::Sys.getenv()
[17:48:10.149]                 names <- names(envs)
[17:48:10.149]                 common <- intersect(names, old_names)
[17:48:10.149]                 added <- setdiff(names, old_names)
[17:48:10.149]                 removed <- setdiff(old_names, names)
[17:48:10.149]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.149]                   envs[common]]
[17:48:10.149]                 NAMES <- toupper(changed)
[17:48:10.149]                 args <- list()
[17:48:10.149]                 for (kk in seq_along(NAMES)) {
[17:48:10.149]                   name <- changed[[kk]]
[17:48:10.149]                   NAME <- NAMES[[kk]]
[17:48:10.149]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.149]                     next
[17:48:10.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.149]                 }
[17:48:10.149]                 NAMES <- toupper(added)
[17:48:10.149]                 for (kk in seq_along(NAMES)) {
[17:48:10.149]                   name <- added[[kk]]
[17:48:10.149]                   NAME <- NAMES[[kk]]
[17:48:10.149]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.149]                     next
[17:48:10.149]                   args[[name]] <- ""
[17:48:10.149]                 }
[17:48:10.149]                 NAMES <- toupper(removed)
[17:48:10.149]                 for (kk in seq_along(NAMES)) {
[17:48:10.149]                   name <- removed[[kk]]
[17:48:10.149]                   NAME <- NAMES[[kk]]
[17:48:10.149]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.149]                     next
[17:48:10.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.149]                 }
[17:48:10.149]                 if (length(args) > 0) 
[17:48:10.149]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.149]             }
[17:48:10.149]             else {
[17:48:10.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.149]             }
[17:48:10.149]             {
[17:48:10.149]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.149]                   0L) {
[17:48:10.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.149]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.149]                   base::options(opts)
[17:48:10.149]                 }
[17:48:10.149]                 {
[17:48:10.149]                   {
[17:48:10.149]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.149]                     NULL
[17:48:10.149]                   }
[17:48:10.149]                   options(future.plan = NULL)
[17:48:10.149]                   if (is.na(NA_character_)) 
[17:48:10.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.149]                     .init = FALSE)
[17:48:10.149]                 }
[17:48:10.149]             }
[17:48:10.149]         }
[17:48:10.149]     })
[17:48:10.149]     if (TRUE) {
[17:48:10.149]         base::sink(type = "output", split = FALSE)
[17:48:10.149]         if (TRUE) {
[17:48:10.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.149]         }
[17:48:10.149]         else {
[17:48:10.149]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.149]         }
[17:48:10.149]         base::close(...future.stdout)
[17:48:10.149]         ...future.stdout <- NULL
[17:48:10.149]     }
[17:48:10.149]     ...future.result$conditions <- ...future.conditions
[17:48:10.149]     ...future.result$finished <- base::Sys.time()
[17:48:10.149]     ...future.result
[17:48:10.149] }
[17:48:10.151] Poll #1 (0): usedNodes() = 2, workers = 2
[17:48:10.161] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.161] - Validating connection of MultisessionFuture
[17:48:10.162] - received message: FutureResult
[17:48:10.162] - Received FutureResult
[17:48:10.162] - Erased future from FutureRegistry
[17:48:10.162] result() for ClusterFuture ...
[17:48:10.162] - result already collected: FutureResult
[17:48:10.162] result() for ClusterFuture ... done
[17:48:10.162] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.162] result() for ClusterFuture ...
[17:48:10.162] - result already collected: FutureResult
[17:48:10.162] result() for ClusterFuture ... done
[17:48:10.163] result() for ClusterFuture ...
[17:48:10.163] - result already collected: FutureResult
[17:48:10.163] result() for ClusterFuture ... done
[17:48:10.164] MultisessionFuture started
[17:48:10.164] - Launch lazy future ... done
[17:48:10.164] run() for ‘MultisessionFuture’ ... done
[17:48:10.164] resolve() on list ...
[17:48:10.164]  recursive: 0
[17:48:10.165]  length: 3
[17:48:10.165]  elements: ‘a’, ‘b’, ‘’
[17:48:10.165] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.166] - Validating connection of MultisessionFuture
[17:48:10.166] - received message: FutureResult
[17:48:10.166] - Received FutureResult
[17:48:10.166] - Erased future from FutureRegistry
[17:48:10.166] result() for ClusterFuture ...
[17:48:10.166] - result already collected: FutureResult
[17:48:10.166] result() for ClusterFuture ... done
[17:48:10.166] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.167] Future #1
[17:48:10.167]  length: 2 (resolved future 1)
[17:48:10.167] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.167] - Validating connection of MultisessionFuture
[17:48:10.167] - received message: FutureResult
[17:48:10.168] - Received FutureResult
[17:48:10.168] - Erased future from FutureRegistry
[17:48:10.168] result() for ClusterFuture ...
[17:48:10.168] - result already collected: FutureResult
[17:48:10.168] result() for ClusterFuture ... done
[17:48:10.168] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.168] Future #2
[17:48:10.168]  length: 1 (resolved future 2)
[17:48:10.168]  length: 0 (resolved future 3)
[17:48:10.168] resolve() on list ... DONE
[17:48:10.168] getGlobalsAndPackages() ...
[17:48:10.169] Searching for globals...
[17:48:10.169] 
[17:48:10.169] Searching for globals ... DONE
[17:48:10.169] - globals: [0] <none>
[17:48:10.169] getGlobalsAndPackages() ... DONE
[17:48:10.169] getGlobalsAndPackages() ...
[17:48:10.169] Searching for globals...
[17:48:10.170] 
[17:48:10.170] Searching for globals ... DONE
[17:48:10.170] - globals: [0] <none>
[17:48:10.170] getGlobalsAndPackages() ... DONE
[17:48:10.170] run() for ‘Future’ ...
[17:48:10.170] - state: ‘created’
[17:48:10.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.184]   - Field: ‘node’
[17:48:10.184]   - Field: ‘label’
[17:48:10.184]   - Field: ‘local’
[17:48:10.184]   - Field: ‘owner’
[17:48:10.185]   - Field: ‘envir’
[17:48:10.185]   - Field: ‘workers’
[17:48:10.185]   - Field: ‘packages’
[17:48:10.185]   - Field: ‘gc’
[17:48:10.185]   - Field: ‘conditions’
[17:48:10.185]   - Field: ‘persistent’
[17:48:10.185]   - Field: ‘expr’
[17:48:10.185]   - Field: ‘uuid’
[17:48:10.185]   - Field: ‘seed’
[17:48:10.185]   - Field: ‘version’
[17:48:10.185]   - Field: ‘result’
[17:48:10.186]   - Field: ‘asynchronous’
[17:48:10.186]   - Field: ‘calls’
[17:48:10.186]   - Field: ‘globals’
[17:48:10.186]   - Field: ‘stdout’
[17:48:10.186]   - Field: ‘earlySignal’
[17:48:10.186]   - Field: ‘lazy’
[17:48:10.186]   - Field: ‘state’
[17:48:10.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.186] - Launch lazy future ...
[17:48:10.187] Packages needed by the future expression (n = 0): <none>
[17:48:10.187] Packages needed by future strategies (n = 0): <none>
[17:48:10.187] {
[17:48:10.187]     {
[17:48:10.187]         {
[17:48:10.187]             ...future.startTime <- base::Sys.time()
[17:48:10.187]             {
[17:48:10.187]                 {
[17:48:10.187]                   {
[17:48:10.187]                     {
[17:48:10.187]                       base::local({
[17:48:10.187]                         has_future <- base::requireNamespace("future", 
[17:48:10.187]                           quietly = TRUE)
[17:48:10.187]                         if (has_future) {
[17:48:10.187]                           ns <- base::getNamespace("future")
[17:48:10.187]                           version <- ns[[".package"]][["version"]]
[17:48:10.187]                           if (is.null(version)) 
[17:48:10.187]                             version <- utils::packageVersion("future")
[17:48:10.187]                         }
[17:48:10.187]                         else {
[17:48:10.187]                           version <- NULL
[17:48:10.187]                         }
[17:48:10.187]                         if (!has_future || version < "1.8.0") {
[17:48:10.187]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.187]                             "", base::R.version$version.string), 
[17:48:10.187]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.187]                               "release", "version")], collapse = " "), 
[17:48:10.187]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.187]                             info)
[17:48:10.187]                           info <- base::paste(info, collapse = "; ")
[17:48:10.187]                           if (!has_future) {
[17:48:10.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.187]                               info)
[17:48:10.187]                           }
[17:48:10.187]                           else {
[17:48:10.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.187]                               info, version)
[17:48:10.187]                           }
[17:48:10.187]                           base::stop(msg)
[17:48:10.187]                         }
[17:48:10.187]                       })
[17:48:10.187]                     }
[17:48:10.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.187]                     base::options(mc.cores = 1L)
[17:48:10.187]                   }
[17:48:10.187]                   ...future.strategy.old <- future::plan("list")
[17:48:10.187]                   options(future.plan = NULL)
[17:48:10.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.187]                 }
[17:48:10.187]                 ...future.workdir <- getwd()
[17:48:10.187]             }
[17:48:10.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.187]         }
[17:48:10.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.187]             base::names(...future.oldOptions))
[17:48:10.187]     }
[17:48:10.187]     if (FALSE) {
[17:48:10.187]     }
[17:48:10.187]     else {
[17:48:10.187]         if (TRUE) {
[17:48:10.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.187]                 open = "w")
[17:48:10.187]         }
[17:48:10.187]         else {
[17:48:10.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.187]         }
[17:48:10.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.187]             base::sink(type = "output", split = FALSE)
[17:48:10.187]             base::close(...future.stdout)
[17:48:10.187]         }, add = TRUE)
[17:48:10.187]     }
[17:48:10.187]     ...future.frame <- base::sys.nframe()
[17:48:10.187]     ...future.conditions <- base::list()
[17:48:10.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.187]     if (FALSE) {
[17:48:10.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.187]     }
[17:48:10.187]     ...future.result <- base::tryCatch({
[17:48:10.187]         base::withCallingHandlers({
[17:48:10.187]             ...future.value <- base::withVisible(base::local({
[17:48:10.187]                 ...future.makeSendCondition <- base::local({
[17:48:10.187]                   sendCondition <- NULL
[17:48:10.187]                   function(frame = 1L) {
[17:48:10.187]                     if (is.function(sendCondition)) 
[17:48:10.187]                       return(sendCondition)
[17:48:10.187]                     ns <- getNamespace("parallel")
[17:48:10.187]                     if (exists("sendData", mode = "function", 
[17:48:10.187]                       envir = ns)) {
[17:48:10.187]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.187]                         envir = ns)
[17:48:10.187]                       envir <- sys.frame(frame)
[17:48:10.187]                       master <- NULL
[17:48:10.187]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.187]                         !identical(envir, emptyenv())) {
[17:48:10.187]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.187]                           inherits = FALSE)) {
[17:48:10.187]                           master <- get("master", mode = "list", 
[17:48:10.187]                             envir = envir, inherits = FALSE)
[17:48:10.187]                           if (inherits(master, c("SOCKnode", 
[17:48:10.187]                             "SOCK0node"))) {
[17:48:10.187]                             sendCondition <<- function(cond) {
[17:48:10.187]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.187]                                 success = TRUE)
[17:48:10.187]                               parallel_sendData(master, data)
[17:48:10.187]                             }
[17:48:10.187]                             return(sendCondition)
[17:48:10.187]                           }
[17:48:10.187]                         }
[17:48:10.187]                         frame <- frame + 1L
[17:48:10.187]                         envir <- sys.frame(frame)
[17:48:10.187]                       }
[17:48:10.187]                     }
[17:48:10.187]                     sendCondition <<- function(cond) NULL
[17:48:10.187]                   }
[17:48:10.187]                 })
[17:48:10.187]                 withCallingHandlers({
[17:48:10.187]                   2
[17:48:10.187]                 }, immediateCondition = function(cond) {
[17:48:10.187]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.187]                   sendCondition(cond)
[17:48:10.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.187]                   {
[17:48:10.187]                     inherits <- base::inherits
[17:48:10.187]                     invokeRestart <- base::invokeRestart
[17:48:10.187]                     is.null <- base::is.null
[17:48:10.187]                     muffled <- FALSE
[17:48:10.187]                     if (inherits(cond, "message")) {
[17:48:10.187]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.187]                       if (muffled) 
[17:48:10.187]                         invokeRestart("muffleMessage")
[17:48:10.187]                     }
[17:48:10.187]                     else if (inherits(cond, "warning")) {
[17:48:10.187]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.187]                       if (muffled) 
[17:48:10.187]                         invokeRestart("muffleWarning")
[17:48:10.187]                     }
[17:48:10.187]                     else if (inherits(cond, "condition")) {
[17:48:10.187]                       if (!is.null(pattern)) {
[17:48:10.187]                         computeRestarts <- base::computeRestarts
[17:48:10.187]                         grepl <- base::grepl
[17:48:10.187]                         restarts <- computeRestarts(cond)
[17:48:10.187]                         for (restart in restarts) {
[17:48:10.187]                           name <- restart$name
[17:48:10.187]                           if (is.null(name)) 
[17:48:10.187]                             next
[17:48:10.187]                           if (!grepl(pattern, name)) 
[17:48:10.187]                             next
[17:48:10.187]                           invokeRestart(restart)
[17:48:10.187]                           muffled <- TRUE
[17:48:10.187]                           break
[17:48:10.187]                         }
[17:48:10.187]                       }
[17:48:10.187]                     }
[17:48:10.187]                     invisible(muffled)
[17:48:10.187]                   }
[17:48:10.187]                   muffleCondition(cond)
[17:48:10.187]                 })
[17:48:10.187]             }))
[17:48:10.187]             future::FutureResult(value = ...future.value$value, 
[17:48:10.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.187]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.187]                     ...future.globalenv.names))
[17:48:10.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.187]         }, condition = base::local({
[17:48:10.187]             c <- base::c
[17:48:10.187]             inherits <- base::inherits
[17:48:10.187]             invokeRestart <- base::invokeRestart
[17:48:10.187]             length <- base::length
[17:48:10.187]             list <- base::list
[17:48:10.187]             seq.int <- base::seq.int
[17:48:10.187]             signalCondition <- base::signalCondition
[17:48:10.187]             sys.calls <- base::sys.calls
[17:48:10.187]             `[[` <- base::`[[`
[17:48:10.187]             `+` <- base::`+`
[17:48:10.187]             `<<-` <- base::`<<-`
[17:48:10.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.187]                   3L)]
[17:48:10.187]             }
[17:48:10.187]             function(cond) {
[17:48:10.187]                 is_error <- inherits(cond, "error")
[17:48:10.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.187]                   NULL)
[17:48:10.187]                 if (is_error) {
[17:48:10.187]                   sessionInformation <- function() {
[17:48:10.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.187]                       search = base::search(), system = base::Sys.info())
[17:48:10.187]                   }
[17:48:10.187]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.187]                     cond$call), session = sessionInformation(), 
[17:48:10.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.187]                   signalCondition(cond)
[17:48:10.187]                 }
[17:48:10.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.187]                 "immediateCondition"))) {
[17:48:10.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.187]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.187]                   if (TRUE && !signal) {
[17:48:10.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.187]                     {
[17:48:10.187]                       inherits <- base::inherits
[17:48:10.187]                       invokeRestart <- base::invokeRestart
[17:48:10.187]                       is.null <- base::is.null
[17:48:10.187]                       muffled <- FALSE
[17:48:10.187]                       if (inherits(cond, "message")) {
[17:48:10.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.187]                         if (muffled) 
[17:48:10.187]                           invokeRestart("muffleMessage")
[17:48:10.187]                       }
[17:48:10.187]                       else if (inherits(cond, "warning")) {
[17:48:10.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.187]                         if (muffled) 
[17:48:10.187]                           invokeRestart("muffleWarning")
[17:48:10.187]                       }
[17:48:10.187]                       else if (inherits(cond, "condition")) {
[17:48:10.187]                         if (!is.null(pattern)) {
[17:48:10.187]                           computeRestarts <- base::computeRestarts
[17:48:10.187]                           grepl <- base::grepl
[17:48:10.187]                           restarts <- computeRestarts(cond)
[17:48:10.187]                           for (restart in restarts) {
[17:48:10.187]                             name <- restart$name
[17:48:10.187]                             if (is.null(name)) 
[17:48:10.187]                               next
[17:48:10.187]                             if (!grepl(pattern, name)) 
[17:48:10.187]                               next
[17:48:10.187]                             invokeRestart(restart)
[17:48:10.187]                             muffled <- TRUE
[17:48:10.187]                             break
[17:48:10.187]                           }
[17:48:10.187]                         }
[17:48:10.187]                       }
[17:48:10.187]                       invisible(muffled)
[17:48:10.187]                     }
[17:48:10.187]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.187]                   }
[17:48:10.187]                 }
[17:48:10.187]                 else {
[17:48:10.187]                   if (TRUE) {
[17:48:10.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.187]                     {
[17:48:10.187]                       inherits <- base::inherits
[17:48:10.187]                       invokeRestart <- base::invokeRestart
[17:48:10.187]                       is.null <- base::is.null
[17:48:10.187]                       muffled <- FALSE
[17:48:10.187]                       if (inherits(cond, "message")) {
[17:48:10.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.187]                         if (muffled) 
[17:48:10.187]                           invokeRestart("muffleMessage")
[17:48:10.187]                       }
[17:48:10.187]                       else if (inherits(cond, "warning")) {
[17:48:10.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.187]                         if (muffled) 
[17:48:10.187]                           invokeRestart("muffleWarning")
[17:48:10.187]                       }
[17:48:10.187]                       else if (inherits(cond, "condition")) {
[17:48:10.187]                         if (!is.null(pattern)) {
[17:48:10.187]                           computeRestarts <- base::computeRestarts
[17:48:10.187]                           grepl <- base::grepl
[17:48:10.187]                           restarts <- computeRestarts(cond)
[17:48:10.187]                           for (restart in restarts) {
[17:48:10.187]                             name <- restart$name
[17:48:10.187]                             if (is.null(name)) 
[17:48:10.187]                               next
[17:48:10.187]                             if (!grepl(pattern, name)) 
[17:48:10.187]                               next
[17:48:10.187]                             invokeRestart(restart)
[17:48:10.187]                             muffled <- TRUE
[17:48:10.187]                             break
[17:48:10.187]                           }
[17:48:10.187]                         }
[17:48:10.187]                       }
[17:48:10.187]                       invisible(muffled)
[17:48:10.187]                     }
[17:48:10.187]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.187]                   }
[17:48:10.187]                 }
[17:48:10.187]             }
[17:48:10.187]         }))
[17:48:10.187]     }, error = function(ex) {
[17:48:10.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.187]                 ...future.rng), started = ...future.startTime, 
[17:48:10.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.187]             version = "1.8"), class = "FutureResult")
[17:48:10.187]     }, finally = {
[17:48:10.187]         if (!identical(...future.workdir, getwd())) 
[17:48:10.187]             setwd(...future.workdir)
[17:48:10.187]         {
[17:48:10.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.187]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.187]             }
[17:48:10.187]             base::options(...future.oldOptions)
[17:48:10.187]             if (.Platform$OS.type == "windows") {
[17:48:10.187]                 old_names <- names(...future.oldEnvVars)
[17:48:10.187]                 envs <- base::Sys.getenv()
[17:48:10.187]                 names <- names(envs)
[17:48:10.187]                 common <- intersect(names, old_names)
[17:48:10.187]                 added <- setdiff(names, old_names)
[17:48:10.187]                 removed <- setdiff(old_names, names)
[17:48:10.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.187]                   envs[common]]
[17:48:10.187]                 NAMES <- toupper(changed)
[17:48:10.187]                 args <- list()
[17:48:10.187]                 for (kk in seq_along(NAMES)) {
[17:48:10.187]                   name <- changed[[kk]]
[17:48:10.187]                   NAME <- NAMES[[kk]]
[17:48:10.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.187]                     next
[17:48:10.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.187]                 }
[17:48:10.187]                 NAMES <- toupper(added)
[17:48:10.187]                 for (kk in seq_along(NAMES)) {
[17:48:10.187]                   name <- added[[kk]]
[17:48:10.187]                   NAME <- NAMES[[kk]]
[17:48:10.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.187]                     next
[17:48:10.187]                   args[[name]] <- ""
[17:48:10.187]                 }
[17:48:10.187]                 NAMES <- toupper(removed)
[17:48:10.187]                 for (kk in seq_along(NAMES)) {
[17:48:10.187]                   name <- removed[[kk]]
[17:48:10.187]                   NAME <- NAMES[[kk]]
[17:48:10.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.187]                     next
[17:48:10.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.187]                 }
[17:48:10.187]                 if (length(args) > 0) 
[17:48:10.187]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.187]             }
[17:48:10.187]             else {
[17:48:10.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.187]             }
[17:48:10.187]             {
[17:48:10.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.187]                   0L) {
[17:48:10.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.187]                   base::options(opts)
[17:48:10.187]                 }
[17:48:10.187]                 {
[17:48:10.187]                   {
[17:48:10.187]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.187]                     NULL
[17:48:10.187]                   }
[17:48:10.187]                   options(future.plan = NULL)
[17:48:10.187]                   if (is.na(NA_character_)) 
[17:48:10.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.187]                     .init = FALSE)
[17:48:10.187]                 }
[17:48:10.187]             }
[17:48:10.187]         }
[17:48:10.187]     })
[17:48:10.187]     if (TRUE) {
[17:48:10.187]         base::sink(type = "output", split = FALSE)
[17:48:10.187]         if (TRUE) {
[17:48:10.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.187]         }
[17:48:10.187]         else {
[17:48:10.187]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.187]         }
[17:48:10.187]         base::close(...future.stdout)
[17:48:10.187]         ...future.stdout <- NULL
[17:48:10.187]     }
[17:48:10.187]     ...future.result$conditions <- ...future.conditions
[17:48:10.187]     ...future.result$finished <- base::Sys.time()
[17:48:10.187]     ...future.result
[17:48:10.187] }
[17:48:10.190] MultisessionFuture started
[17:48:10.190] - Launch lazy future ... done
[17:48:10.190] run() for ‘MultisessionFuture’ ... done
[17:48:10.190] resolve() on list ...
[17:48:10.191]  recursive: 0
[17:48:10.191]  length: 3
[17:48:10.191]  elements: ‘a’, ‘b’, ‘’
[17:48:10.191] run() for ‘Future’ ...
[17:48:10.191] - state: ‘created’
[17:48:10.191] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.207]   - Field: ‘node’
[17:48:10.207]   - Field: ‘label’
[17:48:10.207]   - Field: ‘local’
[17:48:10.207]   - Field: ‘owner’
[17:48:10.207]   - Field: ‘envir’
[17:48:10.207]   - Field: ‘workers’
[17:48:10.207]   - Field: ‘packages’
[17:48:10.207]   - Field: ‘gc’
[17:48:10.208]   - Field: ‘conditions’
[17:48:10.208]   - Field: ‘persistent’
[17:48:10.208]   - Field: ‘expr’
[17:48:10.208]   - Field: ‘uuid’
[17:48:10.208]   - Field: ‘seed’
[17:48:10.208]   - Field: ‘version’
[17:48:10.208]   - Field: ‘result’
[17:48:10.208]   - Field: ‘asynchronous’
[17:48:10.208]   - Field: ‘calls’
[17:48:10.208]   - Field: ‘globals’
[17:48:10.208]   - Field: ‘stdout’
[17:48:10.209]   - Field: ‘earlySignal’
[17:48:10.209]   - Field: ‘lazy’
[17:48:10.209]   - Field: ‘state’
[17:48:10.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.209] - Launch lazy future ...
[17:48:10.209] Packages needed by the future expression (n = 0): <none>
[17:48:10.209] Packages needed by future strategies (n = 0): <none>
[17:48:10.210] {
[17:48:10.210]     {
[17:48:10.210]         {
[17:48:10.210]             ...future.startTime <- base::Sys.time()
[17:48:10.210]             {
[17:48:10.210]                 {
[17:48:10.210]                   {
[17:48:10.210]                     {
[17:48:10.210]                       base::local({
[17:48:10.210]                         has_future <- base::requireNamespace("future", 
[17:48:10.210]                           quietly = TRUE)
[17:48:10.210]                         if (has_future) {
[17:48:10.210]                           ns <- base::getNamespace("future")
[17:48:10.210]                           version <- ns[[".package"]][["version"]]
[17:48:10.210]                           if (is.null(version)) 
[17:48:10.210]                             version <- utils::packageVersion("future")
[17:48:10.210]                         }
[17:48:10.210]                         else {
[17:48:10.210]                           version <- NULL
[17:48:10.210]                         }
[17:48:10.210]                         if (!has_future || version < "1.8.0") {
[17:48:10.210]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.210]                             "", base::R.version$version.string), 
[17:48:10.210]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.210]                               "release", "version")], collapse = " "), 
[17:48:10.210]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.210]                             info)
[17:48:10.210]                           info <- base::paste(info, collapse = "; ")
[17:48:10.210]                           if (!has_future) {
[17:48:10.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.210]                               info)
[17:48:10.210]                           }
[17:48:10.210]                           else {
[17:48:10.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.210]                               info, version)
[17:48:10.210]                           }
[17:48:10.210]                           base::stop(msg)
[17:48:10.210]                         }
[17:48:10.210]                       })
[17:48:10.210]                     }
[17:48:10.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.210]                     base::options(mc.cores = 1L)
[17:48:10.210]                   }
[17:48:10.210]                   ...future.strategy.old <- future::plan("list")
[17:48:10.210]                   options(future.plan = NULL)
[17:48:10.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.210]                 }
[17:48:10.210]                 ...future.workdir <- getwd()
[17:48:10.210]             }
[17:48:10.210]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.210]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.210]         }
[17:48:10.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.210]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.210]             base::names(...future.oldOptions))
[17:48:10.210]     }
[17:48:10.210]     if (FALSE) {
[17:48:10.210]     }
[17:48:10.210]     else {
[17:48:10.210]         if (TRUE) {
[17:48:10.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.210]                 open = "w")
[17:48:10.210]         }
[17:48:10.210]         else {
[17:48:10.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.210]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.210]         }
[17:48:10.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.210]             base::sink(type = "output", split = FALSE)
[17:48:10.210]             base::close(...future.stdout)
[17:48:10.210]         }, add = TRUE)
[17:48:10.210]     }
[17:48:10.210]     ...future.frame <- base::sys.nframe()
[17:48:10.210]     ...future.conditions <- base::list()
[17:48:10.210]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.210]     if (FALSE) {
[17:48:10.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.210]     }
[17:48:10.210]     ...future.result <- base::tryCatch({
[17:48:10.210]         base::withCallingHandlers({
[17:48:10.210]             ...future.value <- base::withVisible(base::local({
[17:48:10.210]                 ...future.makeSendCondition <- base::local({
[17:48:10.210]                   sendCondition <- NULL
[17:48:10.210]                   function(frame = 1L) {
[17:48:10.210]                     if (is.function(sendCondition)) 
[17:48:10.210]                       return(sendCondition)
[17:48:10.210]                     ns <- getNamespace("parallel")
[17:48:10.210]                     if (exists("sendData", mode = "function", 
[17:48:10.210]                       envir = ns)) {
[17:48:10.210]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.210]                         envir = ns)
[17:48:10.210]                       envir <- sys.frame(frame)
[17:48:10.210]                       master <- NULL
[17:48:10.210]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.210]                         !identical(envir, emptyenv())) {
[17:48:10.210]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.210]                           inherits = FALSE)) {
[17:48:10.210]                           master <- get("master", mode = "list", 
[17:48:10.210]                             envir = envir, inherits = FALSE)
[17:48:10.210]                           if (inherits(master, c("SOCKnode", 
[17:48:10.210]                             "SOCK0node"))) {
[17:48:10.210]                             sendCondition <<- function(cond) {
[17:48:10.210]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.210]                                 success = TRUE)
[17:48:10.210]                               parallel_sendData(master, data)
[17:48:10.210]                             }
[17:48:10.210]                             return(sendCondition)
[17:48:10.210]                           }
[17:48:10.210]                         }
[17:48:10.210]                         frame <- frame + 1L
[17:48:10.210]                         envir <- sys.frame(frame)
[17:48:10.210]                       }
[17:48:10.210]                     }
[17:48:10.210]                     sendCondition <<- function(cond) NULL
[17:48:10.210]                   }
[17:48:10.210]                 })
[17:48:10.210]                 withCallingHandlers({
[17:48:10.210]                   1
[17:48:10.210]                 }, immediateCondition = function(cond) {
[17:48:10.210]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.210]                   sendCondition(cond)
[17:48:10.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.210]                   {
[17:48:10.210]                     inherits <- base::inherits
[17:48:10.210]                     invokeRestart <- base::invokeRestart
[17:48:10.210]                     is.null <- base::is.null
[17:48:10.210]                     muffled <- FALSE
[17:48:10.210]                     if (inherits(cond, "message")) {
[17:48:10.210]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.210]                       if (muffled) 
[17:48:10.210]                         invokeRestart("muffleMessage")
[17:48:10.210]                     }
[17:48:10.210]                     else if (inherits(cond, "warning")) {
[17:48:10.210]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.210]                       if (muffled) 
[17:48:10.210]                         invokeRestart("muffleWarning")
[17:48:10.210]                     }
[17:48:10.210]                     else if (inherits(cond, "condition")) {
[17:48:10.210]                       if (!is.null(pattern)) {
[17:48:10.210]                         computeRestarts <- base::computeRestarts
[17:48:10.210]                         grepl <- base::grepl
[17:48:10.210]                         restarts <- computeRestarts(cond)
[17:48:10.210]                         for (restart in restarts) {
[17:48:10.210]                           name <- restart$name
[17:48:10.210]                           if (is.null(name)) 
[17:48:10.210]                             next
[17:48:10.210]                           if (!grepl(pattern, name)) 
[17:48:10.210]                             next
[17:48:10.210]                           invokeRestart(restart)
[17:48:10.210]                           muffled <- TRUE
[17:48:10.210]                           break
[17:48:10.210]                         }
[17:48:10.210]                       }
[17:48:10.210]                     }
[17:48:10.210]                     invisible(muffled)
[17:48:10.210]                   }
[17:48:10.210]                   muffleCondition(cond)
[17:48:10.210]                 })
[17:48:10.210]             }))
[17:48:10.210]             future::FutureResult(value = ...future.value$value, 
[17:48:10.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.210]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.210]                     ...future.globalenv.names))
[17:48:10.210]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.210]         }, condition = base::local({
[17:48:10.210]             c <- base::c
[17:48:10.210]             inherits <- base::inherits
[17:48:10.210]             invokeRestart <- base::invokeRestart
[17:48:10.210]             length <- base::length
[17:48:10.210]             list <- base::list
[17:48:10.210]             seq.int <- base::seq.int
[17:48:10.210]             signalCondition <- base::signalCondition
[17:48:10.210]             sys.calls <- base::sys.calls
[17:48:10.210]             `[[` <- base::`[[`
[17:48:10.210]             `+` <- base::`+`
[17:48:10.210]             `<<-` <- base::`<<-`
[17:48:10.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.210]                   3L)]
[17:48:10.210]             }
[17:48:10.210]             function(cond) {
[17:48:10.210]                 is_error <- inherits(cond, "error")
[17:48:10.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.210]                   NULL)
[17:48:10.210]                 if (is_error) {
[17:48:10.210]                   sessionInformation <- function() {
[17:48:10.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.210]                       search = base::search(), system = base::Sys.info())
[17:48:10.210]                   }
[17:48:10.210]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.210]                     cond$call), session = sessionInformation(), 
[17:48:10.210]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.210]                   signalCondition(cond)
[17:48:10.210]                 }
[17:48:10.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.210]                 "immediateCondition"))) {
[17:48:10.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.210]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.210]                   if (TRUE && !signal) {
[17:48:10.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.210]                     {
[17:48:10.210]                       inherits <- base::inherits
[17:48:10.210]                       invokeRestart <- base::invokeRestart
[17:48:10.210]                       is.null <- base::is.null
[17:48:10.210]                       muffled <- FALSE
[17:48:10.210]                       if (inherits(cond, "message")) {
[17:48:10.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.210]                         if (muffled) 
[17:48:10.210]                           invokeRestart("muffleMessage")
[17:48:10.210]                       }
[17:48:10.210]                       else if (inherits(cond, "warning")) {
[17:48:10.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.210]                         if (muffled) 
[17:48:10.210]                           invokeRestart("muffleWarning")
[17:48:10.210]                       }
[17:48:10.210]                       else if (inherits(cond, "condition")) {
[17:48:10.210]                         if (!is.null(pattern)) {
[17:48:10.210]                           computeRestarts <- base::computeRestarts
[17:48:10.210]                           grepl <- base::grepl
[17:48:10.210]                           restarts <- computeRestarts(cond)
[17:48:10.210]                           for (restart in restarts) {
[17:48:10.210]                             name <- restart$name
[17:48:10.210]                             if (is.null(name)) 
[17:48:10.210]                               next
[17:48:10.210]                             if (!grepl(pattern, name)) 
[17:48:10.210]                               next
[17:48:10.210]                             invokeRestart(restart)
[17:48:10.210]                             muffled <- TRUE
[17:48:10.210]                             break
[17:48:10.210]                           }
[17:48:10.210]                         }
[17:48:10.210]                       }
[17:48:10.210]                       invisible(muffled)
[17:48:10.210]                     }
[17:48:10.210]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.210]                   }
[17:48:10.210]                 }
[17:48:10.210]                 else {
[17:48:10.210]                   if (TRUE) {
[17:48:10.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.210]                     {
[17:48:10.210]                       inherits <- base::inherits
[17:48:10.210]                       invokeRestart <- base::invokeRestart
[17:48:10.210]                       is.null <- base::is.null
[17:48:10.210]                       muffled <- FALSE
[17:48:10.210]                       if (inherits(cond, "message")) {
[17:48:10.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.210]                         if (muffled) 
[17:48:10.210]                           invokeRestart("muffleMessage")
[17:48:10.210]                       }
[17:48:10.210]                       else if (inherits(cond, "warning")) {
[17:48:10.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.210]                         if (muffled) 
[17:48:10.210]                           invokeRestart("muffleWarning")
[17:48:10.210]                       }
[17:48:10.210]                       else if (inherits(cond, "condition")) {
[17:48:10.210]                         if (!is.null(pattern)) {
[17:48:10.210]                           computeRestarts <- base::computeRestarts
[17:48:10.210]                           grepl <- base::grepl
[17:48:10.210]                           restarts <- computeRestarts(cond)
[17:48:10.210]                           for (restart in restarts) {
[17:48:10.210]                             name <- restart$name
[17:48:10.210]                             if (is.null(name)) 
[17:48:10.210]                               next
[17:48:10.210]                             if (!grepl(pattern, name)) 
[17:48:10.210]                               next
[17:48:10.210]                             invokeRestart(restart)
[17:48:10.210]                             muffled <- TRUE
[17:48:10.210]                             break
[17:48:10.210]                           }
[17:48:10.210]                         }
[17:48:10.210]                       }
[17:48:10.210]                       invisible(muffled)
[17:48:10.210]                     }
[17:48:10.210]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.210]                   }
[17:48:10.210]                 }
[17:48:10.210]             }
[17:48:10.210]         }))
[17:48:10.210]     }, error = function(ex) {
[17:48:10.210]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.210]                 ...future.rng), started = ...future.startTime, 
[17:48:10.210]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.210]             version = "1.8"), class = "FutureResult")
[17:48:10.210]     }, finally = {
[17:48:10.210]         if (!identical(...future.workdir, getwd())) 
[17:48:10.210]             setwd(...future.workdir)
[17:48:10.210]         {
[17:48:10.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.210]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.210]             }
[17:48:10.210]             base::options(...future.oldOptions)
[17:48:10.210]             if (.Platform$OS.type == "windows") {
[17:48:10.210]                 old_names <- names(...future.oldEnvVars)
[17:48:10.210]                 envs <- base::Sys.getenv()
[17:48:10.210]                 names <- names(envs)
[17:48:10.210]                 common <- intersect(names, old_names)
[17:48:10.210]                 added <- setdiff(names, old_names)
[17:48:10.210]                 removed <- setdiff(old_names, names)
[17:48:10.210]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.210]                   envs[common]]
[17:48:10.210]                 NAMES <- toupper(changed)
[17:48:10.210]                 args <- list()
[17:48:10.210]                 for (kk in seq_along(NAMES)) {
[17:48:10.210]                   name <- changed[[kk]]
[17:48:10.210]                   NAME <- NAMES[[kk]]
[17:48:10.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.210]                     next
[17:48:10.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.210]                 }
[17:48:10.210]                 NAMES <- toupper(added)
[17:48:10.210]                 for (kk in seq_along(NAMES)) {
[17:48:10.210]                   name <- added[[kk]]
[17:48:10.210]                   NAME <- NAMES[[kk]]
[17:48:10.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.210]                     next
[17:48:10.210]                   args[[name]] <- ""
[17:48:10.210]                 }
[17:48:10.210]                 NAMES <- toupper(removed)
[17:48:10.210]                 for (kk in seq_along(NAMES)) {
[17:48:10.210]                   name <- removed[[kk]]
[17:48:10.210]                   NAME <- NAMES[[kk]]
[17:48:10.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.210]                     next
[17:48:10.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.210]                 }
[17:48:10.210]                 if (length(args) > 0) 
[17:48:10.210]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.210]             }
[17:48:10.210]             else {
[17:48:10.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.210]             }
[17:48:10.210]             {
[17:48:10.210]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.210]                   0L) {
[17:48:10.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.210]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.210]                   base::options(opts)
[17:48:10.210]                 }
[17:48:10.210]                 {
[17:48:10.210]                   {
[17:48:10.210]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.210]                     NULL
[17:48:10.210]                   }
[17:48:10.210]                   options(future.plan = NULL)
[17:48:10.210]                   if (is.na(NA_character_)) 
[17:48:10.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.210]                     .init = FALSE)
[17:48:10.210]                 }
[17:48:10.210]             }
[17:48:10.210]         }
[17:48:10.210]     })
[17:48:10.210]     if (TRUE) {
[17:48:10.210]         base::sink(type = "output", split = FALSE)
[17:48:10.210]         if (TRUE) {
[17:48:10.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.210]         }
[17:48:10.210]         else {
[17:48:10.210]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.210]         }
[17:48:10.210]         base::close(...future.stdout)
[17:48:10.210]         ...future.stdout <- NULL
[17:48:10.210]     }
[17:48:10.210]     ...future.result$conditions <- ...future.conditions
[17:48:10.210]     ...future.result$finished <- base::Sys.time()
[17:48:10.210]     ...future.result
[17:48:10.210] }
[17:48:10.213] MultisessionFuture started
[17:48:10.213] - Launch lazy future ... done
[17:48:10.213] run() for ‘MultisessionFuture’ ... done
[17:48:10.215] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.215] - Validating connection of MultisessionFuture
[17:48:10.215] - received message: FutureResult
[17:48:10.215] - Received FutureResult
[17:48:10.215] - Erased future from FutureRegistry
[17:48:10.216] result() for ClusterFuture ...
[17:48:10.216] - result already collected: FutureResult
[17:48:10.216] result() for ClusterFuture ... done
[17:48:10.216] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.216] Future #1
[17:48:10.216]  length: 2 (resolved future 1)
[17:48:10.217] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.217] - Validating connection of MultisessionFuture
[17:48:10.217] - received message: FutureResult
[17:48:10.217] - Received FutureResult
[17:48:10.217] - Erased future from FutureRegistry
[17:48:10.217] result() for ClusterFuture ...
[17:48:10.217] - result already collected: FutureResult
[17:48:10.217] result() for ClusterFuture ... done
[17:48:10.217] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.218] Future #2
[17:48:10.218]  length: 1 (resolved future 2)
[17:48:10.218]  length: 0 (resolved future 3)
[17:48:10.218] resolve() on list ... DONE
[17:48:10.218] getGlobalsAndPackages() ...
[17:48:10.218] Searching for globals...
[17:48:10.218] 
[17:48:10.218] Searching for globals ... DONE
[17:48:10.219] - globals: [0] <none>
[17:48:10.219] getGlobalsAndPackages() ... DONE
[17:48:10.219] getGlobalsAndPackages() ...
[17:48:10.219] Searching for globals...
[17:48:10.219] 
[17:48:10.219] Searching for globals ... DONE
[17:48:10.220] - globals: [0] <none>
[17:48:10.220] getGlobalsAndPackages() ... DONE
[17:48:10.220] resolve() on list ...
[17:48:10.220]  recursive: 0
[17:48:10.220]  length: 3
[17:48:10.220]  elements: ‘a’, ‘b’, ‘’
[17:48:10.220] run() for ‘Future’ ...
[17:48:10.220] - state: ‘created’
[17:48:10.220] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.235]   - Field: ‘node’
[17:48:10.235]   - Field: ‘label’
[17:48:10.235]   - Field: ‘local’
[17:48:10.235]   - Field: ‘owner’
[17:48:10.235]   - Field: ‘envir’
[17:48:10.235]   - Field: ‘workers’
[17:48:10.236]   - Field: ‘packages’
[17:48:10.236]   - Field: ‘gc’
[17:48:10.236]   - Field: ‘conditions’
[17:48:10.236]   - Field: ‘persistent’
[17:48:10.236]   - Field: ‘expr’
[17:48:10.236]   - Field: ‘uuid’
[17:48:10.236]   - Field: ‘seed’
[17:48:10.236]   - Field: ‘version’
[17:48:10.236]   - Field: ‘result’
[17:48:10.236]   - Field: ‘asynchronous’
[17:48:10.236]   - Field: ‘calls’
[17:48:10.237]   - Field: ‘globals’
[17:48:10.237]   - Field: ‘stdout’
[17:48:10.237]   - Field: ‘earlySignal’
[17:48:10.237]   - Field: ‘lazy’
[17:48:10.237]   - Field: ‘state’
[17:48:10.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.237] - Launch lazy future ...
[17:48:10.237] Packages needed by the future expression (n = 0): <none>
[17:48:10.237] Packages needed by future strategies (n = 0): <none>
[17:48:10.238] {
[17:48:10.238]     {
[17:48:10.238]         {
[17:48:10.238]             ...future.startTime <- base::Sys.time()
[17:48:10.238]             {
[17:48:10.238]                 {
[17:48:10.238]                   {
[17:48:10.238]                     {
[17:48:10.238]                       base::local({
[17:48:10.238]                         has_future <- base::requireNamespace("future", 
[17:48:10.238]                           quietly = TRUE)
[17:48:10.238]                         if (has_future) {
[17:48:10.238]                           ns <- base::getNamespace("future")
[17:48:10.238]                           version <- ns[[".package"]][["version"]]
[17:48:10.238]                           if (is.null(version)) 
[17:48:10.238]                             version <- utils::packageVersion("future")
[17:48:10.238]                         }
[17:48:10.238]                         else {
[17:48:10.238]                           version <- NULL
[17:48:10.238]                         }
[17:48:10.238]                         if (!has_future || version < "1.8.0") {
[17:48:10.238]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.238]                             "", base::R.version$version.string), 
[17:48:10.238]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.238]                               "release", "version")], collapse = " "), 
[17:48:10.238]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.238]                             info)
[17:48:10.238]                           info <- base::paste(info, collapse = "; ")
[17:48:10.238]                           if (!has_future) {
[17:48:10.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.238]                               info)
[17:48:10.238]                           }
[17:48:10.238]                           else {
[17:48:10.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.238]                               info, version)
[17:48:10.238]                           }
[17:48:10.238]                           base::stop(msg)
[17:48:10.238]                         }
[17:48:10.238]                       })
[17:48:10.238]                     }
[17:48:10.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.238]                     base::options(mc.cores = 1L)
[17:48:10.238]                   }
[17:48:10.238]                   ...future.strategy.old <- future::plan("list")
[17:48:10.238]                   options(future.plan = NULL)
[17:48:10.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.238]                 }
[17:48:10.238]                 ...future.workdir <- getwd()
[17:48:10.238]             }
[17:48:10.238]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.238]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.238]         }
[17:48:10.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.238]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.238]             base::names(...future.oldOptions))
[17:48:10.238]     }
[17:48:10.238]     if (FALSE) {
[17:48:10.238]     }
[17:48:10.238]     else {
[17:48:10.238]         if (TRUE) {
[17:48:10.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.238]                 open = "w")
[17:48:10.238]         }
[17:48:10.238]         else {
[17:48:10.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.238]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.238]         }
[17:48:10.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.238]             base::sink(type = "output", split = FALSE)
[17:48:10.238]             base::close(...future.stdout)
[17:48:10.238]         }, add = TRUE)
[17:48:10.238]     }
[17:48:10.238]     ...future.frame <- base::sys.nframe()
[17:48:10.238]     ...future.conditions <- base::list()
[17:48:10.238]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.238]     if (FALSE) {
[17:48:10.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.238]     }
[17:48:10.238]     ...future.result <- base::tryCatch({
[17:48:10.238]         base::withCallingHandlers({
[17:48:10.238]             ...future.value <- base::withVisible(base::local({
[17:48:10.238]                 ...future.makeSendCondition <- base::local({
[17:48:10.238]                   sendCondition <- NULL
[17:48:10.238]                   function(frame = 1L) {
[17:48:10.238]                     if (is.function(sendCondition)) 
[17:48:10.238]                       return(sendCondition)
[17:48:10.238]                     ns <- getNamespace("parallel")
[17:48:10.238]                     if (exists("sendData", mode = "function", 
[17:48:10.238]                       envir = ns)) {
[17:48:10.238]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.238]                         envir = ns)
[17:48:10.238]                       envir <- sys.frame(frame)
[17:48:10.238]                       master <- NULL
[17:48:10.238]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.238]                         !identical(envir, emptyenv())) {
[17:48:10.238]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.238]                           inherits = FALSE)) {
[17:48:10.238]                           master <- get("master", mode = "list", 
[17:48:10.238]                             envir = envir, inherits = FALSE)
[17:48:10.238]                           if (inherits(master, c("SOCKnode", 
[17:48:10.238]                             "SOCK0node"))) {
[17:48:10.238]                             sendCondition <<- function(cond) {
[17:48:10.238]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.238]                                 success = TRUE)
[17:48:10.238]                               parallel_sendData(master, data)
[17:48:10.238]                             }
[17:48:10.238]                             return(sendCondition)
[17:48:10.238]                           }
[17:48:10.238]                         }
[17:48:10.238]                         frame <- frame + 1L
[17:48:10.238]                         envir <- sys.frame(frame)
[17:48:10.238]                       }
[17:48:10.238]                     }
[17:48:10.238]                     sendCondition <<- function(cond) NULL
[17:48:10.238]                   }
[17:48:10.238]                 })
[17:48:10.238]                 withCallingHandlers({
[17:48:10.238]                   1
[17:48:10.238]                 }, immediateCondition = function(cond) {
[17:48:10.238]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.238]                   sendCondition(cond)
[17:48:10.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.238]                   {
[17:48:10.238]                     inherits <- base::inherits
[17:48:10.238]                     invokeRestart <- base::invokeRestart
[17:48:10.238]                     is.null <- base::is.null
[17:48:10.238]                     muffled <- FALSE
[17:48:10.238]                     if (inherits(cond, "message")) {
[17:48:10.238]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.238]                       if (muffled) 
[17:48:10.238]                         invokeRestart("muffleMessage")
[17:48:10.238]                     }
[17:48:10.238]                     else if (inherits(cond, "warning")) {
[17:48:10.238]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.238]                       if (muffled) 
[17:48:10.238]                         invokeRestart("muffleWarning")
[17:48:10.238]                     }
[17:48:10.238]                     else if (inherits(cond, "condition")) {
[17:48:10.238]                       if (!is.null(pattern)) {
[17:48:10.238]                         computeRestarts <- base::computeRestarts
[17:48:10.238]                         grepl <- base::grepl
[17:48:10.238]                         restarts <- computeRestarts(cond)
[17:48:10.238]                         for (restart in restarts) {
[17:48:10.238]                           name <- restart$name
[17:48:10.238]                           if (is.null(name)) 
[17:48:10.238]                             next
[17:48:10.238]                           if (!grepl(pattern, name)) 
[17:48:10.238]                             next
[17:48:10.238]                           invokeRestart(restart)
[17:48:10.238]                           muffled <- TRUE
[17:48:10.238]                           break
[17:48:10.238]                         }
[17:48:10.238]                       }
[17:48:10.238]                     }
[17:48:10.238]                     invisible(muffled)
[17:48:10.238]                   }
[17:48:10.238]                   muffleCondition(cond)
[17:48:10.238]                 })
[17:48:10.238]             }))
[17:48:10.238]             future::FutureResult(value = ...future.value$value, 
[17:48:10.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.238]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.238]                     ...future.globalenv.names))
[17:48:10.238]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.238]         }, condition = base::local({
[17:48:10.238]             c <- base::c
[17:48:10.238]             inherits <- base::inherits
[17:48:10.238]             invokeRestart <- base::invokeRestart
[17:48:10.238]             length <- base::length
[17:48:10.238]             list <- base::list
[17:48:10.238]             seq.int <- base::seq.int
[17:48:10.238]             signalCondition <- base::signalCondition
[17:48:10.238]             sys.calls <- base::sys.calls
[17:48:10.238]             `[[` <- base::`[[`
[17:48:10.238]             `+` <- base::`+`
[17:48:10.238]             `<<-` <- base::`<<-`
[17:48:10.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.238]                   3L)]
[17:48:10.238]             }
[17:48:10.238]             function(cond) {
[17:48:10.238]                 is_error <- inherits(cond, "error")
[17:48:10.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.238]                   NULL)
[17:48:10.238]                 if (is_error) {
[17:48:10.238]                   sessionInformation <- function() {
[17:48:10.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.238]                       search = base::search(), system = base::Sys.info())
[17:48:10.238]                   }
[17:48:10.238]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.238]                     cond$call), session = sessionInformation(), 
[17:48:10.238]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.238]                   signalCondition(cond)
[17:48:10.238]                 }
[17:48:10.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.238]                 "immediateCondition"))) {
[17:48:10.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.238]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.238]                   if (TRUE && !signal) {
[17:48:10.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.238]                     {
[17:48:10.238]                       inherits <- base::inherits
[17:48:10.238]                       invokeRestart <- base::invokeRestart
[17:48:10.238]                       is.null <- base::is.null
[17:48:10.238]                       muffled <- FALSE
[17:48:10.238]                       if (inherits(cond, "message")) {
[17:48:10.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.238]                         if (muffled) 
[17:48:10.238]                           invokeRestart("muffleMessage")
[17:48:10.238]                       }
[17:48:10.238]                       else if (inherits(cond, "warning")) {
[17:48:10.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.238]                         if (muffled) 
[17:48:10.238]                           invokeRestart("muffleWarning")
[17:48:10.238]                       }
[17:48:10.238]                       else if (inherits(cond, "condition")) {
[17:48:10.238]                         if (!is.null(pattern)) {
[17:48:10.238]                           computeRestarts <- base::computeRestarts
[17:48:10.238]                           grepl <- base::grepl
[17:48:10.238]                           restarts <- computeRestarts(cond)
[17:48:10.238]                           for (restart in restarts) {
[17:48:10.238]                             name <- restart$name
[17:48:10.238]                             if (is.null(name)) 
[17:48:10.238]                               next
[17:48:10.238]                             if (!grepl(pattern, name)) 
[17:48:10.238]                               next
[17:48:10.238]                             invokeRestart(restart)
[17:48:10.238]                             muffled <- TRUE
[17:48:10.238]                             break
[17:48:10.238]                           }
[17:48:10.238]                         }
[17:48:10.238]                       }
[17:48:10.238]                       invisible(muffled)
[17:48:10.238]                     }
[17:48:10.238]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.238]                   }
[17:48:10.238]                 }
[17:48:10.238]                 else {
[17:48:10.238]                   if (TRUE) {
[17:48:10.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.238]                     {
[17:48:10.238]                       inherits <- base::inherits
[17:48:10.238]                       invokeRestart <- base::invokeRestart
[17:48:10.238]                       is.null <- base::is.null
[17:48:10.238]                       muffled <- FALSE
[17:48:10.238]                       if (inherits(cond, "message")) {
[17:48:10.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.238]                         if (muffled) 
[17:48:10.238]                           invokeRestart("muffleMessage")
[17:48:10.238]                       }
[17:48:10.238]                       else if (inherits(cond, "warning")) {
[17:48:10.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.238]                         if (muffled) 
[17:48:10.238]                           invokeRestart("muffleWarning")
[17:48:10.238]                       }
[17:48:10.238]                       else if (inherits(cond, "condition")) {
[17:48:10.238]                         if (!is.null(pattern)) {
[17:48:10.238]                           computeRestarts <- base::computeRestarts
[17:48:10.238]                           grepl <- base::grepl
[17:48:10.238]                           restarts <- computeRestarts(cond)
[17:48:10.238]                           for (restart in restarts) {
[17:48:10.238]                             name <- restart$name
[17:48:10.238]                             if (is.null(name)) 
[17:48:10.238]                               next
[17:48:10.238]                             if (!grepl(pattern, name)) 
[17:48:10.238]                               next
[17:48:10.238]                             invokeRestart(restart)
[17:48:10.238]                             muffled <- TRUE
[17:48:10.238]                             break
[17:48:10.238]                           }
[17:48:10.238]                         }
[17:48:10.238]                       }
[17:48:10.238]                       invisible(muffled)
[17:48:10.238]                     }
[17:48:10.238]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.238]                   }
[17:48:10.238]                 }
[17:48:10.238]             }
[17:48:10.238]         }))
[17:48:10.238]     }, error = function(ex) {
[17:48:10.238]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.238]                 ...future.rng), started = ...future.startTime, 
[17:48:10.238]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.238]             version = "1.8"), class = "FutureResult")
[17:48:10.238]     }, finally = {
[17:48:10.238]         if (!identical(...future.workdir, getwd())) 
[17:48:10.238]             setwd(...future.workdir)
[17:48:10.238]         {
[17:48:10.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.238]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.238]             }
[17:48:10.238]             base::options(...future.oldOptions)
[17:48:10.238]             if (.Platform$OS.type == "windows") {
[17:48:10.238]                 old_names <- names(...future.oldEnvVars)
[17:48:10.238]                 envs <- base::Sys.getenv()
[17:48:10.238]                 names <- names(envs)
[17:48:10.238]                 common <- intersect(names, old_names)
[17:48:10.238]                 added <- setdiff(names, old_names)
[17:48:10.238]                 removed <- setdiff(old_names, names)
[17:48:10.238]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.238]                   envs[common]]
[17:48:10.238]                 NAMES <- toupper(changed)
[17:48:10.238]                 args <- list()
[17:48:10.238]                 for (kk in seq_along(NAMES)) {
[17:48:10.238]                   name <- changed[[kk]]
[17:48:10.238]                   NAME <- NAMES[[kk]]
[17:48:10.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.238]                     next
[17:48:10.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.238]                 }
[17:48:10.238]                 NAMES <- toupper(added)
[17:48:10.238]                 for (kk in seq_along(NAMES)) {
[17:48:10.238]                   name <- added[[kk]]
[17:48:10.238]                   NAME <- NAMES[[kk]]
[17:48:10.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.238]                     next
[17:48:10.238]                   args[[name]] <- ""
[17:48:10.238]                 }
[17:48:10.238]                 NAMES <- toupper(removed)
[17:48:10.238]                 for (kk in seq_along(NAMES)) {
[17:48:10.238]                   name <- removed[[kk]]
[17:48:10.238]                   NAME <- NAMES[[kk]]
[17:48:10.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.238]                     next
[17:48:10.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.238]                 }
[17:48:10.238]                 if (length(args) > 0) 
[17:48:10.238]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.238]             }
[17:48:10.238]             else {
[17:48:10.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.238]             }
[17:48:10.238]             {
[17:48:10.238]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.238]                   0L) {
[17:48:10.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.238]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.238]                   base::options(opts)
[17:48:10.238]                 }
[17:48:10.238]                 {
[17:48:10.238]                   {
[17:48:10.238]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.238]                     NULL
[17:48:10.238]                   }
[17:48:10.238]                   options(future.plan = NULL)
[17:48:10.238]                   if (is.na(NA_character_)) 
[17:48:10.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.238]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.238]                     .init = FALSE)
[17:48:10.238]                 }
[17:48:10.238]             }
[17:48:10.238]         }
[17:48:10.238]     })
[17:48:10.238]     if (TRUE) {
[17:48:10.238]         base::sink(type = "output", split = FALSE)
[17:48:10.238]         if (TRUE) {
[17:48:10.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.238]         }
[17:48:10.238]         else {
[17:48:10.238]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.238]         }
[17:48:10.238]         base::close(...future.stdout)
[17:48:10.238]         ...future.stdout <- NULL
[17:48:10.238]     }
[17:48:10.238]     ...future.result$conditions <- ...future.conditions
[17:48:10.238]     ...future.result$finished <- base::Sys.time()
[17:48:10.238]     ...future.result
[17:48:10.238] }
[17:48:10.241] MultisessionFuture started
[17:48:10.241] - Launch lazy future ... done
[17:48:10.241] run() for ‘MultisessionFuture’ ... done
[17:48:10.242] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.243] - Validating connection of MultisessionFuture
[17:48:10.243] - received message: FutureResult
[17:48:10.243] - Received FutureResult
[17:48:10.243] - Erased future from FutureRegistry
[17:48:10.243] result() for ClusterFuture ...
[17:48:10.243] - result already collected: FutureResult
[17:48:10.243] result() for ClusterFuture ... done
[17:48:10.243] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.243] Future #1
[17:48:10.244]  length: 2 (resolved future 1)
[17:48:10.244] run() for ‘Future’ ...
[17:48:10.244] - state: ‘created’
[17:48:10.244] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.257] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.257] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.257]   - Field: ‘node’
[17:48:10.258]   - Field: ‘label’
[17:48:10.258]   - Field: ‘local’
[17:48:10.258]   - Field: ‘owner’
[17:48:10.258]   - Field: ‘envir’
[17:48:10.258]   - Field: ‘workers’
[17:48:10.258]   - Field: ‘packages’
[17:48:10.258]   - Field: ‘gc’
[17:48:10.258]   - Field: ‘conditions’
[17:48:10.258]   - Field: ‘persistent’
[17:48:10.258]   - Field: ‘expr’
[17:48:10.258]   - Field: ‘uuid’
[17:48:10.259]   - Field: ‘seed’
[17:48:10.259]   - Field: ‘version’
[17:48:10.259]   - Field: ‘result’
[17:48:10.259]   - Field: ‘asynchronous’
[17:48:10.259]   - Field: ‘calls’
[17:48:10.259]   - Field: ‘globals’
[17:48:10.259]   - Field: ‘stdout’
[17:48:10.259]   - Field: ‘earlySignal’
[17:48:10.259]   - Field: ‘lazy’
[17:48:10.259]   - Field: ‘state’
[17:48:10.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.260] - Launch lazy future ...
[17:48:10.260] Packages needed by the future expression (n = 0): <none>
[17:48:10.260] Packages needed by future strategies (n = 0): <none>
[17:48:10.260] {
[17:48:10.260]     {
[17:48:10.260]         {
[17:48:10.260]             ...future.startTime <- base::Sys.time()
[17:48:10.260]             {
[17:48:10.260]                 {
[17:48:10.260]                   {
[17:48:10.260]                     {
[17:48:10.260]                       base::local({
[17:48:10.260]                         has_future <- base::requireNamespace("future", 
[17:48:10.260]                           quietly = TRUE)
[17:48:10.260]                         if (has_future) {
[17:48:10.260]                           ns <- base::getNamespace("future")
[17:48:10.260]                           version <- ns[[".package"]][["version"]]
[17:48:10.260]                           if (is.null(version)) 
[17:48:10.260]                             version <- utils::packageVersion("future")
[17:48:10.260]                         }
[17:48:10.260]                         else {
[17:48:10.260]                           version <- NULL
[17:48:10.260]                         }
[17:48:10.260]                         if (!has_future || version < "1.8.0") {
[17:48:10.260]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.260]                             "", base::R.version$version.string), 
[17:48:10.260]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.260]                               "release", "version")], collapse = " "), 
[17:48:10.260]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.260]                             info)
[17:48:10.260]                           info <- base::paste(info, collapse = "; ")
[17:48:10.260]                           if (!has_future) {
[17:48:10.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.260]                               info)
[17:48:10.260]                           }
[17:48:10.260]                           else {
[17:48:10.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.260]                               info, version)
[17:48:10.260]                           }
[17:48:10.260]                           base::stop(msg)
[17:48:10.260]                         }
[17:48:10.260]                       })
[17:48:10.260]                     }
[17:48:10.260]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.260]                     base::options(mc.cores = 1L)
[17:48:10.260]                   }
[17:48:10.260]                   ...future.strategy.old <- future::plan("list")
[17:48:10.260]                   options(future.plan = NULL)
[17:48:10.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.260]                 }
[17:48:10.260]                 ...future.workdir <- getwd()
[17:48:10.260]             }
[17:48:10.260]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.260]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.260]         }
[17:48:10.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.260]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.260]             base::names(...future.oldOptions))
[17:48:10.260]     }
[17:48:10.260]     if (FALSE) {
[17:48:10.260]     }
[17:48:10.260]     else {
[17:48:10.260]         if (TRUE) {
[17:48:10.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.260]                 open = "w")
[17:48:10.260]         }
[17:48:10.260]         else {
[17:48:10.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.260]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.260]         }
[17:48:10.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.260]             base::sink(type = "output", split = FALSE)
[17:48:10.260]             base::close(...future.stdout)
[17:48:10.260]         }, add = TRUE)
[17:48:10.260]     }
[17:48:10.260]     ...future.frame <- base::sys.nframe()
[17:48:10.260]     ...future.conditions <- base::list()
[17:48:10.260]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.260]     if (FALSE) {
[17:48:10.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.260]     }
[17:48:10.260]     ...future.result <- base::tryCatch({
[17:48:10.260]         base::withCallingHandlers({
[17:48:10.260]             ...future.value <- base::withVisible(base::local({
[17:48:10.260]                 ...future.makeSendCondition <- base::local({
[17:48:10.260]                   sendCondition <- NULL
[17:48:10.260]                   function(frame = 1L) {
[17:48:10.260]                     if (is.function(sendCondition)) 
[17:48:10.260]                       return(sendCondition)
[17:48:10.260]                     ns <- getNamespace("parallel")
[17:48:10.260]                     if (exists("sendData", mode = "function", 
[17:48:10.260]                       envir = ns)) {
[17:48:10.260]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.260]                         envir = ns)
[17:48:10.260]                       envir <- sys.frame(frame)
[17:48:10.260]                       master <- NULL
[17:48:10.260]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.260]                         !identical(envir, emptyenv())) {
[17:48:10.260]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.260]                           inherits = FALSE)) {
[17:48:10.260]                           master <- get("master", mode = "list", 
[17:48:10.260]                             envir = envir, inherits = FALSE)
[17:48:10.260]                           if (inherits(master, c("SOCKnode", 
[17:48:10.260]                             "SOCK0node"))) {
[17:48:10.260]                             sendCondition <<- function(cond) {
[17:48:10.260]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.260]                                 success = TRUE)
[17:48:10.260]                               parallel_sendData(master, data)
[17:48:10.260]                             }
[17:48:10.260]                             return(sendCondition)
[17:48:10.260]                           }
[17:48:10.260]                         }
[17:48:10.260]                         frame <- frame + 1L
[17:48:10.260]                         envir <- sys.frame(frame)
[17:48:10.260]                       }
[17:48:10.260]                     }
[17:48:10.260]                     sendCondition <<- function(cond) NULL
[17:48:10.260]                   }
[17:48:10.260]                 })
[17:48:10.260]                 withCallingHandlers({
[17:48:10.260]                   2
[17:48:10.260]                 }, immediateCondition = function(cond) {
[17:48:10.260]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.260]                   sendCondition(cond)
[17:48:10.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.260]                   {
[17:48:10.260]                     inherits <- base::inherits
[17:48:10.260]                     invokeRestart <- base::invokeRestart
[17:48:10.260]                     is.null <- base::is.null
[17:48:10.260]                     muffled <- FALSE
[17:48:10.260]                     if (inherits(cond, "message")) {
[17:48:10.260]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.260]                       if (muffled) 
[17:48:10.260]                         invokeRestart("muffleMessage")
[17:48:10.260]                     }
[17:48:10.260]                     else if (inherits(cond, "warning")) {
[17:48:10.260]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.260]                       if (muffled) 
[17:48:10.260]                         invokeRestart("muffleWarning")
[17:48:10.260]                     }
[17:48:10.260]                     else if (inherits(cond, "condition")) {
[17:48:10.260]                       if (!is.null(pattern)) {
[17:48:10.260]                         computeRestarts <- base::computeRestarts
[17:48:10.260]                         grepl <- base::grepl
[17:48:10.260]                         restarts <- computeRestarts(cond)
[17:48:10.260]                         for (restart in restarts) {
[17:48:10.260]                           name <- restart$name
[17:48:10.260]                           if (is.null(name)) 
[17:48:10.260]                             next
[17:48:10.260]                           if (!grepl(pattern, name)) 
[17:48:10.260]                             next
[17:48:10.260]                           invokeRestart(restart)
[17:48:10.260]                           muffled <- TRUE
[17:48:10.260]                           break
[17:48:10.260]                         }
[17:48:10.260]                       }
[17:48:10.260]                     }
[17:48:10.260]                     invisible(muffled)
[17:48:10.260]                   }
[17:48:10.260]                   muffleCondition(cond)
[17:48:10.260]                 })
[17:48:10.260]             }))
[17:48:10.260]             future::FutureResult(value = ...future.value$value, 
[17:48:10.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.260]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.260]                     ...future.globalenv.names))
[17:48:10.260]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.260]         }, condition = base::local({
[17:48:10.260]             c <- base::c
[17:48:10.260]             inherits <- base::inherits
[17:48:10.260]             invokeRestart <- base::invokeRestart
[17:48:10.260]             length <- base::length
[17:48:10.260]             list <- base::list
[17:48:10.260]             seq.int <- base::seq.int
[17:48:10.260]             signalCondition <- base::signalCondition
[17:48:10.260]             sys.calls <- base::sys.calls
[17:48:10.260]             `[[` <- base::`[[`
[17:48:10.260]             `+` <- base::`+`
[17:48:10.260]             `<<-` <- base::`<<-`
[17:48:10.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.260]                   3L)]
[17:48:10.260]             }
[17:48:10.260]             function(cond) {
[17:48:10.260]                 is_error <- inherits(cond, "error")
[17:48:10.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.260]                   NULL)
[17:48:10.260]                 if (is_error) {
[17:48:10.260]                   sessionInformation <- function() {
[17:48:10.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.260]                       search = base::search(), system = base::Sys.info())
[17:48:10.260]                   }
[17:48:10.260]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.260]                     cond$call), session = sessionInformation(), 
[17:48:10.260]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.260]                   signalCondition(cond)
[17:48:10.260]                 }
[17:48:10.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.260]                 "immediateCondition"))) {
[17:48:10.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.260]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.260]                   if (TRUE && !signal) {
[17:48:10.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.260]                     {
[17:48:10.260]                       inherits <- base::inherits
[17:48:10.260]                       invokeRestart <- base::invokeRestart
[17:48:10.260]                       is.null <- base::is.null
[17:48:10.260]                       muffled <- FALSE
[17:48:10.260]                       if (inherits(cond, "message")) {
[17:48:10.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.260]                         if (muffled) 
[17:48:10.260]                           invokeRestart("muffleMessage")
[17:48:10.260]                       }
[17:48:10.260]                       else if (inherits(cond, "warning")) {
[17:48:10.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.260]                         if (muffled) 
[17:48:10.260]                           invokeRestart("muffleWarning")
[17:48:10.260]                       }
[17:48:10.260]                       else if (inherits(cond, "condition")) {
[17:48:10.260]                         if (!is.null(pattern)) {
[17:48:10.260]                           computeRestarts <- base::computeRestarts
[17:48:10.260]                           grepl <- base::grepl
[17:48:10.260]                           restarts <- computeRestarts(cond)
[17:48:10.260]                           for (restart in restarts) {
[17:48:10.260]                             name <- restart$name
[17:48:10.260]                             if (is.null(name)) 
[17:48:10.260]                               next
[17:48:10.260]                             if (!grepl(pattern, name)) 
[17:48:10.260]                               next
[17:48:10.260]                             invokeRestart(restart)
[17:48:10.260]                             muffled <- TRUE
[17:48:10.260]                             break
[17:48:10.260]                           }
[17:48:10.260]                         }
[17:48:10.260]                       }
[17:48:10.260]                       invisible(muffled)
[17:48:10.260]                     }
[17:48:10.260]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.260]                   }
[17:48:10.260]                 }
[17:48:10.260]                 else {
[17:48:10.260]                   if (TRUE) {
[17:48:10.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.260]                     {
[17:48:10.260]                       inherits <- base::inherits
[17:48:10.260]                       invokeRestart <- base::invokeRestart
[17:48:10.260]                       is.null <- base::is.null
[17:48:10.260]                       muffled <- FALSE
[17:48:10.260]                       if (inherits(cond, "message")) {
[17:48:10.260]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.260]                         if (muffled) 
[17:48:10.260]                           invokeRestart("muffleMessage")
[17:48:10.260]                       }
[17:48:10.260]                       else if (inherits(cond, "warning")) {
[17:48:10.260]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.260]                         if (muffled) 
[17:48:10.260]                           invokeRestart("muffleWarning")
[17:48:10.260]                       }
[17:48:10.260]                       else if (inherits(cond, "condition")) {
[17:48:10.260]                         if (!is.null(pattern)) {
[17:48:10.260]                           computeRestarts <- base::computeRestarts
[17:48:10.260]                           grepl <- base::grepl
[17:48:10.260]                           restarts <- computeRestarts(cond)
[17:48:10.260]                           for (restart in restarts) {
[17:48:10.260]                             name <- restart$name
[17:48:10.260]                             if (is.null(name)) 
[17:48:10.260]                               next
[17:48:10.260]                             if (!grepl(pattern, name)) 
[17:48:10.260]                               next
[17:48:10.260]                             invokeRestart(restart)
[17:48:10.260]                             muffled <- TRUE
[17:48:10.260]                             break
[17:48:10.260]                           }
[17:48:10.260]                         }
[17:48:10.260]                       }
[17:48:10.260]                       invisible(muffled)
[17:48:10.260]                     }
[17:48:10.260]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.260]                   }
[17:48:10.260]                 }
[17:48:10.260]             }
[17:48:10.260]         }))
[17:48:10.260]     }, error = function(ex) {
[17:48:10.260]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.260]                 ...future.rng), started = ...future.startTime, 
[17:48:10.260]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.260]             version = "1.8"), class = "FutureResult")
[17:48:10.260]     }, finally = {
[17:48:10.260]         if (!identical(...future.workdir, getwd())) 
[17:48:10.260]             setwd(...future.workdir)
[17:48:10.260]         {
[17:48:10.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.260]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.260]             }
[17:48:10.260]             base::options(...future.oldOptions)
[17:48:10.260]             if (.Platform$OS.type == "windows") {
[17:48:10.260]                 old_names <- names(...future.oldEnvVars)
[17:48:10.260]                 envs <- base::Sys.getenv()
[17:48:10.260]                 names <- names(envs)
[17:48:10.260]                 common <- intersect(names, old_names)
[17:48:10.260]                 added <- setdiff(names, old_names)
[17:48:10.260]                 removed <- setdiff(old_names, names)
[17:48:10.260]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.260]                   envs[common]]
[17:48:10.260]                 NAMES <- toupper(changed)
[17:48:10.260]                 args <- list()
[17:48:10.260]                 for (kk in seq_along(NAMES)) {
[17:48:10.260]                   name <- changed[[kk]]
[17:48:10.260]                   NAME <- NAMES[[kk]]
[17:48:10.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.260]                     next
[17:48:10.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.260]                 }
[17:48:10.260]                 NAMES <- toupper(added)
[17:48:10.260]                 for (kk in seq_along(NAMES)) {
[17:48:10.260]                   name <- added[[kk]]
[17:48:10.260]                   NAME <- NAMES[[kk]]
[17:48:10.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.260]                     next
[17:48:10.260]                   args[[name]] <- ""
[17:48:10.260]                 }
[17:48:10.260]                 NAMES <- toupper(removed)
[17:48:10.260]                 for (kk in seq_along(NAMES)) {
[17:48:10.260]                   name <- removed[[kk]]
[17:48:10.260]                   NAME <- NAMES[[kk]]
[17:48:10.260]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.260]                     next
[17:48:10.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.260]                 }
[17:48:10.260]                 if (length(args) > 0) 
[17:48:10.260]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.260]             }
[17:48:10.260]             else {
[17:48:10.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.260]             }
[17:48:10.260]             {
[17:48:10.260]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.260]                   0L) {
[17:48:10.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.260]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.260]                   base::options(opts)
[17:48:10.260]                 }
[17:48:10.260]                 {
[17:48:10.260]                   {
[17:48:10.260]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.260]                     NULL
[17:48:10.260]                   }
[17:48:10.260]                   options(future.plan = NULL)
[17:48:10.260]                   if (is.na(NA_character_)) 
[17:48:10.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.260]                     .init = FALSE)
[17:48:10.260]                 }
[17:48:10.260]             }
[17:48:10.260]         }
[17:48:10.260]     })
[17:48:10.260]     if (TRUE) {
[17:48:10.260]         base::sink(type = "output", split = FALSE)
[17:48:10.260]         if (TRUE) {
[17:48:10.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.260]         }
[17:48:10.260]         else {
[17:48:10.260]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.260]         }
[17:48:10.260]         base::close(...future.stdout)
[17:48:10.260]         ...future.stdout <- NULL
[17:48:10.260]     }
[17:48:10.260]     ...future.result$conditions <- ...future.conditions
[17:48:10.260]     ...future.result$finished <- base::Sys.time()
[17:48:10.260]     ...future.result
[17:48:10.260] }
[17:48:10.263] MultisessionFuture started
[17:48:10.264] - Launch lazy future ... done
[17:48:10.264] run() for ‘MultisessionFuture’ ... done
[17:48:10.265] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.265] - Validating connection of MultisessionFuture
[17:48:10.265] - received message: FutureResult
[17:48:10.265] - Received FutureResult
[17:48:10.266] - Erased future from FutureRegistry
[17:48:10.266] result() for ClusterFuture ...
[17:48:10.266] - result already collected: FutureResult
[17:48:10.266] result() for ClusterFuture ... done
[17:48:10.266] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.266] Future #2
[17:48:10.266]  length: 1 (resolved future 2)
[17:48:10.266]  length: 0 (resolved future 3)
[17:48:10.266] resolve() on list ... DONE
[17:48:10.267] getGlobalsAndPackages() ...
[17:48:10.267] Searching for globals...
[17:48:10.267] 
[17:48:10.267] Searching for globals ... DONE
[17:48:10.267] - globals: [0] <none>
[17:48:10.267] getGlobalsAndPackages() ... DONE
[17:48:10.268] run() for ‘Future’ ...
[17:48:10.268] - state: ‘created’
[17:48:10.268] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.281] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.282]   - Field: ‘node’
[17:48:10.282]   - Field: ‘label’
[17:48:10.282]   - Field: ‘local’
[17:48:10.282]   - Field: ‘owner’
[17:48:10.282]   - Field: ‘envir’
[17:48:10.282]   - Field: ‘workers’
[17:48:10.282]   - Field: ‘packages’
[17:48:10.282]   - Field: ‘gc’
[17:48:10.282]   - Field: ‘conditions’
[17:48:10.283]   - Field: ‘persistent’
[17:48:10.283]   - Field: ‘expr’
[17:48:10.283]   - Field: ‘uuid’
[17:48:10.283]   - Field: ‘seed’
[17:48:10.283]   - Field: ‘version’
[17:48:10.283]   - Field: ‘result’
[17:48:10.283]   - Field: ‘asynchronous’
[17:48:10.283]   - Field: ‘calls’
[17:48:10.283]   - Field: ‘globals’
[17:48:10.283]   - Field: ‘stdout’
[17:48:10.283]   - Field: ‘earlySignal’
[17:48:10.284]   - Field: ‘lazy’
[17:48:10.284]   - Field: ‘state’
[17:48:10.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.284] - Launch lazy future ...
[17:48:10.284] Packages needed by the future expression (n = 0): <none>
[17:48:10.284] Packages needed by future strategies (n = 0): <none>
[17:48:10.285] {
[17:48:10.285]     {
[17:48:10.285]         {
[17:48:10.285]             ...future.startTime <- base::Sys.time()
[17:48:10.285]             {
[17:48:10.285]                 {
[17:48:10.285]                   {
[17:48:10.285]                     {
[17:48:10.285]                       base::local({
[17:48:10.285]                         has_future <- base::requireNamespace("future", 
[17:48:10.285]                           quietly = TRUE)
[17:48:10.285]                         if (has_future) {
[17:48:10.285]                           ns <- base::getNamespace("future")
[17:48:10.285]                           version <- ns[[".package"]][["version"]]
[17:48:10.285]                           if (is.null(version)) 
[17:48:10.285]                             version <- utils::packageVersion("future")
[17:48:10.285]                         }
[17:48:10.285]                         else {
[17:48:10.285]                           version <- NULL
[17:48:10.285]                         }
[17:48:10.285]                         if (!has_future || version < "1.8.0") {
[17:48:10.285]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.285]                             "", base::R.version$version.string), 
[17:48:10.285]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.285]                               "release", "version")], collapse = " "), 
[17:48:10.285]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.285]                             info)
[17:48:10.285]                           info <- base::paste(info, collapse = "; ")
[17:48:10.285]                           if (!has_future) {
[17:48:10.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.285]                               info)
[17:48:10.285]                           }
[17:48:10.285]                           else {
[17:48:10.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.285]                               info, version)
[17:48:10.285]                           }
[17:48:10.285]                           base::stop(msg)
[17:48:10.285]                         }
[17:48:10.285]                       })
[17:48:10.285]                     }
[17:48:10.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.285]                     base::options(mc.cores = 1L)
[17:48:10.285]                   }
[17:48:10.285]                   ...future.strategy.old <- future::plan("list")
[17:48:10.285]                   options(future.plan = NULL)
[17:48:10.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.285]                 }
[17:48:10.285]                 ...future.workdir <- getwd()
[17:48:10.285]             }
[17:48:10.285]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.285]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.285]         }
[17:48:10.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.285]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.285]             base::names(...future.oldOptions))
[17:48:10.285]     }
[17:48:10.285]     if (FALSE) {
[17:48:10.285]     }
[17:48:10.285]     else {
[17:48:10.285]         if (TRUE) {
[17:48:10.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.285]                 open = "w")
[17:48:10.285]         }
[17:48:10.285]         else {
[17:48:10.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.285]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.285]         }
[17:48:10.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.285]             base::sink(type = "output", split = FALSE)
[17:48:10.285]             base::close(...future.stdout)
[17:48:10.285]         }, add = TRUE)
[17:48:10.285]     }
[17:48:10.285]     ...future.frame <- base::sys.nframe()
[17:48:10.285]     ...future.conditions <- base::list()
[17:48:10.285]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.285]     if (FALSE) {
[17:48:10.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.285]     }
[17:48:10.285]     ...future.result <- base::tryCatch({
[17:48:10.285]         base::withCallingHandlers({
[17:48:10.285]             ...future.value <- base::withVisible(base::local({
[17:48:10.285]                 ...future.makeSendCondition <- base::local({
[17:48:10.285]                   sendCondition <- NULL
[17:48:10.285]                   function(frame = 1L) {
[17:48:10.285]                     if (is.function(sendCondition)) 
[17:48:10.285]                       return(sendCondition)
[17:48:10.285]                     ns <- getNamespace("parallel")
[17:48:10.285]                     if (exists("sendData", mode = "function", 
[17:48:10.285]                       envir = ns)) {
[17:48:10.285]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.285]                         envir = ns)
[17:48:10.285]                       envir <- sys.frame(frame)
[17:48:10.285]                       master <- NULL
[17:48:10.285]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.285]                         !identical(envir, emptyenv())) {
[17:48:10.285]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.285]                           inherits = FALSE)) {
[17:48:10.285]                           master <- get("master", mode = "list", 
[17:48:10.285]                             envir = envir, inherits = FALSE)
[17:48:10.285]                           if (inherits(master, c("SOCKnode", 
[17:48:10.285]                             "SOCK0node"))) {
[17:48:10.285]                             sendCondition <<- function(cond) {
[17:48:10.285]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.285]                                 success = TRUE)
[17:48:10.285]                               parallel_sendData(master, data)
[17:48:10.285]                             }
[17:48:10.285]                             return(sendCondition)
[17:48:10.285]                           }
[17:48:10.285]                         }
[17:48:10.285]                         frame <- frame + 1L
[17:48:10.285]                         envir <- sys.frame(frame)
[17:48:10.285]                       }
[17:48:10.285]                     }
[17:48:10.285]                     sendCondition <<- function(cond) NULL
[17:48:10.285]                   }
[17:48:10.285]                 })
[17:48:10.285]                 withCallingHandlers({
[17:48:10.285]                   1
[17:48:10.285]                 }, immediateCondition = function(cond) {
[17:48:10.285]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.285]                   sendCondition(cond)
[17:48:10.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.285]                   {
[17:48:10.285]                     inherits <- base::inherits
[17:48:10.285]                     invokeRestart <- base::invokeRestart
[17:48:10.285]                     is.null <- base::is.null
[17:48:10.285]                     muffled <- FALSE
[17:48:10.285]                     if (inherits(cond, "message")) {
[17:48:10.285]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.285]                       if (muffled) 
[17:48:10.285]                         invokeRestart("muffleMessage")
[17:48:10.285]                     }
[17:48:10.285]                     else if (inherits(cond, "warning")) {
[17:48:10.285]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.285]                       if (muffled) 
[17:48:10.285]                         invokeRestart("muffleWarning")
[17:48:10.285]                     }
[17:48:10.285]                     else if (inherits(cond, "condition")) {
[17:48:10.285]                       if (!is.null(pattern)) {
[17:48:10.285]                         computeRestarts <- base::computeRestarts
[17:48:10.285]                         grepl <- base::grepl
[17:48:10.285]                         restarts <- computeRestarts(cond)
[17:48:10.285]                         for (restart in restarts) {
[17:48:10.285]                           name <- restart$name
[17:48:10.285]                           if (is.null(name)) 
[17:48:10.285]                             next
[17:48:10.285]                           if (!grepl(pattern, name)) 
[17:48:10.285]                             next
[17:48:10.285]                           invokeRestart(restart)
[17:48:10.285]                           muffled <- TRUE
[17:48:10.285]                           break
[17:48:10.285]                         }
[17:48:10.285]                       }
[17:48:10.285]                     }
[17:48:10.285]                     invisible(muffled)
[17:48:10.285]                   }
[17:48:10.285]                   muffleCondition(cond)
[17:48:10.285]                 })
[17:48:10.285]             }))
[17:48:10.285]             future::FutureResult(value = ...future.value$value, 
[17:48:10.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.285]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.285]                     ...future.globalenv.names))
[17:48:10.285]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.285]         }, condition = base::local({
[17:48:10.285]             c <- base::c
[17:48:10.285]             inherits <- base::inherits
[17:48:10.285]             invokeRestart <- base::invokeRestart
[17:48:10.285]             length <- base::length
[17:48:10.285]             list <- base::list
[17:48:10.285]             seq.int <- base::seq.int
[17:48:10.285]             signalCondition <- base::signalCondition
[17:48:10.285]             sys.calls <- base::sys.calls
[17:48:10.285]             `[[` <- base::`[[`
[17:48:10.285]             `+` <- base::`+`
[17:48:10.285]             `<<-` <- base::`<<-`
[17:48:10.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.285]                   3L)]
[17:48:10.285]             }
[17:48:10.285]             function(cond) {
[17:48:10.285]                 is_error <- inherits(cond, "error")
[17:48:10.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.285]                   NULL)
[17:48:10.285]                 if (is_error) {
[17:48:10.285]                   sessionInformation <- function() {
[17:48:10.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.285]                       search = base::search(), system = base::Sys.info())
[17:48:10.285]                   }
[17:48:10.285]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.285]                     cond$call), session = sessionInformation(), 
[17:48:10.285]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.285]                   signalCondition(cond)
[17:48:10.285]                 }
[17:48:10.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.285]                 "immediateCondition"))) {
[17:48:10.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.285]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.285]                   if (TRUE && !signal) {
[17:48:10.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.285]                     {
[17:48:10.285]                       inherits <- base::inherits
[17:48:10.285]                       invokeRestart <- base::invokeRestart
[17:48:10.285]                       is.null <- base::is.null
[17:48:10.285]                       muffled <- FALSE
[17:48:10.285]                       if (inherits(cond, "message")) {
[17:48:10.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.285]                         if (muffled) 
[17:48:10.285]                           invokeRestart("muffleMessage")
[17:48:10.285]                       }
[17:48:10.285]                       else if (inherits(cond, "warning")) {
[17:48:10.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.285]                         if (muffled) 
[17:48:10.285]                           invokeRestart("muffleWarning")
[17:48:10.285]                       }
[17:48:10.285]                       else if (inherits(cond, "condition")) {
[17:48:10.285]                         if (!is.null(pattern)) {
[17:48:10.285]                           computeRestarts <- base::computeRestarts
[17:48:10.285]                           grepl <- base::grepl
[17:48:10.285]                           restarts <- computeRestarts(cond)
[17:48:10.285]                           for (restart in restarts) {
[17:48:10.285]                             name <- restart$name
[17:48:10.285]                             if (is.null(name)) 
[17:48:10.285]                               next
[17:48:10.285]                             if (!grepl(pattern, name)) 
[17:48:10.285]                               next
[17:48:10.285]                             invokeRestart(restart)
[17:48:10.285]                             muffled <- TRUE
[17:48:10.285]                             break
[17:48:10.285]                           }
[17:48:10.285]                         }
[17:48:10.285]                       }
[17:48:10.285]                       invisible(muffled)
[17:48:10.285]                     }
[17:48:10.285]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.285]                   }
[17:48:10.285]                 }
[17:48:10.285]                 else {
[17:48:10.285]                   if (TRUE) {
[17:48:10.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.285]                     {
[17:48:10.285]                       inherits <- base::inherits
[17:48:10.285]                       invokeRestart <- base::invokeRestart
[17:48:10.285]                       is.null <- base::is.null
[17:48:10.285]                       muffled <- FALSE
[17:48:10.285]                       if (inherits(cond, "message")) {
[17:48:10.285]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.285]                         if (muffled) 
[17:48:10.285]                           invokeRestart("muffleMessage")
[17:48:10.285]                       }
[17:48:10.285]                       else if (inherits(cond, "warning")) {
[17:48:10.285]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.285]                         if (muffled) 
[17:48:10.285]                           invokeRestart("muffleWarning")
[17:48:10.285]                       }
[17:48:10.285]                       else if (inherits(cond, "condition")) {
[17:48:10.285]                         if (!is.null(pattern)) {
[17:48:10.285]                           computeRestarts <- base::computeRestarts
[17:48:10.285]                           grepl <- base::grepl
[17:48:10.285]                           restarts <- computeRestarts(cond)
[17:48:10.285]                           for (restart in restarts) {
[17:48:10.285]                             name <- restart$name
[17:48:10.285]                             if (is.null(name)) 
[17:48:10.285]                               next
[17:48:10.285]                             if (!grepl(pattern, name)) 
[17:48:10.285]                               next
[17:48:10.285]                             invokeRestart(restart)
[17:48:10.285]                             muffled <- TRUE
[17:48:10.285]                             break
[17:48:10.285]                           }
[17:48:10.285]                         }
[17:48:10.285]                       }
[17:48:10.285]                       invisible(muffled)
[17:48:10.285]                     }
[17:48:10.285]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.285]                   }
[17:48:10.285]                 }
[17:48:10.285]             }
[17:48:10.285]         }))
[17:48:10.285]     }, error = function(ex) {
[17:48:10.285]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.285]                 ...future.rng), started = ...future.startTime, 
[17:48:10.285]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.285]             version = "1.8"), class = "FutureResult")
[17:48:10.285]     }, finally = {
[17:48:10.285]         if (!identical(...future.workdir, getwd())) 
[17:48:10.285]             setwd(...future.workdir)
[17:48:10.285]         {
[17:48:10.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.285]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.285]             }
[17:48:10.285]             base::options(...future.oldOptions)
[17:48:10.285]             if (.Platform$OS.type == "windows") {
[17:48:10.285]                 old_names <- names(...future.oldEnvVars)
[17:48:10.285]                 envs <- base::Sys.getenv()
[17:48:10.285]                 names <- names(envs)
[17:48:10.285]                 common <- intersect(names, old_names)
[17:48:10.285]                 added <- setdiff(names, old_names)
[17:48:10.285]                 removed <- setdiff(old_names, names)
[17:48:10.285]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.285]                   envs[common]]
[17:48:10.285]                 NAMES <- toupper(changed)
[17:48:10.285]                 args <- list()
[17:48:10.285]                 for (kk in seq_along(NAMES)) {
[17:48:10.285]                   name <- changed[[kk]]
[17:48:10.285]                   NAME <- NAMES[[kk]]
[17:48:10.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.285]                     next
[17:48:10.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.285]                 }
[17:48:10.285]                 NAMES <- toupper(added)
[17:48:10.285]                 for (kk in seq_along(NAMES)) {
[17:48:10.285]                   name <- added[[kk]]
[17:48:10.285]                   NAME <- NAMES[[kk]]
[17:48:10.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.285]                     next
[17:48:10.285]                   args[[name]] <- ""
[17:48:10.285]                 }
[17:48:10.285]                 NAMES <- toupper(removed)
[17:48:10.285]                 for (kk in seq_along(NAMES)) {
[17:48:10.285]                   name <- removed[[kk]]
[17:48:10.285]                   NAME <- NAMES[[kk]]
[17:48:10.285]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.285]                     next
[17:48:10.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.285]                 }
[17:48:10.285]                 if (length(args) > 0) 
[17:48:10.285]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.285]             }
[17:48:10.285]             else {
[17:48:10.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.285]             }
[17:48:10.285]             {
[17:48:10.285]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.285]                   0L) {
[17:48:10.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.285]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.285]                   base::options(opts)
[17:48:10.285]                 }
[17:48:10.285]                 {
[17:48:10.285]                   {
[17:48:10.285]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.285]                     NULL
[17:48:10.285]                   }
[17:48:10.285]                   options(future.plan = NULL)
[17:48:10.285]                   if (is.na(NA_character_)) 
[17:48:10.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.285]                     .init = FALSE)
[17:48:10.285]                 }
[17:48:10.285]             }
[17:48:10.285]         }
[17:48:10.285]     })
[17:48:10.285]     if (TRUE) {
[17:48:10.285]         base::sink(type = "output", split = FALSE)
[17:48:10.285]         if (TRUE) {
[17:48:10.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.285]         }
[17:48:10.285]         else {
[17:48:10.285]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.285]         }
[17:48:10.285]         base::close(...future.stdout)
[17:48:10.285]         ...future.stdout <- NULL
[17:48:10.285]     }
[17:48:10.285]     ...future.result$conditions <- ...future.conditions
[17:48:10.285]     ...future.result$finished <- base::Sys.time()
[17:48:10.285]     ...future.result
[17:48:10.285] }
[17:48:10.288] MultisessionFuture started
[17:48:10.288] - Launch lazy future ... done
[17:48:10.288] run() for ‘MultisessionFuture’ ... done
[17:48:10.288] getGlobalsAndPackages() ...
[17:48:10.288] Searching for globals...
[17:48:10.290] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:48:10.290] Searching for globals ... DONE
[17:48:10.290] Resolving globals: FALSE
[17:48:10.290] 
[17:48:10.291] 
[17:48:10.291] getGlobalsAndPackages() ... DONE
[17:48:10.291] run() for ‘Future’ ...
[17:48:10.291] - state: ‘created’
[17:48:10.291] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.306] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.306]   - Field: ‘node’
[17:48:10.306]   - Field: ‘label’
[17:48:10.306]   - Field: ‘local’
[17:48:10.307]   - Field: ‘owner’
[17:48:10.307]   - Field: ‘envir’
[17:48:10.307]   - Field: ‘workers’
[17:48:10.310]   - Field: ‘packages’
[17:48:10.310]   - Field: ‘gc’
[17:48:10.311]   - Field: ‘conditions’
[17:48:10.311]   - Field: ‘persistent’
[17:48:10.311]   - Field: ‘expr’
[17:48:10.311]   - Field: ‘uuid’
[17:48:10.311]   - Field: ‘seed’
[17:48:10.311]   - Field: ‘version’
[17:48:10.311]   - Field: ‘result’
[17:48:10.311]   - Field: ‘asynchronous’
[17:48:10.312]   - Field: ‘calls’
[17:48:10.312]   - Field: ‘globals’
[17:48:10.312]   - Field: ‘stdout’
[17:48:10.312]   - Field: ‘earlySignal’
[17:48:10.312]   - Field: ‘lazy’
[17:48:10.312]   - Field: ‘state’
[17:48:10.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.312] - Launch lazy future ...
[17:48:10.313] Packages needed by the future expression (n = 0): <none>
[17:48:10.313] Packages needed by future strategies (n = 0): <none>
[17:48:10.313] {
[17:48:10.313]     {
[17:48:10.313]         {
[17:48:10.313]             ...future.startTime <- base::Sys.time()
[17:48:10.313]             {
[17:48:10.313]                 {
[17:48:10.313]                   {
[17:48:10.313]                     {
[17:48:10.313]                       base::local({
[17:48:10.313]                         has_future <- base::requireNamespace("future", 
[17:48:10.313]                           quietly = TRUE)
[17:48:10.313]                         if (has_future) {
[17:48:10.313]                           ns <- base::getNamespace("future")
[17:48:10.313]                           version <- ns[[".package"]][["version"]]
[17:48:10.313]                           if (is.null(version)) 
[17:48:10.313]                             version <- utils::packageVersion("future")
[17:48:10.313]                         }
[17:48:10.313]                         else {
[17:48:10.313]                           version <- NULL
[17:48:10.313]                         }
[17:48:10.313]                         if (!has_future || version < "1.8.0") {
[17:48:10.313]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.313]                             "", base::R.version$version.string), 
[17:48:10.313]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.313]                               "release", "version")], collapse = " "), 
[17:48:10.313]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.313]                             info)
[17:48:10.313]                           info <- base::paste(info, collapse = "; ")
[17:48:10.313]                           if (!has_future) {
[17:48:10.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.313]                               info)
[17:48:10.313]                           }
[17:48:10.313]                           else {
[17:48:10.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.313]                               info, version)
[17:48:10.313]                           }
[17:48:10.313]                           base::stop(msg)
[17:48:10.313]                         }
[17:48:10.313]                       })
[17:48:10.313]                     }
[17:48:10.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.313]                     base::options(mc.cores = 1L)
[17:48:10.313]                   }
[17:48:10.313]                   ...future.strategy.old <- future::plan("list")
[17:48:10.313]                   options(future.plan = NULL)
[17:48:10.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.313]                 }
[17:48:10.313]                 ...future.workdir <- getwd()
[17:48:10.313]             }
[17:48:10.313]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.313]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.313]         }
[17:48:10.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.313]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.313]             base::names(...future.oldOptions))
[17:48:10.313]     }
[17:48:10.313]     if (FALSE) {
[17:48:10.313]     }
[17:48:10.313]     else {
[17:48:10.313]         if (TRUE) {
[17:48:10.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.313]                 open = "w")
[17:48:10.313]         }
[17:48:10.313]         else {
[17:48:10.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.313]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.313]         }
[17:48:10.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.313]             base::sink(type = "output", split = FALSE)
[17:48:10.313]             base::close(...future.stdout)
[17:48:10.313]         }, add = TRUE)
[17:48:10.313]     }
[17:48:10.313]     ...future.frame <- base::sys.nframe()
[17:48:10.313]     ...future.conditions <- base::list()
[17:48:10.313]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.313]     if (FALSE) {
[17:48:10.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.313]     }
[17:48:10.313]     ...future.result <- base::tryCatch({
[17:48:10.313]         base::withCallingHandlers({
[17:48:10.313]             ...future.value <- base::withVisible(base::local({
[17:48:10.313]                 ...future.makeSendCondition <- base::local({
[17:48:10.313]                   sendCondition <- NULL
[17:48:10.313]                   function(frame = 1L) {
[17:48:10.313]                     if (is.function(sendCondition)) 
[17:48:10.313]                       return(sendCondition)
[17:48:10.313]                     ns <- getNamespace("parallel")
[17:48:10.313]                     if (exists("sendData", mode = "function", 
[17:48:10.313]                       envir = ns)) {
[17:48:10.313]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.313]                         envir = ns)
[17:48:10.313]                       envir <- sys.frame(frame)
[17:48:10.313]                       master <- NULL
[17:48:10.313]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.313]                         !identical(envir, emptyenv())) {
[17:48:10.313]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.313]                           inherits = FALSE)) {
[17:48:10.313]                           master <- get("master", mode = "list", 
[17:48:10.313]                             envir = envir, inherits = FALSE)
[17:48:10.313]                           if (inherits(master, c("SOCKnode", 
[17:48:10.313]                             "SOCK0node"))) {
[17:48:10.313]                             sendCondition <<- function(cond) {
[17:48:10.313]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.313]                                 success = TRUE)
[17:48:10.313]                               parallel_sendData(master, data)
[17:48:10.313]                             }
[17:48:10.313]                             return(sendCondition)
[17:48:10.313]                           }
[17:48:10.313]                         }
[17:48:10.313]                         frame <- frame + 1L
[17:48:10.313]                         envir <- sys.frame(frame)
[17:48:10.313]                       }
[17:48:10.313]                     }
[17:48:10.313]                     sendCondition <<- function(cond) NULL
[17:48:10.313]                   }
[17:48:10.313]                 })
[17:48:10.313]                 withCallingHandlers({
[17:48:10.313]                   {
[17:48:10.313]                     Sys.sleep(0.5)
[17:48:10.313]                     2
[17:48:10.313]                   }
[17:48:10.313]                 }, immediateCondition = function(cond) {
[17:48:10.313]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.313]                   sendCondition(cond)
[17:48:10.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.313]                   {
[17:48:10.313]                     inherits <- base::inherits
[17:48:10.313]                     invokeRestart <- base::invokeRestart
[17:48:10.313]                     is.null <- base::is.null
[17:48:10.313]                     muffled <- FALSE
[17:48:10.313]                     if (inherits(cond, "message")) {
[17:48:10.313]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.313]                       if (muffled) 
[17:48:10.313]                         invokeRestart("muffleMessage")
[17:48:10.313]                     }
[17:48:10.313]                     else if (inherits(cond, "warning")) {
[17:48:10.313]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.313]                       if (muffled) 
[17:48:10.313]                         invokeRestart("muffleWarning")
[17:48:10.313]                     }
[17:48:10.313]                     else if (inherits(cond, "condition")) {
[17:48:10.313]                       if (!is.null(pattern)) {
[17:48:10.313]                         computeRestarts <- base::computeRestarts
[17:48:10.313]                         grepl <- base::grepl
[17:48:10.313]                         restarts <- computeRestarts(cond)
[17:48:10.313]                         for (restart in restarts) {
[17:48:10.313]                           name <- restart$name
[17:48:10.313]                           if (is.null(name)) 
[17:48:10.313]                             next
[17:48:10.313]                           if (!grepl(pattern, name)) 
[17:48:10.313]                             next
[17:48:10.313]                           invokeRestart(restart)
[17:48:10.313]                           muffled <- TRUE
[17:48:10.313]                           break
[17:48:10.313]                         }
[17:48:10.313]                       }
[17:48:10.313]                     }
[17:48:10.313]                     invisible(muffled)
[17:48:10.313]                   }
[17:48:10.313]                   muffleCondition(cond)
[17:48:10.313]                 })
[17:48:10.313]             }))
[17:48:10.313]             future::FutureResult(value = ...future.value$value, 
[17:48:10.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.313]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.313]                     ...future.globalenv.names))
[17:48:10.313]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.313]         }, condition = base::local({
[17:48:10.313]             c <- base::c
[17:48:10.313]             inherits <- base::inherits
[17:48:10.313]             invokeRestart <- base::invokeRestart
[17:48:10.313]             length <- base::length
[17:48:10.313]             list <- base::list
[17:48:10.313]             seq.int <- base::seq.int
[17:48:10.313]             signalCondition <- base::signalCondition
[17:48:10.313]             sys.calls <- base::sys.calls
[17:48:10.313]             `[[` <- base::`[[`
[17:48:10.313]             `+` <- base::`+`
[17:48:10.313]             `<<-` <- base::`<<-`
[17:48:10.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.313]                   3L)]
[17:48:10.313]             }
[17:48:10.313]             function(cond) {
[17:48:10.313]                 is_error <- inherits(cond, "error")
[17:48:10.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.313]                   NULL)
[17:48:10.313]                 if (is_error) {
[17:48:10.313]                   sessionInformation <- function() {
[17:48:10.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.313]                       search = base::search(), system = base::Sys.info())
[17:48:10.313]                   }
[17:48:10.313]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.313]                     cond$call), session = sessionInformation(), 
[17:48:10.313]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.313]                   signalCondition(cond)
[17:48:10.313]                 }
[17:48:10.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.313]                 "immediateCondition"))) {
[17:48:10.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.313]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.313]                   if (TRUE && !signal) {
[17:48:10.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.313]                     {
[17:48:10.313]                       inherits <- base::inherits
[17:48:10.313]                       invokeRestart <- base::invokeRestart
[17:48:10.313]                       is.null <- base::is.null
[17:48:10.313]                       muffled <- FALSE
[17:48:10.313]                       if (inherits(cond, "message")) {
[17:48:10.313]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.313]                         if (muffled) 
[17:48:10.313]                           invokeRestart("muffleMessage")
[17:48:10.313]                       }
[17:48:10.313]                       else if (inherits(cond, "warning")) {
[17:48:10.313]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.313]                         if (muffled) 
[17:48:10.313]                           invokeRestart("muffleWarning")
[17:48:10.313]                       }
[17:48:10.313]                       else if (inherits(cond, "condition")) {
[17:48:10.313]                         if (!is.null(pattern)) {
[17:48:10.313]                           computeRestarts <- base::computeRestarts
[17:48:10.313]                           grepl <- base::grepl
[17:48:10.313]                           restarts <- computeRestarts(cond)
[17:48:10.313]                           for (restart in restarts) {
[17:48:10.313]                             name <- restart$name
[17:48:10.313]                             if (is.null(name)) 
[17:48:10.313]                               next
[17:48:10.313]                             if (!grepl(pattern, name)) 
[17:48:10.313]                               next
[17:48:10.313]                             invokeRestart(restart)
[17:48:10.313]                             muffled <- TRUE
[17:48:10.313]                             break
[17:48:10.313]                           }
[17:48:10.313]                         }
[17:48:10.313]                       }
[17:48:10.313]                       invisible(muffled)
[17:48:10.313]                     }
[17:48:10.313]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.313]                   }
[17:48:10.313]                 }
[17:48:10.313]                 else {
[17:48:10.313]                   if (TRUE) {
[17:48:10.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.313]                     {
[17:48:10.313]                       inherits <- base::inherits
[17:48:10.313]                       invokeRestart <- base::invokeRestart
[17:48:10.313]                       is.null <- base::is.null
[17:48:10.313]                       muffled <- FALSE
[17:48:10.313]                       if (inherits(cond, "message")) {
[17:48:10.313]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.313]                         if (muffled) 
[17:48:10.313]                           invokeRestart("muffleMessage")
[17:48:10.313]                       }
[17:48:10.313]                       else if (inherits(cond, "warning")) {
[17:48:10.313]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.313]                         if (muffled) 
[17:48:10.313]                           invokeRestart("muffleWarning")
[17:48:10.313]                       }
[17:48:10.313]                       else if (inherits(cond, "condition")) {
[17:48:10.313]                         if (!is.null(pattern)) {
[17:48:10.313]                           computeRestarts <- base::computeRestarts
[17:48:10.313]                           grepl <- base::grepl
[17:48:10.313]                           restarts <- computeRestarts(cond)
[17:48:10.313]                           for (restart in restarts) {
[17:48:10.313]                             name <- restart$name
[17:48:10.313]                             if (is.null(name)) 
[17:48:10.313]                               next
[17:48:10.313]                             if (!grepl(pattern, name)) 
[17:48:10.313]                               next
[17:48:10.313]                             invokeRestart(restart)
[17:48:10.313]                             muffled <- TRUE
[17:48:10.313]                             break
[17:48:10.313]                           }
[17:48:10.313]                         }
[17:48:10.313]                       }
[17:48:10.313]                       invisible(muffled)
[17:48:10.313]                     }
[17:48:10.313]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.313]                   }
[17:48:10.313]                 }
[17:48:10.313]             }
[17:48:10.313]         }))
[17:48:10.313]     }, error = function(ex) {
[17:48:10.313]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.313]                 ...future.rng), started = ...future.startTime, 
[17:48:10.313]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.313]             version = "1.8"), class = "FutureResult")
[17:48:10.313]     }, finally = {
[17:48:10.313]         if (!identical(...future.workdir, getwd())) 
[17:48:10.313]             setwd(...future.workdir)
[17:48:10.313]         {
[17:48:10.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.313]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.313]             }
[17:48:10.313]             base::options(...future.oldOptions)
[17:48:10.313]             if (.Platform$OS.type == "windows") {
[17:48:10.313]                 old_names <- names(...future.oldEnvVars)
[17:48:10.313]                 envs <- base::Sys.getenv()
[17:48:10.313]                 names <- names(envs)
[17:48:10.313]                 common <- intersect(names, old_names)
[17:48:10.313]                 added <- setdiff(names, old_names)
[17:48:10.313]                 removed <- setdiff(old_names, names)
[17:48:10.313]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.313]                   envs[common]]
[17:48:10.313]                 NAMES <- toupper(changed)
[17:48:10.313]                 args <- list()
[17:48:10.313]                 for (kk in seq_along(NAMES)) {
[17:48:10.313]                   name <- changed[[kk]]
[17:48:10.313]                   NAME <- NAMES[[kk]]
[17:48:10.313]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.313]                     next
[17:48:10.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.313]                 }
[17:48:10.313]                 NAMES <- toupper(added)
[17:48:10.313]                 for (kk in seq_along(NAMES)) {
[17:48:10.313]                   name <- added[[kk]]
[17:48:10.313]                   NAME <- NAMES[[kk]]
[17:48:10.313]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.313]                     next
[17:48:10.313]                   args[[name]] <- ""
[17:48:10.313]                 }
[17:48:10.313]                 NAMES <- toupper(removed)
[17:48:10.313]                 for (kk in seq_along(NAMES)) {
[17:48:10.313]                   name <- removed[[kk]]
[17:48:10.313]                   NAME <- NAMES[[kk]]
[17:48:10.313]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.313]                     next
[17:48:10.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.313]                 }
[17:48:10.313]                 if (length(args) > 0) 
[17:48:10.313]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.313]             }
[17:48:10.313]             else {
[17:48:10.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.313]             }
[17:48:10.313]             {
[17:48:10.313]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.313]                   0L) {
[17:48:10.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.313]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.313]                   base::options(opts)
[17:48:10.313]                 }
[17:48:10.313]                 {
[17:48:10.313]                   {
[17:48:10.313]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.313]                     NULL
[17:48:10.313]                   }
[17:48:10.313]                   options(future.plan = NULL)
[17:48:10.313]                   if (is.na(NA_character_)) 
[17:48:10.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.313]                     .init = FALSE)
[17:48:10.313]                 }
[17:48:10.313]             }
[17:48:10.313]         }
[17:48:10.313]     })
[17:48:10.313]     if (TRUE) {
[17:48:10.313]         base::sink(type = "output", split = FALSE)
[17:48:10.313]         if (TRUE) {
[17:48:10.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.313]         }
[17:48:10.313]         else {
[17:48:10.313]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.313]         }
[17:48:10.313]         base::close(...future.stdout)
[17:48:10.313]         ...future.stdout <- NULL
[17:48:10.313]     }
[17:48:10.313]     ...future.result$conditions <- ...future.conditions
[17:48:10.313]     ...future.result$finished <- base::Sys.time()
[17:48:10.313]     ...future.result
[17:48:10.313] }
[17:48:10.316] MultisessionFuture started
[17:48:10.317] - Launch lazy future ... done
[17:48:10.317] run() for ‘MultisessionFuture’ ... done
[17:48:10.317] resolve() on list ...
[17:48:10.317]  recursive: 0
[17:48:10.317]  length: 1
[17:48:10.317] 
[17:48:10.318] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.318] - Validating connection of MultisessionFuture
[17:48:10.318] - received message: FutureResult
[17:48:10.319] - Received FutureResult
[17:48:10.319] - Erased future from FutureRegistry
[17:48:10.319] result() for ClusterFuture ...
[17:48:10.319] - result already collected: FutureResult
[17:48:10.319] result() for ClusterFuture ... done
[17:48:10.319] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.319] Future #1
[17:48:10.320]  length: 0 (resolved future 1)
[17:48:10.320] resolve() on list ... DONE
[17:48:10.320] resolve() on list ...
[17:48:10.320]  recursive: 0
[17:48:10.320]  length: 1
[17:48:10.320] 
[17:48:10.819] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.820] - Validating connection of MultisessionFuture
[17:48:10.820] - received message: FutureResult
[17:48:10.820] - Received FutureResult
[17:48:10.820] - Erased future from FutureRegistry
[17:48:10.820] result() for ClusterFuture ...
[17:48:10.820] - result already collected: FutureResult
[17:48:10.820] result() for ClusterFuture ... done
[17:48:10.820] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.821] Future #1
[17:48:10.821]  length: 0 (resolved future 1)
[17:48:10.821] resolve() on list ... DONE
[17:48:10.821] resolve() on list ...
[17:48:10.821]  recursive: 0
[17:48:10.821]  length: 1
[17:48:10.821] 
[17:48:10.821]  length: 0 (resolved future 1)
[17:48:10.821] resolve() on list ... DONE
[17:48:10.822] resolve() on list ...
[17:48:10.822]  recursive: 0
[17:48:10.822]  length: 4
[17:48:10.822] 
[17:48:10.822] Future #1
[17:48:10.822]  length: 3 (resolved future 1)
[17:48:10.822] Future #2
[17:48:10.822]  length: 2 (resolved future 2)
[17:48:10.822]  length: 1 (resolved future 3)
[17:48:10.822]  length: 0 (resolved future 4)
[17:48:10.823] resolve() on list ... DONE
[17:48:10.823] resolve() on list ...
[17:48:10.823]  recursive: 0
[17:48:10.823]  length: 4
[17:48:10.823] 
[17:48:10.823] Future #1
[17:48:10.823]  length: 3 (resolved future 1)
[17:48:10.823] Future #2
[17:48:10.823]  length: 2 (resolved future 2)
[17:48:10.824]  length: 1 (resolved future 3)
[17:48:10.824]  length: 0 (resolved future 4)
[17:48:10.824] resolve() on list ... DONE
[17:48:10.824] resolve() on list ...
[17:48:10.824]  recursive: 0
[17:48:10.824]  length: 1
[17:48:10.824] 
[17:48:10.824]  length: 0 (resolved future 1)
[17:48:10.824] resolve() on list ... DONE
[17:48:10.824] getGlobalsAndPackages() ...
[17:48:10.825] Searching for globals...
[17:48:10.825] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:48:10.826] Searching for globals ... DONE
[17:48:10.826] Resolving globals: FALSE
[17:48:10.826] The total size of the 1 globals is 56 bytes (56 bytes)
[17:48:10.826] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:48:10.827] - globals: [1] ‘kk’
[17:48:10.827] 
[17:48:10.827] getGlobalsAndPackages() ... DONE
[17:48:10.827] run() for ‘Future’ ...
[17:48:10.827] - state: ‘created’
[17:48:10.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.842] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.842]   - Field: ‘node’
[17:48:10.842]   - Field: ‘label’
[17:48:10.843]   - Field: ‘local’
[17:48:10.843]   - Field: ‘owner’
[17:48:10.843]   - Field: ‘envir’
[17:48:10.843]   - Field: ‘workers’
[17:48:10.843]   - Field: ‘packages’
[17:48:10.843]   - Field: ‘gc’
[17:48:10.843]   - Field: ‘conditions’
[17:48:10.843]   - Field: ‘persistent’
[17:48:10.843]   - Field: ‘expr’
[17:48:10.843]   - Field: ‘uuid’
[17:48:10.844]   - Field: ‘seed’
[17:48:10.844]   - Field: ‘version’
[17:48:10.844]   - Field: ‘result’
[17:48:10.844]   - Field: ‘asynchronous’
[17:48:10.844]   - Field: ‘calls’
[17:48:10.844]   - Field: ‘globals’
[17:48:10.844]   - Field: ‘stdout’
[17:48:10.844]   - Field: ‘earlySignal’
[17:48:10.844]   - Field: ‘lazy’
[17:48:10.844]   - Field: ‘state’
[17:48:10.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.844] - Launch lazy future ...
[17:48:10.845] Packages needed by the future expression (n = 0): <none>
[17:48:10.845] Packages needed by future strategies (n = 0): <none>
[17:48:10.845] {
[17:48:10.845]     {
[17:48:10.845]         {
[17:48:10.845]             ...future.startTime <- base::Sys.time()
[17:48:10.845]             {
[17:48:10.845]                 {
[17:48:10.845]                   {
[17:48:10.845]                     {
[17:48:10.845]                       base::local({
[17:48:10.845]                         has_future <- base::requireNamespace("future", 
[17:48:10.845]                           quietly = TRUE)
[17:48:10.845]                         if (has_future) {
[17:48:10.845]                           ns <- base::getNamespace("future")
[17:48:10.845]                           version <- ns[[".package"]][["version"]]
[17:48:10.845]                           if (is.null(version)) 
[17:48:10.845]                             version <- utils::packageVersion("future")
[17:48:10.845]                         }
[17:48:10.845]                         else {
[17:48:10.845]                           version <- NULL
[17:48:10.845]                         }
[17:48:10.845]                         if (!has_future || version < "1.8.0") {
[17:48:10.845]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.845]                             "", base::R.version$version.string), 
[17:48:10.845]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.845]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.845]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.845]                               "release", "version")], collapse = " "), 
[17:48:10.845]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.845]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.845]                             info)
[17:48:10.845]                           info <- base::paste(info, collapse = "; ")
[17:48:10.845]                           if (!has_future) {
[17:48:10.845]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.845]                               info)
[17:48:10.845]                           }
[17:48:10.845]                           else {
[17:48:10.845]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.845]                               info, version)
[17:48:10.845]                           }
[17:48:10.845]                           base::stop(msg)
[17:48:10.845]                         }
[17:48:10.845]                       })
[17:48:10.845]                     }
[17:48:10.845]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.845]                     base::options(mc.cores = 1L)
[17:48:10.845]                   }
[17:48:10.845]                   ...future.strategy.old <- future::plan("list")
[17:48:10.845]                   options(future.plan = NULL)
[17:48:10.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.845]                 }
[17:48:10.845]                 ...future.workdir <- getwd()
[17:48:10.845]             }
[17:48:10.845]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.845]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.845]         }
[17:48:10.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.845]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.845]             base::names(...future.oldOptions))
[17:48:10.845]     }
[17:48:10.845]     if (FALSE) {
[17:48:10.845]     }
[17:48:10.845]     else {
[17:48:10.845]         if (TRUE) {
[17:48:10.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.845]                 open = "w")
[17:48:10.845]         }
[17:48:10.845]         else {
[17:48:10.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.845]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.845]         }
[17:48:10.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.845]             base::sink(type = "output", split = FALSE)
[17:48:10.845]             base::close(...future.stdout)
[17:48:10.845]         }, add = TRUE)
[17:48:10.845]     }
[17:48:10.845]     ...future.frame <- base::sys.nframe()
[17:48:10.845]     ...future.conditions <- base::list()
[17:48:10.845]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.845]     if (FALSE) {
[17:48:10.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.845]     }
[17:48:10.845]     ...future.result <- base::tryCatch({
[17:48:10.845]         base::withCallingHandlers({
[17:48:10.845]             ...future.value <- base::withVisible(base::local({
[17:48:10.845]                 ...future.makeSendCondition <- base::local({
[17:48:10.845]                   sendCondition <- NULL
[17:48:10.845]                   function(frame = 1L) {
[17:48:10.845]                     if (is.function(sendCondition)) 
[17:48:10.845]                       return(sendCondition)
[17:48:10.845]                     ns <- getNamespace("parallel")
[17:48:10.845]                     if (exists("sendData", mode = "function", 
[17:48:10.845]                       envir = ns)) {
[17:48:10.845]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.845]                         envir = ns)
[17:48:10.845]                       envir <- sys.frame(frame)
[17:48:10.845]                       master <- NULL
[17:48:10.845]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.845]                         !identical(envir, emptyenv())) {
[17:48:10.845]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.845]                           inherits = FALSE)) {
[17:48:10.845]                           master <- get("master", mode = "list", 
[17:48:10.845]                             envir = envir, inherits = FALSE)
[17:48:10.845]                           if (inherits(master, c("SOCKnode", 
[17:48:10.845]                             "SOCK0node"))) {
[17:48:10.845]                             sendCondition <<- function(cond) {
[17:48:10.845]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.845]                                 success = TRUE)
[17:48:10.845]                               parallel_sendData(master, data)
[17:48:10.845]                             }
[17:48:10.845]                             return(sendCondition)
[17:48:10.845]                           }
[17:48:10.845]                         }
[17:48:10.845]                         frame <- frame + 1L
[17:48:10.845]                         envir <- sys.frame(frame)
[17:48:10.845]                       }
[17:48:10.845]                     }
[17:48:10.845]                     sendCondition <<- function(cond) NULL
[17:48:10.845]                   }
[17:48:10.845]                 })
[17:48:10.845]                 withCallingHandlers({
[17:48:10.845]                   {
[17:48:10.845]                     Sys.sleep(0.1)
[17:48:10.845]                     kk
[17:48:10.845]                   }
[17:48:10.845]                 }, immediateCondition = function(cond) {
[17:48:10.845]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.845]                   sendCondition(cond)
[17:48:10.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.845]                   {
[17:48:10.845]                     inherits <- base::inherits
[17:48:10.845]                     invokeRestart <- base::invokeRestart
[17:48:10.845]                     is.null <- base::is.null
[17:48:10.845]                     muffled <- FALSE
[17:48:10.845]                     if (inherits(cond, "message")) {
[17:48:10.845]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.845]                       if (muffled) 
[17:48:10.845]                         invokeRestart("muffleMessage")
[17:48:10.845]                     }
[17:48:10.845]                     else if (inherits(cond, "warning")) {
[17:48:10.845]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.845]                       if (muffled) 
[17:48:10.845]                         invokeRestart("muffleWarning")
[17:48:10.845]                     }
[17:48:10.845]                     else if (inherits(cond, "condition")) {
[17:48:10.845]                       if (!is.null(pattern)) {
[17:48:10.845]                         computeRestarts <- base::computeRestarts
[17:48:10.845]                         grepl <- base::grepl
[17:48:10.845]                         restarts <- computeRestarts(cond)
[17:48:10.845]                         for (restart in restarts) {
[17:48:10.845]                           name <- restart$name
[17:48:10.845]                           if (is.null(name)) 
[17:48:10.845]                             next
[17:48:10.845]                           if (!grepl(pattern, name)) 
[17:48:10.845]                             next
[17:48:10.845]                           invokeRestart(restart)
[17:48:10.845]                           muffled <- TRUE
[17:48:10.845]                           break
[17:48:10.845]                         }
[17:48:10.845]                       }
[17:48:10.845]                     }
[17:48:10.845]                     invisible(muffled)
[17:48:10.845]                   }
[17:48:10.845]                   muffleCondition(cond)
[17:48:10.845]                 })
[17:48:10.845]             }))
[17:48:10.845]             future::FutureResult(value = ...future.value$value, 
[17:48:10.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.845]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.845]                     ...future.globalenv.names))
[17:48:10.845]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.845]         }, condition = base::local({
[17:48:10.845]             c <- base::c
[17:48:10.845]             inherits <- base::inherits
[17:48:10.845]             invokeRestart <- base::invokeRestart
[17:48:10.845]             length <- base::length
[17:48:10.845]             list <- base::list
[17:48:10.845]             seq.int <- base::seq.int
[17:48:10.845]             signalCondition <- base::signalCondition
[17:48:10.845]             sys.calls <- base::sys.calls
[17:48:10.845]             `[[` <- base::`[[`
[17:48:10.845]             `+` <- base::`+`
[17:48:10.845]             `<<-` <- base::`<<-`
[17:48:10.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.845]                   3L)]
[17:48:10.845]             }
[17:48:10.845]             function(cond) {
[17:48:10.845]                 is_error <- inherits(cond, "error")
[17:48:10.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.845]                   NULL)
[17:48:10.845]                 if (is_error) {
[17:48:10.845]                   sessionInformation <- function() {
[17:48:10.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.845]                       search = base::search(), system = base::Sys.info())
[17:48:10.845]                   }
[17:48:10.845]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.845]                     cond$call), session = sessionInformation(), 
[17:48:10.845]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.845]                   signalCondition(cond)
[17:48:10.845]                 }
[17:48:10.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.845]                 "immediateCondition"))) {
[17:48:10.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.845]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.845]                   if (TRUE && !signal) {
[17:48:10.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.845]                     {
[17:48:10.845]                       inherits <- base::inherits
[17:48:10.845]                       invokeRestart <- base::invokeRestart
[17:48:10.845]                       is.null <- base::is.null
[17:48:10.845]                       muffled <- FALSE
[17:48:10.845]                       if (inherits(cond, "message")) {
[17:48:10.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.845]                         if (muffled) 
[17:48:10.845]                           invokeRestart("muffleMessage")
[17:48:10.845]                       }
[17:48:10.845]                       else if (inherits(cond, "warning")) {
[17:48:10.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.845]                         if (muffled) 
[17:48:10.845]                           invokeRestart("muffleWarning")
[17:48:10.845]                       }
[17:48:10.845]                       else if (inherits(cond, "condition")) {
[17:48:10.845]                         if (!is.null(pattern)) {
[17:48:10.845]                           computeRestarts <- base::computeRestarts
[17:48:10.845]                           grepl <- base::grepl
[17:48:10.845]                           restarts <- computeRestarts(cond)
[17:48:10.845]                           for (restart in restarts) {
[17:48:10.845]                             name <- restart$name
[17:48:10.845]                             if (is.null(name)) 
[17:48:10.845]                               next
[17:48:10.845]                             if (!grepl(pattern, name)) 
[17:48:10.845]                               next
[17:48:10.845]                             invokeRestart(restart)
[17:48:10.845]                             muffled <- TRUE
[17:48:10.845]                             break
[17:48:10.845]                           }
[17:48:10.845]                         }
[17:48:10.845]                       }
[17:48:10.845]                       invisible(muffled)
[17:48:10.845]                     }
[17:48:10.845]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.845]                   }
[17:48:10.845]                 }
[17:48:10.845]                 else {
[17:48:10.845]                   if (TRUE) {
[17:48:10.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.845]                     {
[17:48:10.845]                       inherits <- base::inherits
[17:48:10.845]                       invokeRestart <- base::invokeRestart
[17:48:10.845]                       is.null <- base::is.null
[17:48:10.845]                       muffled <- FALSE
[17:48:10.845]                       if (inherits(cond, "message")) {
[17:48:10.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.845]                         if (muffled) 
[17:48:10.845]                           invokeRestart("muffleMessage")
[17:48:10.845]                       }
[17:48:10.845]                       else if (inherits(cond, "warning")) {
[17:48:10.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.845]                         if (muffled) 
[17:48:10.845]                           invokeRestart("muffleWarning")
[17:48:10.845]                       }
[17:48:10.845]                       else if (inherits(cond, "condition")) {
[17:48:10.845]                         if (!is.null(pattern)) {
[17:48:10.845]                           computeRestarts <- base::computeRestarts
[17:48:10.845]                           grepl <- base::grepl
[17:48:10.845]                           restarts <- computeRestarts(cond)
[17:48:10.845]                           for (restart in restarts) {
[17:48:10.845]                             name <- restart$name
[17:48:10.845]                             if (is.null(name)) 
[17:48:10.845]                               next
[17:48:10.845]                             if (!grepl(pattern, name)) 
[17:48:10.845]                               next
[17:48:10.845]                             invokeRestart(restart)
[17:48:10.845]                             muffled <- TRUE
[17:48:10.845]                             break
[17:48:10.845]                           }
[17:48:10.845]                         }
[17:48:10.845]                       }
[17:48:10.845]                       invisible(muffled)
[17:48:10.845]                     }
[17:48:10.845]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.845]                   }
[17:48:10.845]                 }
[17:48:10.845]             }
[17:48:10.845]         }))
[17:48:10.845]     }, error = function(ex) {
[17:48:10.845]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.845]                 ...future.rng), started = ...future.startTime, 
[17:48:10.845]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.845]             version = "1.8"), class = "FutureResult")
[17:48:10.845]     }, finally = {
[17:48:10.845]         if (!identical(...future.workdir, getwd())) 
[17:48:10.845]             setwd(...future.workdir)
[17:48:10.845]         {
[17:48:10.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.845]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.845]             }
[17:48:10.845]             base::options(...future.oldOptions)
[17:48:10.845]             if (.Platform$OS.type == "windows") {
[17:48:10.845]                 old_names <- names(...future.oldEnvVars)
[17:48:10.845]                 envs <- base::Sys.getenv()
[17:48:10.845]                 names <- names(envs)
[17:48:10.845]                 common <- intersect(names, old_names)
[17:48:10.845]                 added <- setdiff(names, old_names)
[17:48:10.845]                 removed <- setdiff(old_names, names)
[17:48:10.845]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.845]                   envs[common]]
[17:48:10.845]                 NAMES <- toupper(changed)
[17:48:10.845]                 args <- list()
[17:48:10.845]                 for (kk in seq_along(NAMES)) {
[17:48:10.845]                   name <- changed[[kk]]
[17:48:10.845]                   NAME <- NAMES[[kk]]
[17:48:10.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.845]                     next
[17:48:10.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.845]                 }
[17:48:10.845]                 NAMES <- toupper(added)
[17:48:10.845]                 for (kk in seq_along(NAMES)) {
[17:48:10.845]                   name <- added[[kk]]
[17:48:10.845]                   NAME <- NAMES[[kk]]
[17:48:10.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.845]                     next
[17:48:10.845]                   args[[name]] <- ""
[17:48:10.845]                 }
[17:48:10.845]                 NAMES <- toupper(removed)
[17:48:10.845]                 for (kk in seq_along(NAMES)) {
[17:48:10.845]                   name <- removed[[kk]]
[17:48:10.845]                   NAME <- NAMES[[kk]]
[17:48:10.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.845]                     next
[17:48:10.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.845]                 }
[17:48:10.845]                 if (length(args) > 0) 
[17:48:10.845]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.845]             }
[17:48:10.845]             else {
[17:48:10.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.845]             }
[17:48:10.845]             {
[17:48:10.845]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.845]                   0L) {
[17:48:10.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.845]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.845]                   base::options(opts)
[17:48:10.845]                 }
[17:48:10.845]                 {
[17:48:10.845]                   {
[17:48:10.845]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.845]                     NULL
[17:48:10.845]                   }
[17:48:10.845]                   options(future.plan = NULL)
[17:48:10.845]                   if (is.na(NA_character_)) 
[17:48:10.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.845]                     .init = FALSE)
[17:48:10.845]                 }
[17:48:10.845]             }
[17:48:10.845]         }
[17:48:10.845]     })
[17:48:10.845]     if (TRUE) {
[17:48:10.845]         base::sink(type = "output", split = FALSE)
[17:48:10.845]         if (TRUE) {
[17:48:10.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.845]         }
[17:48:10.845]         else {
[17:48:10.845]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.845]         }
[17:48:10.845]         base::close(...future.stdout)
[17:48:10.845]         ...future.stdout <- NULL
[17:48:10.845]     }
[17:48:10.845]     ...future.result$conditions <- ...future.conditions
[17:48:10.845]     ...future.result$finished <- base::Sys.time()
[17:48:10.845]     ...future.result
[17:48:10.845] }
[17:48:10.848] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:48:10.848] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:48:10.848] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:48:10.849] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:48:10.849] MultisessionFuture started
[17:48:10.849] - Launch lazy future ... done
[17:48:10.849] run() for ‘MultisessionFuture’ ... done
[17:48:10.850] getGlobalsAndPackages() ...
[17:48:10.850] Searching for globals...
[17:48:10.851] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:48:10.851] Searching for globals ... DONE
[17:48:10.851] Resolving globals: FALSE
[17:48:10.852] The total size of the 1 globals is 56 bytes (56 bytes)
[17:48:10.852] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:48:10.852] - globals: [1] ‘kk’
[17:48:10.852] 
[17:48:10.852] getGlobalsAndPackages() ... DONE
[17:48:10.853] run() for ‘Future’ ...
[17:48:10.853] - state: ‘created’
[17:48:10.853] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.866]   - Field: ‘node’
[17:48:10.867]   - Field: ‘label’
[17:48:10.867]   - Field: ‘local’
[17:48:10.867]   - Field: ‘owner’
[17:48:10.867]   - Field: ‘envir’
[17:48:10.867]   - Field: ‘workers’
[17:48:10.867]   - Field: ‘packages’
[17:48:10.867]   - Field: ‘gc’
[17:48:10.867]   - Field: ‘conditions’
[17:48:10.867]   - Field: ‘persistent’
[17:48:10.867]   - Field: ‘expr’
[17:48:10.867]   - Field: ‘uuid’
[17:48:10.868]   - Field: ‘seed’
[17:48:10.868]   - Field: ‘version’
[17:48:10.868]   - Field: ‘result’
[17:48:10.868]   - Field: ‘asynchronous’
[17:48:10.868]   - Field: ‘calls’
[17:48:10.868]   - Field: ‘globals’
[17:48:10.868]   - Field: ‘stdout’
[17:48:10.868]   - Field: ‘earlySignal’
[17:48:10.868]   - Field: ‘lazy’
[17:48:10.868]   - Field: ‘state’
[17:48:10.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.869] - Launch lazy future ...
[17:48:10.869] Packages needed by the future expression (n = 0): <none>
[17:48:10.869] Packages needed by future strategies (n = 0): <none>
[17:48:10.869] {
[17:48:10.869]     {
[17:48:10.869]         {
[17:48:10.869]             ...future.startTime <- base::Sys.time()
[17:48:10.869]             {
[17:48:10.869]                 {
[17:48:10.869]                   {
[17:48:10.869]                     {
[17:48:10.869]                       base::local({
[17:48:10.869]                         has_future <- base::requireNamespace("future", 
[17:48:10.869]                           quietly = TRUE)
[17:48:10.869]                         if (has_future) {
[17:48:10.869]                           ns <- base::getNamespace("future")
[17:48:10.869]                           version <- ns[[".package"]][["version"]]
[17:48:10.869]                           if (is.null(version)) 
[17:48:10.869]                             version <- utils::packageVersion("future")
[17:48:10.869]                         }
[17:48:10.869]                         else {
[17:48:10.869]                           version <- NULL
[17:48:10.869]                         }
[17:48:10.869]                         if (!has_future || version < "1.8.0") {
[17:48:10.869]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.869]                             "", base::R.version$version.string), 
[17:48:10.869]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.869]                               "release", "version")], collapse = " "), 
[17:48:10.869]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.869]                             info)
[17:48:10.869]                           info <- base::paste(info, collapse = "; ")
[17:48:10.869]                           if (!has_future) {
[17:48:10.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.869]                               info)
[17:48:10.869]                           }
[17:48:10.869]                           else {
[17:48:10.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.869]                               info, version)
[17:48:10.869]                           }
[17:48:10.869]                           base::stop(msg)
[17:48:10.869]                         }
[17:48:10.869]                       })
[17:48:10.869]                     }
[17:48:10.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.869]                     base::options(mc.cores = 1L)
[17:48:10.869]                   }
[17:48:10.869]                   ...future.strategy.old <- future::plan("list")
[17:48:10.869]                   options(future.plan = NULL)
[17:48:10.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.869]                 }
[17:48:10.869]                 ...future.workdir <- getwd()
[17:48:10.869]             }
[17:48:10.869]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.869]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.869]         }
[17:48:10.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.869]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.869]             base::names(...future.oldOptions))
[17:48:10.869]     }
[17:48:10.869]     if (FALSE) {
[17:48:10.869]     }
[17:48:10.869]     else {
[17:48:10.869]         if (TRUE) {
[17:48:10.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.869]                 open = "w")
[17:48:10.869]         }
[17:48:10.869]         else {
[17:48:10.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.869]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.869]         }
[17:48:10.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.869]             base::sink(type = "output", split = FALSE)
[17:48:10.869]             base::close(...future.stdout)
[17:48:10.869]         }, add = TRUE)
[17:48:10.869]     }
[17:48:10.869]     ...future.frame <- base::sys.nframe()
[17:48:10.869]     ...future.conditions <- base::list()
[17:48:10.869]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.869]     if (FALSE) {
[17:48:10.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.869]     }
[17:48:10.869]     ...future.result <- base::tryCatch({
[17:48:10.869]         base::withCallingHandlers({
[17:48:10.869]             ...future.value <- base::withVisible(base::local({
[17:48:10.869]                 ...future.makeSendCondition <- base::local({
[17:48:10.869]                   sendCondition <- NULL
[17:48:10.869]                   function(frame = 1L) {
[17:48:10.869]                     if (is.function(sendCondition)) 
[17:48:10.869]                       return(sendCondition)
[17:48:10.869]                     ns <- getNamespace("parallel")
[17:48:10.869]                     if (exists("sendData", mode = "function", 
[17:48:10.869]                       envir = ns)) {
[17:48:10.869]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.869]                         envir = ns)
[17:48:10.869]                       envir <- sys.frame(frame)
[17:48:10.869]                       master <- NULL
[17:48:10.869]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.869]                         !identical(envir, emptyenv())) {
[17:48:10.869]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.869]                           inherits = FALSE)) {
[17:48:10.869]                           master <- get("master", mode = "list", 
[17:48:10.869]                             envir = envir, inherits = FALSE)
[17:48:10.869]                           if (inherits(master, c("SOCKnode", 
[17:48:10.869]                             "SOCK0node"))) {
[17:48:10.869]                             sendCondition <<- function(cond) {
[17:48:10.869]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.869]                                 success = TRUE)
[17:48:10.869]                               parallel_sendData(master, data)
[17:48:10.869]                             }
[17:48:10.869]                             return(sendCondition)
[17:48:10.869]                           }
[17:48:10.869]                         }
[17:48:10.869]                         frame <- frame + 1L
[17:48:10.869]                         envir <- sys.frame(frame)
[17:48:10.869]                       }
[17:48:10.869]                     }
[17:48:10.869]                     sendCondition <<- function(cond) NULL
[17:48:10.869]                   }
[17:48:10.869]                 })
[17:48:10.869]                 withCallingHandlers({
[17:48:10.869]                   {
[17:48:10.869]                     Sys.sleep(0.1)
[17:48:10.869]                     kk
[17:48:10.869]                   }
[17:48:10.869]                 }, immediateCondition = function(cond) {
[17:48:10.869]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.869]                   sendCondition(cond)
[17:48:10.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.869]                   {
[17:48:10.869]                     inherits <- base::inherits
[17:48:10.869]                     invokeRestart <- base::invokeRestart
[17:48:10.869]                     is.null <- base::is.null
[17:48:10.869]                     muffled <- FALSE
[17:48:10.869]                     if (inherits(cond, "message")) {
[17:48:10.869]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.869]                       if (muffled) 
[17:48:10.869]                         invokeRestart("muffleMessage")
[17:48:10.869]                     }
[17:48:10.869]                     else if (inherits(cond, "warning")) {
[17:48:10.869]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.869]                       if (muffled) 
[17:48:10.869]                         invokeRestart("muffleWarning")
[17:48:10.869]                     }
[17:48:10.869]                     else if (inherits(cond, "condition")) {
[17:48:10.869]                       if (!is.null(pattern)) {
[17:48:10.869]                         computeRestarts <- base::computeRestarts
[17:48:10.869]                         grepl <- base::grepl
[17:48:10.869]                         restarts <- computeRestarts(cond)
[17:48:10.869]                         for (restart in restarts) {
[17:48:10.869]                           name <- restart$name
[17:48:10.869]                           if (is.null(name)) 
[17:48:10.869]                             next
[17:48:10.869]                           if (!grepl(pattern, name)) 
[17:48:10.869]                             next
[17:48:10.869]                           invokeRestart(restart)
[17:48:10.869]                           muffled <- TRUE
[17:48:10.869]                           break
[17:48:10.869]                         }
[17:48:10.869]                       }
[17:48:10.869]                     }
[17:48:10.869]                     invisible(muffled)
[17:48:10.869]                   }
[17:48:10.869]                   muffleCondition(cond)
[17:48:10.869]                 })
[17:48:10.869]             }))
[17:48:10.869]             future::FutureResult(value = ...future.value$value, 
[17:48:10.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.869]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.869]                     ...future.globalenv.names))
[17:48:10.869]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.869]         }, condition = base::local({
[17:48:10.869]             c <- base::c
[17:48:10.869]             inherits <- base::inherits
[17:48:10.869]             invokeRestart <- base::invokeRestart
[17:48:10.869]             length <- base::length
[17:48:10.869]             list <- base::list
[17:48:10.869]             seq.int <- base::seq.int
[17:48:10.869]             signalCondition <- base::signalCondition
[17:48:10.869]             sys.calls <- base::sys.calls
[17:48:10.869]             `[[` <- base::`[[`
[17:48:10.869]             `+` <- base::`+`
[17:48:10.869]             `<<-` <- base::`<<-`
[17:48:10.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.869]                   3L)]
[17:48:10.869]             }
[17:48:10.869]             function(cond) {
[17:48:10.869]                 is_error <- inherits(cond, "error")
[17:48:10.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.869]                   NULL)
[17:48:10.869]                 if (is_error) {
[17:48:10.869]                   sessionInformation <- function() {
[17:48:10.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.869]                       search = base::search(), system = base::Sys.info())
[17:48:10.869]                   }
[17:48:10.869]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.869]                     cond$call), session = sessionInformation(), 
[17:48:10.869]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.869]                   signalCondition(cond)
[17:48:10.869]                 }
[17:48:10.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.869]                 "immediateCondition"))) {
[17:48:10.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.869]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.869]                   if (TRUE && !signal) {
[17:48:10.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.869]                     {
[17:48:10.869]                       inherits <- base::inherits
[17:48:10.869]                       invokeRestart <- base::invokeRestart
[17:48:10.869]                       is.null <- base::is.null
[17:48:10.869]                       muffled <- FALSE
[17:48:10.869]                       if (inherits(cond, "message")) {
[17:48:10.869]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.869]                         if (muffled) 
[17:48:10.869]                           invokeRestart("muffleMessage")
[17:48:10.869]                       }
[17:48:10.869]                       else if (inherits(cond, "warning")) {
[17:48:10.869]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.869]                         if (muffled) 
[17:48:10.869]                           invokeRestart("muffleWarning")
[17:48:10.869]                       }
[17:48:10.869]                       else if (inherits(cond, "condition")) {
[17:48:10.869]                         if (!is.null(pattern)) {
[17:48:10.869]                           computeRestarts <- base::computeRestarts
[17:48:10.869]                           grepl <- base::grepl
[17:48:10.869]                           restarts <- computeRestarts(cond)
[17:48:10.869]                           for (restart in restarts) {
[17:48:10.869]                             name <- restart$name
[17:48:10.869]                             if (is.null(name)) 
[17:48:10.869]                               next
[17:48:10.869]                             if (!grepl(pattern, name)) 
[17:48:10.869]                               next
[17:48:10.869]                             invokeRestart(restart)
[17:48:10.869]                             muffled <- TRUE
[17:48:10.869]                             break
[17:48:10.869]                           }
[17:48:10.869]                         }
[17:48:10.869]                       }
[17:48:10.869]                       invisible(muffled)
[17:48:10.869]                     }
[17:48:10.869]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.869]                   }
[17:48:10.869]                 }
[17:48:10.869]                 else {
[17:48:10.869]                   if (TRUE) {
[17:48:10.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.869]                     {
[17:48:10.869]                       inherits <- base::inherits
[17:48:10.869]                       invokeRestart <- base::invokeRestart
[17:48:10.869]                       is.null <- base::is.null
[17:48:10.869]                       muffled <- FALSE
[17:48:10.869]                       if (inherits(cond, "message")) {
[17:48:10.869]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.869]                         if (muffled) 
[17:48:10.869]                           invokeRestart("muffleMessage")
[17:48:10.869]                       }
[17:48:10.869]                       else if (inherits(cond, "warning")) {
[17:48:10.869]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.869]                         if (muffled) 
[17:48:10.869]                           invokeRestart("muffleWarning")
[17:48:10.869]                       }
[17:48:10.869]                       else if (inherits(cond, "condition")) {
[17:48:10.869]                         if (!is.null(pattern)) {
[17:48:10.869]                           computeRestarts <- base::computeRestarts
[17:48:10.869]                           grepl <- base::grepl
[17:48:10.869]                           restarts <- computeRestarts(cond)
[17:48:10.869]                           for (restart in restarts) {
[17:48:10.869]                             name <- restart$name
[17:48:10.869]                             if (is.null(name)) 
[17:48:10.869]                               next
[17:48:10.869]                             if (!grepl(pattern, name)) 
[17:48:10.869]                               next
[17:48:10.869]                             invokeRestart(restart)
[17:48:10.869]                             muffled <- TRUE
[17:48:10.869]                             break
[17:48:10.869]                           }
[17:48:10.869]                         }
[17:48:10.869]                       }
[17:48:10.869]                       invisible(muffled)
[17:48:10.869]                     }
[17:48:10.869]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.869]                   }
[17:48:10.869]                 }
[17:48:10.869]             }
[17:48:10.869]         }))
[17:48:10.869]     }, error = function(ex) {
[17:48:10.869]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.869]                 ...future.rng), started = ...future.startTime, 
[17:48:10.869]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.869]             version = "1.8"), class = "FutureResult")
[17:48:10.869]     }, finally = {
[17:48:10.869]         if (!identical(...future.workdir, getwd())) 
[17:48:10.869]             setwd(...future.workdir)
[17:48:10.869]         {
[17:48:10.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.869]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.869]             }
[17:48:10.869]             base::options(...future.oldOptions)
[17:48:10.869]             if (.Platform$OS.type == "windows") {
[17:48:10.869]                 old_names <- names(...future.oldEnvVars)
[17:48:10.869]                 envs <- base::Sys.getenv()
[17:48:10.869]                 names <- names(envs)
[17:48:10.869]                 common <- intersect(names, old_names)
[17:48:10.869]                 added <- setdiff(names, old_names)
[17:48:10.869]                 removed <- setdiff(old_names, names)
[17:48:10.869]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.869]                   envs[common]]
[17:48:10.869]                 NAMES <- toupper(changed)
[17:48:10.869]                 args <- list()
[17:48:10.869]                 for (kk in seq_along(NAMES)) {
[17:48:10.869]                   name <- changed[[kk]]
[17:48:10.869]                   NAME <- NAMES[[kk]]
[17:48:10.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.869]                     next
[17:48:10.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.869]                 }
[17:48:10.869]                 NAMES <- toupper(added)
[17:48:10.869]                 for (kk in seq_along(NAMES)) {
[17:48:10.869]                   name <- added[[kk]]
[17:48:10.869]                   NAME <- NAMES[[kk]]
[17:48:10.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.869]                     next
[17:48:10.869]                   args[[name]] <- ""
[17:48:10.869]                 }
[17:48:10.869]                 NAMES <- toupper(removed)
[17:48:10.869]                 for (kk in seq_along(NAMES)) {
[17:48:10.869]                   name <- removed[[kk]]
[17:48:10.869]                   NAME <- NAMES[[kk]]
[17:48:10.869]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.869]                     next
[17:48:10.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.869]                 }
[17:48:10.869]                 if (length(args) > 0) 
[17:48:10.869]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.869]             }
[17:48:10.869]             else {
[17:48:10.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.869]             }
[17:48:10.869]             {
[17:48:10.869]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.869]                   0L) {
[17:48:10.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.869]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.869]                   base::options(opts)
[17:48:10.869]                 }
[17:48:10.869]                 {
[17:48:10.869]                   {
[17:48:10.869]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.869]                     NULL
[17:48:10.869]                   }
[17:48:10.869]                   options(future.plan = NULL)
[17:48:10.869]                   if (is.na(NA_character_)) 
[17:48:10.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.869]                     .init = FALSE)
[17:48:10.869]                 }
[17:48:10.869]             }
[17:48:10.869]         }
[17:48:10.869]     })
[17:48:10.869]     if (TRUE) {
[17:48:10.869]         base::sink(type = "output", split = FALSE)
[17:48:10.869]         if (TRUE) {
[17:48:10.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.869]         }
[17:48:10.869]         else {
[17:48:10.869]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.869]         }
[17:48:10.869]         base::close(...future.stdout)
[17:48:10.869]         ...future.stdout <- NULL
[17:48:10.869]     }
[17:48:10.869]     ...future.result$conditions <- ...future.conditions
[17:48:10.869]     ...future.result$finished <- base::Sys.time()
[17:48:10.869]     ...future.result
[17:48:10.869] }
[17:48:10.872] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:48:10.872] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:48:10.872] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:48:10.873] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:48:10.873] MultisessionFuture started
[17:48:10.873] - Launch lazy future ... done
[17:48:10.873] run() for ‘MultisessionFuture’ ... done
[17:48:10.874] getGlobalsAndPackages() ...
[17:48:10.874] Searching for globals...
[17:48:10.875] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:48:10.875] Searching for globals ... DONE
[17:48:10.875] Resolving globals: FALSE
[17:48:10.876] The total size of the 1 globals is 56 bytes (56 bytes)
[17:48:10.876] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:48:10.876] - globals: [1] ‘kk’
[17:48:10.876] 
[17:48:10.876] getGlobalsAndPackages() ... DONE
[17:48:10.876] run() for ‘Future’ ...
[17:48:10.877] - state: ‘created’
[17:48:10.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:10.890] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:10.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:10.890]   - Field: ‘node’
[17:48:10.890]   - Field: ‘label’
[17:48:10.890]   - Field: ‘local’
[17:48:10.890]   - Field: ‘owner’
[17:48:10.891]   - Field: ‘envir’
[17:48:10.891]   - Field: ‘workers’
[17:48:10.891]   - Field: ‘packages’
[17:48:10.891]   - Field: ‘gc’
[17:48:10.891]   - Field: ‘conditions’
[17:48:10.891]   - Field: ‘persistent’
[17:48:10.891]   - Field: ‘expr’
[17:48:10.891]   - Field: ‘uuid’
[17:48:10.891]   - Field: ‘seed’
[17:48:10.891]   - Field: ‘version’
[17:48:10.892]   - Field: ‘result’
[17:48:10.892]   - Field: ‘asynchronous’
[17:48:10.892]   - Field: ‘calls’
[17:48:10.892]   - Field: ‘globals’
[17:48:10.892]   - Field: ‘stdout’
[17:48:10.892]   - Field: ‘earlySignal’
[17:48:10.892]   - Field: ‘lazy’
[17:48:10.892]   - Field: ‘state’
[17:48:10.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:10.892] - Launch lazy future ...
[17:48:10.893] Packages needed by the future expression (n = 0): <none>
[17:48:10.893] Packages needed by future strategies (n = 0): <none>
[17:48:10.893] {
[17:48:10.893]     {
[17:48:10.893]         {
[17:48:10.893]             ...future.startTime <- base::Sys.time()
[17:48:10.893]             {
[17:48:10.893]                 {
[17:48:10.893]                   {
[17:48:10.893]                     {
[17:48:10.893]                       base::local({
[17:48:10.893]                         has_future <- base::requireNamespace("future", 
[17:48:10.893]                           quietly = TRUE)
[17:48:10.893]                         if (has_future) {
[17:48:10.893]                           ns <- base::getNamespace("future")
[17:48:10.893]                           version <- ns[[".package"]][["version"]]
[17:48:10.893]                           if (is.null(version)) 
[17:48:10.893]                             version <- utils::packageVersion("future")
[17:48:10.893]                         }
[17:48:10.893]                         else {
[17:48:10.893]                           version <- NULL
[17:48:10.893]                         }
[17:48:10.893]                         if (!has_future || version < "1.8.0") {
[17:48:10.893]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:10.893]                             "", base::R.version$version.string), 
[17:48:10.893]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:10.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:10.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:10.893]                               "release", "version")], collapse = " "), 
[17:48:10.893]                             hostname = base::Sys.info()[["nodename"]])
[17:48:10.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:10.893]                             info)
[17:48:10.893]                           info <- base::paste(info, collapse = "; ")
[17:48:10.893]                           if (!has_future) {
[17:48:10.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:10.893]                               info)
[17:48:10.893]                           }
[17:48:10.893]                           else {
[17:48:10.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:10.893]                               info, version)
[17:48:10.893]                           }
[17:48:10.893]                           base::stop(msg)
[17:48:10.893]                         }
[17:48:10.893]                       })
[17:48:10.893]                     }
[17:48:10.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:10.893]                     base::options(mc.cores = 1L)
[17:48:10.893]                   }
[17:48:10.893]                   ...future.strategy.old <- future::plan("list")
[17:48:10.893]                   options(future.plan = NULL)
[17:48:10.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:10.893]                 }
[17:48:10.893]                 ...future.workdir <- getwd()
[17:48:10.893]             }
[17:48:10.893]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:10.893]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:10.893]         }
[17:48:10.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:10.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:10.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:10.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:10.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:10.893]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:10.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:10.893]             base::names(...future.oldOptions))
[17:48:10.893]     }
[17:48:10.893]     if (FALSE) {
[17:48:10.893]     }
[17:48:10.893]     else {
[17:48:10.893]         if (TRUE) {
[17:48:10.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:10.893]                 open = "w")
[17:48:10.893]         }
[17:48:10.893]         else {
[17:48:10.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:10.893]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:10.893]         }
[17:48:10.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:10.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:10.893]             base::sink(type = "output", split = FALSE)
[17:48:10.893]             base::close(...future.stdout)
[17:48:10.893]         }, add = TRUE)
[17:48:10.893]     }
[17:48:10.893]     ...future.frame <- base::sys.nframe()
[17:48:10.893]     ...future.conditions <- base::list()
[17:48:10.893]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:10.893]     if (FALSE) {
[17:48:10.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:10.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:10.893]     }
[17:48:10.893]     ...future.result <- base::tryCatch({
[17:48:10.893]         base::withCallingHandlers({
[17:48:10.893]             ...future.value <- base::withVisible(base::local({
[17:48:10.893]                 ...future.makeSendCondition <- base::local({
[17:48:10.893]                   sendCondition <- NULL
[17:48:10.893]                   function(frame = 1L) {
[17:48:10.893]                     if (is.function(sendCondition)) 
[17:48:10.893]                       return(sendCondition)
[17:48:10.893]                     ns <- getNamespace("parallel")
[17:48:10.893]                     if (exists("sendData", mode = "function", 
[17:48:10.893]                       envir = ns)) {
[17:48:10.893]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:10.893]                         envir = ns)
[17:48:10.893]                       envir <- sys.frame(frame)
[17:48:10.893]                       master <- NULL
[17:48:10.893]                       while (!identical(envir, .GlobalEnv) && 
[17:48:10.893]                         !identical(envir, emptyenv())) {
[17:48:10.893]                         if (exists("master", mode = "list", envir = envir, 
[17:48:10.893]                           inherits = FALSE)) {
[17:48:10.893]                           master <- get("master", mode = "list", 
[17:48:10.893]                             envir = envir, inherits = FALSE)
[17:48:10.893]                           if (inherits(master, c("SOCKnode", 
[17:48:10.893]                             "SOCK0node"))) {
[17:48:10.893]                             sendCondition <<- function(cond) {
[17:48:10.893]                               data <- list(type = "VALUE", value = cond, 
[17:48:10.893]                                 success = TRUE)
[17:48:10.893]                               parallel_sendData(master, data)
[17:48:10.893]                             }
[17:48:10.893]                             return(sendCondition)
[17:48:10.893]                           }
[17:48:10.893]                         }
[17:48:10.893]                         frame <- frame + 1L
[17:48:10.893]                         envir <- sys.frame(frame)
[17:48:10.893]                       }
[17:48:10.893]                     }
[17:48:10.893]                     sendCondition <<- function(cond) NULL
[17:48:10.893]                   }
[17:48:10.893]                 })
[17:48:10.893]                 withCallingHandlers({
[17:48:10.893]                   {
[17:48:10.893]                     Sys.sleep(0.1)
[17:48:10.893]                     kk
[17:48:10.893]                   }
[17:48:10.893]                 }, immediateCondition = function(cond) {
[17:48:10.893]                   sendCondition <- ...future.makeSendCondition()
[17:48:10.893]                   sendCondition(cond)
[17:48:10.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.893]                   {
[17:48:10.893]                     inherits <- base::inherits
[17:48:10.893]                     invokeRestart <- base::invokeRestart
[17:48:10.893]                     is.null <- base::is.null
[17:48:10.893]                     muffled <- FALSE
[17:48:10.893]                     if (inherits(cond, "message")) {
[17:48:10.893]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:10.893]                       if (muffled) 
[17:48:10.893]                         invokeRestart("muffleMessage")
[17:48:10.893]                     }
[17:48:10.893]                     else if (inherits(cond, "warning")) {
[17:48:10.893]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:10.893]                       if (muffled) 
[17:48:10.893]                         invokeRestart("muffleWarning")
[17:48:10.893]                     }
[17:48:10.893]                     else if (inherits(cond, "condition")) {
[17:48:10.893]                       if (!is.null(pattern)) {
[17:48:10.893]                         computeRestarts <- base::computeRestarts
[17:48:10.893]                         grepl <- base::grepl
[17:48:10.893]                         restarts <- computeRestarts(cond)
[17:48:10.893]                         for (restart in restarts) {
[17:48:10.893]                           name <- restart$name
[17:48:10.893]                           if (is.null(name)) 
[17:48:10.893]                             next
[17:48:10.893]                           if (!grepl(pattern, name)) 
[17:48:10.893]                             next
[17:48:10.893]                           invokeRestart(restart)
[17:48:10.893]                           muffled <- TRUE
[17:48:10.893]                           break
[17:48:10.893]                         }
[17:48:10.893]                       }
[17:48:10.893]                     }
[17:48:10.893]                     invisible(muffled)
[17:48:10.893]                   }
[17:48:10.893]                   muffleCondition(cond)
[17:48:10.893]                 })
[17:48:10.893]             }))
[17:48:10.893]             future::FutureResult(value = ...future.value$value, 
[17:48:10.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.893]                   ...future.rng), globalenv = if (FALSE) 
[17:48:10.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:10.893]                     ...future.globalenv.names))
[17:48:10.893]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:10.893]         }, condition = base::local({
[17:48:10.893]             c <- base::c
[17:48:10.893]             inherits <- base::inherits
[17:48:10.893]             invokeRestart <- base::invokeRestart
[17:48:10.893]             length <- base::length
[17:48:10.893]             list <- base::list
[17:48:10.893]             seq.int <- base::seq.int
[17:48:10.893]             signalCondition <- base::signalCondition
[17:48:10.893]             sys.calls <- base::sys.calls
[17:48:10.893]             `[[` <- base::`[[`
[17:48:10.893]             `+` <- base::`+`
[17:48:10.893]             `<<-` <- base::`<<-`
[17:48:10.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:10.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:10.893]                   3L)]
[17:48:10.893]             }
[17:48:10.893]             function(cond) {
[17:48:10.893]                 is_error <- inherits(cond, "error")
[17:48:10.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:10.893]                   NULL)
[17:48:10.893]                 if (is_error) {
[17:48:10.893]                   sessionInformation <- function() {
[17:48:10.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:10.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:10.893]                       search = base::search(), system = base::Sys.info())
[17:48:10.893]                   }
[17:48:10.893]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:10.893]                     cond$call), session = sessionInformation(), 
[17:48:10.893]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:10.893]                   signalCondition(cond)
[17:48:10.893]                 }
[17:48:10.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:10.893]                 "immediateCondition"))) {
[17:48:10.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:10.893]                   ...future.conditions[[length(...future.conditions) + 
[17:48:10.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:10.893]                   if (TRUE && !signal) {
[17:48:10.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.893]                     {
[17:48:10.893]                       inherits <- base::inherits
[17:48:10.893]                       invokeRestart <- base::invokeRestart
[17:48:10.893]                       is.null <- base::is.null
[17:48:10.893]                       muffled <- FALSE
[17:48:10.893]                       if (inherits(cond, "message")) {
[17:48:10.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.893]                         if (muffled) 
[17:48:10.893]                           invokeRestart("muffleMessage")
[17:48:10.893]                       }
[17:48:10.893]                       else if (inherits(cond, "warning")) {
[17:48:10.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.893]                         if (muffled) 
[17:48:10.893]                           invokeRestart("muffleWarning")
[17:48:10.893]                       }
[17:48:10.893]                       else if (inherits(cond, "condition")) {
[17:48:10.893]                         if (!is.null(pattern)) {
[17:48:10.893]                           computeRestarts <- base::computeRestarts
[17:48:10.893]                           grepl <- base::grepl
[17:48:10.893]                           restarts <- computeRestarts(cond)
[17:48:10.893]                           for (restart in restarts) {
[17:48:10.893]                             name <- restart$name
[17:48:10.893]                             if (is.null(name)) 
[17:48:10.893]                               next
[17:48:10.893]                             if (!grepl(pattern, name)) 
[17:48:10.893]                               next
[17:48:10.893]                             invokeRestart(restart)
[17:48:10.893]                             muffled <- TRUE
[17:48:10.893]                             break
[17:48:10.893]                           }
[17:48:10.893]                         }
[17:48:10.893]                       }
[17:48:10.893]                       invisible(muffled)
[17:48:10.893]                     }
[17:48:10.893]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.893]                   }
[17:48:10.893]                 }
[17:48:10.893]                 else {
[17:48:10.893]                   if (TRUE) {
[17:48:10.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:10.893]                     {
[17:48:10.893]                       inherits <- base::inherits
[17:48:10.893]                       invokeRestart <- base::invokeRestart
[17:48:10.893]                       is.null <- base::is.null
[17:48:10.893]                       muffled <- FALSE
[17:48:10.893]                       if (inherits(cond, "message")) {
[17:48:10.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:10.893]                         if (muffled) 
[17:48:10.893]                           invokeRestart("muffleMessage")
[17:48:10.893]                       }
[17:48:10.893]                       else if (inherits(cond, "warning")) {
[17:48:10.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:10.893]                         if (muffled) 
[17:48:10.893]                           invokeRestart("muffleWarning")
[17:48:10.893]                       }
[17:48:10.893]                       else if (inherits(cond, "condition")) {
[17:48:10.893]                         if (!is.null(pattern)) {
[17:48:10.893]                           computeRestarts <- base::computeRestarts
[17:48:10.893]                           grepl <- base::grepl
[17:48:10.893]                           restarts <- computeRestarts(cond)
[17:48:10.893]                           for (restart in restarts) {
[17:48:10.893]                             name <- restart$name
[17:48:10.893]                             if (is.null(name)) 
[17:48:10.893]                               next
[17:48:10.893]                             if (!grepl(pattern, name)) 
[17:48:10.893]                               next
[17:48:10.893]                             invokeRestart(restart)
[17:48:10.893]                             muffled <- TRUE
[17:48:10.893]                             break
[17:48:10.893]                           }
[17:48:10.893]                         }
[17:48:10.893]                       }
[17:48:10.893]                       invisible(muffled)
[17:48:10.893]                     }
[17:48:10.893]                     muffleCondition(cond, pattern = "^muffle")
[17:48:10.893]                   }
[17:48:10.893]                 }
[17:48:10.893]             }
[17:48:10.893]         }))
[17:48:10.893]     }, error = function(ex) {
[17:48:10.893]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:10.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:10.893]                 ...future.rng), started = ...future.startTime, 
[17:48:10.893]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:10.893]             version = "1.8"), class = "FutureResult")
[17:48:10.893]     }, finally = {
[17:48:10.893]         if (!identical(...future.workdir, getwd())) 
[17:48:10.893]             setwd(...future.workdir)
[17:48:10.893]         {
[17:48:10.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:10.893]                 ...future.oldOptions$nwarnings <- NULL
[17:48:10.893]             }
[17:48:10.893]             base::options(...future.oldOptions)
[17:48:10.893]             if (.Platform$OS.type == "windows") {
[17:48:10.893]                 old_names <- names(...future.oldEnvVars)
[17:48:10.893]                 envs <- base::Sys.getenv()
[17:48:10.893]                 names <- names(envs)
[17:48:10.893]                 common <- intersect(names, old_names)
[17:48:10.893]                 added <- setdiff(names, old_names)
[17:48:10.893]                 removed <- setdiff(old_names, names)
[17:48:10.893]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:10.893]                   envs[common]]
[17:48:10.893]                 NAMES <- toupper(changed)
[17:48:10.893]                 args <- list()
[17:48:10.893]                 for (kk in seq_along(NAMES)) {
[17:48:10.893]                   name <- changed[[kk]]
[17:48:10.893]                   NAME <- NAMES[[kk]]
[17:48:10.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.893]                     next
[17:48:10.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.893]                 }
[17:48:10.893]                 NAMES <- toupper(added)
[17:48:10.893]                 for (kk in seq_along(NAMES)) {
[17:48:10.893]                   name <- added[[kk]]
[17:48:10.893]                   NAME <- NAMES[[kk]]
[17:48:10.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.893]                     next
[17:48:10.893]                   args[[name]] <- ""
[17:48:10.893]                 }
[17:48:10.893]                 NAMES <- toupper(removed)
[17:48:10.893]                 for (kk in seq_along(NAMES)) {
[17:48:10.893]                   name <- removed[[kk]]
[17:48:10.893]                   NAME <- NAMES[[kk]]
[17:48:10.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:10.893]                     next
[17:48:10.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:10.893]                 }
[17:48:10.893]                 if (length(args) > 0) 
[17:48:10.893]                   base::do.call(base::Sys.setenv, args = args)
[17:48:10.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:10.893]             }
[17:48:10.893]             else {
[17:48:10.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:10.893]             }
[17:48:10.893]             {
[17:48:10.893]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:10.893]                   0L) {
[17:48:10.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:10.893]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:10.893]                   base::options(opts)
[17:48:10.893]                 }
[17:48:10.893]                 {
[17:48:10.893]                   {
[17:48:10.893]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:10.893]                     NULL
[17:48:10.893]                   }
[17:48:10.893]                   options(future.plan = NULL)
[17:48:10.893]                   if (is.na(NA_character_)) 
[17:48:10.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:10.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:10.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:10.893]                     .init = FALSE)
[17:48:10.893]                 }
[17:48:10.893]             }
[17:48:10.893]         }
[17:48:10.893]     })
[17:48:10.893]     if (TRUE) {
[17:48:10.893]         base::sink(type = "output", split = FALSE)
[17:48:10.893]         if (TRUE) {
[17:48:10.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:10.893]         }
[17:48:10.893]         else {
[17:48:10.893]             ...future.result["stdout"] <- base::list(NULL)
[17:48:10.893]         }
[17:48:10.893]         base::close(...future.stdout)
[17:48:10.893]         ...future.stdout <- NULL
[17:48:10.893]     }
[17:48:10.893]     ...future.result$conditions <- ...future.conditions
[17:48:10.893]     ...future.result$finished <- base::Sys.time()
[17:48:10.893]     ...future.result
[17:48:10.893] }
[17:48:10.895] Poll #1 (0): usedNodes() = 2, workers = 2
[17:48:10.926] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:48:10.958] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[17:48:10.969] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.969] - Validating connection of MultisessionFuture
[17:48:10.969] - received message: FutureResult
[17:48:10.969] - Received FutureResult
[17:48:10.969] - Erased future from FutureRegistry
[17:48:10.970] result() for ClusterFuture ...
[17:48:10.970] - result already collected: FutureResult
[17:48:10.970] result() for ClusterFuture ... done
[17:48:10.970] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.970] result() for ClusterFuture ...
[17:48:10.970] - result already collected: FutureResult
[17:48:10.970] result() for ClusterFuture ... done
[17:48:10.970] result() for ClusterFuture ...
[17:48:10.970] - result already collected: FutureResult
[17:48:10.970] result() for ClusterFuture ... done
[17:48:10.971] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:48:10.971] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:48:10.972] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:48:10.972] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:48:10.972] MultisessionFuture started
[17:48:10.972] - Launch lazy future ... done
[17:48:10.973] run() for ‘MultisessionFuture’ ... done
[17:48:10.973] resolve() on list ...
[17:48:10.973]  recursive: 0
[17:48:10.973]  length: 3
[17:48:10.973] 
[17:48:10.973] Future #1
[17:48:10.974]  length: 2 (resolved future 1)
[17:48:10.975] receiveMessageFromWorker() for ClusterFuture ...
[17:48:10.976] - Validating connection of MultisessionFuture
[17:48:10.976] - received message: FutureResult
[17:48:10.976] - Received FutureResult
[17:48:10.976] - Erased future from FutureRegistry
[17:48:10.976] result() for ClusterFuture ...
[17:48:10.976] - result already collected: FutureResult
[17:48:10.976] result() for ClusterFuture ... done
[17:48:10.977] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:10.977] Future #2
[17:48:10.977]  length: 1 (resolved future 2)
[17:48:11.080] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.080] - Validating connection of MultisessionFuture
[17:48:11.080] - received message: FutureResult
[17:48:11.081] - Received FutureResult
[17:48:11.081] - Erased future from FutureRegistry
[17:48:11.081] result() for ClusterFuture ...
[17:48:11.081] - result already collected: FutureResult
[17:48:11.081] result() for ClusterFuture ... done
[17:48:11.081] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.081] Future #3
[17:48:11.081]  length: 0 (resolved future 3)
[17:48:11.081] resolve() on list ... DONE
[17:48:11.081] getGlobalsAndPackages() ...
[17:48:11.082] Searching for globals...
[17:48:11.083] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:48:11.083] Searching for globals ... DONE
[17:48:11.083] Resolving globals: FALSE
[17:48:11.083] The total size of the 1 globals is 56 bytes (56 bytes)
[17:48:11.084] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:48:11.084] - globals: [1] ‘kk’
[17:48:11.084] 
[17:48:11.084] getGlobalsAndPackages() ... DONE
[17:48:11.084] getGlobalsAndPackages() ...
[17:48:11.084] Searching for globals...
[17:48:11.085] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:48:11.085] Searching for globals ... DONE
[17:48:11.085] Resolving globals: FALSE
[17:48:11.086] The total size of the 1 globals is 56 bytes (56 bytes)
[17:48:11.086] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:48:11.086] - globals: [1] ‘kk’
[17:48:11.086] 
[17:48:11.086] getGlobalsAndPackages() ... DONE
[17:48:11.087] getGlobalsAndPackages() ...
[17:48:11.087] Searching for globals...
[17:48:11.088] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:48:11.088] Searching for globals ... DONE
[17:48:11.088] Resolving globals: FALSE
[17:48:11.088] The total size of the 1 globals is 56 bytes (56 bytes)
[17:48:11.089] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:48:11.089] - globals: [1] ‘kk’
[17:48:11.089] 
[17:48:11.089] getGlobalsAndPackages() ... DONE
[17:48:11.089] resolve() on list ...
[17:48:11.089]  recursive: 0
[17:48:11.089]  length: 3
[17:48:11.089] 
[17:48:11.089] run() for ‘Future’ ...
[17:48:11.090] - state: ‘created’
[17:48:11.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.104] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.104]   - Field: ‘node’
[17:48:11.107]   - Field: ‘label’
[17:48:11.107]   - Field: ‘local’
[17:48:11.107]   - Field: ‘owner’
[17:48:11.108]   - Field: ‘envir’
[17:48:11.108]   - Field: ‘workers’
[17:48:11.108]   - Field: ‘packages’
[17:48:11.108]   - Field: ‘gc’
[17:48:11.108]   - Field: ‘conditions’
[17:48:11.108]   - Field: ‘persistent’
[17:48:11.108]   - Field: ‘expr’
[17:48:11.108]   - Field: ‘uuid’
[17:48:11.108]   - Field: ‘seed’
[17:48:11.109]   - Field: ‘version’
[17:48:11.109]   - Field: ‘result’
[17:48:11.109]   - Field: ‘asynchronous’
[17:48:11.109]   - Field: ‘calls’
[17:48:11.109]   - Field: ‘globals’
[17:48:11.109]   - Field: ‘stdout’
[17:48:11.109]   - Field: ‘earlySignal’
[17:48:11.109]   - Field: ‘lazy’
[17:48:11.109]   - Field: ‘state’
[17:48:11.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.110] - Launch lazy future ...
[17:48:11.110] Packages needed by the future expression (n = 0): <none>
[17:48:11.110] Packages needed by future strategies (n = 0): <none>
[17:48:11.111] {
[17:48:11.111]     {
[17:48:11.111]         {
[17:48:11.111]             ...future.startTime <- base::Sys.time()
[17:48:11.111]             {
[17:48:11.111]                 {
[17:48:11.111]                   {
[17:48:11.111]                     {
[17:48:11.111]                       base::local({
[17:48:11.111]                         has_future <- base::requireNamespace("future", 
[17:48:11.111]                           quietly = TRUE)
[17:48:11.111]                         if (has_future) {
[17:48:11.111]                           ns <- base::getNamespace("future")
[17:48:11.111]                           version <- ns[[".package"]][["version"]]
[17:48:11.111]                           if (is.null(version)) 
[17:48:11.111]                             version <- utils::packageVersion("future")
[17:48:11.111]                         }
[17:48:11.111]                         else {
[17:48:11.111]                           version <- NULL
[17:48:11.111]                         }
[17:48:11.111]                         if (!has_future || version < "1.8.0") {
[17:48:11.111]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.111]                             "", base::R.version$version.string), 
[17:48:11.111]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.111]                               "release", "version")], collapse = " "), 
[17:48:11.111]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.111]                             info)
[17:48:11.111]                           info <- base::paste(info, collapse = "; ")
[17:48:11.111]                           if (!has_future) {
[17:48:11.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.111]                               info)
[17:48:11.111]                           }
[17:48:11.111]                           else {
[17:48:11.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.111]                               info, version)
[17:48:11.111]                           }
[17:48:11.111]                           base::stop(msg)
[17:48:11.111]                         }
[17:48:11.111]                       })
[17:48:11.111]                     }
[17:48:11.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.111]                     base::options(mc.cores = 1L)
[17:48:11.111]                   }
[17:48:11.111]                   ...future.strategy.old <- future::plan("list")
[17:48:11.111]                   options(future.plan = NULL)
[17:48:11.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.111]                 }
[17:48:11.111]                 ...future.workdir <- getwd()
[17:48:11.111]             }
[17:48:11.111]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.111]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.111]         }
[17:48:11.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.111]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.111]             base::names(...future.oldOptions))
[17:48:11.111]     }
[17:48:11.111]     if (FALSE) {
[17:48:11.111]     }
[17:48:11.111]     else {
[17:48:11.111]         if (TRUE) {
[17:48:11.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.111]                 open = "w")
[17:48:11.111]         }
[17:48:11.111]         else {
[17:48:11.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.111]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.111]         }
[17:48:11.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.111]             base::sink(type = "output", split = FALSE)
[17:48:11.111]             base::close(...future.stdout)
[17:48:11.111]         }, add = TRUE)
[17:48:11.111]     }
[17:48:11.111]     ...future.frame <- base::sys.nframe()
[17:48:11.111]     ...future.conditions <- base::list()
[17:48:11.111]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.111]     if (FALSE) {
[17:48:11.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.111]     }
[17:48:11.111]     ...future.result <- base::tryCatch({
[17:48:11.111]         base::withCallingHandlers({
[17:48:11.111]             ...future.value <- base::withVisible(base::local({
[17:48:11.111]                 ...future.makeSendCondition <- base::local({
[17:48:11.111]                   sendCondition <- NULL
[17:48:11.111]                   function(frame = 1L) {
[17:48:11.111]                     if (is.function(sendCondition)) 
[17:48:11.111]                       return(sendCondition)
[17:48:11.111]                     ns <- getNamespace("parallel")
[17:48:11.111]                     if (exists("sendData", mode = "function", 
[17:48:11.111]                       envir = ns)) {
[17:48:11.111]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.111]                         envir = ns)
[17:48:11.111]                       envir <- sys.frame(frame)
[17:48:11.111]                       master <- NULL
[17:48:11.111]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.111]                         !identical(envir, emptyenv())) {
[17:48:11.111]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.111]                           inherits = FALSE)) {
[17:48:11.111]                           master <- get("master", mode = "list", 
[17:48:11.111]                             envir = envir, inherits = FALSE)
[17:48:11.111]                           if (inherits(master, c("SOCKnode", 
[17:48:11.111]                             "SOCK0node"))) {
[17:48:11.111]                             sendCondition <<- function(cond) {
[17:48:11.111]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.111]                                 success = TRUE)
[17:48:11.111]                               parallel_sendData(master, data)
[17:48:11.111]                             }
[17:48:11.111]                             return(sendCondition)
[17:48:11.111]                           }
[17:48:11.111]                         }
[17:48:11.111]                         frame <- frame + 1L
[17:48:11.111]                         envir <- sys.frame(frame)
[17:48:11.111]                       }
[17:48:11.111]                     }
[17:48:11.111]                     sendCondition <<- function(cond) NULL
[17:48:11.111]                   }
[17:48:11.111]                 })
[17:48:11.111]                 withCallingHandlers({
[17:48:11.111]                   {
[17:48:11.111]                     Sys.sleep(0.1)
[17:48:11.111]                     kk
[17:48:11.111]                   }
[17:48:11.111]                 }, immediateCondition = function(cond) {
[17:48:11.111]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.111]                   sendCondition(cond)
[17:48:11.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.111]                   {
[17:48:11.111]                     inherits <- base::inherits
[17:48:11.111]                     invokeRestart <- base::invokeRestart
[17:48:11.111]                     is.null <- base::is.null
[17:48:11.111]                     muffled <- FALSE
[17:48:11.111]                     if (inherits(cond, "message")) {
[17:48:11.111]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.111]                       if (muffled) 
[17:48:11.111]                         invokeRestart("muffleMessage")
[17:48:11.111]                     }
[17:48:11.111]                     else if (inherits(cond, "warning")) {
[17:48:11.111]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.111]                       if (muffled) 
[17:48:11.111]                         invokeRestart("muffleWarning")
[17:48:11.111]                     }
[17:48:11.111]                     else if (inherits(cond, "condition")) {
[17:48:11.111]                       if (!is.null(pattern)) {
[17:48:11.111]                         computeRestarts <- base::computeRestarts
[17:48:11.111]                         grepl <- base::grepl
[17:48:11.111]                         restarts <- computeRestarts(cond)
[17:48:11.111]                         for (restart in restarts) {
[17:48:11.111]                           name <- restart$name
[17:48:11.111]                           if (is.null(name)) 
[17:48:11.111]                             next
[17:48:11.111]                           if (!grepl(pattern, name)) 
[17:48:11.111]                             next
[17:48:11.111]                           invokeRestart(restart)
[17:48:11.111]                           muffled <- TRUE
[17:48:11.111]                           break
[17:48:11.111]                         }
[17:48:11.111]                       }
[17:48:11.111]                     }
[17:48:11.111]                     invisible(muffled)
[17:48:11.111]                   }
[17:48:11.111]                   muffleCondition(cond)
[17:48:11.111]                 })
[17:48:11.111]             }))
[17:48:11.111]             future::FutureResult(value = ...future.value$value, 
[17:48:11.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.111]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.111]                     ...future.globalenv.names))
[17:48:11.111]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.111]         }, condition = base::local({
[17:48:11.111]             c <- base::c
[17:48:11.111]             inherits <- base::inherits
[17:48:11.111]             invokeRestart <- base::invokeRestart
[17:48:11.111]             length <- base::length
[17:48:11.111]             list <- base::list
[17:48:11.111]             seq.int <- base::seq.int
[17:48:11.111]             signalCondition <- base::signalCondition
[17:48:11.111]             sys.calls <- base::sys.calls
[17:48:11.111]             `[[` <- base::`[[`
[17:48:11.111]             `+` <- base::`+`
[17:48:11.111]             `<<-` <- base::`<<-`
[17:48:11.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.111]                   3L)]
[17:48:11.111]             }
[17:48:11.111]             function(cond) {
[17:48:11.111]                 is_error <- inherits(cond, "error")
[17:48:11.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.111]                   NULL)
[17:48:11.111]                 if (is_error) {
[17:48:11.111]                   sessionInformation <- function() {
[17:48:11.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.111]                       search = base::search(), system = base::Sys.info())
[17:48:11.111]                   }
[17:48:11.111]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.111]                     cond$call), session = sessionInformation(), 
[17:48:11.111]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.111]                   signalCondition(cond)
[17:48:11.111]                 }
[17:48:11.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.111]                 "immediateCondition"))) {
[17:48:11.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.111]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.111]                   if (TRUE && !signal) {
[17:48:11.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.111]                     {
[17:48:11.111]                       inherits <- base::inherits
[17:48:11.111]                       invokeRestart <- base::invokeRestart
[17:48:11.111]                       is.null <- base::is.null
[17:48:11.111]                       muffled <- FALSE
[17:48:11.111]                       if (inherits(cond, "message")) {
[17:48:11.111]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.111]                         if (muffled) 
[17:48:11.111]                           invokeRestart("muffleMessage")
[17:48:11.111]                       }
[17:48:11.111]                       else if (inherits(cond, "warning")) {
[17:48:11.111]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.111]                         if (muffled) 
[17:48:11.111]                           invokeRestart("muffleWarning")
[17:48:11.111]                       }
[17:48:11.111]                       else if (inherits(cond, "condition")) {
[17:48:11.111]                         if (!is.null(pattern)) {
[17:48:11.111]                           computeRestarts <- base::computeRestarts
[17:48:11.111]                           grepl <- base::grepl
[17:48:11.111]                           restarts <- computeRestarts(cond)
[17:48:11.111]                           for (restart in restarts) {
[17:48:11.111]                             name <- restart$name
[17:48:11.111]                             if (is.null(name)) 
[17:48:11.111]                               next
[17:48:11.111]                             if (!grepl(pattern, name)) 
[17:48:11.111]                               next
[17:48:11.111]                             invokeRestart(restart)
[17:48:11.111]                             muffled <- TRUE
[17:48:11.111]                             break
[17:48:11.111]                           }
[17:48:11.111]                         }
[17:48:11.111]                       }
[17:48:11.111]                       invisible(muffled)
[17:48:11.111]                     }
[17:48:11.111]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.111]                   }
[17:48:11.111]                 }
[17:48:11.111]                 else {
[17:48:11.111]                   if (TRUE) {
[17:48:11.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.111]                     {
[17:48:11.111]                       inherits <- base::inherits
[17:48:11.111]                       invokeRestart <- base::invokeRestart
[17:48:11.111]                       is.null <- base::is.null
[17:48:11.111]                       muffled <- FALSE
[17:48:11.111]                       if (inherits(cond, "message")) {
[17:48:11.111]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.111]                         if (muffled) 
[17:48:11.111]                           invokeRestart("muffleMessage")
[17:48:11.111]                       }
[17:48:11.111]                       else if (inherits(cond, "warning")) {
[17:48:11.111]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.111]                         if (muffled) 
[17:48:11.111]                           invokeRestart("muffleWarning")
[17:48:11.111]                       }
[17:48:11.111]                       else if (inherits(cond, "condition")) {
[17:48:11.111]                         if (!is.null(pattern)) {
[17:48:11.111]                           computeRestarts <- base::computeRestarts
[17:48:11.111]                           grepl <- base::grepl
[17:48:11.111]                           restarts <- computeRestarts(cond)
[17:48:11.111]                           for (restart in restarts) {
[17:48:11.111]                             name <- restart$name
[17:48:11.111]                             if (is.null(name)) 
[17:48:11.111]                               next
[17:48:11.111]                             if (!grepl(pattern, name)) 
[17:48:11.111]                               next
[17:48:11.111]                             invokeRestart(restart)
[17:48:11.111]                             muffled <- TRUE
[17:48:11.111]                             break
[17:48:11.111]                           }
[17:48:11.111]                         }
[17:48:11.111]                       }
[17:48:11.111]                       invisible(muffled)
[17:48:11.111]                     }
[17:48:11.111]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.111]                   }
[17:48:11.111]                 }
[17:48:11.111]             }
[17:48:11.111]         }))
[17:48:11.111]     }, error = function(ex) {
[17:48:11.111]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.111]                 ...future.rng), started = ...future.startTime, 
[17:48:11.111]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.111]             version = "1.8"), class = "FutureResult")
[17:48:11.111]     }, finally = {
[17:48:11.111]         if (!identical(...future.workdir, getwd())) 
[17:48:11.111]             setwd(...future.workdir)
[17:48:11.111]         {
[17:48:11.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.111]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.111]             }
[17:48:11.111]             base::options(...future.oldOptions)
[17:48:11.111]             if (.Platform$OS.type == "windows") {
[17:48:11.111]                 old_names <- names(...future.oldEnvVars)
[17:48:11.111]                 envs <- base::Sys.getenv()
[17:48:11.111]                 names <- names(envs)
[17:48:11.111]                 common <- intersect(names, old_names)
[17:48:11.111]                 added <- setdiff(names, old_names)
[17:48:11.111]                 removed <- setdiff(old_names, names)
[17:48:11.111]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.111]                   envs[common]]
[17:48:11.111]                 NAMES <- toupper(changed)
[17:48:11.111]                 args <- list()
[17:48:11.111]                 for (kk in seq_along(NAMES)) {
[17:48:11.111]                   name <- changed[[kk]]
[17:48:11.111]                   NAME <- NAMES[[kk]]
[17:48:11.111]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.111]                     next
[17:48:11.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.111]                 }
[17:48:11.111]                 NAMES <- toupper(added)
[17:48:11.111]                 for (kk in seq_along(NAMES)) {
[17:48:11.111]                   name <- added[[kk]]
[17:48:11.111]                   NAME <- NAMES[[kk]]
[17:48:11.111]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.111]                     next
[17:48:11.111]                   args[[name]] <- ""
[17:48:11.111]                 }
[17:48:11.111]                 NAMES <- toupper(removed)
[17:48:11.111]                 for (kk in seq_along(NAMES)) {
[17:48:11.111]                   name <- removed[[kk]]
[17:48:11.111]                   NAME <- NAMES[[kk]]
[17:48:11.111]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.111]                     next
[17:48:11.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.111]                 }
[17:48:11.111]                 if (length(args) > 0) 
[17:48:11.111]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.111]             }
[17:48:11.111]             else {
[17:48:11.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.111]             }
[17:48:11.111]             {
[17:48:11.111]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.111]                   0L) {
[17:48:11.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.111]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.111]                   base::options(opts)
[17:48:11.111]                 }
[17:48:11.111]                 {
[17:48:11.111]                   {
[17:48:11.111]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.111]                     NULL
[17:48:11.111]                   }
[17:48:11.111]                   options(future.plan = NULL)
[17:48:11.111]                   if (is.na(NA_character_)) 
[17:48:11.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.111]                     .init = FALSE)
[17:48:11.111]                 }
[17:48:11.111]             }
[17:48:11.111]         }
[17:48:11.111]     })
[17:48:11.111]     if (TRUE) {
[17:48:11.111]         base::sink(type = "output", split = FALSE)
[17:48:11.111]         if (TRUE) {
[17:48:11.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.111]         }
[17:48:11.111]         else {
[17:48:11.111]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.111]         }
[17:48:11.111]         base::close(...future.stdout)
[17:48:11.111]         ...future.stdout <- NULL
[17:48:11.111]     }
[17:48:11.111]     ...future.result$conditions <- ...future.conditions
[17:48:11.111]     ...future.result$finished <- base::Sys.time()
[17:48:11.111]     ...future.result
[17:48:11.111] }
[17:48:11.113] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:48:11.113] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:48:11.114] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:48:11.114] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:48:11.114] MultisessionFuture started
[17:48:11.115] - Launch lazy future ... done
[17:48:11.115] run() for ‘MultisessionFuture’ ... done
[17:48:11.126] run() for ‘Future’ ...
[17:48:11.126] - state: ‘created’
[17:48:11.126] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.140] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.141]   - Field: ‘node’
[17:48:11.141]   - Field: ‘label’
[17:48:11.141]   - Field: ‘local’
[17:48:11.141]   - Field: ‘owner’
[17:48:11.141]   - Field: ‘envir’
[17:48:11.141]   - Field: ‘workers’
[17:48:11.141]   - Field: ‘packages’
[17:48:11.141]   - Field: ‘gc’
[17:48:11.142]   - Field: ‘conditions’
[17:48:11.142]   - Field: ‘persistent’
[17:48:11.142]   - Field: ‘expr’
[17:48:11.142]   - Field: ‘uuid’
[17:48:11.142]   - Field: ‘seed’
[17:48:11.142]   - Field: ‘version’
[17:48:11.142]   - Field: ‘result’
[17:48:11.142]   - Field: ‘asynchronous’
[17:48:11.142]   - Field: ‘calls’
[17:48:11.143]   - Field: ‘globals’
[17:48:11.143]   - Field: ‘stdout’
[17:48:11.143]   - Field: ‘earlySignal’
[17:48:11.143]   - Field: ‘lazy’
[17:48:11.143]   - Field: ‘state’
[17:48:11.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.143] - Launch lazy future ...
[17:48:11.144] Packages needed by the future expression (n = 0): <none>
[17:48:11.144] Packages needed by future strategies (n = 0): <none>
[17:48:11.144] {
[17:48:11.144]     {
[17:48:11.144]         {
[17:48:11.144]             ...future.startTime <- base::Sys.time()
[17:48:11.144]             {
[17:48:11.144]                 {
[17:48:11.144]                   {
[17:48:11.144]                     {
[17:48:11.144]                       base::local({
[17:48:11.144]                         has_future <- base::requireNamespace("future", 
[17:48:11.144]                           quietly = TRUE)
[17:48:11.144]                         if (has_future) {
[17:48:11.144]                           ns <- base::getNamespace("future")
[17:48:11.144]                           version <- ns[[".package"]][["version"]]
[17:48:11.144]                           if (is.null(version)) 
[17:48:11.144]                             version <- utils::packageVersion("future")
[17:48:11.144]                         }
[17:48:11.144]                         else {
[17:48:11.144]                           version <- NULL
[17:48:11.144]                         }
[17:48:11.144]                         if (!has_future || version < "1.8.0") {
[17:48:11.144]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.144]                             "", base::R.version$version.string), 
[17:48:11.144]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.144]                               "release", "version")], collapse = " "), 
[17:48:11.144]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.144]                             info)
[17:48:11.144]                           info <- base::paste(info, collapse = "; ")
[17:48:11.144]                           if (!has_future) {
[17:48:11.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.144]                               info)
[17:48:11.144]                           }
[17:48:11.144]                           else {
[17:48:11.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.144]                               info, version)
[17:48:11.144]                           }
[17:48:11.144]                           base::stop(msg)
[17:48:11.144]                         }
[17:48:11.144]                       })
[17:48:11.144]                     }
[17:48:11.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.144]                     base::options(mc.cores = 1L)
[17:48:11.144]                   }
[17:48:11.144]                   ...future.strategy.old <- future::plan("list")
[17:48:11.144]                   options(future.plan = NULL)
[17:48:11.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.144]                 }
[17:48:11.144]                 ...future.workdir <- getwd()
[17:48:11.144]             }
[17:48:11.144]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.144]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.144]         }
[17:48:11.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.144]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.144]             base::names(...future.oldOptions))
[17:48:11.144]     }
[17:48:11.144]     if (FALSE) {
[17:48:11.144]     }
[17:48:11.144]     else {
[17:48:11.144]         if (TRUE) {
[17:48:11.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.144]                 open = "w")
[17:48:11.144]         }
[17:48:11.144]         else {
[17:48:11.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.144]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.144]         }
[17:48:11.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.144]             base::sink(type = "output", split = FALSE)
[17:48:11.144]             base::close(...future.stdout)
[17:48:11.144]         }, add = TRUE)
[17:48:11.144]     }
[17:48:11.144]     ...future.frame <- base::sys.nframe()
[17:48:11.144]     ...future.conditions <- base::list()
[17:48:11.144]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.144]     if (FALSE) {
[17:48:11.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.144]     }
[17:48:11.144]     ...future.result <- base::tryCatch({
[17:48:11.144]         base::withCallingHandlers({
[17:48:11.144]             ...future.value <- base::withVisible(base::local({
[17:48:11.144]                 ...future.makeSendCondition <- base::local({
[17:48:11.144]                   sendCondition <- NULL
[17:48:11.144]                   function(frame = 1L) {
[17:48:11.144]                     if (is.function(sendCondition)) 
[17:48:11.144]                       return(sendCondition)
[17:48:11.144]                     ns <- getNamespace("parallel")
[17:48:11.144]                     if (exists("sendData", mode = "function", 
[17:48:11.144]                       envir = ns)) {
[17:48:11.144]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.144]                         envir = ns)
[17:48:11.144]                       envir <- sys.frame(frame)
[17:48:11.144]                       master <- NULL
[17:48:11.144]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.144]                         !identical(envir, emptyenv())) {
[17:48:11.144]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.144]                           inherits = FALSE)) {
[17:48:11.144]                           master <- get("master", mode = "list", 
[17:48:11.144]                             envir = envir, inherits = FALSE)
[17:48:11.144]                           if (inherits(master, c("SOCKnode", 
[17:48:11.144]                             "SOCK0node"))) {
[17:48:11.144]                             sendCondition <<- function(cond) {
[17:48:11.144]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.144]                                 success = TRUE)
[17:48:11.144]                               parallel_sendData(master, data)
[17:48:11.144]                             }
[17:48:11.144]                             return(sendCondition)
[17:48:11.144]                           }
[17:48:11.144]                         }
[17:48:11.144]                         frame <- frame + 1L
[17:48:11.144]                         envir <- sys.frame(frame)
[17:48:11.144]                       }
[17:48:11.144]                     }
[17:48:11.144]                     sendCondition <<- function(cond) NULL
[17:48:11.144]                   }
[17:48:11.144]                 })
[17:48:11.144]                 withCallingHandlers({
[17:48:11.144]                   {
[17:48:11.144]                     Sys.sleep(0.1)
[17:48:11.144]                     kk
[17:48:11.144]                   }
[17:48:11.144]                 }, immediateCondition = function(cond) {
[17:48:11.144]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.144]                   sendCondition(cond)
[17:48:11.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.144]                   {
[17:48:11.144]                     inherits <- base::inherits
[17:48:11.144]                     invokeRestart <- base::invokeRestart
[17:48:11.144]                     is.null <- base::is.null
[17:48:11.144]                     muffled <- FALSE
[17:48:11.144]                     if (inherits(cond, "message")) {
[17:48:11.144]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.144]                       if (muffled) 
[17:48:11.144]                         invokeRestart("muffleMessage")
[17:48:11.144]                     }
[17:48:11.144]                     else if (inherits(cond, "warning")) {
[17:48:11.144]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.144]                       if (muffled) 
[17:48:11.144]                         invokeRestart("muffleWarning")
[17:48:11.144]                     }
[17:48:11.144]                     else if (inherits(cond, "condition")) {
[17:48:11.144]                       if (!is.null(pattern)) {
[17:48:11.144]                         computeRestarts <- base::computeRestarts
[17:48:11.144]                         grepl <- base::grepl
[17:48:11.144]                         restarts <- computeRestarts(cond)
[17:48:11.144]                         for (restart in restarts) {
[17:48:11.144]                           name <- restart$name
[17:48:11.144]                           if (is.null(name)) 
[17:48:11.144]                             next
[17:48:11.144]                           if (!grepl(pattern, name)) 
[17:48:11.144]                             next
[17:48:11.144]                           invokeRestart(restart)
[17:48:11.144]                           muffled <- TRUE
[17:48:11.144]                           break
[17:48:11.144]                         }
[17:48:11.144]                       }
[17:48:11.144]                     }
[17:48:11.144]                     invisible(muffled)
[17:48:11.144]                   }
[17:48:11.144]                   muffleCondition(cond)
[17:48:11.144]                 })
[17:48:11.144]             }))
[17:48:11.144]             future::FutureResult(value = ...future.value$value, 
[17:48:11.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.144]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.144]                     ...future.globalenv.names))
[17:48:11.144]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.144]         }, condition = base::local({
[17:48:11.144]             c <- base::c
[17:48:11.144]             inherits <- base::inherits
[17:48:11.144]             invokeRestart <- base::invokeRestart
[17:48:11.144]             length <- base::length
[17:48:11.144]             list <- base::list
[17:48:11.144]             seq.int <- base::seq.int
[17:48:11.144]             signalCondition <- base::signalCondition
[17:48:11.144]             sys.calls <- base::sys.calls
[17:48:11.144]             `[[` <- base::`[[`
[17:48:11.144]             `+` <- base::`+`
[17:48:11.144]             `<<-` <- base::`<<-`
[17:48:11.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.144]                   3L)]
[17:48:11.144]             }
[17:48:11.144]             function(cond) {
[17:48:11.144]                 is_error <- inherits(cond, "error")
[17:48:11.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.144]                   NULL)
[17:48:11.144]                 if (is_error) {
[17:48:11.144]                   sessionInformation <- function() {
[17:48:11.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.144]                       search = base::search(), system = base::Sys.info())
[17:48:11.144]                   }
[17:48:11.144]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.144]                     cond$call), session = sessionInformation(), 
[17:48:11.144]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.144]                   signalCondition(cond)
[17:48:11.144]                 }
[17:48:11.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.144]                 "immediateCondition"))) {
[17:48:11.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.144]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.144]                   if (TRUE && !signal) {
[17:48:11.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.144]                     {
[17:48:11.144]                       inherits <- base::inherits
[17:48:11.144]                       invokeRestart <- base::invokeRestart
[17:48:11.144]                       is.null <- base::is.null
[17:48:11.144]                       muffled <- FALSE
[17:48:11.144]                       if (inherits(cond, "message")) {
[17:48:11.144]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.144]                         if (muffled) 
[17:48:11.144]                           invokeRestart("muffleMessage")
[17:48:11.144]                       }
[17:48:11.144]                       else if (inherits(cond, "warning")) {
[17:48:11.144]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.144]                         if (muffled) 
[17:48:11.144]                           invokeRestart("muffleWarning")
[17:48:11.144]                       }
[17:48:11.144]                       else if (inherits(cond, "condition")) {
[17:48:11.144]                         if (!is.null(pattern)) {
[17:48:11.144]                           computeRestarts <- base::computeRestarts
[17:48:11.144]                           grepl <- base::grepl
[17:48:11.144]                           restarts <- computeRestarts(cond)
[17:48:11.144]                           for (restart in restarts) {
[17:48:11.144]                             name <- restart$name
[17:48:11.144]                             if (is.null(name)) 
[17:48:11.144]                               next
[17:48:11.144]                             if (!grepl(pattern, name)) 
[17:48:11.144]                               next
[17:48:11.144]                             invokeRestart(restart)
[17:48:11.144]                             muffled <- TRUE
[17:48:11.144]                             break
[17:48:11.144]                           }
[17:48:11.144]                         }
[17:48:11.144]                       }
[17:48:11.144]                       invisible(muffled)
[17:48:11.144]                     }
[17:48:11.144]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.144]                   }
[17:48:11.144]                 }
[17:48:11.144]                 else {
[17:48:11.144]                   if (TRUE) {
[17:48:11.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.144]                     {
[17:48:11.144]                       inherits <- base::inherits
[17:48:11.144]                       invokeRestart <- base::invokeRestart
[17:48:11.144]                       is.null <- base::is.null
[17:48:11.144]                       muffled <- FALSE
[17:48:11.144]                       if (inherits(cond, "message")) {
[17:48:11.144]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.144]                         if (muffled) 
[17:48:11.144]                           invokeRestart("muffleMessage")
[17:48:11.144]                       }
[17:48:11.144]                       else if (inherits(cond, "warning")) {
[17:48:11.144]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.144]                         if (muffled) 
[17:48:11.144]                           invokeRestart("muffleWarning")
[17:48:11.144]                       }
[17:48:11.144]                       else if (inherits(cond, "condition")) {
[17:48:11.144]                         if (!is.null(pattern)) {
[17:48:11.144]                           computeRestarts <- base::computeRestarts
[17:48:11.144]                           grepl <- base::grepl
[17:48:11.144]                           restarts <- computeRestarts(cond)
[17:48:11.144]                           for (restart in restarts) {
[17:48:11.144]                             name <- restart$name
[17:48:11.144]                             if (is.null(name)) 
[17:48:11.144]                               next
[17:48:11.144]                             if (!grepl(pattern, name)) 
[17:48:11.144]                               next
[17:48:11.144]                             invokeRestart(restart)
[17:48:11.144]                             muffled <- TRUE
[17:48:11.144]                             break
[17:48:11.144]                           }
[17:48:11.144]                         }
[17:48:11.144]                       }
[17:48:11.144]                       invisible(muffled)
[17:48:11.144]                     }
[17:48:11.144]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.144]                   }
[17:48:11.144]                 }
[17:48:11.144]             }
[17:48:11.144]         }))
[17:48:11.144]     }, error = function(ex) {
[17:48:11.144]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.144]                 ...future.rng), started = ...future.startTime, 
[17:48:11.144]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.144]             version = "1.8"), class = "FutureResult")
[17:48:11.144]     }, finally = {
[17:48:11.144]         if (!identical(...future.workdir, getwd())) 
[17:48:11.144]             setwd(...future.workdir)
[17:48:11.144]         {
[17:48:11.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.144]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.144]             }
[17:48:11.144]             base::options(...future.oldOptions)
[17:48:11.144]             if (.Platform$OS.type == "windows") {
[17:48:11.144]                 old_names <- names(...future.oldEnvVars)
[17:48:11.144]                 envs <- base::Sys.getenv()
[17:48:11.144]                 names <- names(envs)
[17:48:11.144]                 common <- intersect(names, old_names)
[17:48:11.144]                 added <- setdiff(names, old_names)
[17:48:11.144]                 removed <- setdiff(old_names, names)
[17:48:11.144]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.144]                   envs[common]]
[17:48:11.144]                 NAMES <- toupper(changed)
[17:48:11.144]                 args <- list()
[17:48:11.144]                 for (kk in seq_along(NAMES)) {
[17:48:11.144]                   name <- changed[[kk]]
[17:48:11.144]                   NAME <- NAMES[[kk]]
[17:48:11.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.144]                     next
[17:48:11.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.144]                 }
[17:48:11.144]                 NAMES <- toupper(added)
[17:48:11.144]                 for (kk in seq_along(NAMES)) {
[17:48:11.144]                   name <- added[[kk]]
[17:48:11.144]                   NAME <- NAMES[[kk]]
[17:48:11.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.144]                     next
[17:48:11.144]                   args[[name]] <- ""
[17:48:11.144]                 }
[17:48:11.144]                 NAMES <- toupper(removed)
[17:48:11.144]                 for (kk in seq_along(NAMES)) {
[17:48:11.144]                   name <- removed[[kk]]
[17:48:11.144]                   NAME <- NAMES[[kk]]
[17:48:11.144]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.144]                     next
[17:48:11.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.144]                 }
[17:48:11.144]                 if (length(args) > 0) 
[17:48:11.144]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.144]             }
[17:48:11.144]             else {
[17:48:11.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.144]             }
[17:48:11.144]             {
[17:48:11.144]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.144]                   0L) {
[17:48:11.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.144]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.144]                   base::options(opts)
[17:48:11.144]                 }
[17:48:11.144]                 {
[17:48:11.144]                   {
[17:48:11.144]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.144]                     NULL
[17:48:11.144]                   }
[17:48:11.144]                   options(future.plan = NULL)
[17:48:11.144]                   if (is.na(NA_character_)) 
[17:48:11.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.144]                     .init = FALSE)
[17:48:11.144]                 }
[17:48:11.144]             }
[17:48:11.144]         }
[17:48:11.144]     })
[17:48:11.144]     if (TRUE) {
[17:48:11.144]         base::sink(type = "output", split = FALSE)
[17:48:11.144]         if (TRUE) {
[17:48:11.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.144]         }
[17:48:11.144]         else {
[17:48:11.144]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.144]         }
[17:48:11.144]         base::close(...future.stdout)
[17:48:11.144]         ...future.stdout <- NULL
[17:48:11.144]     }
[17:48:11.144]     ...future.result$conditions <- ...future.conditions
[17:48:11.144]     ...future.result$finished <- base::Sys.time()
[17:48:11.144]     ...future.result
[17:48:11.144] }
[17:48:11.147] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:48:11.147] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:48:11.147] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:48:11.147] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:48:11.148] MultisessionFuture started
[17:48:11.148] - Launch lazy future ... done
[17:48:11.148] run() for ‘MultisessionFuture’ ... done
[17:48:11.159] run() for ‘Future’ ...
[17:48:11.159] - state: ‘created’
[17:48:11.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.173] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.173]   - Field: ‘node’
[17:48:11.173]   - Field: ‘label’
[17:48:11.173]   - Field: ‘local’
[17:48:11.173]   - Field: ‘owner’
[17:48:11.173]   - Field: ‘envir’
[17:48:11.173]   - Field: ‘workers’
[17:48:11.173]   - Field: ‘packages’
[17:48:11.173]   - Field: ‘gc’
[17:48:11.174]   - Field: ‘conditions’
[17:48:11.174]   - Field: ‘persistent’
[17:48:11.174]   - Field: ‘expr’
[17:48:11.174]   - Field: ‘uuid’
[17:48:11.174]   - Field: ‘seed’
[17:48:11.174]   - Field: ‘version’
[17:48:11.174]   - Field: ‘result’
[17:48:11.174]   - Field: ‘asynchronous’
[17:48:11.174]   - Field: ‘calls’
[17:48:11.174]   - Field: ‘globals’
[17:48:11.174]   - Field: ‘stdout’
[17:48:11.175]   - Field: ‘earlySignal’
[17:48:11.175]   - Field: ‘lazy’
[17:48:11.175]   - Field: ‘state’
[17:48:11.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.175] - Launch lazy future ...
[17:48:11.175] Packages needed by the future expression (n = 0): <none>
[17:48:11.175] Packages needed by future strategies (n = 0): <none>
[17:48:11.176] {
[17:48:11.176]     {
[17:48:11.176]         {
[17:48:11.176]             ...future.startTime <- base::Sys.time()
[17:48:11.176]             {
[17:48:11.176]                 {
[17:48:11.176]                   {
[17:48:11.176]                     {
[17:48:11.176]                       base::local({
[17:48:11.176]                         has_future <- base::requireNamespace("future", 
[17:48:11.176]                           quietly = TRUE)
[17:48:11.176]                         if (has_future) {
[17:48:11.176]                           ns <- base::getNamespace("future")
[17:48:11.176]                           version <- ns[[".package"]][["version"]]
[17:48:11.176]                           if (is.null(version)) 
[17:48:11.176]                             version <- utils::packageVersion("future")
[17:48:11.176]                         }
[17:48:11.176]                         else {
[17:48:11.176]                           version <- NULL
[17:48:11.176]                         }
[17:48:11.176]                         if (!has_future || version < "1.8.0") {
[17:48:11.176]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.176]                             "", base::R.version$version.string), 
[17:48:11.176]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.176]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.176]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.176]                               "release", "version")], collapse = " "), 
[17:48:11.176]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.176]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.176]                             info)
[17:48:11.176]                           info <- base::paste(info, collapse = "; ")
[17:48:11.176]                           if (!has_future) {
[17:48:11.176]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.176]                               info)
[17:48:11.176]                           }
[17:48:11.176]                           else {
[17:48:11.176]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.176]                               info, version)
[17:48:11.176]                           }
[17:48:11.176]                           base::stop(msg)
[17:48:11.176]                         }
[17:48:11.176]                       })
[17:48:11.176]                     }
[17:48:11.176]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.176]                     base::options(mc.cores = 1L)
[17:48:11.176]                   }
[17:48:11.176]                   ...future.strategy.old <- future::plan("list")
[17:48:11.176]                   options(future.plan = NULL)
[17:48:11.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.176]                 }
[17:48:11.176]                 ...future.workdir <- getwd()
[17:48:11.176]             }
[17:48:11.176]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.176]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.176]         }
[17:48:11.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.176]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.176]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.176]             base::names(...future.oldOptions))
[17:48:11.176]     }
[17:48:11.176]     if (FALSE) {
[17:48:11.176]     }
[17:48:11.176]     else {
[17:48:11.176]         if (TRUE) {
[17:48:11.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.176]                 open = "w")
[17:48:11.176]         }
[17:48:11.176]         else {
[17:48:11.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.176]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.176]         }
[17:48:11.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.176]             base::sink(type = "output", split = FALSE)
[17:48:11.176]             base::close(...future.stdout)
[17:48:11.176]         }, add = TRUE)
[17:48:11.176]     }
[17:48:11.176]     ...future.frame <- base::sys.nframe()
[17:48:11.176]     ...future.conditions <- base::list()
[17:48:11.176]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.176]     if (FALSE) {
[17:48:11.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.176]     }
[17:48:11.176]     ...future.result <- base::tryCatch({
[17:48:11.176]         base::withCallingHandlers({
[17:48:11.176]             ...future.value <- base::withVisible(base::local({
[17:48:11.176]                 ...future.makeSendCondition <- base::local({
[17:48:11.176]                   sendCondition <- NULL
[17:48:11.176]                   function(frame = 1L) {
[17:48:11.176]                     if (is.function(sendCondition)) 
[17:48:11.176]                       return(sendCondition)
[17:48:11.176]                     ns <- getNamespace("parallel")
[17:48:11.176]                     if (exists("sendData", mode = "function", 
[17:48:11.176]                       envir = ns)) {
[17:48:11.176]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.176]                         envir = ns)
[17:48:11.176]                       envir <- sys.frame(frame)
[17:48:11.176]                       master <- NULL
[17:48:11.176]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.176]                         !identical(envir, emptyenv())) {
[17:48:11.176]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.176]                           inherits = FALSE)) {
[17:48:11.176]                           master <- get("master", mode = "list", 
[17:48:11.176]                             envir = envir, inherits = FALSE)
[17:48:11.176]                           if (inherits(master, c("SOCKnode", 
[17:48:11.176]                             "SOCK0node"))) {
[17:48:11.176]                             sendCondition <<- function(cond) {
[17:48:11.176]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.176]                                 success = TRUE)
[17:48:11.176]                               parallel_sendData(master, data)
[17:48:11.176]                             }
[17:48:11.176]                             return(sendCondition)
[17:48:11.176]                           }
[17:48:11.176]                         }
[17:48:11.176]                         frame <- frame + 1L
[17:48:11.176]                         envir <- sys.frame(frame)
[17:48:11.176]                       }
[17:48:11.176]                     }
[17:48:11.176]                     sendCondition <<- function(cond) NULL
[17:48:11.176]                   }
[17:48:11.176]                 })
[17:48:11.176]                 withCallingHandlers({
[17:48:11.176]                   {
[17:48:11.176]                     Sys.sleep(0.1)
[17:48:11.176]                     kk
[17:48:11.176]                   }
[17:48:11.176]                 }, immediateCondition = function(cond) {
[17:48:11.176]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.176]                   sendCondition(cond)
[17:48:11.176]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.176]                   {
[17:48:11.176]                     inherits <- base::inherits
[17:48:11.176]                     invokeRestart <- base::invokeRestart
[17:48:11.176]                     is.null <- base::is.null
[17:48:11.176]                     muffled <- FALSE
[17:48:11.176]                     if (inherits(cond, "message")) {
[17:48:11.176]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.176]                       if (muffled) 
[17:48:11.176]                         invokeRestart("muffleMessage")
[17:48:11.176]                     }
[17:48:11.176]                     else if (inherits(cond, "warning")) {
[17:48:11.176]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.176]                       if (muffled) 
[17:48:11.176]                         invokeRestart("muffleWarning")
[17:48:11.176]                     }
[17:48:11.176]                     else if (inherits(cond, "condition")) {
[17:48:11.176]                       if (!is.null(pattern)) {
[17:48:11.176]                         computeRestarts <- base::computeRestarts
[17:48:11.176]                         grepl <- base::grepl
[17:48:11.176]                         restarts <- computeRestarts(cond)
[17:48:11.176]                         for (restart in restarts) {
[17:48:11.176]                           name <- restart$name
[17:48:11.176]                           if (is.null(name)) 
[17:48:11.176]                             next
[17:48:11.176]                           if (!grepl(pattern, name)) 
[17:48:11.176]                             next
[17:48:11.176]                           invokeRestart(restart)
[17:48:11.176]                           muffled <- TRUE
[17:48:11.176]                           break
[17:48:11.176]                         }
[17:48:11.176]                       }
[17:48:11.176]                     }
[17:48:11.176]                     invisible(muffled)
[17:48:11.176]                   }
[17:48:11.176]                   muffleCondition(cond)
[17:48:11.176]                 })
[17:48:11.176]             }))
[17:48:11.176]             future::FutureResult(value = ...future.value$value, 
[17:48:11.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.176]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.176]                     ...future.globalenv.names))
[17:48:11.176]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.176]         }, condition = base::local({
[17:48:11.176]             c <- base::c
[17:48:11.176]             inherits <- base::inherits
[17:48:11.176]             invokeRestart <- base::invokeRestart
[17:48:11.176]             length <- base::length
[17:48:11.176]             list <- base::list
[17:48:11.176]             seq.int <- base::seq.int
[17:48:11.176]             signalCondition <- base::signalCondition
[17:48:11.176]             sys.calls <- base::sys.calls
[17:48:11.176]             `[[` <- base::`[[`
[17:48:11.176]             `+` <- base::`+`
[17:48:11.176]             `<<-` <- base::`<<-`
[17:48:11.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.176]                   3L)]
[17:48:11.176]             }
[17:48:11.176]             function(cond) {
[17:48:11.176]                 is_error <- inherits(cond, "error")
[17:48:11.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.176]                   NULL)
[17:48:11.176]                 if (is_error) {
[17:48:11.176]                   sessionInformation <- function() {
[17:48:11.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.176]                       search = base::search(), system = base::Sys.info())
[17:48:11.176]                   }
[17:48:11.176]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.176]                     cond$call), session = sessionInformation(), 
[17:48:11.176]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.176]                   signalCondition(cond)
[17:48:11.176]                 }
[17:48:11.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.176]                 "immediateCondition"))) {
[17:48:11.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.176]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.176]                   if (TRUE && !signal) {
[17:48:11.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.176]                     {
[17:48:11.176]                       inherits <- base::inherits
[17:48:11.176]                       invokeRestart <- base::invokeRestart
[17:48:11.176]                       is.null <- base::is.null
[17:48:11.176]                       muffled <- FALSE
[17:48:11.176]                       if (inherits(cond, "message")) {
[17:48:11.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.176]                         if (muffled) 
[17:48:11.176]                           invokeRestart("muffleMessage")
[17:48:11.176]                       }
[17:48:11.176]                       else if (inherits(cond, "warning")) {
[17:48:11.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.176]                         if (muffled) 
[17:48:11.176]                           invokeRestart("muffleWarning")
[17:48:11.176]                       }
[17:48:11.176]                       else if (inherits(cond, "condition")) {
[17:48:11.176]                         if (!is.null(pattern)) {
[17:48:11.176]                           computeRestarts <- base::computeRestarts
[17:48:11.176]                           grepl <- base::grepl
[17:48:11.176]                           restarts <- computeRestarts(cond)
[17:48:11.176]                           for (restart in restarts) {
[17:48:11.176]                             name <- restart$name
[17:48:11.176]                             if (is.null(name)) 
[17:48:11.176]                               next
[17:48:11.176]                             if (!grepl(pattern, name)) 
[17:48:11.176]                               next
[17:48:11.176]                             invokeRestart(restart)
[17:48:11.176]                             muffled <- TRUE
[17:48:11.176]                             break
[17:48:11.176]                           }
[17:48:11.176]                         }
[17:48:11.176]                       }
[17:48:11.176]                       invisible(muffled)
[17:48:11.176]                     }
[17:48:11.176]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.176]                   }
[17:48:11.176]                 }
[17:48:11.176]                 else {
[17:48:11.176]                   if (TRUE) {
[17:48:11.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.176]                     {
[17:48:11.176]                       inherits <- base::inherits
[17:48:11.176]                       invokeRestart <- base::invokeRestart
[17:48:11.176]                       is.null <- base::is.null
[17:48:11.176]                       muffled <- FALSE
[17:48:11.176]                       if (inherits(cond, "message")) {
[17:48:11.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.176]                         if (muffled) 
[17:48:11.176]                           invokeRestart("muffleMessage")
[17:48:11.176]                       }
[17:48:11.176]                       else if (inherits(cond, "warning")) {
[17:48:11.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.176]                         if (muffled) 
[17:48:11.176]                           invokeRestart("muffleWarning")
[17:48:11.176]                       }
[17:48:11.176]                       else if (inherits(cond, "condition")) {
[17:48:11.176]                         if (!is.null(pattern)) {
[17:48:11.176]                           computeRestarts <- base::computeRestarts
[17:48:11.176]                           grepl <- base::grepl
[17:48:11.176]                           restarts <- computeRestarts(cond)
[17:48:11.176]                           for (restart in restarts) {
[17:48:11.176]                             name <- restart$name
[17:48:11.176]                             if (is.null(name)) 
[17:48:11.176]                               next
[17:48:11.176]                             if (!grepl(pattern, name)) 
[17:48:11.176]                               next
[17:48:11.176]                             invokeRestart(restart)
[17:48:11.176]                             muffled <- TRUE
[17:48:11.176]                             break
[17:48:11.176]                           }
[17:48:11.176]                         }
[17:48:11.176]                       }
[17:48:11.176]                       invisible(muffled)
[17:48:11.176]                     }
[17:48:11.176]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.176]                   }
[17:48:11.176]                 }
[17:48:11.176]             }
[17:48:11.176]         }))
[17:48:11.176]     }, error = function(ex) {
[17:48:11.176]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.176]                 ...future.rng), started = ...future.startTime, 
[17:48:11.176]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.176]             version = "1.8"), class = "FutureResult")
[17:48:11.176]     }, finally = {
[17:48:11.176]         if (!identical(...future.workdir, getwd())) 
[17:48:11.176]             setwd(...future.workdir)
[17:48:11.176]         {
[17:48:11.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.176]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.176]             }
[17:48:11.176]             base::options(...future.oldOptions)
[17:48:11.176]             if (.Platform$OS.type == "windows") {
[17:48:11.176]                 old_names <- names(...future.oldEnvVars)
[17:48:11.176]                 envs <- base::Sys.getenv()
[17:48:11.176]                 names <- names(envs)
[17:48:11.176]                 common <- intersect(names, old_names)
[17:48:11.176]                 added <- setdiff(names, old_names)
[17:48:11.176]                 removed <- setdiff(old_names, names)
[17:48:11.176]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.176]                   envs[common]]
[17:48:11.176]                 NAMES <- toupper(changed)
[17:48:11.176]                 args <- list()
[17:48:11.176]                 for (kk in seq_along(NAMES)) {
[17:48:11.176]                   name <- changed[[kk]]
[17:48:11.176]                   NAME <- NAMES[[kk]]
[17:48:11.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.176]                     next
[17:48:11.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.176]                 }
[17:48:11.176]                 NAMES <- toupper(added)
[17:48:11.176]                 for (kk in seq_along(NAMES)) {
[17:48:11.176]                   name <- added[[kk]]
[17:48:11.176]                   NAME <- NAMES[[kk]]
[17:48:11.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.176]                     next
[17:48:11.176]                   args[[name]] <- ""
[17:48:11.176]                 }
[17:48:11.176]                 NAMES <- toupper(removed)
[17:48:11.176]                 for (kk in seq_along(NAMES)) {
[17:48:11.176]                   name <- removed[[kk]]
[17:48:11.176]                   NAME <- NAMES[[kk]]
[17:48:11.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.176]                     next
[17:48:11.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.176]                 }
[17:48:11.176]                 if (length(args) > 0) 
[17:48:11.176]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.176]             }
[17:48:11.176]             else {
[17:48:11.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.176]             }
[17:48:11.176]             {
[17:48:11.176]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.176]                   0L) {
[17:48:11.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.176]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.176]                   base::options(opts)
[17:48:11.176]                 }
[17:48:11.176]                 {
[17:48:11.176]                   {
[17:48:11.176]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.176]                     NULL
[17:48:11.176]                   }
[17:48:11.176]                   options(future.plan = NULL)
[17:48:11.176]                   if (is.na(NA_character_)) 
[17:48:11.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.176]                     .init = FALSE)
[17:48:11.176]                 }
[17:48:11.176]             }
[17:48:11.176]         }
[17:48:11.176]     })
[17:48:11.176]     if (TRUE) {
[17:48:11.176]         base::sink(type = "output", split = FALSE)
[17:48:11.176]         if (TRUE) {
[17:48:11.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.176]         }
[17:48:11.176]         else {
[17:48:11.176]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.176]         }
[17:48:11.176]         base::close(...future.stdout)
[17:48:11.176]         ...future.stdout <- NULL
[17:48:11.176]     }
[17:48:11.176]     ...future.result$conditions <- ...future.conditions
[17:48:11.176]     ...future.result$finished <- base::Sys.time()
[17:48:11.176]     ...future.result
[17:48:11.176] }
[17:48:11.178] Poll #1 (0): usedNodes() = 2, workers = 2
[17:48:11.209] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:48:11.220] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.220] - Validating connection of MultisessionFuture
[17:48:11.220] - received message: FutureResult
[17:48:11.220] - Received FutureResult
[17:48:11.220] - Erased future from FutureRegistry
[17:48:11.220] result() for ClusterFuture ...
[17:48:11.220] - result already collected: FutureResult
[17:48:11.221] result() for ClusterFuture ... done
[17:48:11.221] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.221] result() for ClusterFuture ...
[17:48:11.221] - result already collected: FutureResult
[17:48:11.221] result() for ClusterFuture ... done
[17:48:11.221] result() for ClusterFuture ...
[17:48:11.221] - result already collected: FutureResult
[17:48:11.221] result() for ClusterFuture ... done
[17:48:11.222] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:48:11.222] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:48:11.222] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:48:11.222] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:48:11.223] MultisessionFuture started
[17:48:11.223] - Launch lazy future ... done
[17:48:11.223] run() for ‘MultisessionFuture’ ... done
[17:48:11.244] Future #1
[17:48:11.244]  length: 2 (resolved future 1)
[17:48:11.250] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.250] - Validating connection of MultisessionFuture
[17:48:11.250] - received message: FutureResult
[17:48:11.250] - Received FutureResult
[17:48:11.250] - Erased future from FutureRegistry
[17:48:11.251] result() for ClusterFuture ...
[17:48:11.251] - result already collected: FutureResult
[17:48:11.251] result() for ClusterFuture ... done
[17:48:11.251] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.251] Future #2
[17:48:11.251]  length: 1 (resolved future 2)
[17:48:11.333] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.334] - Validating connection of MultisessionFuture
[17:48:11.334] - received message: FutureResult
[17:48:11.334] - Received FutureResult
[17:48:11.334] - Erased future from FutureRegistry
[17:48:11.334] result() for ClusterFuture ...
[17:48:11.334] - result already collected: FutureResult
[17:48:11.334] result() for ClusterFuture ... done
[17:48:11.334] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.335] Future #3
[17:48:11.335]  length: 0 (resolved future 3)
[17:48:11.335] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:48:11.335] resolve() on environment ...
[17:48:11.335]  recursive: 0
[17:48:11.336]  elements: [2] ‘a’, ‘b’
[17:48:11.336]  length: 1 (resolved future 1)
[17:48:11.336]  length: 0 (resolved future 2)
[17:48:11.336] resolve() on environment ... DONE
[17:48:11.337] getGlobalsAndPackages() ...
[17:48:11.337] Searching for globals...
[17:48:11.337] 
[17:48:11.337] Searching for globals ... DONE
[17:48:11.337] - globals: [0] <none>
[17:48:11.337] getGlobalsAndPackages() ... DONE
[17:48:11.338] run() for ‘Future’ ...
[17:48:11.338] - state: ‘created’
[17:48:11.338] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.352] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.352]   - Field: ‘node’
[17:48:11.352]   - Field: ‘label’
[17:48:11.352]   - Field: ‘local’
[17:48:11.352]   - Field: ‘owner’
[17:48:11.352]   - Field: ‘envir’
[17:48:11.352]   - Field: ‘workers’
[17:48:11.352]   - Field: ‘packages’
[17:48:11.352]   - Field: ‘gc’
[17:48:11.353]   - Field: ‘conditions’
[17:48:11.353]   - Field: ‘persistent’
[17:48:11.353]   - Field: ‘expr’
[17:48:11.353]   - Field: ‘uuid’
[17:48:11.353]   - Field: ‘seed’
[17:48:11.353]   - Field: ‘version’
[17:48:11.353]   - Field: ‘result’
[17:48:11.353]   - Field: ‘asynchronous’
[17:48:11.353]   - Field: ‘calls’
[17:48:11.353]   - Field: ‘globals’
[17:48:11.353]   - Field: ‘stdout’
[17:48:11.354]   - Field: ‘earlySignal’
[17:48:11.354]   - Field: ‘lazy’
[17:48:11.354]   - Field: ‘state’
[17:48:11.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.354] - Launch lazy future ...
[17:48:11.354] Packages needed by the future expression (n = 0): <none>
[17:48:11.354] Packages needed by future strategies (n = 0): <none>
[17:48:11.355] {
[17:48:11.355]     {
[17:48:11.355]         {
[17:48:11.355]             ...future.startTime <- base::Sys.time()
[17:48:11.355]             {
[17:48:11.355]                 {
[17:48:11.355]                   {
[17:48:11.355]                     {
[17:48:11.355]                       base::local({
[17:48:11.355]                         has_future <- base::requireNamespace("future", 
[17:48:11.355]                           quietly = TRUE)
[17:48:11.355]                         if (has_future) {
[17:48:11.355]                           ns <- base::getNamespace("future")
[17:48:11.355]                           version <- ns[[".package"]][["version"]]
[17:48:11.355]                           if (is.null(version)) 
[17:48:11.355]                             version <- utils::packageVersion("future")
[17:48:11.355]                         }
[17:48:11.355]                         else {
[17:48:11.355]                           version <- NULL
[17:48:11.355]                         }
[17:48:11.355]                         if (!has_future || version < "1.8.0") {
[17:48:11.355]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.355]                             "", base::R.version$version.string), 
[17:48:11.355]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.355]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.355]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.355]                               "release", "version")], collapse = " "), 
[17:48:11.355]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.355]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.355]                             info)
[17:48:11.355]                           info <- base::paste(info, collapse = "; ")
[17:48:11.355]                           if (!has_future) {
[17:48:11.355]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.355]                               info)
[17:48:11.355]                           }
[17:48:11.355]                           else {
[17:48:11.355]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.355]                               info, version)
[17:48:11.355]                           }
[17:48:11.355]                           base::stop(msg)
[17:48:11.355]                         }
[17:48:11.355]                       })
[17:48:11.355]                     }
[17:48:11.355]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.355]                     base::options(mc.cores = 1L)
[17:48:11.355]                   }
[17:48:11.355]                   ...future.strategy.old <- future::plan("list")
[17:48:11.355]                   options(future.plan = NULL)
[17:48:11.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.355]                 }
[17:48:11.355]                 ...future.workdir <- getwd()
[17:48:11.355]             }
[17:48:11.355]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.355]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.355]         }
[17:48:11.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.355]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.355]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.355]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.355]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.355]             base::names(...future.oldOptions))
[17:48:11.355]     }
[17:48:11.355]     if (FALSE) {
[17:48:11.355]     }
[17:48:11.355]     else {
[17:48:11.355]         if (TRUE) {
[17:48:11.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.355]                 open = "w")
[17:48:11.355]         }
[17:48:11.355]         else {
[17:48:11.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.355]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.355]         }
[17:48:11.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.355]             base::sink(type = "output", split = FALSE)
[17:48:11.355]             base::close(...future.stdout)
[17:48:11.355]         }, add = TRUE)
[17:48:11.355]     }
[17:48:11.355]     ...future.frame <- base::sys.nframe()
[17:48:11.355]     ...future.conditions <- base::list()
[17:48:11.355]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.355]     if (FALSE) {
[17:48:11.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.355]     }
[17:48:11.355]     ...future.result <- base::tryCatch({
[17:48:11.355]         base::withCallingHandlers({
[17:48:11.355]             ...future.value <- base::withVisible(base::local({
[17:48:11.355]                 ...future.makeSendCondition <- base::local({
[17:48:11.355]                   sendCondition <- NULL
[17:48:11.355]                   function(frame = 1L) {
[17:48:11.355]                     if (is.function(sendCondition)) 
[17:48:11.355]                       return(sendCondition)
[17:48:11.355]                     ns <- getNamespace("parallel")
[17:48:11.355]                     if (exists("sendData", mode = "function", 
[17:48:11.355]                       envir = ns)) {
[17:48:11.355]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.355]                         envir = ns)
[17:48:11.355]                       envir <- sys.frame(frame)
[17:48:11.355]                       master <- NULL
[17:48:11.355]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.355]                         !identical(envir, emptyenv())) {
[17:48:11.355]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.355]                           inherits = FALSE)) {
[17:48:11.355]                           master <- get("master", mode = "list", 
[17:48:11.355]                             envir = envir, inherits = FALSE)
[17:48:11.355]                           if (inherits(master, c("SOCKnode", 
[17:48:11.355]                             "SOCK0node"))) {
[17:48:11.355]                             sendCondition <<- function(cond) {
[17:48:11.355]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.355]                                 success = TRUE)
[17:48:11.355]                               parallel_sendData(master, data)
[17:48:11.355]                             }
[17:48:11.355]                             return(sendCondition)
[17:48:11.355]                           }
[17:48:11.355]                         }
[17:48:11.355]                         frame <- frame + 1L
[17:48:11.355]                         envir <- sys.frame(frame)
[17:48:11.355]                       }
[17:48:11.355]                     }
[17:48:11.355]                     sendCondition <<- function(cond) NULL
[17:48:11.355]                   }
[17:48:11.355]                 })
[17:48:11.355]                 withCallingHandlers({
[17:48:11.355]                   1
[17:48:11.355]                 }, immediateCondition = function(cond) {
[17:48:11.355]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.355]                   sendCondition(cond)
[17:48:11.355]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.355]                   {
[17:48:11.355]                     inherits <- base::inherits
[17:48:11.355]                     invokeRestart <- base::invokeRestart
[17:48:11.355]                     is.null <- base::is.null
[17:48:11.355]                     muffled <- FALSE
[17:48:11.355]                     if (inherits(cond, "message")) {
[17:48:11.355]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.355]                       if (muffled) 
[17:48:11.355]                         invokeRestart("muffleMessage")
[17:48:11.355]                     }
[17:48:11.355]                     else if (inherits(cond, "warning")) {
[17:48:11.355]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.355]                       if (muffled) 
[17:48:11.355]                         invokeRestart("muffleWarning")
[17:48:11.355]                     }
[17:48:11.355]                     else if (inherits(cond, "condition")) {
[17:48:11.355]                       if (!is.null(pattern)) {
[17:48:11.355]                         computeRestarts <- base::computeRestarts
[17:48:11.355]                         grepl <- base::grepl
[17:48:11.355]                         restarts <- computeRestarts(cond)
[17:48:11.355]                         for (restart in restarts) {
[17:48:11.355]                           name <- restart$name
[17:48:11.355]                           if (is.null(name)) 
[17:48:11.355]                             next
[17:48:11.355]                           if (!grepl(pattern, name)) 
[17:48:11.355]                             next
[17:48:11.355]                           invokeRestart(restart)
[17:48:11.355]                           muffled <- TRUE
[17:48:11.355]                           break
[17:48:11.355]                         }
[17:48:11.355]                       }
[17:48:11.355]                     }
[17:48:11.355]                     invisible(muffled)
[17:48:11.355]                   }
[17:48:11.355]                   muffleCondition(cond)
[17:48:11.355]                 })
[17:48:11.355]             }))
[17:48:11.355]             future::FutureResult(value = ...future.value$value, 
[17:48:11.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.355]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.355]                     ...future.globalenv.names))
[17:48:11.355]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.355]         }, condition = base::local({
[17:48:11.355]             c <- base::c
[17:48:11.355]             inherits <- base::inherits
[17:48:11.355]             invokeRestart <- base::invokeRestart
[17:48:11.355]             length <- base::length
[17:48:11.355]             list <- base::list
[17:48:11.355]             seq.int <- base::seq.int
[17:48:11.355]             signalCondition <- base::signalCondition
[17:48:11.355]             sys.calls <- base::sys.calls
[17:48:11.355]             `[[` <- base::`[[`
[17:48:11.355]             `+` <- base::`+`
[17:48:11.355]             `<<-` <- base::`<<-`
[17:48:11.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.355]                   3L)]
[17:48:11.355]             }
[17:48:11.355]             function(cond) {
[17:48:11.355]                 is_error <- inherits(cond, "error")
[17:48:11.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.355]                   NULL)
[17:48:11.355]                 if (is_error) {
[17:48:11.355]                   sessionInformation <- function() {
[17:48:11.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.355]                       search = base::search(), system = base::Sys.info())
[17:48:11.355]                   }
[17:48:11.355]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.355]                     cond$call), session = sessionInformation(), 
[17:48:11.355]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.355]                   signalCondition(cond)
[17:48:11.355]                 }
[17:48:11.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.355]                 "immediateCondition"))) {
[17:48:11.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.355]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.355]                   if (TRUE && !signal) {
[17:48:11.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.355]                     {
[17:48:11.355]                       inherits <- base::inherits
[17:48:11.355]                       invokeRestart <- base::invokeRestart
[17:48:11.355]                       is.null <- base::is.null
[17:48:11.355]                       muffled <- FALSE
[17:48:11.355]                       if (inherits(cond, "message")) {
[17:48:11.355]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.355]                         if (muffled) 
[17:48:11.355]                           invokeRestart("muffleMessage")
[17:48:11.355]                       }
[17:48:11.355]                       else if (inherits(cond, "warning")) {
[17:48:11.355]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.355]                         if (muffled) 
[17:48:11.355]                           invokeRestart("muffleWarning")
[17:48:11.355]                       }
[17:48:11.355]                       else if (inherits(cond, "condition")) {
[17:48:11.355]                         if (!is.null(pattern)) {
[17:48:11.355]                           computeRestarts <- base::computeRestarts
[17:48:11.355]                           grepl <- base::grepl
[17:48:11.355]                           restarts <- computeRestarts(cond)
[17:48:11.355]                           for (restart in restarts) {
[17:48:11.355]                             name <- restart$name
[17:48:11.355]                             if (is.null(name)) 
[17:48:11.355]                               next
[17:48:11.355]                             if (!grepl(pattern, name)) 
[17:48:11.355]                               next
[17:48:11.355]                             invokeRestart(restart)
[17:48:11.355]                             muffled <- TRUE
[17:48:11.355]                             break
[17:48:11.355]                           }
[17:48:11.355]                         }
[17:48:11.355]                       }
[17:48:11.355]                       invisible(muffled)
[17:48:11.355]                     }
[17:48:11.355]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.355]                   }
[17:48:11.355]                 }
[17:48:11.355]                 else {
[17:48:11.355]                   if (TRUE) {
[17:48:11.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.355]                     {
[17:48:11.355]                       inherits <- base::inherits
[17:48:11.355]                       invokeRestart <- base::invokeRestart
[17:48:11.355]                       is.null <- base::is.null
[17:48:11.355]                       muffled <- FALSE
[17:48:11.355]                       if (inherits(cond, "message")) {
[17:48:11.355]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.355]                         if (muffled) 
[17:48:11.355]                           invokeRestart("muffleMessage")
[17:48:11.355]                       }
[17:48:11.355]                       else if (inherits(cond, "warning")) {
[17:48:11.355]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.355]                         if (muffled) 
[17:48:11.355]                           invokeRestart("muffleWarning")
[17:48:11.355]                       }
[17:48:11.355]                       else if (inherits(cond, "condition")) {
[17:48:11.355]                         if (!is.null(pattern)) {
[17:48:11.355]                           computeRestarts <- base::computeRestarts
[17:48:11.355]                           grepl <- base::grepl
[17:48:11.355]                           restarts <- computeRestarts(cond)
[17:48:11.355]                           for (restart in restarts) {
[17:48:11.355]                             name <- restart$name
[17:48:11.355]                             if (is.null(name)) 
[17:48:11.355]                               next
[17:48:11.355]                             if (!grepl(pattern, name)) 
[17:48:11.355]                               next
[17:48:11.355]                             invokeRestart(restart)
[17:48:11.355]                             muffled <- TRUE
[17:48:11.355]                             break
[17:48:11.355]                           }
[17:48:11.355]                         }
[17:48:11.355]                       }
[17:48:11.355]                       invisible(muffled)
[17:48:11.355]                     }
[17:48:11.355]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.355]                   }
[17:48:11.355]                 }
[17:48:11.355]             }
[17:48:11.355]         }))
[17:48:11.355]     }, error = function(ex) {
[17:48:11.355]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.355]                 ...future.rng), started = ...future.startTime, 
[17:48:11.355]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.355]             version = "1.8"), class = "FutureResult")
[17:48:11.355]     }, finally = {
[17:48:11.355]         if (!identical(...future.workdir, getwd())) 
[17:48:11.355]             setwd(...future.workdir)
[17:48:11.355]         {
[17:48:11.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.355]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.355]             }
[17:48:11.355]             base::options(...future.oldOptions)
[17:48:11.355]             if (.Platform$OS.type == "windows") {
[17:48:11.355]                 old_names <- names(...future.oldEnvVars)
[17:48:11.355]                 envs <- base::Sys.getenv()
[17:48:11.355]                 names <- names(envs)
[17:48:11.355]                 common <- intersect(names, old_names)
[17:48:11.355]                 added <- setdiff(names, old_names)
[17:48:11.355]                 removed <- setdiff(old_names, names)
[17:48:11.355]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.355]                   envs[common]]
[17:48:11.355]                 NAMES <- toupper(changed)
[17:48:11.355]                 args <- list()
[17:48:11.355]                 for (kk in seq_along(NAMES)) {
[17:48:11.355]                   name <- changed[[kk]]
[17:48:11.355]                   NAME <- NAMES[[kk]]
[17:48:11.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.355]                     next
[17:48:11.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.355]                 }
[17:48:11.355]                 NAMES <- toupper(added)
[17:48:11.355]                 for (kk in seq_along(NAMES)) {
[17:48:11.355]                   name <- added[[kk]]
[17:48:11.355]                   NAME <- NAMES[[kk]]
[17:48:11.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.355]                     next
[17:48:11.355]                   args[[name]] <- ""
[17:48:11.355]                 }
[17:48:11.355]                 NAMES <- toupper(removed)
[17:48:11.355]                 for (kk in seq_along(NAMES)) {
[17:48:11.355]                   name <- removed[[kk]]
[17:48:11.355]                   NAME <- NAMES[[kk]]
[17:48:11.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.355]                     next
[17:48:11.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.355]                 }
[17:48:11.355]                 if (length(args) > 0) 
[17:48:11.355]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.355]             }
[17:48:11.355]             else {
[17:48:11.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.355]             }
[17:48:11.355]             {
[17:48:11.355]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.355]                   0L) {
[17:48:11.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.355]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.355]                   base::options(opts)
[17:48:11.355]                 }
[17:48:11.355]                 {
[17:48:11.355]                   {
[17:48:11.355]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.355]                     NULL
[17:48:11.355]                   }
[17:48:11.355]                   options(future.plan = NULL)
[17:48:11.355]                   if (is.na(NA_character_)) 
[17:48:11.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.355]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.355]                     .init = FALSE)
[17:48:11.355]                 }
[17:48:11.355]             }
[17:48:11.355]         }
[17:48:11.355]     })
[17:48:11.355]     if (TRUE) {
[17:48:11.355]         base::sink(type = "output", split = FALSE)
[17:48:11.355]         if (TRUE) {
[17:48:11.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.355]         }
[17:48:11.355]         else {
[17:48:11.355]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.355]         }
[17:48:11.355]         base::close(...future.stdout)
[17:48:11.355]         ...future.stdout <- NULL
[17:48:11.355]     }
[17:48:11.355]     ...future.result$conditions <- ...future.conditions
[17:48:11.355]     ...future.result$finished <- base::Sys.time()
[17:48:11.355]     ...future.result
[17:48:11.355] }
[17:48:11.358] MultisessionFuture started
[17:48:11.358] - Launch lazy future ... done
[17:48:11.358] run() for ‘MultisessionFuture’ ... done
[17:48:11.358] getGlobalsAndPackages() ...
[17:48:11.358] Searching for globals...
[17:48:11.359] 
[17:48:11.359] Searching for globals ... DONE
[17:48:11.359] - globals: [0] <none>
[17:48:11.359] getGlobalsAndPackages() ... DONE
[17:48:11.360] run() for ‘Future’ ...
[17:48:11.360] - state: ‘created’
[17:48:11.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.373] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.374]   - Field: ‘node’
[17:48:11.374]   - Field: ‘label’
[17:48:11.374]   - Field: ‘local’
[17:48:11.374]   - Field: ‘owner’
[17:48:11.374]   - Field: ‘envir’
[17:48:11.374]   - Field: ‘workers’
[17:48:11.374]   - Field: ‘packages’
[17:48:11.374]   - Field: ‘gc’
[17:48:11.374]   - Field: ‘conditions’
[17:48:11.375]   - Field: ‘persistent’
[17:48:11.375]   - Field: ‘expr’
[17:48:11.375]   - Field: ‘uuid’
[17:48:11.375]   - Field: ‘seed’
[17:48:11.375]   - Field: ‘version’
[17:48:11.375]   - Field: ‘result’
[17:48:11.375]   - Field: ‘asynchronous’
[17:48:11.375]   - Field: ‘calls’
[17:48:11.375]   - Field: ‘globals’
[17:48:11.375]   - Field: ‘stdout’
[17:48:11.376]   - Field: ‘earlySignal’
[17:48:11.376]   - Field: ‘lazy’
[17:48:11.376]   - Field: ‘state’
[17:48:11.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.376] - Launch lazy future ...
[17:48:11.376] Packages needed by the future expression (n = 0): <none>
[17:48:11.376] Packages needed by future strategies (n = 0): <none>
[17:48:11.377] {
[17:48:11.377]     {
[17:48:11.377]         {
[17:48:11.377]             ...future.startTime <- base::Sys.time()
[17:48:11.377]             {
[17:48:11.377]                 {
[17:48:11.377]                   {
[17:48:11.377]                     {
[17:48:11.377]                       base::local({
[17:48:11.377]                         has_future <- base::requireNamespace("future", 
[17:48:11.377]                           quietly = TRUE)
[17:48:11.377]                         if (has_future) {
[17:48:11.377]                           ns <- base::getNamespace("future")
[17:48:11.377]                           version <- ns[[".package"]][["version"]]
[17:48:11.377]                           if (is.null(version)) 
[17:48:11.377]                             version <- utils::packageVersion("future")
[17:48:11.377]                         }
[17:48:11.377]                         else {
[17:48:11.377]                           version <- NULL
[17:48:11.377]                         }
[17:48:11.377]                         if (!has_future || version < "1.8.0") {
[17:48:11.377]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.377]                             "", base::R.version$version.string), 
[17:48:11.377]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.377]                               "release", "version")], collapse = " "), 
[17:48:11.377]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.377]                             info)
[17:48:11.377]                           info <- base::paste(info, collapse = "; ")
[17:48:11.377]                           if (!has_future) {
[17:48:11.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.377]                               info)
[17:48:11.377]                           }
[17:48:11.377]                           else {
[17:48:11.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.377]                               info, version)
[17:48:11.377]                           }
[17:48:11.377]                           base::stop(msg)
[17:48:11.377]                         }
[17:48:11.377]                       })
[17:48:11.377]                     }
[17:48:11.377]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.377]                     base::options(mc.cores = 1L)
[17:48:11.377]                   }
[17:48:11.377]                   ...future.strategy.old <- future::plan("list")
[17:48:11.377]                   options(future.plan = NULL)
[17:48:11.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.377]                 }
[17:48:11.377]                 ...future.workdir <- getwd()
[17:48:11.377]             }
[17:48:11.377]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.377]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.377]         }
[17:48:11.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.377]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.377]             base::names(...future.oldOptions))
[17:48:11.377]     }
[17:48:11.377]     if (FALSE) {
[17:48:11.377]     }
[17:48:11.377]     else {
[17:48:11.377]         if (TRUE) {
[17:48:11.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.377]                 open = "w")
[17:48:11.377]         }
[17:48:11.377]         else {
[17:48:11.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.377]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.377]         }
[17:48:11.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.377]             base::sink(type = "output", split = FALSE)
[17:48:11.377]             base::close(...future.stdout)
[17:48:11.377]         }, add = TRUE)
[17:48:11.377]     }
[17:48:11.377]     ...future.frame <- base::sys.nframe()
[17:48:11.377]     ...future.conditions <- base::list()
[17:48:11.377]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.377]     if (FALSE) {
[17:48:11.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.377]     }
[17:48:11.377]     ...future.result <- base::tryCatch({
[17:48:11.377]         base::withCallingHandlers({
[17:48:11.377]             ...future.value <- base::withVisible(base::local({
[17:48:11.377]                 ...future.makeSendCondition <- base::local({
[17:48:11.377]                   sendCondition <- NULL
[17:48:11.377]                   function(frame = 1L) {
[17:48:11.377]                     if (is.function(sendCondition)) 
[17:48:11.377]                       return(sendCondition)
[17:48:11.377]                     ns <- getNamespace("parallel")
[17:48:11.377]                     if (exists("sendData", mode = "function", 
[17:48:11.377]                       envir = ns)) {
[17:48:11.377]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.377]                         envir = ns)
[17:48:11.377]                       envir <- sys.frame(frame)
[17:48:11.377]                       master <- NULL
[17:48:11.377]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.377]                         !identical(envir, emptyenv())) {
[17:48:11.377]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.377]                           inherits = FALSE)) {
[17:48:11.377]                           master <- get("master", mode = "list", 
[17:48:11.377]                             envir = envir, inherits = FALSE)
[17:48:11.377]                           if (inherits(master, c("SOCKnode", 
[17:48:11.377]                             "SOCK0node"))) {
[17:48:11.377]                             sendCondition <<- function(cond) {
[17:48:11.377]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.377]                                 success = TRUE)
[17:48:11.377]                               parallel_sendData(master, data)
[17:48:11.377]                             }
[17:48:11.377]                             return(sendCondition)
[17:48:11.377]                           }
[17:48:11.377]                         }
[17:48:11.377]                         frame <- frame + 1L
[17:48:11.377]                         envir <- sys.frame(frame)
[17:48:11.377]                       }
[17:48:11.377]                     }
[17:48:11.377]                     sendCondition <<- function(cond) NULL
[17:48:11.377]                   }
[17:48:11.377]                 })
[17:48:11.377]                 withCallingHandlers({
[17:48:11.377]                   2
[17:48:11.377]                 }, immediateCondition = function(cond) {
[17:48:11.377]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.377]                   sendCondition(cond)
[17:48:11.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.377]                   {
[17:48:11.377]                     inherits <- base::inherits
[17:48:11.377]                     invokeRestart <- base::invokeRestart
[17:48:11.377]                     is.null <- base::is.null
[17:48:11.377]                     muffled <- FALSE
[17:48:11.377]                     if (inherits(cond, "message")) {
[17:48:11.377]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.377]                       if (muffled) 
[17:48:11.377]                         invokeRestart("muffleMessage")
[17:48:11.377]                     }
[17:48:11.377]                     else if (inherits(cond, "warning")) {
[17:48:11.377]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.377]                       if (muffled) 
[17:48:11.377]                         invokeRestart("muffleWarning")
[17:48:11.377]                     }
[17:48:11.377]                     else if (inherits(cond, "condition")) {
[17:48:11.377]                       if (!is.null(pattern)) {
[17:48:11.377]                         computeRestarts <- base::computeRestarts
[17:48:11.377]                         grepl <- base::grepl
[17:48:11.377]                         restarts <- computeRestarts(cond)
[17:48:11.377]                         for (restart in restarts) {
[17:48:11.377]                           name <- restart$name
[17:48:11.377]                           if (is.null(name)) 
[17:48:11.377]                             next
[17:48:11.377]                           if (!grepl(pattern, name)) 
[17:48:11.377]                             next
[17:48:11.377]                           invokeRestart(restart)
[17:48:11.377]                           muffled <- TRUE
[17:48:11.377]                           break
[17:48:11.377]                         }
[17:48:11.377]                       }
[17:48:11.377]                     }
[17:48:11.377]                     invisible(muffled)
[17:48:11.377]                   }
[17:48:11.377]                   muffleCondition(cond)
[17:48:11.377]                 })
[17:48:11.377]             }))
[17:48:11.377]             future::FutureResult(value = ...future.value$value, 
[17:48:11.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.377]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.377]                     ...future.globalenv.names))
[17:48:11.377]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.377]         }, condition = base::local({
[17:48:11.377]             c <- base::c
[17:48:11.377]             inherits <- base::inherits
[17:48:11.377]             invokeRestart <- base::invokeRestart
[17:48:11.377]             length <- base::length
[17:48:11.377]             list <- base::list
[17:48:11.377]             seq.int <- base::seq.int
[17:48:11.377]             signalCondition <- base::signalCondition
[17:48:11.377]             sys.calls <- base::sys.calls
[17:48:11.377]             `[[` <- base::`[[`
[17:48:11.377]             `+` <- base::`+`
[17:48:11.377]             `<<-` <- base::`<<-`
[17:48:11.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.377]                   3L)]
[17:48:11.377]             }
[17:48:11.377]             function(cond) {
[17:48:11.377]                 is_error <- inherits(cond, "error")
[17:48:11.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.377]                   NULL)
[17:48:11.377]                 if (is_error) {
[17:48:11.377]                   sessionInformation <- function() {
[17:48:11.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.377]                       search = base::search(), system = base::Sys.info())
[17:48:11.377]                   }
[17:48:11.377]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.377]                     cond$call), session = sessionInformation(), 
[17:48:11.377]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.377]                   signalCondition(cond)
[17:48:11.377]                 }
[17:48:11.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.377]                 "immediateCondition"))) {
[17:48:11.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.377]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.377]                   if (TRUE && !signal) {
[17:48:11.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.377]                     {
[17:48:11.377]                       inherits <- base::inherits
[17:48:11.377]                       invokeRestart <- base::invokeRestart
[17:48:11.377]                       is.null <- base::is.null
[17:48:11.377]                       muffled <- FALSE
[17:48:11.377]                       if (inherits(cond, "message")) {
[17:48:11.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.377]                         if (muffled) 
[17:48:11.377]                           invokeRestart("muffleMessage")
[17:48:11.377]                       }
[17:48:11.377]                       else if (inherits(cond, "warning")) {
[17:48:11.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.377]                         if (muffled) 
[17:48:11.377]                           invokeRestart("muffleWarning")
[17:48:11.377]                       }
[17:48:11.377]                       else if (inherits(cond, "condition")) {
[17:48:11.377]                         if (!is.null(pattern)) {
[17:48:11.377]                           computeRestarts <- base::computeRestarts
[17:48:11.377]                           grepl <- base::grepl
[17:48:11.377]                           restarts <- computeRestarts(cond)
[17:48:11.377]                           for (restart in restarts) {
[17:48:11.377]                             name <- restart$name
[17:48:11.377]                             if (is.null(name)) 
[17:48:11.377]                               next
[17:48:11.377]                             if (!grepl(pattern, name)) 
[17:48:11.377]                               next
[17:48:11.377]                             invokeRestart(restart)
[17:48:11.377]                             muffled <- TRUE
[17:48:11.377]                             break
[17:48:11.377]                           }
[17:48:11.377]                         }
[17:48:11.377]                       }
[17:48:11.377]                       invisible(muffled)
[17:48:11.377]                     }
[17:48:11.377]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.377]                   }
[17:48:11.377]                 }
[17:48:11.377]                 else {
[17:48:11.377]                   if (TRUE) {
[17:48:11.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.377]                     {
[17:48:11.377]                       inherits <- base::inherits
[17:48:11.377]                       invokeRestart <- base::invokeRestart
[17:48:11.377]                       is.null <- base::is.null
[17:48:11.377]                       muffled <- FALSE
[17:48:11.377]                       if (inherits(cond, "message")) {
[17:48:11.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.377]                         if (muffled) 
[17:48:11.377]                           invokeRestart("muffleMessage")
[17:48:11.377]                       }
[17:48:11.377]                       else if (inherits(cond, "warning")) {
[17:48:11.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.377]                         if (muffled) 
[17:48:11.377]                           invokeRestart("muffleWarning")
[17:48:11.377]                       }
[17:48:11.377]                       else if (inherits(cond, "condition")) {
[17:48:11.377]                         if (!is.null(pattern)) {
[17:48:11.377]                           computeRestarts <- base::computeRestarts
[17:48:11.377]                           grepl <- base::grepl
[17:48:11.377]                           restarts <- computeRestarts(cond)
[17:48:11.377]                           for (restart in restarts) {
[17:48:11.377]                             name <- restart$name
[17:48:11.377]                             if (is.null(name)) 
[17:48:11.377]                               next
[17:48:11.377]                             if (!grepl(pattern, name)) 
[17:48:11.377]                               next
[17:48:11.377]                             invokeRestart(restart)
[17:48:11.377]                             muffled <- TRUE
[17:48:11.377]                             break
[17:48:11.377]                           }
[17:48:11.377]                         }
[17:48:11.377]                       }
[17:48:11.377]                       invisible(muffled)
[17:48:11.377]                     }
[17:48:11.377]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.377]                   }
[17:48:11.377]                 }
[17:48:11.377]             }
[17:48:11.377]         }))
[17:48:11.377]     }, error = function(ex) {
[17:48:11.377]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.377]                 ...future.rng), started = ...future.startTime, 
[17:48:11.377]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.377]             version = "1.8"), class = "FutureResult")
[17:48:11.377]     }, finally = {
[17:48:11.377]         if (!identical(...future.workdir, getwd())) 
[17:48:11.377]             setwd(...future.workdir)
[17:48:11.377]         {
[17:48:11.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.377]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.377]             }
[17:48:11.377]             base::options(...future.oldOptions)
[17:48:11.377]             if (.Platform$OS.type == "windows") {
[17:48:11.377]                 old_names <- names(...future.oldEnvVars)
[17:48:11.377]                 envs <- base::Sys.getenv()
[17:48:11.377]                 names <- names(envs)
[17:48:11.377]                 common <- intersect(names, old_names)
[17:48:11.377]                 added <- setdiff(names, old_names)
[17:48:11.377]                 removed <- setdiff(old_names, names)
[17:48:11.377]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.377]                   envs[common]]
[17:48:11.377]                 NAMES <- toupper(changed)
[17:48:11.377]                 args <- list()
[17:48:11.377]                 for (kk in seq_along(NAMES)) {
[17:48:11.377]                   name <- changed[[kk]]
[17:48:11.377]                   NAME <- NAMES[[kk]]
[17:48:11.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.377]                     next
[17:48:11.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.377]                 }
[17:48:11.377]                 NAMES <- toupper(added)
[17:48:11.377]                 for (kk in seq_along(NAMES)) {
[17:48:11.377]                   name <- added[[kk]]
[17:48:11.377]                   NAME <- NAMES[[kk]]
[17:48:11.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.377]                     next
[17:48:11.377]                   args[[name]] <- ""
[17:48:11.377]                 }
[17:48:11.377]                 NAMES <- toupper(removed)
[17:48:11.377]                 for (kk in seq_along(NAMES)) {
[17:48:11.377]                   name <- removed[[kk]]
[17:48:11.377]                   NAME <- NAMES[[kk]]
[17:48:11.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.377]                     next
[17:48:11.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.377]                 }
[17:48:11.377]                 if (length(args) > 0) 
[17:48:11.377]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.377]             }
[17:48:11.377]             else {
[17:48:11.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.377]             }
[17:48:11.377]             {
[17:48:11.377]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.377]                   0L) {
[17:48:11.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.377]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.377]                   base::options(opts)
[17:48:11.377]                 }
[17:48:11.377]                 {
[17:48:11.377]                   {
[17:48:11.377]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.377]                     NULL
[17:48:11.377]                   }
[17:48:11.377]                   options(future.plan = NULL)
[17:48:11.377]                   if (is.na(NA_character_)) 
[17:48:11.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.377]                     .init = FALSE)
[17:48:11.377]                 }
[17:48:11.377]             }
[17:48:11.377]         }
[17:48:11.377]     })
[17:48:11.377]     if (TRUE) {
[17:48:11.377]         base::sink(type = "output", split = FALSE)
[17:48:11.377]         if (TRUE) {
[17:48:11.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.377]         }
[17:48:11.377]         else {
[17:48:11.377]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.377]         }
[17:48:11.377]         base::close(...future.stdout)
[17:48:11.377]         ...future.stdout <- NULL
[17:48:11.377]     }
[17:48:11.377]     ...future.result$conditions <- ...future.conditions
[17:48:11.377]     ...future.result$finished <- base::Sys.time()
[17:48:11.377]     ...future.result
[17:48:11.377] }
[17:48:11.380] MultisessionFuture started
[17:48:11.380] - Launch lazy future ... done
[17:48:11.380] run() for ‘MultisessionFuture’ ... done
[17:48:11.381] resolve() on environment ...
[17:48:11.381]  recursive: 0
[17:48:11.381]  elements: [3] ‘a’, ‘b’, ‘c’
[17:48:11.382] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.382] - Validating connection of MultisessionFuture
[17:48:11.382] - received message: FutureResult
[17:48:11.383] - Received FutureResult
[17:48:11.383] - Erased future from FutureRegistry
[17:48:11.383] result() for ClusterFuture ...
[17:48:11.383] - result already collected: FutureResult
[17:48:11.383] result() for ClusterFuture ... done
[17:48:11.383] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.383] Future #1
[17:48:11.384]  length: 2 (resolved future 1)
[17:48:11.385] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.385] - Validating connection of MultisessionFuture
[17:48:11.385] - received message: FutureResult
[17:48:11.385] - Received FutureResult
[17:48:11.385] - Erased future from FutureRegistry
[17:48:11.385] result() for ClusterFuture ...
[17:48:11.385] - result already collected: FutureResult
[17:48:11.385] result() for ClusterFuture ... done
[17:48:11.385] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.386] Future #2
[17:48:11.386]  length: 1 (resolved future 2)
[17:48:11.386]  length: 0 (resolved future 3)
[17:48:11.386] resolve() on environment ... DONE
[17:48:11.386] getGlobalsAndPackages() ...
[17:48:11.387] Searching for globals...
[17:48:11.387] - globals found: [1] ‘{’
[17:48:11.387] Searching for globals ... DONE
[17:48:11.387] Resolving globals: FALSE
[17:48:11.388] 
[17:48:11.388] 
[17:48:11.388] getGlobalsAndPackages() ... DONE
[17:48:11.388] run() for ‘Future’ ...
[17:48:11.388] - state: ‘created’
[17:48:11.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.402] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.402]   - Field: ‘node’
[17:48:11.402]   - Field: ‘label’
[17:48:11.402]   - Field: ‘local’
[17:48:11.402]   - Field: ‘owner’
[17:48:11.402]   - Field: ‘envir’
[17:48:11.403]   - Field: ‘workers’
[17:48:11.403]   - Field: ‘packages’
[17:48:11.403]   - Field: ‘gc’
[17:48:11.403]   - Field: ‘conditions’
[17:48:11.403]   - Field: ‘persistent’
[17:48:11.403]   - Field: ‘expr’
[17:48:11.403]   - Field: ‘uuid’
[17:48:11.403]   - Field: ‘seed’
[17:48:11.403]   - Field: ‘version’
[17:48:11.403]   - Field: ‘result’
[17:48:11.404]   - Field: ‘asynchronous’
[17:48:11.404]   - Field: ‘calls’
[17:48:11.404]   - Field: ‘globals’
[17:48:11.404]   - Field: ‘stdout’
[17:48:11.404]   - Field: ‘earlySignal’
[17:48:11.404]   - Field: ‘lazy’
[17:48:11.404]   - Field: ‘state’
[17:48:11.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.404] - Launch lazy future ...
[17:48:11.404] Packages needed by the future expression (n = 0): <none>
[17:48:11.405] Packages needed by future strategies (n = 0): <none>
[17:48:11.405] {
[17:48:11.405]     {
[17:48:11.405]         {
[17:48:11.405]             ...future.startTime <- base::Sys.time()
[17:48:11.405]             {
[17:48:11.405]                 {
[17:48:11.405]                   {
[17:48:11.405]                     {
[17:48:11.405]                       base::local({
[17:48:11.405]                         has_future <- base::requireNamespace("future", 
[17:48:11.405]                           quietly = TRUE)
[17:48:11.405]                         if (has_future) {
[17:48:11.405]                           ns <- base::getNamespace("future")
[17:48:11.405]                           version <- ns[[".package"]][["version"]]
[17:48:11.405]                           if (is.null(version)) 
[17:48:11.405]                             version <- utils::packageVersion("future")
[17:48:11.405]                         }
[17:48:11.405]                         else {
[17:48:11.405]                           version <- NULL
[17:48:11.405]                         }
[17:48:11.405]                         if (!has_future || version < "1.8.0") {
[17:48:11.405]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.405]                             "", base::R.version$version.string), 
[17:48:11.405]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.405]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.405]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.405]                               "release", "version")], collapse = " "), 
[17:48:11.405]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.405]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.405]                             info)
[17:48:11.405]                           info <- base::paste(info, collapse = "; ")
[17:48:11.405]                           if (!has_future) {
[17:48:11.405]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.405]                               info)
[17:48:11.405]                           }
[17:48:11.405]                           else {
[17:48:11.405]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.405]                               info, version)
[17:48:11.405]                           }
[17:48:11.405]                           base::stop(msg)
[17:48:11.405]                         }
[17:48:11.405]                       })
[17:48:11.405]                     }
[17:48:11.405]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.405]                     base::options(mc.cores = 1L)
[17:48:11.405]                   }
[17:48:11.405]                   ...future.strategy.old <- future::plan("list")
[17:48:11.405]                   options(future.plan = NULL)
[17:48:11.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.405]                 }
[17:48:11.405]                 ...future.workdir <- getwd()
[17:48:11.405]             }
[17:48:11.405]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.405]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.405]         }
[17:48:11.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.405]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.405]             base::names(...future.oldOptions))
[17:48:11.405]     }
[17:48:11.405]     if (FALSE) {
[17:48:11.405]     }
[17:48:11.405]     else {
[17:48:11.405]         if (TRUE) {
[17:48:11.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.405]                 open = "w")
[17:48:11.405]         }
[17:48:11.405]         else {
[17:48:11.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.405]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.405]         }
[17:48:11.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.405]             base::sink(type = "output", split = FALSE)
[17:48:11.405]             base::close(...future.stdout)
[17:48:11.405]         }, add = TRUE)
[17:48:11.405]     }
[17:48:11.405]     ...future.frame <- base::sys.nframe()
[17:48:11.405]     ...future.conditions <- base::list()
[17:48:11.405]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.405]     if (FALSE) {
[17:48:11.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.405]     }
[17:48:11.405]     ...future.result <- base::tryCatch({
[17:48:11.405]         base::withCallingHandlers({
[17:48:11.405]             ...future.value <- base::withVisible(base::local({
[17:48:11.405]                 ...future.makeSendCondition <- base::local({
[17:48:11.405]                   sendCondition <- NULL
[17:48:11.405]                   function(frame = 1L) {
[17:48:11.405]                     if (is.function(sendCondition)) 
[17:48:11.405]                       return(sendCondition)
[17:48:11.405]                     ns <- getNamespace("parallel")
[17:48:11.405]                     if (exists("sendData", mode = "function", 
[17:48:11.405]                       envir = ns)) {
[17:48:11.405]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.405]                         envir = ns)
[17:48:11.405]                       envir <- sys.frame(frame)
[17:48:11.405]                       master <- NULL
[17:48:11.405]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.405]                         !identical(envir, emptyenv())) {
[17:48:11.405]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.405]                           inherits = FALSE)) {
[17:48:11.405]                           master <- get("master", mode = "list", 
[17:48:11.405]                             envir = envir, inherits = FALSE)
[17:48:11.405]                           if (inherits(master, c("SOCKnode", 
[17:48:11.405]                             "SOCK0node"))) {
[17:48:11.405]                             sendCondition <<- function(cond) {
[17:48:11.405]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.405]                                 success = TRUE)
[17:48:11.405]                               parallel_sendData(master, data)
[17:48:11.405]                             }
[17:48:11.405]                             return(sendCondition)
[17:48:11.405]                           }
[17:48:11.405]                         }
[17:48:11.405]                         frame <- frame + 1L
[17:48:11.405]                         envir <- sys.frame(frame)
[17:48:11.405]                       }
[17:48:11.405]                     }
[17:48:11.405]                     sendCondition <<- function(cond) NULL
[17:48:11.405]                   }
[17:48:11.405]                 })
[17:48:11.405]                 withCallingHandlers({
[17:48:11.405]                   {
[17:48:11.405]                     1
[17:48:11.405]                   }
[17:48:11.405]                 }, immediateCondition = function(cond) {
[17:48:11.405]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.405]                   sendCondition(cond)
[17:48:11.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.405]                   {
[17:48:11.405]                     inherits <- base::inherits
[17:48:11.405]                     invokeRestart <- base::invokeRestart
[17:48:11.405]                     is.null <- base::is.null
[17:48:11.405]                     muffled <- FALSE
[17:48:11.405]                     if (inherits(cond, "message")) {
[17:48:11.405]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.405]                       if (muffled) 
[17:48:11.405]                         invokeRestart("muffleMessage")
[17:48:11.405]                     }
[17:48:11.405]                     else if (inherits(cond, "warning")) {
[17:48:11.405]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.405]                       if (muffled) 
[17:48:11.405]                         invokeRestart("muffleWarning")
[17:48:11.405]                     }
[17:48:11.405]                     else if (inherits(cond, "condition")) {
[17:48:11.405]                       if (!is.null(pattern)) {
[17:48:11.405]                         computeRestarts <- base::computeRestarts
[17:48:11.405]                         grepl <- base::grepl
[17:48:11.405]                         restarts <- computeRestarts(cond)
[17:48:11.405]                         for (restart in restarts) {
[17:48:11.405]                           name <- restart$name
[17:48:11.405]                           if (is.null(name)) 
[17:48:11.405]                             next
[17:48:11.405]                           if (!grepl(pattern, name)) 
[17:48:11.405]                             next
[17:48:11.405]                           invokeRestart(restart)
[17:48:11.405]                           muffled <- TRUE
[17:48:11.405]                           break
[17:48:11.405]                         }
[17:48:11.405]                       }
[17:48:11.405]                     }
[17:48:11.405]                     invisible(muffled)
[17:48:11.405]                   }
[17:48:11.405]                   muffleCondition(cond)
[17:48:11.405]                 })
[17:48:11.405]             }))
[17:48:11.405]             future::FutureResult(value = ...future.value$value, 
[17:48:11.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.405]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.405]                     ...future.globalenv.names))
[17:48:11.405]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.405]         }, condition = base::local({
[17:48:11.405]             c <- base::c
[17:48:11.405]             inherits <- base::inherits
[17:48:11.405]             invokeRestart <- base::invokeRestart
[17:48:11.405]             length <- base::length
[17:48:11.405]             list <- base::list
[17:48:11.405]             seq.int <- base::seq.int
[17:48:11.405]             signalCondition <- base::signalCondition
[17:48:11.405]             sys.calls <- base::sys.calls
[17:48:11.405]             `[[` <- base::`[[`
[17:48:11.405]             `+` <- base::`+`
[17:48:11.405]             `<<-` <- base::`<<-`
[17:48:11.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.405]                   3L)]
[17:48:11.405]             }
[17:48:11.405]             function(cond) {
[17:48:11.405]                 is_error <- inherits(cond, "error")
[17:48:11.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.405]                   NULL)
[17:48:11.405]                 if (is_error) {
[17:48:11.405]                   sessionInformation <- function() {
[17:48:11.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.405]                       search = base::search(), system = base::Sys.info())
[17:48:11.405]                   }
[17:48:11.405]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.405]                     cond$call), session = sessionInformation(), 
[17:48:11.405]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.405]                   signalCondition(cond)
[17:48:11.405]                 }
[17:48:11.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.405]                 "immediateCondition"))) {
[17:48:11.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.405]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.405]                   if (TRUE && !signal) {
[17:48:11.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.405]                     {
[17:48:11.405]                       inherits <- base::inherits
[17:48:11.405]                       invokeRestart <- base::invokeRestart
[17:48:11.405]                       is.null <- base::is.null
[17:48:11.405]                       muffled <- FALSE
[17:48:11.405]                       if (inherits(cond, "message")) {
[17:48:11.405]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.405]                         if (muffled) 
[17:48:11.405]                           invokeRestart("muffleMessage")
[17:48:11.405]                       }
[17:48:11.405]                       else if (inherits(cond, "warning")) {
[17:48:11.405]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.405]                         if (muffled) 
[17:48:11.405]                           invokeRestart("muffleWarning")
[17:48:11.405]                       }
[17:48:11.405]                       else if (inherits(cond, "condition")) {
[17:48:11.405]                         if (!is.null(pattern)) {
[17:48:11.405]                           computeRestarts <- base::computeRestarts
[17:48:11.405]                           grepl <- base::grepl
[17:48:11.405]                           restarts <- computeRestarts(cond)
[17:48:11.405]                           for (restart in restarts) {
[17:48:11.405]                             name <- restart$name
[17:48:11.405]                             if (is.null(name)) 
[17:48:11.405]                               next
[17:48:11.405]                             if (!grepl(pattern, name)) 
[17:48:11.405]                               next
[17:48:11.405]                             invokeRestart(restart)
[17:48:11.405]                             muffled <- TRUE
[17:48:11.405]                             break
[17:48:11.405]                           }
[17:48:11.405]                         }
[17:48:11.405]                       }
[17:48:11.405]                       invisible(muffled)
[17:48:11.405]                     }
[17:48:11.405]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.405]                   }
[17:48:11.405]                 }
[17:48:11.405]                 else {
[17:48:11.405]                   if (TRUE) {
[17:48:11.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.405]                     {
[17:48:11.405]                       inherits <- base::inherits
[17:48:11.405]                       invokeRestart <- base::invokeRestart
[17:48:11.405]                       is.null <- base::is.null
[17:48:11.405]                       muffled <- FALSE
[17:48:11.405]                       if (inherits(cond, "message")) {
[17:48:11.405]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.405]                         if (muffled) 
[17:48:11.405]                           invokeRestart("muffleMessage")
[17:48:11.405]                       }
[17:48:11.405]                       else if (inherits(cond, "warning")) {
[17:48:11.405]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.405]                         if (muffled) 
[17:48:11.405]                           invokeRestart("muffleWarning")
[17:48:11.405]                       }
[17:48:11.405]                       else if (inherits(cond, "condition")) {
[17:48:11.405]                         if (!is.null(pattern)) {
[17:48:11.405]                           computeRestarts <- base::computeRestarts
[17:48:11.405]                           grepl <- base::grepl
[17:48:11.405]                           restarts <- computeRestarts(cond)
[17:48:11.405]                           for (restart in restarts) {
[17:48:11.405]                             name <- restart$name
[17:48:11.405]                             if (is.null(name)) 
[17:48:11.405]                               next
[17:48:11.405]                             if (!grepl(pattern, name)) 
[17:48:11.405]                               next
[17:48:11.405]                             invokeRestart(restart)
[17:48:11.405]                             muffled <- TRUE
[17:48:11.405]                             break
[17:48:11.405]                           }
[17:48:11.405]                         }
[17:48:11.405]                       }
[17:48:11.405]                       invisible(muffled)
[17:48:11.405]                     }
[17:48:11.405]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.405]                   }
[17:48:11.405]                 }
[17:48:11.405]             }
[17:48:11.405]         }))
[17:48:11.405]     }, error = function(ex) {
[17:48:11.405]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.405]                 ...future.rng), started = ...future.startTime, 
[17:48:11.405]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.405]             version = "1.8"), class = "FutureResult")
[17:48:11.405]     }, finally = {
[17:48:11.405]         if (!identical(...future.workdir, getwd())) 
[17:48:11.405]             setwd(...future.workdir)
[17:48:11.405]         {
[17:48:11.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.405]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.405]             }
[17:48:11.405]             base::options(...future.oldOptions)
[17:48:11.405]             if (.Platform$OS.type == "windows") {
[17:48:11.405]                 old_names <- names(...future.oldEnvVars)
[17:48:11.405]                 envs <- base::Sys.getenv()
[17:48:11.405]                 names <- names(envs)
[17:48:11.405]                 common <- intersect(names, old_names)
[17:48:11.405]                 added <- setdiff(names, old_names)
[17:48:11.405]                 removed <- setdiff(old_names, names)
[17:48:11.405]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.405]                   envs[common]]
[17:48:11.405]                 NAMES <- toupper(changed)
[17:48:11.405]                 args <- list()
[17:48:11.405]                 for (kk in seq_along(NAMES)) {
[17:48:11.405]                   name <- changed[[kk]]
[17:48:11.405]                   NAME <- NAMES[[kk]]
[17:48:11.405]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.405]                     next
[17:48:11.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.405]                 }
[17:48:11.405]                 NAMES <- toupper(added)
[17:48:11.405]                 for (kk in seq_along(NAMES)) {
[17:48:11.405]                   name <- added[[kk]]
[17:48:11.405]                   NAME <- NAMES[[kk]]
[17:48:11.405]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.405]                     next
[17:48:11.405]                   args[[name]] <- ""
[17:48:11.405]                 }
[17:48:11.405]                 NAMES <- toupper(removed)
[17:48:11.405]                 for (kk in seq_along(NAMES)) {
[17:48:11.405]                   name <- removed[[kk]]
[17:48:11.405]                   NAME <- NAMES[[kk]]
[17:48:11.405]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.405]                     next
[17:48:11.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.405]                 }
[17:48:11.405]                 if (length(args) > 0) 
[17:48:11.405]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.405]             }
[17:48:11.405]             else {
[17:48:11.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.405]             }
[17:48:11.405]             {
[17:48:11.405]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.405]                   0L) {
[17:48:11.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.405]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.405]                   base::options(opts)
[17:48:11.405]                 }
[17:48:11.405]                 {
[17:48:11.405]                   {
[17:48:11.405]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.405]                     NULL
[17:48:11.405]                   }
[17:48:11.405]                   options(future.plan = NULL)
[17:48:11.405]                   if (is.na(NA_character_)) 
[17:48:11.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.405]                     .init = FALSE)
[17:48:11.405]                 }
[17:48:11.405]             }
[17:48:11.405]         }
[17:48:11.405]     })
[17:48:11.405]     if (TRUE) {
[17:48:11.405]         base::sink(type = "output", split = FALSE)
[17:48:11.405]         if (TRUE) {
[17:48:11.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.405]         }
[17:48:11.405]         else {
[17:48:11.405]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.405]         }
[17:48:11.405]         base::close(...future.stdout)
[17:48:11.405]         ...future.stdout <- NULL
[17:48:11.405]     }
[17:48:11.405]     ...future.result$conditions <- ...future.conditions
[17:48:11.405]     ...future.result$finished <- base::Sys.time()
[17:48:11.405]     ...future.result
[17:48:11.405] }
[17:48:11.408] MultisessionFuture started
[17:48:11.408] - Launch lazy future ... done
[17:48:11.408] run() for ‘MultisessionFuture’ ... done
[17:48:11.409] getGlobalsAndPackages() ...
[17:48:11.409] Searching for globals...
[17:48:11.410] - globals found: [1] ‘{’
[17:48:11.410] Searching for globals ... DONE
[17:48:11.410] Resolving globals: FALSE
[17:48:11.410] 
[17:48:11.411] 
[17:48:11.411] getGlobalsAndPackages() ... DONE
[17:48:11.411] run() for ‘Future’ ...
[17:48:11.411] - state: ‘created’
[17:48:11.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.425] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.425]   - Field: ‘node’
[17:48:11.425]   - Field: ‘label’
[17:48:11.425]   - Field: ‘local’
[17:48:11.425]   - Field: ‘owner’
[17:48:11.425]   - Field: ‘envir’
[17:48:11.425]   - Field: ‘workers’
[17:48:11.425]   - Field: ‘packages’
[17:48:11.426]   - Field: ‘gc’
[17:48:11.426]   - Field: ‘conditions’
[17:48:11.426]   - Field: ‘persistent’
[17:48:11.426]   - Field: ‘expr’
[17:48:11.426]   - Field: ‘uuid’
[17:48:11.426]   - Field: ‘seed’
[17:48:11.426]   - Field: ‘version’
[17:48:11.426]   - Field: ‘result’
[17:48:11.426]   - Field: ‘asynchronous’
[17:48:11.426]   - Field: ‘calls’
[17:48:11.426]   - Field: ‘globals’
[17:48:11.427]   - Field: ‘stdout’
[17:48:11.427]   - Field: ‘earlySignal’
[17:48:11.427]   - Field: ‘lazy’
[17:48:11.427]   - Field: ‘state’
[17:48:11.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.427] - Launch lazy future ...
[17:48:11.427] Packages needed by the future expression (n = 0): <none>
[17:48:11.427] Packages needed by future strategies (n = 0): <none>
[17:48:11.428] {
[17:48:11.428]     {
[17:48:11.428]         {
[17:48:11.428]             ...future.startTime <- base::Sys.time()
[17:48:11.428]             {
[17:48:11.428]                 {
[17:48:11.428]                   {
[17:48:11.428]                     {
[17:48:11.428]                       base::local({
[17:48:11.428]                         has_future <- base::requireNamespace("future", 
[17:48:11.428]                           quietly = TRUE)
[17:48:11.428]                         if (has_future) {
[17:48:11.428]                           ns <- base::getNamespace("future")
[17:48:11.428]                           version <- ns[[".package"]][["version"]]
[17:48:11.428]                           if (is.null(version)) 
[17:48:11.428]                             version <- utils::packageVersion("future")
[17:48:11.428]                         }
[17:48:11.428]                         else {
[17:48:11.428]                           version <- NULL
[17:48:11.428]                         }
[17:48:11.428]                         if (!has_future || version < "1.8.0") {
[17:48:11.428]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.428]                             "", base::R.version$version.string), 
[17:48:11.428]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.428]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.428]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.428]                               "release", "version")], collapse = " "), 
[17:48:11.428]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.428]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.428]                             info)
[17:48:11.428]                           info <- base::paste(info, collapse = "; ")
[17:48:11.428]                           if (!has_future) {
[17:48:11.428]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.428]                               info)
[17:48:11.428]                           }
[17:48:11.428]                           else {
[17:48:11.428]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.428]                               info, version)
[17:48:11.428]                           }
[17:48:11.428]                           base::stop(msg)
[17:48:11.428]                         }
[17:48:11.428]                       })
[17:48:11.428]                     }
[17:48:11.428]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.428]                     base::options(mc.cores = 1L)
[17:48:11.428]                   }
[17:48:11.428]                   ...future.strategy.old <- future::plan("list")
[17:48:11.428]                   options(future.plan = NULL)
[17:48:11.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.428]                 }
[17:48:11.428]                 ...future.workdir <- getwd()
[17:48:11.428]             }
[17:48:11.428]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.428]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.428]         }
[17:48:11.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.428]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.428]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.428]             base::names(...future.oldOptions))
[17:48:11.428]     }
[17:48:11.428]     if (FALSE) {
[17:48:11.428]     }
[17:48:11.428]     else {
[17:48:11.428]         if (TRUE) {
[17:48:11.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.428]                 open = "w")
[17:48:11.428]         }
[17:48:11.428]         else {
[17:48:11.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.428]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.428]         }
[17:48:11.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.428]             base::sink(type = "output", split = FALSE)
[17:48:11.428]             base::close(...future.stdout)
[17:48:11.428]         }, add = TRUE)
[17:48:11.428]     }
[17:48:11.428]     ...future.frame <- base::sys.nframe()
[17:48:11.428]     ...future.conditions <- base::list()
[17:48:11.428]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.428]     if (FALSE) {
[17:48:11.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.428]     }
[17:48:11.428]     ...future.result <- base::tryCatch({
[17:48:11.428]         base::withCallingHandlers({
[17:48:11.428]             ...future.value <- base::withVisible(base::local({
[17:48:11.428]                 ...future.makeSendCondition <- base::local({
[17:48:11.428]                   sendCondition <- NULL
[17:48:11.428]                   function(frame = 1L) {
[17:48:11.428]                     if (is.function(sendCondition)) 
[17:48:11.428]                       return(sendCondition)
[17:48:11.428]                     ns <- getNamespace("parallel")
[17:48:11.428]                     if (exists("sendData", mode = "function", 
[17:48:11.428]                       envir = ns)) {
[17:48:11.428]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.428]                         envir = ns)
[17:48:11.428]                       envir <- sys.frame(frame)
[17:48:11.428]                       master <- NULL
[17:48:11.428]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.428]                         !identical(envir, emptyenv())) {
[17:48:11.428]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.428]                           inherits = FALSE)) {
[17:48:11.428]                           master <- get("master", mode = "list", 
[17:48:11.428]                             envir = envir, inherits = FALSE)
[17:48:11.428]                           if (inherits(master, c("SOCKnode", 
[17:48:11.428]                             "SOCK0node"))) {
[17:48:11.428]                             sendCondition <<- function(cond) {
[17:48:11.428]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.428]                                 success = TRUE)
[17:48:11.428]                               parallel_sendData(master, data)
[17:48:11.428]                             }
[17:48:11.428]                             return(sendCondition)
[17:48:11.428]                           }
[17:48:11.428]                         }
[17:48:11.428]                         frame <- frame + 1L
[17:48:11.428]                         envir <- sys.frame(frame)
[17:48:11.428]                       }
[17:48:11.428]                     }
[17:48:11.428]                     sendCondition <<- function(cond) NULL
[17:48:11.428]                   }
[17:48:11.428]                 })
[17:48:11.428]                 withCallingHandlers({
[17:48:11.428]                   {
[17:48:11.428]                     2
[17:48:11.428]                   }
[17:48:11.428]                 }, immediateCondition = function(cond) {
[17:48:11.428]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.428]                   sendCondition(cond)
[17:48:11.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.428]                   {
[17:48:11.428]                     inherits <- base::inherits
[17:48:11.428]                     invokeRestart <- base::invokeRestart
[17:48:11.428]                     is.null <- base::is.null
[17:48:11.428]                     muffled <- FALSE
[17:48:11.428]                     if (inherits(cond, "message")) {
[17:48:11.428]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.428]                       if (muffled) 
[17:48:11.428]                         invokeRestart("muffleMessage")
[17:48:11.428]                     }
[17:48:11.428]                     else if (inherits(cond, "warning")) {
[17:48:11.428]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.428]                       if (muffled) 
[17:48:11.428]                         invokeRestart("muffleWarning")
[17:48:11.428]                     }
[17:48:11.428]                     else if (inherits(cond, "condition")) {
[17:48:11.428]                       if (!is.null(pattern)) {
[17:48:11.428]                         computeRestarts <- base::computeRestarts
[17:48:11.428]                         grepl <- base::grepl
[17:48:11.428]                         restarts <- computeRestarts(cond)
[17:48:11.428]                         for (restart in restarts) {
[17:48:11.428]                           name <- restart$name
[17:48:11.428]                           if (is.null(name)) 
[17:48:11.428]                             next
[17:48:11.428]                           if (!grepl(pattern, name)) 
[17:48:11.428]                             next
[17:48:11.428]                           invokeRestart(restart)
[17:48:11.428]                           muffled <- TRUE
[17:48:11.428]                           break
[17:48:11.428]                         }
[17:48:11.428]                       }
[17:48:11.428]                     }
[17:48:11.428]                     invisible(muffled)
[17:48:11.428]                   }
[17:48:11.428]                   muffleCondition(cond)
[17:48:11.428]                 })
[17:48:11.428]             }))
[17:48:11.428]             future::FutureResult(value = ...future.value$value, 
[17:48:11.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.428]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.428]                     ...future.globalenv.names))
[17:48:11.428]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.428]         }, condition = base::local({
[17:48:11.428]             c <- base::c
[17:48:11.428]             inherits <- base::inherits
[17:48:11.428]             invokeRestart <- base::invokeRestart
[17:48:11.428]             length <- base::length
[17:48:11.428]             list <- base::list
[17:48:11.428]             seq.int <- base::seq.int
[17:48:11.428]             signalCondition <- base::signalCondition
[17:48:11.428]             sys.calls <- base::sys.calls
[17:48:11.428]             `[[` <- base::`[[`
[17:48:11.428]             `+` <- base::`+`
[17:48:11.428]             `<<-` <- base::`<<-`
[17:48:11.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.428]                   3L)]
[17:48:11.428]             }
[17:48:11.428]             function(cond) {
[17:48:11.428]                 is_error <- inherits(cond, "error")
[17:48:11.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.428]                   NULL)
[17:48:11.428]                 if (is_error) {
[17:48:11.428]                   sessionInformation <- function() {
[17:48:11.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.428]                       search = base::search(), system = base::Sys.info())
[17:48:11.428]                   }
[17:48:11.428]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.428]                     cond$call), session = sessionInformation(), 
[17:48:11.428]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.428]                   signalCondition(cond)
[17:48:11.428]                 }
[17:48:11.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.428]                 "immediateCondition"))) {
[17:48:11.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.428]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.428]                   if (TRUE && !signal) {
[17:48:11.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.428]                     {
[17:48:11.428]                       inherits <- base::inherits
[17:48:11.428]                       invokeRestart <- base::invokeRestart
[17:48:11.428]                       is.null <- base::is.null
[17:48:11.428]                       muffled <- FALSE
[17:48:11.428]                       if (inherits(cond, "message")) {
[17:48:11.428]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.428]                         if (muffled) 
[17:48:11.428]                           invokeRestart("muffleMessage")
[17:48:11.428]                       }
[17:48:11.428]                       else if (inherits(cond, "warning")) {
[17:48:11.428]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.428]                         if (muffled) 
[17:48:11.428]                           invokeRestart("muffleWarning")
[17:48:11.428]                       }
[17:48:11.428]                       else if (inherits(cond, "condition")) {
[17:48:11.428]                         if (!is.null(pattern)) {
[17:48:11.428]                           computeRestarts <- base::computeRestarts
[17:48:11.428]                           grepl <- base::grepl
[17:48:11.428]                           restarts <- computeRestarts(cond)
[17:48:11.428]                           for (restart in restarts) {
[17:48:11.428]                             name <- restart$name
[17:48:11.428]                             if (is.null(name)) 
[17:48:11.428]                               next
[17:48:11.428]                             if (!grepl(pattern, name)) 
[17:48:11.428]                               next
[17:48:11.428]                             invokeRestart(restart)
[17:48:11.428]                             muffled <- TRUE
[17:48:11.428]                             break
[17:48:11.428]                           }
[17:48:11.428]                         }
[17:48:11.428]                       }
[17:48:11.428]                       invisible(muffled)
[17:48:11.428]                     }
[17:48:11.428]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.428]                   }
[17:48:11.428]                 }
[17:48:11.428]                 else {
[17:48:11.428]                   if (TRUE) {
[17:48:11.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.428]                     {
[17:48:11.428]                       inherits <- base::inherits
[17:48:11.428]                       invokeRestart <- base::invokeRestart
[17:48:11.428]                       is.null <- base::is.null
[17:48:11.428]                       muffled <- FALSE
[17:48:11.428]                       if (inherits(cond, "message")) {
[17:48:11.428]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.428]                         if (muffled) 
[17:48:11.428]                           invokeRestart("muffleMessage")
[17:48:11.428]                       }
[17:48:11.428]                       else if (inherits(cond, "warning")) {
[17:48:11.428]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.428]                         if (muffled) 
[17:48:11.428]                           invokeRestart("muffleWarning")
[17:48:11.428]                       }
[17:48:11.428]                       else if (inherits(cond, "condition")) {
[17:48:11.428]                         if (!is.null(pattern)) {
[17:48:11.428]                           computeRestarts <- base::computeRestarts
[17:48:11.428]                           grepl <- base::grepl
[17:48:11.428]                           restarts <- computeRestarts(cond)
[17:48:11.428]                           for (restart in restarts) {
[17:48:11.428]                             name <- restart$name
[17:48:11.428]                             if (is.null(name)) 
[17:48:11.428]                               next
[17:48:11.428]                             if (!grepl(pattern, name)) 
[17:48:11.428]                               next
[17:48:11.428]                             invokeRestart(restart)
[17:48:11.428]                             muffled <- TRUE
[17:48:11.428]                             break
[17:48:11.428]                           }
[17:48:11.428]                         }
[17:48:11.428]                       }
[17:48:11.428]                       invisible(muffled)
[17:48:11.428]                     }
[17:48:11.428]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.428]                   }
[17:48:11.428]                 }
[17:48:11.428]             }
[17:48:11.428]         }))
[17:48:11.428]     }, error = function(ex) {
[17:48:11.428]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.428]                 ...future.rng), started = ...future.startTime, 
[17:48:11.428]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.428]             version = "1.8"), class = "FutureResult")
[17:48:11.428]     }, finally = {
[17:48:11.428]         if (!identical(...future.workdir, getwd())) 
[17:48:11.428]             setwd(...future.workdir)
[17:48:11.428]         {
[17:48:11.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.428]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.428]             }
[17:48:11.428]             base::options(...future.oldOptions)
[17:48:11.428]             if (.Platform$OS.type == "windows") {
[17:48:11.428]                 old_names <- names(...future.oldEnvVars)
[17:48:11.428]                 envs <- base::Sys.getenv()
[17:48:11.428]                 names <- names(envs)
[17:48:11.428]                 common <- intersect(names, old_names)
[17:48:11.428]                 added <- setdiff(names, old_names)
[17:48:11.428]                 removed <- setdiff(old_names, names)
[17:48:11.428]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.428]                   envs[common]]
[17:48:11.428]                 NAMES <- toupper(changed)
[17:48:11.428]                 args <- list()
[17:48:11.428]                 for (kk in seq_along(NAMES)) {
[17:48:11.428]                   name <- changed[[kk]]
[17:48:11.428]                   NAME <- NAMES[[kk]]
[17:48:11.428]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.428]                     next
[17:48:11.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.428]                 }
[17:48:11.428]                 NAMES <- toupper(added)
[17:48:11.428]                 for (kk in seq_along(NAMES)) {
[17:48:11.428]                   name <- added[[kk]]
[17:48:11.428]                   NAME <- NAMES[[kk]]
[17:48:11.428]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.428]                     next
[17:48:11.428]                   args[[name]] <- ""
[17:48:11.428]                 }
[17:48:11.428]                 NAMES <- toupper(removed)
[17:48:11.428]                 for (kk in seq_along(NAMES)) {
[17:48:11.428]                   name <- removed[[kk]]
[17:48:11.428]                   NAME <- NAMES[[kk]]
[17:48:11.428]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.428]                     next
[17:48:11.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.428]                 }
[17:48:11.428]                 if (length(args) > 0) 
[17:48:11.428]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.428]             }
[17:48:11.428]             else {
[17:48:11.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.428]             }
[17:48:11.428]             {
[17:48:11.428]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.428]                   0L) {
[17:48:11.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.428]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.428]                   base::options(opts)
[17:48:11.428]                 }
[17:48:11.428]                 {
[17:48:11.428]                   {
[17:48:11.428]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.428]                     NULL
[17:48:11.428]                   }
[17:48:11.428]                   options(future.plan = NULL)
[17:48:11.428]                   if (is.na(NA_character_)) 
[17:48:11.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.428]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.428]                     .init = FALSE)
[17:48:11.428]                 }
[17:48:11.428]             }
[17:48:11.428]         }
[17:48:11.428]     })
[17:48:11.428]     if (TRUE) {
[17:48:11.428]         base::sink(type = "output", split = FALSE)
[17:48:11.428]         if (TRUE) {
[17:48:11.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.428]         }
[17:48:11.428]         else {
[17:48:11.428]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.428]         }
[17:48:11.428]         base::close(...future.stdout)
[17:48:11.428]         ...future.stdout <- NULL
[17:48:11.428]     }
[17:48:11.428]     ...future.result$conditions <- ...future.conditions
[17:48:11.428]     ...future.result$finished <- base::Sys.time()
[17:48:11.428]     ...future.result
[17:48:11.428] }
[17:48:11.431] MultisessionFuture started
[17:48:11.431] - Launch lazy future ... done
[17:48:11.435] run() for ‘MultisessionFuture’ ... done
[17:48:11.435] resolve() on environment ...
[17:48:11.436]  recursive: 0
[17:48:11.436]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:48:11.437] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.437] - Validating connection of MultisessionFuture
[17:48:11.437] - received message: FutureResult
[17:48:11.437] - Received FutureResult
[17:48:11.437] - Erased future from FutureRegistry
[17:48:11.437] result() for ClusterFuture ...
[17:48:11.437] - result already collected: FutureResult
[17:48:11.437] result() for ClusterFuture ... done
[17:48:11.438] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.438] Future #1
[17:48:11.438]  length: 2 (resolved future 1)
[17:48:11.438] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.438] - Validating connection of MultisessionFuture
[17:48:11.438] - received message: FutureResult
[17:48:11.439] - Received FutureResult
[17:48:11.439] - Erased future from FutureRegistry
[17:48:11.439] result() for ClusterFuture ...
[17:48:11.439] - result already collected: FutureResult
[17:48:11.439] result() for ClusterFuture ... done
[17:48:11.439] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.439] Future #2
[17:48:11.439]  length: 1 (resolved future 2)
[17:48:11.439]  length: 0 (resolved future 3)
[17:48:11.439] resolve() on environment ... DONE
[17:48:11.440] getGlobalsAndPackages() ...
[17:48:11.440] Searching for globals...
[17:48:11.441] - globals found: [1] ‘{’
[17:48:11.441] Searching for globals ... DONE
[17:48:11.441] Resolving globals: FALSE
[17:48:11.441] 
[17:48:11.441] 
[17:48:11.441] getGlobalsAndPackages() ... DONE
[17:48:11.441] run() for ‘Future’ ...
[17:48:11.442] - state: ‘created’
[17:48:11.442] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.455]   - Field: ‘node’
[17:48:11.456]   - Field: ‘label’
[17:48:11.456]   - Field: ‘local’
[17:48:11.456]   - Field: ‘owner’
[17:48:11.456]   - Field: ‘envir’
[17:48:11.456]   - Field: ‘workers’
[17:48:11.456]   - Field: ‘packages’
[17:48:11.456]   - Field: ‘gc’
[17:48:11.456]   - Field: ‘conditions’
[17:48:11.456]   - Field: ‘persistent’
[17:48:11.456]   - Field: ‘expr’
[17:48:11.456]   - Field: ‘uuid’
[17:48:11.457]   - Field: ‘seed’
[17:48:11.457]   - Field: ‘version’
[17:48:11.457]   - Field: ‘result’
[17:48:11.457]   - Field: ‘asynchronous’
[17:48:11.457]   - Field: ‘calls’
[17:48:11.457]   - Field: ‘globals’
[17:48:11.457]   - Field: ‘stdout’
[17:48:11.457]   - Field: ‘earlySignal’
[17:48:11.457]   - Field: ‘lazy’
[17:48:11.457]   - Field: ‘state’
[17:48:11.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.457] - Launch lazy future ...
[17:48:11.458] Packages needed by the future expression (n = 0): <none>
[17:48:11.458] Packages needed by future strategies (n = 0): <none>
[17:48:11.458] {
[17:48:11.458]     {
[17:48:11.458]         {
[17:48:11.458]             ...future.startTime <- base::Sys.time()
[17:48:11.458]             {
[17:48:11.458]                 {
[17:48:11.458]                   {
[17:48:11.458]                     {
[17:48:11.458]                       base::local({
[17:48:11.458]                         has_future <- base::requireNamespace("future", 
[17:48:11.458]                           quietly = TRUE)
[17:48:11.458]                         if (has_future) {
[17:48:11.458]                           ns <- base::getNamespace("future")
[17:48:11.458]                           version <- ns[[".package"]][["version"]]
[17:48:11.458]                           if (is.null(version)) 
[17:48:11.458]                             version <- utils::packageVersion("future")
[17:48:11.458]                         }
[17:48:11.458]                         else {
[17:48:11.458]                           version <- NULL
[17:48:11.458]                         }
[17:48:11.458]                         if (!has_future || version < "1.8.0") {
[17:48:11.458]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.458]                             "", base::R.version$version.string), 
[17:48:11.458]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.458]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.458]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.458]                               "release", "version")], collapse = " "), 
[17:48:11.458]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.458]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.458]                             info)
[17:48:11.458]                           info <- base::paste(info, collapse = "; ")
[17:48:11.458]                           if (!has_future) {
[17:48:11.458]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.458]                               info)
[17:48:11.458]                           }
[17:48:11.458]                           else {
[17:48:11.458]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.458]                               info, version)
[17:48:11.458]                           }
[17:48:11.458]                           base::stop(msg)
[17:48:11.458]                         }
[17:48:11.458]                       })
[17:48:11.458]                     }
[17:48:11.458]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.458]                     base::options(mc.cores = 1L)
[17:48:11.458]                   }
[17:48:11.458]                   ...future.strategy.old <- future::plan("list")
[17:48:11.458]                   options(future.plan = NULL)
[17:48:11.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.458]                 }
[17:48:11.458]                 ...future.workdir <- getwd()
[17:48:11.458]             }
[17:48:11.458]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.458]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.458]         }
[17:48:11.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.458]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.458]             base::names(...future.oldOptions))
[17:48:11.458]     }
[17:48:11.458]     if (FALSE) {
[17:48:11.458]     }
[17:48:11.458]     else {
[17:48:11.458]         if (TRUE) {
[17:48:11.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.458]                 open = "w")
[17:48:11.458]         }
[17:48:11.458]         else {
[17:48:11.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.458]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.458]         }
[17:48:11.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.458]             base::sink(type = "output", split = FALSE)
[17:48:11.458]             base::close(...future.stdout)
[17:48:11.458]         }, add = TRUE)
[17:48:11.458]     }
[17:48:11.458]     ...future.frame <- base::sys.nframe()
[17:48:11.458]     ...future.conditions <- base::list()
[17:48:11.458]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.458]     if (FALSE) {
[17:48:11.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.458]     }
[17:48:11.458]     ...future.result <- base::tryCatch({
[17:48:11.458]         base::withCallingHandlers({
[17:48:11.458]             ...future.value <- base::withVisible(base::local({
[17:48:11.458]                 ...future.makeSendCondition <- base::local({
[17:48:11.458]                   sendCondition <- NULL
[17:48:11.458]                   function(frame = 1L) {
[17:48:11.458]                     if (is.function(sendCondition)) 
[17:48:11.458]                       return(sendCondition)
[17:48:11.458]                     ns <- getNamespace("parallel")
[17:48:11.458]                     if (exists("sendData", mode = "function", 
[17:48:11.458]                       envir = ns)) {
[17:48:11.458]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.458]                         envir = ns)
[17:48:11.458]                       envir <- sys.frame(frame)
[17:48:11.458]                       master <- NULL
[17:48:11.458]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.458]                         !identical(envir, emptyenv())) {
[17:48:11.458]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.458]                           inherits = FALSE)) {
[17:48:11.458]                           master <- get("master", mode = "list", 
[17:48:11.458]                             envir = envir, inherits = FALSE)
[17:48:11.458]                           if (inherits(master, c("SOCKnode", 
[17:48:11.458]                             "SOCK0node"))) {
[17:48:11.458]                             sendCondition <<- function(cond) {
[17:48:11.458]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.458]                                 success = TRUE)
[17:48:11.458]                               parallel_sendData(master, data)
[17:48:11.458]                             }
[17:48:11.458]                             return(sendCondition)
[17:48:11.458]                           }
[17:48:11.458]                         }
[17:48:11.458]                         frame <- frame + 1L
[17:48:11.458]                         envir <- sys.frame(frame)
[17:48:11.458]                       }
[17:48:11.458]                     }
[17:48:11.458]                     sendCondition <<- function(cond) NULL
[17:48:11.458]                   }
[17:48:11.458]                 })
[17:48:11.458]                 withCallingHandlers({
[17:48:11.458]                   {
[17:48:11.458]                     1
[17:48:11.458]                   }
[17:48:11.458]                 }, immediateCondition = function(cond) {
[17:48:11.458]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.458]                   sendCondition(cond)
[17:48:11.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.458]                   {
[17:48:11.458]                     inherits <- base::inherits
[17:48:11.458]                     invokeRestart <- base::invokeRestart
[17:48:11.458]                     is.null <- base::is.null
[17:48:11.458]                     muffled <- FALSE
[17:48:11.458]                     if (inherits(cond, "message")) {
[17:48:11.458]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.458]                       if (muffled) 
[17:48:11.458]                         invokeRestart("muffleMessage")
[17:48:11.458]                     }
[17:48:11.458]                     else if (inherits(cond, "warning")) {
[17:48:11.458]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.458]                       if (muffled) 
[17:48:11.458]                         invokeRestart("muffleWarning")
[17:48:11.458]                     }
[17:48:11.458]                     else if (inherits(cond, "condition")) {
[17:48:11.458]                       if (!is.null(pattern)) {
[17:48:11.458]                         computeRestarts <- base::computeRestarts
[17:48:11.458]                         grepl <- base::grepl
[17:48:11.458]                         restarts <- computeRestarts(cond)
[17:48:11.458]                         for (restart in restarts) {
[17:48:11.458]                           name <- restart$name
[17:48:11.458]                           if (is.null(name)) 
[17:48:11.458]                             next
[17:48:11.458]                           if (!grepl(pattern, name)) 
[17:48:11.458]                             next
[17:48:11.458]                           invokeRestart(restart)
[17:48:11.458]                           muffled <- TRUE
[17:48:11.458]                           break
[17:48:11.458]                         }
[17:48:11.458]                       }
[17:48:11.458]                     }
[17:48:11.458]                     invisible(muffled)
[17:48:11.458]                   }
[17:48:11.458]                   muffleCondition(cond)
[17:48:11.458]                 })
[17:48:11.458]             }))
[17:48:11.458]             future::FutureResult(value = ...future.value$value, 
[17:48:11.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.458]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.458]                     ...future.globalenv.names))
[17:48:11.458]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.458]         }, condition = base::local({
[17:48:11.458]             c <- base::c
[17:48:11.458]             inherits <- base::inherits
[17:48:11.458]             invokeRestart <- base::invokeRestart
[17:48:11.458]             length <- base::length
[17:48:11.458]             list <- base::list
[17:48:11.458]             seq.int <- base::seq.int
[17:48:11.458]             signalCondition <- base::signalCondition
[17:48:11.458]             sys.calls <- base::sys.calls
[17:48:11.458]             `[[` <- base::`[[`
[17:48:11.458]             `+` <- base::`+`
[17:48:11.458]             `<<-` <- base::`<<-`
[17:48:11.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.458]                   3L)]
[17:48:11.458]             }
[17:48:11.458]             function(cond) {
[17:48:11.458]                 is_error <- inherits(cond, "error")
[17:48:11.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.458]                   NULL)
[17:48:11.458]                 if (is_error) {
[17:48:11.458]                   sessionInformation <- function() {
[17:48:11.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.458]                       search = base::search(), system = base::Sys.info())
[17:48:11.458]                   }
[17:48:11.458]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.458]                     cond$call), session = sessionInformation(), 
[17:48:11.458]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.458]                   signalCondition(cond)
[17:48:11.458]                 }
[17:48:11.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.458]                 "immediateCondition"))) {
[17:48:11.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.458]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.458]                   if (TRUE && !signal) {
[17:48:11.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.458]                     {
[17:48:11.458]                       inherits <- base::inherits
[17:48:11.458]                       invokeRestart <- base::invokeRestart
[17:48:11.458]                       is.null <- base::is.null
[17:48:11.458]                       muffled <- FALSE
[17:48:11.458]                       if (inherits(cond, "message")) {
[17:48:11.458]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.458]                         if (muffled) 
[17:48:11.458]                           invokeRestart("muffleMessage")
[17:48:11.458]                       }
[17:48:11.458]                       else if (inherits(cond, "warning")) {
[17:48:11.458]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.458]                         if (muffled) 
[17:48:11.458]                           invokeRestart("muffleWarning")
[17:48:11.458]                       }
[17:48:11.458]                       else if (inherits(cond, "condition")) {
[17:48:11.458]                         if (!is.null(pattern)) {
[17:48:11.458]                           computeRestarts <- base::computeRestarts
[17:48:11.458]                           grepl <- base::grepl
[17:48:11.458]                           restarts <- computeRestarts(cond)
[17:48:11.458]                           for (restart in restarts) {
[17:48:11.458]                             name <- restart$name
[17:48:11.458]                             if (is.null(name)) 
[17:48:11.458]                               next
[17:48:11.458]                             if (!grepl(pattern, name)) 
[17:48:11.458]                               next
[17:48:11.458]                             invokeRestart(restart)
[17:48:11.458]                             muffled <- TRUE
[17:48:11.458]                             break
[17:48:11.458]                           }
[17:48:11.458]                         }
[17:48:11.458]                       }
[17:48:11.458]                       invisible(muffled)
[17:48:11.458]                     }
[17:48:11.458]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.458]                   }
[17:48:11.458]                 }
[17:48:11.458]                 else {
[17:48:11.458]                   if (TRUE) {
[17:48:11.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.458]                     {
[17:48:11.458]                       inherits <- base::inherits
[17:48:11.458]                       invokeRestart <- base::invokeRestart
[17:48:11.458]                       is.null <- base::is.null
[17:48:11.458]                       muffled <- FALSE
[17:48:11.458]                       if (inherits(cond, "message")) {
[17:48:11.458]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.458]                         if (muffled) 
[17:48:11.458]                           invokeRestart("muffleMessage")
[17:48:11.458]                       }
[17:48:11.458]                       else if (inherits(cond, "warning")) {
[17:48:11.458]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.458]                         if (muffled) 
[17:48:11.458]                           invokeRestart("muffleWarning")
[17:48:11.458]                       }
[17:48:11.458]                       else if (inherits(cond, "condition")) {
[17:48:11.458]                         if (!is.null(pattern)) {
[17:48:11.458]                           computeRestarts <- base::computeRestarts
[17:48:11.458]                           grepl <- base::grepl
[17:48:11.458]                           restarts <- computeRestarts(cond)
[17:48:11.458]                           for (restart in restarts) {
[17:48:11.458]                             name <- restart$name
[17:48:11.458]                             if (is.null(name)) 
[17:48:11.458]                               next
[17:48:11.458]                             if (!grepl(pattern, name)) 
[17:48:11.458]                               next
[17:48:11.458]                             invokeRestart(restart)
[17:48:11.458]                             muffled <- TRUE
[17:48:11.458]                             break
[17:48:11.458]                           }
[17:48:11.458]                         }
[17:48:11.458]                       }
[17:48:11.458]                       invisible(muffled)
[17:48:11.458]                     }
[17:48:11.458]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.458]                   }
[17:48:11.458]                 }
[17:48:11.458]             }
[17:48:11.458]         }))
[17:48:11.458]     }, error = function(ex) {
[17:48:11.458]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.458]                 ...future.rng), started = ...future.startTime, 
[17:48:11.458]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.458]             version = "1.8"), class = "FutureResult")
[17:48:11.458]     }, finally = {
[17:48:11.458]         if (!identical(...future.workdir, getwd())) 
[17:48:11.458]             setwd(...future.workdir)
[17:48:11.458]         {
[17:48:11.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.458]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.458]             }
[17:48:11.458]             base::options(...future.oldOptions)
[17:48:11.458]             if (.Platform$OS.type == "windows") {
[17:48:11.458]                 old_names <- names(...future.oldEnvVars)
[17:48:11.458]                 envs <- base::Sys.getenv()
[17:48:11.458]                 names <- names(envs)
[17:48:11.458]                 common <- intersect(names, old_names)
[17:48:11.458]                 added <- setdiff(names, old_names)
[17:48:11.458]                 removed <- setdiff(old_names, names)
[17:48:11.458]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.458]                   envs[common]]
[17:48:11.458]                 NAMES <- toupper(changed)
[17:48:11.458]                 args <- list()
[17:48:11.458]                 for (kk in seq_along(NAMES)) {
[17:48:11.458]                   name <- changed[[kk]]
[17:48:11.458]                   NAME <- NAMES[[kk]]
[17:48:11.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.458]                     next
[17:48:11.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.458]                 }
[17:48:11.458]                 NAMES <- toupper(added)
[17:48:11.458]                 for (kk in seq_along(NAMES)) {
[17:48:11.458]                   name <- added[[kk]]
[17:48:11.458]                   NAME <- NAMES[[kk]]
[17:48:11.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.458]                     next
[17:48:11.458]                   args[[name]] <- ""
[17:48:11.458]                 }
[17:48:11.458]                 NAMES <- toupper(removed)
[17:48:11.458]                 for (kk in seq_along(NAMES)) {
[17:48:11.458]                   name <- removed[[kk]]
[17:48:11.458]                   NAME <- NAMES[[kk]]
[17:48:11.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.458]                     next
[17:48:11.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.458]                 }
[17:48:11.458]                 if (length(args) > 0) 
[17:48:11.458]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.458]             }
[17:48:11.458]             else {
[17:48:11.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.458]             }
[17:48:11.458]             {
[17:48:11.458]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.458]                   0L) {
[17:48:11.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.458]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.458]                   base::options(opts)
[17:48:11.458]                 }
[17:48:11.458]                 {
[17:48:11.458]                   {
[17:48:11.458]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.458]                     NULL
[17:48:11.458]                   }
[17:48:11.458]                   options(future.plan = NULL)
[17:48:11.458]                   if (is.na(NA_character_)) 
[17:48:11.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.458]                     .init = FALSE)
[17:48:11.458]                 }
[17:48:11.458]             }
[17:48:11.458]         }
[17:48:11.458]     })
[17:48:11.458]     if (TRUE) {
[17:48:11.458]         base::sink(type = "output", split = FALSE)
[17:48:11.458]         if (TRUE) {
[17:48:11.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.458]         }
[17:48:11.458]         else {
[17:48:11.458]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.458]         }
[17:48:11.458]         base::close(...future.stdout)
[17:48:11.458]         ...future.stdout <- NULL
[17:48:11.458]     }
[17:48:11.458]     ...future.result$conditions <- ...future.conditions
[17:48:11.458]     ...future.result$finished <- base::Sys.time()
[17:48:11.458]     ...future.result
[17:48:11.458] }
[17:48:11.461] MultisessionFuture started
[17:48:11.461] - Launch lazy future ... done
[17:48:11.461] run() for ‘MultisessionFuture’ ... done
[17:48:11.462] getGlobalsAndPackages() ...
[17:48:11.462] Searching for globals...
[17:48:11.463] - globals found: [1] ‘{’
[17:48:11.463] Searching for globals ... DONE
[17:48:11.463] Resolving globals: FALSE
[17:48:11.464] 
[17:48:11.464] 
[17:48:11.464] getGlobalsAndPackages() ... DONE
[17:48:11.464] run() for ‘Future’ ...
[17:48:11.464] - state: ‘created’
[17:48:11.464] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.478]   - Field: ‘node’
[17:48:11.478]   - Field: ‘label’
[17:48:11.478]   - Field: ‘local’
[17:48:11.478]   - Field: ‘owner’
[17:48:11.478]   - Field: ‘envir’
[17:48:11.478]   - Field: ‘workers’
[17:48:11.479]   - Field: ‘packages’
[17:48:11.479]   - Field: ‘gc’
[17:48:11.479]   - Field: ‘conditions’
[17:48:11.479]   - Field: ‘persistent’
[17:48:11.479]   - Field: ‘expr’
[17:48:11.479]   - Field: ‘uuid’
[17:48:11.479]   - Field: ‘seed’
[17:48:11.479]   - Field: ‘version’
[17:48:11.479]   - Field: ‘result’
[17:48:11.479]   - Field: ‘asynchronous’
[17:48:11.479]   - Field: ‘calls’
[17:48:11.480]   - Field: ‘globals’
[17:48:11.480]   - Field: ‘stdout’
[17:48:11.480]   - Field: ‘earlySignal’
[17:48:11.480]   - Field: ‘lazy’
[17:48:11.480]   - Field: ‘state’
[17:48:11.480] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.480] - Launch lazy future ...
[17:48:11.480] Packages needed by the future expression (n = 0): <none>
[17:48:11.480] Packages needed by future strategies (n = 0): <none>
[17:48:11.481] {
[17:48:11.481]     {
[17:48:11.481]         {
[17:48:11.481]             ...future.startTime <- base::Sys.time()
[17:48:11.481]             {
[17:48:11.481]                 {
[17:48:11.481]                   {
[17:48:11.481]                     {
[17:48:11.481]                       base::local({
[17:48:11.481]                         has_future <- base::requireNamespace("future", 
[17:48:11.481]                           quietly = TRUE)
[17:48:11.481]                         if (has_future) {
[17:48:11.481]                           ns <- base::getNamespace("future")
[17:48:11.481]                           version <- ns[[".package"]][["version"]]
[17:48:11.481]                           if (is.null(version)) 
[17:48:11.481]                             version <- utils::packageVersion("future")
[17:48:11.481]                         }
[17:48:11.481]                         else {
[17:48:11.481]                           version <- NULL
[17:48:11.481]                         }
[17:48:11.481]                         if (!has_future || version < "1.8.0") {
[17:48:11.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.481]                             "", base::R.version$version.string), 
[17:48:11.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.481]                               "release", "version")], collapse = " "), 
[17:48:11.481]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.481]                             info)
[17:48:11.481]                           info <- base::paste(info, collapse = "; ")
[17:48:11.481]                           if (!has_future) {
[17:48:11.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.481]                               info)
[17:48:11.481]                           }
[17:48:11.481]                           else {
[17:48:11.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.481]                               info, version)
[17:48:11.481]                           }
[17:48:11.481]                           base::stop(msg)
[17:48:11.481]                         }
[17:48:11.481]                       })
[17:48:11.481]                     }
[17:48:11.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.481]                     base::options(mc.cores = 1L)
[17:48:11.481]                   }
[17:48:11.481]                   ...future.strategy.old <- future::plan("list")
[17:48:11.481]                   options(future.plan = NULL)
[17:48:11.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.481]                 }
[17:48:11.481]                 ...future.workdir <- getwd()
[17:48:11.481]             }
[17:48:11.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.481]         }
[17:48:11.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.481]             base::names(...future.oldOptions))
[17:48:11.481]     }
[17:48:11.481]     if (FALSE) {
[17:48:11.481]     }
[17:48:11.481]     else {
[17:48:11.481]         if (TRUE) {
[17:48:11.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.481]                 open = "w")
[17:48:11.481]         }
[17:48:11.481]         else {
[17:48:11.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.481]         }
[17:48:11.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.481]             base::sink(type = "output", split = FALSE)
[17:48:11.481]             base::close(...future.stdout)
[17:48:11.481]         }, add = TRUE)
[17:48:11.481]     }
[17:48:11.481]     ...future.frame <- base::sys.nframe()
[17:48:11.481]     ...future.conditions <- base::list()
[17:48:11.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.481]     if (FALSE) {
[17:48:11.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.481]     }
[17:48:11.481]     ...future.result <- base::tryCatch({
[17:48:11.481]         base::withCallingHandlers({
[17:48:11.481]             ...future.value <- base::withVisible(base::local({
[17:48:11.481]                 ...future.makeSendCondition <- base::local({
[17:48:11.481]                   sendCondition <- NULL
[17:48:11.481]                   function(frame = 1L) {
[17:48:11.481]                     if (is.function(sendCondition)) 
[17:48:11.481]                       return(sendCondition)
[17:48:11.481]                     ns <- getNamespace("parallel")
[17:48:11.481]                     if (exists("sendData", mode = "function", 
[17:48:11.481]                       envir = ns)) {
[17:48:11.481]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.481]                         envir = ns)
[17:48:11.481]                       envir <- sys.frame(frame)
[17:48:11.481]                       master <- NULL
[17:48:11.481]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.481]                         !identical(envir, emptyenv())) {
[17:48:11.481]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.481]                           inherits = FALSE)) {
[17:48:11.481]                           master <- get("master", mode = "list", 
[17:48:11.481]                             envir = envir, inherits = FALSE)
[17:48:11.481]                           if (inherits(master, c("SOCKnode", 
[17:48:11.481]                             "SOCK0node"))) {
[17:48:11.481]                             sendCondition <<- function(cond) {
[17:48:11.481]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.481]                                 success = TRUE)
[17:48:11.481]                               parallel_sendData(master, data)
[17:48:11.481]                             }
[17:48:11.481]                             return(sendCondition)
[17:48:11.481]                           }
[17:48:11.481]                         }
[17:48:11.481]                         frame <- frame + 1L
[17:48:11.481]                         envir <- sys.frame(frame)
[17:48:11.481]                       }
[17:48:11.481]                     }
[17:48:11.481]                     sendCondition <<- function(cond) NULL
[17:48:11.481]                   }
[17:48:11.481]                 })
[17:48:11.481]                 withCallingHandlers({
[17:48:11.481]                   {
[17:48:11.481]                     2
[17:48:11.481]                   }
[17:48:11.481]                 }, immediateCondition = function(cond) {
[17:48:11.481]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.481]                   sendCondition(cond)
[17:48:11.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.481]                   {
[17:48:11.481]                     inherits <- base::inherits
[17:48:11.481]                     invokeRestart <- base::invokeRestart
[17:48:11.481]                     is.null <- base::is.null
[17:48:11.481]                     muffled <- FALSE
[17:48:11.481]                     if (inherits(cond, "message")) {
[17:48:11.481]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.481]                       if (muffled) 
[17:48:11.481]                         invokeRestart("muffleMessage")
[17:48:11.481]                     }
[17:48:11.481]                     else if (inherits(cond, "warning")) {
[17:48:11.481]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.481]                       if (muffled) 
[17:48:11.481]                         invokeRestart("muffleWarning")
[17:48:11.481]                     }
[17:48:11.481]                     else if (inherits(cond, "condition")) {
[17:48:11.481]                       if (!is.null(pattern)) {
[17:48:11.481]                         computeRestarts <- base::computeRestarts
[17:48:11.481]                         grepl <- base::grepl
[17:48:11.481]                         restarts <- computeRestarts(cond)
[17:48:11.481]                         for (restart in restarts) {
[17:48:11.481]                           name <- restart$name
[17:48:11.481]                           if (is.null(name)) 
[17:48:11.481]                             next
[17:48:11.481]                           if (!grepl(pattern, name)) 
[17:48:11.481]                             next
[17:48:11.481]                           invokeRestart(restart)
[17:48:11.481]                           muffled <- TRUE
[17:48:11.481]                           break
[17:48:11.481]                         }
[17:48:11.481]                       }
[17:48:11.481]                     }
[17:48:11.481]                     invisible(muffled)
[17:48:11.481]                   }
[17:48:11.481]                   muffleCondition(cond)
[17:48:11.481]                 })
[17:48:11.481]             }))
[17:48:11.481]             future::FutureResult(value = ...future.value$value, 
[17:48:11.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.481]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.481]                     ...future.globalenv.names))
[17:48:11.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.481]         }, condition = base::local({
[17:48:11.481]             c <- base::c
[17:48:11.481]             inherits <- base::inherits
[17:48:11.481]             invokeRestart <- base::invokeRestart
[17:48:11.481]             length <- base::length
[17:48:11.481]             list <- base::list
[17:48:11.481]             seq.int <- base::seq.int
[17:48:11.481]             signalCondition <- base::signalCondition
[17:48:11.481]             sys.calls <- base::sys.calls
[17:48:11.481]             `[[` <- base::`[[`
[17:48:11.481]             `+` <- base::`+`
[17:48:11.481]             `<<-` <- base::`<<-`
[17:48:11.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.481]                   3L)]
[17:48:11.481]             }
[17:48:11.481]             function(cond) {
[17:48:11.481]                 is_error <- inherits(cond, "error")
[17:48:11.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.481]                   NULL)
[17:48:11.481]                 if (is_error) {
[17:48:11.481]                   sessionInformation <- function() {
[17:48:11.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.481]                       search = base::search(), system = base::Sys.info())
[17:48:11.481]                   }
[17:48:11.481]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.481]                     cond$call), session = sessionInformation(), 
[17:48:11.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.481]                   signalCondition(cond)
[17:48:11.481]                 }
[17:48:11.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.481]                 "immediateCondition"))) {
[17:48:11.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.481]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.481]                   if (TRUE && !signal) {
[17:48:11.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.481]                     {
[17:48:11.481]                       inherits <- base::inherits
[17:48:11.481]                       invokeRestart <- base::invokeRestart
[17:48:11.481]                       is.null <- base::is.null
[17:48:11.481]                       muffled <- FALSE
[17:48:11.481]                       if (inherits(cond, "message")) {
[17:48:11.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.481]                         if (muffled) 
[17:48:11.481]                           invokeRestart("muffleMessage")
[17:48:11.481]                       }
[17:48:11.481]                       else if (inherits(cond, "warning")) {
[17:48:11.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.481]                         if (muffled) 
[17:48:11.481]                           invokeRestart("muffleWarning")
[17:48:11.481]                       }
[17:48:11.481]                       else if (inherits(cond, "condition")) {
[17:48:11.481]                         if (!is.null(pattern)) {
[17:48:11.481]                           computeRestarts <- base::computeRestarts
[17:48:11.481]                           grepl <- base::grepl
[17:48:11.481]                           restarts <- computeRestarts(cond)
[17:48:11.481]                           for (restart in restarts) {
[17:48:11.481]                             name <- restart$name
[17:48:11.481]                             if (is.null(name)) 
[17:48:11.481]                               next
[17:48:11.481]                             if (!grepl(pattern, name)) 
[17:48:11.481]                               next
[17:48:11.481]                             invokeRestart(restart)
[17:48:11.481]                             muffled <- TRUE
[17:48:11.481]                             break
[17:48:11.481]                           }
[17:48:11.481]                         }
[17:48:11.481]                       }
[17:48:11.481]                       invisible(muffled)
[17:48:11.481]                     }
[17:48:11.481]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.481]                   }
[17:48:11.481]                 }
[17:48:11.481]                 else {
[17:48:11.481]                   if (TRUE) {
[17:48:11.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.481]                     {
[17:48:11.481]                       inherits <- base::inherits
[17:48:11.481]                       invokeRestart <- base::invokeRestart
[17:48:11.481]                       is.null <- base::is.null
[17:48:11.481]                       muffled <- FALSE
[17:48:11.481]                       if (inherits(cond, "message")) {
[17:48:11.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.481]                         if (muffled) 
[17:48:11.481]                           invokeRestart("muffleMessage")
[17:48:11.481]                       }
[17:48:11.481]                       else if (inherits(cond, "warning")) {
[17:48:11.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.481]                         if (muffled) 
[17:48:11.481]                           invokeRestart("muffleWarning")
[17:48:11.481]                       }
[17:48:11.481]                       else if (inherits(cond, "condition")) {
[17:48:11.481]                         if (!is.null(pattern)) {
[17:48:11.481]                           computeRestarts <- base::computeRestarts
[17:48:11.481]                           grepl <- base::grepl
[17:48:11.481]                           restarts <- computeRestarts(cond)
[17:48:11.481]                           for (restart in restarts) {
[17:48:11.481]                             name <- restart$name
[17:48:11.481]                             if (is.null(name)) 
[17:48:11.481]                               next
[17:48:11.481]                             if (!grepl(pattern, name)) 
[17:48:11.481]                               next
[17:48:11.481]                             invokeRestart(restart)
[17:48:11.481]                             muffled <- TRUE
[17:48:11.481]                             break
[17:48:11.481]                           }
[17:48:11.481]                         }
[17:48:11.481]                       }
[17:48:11.481]                       invisible(muffled)
[17:48:11.481]                     }
[17:48:11.481]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.481]                   }
[17:48:11.481]                 }
[17:48:11.481]             }
[17:48:11.481]         }))
[17:48:11.481]     }, error = function(ex) {
[17:48:11.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.481]                 ...future.rng), started = ...future.startTime, 
[17:48:11.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.481]             version = "1.8"), class = "FutureResult")
[17:48:11.481]     }, finally = {
[17:48:11.481]         if (!identical(...future.workdir, getwd())) 
[17:48:11.481]             setwd(...future.workdir)
[17:48:11.481]         {
[17:48:11.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.481]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.481]             }
[17:48:11.481]             base::options(...future.oldOptions)
[17:48:11.481]             if (.Platform$OS.type == "windows") {
[17:48:11.481]                 old_names <- names(...future.oldEnvVars)
[17:48:11.481]                 envs <- base::Sys.getenv()
[17:48:11.481]                 names <- names(envs)
[17:48:11.481]                 common <- intersect(names, old_names)
[17:48:11.481]                 added <- setdiff(names, old_names)
[17:48:11.481]                 removed <- setdiff(old_names, names)
[17:48:11.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.481]                   envs[common]]
[17:48:11.481]                 NAMES <- toupper(changed)
[17:48:11.481]                 args <- list()
[17:48:11.481]                 for (kk in seq_along(NAMES)) {
[17:48:11.481]                   name <- changed[[kk]]
[17:48:11.481]                   NAME <- NAMES[[kk]]
[17:48:11.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.481]                     next
[17:48:11.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.481]                 }
[17:48:11.481]                 NAMES <- toupper(added)
[17:48:11.481]                 for (kk in seq_along(NAMES)) {
[17:48:11.481]                   name <- added[[kk]]
[17:48:11.481]                   NAME <- NAMES[[kk]]
[17:48:11.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.481]                     next
[17:48:11.481]                   args[[name]] <- ""
[17:48:11.481]                 }
[17:48:11.481]                 NAMES <- toupper(removed)
[17:48:11.481]                 for (kk in seq_along(NAMES)) {
[17:48:11.481]                   name <- removed[[kk]]
[17:48:11.481]                   NAME <- NAMES[[kk]]
[17:48:11.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.481]                     next
[17:48:11.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.481]                 }
[17:48:11.481]                 if (length(args) > 0) 
[17:48:11.481]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.481]             }
[17:48:11.481]             else {
[17:48:11.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.481]             }
[17:48:11.481]             {
[17:48:11.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.481]                   0L) {
[17:48:11.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.481]                   base::options(opts)
[17:48:11.481]                 }
[17:48:11.481]                 {
[17:48:11.481]                   {
[17:48:11.481]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.481]                     NULL
[17:48:11.481]                   }
[17:48:11.481]                   options(future.plan = NULL)
[17:48:11.481]                   if (is.na(NA_character_)) 
[17:48:11.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.481]                     .init = FALSE)
[17:48:11.481]                 }
[17:48:11.481]             }
[17:48:11.481]         }
[17:48:11.481]     })
[17:48:11.481]     if (TRUE) {
[17:48:11.481]         base::sink(type = "output", split = FALSE)
[17:48:11.481]         if (TRUE) {
[17:48:11.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.481]         }
[17:48:11.481]         else {
[17:48:11.481]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.481]         }
[17:48:11.481]         base::close(...future.stdout)
[17:48:11.481]         ...future.stdout <- NULL
[17:48:11.481]     }
[17:48:11.481]     ...future.result$conditions <- ...future.conditions
[17:48:11.481]     ...future.result$finished <- base::Sys.time()
[17:48:11.481]     ...future.result
[17:48:11.481] }
[17:48:11.484] MultisessionFuture started
[17:48:11.484] - Launch lazy future ... done
[17:48:11.484] run() for ‘MultisessionFuture’ ... done
[17:48:11.485] resolve() on environment ...
[17:48:11.485]  recursive: 0
[17:48:11.486]  elements: [3] ‘a’
[17:48:11.486] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.486] - Validating connection of MultisessionFuture
[17:48:11.487] - received message: FutureResult
[17:48:11.487] - Received FutureResult
[17:48:11.487] - Erased future from FutureRegistry
[17:48:11.487] result() for ClusterFuture ...
[17:48:11.487] - result already collected: FutureResult
[17:48:11.487] result() for ClusterFuture ... done
[17:48:11.487] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.487] Future #1
[17:48:11.487]  length: 2 (resolved future 1)
[17:48:11.488] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.488] - Validating connection of MultisessionFuture
[17:48:11.488] - received message: FutureResult
[17:48:11.488] - Received FutureResult
[17:48:11.488] - Erased future from FutureRegistry
[17:48:11.488] result() for ClusterFuture ...
[17:48:11.489] - result already collected: FutureResult
[17:48:11.489] result() for ClusterFuture ... done
[17:48:11.489] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.489] Future #2
[17:48:11.489]  length: 1 (resolved future 2)
[17:48:11.489]  length: 0 (resolved future 3)
[17:48:11.489] resolve() on environment ... DONE
[17:48:11.490] resolve() on environment ...
[17:48:11.490]  recursive: 0
[17:48:11.490]  elements: [3] ‘b’
[17:48:11.490] Future #1
[17:48:11.490]  length: 2 (resolved future 1)
[17:48:11.490] Future #2
[17:48:11.491]  length: 1 (resolved future 2)
[17:48:11.491]  length: 0 (resolved future 3)
[17:48:11.491] resolve() on environment ... DONE
[17:48:11.491] resolve() on environment ...
[17:48:11.491]  recursive: 0
[17:48:11.492]  elements: [3] ‘c’
[17:48:11.492] Future #1
[17:48:11.492]  length: 2 (resolved future 1)
[17:48:11.492] Future #2
[17:48:11.492]  length: 1 (resolved future 2)
[17:48:11.492]  length: 0 (resolved future 3)
[17:48:11.492] resolve() on environment ... DONE
[17:48:11.493] resolve() on environment ...
[17:48:11.493]  recursive: 0
[17:48:11.493]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:48:11.493] Future #1
[17:48:11.494] result() for ClusterFuture ...
[17:48:11.494] - result already collected: FutureResult
[17:48:11.494] result() for ClusterFuture ... done
[17:48:11.494] result() for ClusterFuture ...
[17:48:11.494] - result already collected: FutureResult
[17:48:11.494] result() for ClusterFuture ... done
[17:48:11.494]  length: 2 (resolved future 1)
[17:48:11.494] Future #2
[17:48:11.494] result() for ClusterFuture ...
[17:48:11.494] - result already collected: FutureResult
[17:48:11.494] result() for ClusterFuture ... done
[17:48:11.495] result() for ClusterFuture ...
[17:48:11.495] - result already collected: FutureResult
[17:48:11.495] result() for ClusterFuture ... done
[17:48:11.495]  length: 1 (resolved future 2)
[17:48:11.495]  length: 0 (resolved future 3)
[17:48:11.495] resolve() on environment ... DONE
[17:48:11.496] resolve() on environment ...
[17:48:11.496]  recursive: 99
[17:48:11.496]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:48:11.496] Future #1
[17:48:11.496] result() for ClusterFuture ...
[17:48:11.496] - result already collected: FutureResult
[17:48:11.496] result() for ClusterFuture ... done
[17:48:11.497] result() for ClusterFuture ...
[17:48:11.497] - result already collected: FutureResult
[17:48:11.497] result() for ClusterFuture ... done
[17:48:11.497] A MultisessionFuture was resolved
[17:48:11.497]  length: 2 (resolved future 1)
[17:48:11.497] Future #2
[17:48:11.497] result() for ClusterFuture ...
[17:48:11.497] - result already collected: FutureResult
[17:48:11.497] result() for ClusterFuture ... done
[17:48:11.497] result() for ClusterFuture ...
[17:48:11.497] - result already collected: FutureResult
[17:48:11.498] result() for ClusterFuture ... done
[17:48:11.498] A MultisessionFuture was resolved
[17:48:11.498]  length: 1 (resolved future 2)
[17:48:11.498]  length: 0 (resolved future 3)
[17:48:11.498] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:48:11.499] resolve() on list environment ...
[17:48:11.499]  recursive: 0
[17:48:11.499]  length: 2
[17:48:11.499]  elements: ‘a’, ‘b’
[17:48:11.499]  length: 1 (resolved future 1)
[17:48:11.500]  length: 0 (resolved future 2)
[17:48:11.500] resolve() on list environment ... DONE
[17:48:11.500] getGlobalsAndPackages() ...
[17:48:11.500] Searching for globals...
[17:48:11.500] 
[17:48:11.500] Searching for globals ... DONE
[17:48:11.500] - globals: [0] <none>
[17:48:11.500] getGlobalsAndPackages() ... DONE
[17:48:11.501] run() for ‘Future’ ...
[17:48:11.501] - state: ‘created’
[17:48:11.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.515]   - Field: ‘node’
[17:48:11.515]   - Field: ‘label’
[17:48:11.515]   - Field: ‘local’
[17:48:11.515]   - Field: ‘owner’
[17:48:11.515]   - Field: ‘envir’
[17:48:11.515]   - Field: ‘workers’
[17:48:11.515]   - Field: ‘packages’
[17:48:11.515]   - Field: ‘gc’
[17:48:11.515]   - Field: ‘conditions’
[17:48:11.516]   - Field: ‘persistent’
[17:48:11.516]   - Field: ‘expr’
[17:48:11.516]   - Field: ‘uuid’
[17:48:11.516]   - Field: ‘seed’
[17:48:11.516]   - Field: ‘version’
[17:48:11.516]   - Field: ‘result’
[17:48:11.516]   - Field: ‘asynchronous’
[17:48:11.516]   - Field: ‘calls’
[17:48:11.516]   - Field: ‘globals’
[17:48:11.516]   - Field: ‘stdout’
[17:48:11.516]   - Field: ‘earlySignal’
[17:48:11.517]   - Field: ‘lazy’
[17:48:11.517]   - Field: ‘state’
[17:48:11.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.517] - Launch lazy future ...
[17:48:11.517] Packages needed by the future expression (n = 0): <none>
[17:48:11.517] Packages needed by future strategies (n = 0): <none>
[17:48:11.518] {
[17:48:11.518]     {
[17:48:11.518]         {
[17:48:11.518]             ...future.startTime <- base::Sys.time()
[17:48:11.518]             {
[17:48:11.518]                 {
[17:48:11.518]                   {
[17:48:11.518]                     {
[17:48:11.518]                       base::local({
[17:48:11.518]                         has_future <- base::requireNamespace("future", 
[17:48:11.518]                           quietly = TRUE)
[17:48:11.518]                         if (has_future) {
[17:48:11.518]                           ns <- base::getNamespace("future")
[17:48:11.518]                           version <- ns[[".package"]][["version"]]
[17:48:11.518]                           if (is.null(version)) 
[17:48:11.518]                             version <- utils::packageVersion("future")
[17:48:11.518]                         }
[17:48:11.518]                         else {
[17:48:11.518]                           version <- NULL
[17:48:11.518]                         }
[17:48:11.518]                         if (!has_future || version < "1.8.0") {
[17:48:11.518]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.518]                             "", base::R.version$version.string), 
[17:48:11.518]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.518]                               "release", "version")], collapse = " "), 
[17:48:11.518]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.518]                             info)
[17:48:11.518]                           info <- base::paste(info, collapse = "; ")
[17:48:11.518]                           if (!has_future) {
[17:48:11.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.518]                               info)
[17:48:11.518]                           }
[17:48:11.518]                           else {
[17:48:11.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.518]                               info, version)
[17:48:11.518]                           }
[17:48:11.518]                           base::stop(msg)
[17:48:11.518]                         }
[17:48:11.518]                       })
[17:48:11.518]                     }
[17:48:11.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.518]                     base::options(mc.cores = 1L)
[17:48:11.518]                   }
[17:48:11.518]                   ...future.strategy.old <- future::plan("list")
[17:48:11.518]                   options(future.plan = NULL)
[17:48:11.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.518]                 }
[17:48:11.518]                 ...future.workdir <- getwd()
[17:48:11.518]             }
[17:48:11.518]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.518]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.518]         }
[17:48:11.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.518]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.518]             base::names(...future.oldOptions))
[17:48:11.518]     }
[17:48:11.518]     if (FALSE) {
[17:48:11.518]     }
[17:48:11.518]     else {
[17:48:11.518]         if (TRUE) {
[17:48:11.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.518]                 open = "w")
[17:48:11.518]         }
[17:48:11.518]         else {
[17:48:11.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.518]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.518]         }
[17:48:11.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.518]             base::sink(type = "output", split = FALSE)
[17:48:11.518]             base::close(...future.stdout)
[17:48:11.518]         }, add = TRUE)
[17:48:11.518]     }
[17:48:11.518]     ...future.frame <- base::sys.nframe()
[17:48:11.518]     ...future.conditions <- base::list()
[17:48:11.518]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.518]     if (FALSE) {
[17:48:11.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.518]     }
[17:48:11.518]     ...future.result <- base::tryCatch({
[17:48:11.518]         base::withCallingHandlers({
[17:48:11.518]             ...future.value <- base::withVisible(base::local({
[17:48:11.518]                 ...future.makeSendCondition <- base::local({
[17:48:11.518]                   sendCondition <- NULL
[17:48:11.518]                   function(frame = 1L) {
[17:48:11.518]                     if (is.function(sendCondition)) 
[17:48:11.518]                       return(sendCondition)
[17:48:11.518]                     ns <- getNamespace("parallel")
[17:48:11.518]                     if (exists("sendData", mode = "function", 
[17:48:11.518]                       envir = ns)) {
[17:48:11.518]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.518]                         envir = ns)
[17:48:11.518]                       envir <- sys.frame(frame)
[17:48:11.518]                       master <- NULL
[17:48:11.518]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.518]                         !identical(envir, emptyenv())) {
[17:48:11.518]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.518]                           inherits = FALSE)) {
[17:48:11.518]                           master <- get("master", mode = "list", 
[17:48:11.518]                             envir = envir, inherits = FALSE)
[17:48:11.518]                           if (inherits(master, c("SOCKnode", 
[17:48:11.518]                             "SOCK0node"))) {
[17:48:11.518]                             sendCondition <<- function(cond) {
[17:48:11.518]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.518]                                 success = TRUE)
[17:48:11.518]                               parallel_sendData(master, data)
[17:48:11.518]                             }
[17:48:11.518]                             return(sendCondition)
[17:48:11.518]                           }
[17:48:11.518]                         }
[17:48:11.518]                         frame <- frame + 1L
[17:48:11.518]                         envir <- sys.frame(frame)
[17:48:11.518]                       }
[17:48:11.518]                     }
[17:48:11.518]                     sendCondition <<- function(cond) NULL
[17:48:11.518]                   }
[17:48:11.518]                 })
[17:48:11.518]                 withCallingHandlers({
[17:48:11.518]                   1
[17:48:11.518]                 }, immediateCondition = function(cond) {
[17:48:11.518]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.518]                   sendCondition(cond)
[17:48:11.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.518]                   {
[17:48:11.518]                     inherits <- base::inherits
[17:48:11.518]                     invokeRestart <- base::invokeRestart
[17:48:11.518]                     is.null <- base::is.null
[17:48:11.518]                     muffled <- FALSE
[17:48:11.518]                     if (inherits(cond, "message")) {
[17:48:11.518]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.518]                       if (muffled) 
[17:48:11.518]                         invokeRestart("muffleMessage")
[17:48:11.518]                     }
[17:48:11.518]                     else if (inherits(cond, "warning")) {
[17:48:11.518]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.518]                       if (muffled) 
[17:48:11.518]                         invokeRestart("muffleWarning")
[17:48:11.518]                     }
[17:48:11.518]                     else if (inherits(cond, "condition")) {
[17:48:11.518]                       if (!is.null(pattern)) {
[17:48:11.518]                         computeRestarts <- base::computeRestarts
[17:48:11.518]                         grepl <- base::grepl
[17:48:11.518]                         restarts <- computeRestarts(cond)
[17:48:11.518]                         for (restart in restarts) {
[17:48:11.518]                           name <- restart$name
[17:48:11.518]                           if (is.null(name)) 
[17:48:11.518]                             next
[17:48:11.518]                           if (!grepl(pattern, name)) 
[17:48:11.518]                             next
[17:48:11.518]                           invokeRestart(restart)
[17:48:11.518]                           muffled <- TRUE
[17:48:11.518]                           break
[17:48:11.518]                         }
[17:48:11.518]                       }
[17:48:11.518]                     }
[17:48:11.518]                     invisible(muffled)
[17:48:11.518]                   }
[17:48:11.518]                   muffleCondition(cond)
[17:48:11.518]                 })
[17:48:11.518]             }))
[17:48:11.518]             future::FutureResult(value = ...future.value$value, 
[17:48:11.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.518]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.518]                     ...future.globalenv.names))
[17:48:11.518]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.518]         }, condition = base::local({
[17:48:11.518]             c <- base::c
[17:48:11.518]             inherits <- base::inherits
[17:48:11.518]             invokeRestart <- base::invokeRestart
[17:48:11.518]             length <- base::length
[17:48:11.518]             list <- base::list
[17:48:11.518]             seq.int <- base::seq.int
[17:48:11.518]             signalCondition <- base::signalCondition
[17:48:11.518]             sys.calls <- base::sys.calls
[17:48:11.518]             `[[` <- base::`[[`
[17:48:11.518]             `+` <- base::`+`
[17:48:11.518]             `<<-` <- base::`<<-`
[17:48:11.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.518]                   3L)]
[17:48:11.518]             }
[17:48:11.518]             function(cond) {
[17:48:11.518]                 is_error <- inherits(cond, "error")
[17:48:11.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.518]                   NULL)
[17:48:11.518]                 if (is_error) {
[17:48:11.518]                   sessionInformation <- function() {
[17:48:11.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.518]                       search = base::search(), system = base::Sys.info())
[17:48:11.518]                   }
[17:48:11.518]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.518]                     cond$call), session = sessionInformation(), 
[17:48:11.518]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.518]                   signalCondition(cond)
[17:48:11.518]                 }
[17:48:11.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.518]                 "immediateCondition"))) {
[17:48:11.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.518]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.518]                   if (TRUE && !signal) {
[17:48:11.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.518]                     {
[17:48:11.518]                       inherits <- base::inherits
[17:48:11.518]                       invokeRestart <- base::invokeRestart
[17:48:11.518]                       is.null <- base::is.null
[17:48:11.518]                       muffled <- FALSE
[17:48:11.518]                       if (inherits(cond, "message")) {
[17:48:11.518]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.518]                         if (muffled) 
[17:48:11.518]                           invokeRestart("muffleMessage")
[17:48:11.518]                       }
[17:48:11.518]                       else if (inherits(cond, "warning")) {
[17:48:11.518]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.518]                         if (muffled) 
[17:48:11.518]                           invokeRestart("muffleWarning")
[17:48:11.518]                       }
[17:48:11.518]                       else if (inherits(cond, "condition")) {
[17:48:11.518]                         if (!is.null(pattern)) {
[17:48:11.518]                           computeRestarts <- base::computeRestarts
[17:48:11.518]                           grepl <- base::grepl
[17:48:11.518]                           restarts <- computeRestarts(cond)
[17:48:11.518]                           for (restart in restarts) {
[17:48:11.518]                             name <- restart$name
[17:48:11.518]                             if (is.null(name)) 
[17:48:11.518]                               next
[17:48:11.518]                             if (!grepl(pattern, name)) 
[17:48:11.518]                               next
[17:48:11.518]                             invokeRestart(restart)
[17:48:11.518]                             muffled <- TRUE
[17:48:11.518]                             break
[17:48:11.518]                           }
[17:48:11.518]                         }
[17:48:11.518]                       }
[17:48:11.518]                       invisible(muffled)
[17:48:11.518]                     }
[17:48:11.518]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.518]                   }
[17:48:11.518]                 }
[17:48:11.518]                 else {
[17:48:11.518]                   if (TRUE) {
[17:48:11.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.518]                     {
[17:48:11.518]                       inherits <- base::inherits
[17:48:11.518]                       invokeRestart <- base::invokeRestart
[17:48:11.518]                       is.null <- base::is.null
[17:48:11.518]                       muffled <- FALSE
[17:48:11.518]                       if (inherits(cond, "message")) {
[17:48:11.518]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.518]                         if (muffled) 
[17:48:11.518]                           invokeRestart("muffleMessage")
[17:48:11.518]                       }
[17:48:11.518]                       else if (inherits(cond, "warning")) {
[17:48:11.518]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.518]                         if (muffled) 
[17:48:11.518]                           invokeRestart("muffleWarning")
[17:48:11.518]                       }
[17:48:11.518]                       else if (inherits(cond, "condition")) {
[17:48:11.518]                         if (!is.null(pattern)) {
[17:48:11.518]                           computeRestarts <- base::computeRestarts
[17:48:11.518]                           grepl <- base::grepl
[17:48:11.518]                           restarts <- computeRestarts(cond)
[17:48:11.518]                           for (restart in restarts) {
[17:48:11.518]                             name <- restart$name
[17:48:11.518]                             if (is.null(name)) 
[17:48:11.518]                               next
[17:48:11.518]                             if (!grepl(pattern, name)) 
[17:48:11.518]                               next
[17:48:11.518]                             invokeRestart(restart)
[17:48:11.518]                             muffled <- TRUE
[17:48:11.518]                             break
[17:48:11.518]                           }
[17:48:11.518]                         }
[17:48:11.518]                       }
[17:48:11.518]                       invisible(muffled)
[17:48:11.518]                     }
[17:48:11.518]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.518]                   }
[17:48:11.518]                 }
[17:48:11.518]             }
[17:48:11.518]         }))
[17:48:11.518]     }, error = function(ex) {
[17:48:11.518]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.518]                 ...future.rng), started = ...future.startTime, 
[17:48:11.518]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.518]             version = "1.8"), class = "FutureResult")
[17:48:11.518]     }, finally = {
[17:48:11.518]         if (!identical(...future.workdir, getwd())) 
[17:48:11.518]             setwd(...future.workdir)
[17:48:11.518]         {
[17:48:11.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.518]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.518]             }
[17:48:11.518]             base::options(...future.oldOptions)
[17:48:11.518]             if (.Platform$OS.type == "windows") {
[17:48:11.518]                 old_names <- names(...future.oldEnvVars)
[17:48:11.518]                 envs <- base::Sys.getenv()
[17:48:11.518]                 names <- names(envs)
[17:48:11.518]                 common <- intersect(names, old_names)
[17:48:11.518]                 added <- setdiff(names, old_names)
[17:48:11.518]                 removed <- setdiff(old_names, names)
[17:48:11.518]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.518]                   envs[common]]
[17:48:11.518]                 NAMES <- toupper(changed)
[17:48:11.518]                 args <- list()
[17:48:11.518]                 for (kk in seq_along(NAMES)) {
[17:48:11.518]                   name <- changed[[kk]]
[17:48:11.518]                   NAME <- NAMES[[kk]]
[17:48:11.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.518]                     next
[17:48:11.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.518]                 }
[17:48:11.518]                 NAMES <- toupper(added)
[17:48:11.518]                 for (kk in seq_along(NAMES)) {
[17:48:11.518]                   name <- added[[kk]]
[17:48:11.518]                   NAME <- NAMES[[kk]]
[17:48:11.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.518]                     next
[17:48:11.518]                   args[[name]] <- ""
[17:48:11.518]                 }
[17:48:11.518]                 NAMES <- toupper(removed)
[17:48:11.518]                 for (kk in seq_along(NAMES)) {
[17:48:11.518]                   name <- removed[[kk]]
[17:48:11.518]                   NAME <- NAMES[[kk]]
[17:48:11.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.518]                     next
[17:48:11.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.518]                 }
[17:48:11.518]                 if (length(args) > 0) 
[17:48:11.518]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.518]             }
[17:48:11.518]             else {
[17:48:11.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.518]             }
[17:48:11.518]             {
[17:48:11.518]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.518]                   0L) {
[17:48:11.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.518]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.518]                   base::options(opts)
[17:48:11.518]                 }
[17:48:11.518]                 {
[17:48:11.518]                   {
[17:48:11.518]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.518]                     NULL
[17:48:11.518]                   }
[17:48:11.518]                   options(future.plan = NULL)
[17:48:11.518]                   if (is.na(NA_character_)) 
[17:48:11.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.518]                     .init = FALSE)
[17:48:11.518]                 }
[17:48:11.518]             }
[17:48:11.518]         }
[17:48:11.518]     })
[17:48:11.518]     if (TRUE) {
[17:48:11.518]         base::sink(type = "output", split = FALSE)
[17:48:11.518]         if (TRUE) {
[17:48:11.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.518]         }
[17:48:11.518]         else {
[17:48:11.518]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.518]         }
[17:48:11.518]         base::close(...future.stdout)
[17:48:11.518]         ...future.stdout <- NULL
[17:48:11.518]     }
[17:48:11.518]     ...future.result$conditions <- ...future.conditions
[17:48:11.518]     ...future.result$finished <- base::Sys.time()
[17:48:11.518]     ...future.result
[17:48:11.518] }
[17:48:11.520] MultisessionFuture started
[17:48:11.521] - Launch lazy future ... done
[17:48:11.521] run() for ‘MultisessionFuture’ ... done
[17:48:11.521] getGlobalsAndPackages() ...
[17:48:11.521] Searching for globals...
[17:48:11.521] 
[17:48:11.521] Searching for globals ... DONE
[17:48:11.521] - globals: [0] <none>
[17:48:11.521] getGlobalsAndPackages() ... DONE
[17:48:11.522] run() for ‘Future’ ...
[17:48:11.522] - state: ‘created’
[17:48:11.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.535] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.535]   - Field: ‘node’
[17:48:11.535]   - Field: ‘label’
[17:48:11.535]   - Field: ‘local’
[17:48:11.536]   - Field: ‘owner’
[17:48:11.536]   - Field: ‘envir’
[17:48:11.536]   - Field: ‘workers’
[17:48:11.536]   - Field: ‘packages’
[17:48:11.536]   - Field: ‘gc’
[17:48:11.536]   - Field: ‘conditions’
[17:48:11.536]   - Field: ‘persistent’
[17:48:11.536]   - Field: ‘expr’
[17:48:11.536]   - Field: ‘uuid’
[17:48:11.536]   - Field: ‘seed’
[17:48:11.536]   - Field: ‘version’
[17:48:11.537]   - Field: ‘result’
[17:48:11.537]   - Field: ‘asynchronous’
[17:48:11.537]   - Field: ‘calls’
[17:48:11.537]   - Field: ‘globals’
[17:48:11.537]   - Field: ‘stdout’
[17:48:11.537]   - Field: ‘earlySignal’
[17:48:11.537]   - Field: ‘lazy’
[17:48:11.537]   - Field: ‘state’
[17:48:11.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.537] - Launch lazy future ...
[17:48:11.538] Packages needed by the future expression (n = 0): <none>
[17:48:11.538] Packages needed by future strategies (n = 0): <none>
[17:48:11.538] {
[17:48:11.538]     {
[17:48:11.538]         {
[17:48:11.538]             ...future.startTime <- base::Sys.time()
[17:48:11.538]             {
[17:48:11.538]                 {
[17:48:11.538]                   {
[17:48:11.538]                     {
[17:48:11.538]                       base::local({
[17:48:11.538]                         has_future <- base::requireNamespace("future", 
[17:48:11.538]                           quietly = TRUE)
[17:48:11.538]                         if (has_future) {
[17:48:11.538]                           ns <- base::getNamespace("future")
[17:48:11.538]                           version <- ns[[".package"]][["version"]]
[17:48:11.538]                           if (is.null(version)) 
[17:48:11.538]                             version <- utils::packageVersion("future")
[17:48:11.538]                         }
[17:48:11.538]                         else {
[17:48:11.538]                           version <- NULL
[17:48:11.538]                         }
[17:48:11.538]                         if (!has_future || version < "1.8.0") {
[17:48:11.538]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.538]                             "", base::R.version$version.string), 
[17:48:11.538]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.538]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.538]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.538]                               "release", "version")], collapse = " "), 
[17:48:11.538]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.538]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.538]                             info)
[17:48:11.538]                           info <- base::paste(info, collapse = "; ")
[17:48:11.538]                           if (!has_future) {
[17:48:11.538]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.538]                               info)
[17:48:11.538]                           }
[17:48:11.538]                           else {
[17:48:11.538]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.538]                               info, version)
[17:48:11.538]                           }
[17:48:11.538]                           base::stop(msg)
[17:48:11.538]                         }
[17:48:11.538]                       })
[17:48:11.538]                     }
[17:48:11.538]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.538]                     base::options(mc.cores = 1L)
[17:48:11.538]                   }
[17:48:11.538]                   ...future.strategy.old <- future::plan("list")
[17:48:11.538]                   options(future.plan = NULL)
[17:48:11.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.538]                 }
[17:48:11.538]                 ...future.workdir <- getwd()
[17:48:11.538]             }
[17:48:11.538]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.538]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.538]         }
[17:48:11.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.538]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.538]             base::names(...future.oldOptions))
[17:48:11.538]     }
[17:48:11.538]     if (FALSE) {
[17:48:11.538]     }
[17:48:11.538]     else {
[17:48:11.538]         if (TRUE) {
[17:48:11.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.538]                 open = "w")
[17:48:11.538]         }
[17:48:11.538]         else {
[17:48:11.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.538]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.538]         }
[17:48:11.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.538]             base::sink(type = "output", split = FALSE)
[17:48:11.538]             base::close(...future.stdout)
[17:48:11.538]         }, add = TRUE)
[17:48:11.538]     }
[17:48:11.538]     ...future.frame <- base::sys.nframe()
[17:48:11.538]     ...future.conditions <- base::list()
[17:48:11.538]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.538]     if (FALSE) {
[17:48:11.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.538]     }
[17:48:11.538]     ...future.result <- base::tryCatch({
[17:48:11.538]         base::withCallingHandlers({
[17:48:11.538]             ...future.value <- base::withVisible(base::local({
[17:48:11.538]                 ...future.makeSendCondition <- base::local({
[17:48:11.538]                   sendCondition <- NULL
[17:48:11.538]                   function(frame = 1L) {
[17:48:11.538]                     if (is.function(sendCondition)) 
[17:48:11.538]                       return(sendCondition)
[17:48:11.538]                     ns <- getNamespace("parallel")
[17:48:11.538]                     if (exists("sendData", mode = "function", 
[17:48:11.538]                       envir = ns)) {
[17:48:11.538]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.538]                         envir = ns)
[17:48:11.538]                       envir <- sys.frame(frame)
[17:48:11.538]                       master <- NULL
[17:48:11.538]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.538]                         !identical(envir, emptyenv())) {
[17:48:11.538]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.538]                           inherits = FALSE)) {
[17:48:11.538]                           master <- get("master", mode = "list", 
[17:48:11.538]                             envir = envir, inherits = FALSE)
[17:48:11.538]                           if (inherits(master, c("SOCKnode", 
[17:48:11.538]                             "SOCK0node"))) {
[17:48:11.538]                             sendCondition <<- function(cond) {
[17:48:11.538]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.538]                                 success = TRUE)
[17:48:11.538]                               parallel_sendData(master, data)
[17:48:11.538]                             }
[17:48:11.538]                             return(sendCondition)
[17:48:11.538]                           }
[17:48:11.538]                         }
[17:48:11.538]                         frame <- frame + 1L
[17:48:11.538]                         envir <- sys.frame(frame)
[17:48:11.538]                       }
[17:48:11.538]                     }
[17:48:11.538]                     sendCondition <<- function(cond) NULL
[17:48:11.538]                   }
[17:48:11.538]                 })
[17:48:11.538]                 withCallingHandlers({
[17:48:11.538]                   2
[17:48:11.538]                 }, immediateCondition = function(cond) {
[17:48:11.538]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.538]                   sendCondition(cond)
[17:48:11.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.538]                   {
[17:48:11.538]                     inherits <- base::inherits
[17:48:11.538]                     invokeRestart <- base::invokeRestart
[17:48:11.538]                     is.null <- base::is.null
[17:48:11.538]                     muffled <- FALSE
[17:48:11.538]                     if (inherits(cond, "message")) {
[17:48:11.538]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.538]                       if (muffled) 
[17:48:11.538]                         invokeRestart("muffleMessage")
[17:48:11.538]                     }
[17:48:11.538]                     else if (inherits(cond, "warning")) {
[17:48:11.538]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.538]                       if (muffled) 
[17:48:11.538]                         invokeRestart("muffleWarning")
[17:48:11.538]                     }
[17:48:11.538]                     else if (inherits(cond, "condition")) {
[17:48:11.538]                       if (!is.null(pattern)) {
[17:48:11.538]                         computeRestarts <- base::computeRestarts
[17:48:11.538]                         grepl <- base::grepl
[17:48:11.538]                         restarts <- computeRestarts(cond)
[17:48:11.538]                         for (restart in restarts) {
[17:48:11.538]                           name <- restart$name
[17:48:11.538]                           if (is.null(name)) 
[17:48:11.538]                             next
[17:48:11.538]                           if (!grepl(pattern, name)) 
[17:48:11.538]                             next
[17:48:11.538]                           invokeRestart(restart)
[17:48:11.538]                           muffled <- TRUE
[17:48:11.538]                           break
[17:48:11.538]                         }
[17:48:11.538]                       }
[17:48:11.538]                     }
[17:48:11.538]                     invisible(muffled)
[17:48:11.538]                   }
[17:48:11.538]                   muffleCondition(cond)
[17:48:11.538]                 })
[17:48:11.538]             }))
[17:48:11.538]             future::FutureResult(value = ...future.value$value, 
[17:48:11.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.538]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.538]                     ...future.globalenv.names))
[17:48:11.538]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.538]         }, condition = base::local({
[17:48:11.538]             c <- base::c
[17:48:11.538]             inherits <- base::inherits
[17:48:11.538]             invokeRestart <- base::invokeRestart
[17:48:11.538]             length <- base::length
[17:48:11.538]             list <- base::list
[17:48:11.538]             seq.int <- base::seq.int
[17:48:11.538]             signalCondition <- base::signalCondition
[17:48:11.538]             sys.calls <- base::sys.calls
[17:48:11.538]             `[[` <- base::`[[`
[17:48:11.538]             `+` <- base::`+`
[17:48:11.538]             `<<-` <- base::`<<-`
[17:48:11.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.538]                   3L)]
[17:48:11.538]             }
[17:48:11.538]             function(cond) {
[17:48:11.538]                 is_error <- inherits(cond, "error")
[17:48:11.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.538]                   NULL)
[17:48:11.538]                 if (is_error) {
[17:48:11.538]                   sessionInformation <- function() {
[17:48:11.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.538]                       search = base::search(), system = base::Sys.info())
[17:48:11.538]                   }
[17:48:11.538]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.538]                     cond$call), session = sessionInformation(), 
[17:48:11.538]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.538]                   signalCondition(cond)
[17:48:11.538]                 }
[17:48:11.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.538]                 "immediateCondition"))) {
[17:48:11.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.538]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.538]                   if (TRUE && !signal) {
[17:48:11.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.538]                     {
[17:48:11.538]                       inherits <- base::inherits
[17:48:11.538]                       invokeRestart <- base::invokeRestart
[17:48:11.538]                       is.null <- base::is.null
[17:48:11.538]                       muffled <- FALSE
[17:48:11.538]                       if (inherits(cond, "message")) {
[17:48:11.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.538]                         if (muffled) 
[17:48:11.538]                           invokeRestart("muffleMessage")
[17:48:11.538]                       }
[17:48:11.538]                       else if (inherits(cond, "warning")) {
[17:48:11.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.538]                         if (muffled) 
[17:48:11.538]                           invokeRestart("muffleWarning")
[17:48:11.538]                       }
[17:48:11.538]                       else if (inherits(cond, "condition")) {
[17:48:11.538]                         if (!is.null(pattern)) {
[17:48:11.538]                           computeRestarts <- base::computeRestarts
[17:48:11.538]                           grepl <- base::grepl
[17:48:11.538]                           restarts <- computeRestarts(cond)
[17:48:11.538]                           for (restart in restarts) {
[17:48:11.538]                             name <- restart$name
[17:48:11.538]                             if (is.null(name)) 
[17:48:11.538]                               next
[17:48:11.538]                             if (!grepl(pattern, name)) 
[17:48:11.538]                               next
[17:48:11.538]                             invokeRestart(restart)
[17:48:11.538]                             muffled <- TRUE
[17:48:11.538]                             break
[17:48:11.538]                           }
[17:48:11.538]                         }
[17:48:11.538]                       }
[17:48:11.538]                       invisible(muffled)
[17:48:11.538]                     }
[17:48:11.538]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.538]                   }
[17:48:11.538]                 }
[17:48:11.538]                 else {
[17:48:11.538]                   if (TRUE) {
[17:48:11.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.538]                     {
[17:48:11.538]                       inherits <- base::inherits
[17:48:11.538]                       invokeRestart <- base::invokeRestart
[17:48:11.538]                       is.null <- base::is.null
[17:48:11.538]                       muffled <- FALSE
[17:48:11.538]                       if (inherits(cond, "message")) {
[17:48:11.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.538]                         if (muffled) 
[17:48:11.538]                           invokeRestart("muffleMessage")
[17:48:11.538]                       }
[17:48:11.538]                       else if (inherits(cond, "warning")) {
[17:48:11.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.538]                         if (muffled) 
[17:48:11.538]                           invokeRestart("muffleWarning")
[17:48:11.538]                       }
[17:48:11.538]                       else if (inherits(cond, "condition")) {
[17:48:11.538]                         if (!is.null(pattern)) {
[17:48:11.538]                           computeRestarts <- base::computeRestarts
[17:48:11.538]                           grepl <- base::grepl
[17:48:11.538]                           restarts <- computeRestarts(cond)
[17:48:11.538]                           for (restart in restarts) {
[17:48:11.538]                             name <- restart$name
[17:48:11.538]                             if (is.null(name)) 
[17:48:11.538]                               next
[17:48:11.538]                             if (!grepl(pattern, name)) 
[17:48:11.538]                               next
[17:48:11.538]                             invokeRestart(restart)
[17:48:11.538]                             muffled <- TRUE
[17:48:11.538]                             break
[17:48:11.538]                           }
[17:48:11.538]                         }
[17:48:11.538]                       }
[17:48:11.538]                       invisible(muffled)
[17:48:11.538]                     }
[17:48:11.538]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.538]                   }
[17:48:11.538]                 }
[17:48:11.538]             }
[17:48:11.538]         }))
[17:48:11.538]     }, error = function(ex) {
[17:48:11.538]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.538]                 ...future.rng), started = ...future.startTime, 
[17:48:11.538]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.538]             version = "1.8"), class = "FutureResult")
[17:48:11.538]     }, finally = {
[17:48:11.538]         if (!identical(...future.workdir, getwd())) 
[17:48:11.538]             setwd(...future.workdir)
[17:48:11.538]         {
[17:48:11.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.538]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.538]             }
[17:48:11.538]             base::options(...future.oldOptions)
[17:48:11.538]             if (.Platform$OS.type == "windows") {
[17:48:11.538]                 old_names <- names(...future.oldEnvVars)
[17:48:11.538]                 envs <- base::Sys.getenv()
[17:48:11.538]                 names <- names(envs)
[17:48:11.538]                 common <- intersect(names, old_names)
[17:48:11.538]                 added <- setdiff(names, old_names)
[17:48:11.538]                 removed <- setdiff(old_names, names)
[17:48:11.538]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.538]                   envs[common]]
[17:48:11.538]                 NAMES <- toupper(changed)
[17:48:11.538]                 args <- list()
[17:48:11.538]                 for (kk in seq_along(NAMES)) {
[17:48:11.538]                   name <- changed[[kk]]
[17:48:11.538]                   NAME <- NAMES[[kk]]
[17:48:11.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.538]                     next
[17:48:11.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.538]                 }
[17:48:11.538]                 NAMES <- toupper(added)
[17:48:11.538]                 for (kk in seq_along(NAMES)) {
[17:48:11.538]                   name <- added[[kk]]
[17:48:11.538]                   NAME <- NAMES[[kk]]
[17:48:11.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.538]                     next
[17:48:11.538]                   args[[name]] <- ""
[17:48:11.538]                 }
[17:48:11.538]                 NAMES <- toupper(removed)
[17:48:11.538]                 for (kk in seq_along(NAMES)) {
[17:48:11.538]                   name <- removed[[kk]]
[17:48:11.538]                   NAME <- NAMES[[kk]]
[17:48:11.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.538]                     next
[17:48:11.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.538]                 }
[17:48:11.538]                 if (length(args) > 0) 
[17:48:11.538]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.538]             }
[17:48:11.538]             else {
[17:48:11.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.538]             }
[17:48:11.538]             {
[17:48:11.538]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.538]                   0L) {
[17:48:11.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.538]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.538]                   base::options(opts)
[17:48:11.538]                 }
[17:48:11.538]                 {
[17:48:11.538]                   {
[17:48:11.538]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.538]                     NULL
[17:48:11.538]                   }
[17:48:11.538]                   options(future.plan = NULL)
[17:48:11.538]                   if (is.na(NA_character_)) 
[17:48:11.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.538]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.538]                     .init = FALSE)
[17:48:11.538]                 }
[17:48:11.538]             }
[17:48:11.538]         }
[17:48:11.538]     })
[17:48:11.538]     if (TRUE) {
[17:48:11.538]         base::sink(type = "output", split = FALSE)
[17:48:11.538]         if (TRUE) {
[17:48:11.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.538]         }
[17:48:11.538]         else {
[17:48:11.538]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.538]         }
[17:48:11.538]         base::close(...future.stdout)
[17:48:11.538]         ...future.stdout <- NULL
[17:48:11.538]     }
[17:48:11.538]     ...future.result$conditions <- ...future.conditions
[17:48:11.538]     ...future.result$finished <- base::Sys.time()
[17:48:11.538]     ...future.result
[17:48:11.538] }
[17:48:11.541] MultisessionFuture started
[17:48:11.541] - Launch lazy future ... done
[17:48:11.541] run() for ‘MultisessionFuture’ ... done
[17:48:11.542] resolve() on list environment ...
[17:48:11.542]  recursive: 0
[17:48:11.542]  length: 3
[17:48:11.542]  elements: ‘a’, ‘b’, ‘c’
[17:48:11.543] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.543] - Validating connection of MultisessionFuture
[17:48:11.543] - received message: FutureResult
[17:48:11.543] - Received FutureResult
[17:48:11.543] - Erased future from FutureRegistry
[17:48:11.544] result() for ClusterFuture ...
[17:48:11.544] - result already collected: FutureResult
[17:48:11.544] result() for ClusterFuture ... done
[17:48:11.544] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.544] Future #1
[17:48:11.544]  length: 2 (resolved future 1)
[17:48:11.544] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.545] - Validating connection of MultisessionFuture
[17:48:11.545] - received message: FutureResult
[17:48:11.545] - Received FutureResult
[17:48:11.545] - Erased future from FutureRegistry
[17:48:11.545] result() for ClusterFuture ...
[17:48:11.545] - result already collected: FutureResult
[17:48:11.545] result() for ClusterFuture ... done
[17:48:11.545] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.545] Future #2
[17:48:11.545]  length: 1 (resolved future 2)
[17:48:11.546]  length: 0 (resolved future 3)
[17:48:11.546] resolve() on list environment ... DONE
[17:48:11.546] getGlobalsAndPackages() ...
[17:48:11.546] Searching for globals...
[17:48:11.547] - globals found: [1] ‘{’
[17:48:11.547] Searching for globals ... DONE
[17:48:11.547] Resolving globals: FALSE
[17:48:11.547] 
[17:48:11.548] 
[17:48:11.548] getGlobalsAndPackages() ... DONE
[17:48:11.548] run() for ‘Future’ ...
[17:48:11.548] - state: ‘created’
[17:48:11.548] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.561] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.561]   - Field: ‘node’
[17:48:11.562]   - Field: ‘label’
[17:48:11.562]   - Field: ‘local’
[17:48:11.562]   - Field: ‘owner’
[17:48:11.562]   - Field: ‘envir’
[17:48:11.562]   - Field: ‘workers’
[17:48:11.562]   - Field: ‘packages’
[17:48:11.562]   - Field: ‘gc’
[17:48:11.562]   - Field: ‘conditions’
[17:48:11.562]   - Field: ‘persistent’
[17:48:11.562]   - Field: ‘expr’
[17:48:11.563]   - Field: ‘uuid’
[17:48:11.563]   - Field: ‘seed’
[17:48:11.563]   - Field: ‘version’
[17:48:11.563]   - Field: ‘result’
[17:48:11.563]   - Field: ‘asynchronous’
[17:48:11.563]   - Field: ‘calls’
[17:48:11.563]   - Field: ‘globals’
[17:48:11.563]   - Field: ‘stdout’
[17:48:11.563]   - Field: ‘earlySignal’
[17:48:11.563]   - Field: ‘lazy’
[17:48:11.563]   - Field: ‘state’
[17:48:11.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.564] - Launch lazy future ...
[17:48:11.564] Packages needed by the future expression (n = 0): <none>
[17:48:11.564] Packages needed by future strategies (n = 0): <none>
[17:48:11.564] {
[17:48:11.564]     {
[17:48:11.564]         {
[17:48:11.564]             ...future.startTime <- base::Sys.time()
[17:48:11.564]             {
[17:48:11.564]                 {
[17:48:11.564]                   {
[17:48:11.564]                     {
[17:48:11.564]                       base::local({
[17:48:11.564]                         has_future <- base::requireNamespace("future", 
[17:48:11.564]                           quietly = TRUE)
[17:48:11.564]                         if (has_future) {
[17:48:11.564]                           ns <- base::getNamespace("future")
[17:48:11.564]                           version <- ns[[".package"]][["version"]]
[17:48:11.564]                           if (is.null(version)) 
[17:48:11.564]                             version <- utils::packageVersion("future")
[17:48:11.564]                         }
[17:48:11.564]                         else {
[17:48:11.564]                           version <- NULL
[17:48:11.564]                         }
[17:48:11.564]                         if (!has_future || version < "1.8.0") {
[17:48:11.564]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.564]                             "", base::R.version$version.string), 
[17:48:11.564]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.564]                               "release", "version")], collapse = " "), 
[17:48:11.564]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.564]                             info)
[17:48:11.564]                           info <- base::paste(info, collapse = "; ")
[17:48:11.564]                           if (!has_future) {
[17:48:11.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.564]                               info)
[17:48:11.564]                           }
[17:48:11.564]                           else {
[17:48:11.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.564]                               info, version)
[17:48:11.564]                           }
[17:48:11.564]                           base::stop(msg)
[17:48:11.564]                         }
[17:48:11.564]                       })
[17:48:11.564]                     }
[17:48:11.564]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.564]                     base::options(mc.cores = 1L)
[17:48:11.564]                   }
[17:48:11.564]                   ...future.strategy.old <- future::plan("list")
[17:48:11.564]                   options(future.plan = NULL)
[17:48:11.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.564]                 }
[17:48:11.564]                 ...future.workdir <- getwd()
[17:48:11.564]             }
[17:48:11.564]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.564]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.564]         }
[17:48:11.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.564]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.564]             base::names(...future.oldOptions))
[17:48:11.564]     }
[17:48:11.564]     if (FALSE) {
[17:48:11.564]     }
[17:48:11.564]     else {
[17:48:11.564]         if (TRUE) {
[17:48:11.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.564]                 open = "w")
[17:48:11.564]         }
[17:48:11.564]         else {
[17:48:11.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.564]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.564]         }
[17:48:11.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.564]             base::sink(type = "output", split = FALSE)
[17:48:11.564]             base::close(...future.stdout)
[17:48:11.564]         }, add = TRUE)
[17:48:11.564]     }
[17:48:11.564]     ...future.frame <- base::sys.nframe()
[17:48:11.564]     ...future.conditions <- base::list()
[17:48:11.564]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.564]     if (FALSE) {
[17:48:11.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.564]     }
[17:48:11.564]     ...future.result <- base::tryCatch({
[17:48:11.564]         base::withCallingHandlers({
[17:48:11.564]             ...future.value <- base::withVisible(base::local({
[17:48:11.564]                 ...future.makeSendCondition <- base::local({
[17:48:11.564]                   sendCondition <- NULL
[17:48:11.564]                   function(frame = 1L) {
[17:48:11.564]                     if (is.function(sendCondition)) 
[17:48:11.564]                       return(sendCondition)
[17:48:11.564]                     ns <- getNamespace("parallel")
[17:48:11.564]                     if (exists("sendData", mode = "function", 
[17:48:11.564]                       envir = ns)) {
[17:48:11.564]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.564]                         envir = ns)
[17:48:11.564]                       envir <- sys.frame(frame)
[17:48:11.564]                       master <- NULL
[17:48:11.564]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.564]                         !identical(envir, emptyenv())) {
[17:48:11.564]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.564]                           inherits = FALSE)) {
[17:48:11.564]                           master <- get("master", mode = "list", 
[17:48:11.564]                             envir = envir, inherits = FALSE)
[17:48:11.564]                           if (inherits(master, c("SOCKnode", 
[17:48:11.564]                             "SOCK0node"))) {
[17:48:11.564]                             sendCondition <<- function(cond) {
[17:48:11.564]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.564]                                 success = TRUE)
[17:48:11.564]                               parallel_sendData(master, data)
[17:48:11.564]                             }
[17:48:11.564]                             return(sendCondition)
[17:48:11.564]                           }
[17:48:11.564]                         }
[17:48:11.564]                         frame <- frame + 1L
[17:48:11.564]                         envir <- sys.frame(frame)
[17:48:11.564]                       }
[17:48:11.564]                     }
[17:48:11.564]                     sendCondition <<- function(cond) NULL
[17:48:11.564]                   }
[17:48:11.564]                 })
[17:48:11.564]                 withCallingHandlers({
[17:48:11.564]                   {
[17:48:11.564]                     1
[17:48:11.564]                   }
[17:48:11.564]                 }, immediateCondition = function(cond) {
[17:48:11.564]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.564]                   sendCondition(cond)
[17:48:11.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.564]                   {
[17:48:11.564]                     inherits <- base::inherits
[17:48:11.564]                     invokeRestart <- base::invokeRestart
[17:48:11.564]                     is.null <- base::is.null
[17:48:11.564]                     muffled <- FALSE
[17:48:11.564]                     if (inherits(cond, "message")) {
[17:48:11.564]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.564]                       if (muffled) 
[17:48:11.564]                         invokeRestart("muffleMessage")
[17:48:11.564]                     }
[17:48:11.564]                     else if (inherits(cond, "warning")) {
[17:48:11.564]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.564]                       if (muffled) 
[17:48:11.564]                         invokeRestart("muffleWarning")
[17:48:11.564]                     }
[17:48:11.564]                     else if (inherits(cond, "condition")) {
[17:48:11.564]                       if (!is.null(pattern)) {
[17:48:11.564]                         computeRestarts <- base::computeRestarts
[17:48:11.564]                         grepl <- base::grepl
[17:48:11.564]                         restarts <- computeRestarts(cond)
[17:48:11.564]                         for (restart in restarts) {
[17:48:11.564]                           name <- restart$name
[17:48:11.564]                           if (is.null(name)) 
[17:48:11.564]                             next
[17:48:11.564]                           if (!grepl(pattern, name)) 
[17:48:11.564]                             next
[17:48:11.564]                           invokeRestart(restart)
[17:48:11.564]                           muffled <- TRUE
[17:48:11.564]                           break
[17:48:11.564]                         }
[17:48:11.564]                       }
[17:48:11.564]                     }
[17:48:11.564]                     invisible(muffled)
[17:48:11.564]                   }
[17:48:11.564]                   muffleCondition(cond)
[17:48:11.564]                 })
[17:48:11.564]             }))
[17:48:11.564]             future::FutureResult(value = ...future.value$value, 
[17:48:11.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.564]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.564]                     ...future.globalenv.names))
[17:48:11.564]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.564]         }, condition = base::local({
[17:48:11.564]             c <- base::c
[17:48:11.564]             inherits <- base::inherits
[17:48:11.564]             invokeRestart <- base::invokeRestart
[17:48:11.564]             length <- base::length
[17:48:11.564]             list <- base::list
[17:48:11.564]             seq.int <- base::seq.int
[17:48:11.564]             signalCondition <- base::signalCondition
[17:48:11.564]             sys.calls <- base::sys.calls
[17:48:11.564]             `[[` <- base::`[[`
[17:48:11.564]             `+` <- base::`+`
[17:48:11.564]             `<<-` <- base::`<<-`
[17:48:11.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.564]                   3L)]
[17:48:11.564]             }
[17:48:11.564]             function(cond) {
[17:48:11.564]                 is_error <- inherits(cond, "error")
[17:48:11.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.564]                   NULL)
[17:48:11.564]                 if (is_error) {
[17:48:11.564]                   sessionInformation <- function() {
[17:48:11.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.564]                       search = base::search(), system = base::Sys.info())
[17:48:11.564]                   }
[17:48:11.564]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.564]                     cond$call), session = sessionInformation(), 
[17:48:11.564]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.564]                   signalCondition(cond)
[17:48:11.564]                 }
[17:48:11.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.564]                 "immediateCondition"))) {
[17:48:11.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.564]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.564]                   if (TRUE && !signal) {
[17:48:11.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.564]                     {
[17:48:11.564]                       inherits <- base::inherits
[17:48:11.564]                       invokeRestart <- base::invokeRestart
[17:48:11.564]                       is.null <- base::is.null
[17:48:11.564]                       muffled <- FALSE
[17:48:11.564]                       if (inherits(cond, "message")) {
[17:48:11.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.564]                         if (muffled) 
[17:48:11.564]                           invokeRestart("muffleMessage")
[17:48:11.564]                       }
[17:48:11.564]                       else if (inherits(cond, "warning")) {
[17:48:11.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.564]                         if (muffled) 
[17:48:11.564]                           invokeRestart("muffleWarning")
[17:48:11.564]                       }
[17:48:11.564]                       else if (inherits(cond, "condition")) {
[17:48:11.564]                         if (!is.null(pattern)) {
[17:48:11.564]                           computeRestarts <- base::computeRestarts
[17:48:11.564]                           grepl <- base::grepl
[17:48:11.564]                           restarts <- computeRestarts(cond)
[17:48:11.564]                           for (restart in restarts) {
[17:48:11.564]                             name <- restart$name
[17:48:11.564]                             if (is.null(name)) 
[17:48:11.564]                               next
[17:48:11.564]                             if (!grepl(pattern, name)) 
[17:48:11.564]                               next
[17:48:11.564]                             invokeRestart(restart)
[17:48:11.564]                             muffled <- TRUE
[17:48:11.564]                             break
[17:48:11.564]                           }
[17:48:11.564]                         }
[17:48:11.564]                       }
[17:48:11.564]                       invisible(muffled)
[17:48:11.564]                     }
[17:48:11.564]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.564]                   }
[17:48:11.564]                 }
[17:48:11.564]                 else {
[17:48:11.564]                   if (TRUE) {
[17:48:11.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.564]                     {
[17:48:11.564]                       inherits <- base::inherits
[17:48:11.564]                       invokeRestart <- base::invokeRestart
[17:48:11.564]                       is.null <- base::is.null
[17:48:11.564]                       muffled <- FALSE
[17:48:11.564]                       if (inherits(cond, "message")) {
[17:48:11.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.564]                         if (muffled) 
[17:48:11.564]                           invokeRestart("muffleMessage")
[17:48:11.564]                       }
[17:48:11.564]                       else if (inherits(cond, "warning")) {
[17:48:11.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.564]                         if (muffled) 
[17:48:11.564]                           invokeRestart("muffleWarning")
[17:48:11.564]                       }
[17:48:11.564]                       else if (inherits(cond, "condition")) {
[17:48:11.564]                         if (!is.null(pattern)) {
[17:48:11.564]                           computeRestarts <- base::computeRestarts
[17:48:11.564]                           grepl <- base::grepl
[17:48:11.564]                           restarts <- computeRestarts(cond)
[17:48:11.564]                           for (restart in restarts) {
[17:48:11.564]                             name <- restart$name
[17:48:11.564]                             if (is.null(name)) 
[17:48:11.564]                               next
[17:48:11.564]                             if (!grepl(pattern, name)) 
[17:48:11.564]                               next
[17:48:11.564]                             invokeRestart(restart)
[17:48:11.564]                             muffled <- TRUE
[17:48:11.564]                             break
[17:48:11.564]                           }
[17:48:11.564]                         }
[17:48:11.564]                       }
[17:48:11.564]                       invisible(muffled)
[17:48:11.564]                     }
[17:48:11.564]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.564]                   }
[17:48:11.564]                 }
[17:48:11.564]             }
[17:48:11.564]         }))
[17:48:11.564]     }, error = function(ex) {
[17:48:11.564]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.564]                 ...future.rng), started = ...future.startTime, 
[17:48:11.564]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.564]             version = "1.8"), class = "FutureResult")
[17:48:11.564]     }, finally = {
[17:48:11.564]         if (!identical(...future.workdir, getwd())) 
[17:48:11.564]             setwd(...future.workdir)
[17:48:11.564]         {
[17:48:11.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.564]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.564]             }
[17:48:11.564]             base::options(...future.oldOptions)
[17:48:11.564]             if (.Platform$OS.type == "windows") {
[17:48:11.564]                 old_names <- names(...future.oldEnvVars)
[17:48:11.564]                 envs <- base::Sys.getenv()
[17:48:11.564]                 names <- names(envs)
[17:48:11.564]                 common <- intersect(names, old_names)
[17:48:11.564]                 added <- setdiff(names, old_names)
[17:48:11.564]                 removed <- setdiff(old_names, names)
[17:48:11.564]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.564]                   envs[common]]
[17:48:11.564]                 NAMES <- toupper(changed)
[17:48:11.564]                 args <- list()
[17:48:11.564]                 for (kk in seq_along(NAMES)) {
[17:48:11.564]                   name <- changed[[kk]]
[17:48:11.564]                   NAME <- NAMES[[kk]]
[17:48:11.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.564]                     next
[17:48:11.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.564]                 }
[17:48:11.564]                 NAMES <- toupper(added)
[17:48:11.564]                 for (kk in seq_along(NAMES)) {
[17:48:11.564]                   name <- added[[kk]]
[17:48:11.564]                   NAME <- NAMES[[kk]]
[17:48:11.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.564]                     next
[17:48:11.564]                   args[[name]] <- ""
[17:48:11.564]                 }
[17:48:11.564]                 NAMES <- toupper(removed)
[17:48:11.564]                 for (kk in seq_along(NAMES)) {
[17:48:11.564]                   name <- removed[[kk]]
[17:48:11.564]                   NAME <- NAMES[[kk]]
[17:48:11.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.564]                     next
[17:48:11.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.564]                 }
[17:48:11.564]                 if (length(args) > 0) 
[17:48:11.564]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.564]             }
[17:48:11.564]             else {
[17:48:11.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.564]             }
[17:48:11.564]             {
[17:48:11.564]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.564]                   0L) {
[17:48:11.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.564]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.564]                   base::options(opts)
[17:48:11.564]                 }
[17:48:11.564]                 {
[17:48:11.564]                   {
[17:48:11.564]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.564]                     NULL
[17:48:11.564]                   }
[17:48:11.564]                   options(future.plan = NULL)
[17:48:11.564]                   if (is.na(NA_character_)) 
[17:48:11.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.564]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.564]                     .init = FALSE)
[17:48:11.564]                 }
[17:48:11.564]             }
[17:48:11.564]         }
[17:48:11.564]     })
[17:48:11.564]     if (TRUE) {
[17:48:11.564]         base::sink(type = "output", split = FALSE)
[17:48:11.564]         if (TRUE) {
[17:48:11.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.564]         }
[17:48:11.564]         else {
[17:48:11.564]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.564]         }
[17:48:11.564]         base::close(...future.stdout)
[17:48:11.564]         ...future.stdout <- NULL
[17:48:11.564]     }
[17:48:11.564]     ...future.result$conditions <- ...future.conditions
[17:48:11.564]     ...future.result$finished <- base::Sys.time()
[17:48:11.564]     ...future.result
[17:48:11.564] }
[17:48:11.570] MultisessionFuture started
[17:48:11.570] - Launch lazy future ... done
[17:48:11.570] run() for ‘MultisessionFuture’ ... done
[17:48:11.571] getGlobalsAndPackages() ...
[17:48:11.571] Searching for globals...
[17:48:11.572] - globals found: [1] ‘{’
[17:48:11.572] Searching for globals ... DONE
[17:48:11.572] Resolving globals: FALSE
[17:48:11.572] 
[17:48:11.572] 
[17:48:11.572] getGlobalsAndPackages() ... DONE
[17:48:11.573] run() for ‘Future’ ...
[17:48:11.573] - state: ‘created’
[17:48:11.573] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.587] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.588]   - Field: ‘node’
[17:48:11.588]   - Field: ‘label’
[17:48:11.588]   - Field: ‘local’
[17:48:11.588]   - Field: ‘owner’
[17:48:11.588]   - Field: ‘envir’
[17:48:11.588]   - Field: ‘workers’
[17:48:11.588]   - Field: ‘packages’
[17:48:11.588]   - Field: ‘gc’
[17:48:11.588]   - Field: ‘conditions’
[17:48:11.589]   - Field: ‘persistent’
[17:48:11.589]   - Field: ‘expr’
[17:48:11.589]   - Field: ‘uuid’
[17:48:11.589]   - Field: ‘seed’
[17:48:11.589]   - Field: ‘version’
[17:48:11.589]   - Field: ‘result’
[17:48:11.589]   - Field: ‘asynchronous’
[17:48:11.589]   - Field: ‘calls’
[17:48:11.589]   - Field: ‘globals’
[17:48:11.589]   - Field: ‘stdout’
[17:48:11.589]   - Field: ‘earlySignal’
[17:48:11.590]   - Field: ‘lazy’
[17:48:11.590]   - Field: ‘state’
[17:48:11.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.590] - Launch lazy future ...
[17:48:11.590] Packages needed by the future expression (n = 0): <none>
[17:48:11.590] Packages needed by future strategies (n = 0): <none>
[17:48:11.591] {
[17:48:11.591]     {
[17:48:11.591]         {
[17:48:11.591]             ...future.startTime <- base::Sys.time()
[17:48:11.591]             {
[17:48:11.591]                 {
[17:48:11.591]                   {
[17:48:11.591]                     {
[17:48:11.591]                       base::local({
[17:48:11.591]                         has_future <- base::requireNamespace("future", 
[17:48:11.591]                           quietly = TRUE)
[17:48:11.591]                         if (has_future) {
[17:48:11.591]                           ns <- base::getNamespace("future")
[17:48:11.591]                           version <- ns[[".package"]][["version"]]
[17:48:11.591]                           if (is.null(version)) 
[17:48:11.591]                             version <- utils::packageVersion("future")
[17:48:11.591]                         }
[17:48:11.591]                         else {
[17:48:11.591]                           version <- NULL
[17:48:11.591]                         }
[17:48:11.591]                         if (!has_future || version < "1.8.0") {
[17:48:11.591]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.591]                             "", base::R.version$version.string), 
[17:48:11.591]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.591]                               "release", "version")], collapse = " "), 
[17:48:11.591]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.591]                             info)
[17:48:11.591]                           info <- base::paste(info, collapse = "; ")
[17:48:11.591]                           if (!has_future) {
[17:48:11.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.591]                               info)
[17:48:11.591]                           }
[17:48:11.591]                           else {
[17:48:11.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.591]                               info, version)
[17:48:11.591]                           }
[17:48:11.591]                           base::stop(msg)
[17:48:11.591]                         }
[17:48:11.591]                       })
[17:48:11.591]                     }
[17:48:11.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.591]                     base::options(mc.cores = 1L)
[17:48:11.591]                   }
[17:48:11.591]                   ...future.strategy.old <- future::plan("list")
[17:48:11.591]                   options(future.plan = NULL)
[17:48:11.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.591]                 }
[17:48:11.591]                 ...future.workdir <- getwd()
[17:48:11.591]             }
[17:48:11.591]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.591]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.591]         }
[17:48:11.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.591]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.591]             base::names(...future.oldOptions))
[17:48:11.591]     }
[17:48:11.591]     if (FALSE) {
[17:48:11.591]     }
[17:48:11.591]     else {
[17:48:11.591]         if (TRUE) {
[17:48:11.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.591]                 open = "w")
[17:48:11.591]         }
[17:48:11.591]         else {
[17:48:11.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.591]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.591]         }
[17:48:11.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.591]             base::sink(type = "output", split = FALSE)
[17:48:11.591]             base::close(...future.stdout)
[17:48:11.591]         }, add = TRUE)
[17:48:11.591]     }
[17:48:11.591]     ...future.frame <- base::sys.nframe()
[17:48:11.591]     ...future.conditions <- base::list()
[17:48:11.591]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.591]     if (FALSE) {
[17:48:11.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.591]     }
[17:48:11.591]     ...future.result <- base::tryCatch({
[17:48:11.591]         base::withCallingHandlers({
[17:48:11.591]             ...future.value <- base::withVisible(base::local({
[17:48:11.591]                 ...future.makeSendCondition <- base::local({
[17:48:11.591]                   sendCondition <- NULL
[17:48:11.591]                   function(frame = 1L) {
[17:48:11.591]                     if (is.function(sendCondition)) 
[17:48:11.591]                       return(sendCondition)
[17:48:11.591]                     ns <- getNamespace("parallel")
[17:48:11.591]                     if (exists("sendData", mode = "function", 
[17:48:11.591]                       envir = ns)) {
[17:48:11.591]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.591]                         envir = ns)
[17:48:11.591]                       envir <- sys.frame(frame)
[17:48:11.591]                       master <- NULL
[17:48:11.591]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.591]                         !identical(envir, emptyenv())) {
[17:48:11.591]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.591]                           inherits = FALSE)) {
[17:48:11.591]                           master <- get("master", mode = "list", 
[17:48:11.591]                             envir = envir, inherits = FALSE)
[17:48:11.591]                           if (inherits(master, c("SOCKnode", 
[17:48:11.591]                             "SOCK0node"))) {
[17:48:11.591]                             sendCondition <<- function(cond) {
[17:48:11.591]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.591]                                 success = TRUE)
[17:48:11.591]                               parallel_sendData(master, data)
[17:48:11.591]                             }
[17:48:11.591]                             return(sendCondition)
[17:48:11.591]                           }
[17:48:11.591]                         }
[17:48:11.591]                         frame <- frame + 1L
[17:48:11.591]                         envir <- sys.frame(frame)
[17:48:11.591]                       }
[17:48:11.591]                     }
[17:48:11.591]                     sendCondition <<- function(cond) NULL
[17:48:11.591]                   }
[17:48:11.591]                 })
[17:48:11.591]                 withCallingHandlers({
[17:48:11.591]                   {
[17:48:11.591]                     2
[17:48:11.591]                   }
[17:48:11.591]                 }, immediateCondition = function(cond) {
[17:48:11.591]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.591]                   sendCondition(cond)
[17:48:11.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.591]                   {
[17:48:11.591]                     inherits <- base::inherits
[17:48:11.591]                     invokeRestart <- base::invokeRestart
[17:48:11.591]                     is.null <- base::is.null
[17:48:11.591]                     muffled <- FALSE
[17:48:11.591]                     if (inherits(cond, "message")) {
[17:48:11.591]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.591]                       if (muffled) 
[17:48:11.591]                         invokeRestart("muffleMessage")
[17:48:11.591]                     }
[17:48:11.591]                     else if (inherits(cond, "warning")) {
[17:48:11.591]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.591]                       if (muffled) 
[17:48:11.591]                         invokeRestart("muffleWarning")
[17:48:11.591]                     }
[17:48:11.591]                     else if (inherits(cond, "condition")) {
[17:48:11.591]                       if (!is.null(pattern)) {
[17:48:11.591]                         computeRestarts <- base::computeRestarts
[17:48:11.591]                         grepl <- base::grepl
[17:48:11.591]                         restarts <- computeRestarts(cond)
[17:48:11.591]                         for (restart in restarts) {
[17:48:11.591]                           name <- restart$name
[17:48:11.591]                           if (is.null(name)) 
[17:48:11.591]                             next
[17:48:11.591]                           if (!grepl(pattern, name)) 
[17:48:11.591]                             next
[17:48:11.591]                           invokeRestart(restart)
[17:48:11.591]                           muffled <- TRUE
[17:48:11.591]                           break
[17:48:11.591]                         }
[17:48:11.591]                       }
[17:48:11.591]                     }
[17:48:11.591]                     invisible(muffled)
[17:48:11.591]                   }
[17:48:11.591]                   muffleCondition(cond)
[17:48:11.591]                 })
[17:48:11.591]             }))
[17:48:11.591]             future::FutureResult(value = ...future.value$value, 
[17:48:11.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.591]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.591]                     ...future.globalenv.names))
[17:48:11.591]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.591]         }, condition = base::local({
[17:48:11.591]             c <- base::c
[17:48:11.591]             inherits <- base::inherits
[17:48:11.591]             invokeRestart <- base::invokeRestart
[17:48:11.591]             length <- base::length
[17:48:11.591]             list <- base::list
[17:48:11.591]             seq.int <- base::seq.int
[17:48:11.591]             signalCondition <- base::signalCondition
[17:48:11.591]             sys.calls <- base::sys.calls
[17:48:11.591]             `[[` <- base::`[[`
[17:48:11.591]             `+` <- base::`+`
[17:48:11.591]             `<<-` <- base::`<<-`
[17:48:11.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.591]                   3L)]
[17:48:11.591]             }
[17:48:11.591]             function(cond) {
[17:48:11.591]                 is_error <- inherits(cond, "error")
[17:48:11.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.591]                   NULL)
[17:48:11.591]                 if (is_error) {
[17:48:11.591]                   sessionInformation <- function() {
[17:48:11.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.591]                       search = base::search(), system = base::Sys.info())
[17:48:11.591]                   }
[17:48:11.591]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.591]                     cond$call), session = sessionInformation(), 
[17:48:11.591]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.591]                   signalCondition(cond)
[17:48:11.591]                 }
[17:48:11.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.591]                 "immediateCondition"))) {
[17:48:11.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.591]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.591]                   if (TRUE && !signal) {
[17:48:11.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.591]                     {
[17:48:11.591]                       inherits <- base::inherits
[17:48:11.591]                       invokeRestart <- base::invokeRestart
[17:48:11.591]                       is.null <- base::is.null
[17:48:11.591]                       muffled <- FALSE
[17:48:11.591]                       if (inherits(cond, "message")) {
[17:48:11.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.591]                         if (muffled) 
[17:48:11.591]                           invokeRestart("muffleMessage")
[17:48:11.591]                       }
[17:48:11.591]                       else if (inherits(cond, "warning")) {
[17:48:11.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.591]                         if (muffled) 
[17:48:11.591]                           invokeRestart("muffleWarning")
[17:48:11.591]                       }
[17:48:11.591]                       else if (inherits(cond, "condition")) {
[17:48:11.591]                         if (!is.null(pattern)) {
[17:48:11.591]                           computeRestarts <- base::computeRestarts
[17:48:11.591]                           grepl <- base::grepl
[17:48:11.591]                           restarts <- computeRestarts(cond)
[17:48:11.591]                           for (restart in restarts) {
[17:48:11.591]                             name <- restart$name
[17:48:11.591]                             if (is.null(name)) 
[17:48:11.591]                               next
[17:48:11.591]                             if (!grepl(pattern, name)) 
[17:48:11.591]                               next
[17:48:11.591]                             invokeRestart(restart)
[17:48:11.591]                             muffled <- TRUE
[17:48:11.591]                             break
[17:48:11.591]                           }
[17:48:11.591]                         }
[17:48:11.591]                       }
[17:48:11.591]                       invisible(muffled)
[17:48:11.591]                     }
[17:48:11.591]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.591]                   }
[17:48:11.591]                 }
[17:48:11.591]                 else {
[17:48:11.591]                   if (TRUE) {
[17:48:11.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.591]                     {
[17:48:11.591]                       inherits <- base::inherits
[17:48:11.591]                       invokeRestart <- base::invokeRestart
[17:48:11.591]                       is.null <- base::is.null
[17:48:11.591]                       muffled <- FALSE
[17:48:11.591]                       if (inherits(cond, "message")) {
[17:48:11.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.591]                         if (muffled) 
[17:48:11.591]                           invokeRestart("muffleMessage")
[17:48:11.591]                       }
[17:48:11.591]                       else if (inherits(cond, "warning")) {
[17:48:11.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.591]                         if (muffled) 
[17:48:11.591]                           invokeRestart("muffleWarning")
[17:48:11.591]                       }
[17:48:11.591]                       else if (inherits(cond, "condition")) {
[17:48:11.591]                         if (!is.null(pattern)) {
[17:48:11.591]                           computeRestarts <- base::computeRestarts
[17:48:11.591]                           grepl <- base::grepl
[17:48:11.591]                           restarts <- computeRestarts(cond)
[17:48:11.591]                           for (restart in restarts) {
[17:48:11.591]                             name <- restart$name
[17:48:11.591]                             if (is.null(name)) 
[17:48:11.591]                               next
[17:48:11.591]                             if (!grepl(pattern, name)) 
[17:48:11.591]                               next
[17:48:11.591]                             invokeRestart(restart)
[17:48:11.591]                             muffled <- TRUE
[17:48:11.591]                             break
[17:48:11.591]                           }
[17:48:11.591]                         }
[17:48:11.591]                       }
[17:48:11.591]                       invisible(muffled)
[17:48:11.591]                     }
[17:48:11.591]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.591]                   }
[17:48:11.591]                 }
[17:48:11.591]             }
[17:48:11.591]         }))
[17:48:11.591]     }, error = function(ex) {
[17:48:11.591]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.591]                 ...future.rng), started = ...future.startTime, 
[17:48:11.591]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.591]             version = "1.8"), class = "FutureResult")
[17:48:11.591]     }, finally = {
[17:48:11.591]         if (!identical(...future.workdir, getwd())) 
[17:48:11.591]             setwd(...future.workdir)
[17:48:11.591]         {
[17:48:11.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.591]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.591]             }
[17:48:11.591]             base::options(...future.oldOptions)
[17:48:11.591]             if (.Platform$OS.type == "windows") {
[17:48:11.591]                 old_names <- names(...future.oldEnvVars)
[17:48:11.591]                 envs <- base::Sys.getenv()
[17:48:11.591]                 names <- names(envs)
[17:48:11.591]                 common <- intersect(names, old_names)
[17:48:11.591]                 added <- setdiff(names, old_names)
[17:48:11.591]                 removed <- setdiff(old_names, names)
[17:48:11.591]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.591]                   envs[common]]
[17:48:11.591]                 NAMES <- toupper(changed)
[17:48:11.591]                 args <- list()
[17:48:11.591]                 for (kk in seq_along(NAMES)) {
[17:48:11.591]                   name <- changed[[kk]]
[17:48:11.591]                   NAME <- NAMES[[kk]]
[17:48:11.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.591]                     next
[17:48:11.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.591]                 }
[17:48:11.591]                 NAMES <- toupper(added)
[17:48:11.591]                 for (kk in seq_along(NAMES)) {
[17:48:11.591]                   name <- added[[kk]]
[17:48:11.591]                   NAME <- NAMES[[kk]]
[17:48:11.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.591]                     next
[17:48:11.591]                   args[[name]] <- ""
[17:48:11.591]                 }
[17:48:11.591]                 NAMES <- toupper(removed)
[17:48:11.591]                 for (kk in seq_along(NAMES)) {
[17:48:11.591]                   name <- removed[[kk]]
[17:48:11.591]                   NAME <- NAMES[[kk]]
[17:48:11.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.591]                     next
[17:48:11.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.591]                 }
[17:48:11.591]                 if (length(args) > 0) 
[17:48:11.591]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.591]             }
[17:48:11.591]             else {
[17:48:11.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.591]             }
[17:48:11.591]             {
[17:48:11.591]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.591]                   0L) {
[17:48:11.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.591]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.591]                   base::options(opts)
[17:48:11.591]                 }
[17:48:11.591]                 {
[17:48:11.591]                   {
[17:48:11.591]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.591]                     NULL
[17:48:11.591]                   }
[17:48:11.591]                   options(future.plan = NULL)
[17:48:11.591]                   if (is.na(NA_character_)) 
[17:48:11.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.591]                     .init = FALSE)
[17:48:11.591]                 }
[17:48:11.591]             }
[17:48:11.591]         }
[17:48:11.591]     })
[17:48:11.591]     if (TRUE) {
[17:48:11.591]         base::sink(type = "output", split = FALSE)
[17:48:11.591]         if (TRUE) {
[17:48:11.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.591]         }
[17:48:11.591]         else {
[17:48:11.591]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.591]         }
[17:48:11.591]         base::close(...future.stdout)
[17:48:11.591]         ...future.stdout <- NULL
[17:48:11.591]     }
[17:48:11.591]     ...future.result$conditions <- ...future.conditions
[17:48:11.591]     ...future.result$finished <- base::Sys.time()
[17:48:11.591]     ...future.result
[17:48:11.591] }
[17:48:11.594] MultisessionFuture started
[17:48:11.594] - Launch lazy future ... done
[17:48:11.594] run() for ‘MultisessionFuture’ ... done
[17:48:11.595] resolve() on list environment ...
[17:48:11.595]  recursive: 0
[17:48:11.596]  length: 3
[17:48:11.596]  elements: ‘a’, ‘b’, ‘c’
[17:48:11.596] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.596] - Validating connection of MultisessionFuture
[17:48:11.597] - received message: FutureResult
[17:48:11.597] - Received FutureResult
[17:48:11.597] - Erased future from FutureRegistry
[17:48:11.597] result() for ClusterFuture ...
[17:48:11.597] - result already collected: FutureResult
[17:48:11.597] result() for ClusterFuture ... done
[17:48:11.597] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.597] Future #1
[17:48:11.597]  length: 2 (resolved future 1)
[17:48:11.598] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.598] - Validating connection of MultisessionFuture
[17:48:11.598] - received message: FutureResult
[17:48:11.598] - Received FutureResult
[17:48:11.598] - Erased future from FutureRegistry
[17:48:11.598] result() for ClusterFuture ...
[17:48:11.598] - result already collected: FutureResult
[17:48:11.598] result() for ClusterFuture ... done
[17:48:11.599] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.599] Future #2
[17:48:11.599]  length: 1 (resolved future 2)
[17:48:11.599]  length: 0 (resolved future 3)
[17:48:11.599] resolve() on list environment ... DONE
[17:48:11.599] getGlobalsAndPackages() ...
[17:48:11.599] Searching for globals...
[17:48:11.600] - globals found: [1] ‘{’
[17:48:11.600] Searching for globals ... DONE
[17:48:11.600] Resolving globals: FALSE
[17:48:11.600] 
[17:48:11.601] 
[17:48:11.601] getGlobalsAndPackages() ... DONE
[17:48:11.601] run() for ‘Future’ ...
[17:48:11.601] - state: ‘created’
[17:48:11.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.615] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.615]   - Field: ‘node’
[17:48:11.615]   - Field: ‘label’
[17:48:11.615]   - Field: ‘local’
[17:48:11.615]   - Field: ‘owner’
[17:48:11.615]   - Field: ‘envir’
[17:48:11.615]   - Field: ‘workers’
[17:48:11.616]   - Field: ‘packages’
[17:48:11.616]   - Field: ‘gc’
[17:48:11.616]   - Field: ‘conditions’
[17:48:11.616]   - Field: ‘persistent’
[17:48:11.616]   - Field: ‘expr’
[17:48:11.616]   - Field: ‘uuid’
[17:48:11.616]   - Field: ‘seed’
[17:48:11.616]   - Field: ‘version’
[17:48:11.616]   - Field: ‘result’
[17:48:11.616]   - Field: ‘asynchronous’
[17:48:11.616]   - Field: ‘calls’
[17:48:11.617]   - Field: ‘globals’
[17:48:11.617]   - Field: ‘stdout’
[17:48:11.617]   - Field: ‘earlySignal’
[17:48:11.617]   - Field: ‘lazy’
[17:48:11.617]   - Field: ‘state’
[17:48:11.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.617] - Launch lazy future ...
[17:48:11.617] Packages needed by the future expression (n = 0): <none>
[17:48:11.617] Packages needed by future strategies (n = 0): <none>
[17:48:11.618] {
[17:48:11.618]     {
[17:48:11.618]         {
[17:48:11.618]             ...future.startTime <- base::Sys.time()
[17:48:11.618]             {
[17:48:11.618]                 {
[17:48:11.618]                   {
[17:48:11.618]                     {
[17:48:11.618]                       base::local({
[17:48:11.618]                         has_future <- base::requireNamespace("future", 
[17:48:11.618]                           quietly = TRUE)
[17:48:11.618]                         if (has_future) {
[17:48:11.618]                           ns <- base::getNamespace("future")
[17:48:11.618]                           version <- ns[[".package"]][["version"]]
[17:48:11.618]                           if (is.null(version)) 
[17:48:11.618]                             version <- utils::packageVersion("future")
[17:48:11.618]                         }
[17:48:11.618]                         else {
[17:48:11.618]                           version <- NULL
[17:48:11.618]                         }
[17:48:11.618]                         if (!has_future || version < "1.8.0") {
[17:48:11.618]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.618]                             "", base::R.version$version.string), 
[17:48:11.618]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.618]                               "release", "version")], collapse = " "), 
[17:48:11.618]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.618]                             info)
[17:48:11.618]                           info <- base::paste(info, collapse = "; ")
[17:48:11.618]                           if (!has_future) {
[17:48:11.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.618]                               info)
[17:48:11.618]                           }
[17:48:11.618]                           else {
[17:48:11.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.618]                               info, version)
[17:48:11.618]                           }
[17:48:11.618]                           base::stop(msg)
[17:48:11.618]                         }
[17:48:11.618]                       })
[17:48:11.618]                     }
[17:48:11.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.618]                     base::options(mc.cores = 1L)
[17:48:11.618]                   }
[17:48:11.618]                   ...future.strategy.old <- future::plan("list")
[17:48:11.618]                   options(future.plan = NULL)
[17:48:11.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.618]                 }
[17:48:11.618]                 ...future.workdir <- getwd()
[17:48:11.618]             }
[17:48:11.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.618]         }
[17:48:11.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.618]             base::names(...future.oldOptions))
[17:48:11.618]     }
[17:48:11.618]     if (FALSE) {
[17:48:11.618]     }
[17:48:11.618]     else {
[17:48:11.618]         if (TRUE) {
[17:48:11.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.618]                 open = "w")
[17:48:11.618]         }
[17:48:11.618]         else {
[17:48:11.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.618]         }
[17:48:11.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.618]             base::sink(type = "output", split = FALSE)
[17:48:11.618]             base::close(...future.stdout)
[17:48:11.618]         }, add = TRUE)
[17:48:11.618]     }
[17:48:11.618]     ...future.frame <- base::sys.nframe()
[17:48:11.618]     ...future.conditions <- base::list()
[17:48:11.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.618]     if (FALSE) {
[17:48:11.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.618]     }
[17:48:11.618]     ...future.result <- base::tryCatch({
[17:48:11.618]         base::withCallingHandlers({
[17:48:11.618]             ...future.value <- base::withVisible(base::local({
[17:48:11.618]                 ...future.makeSendCondition <- base::local({
[17:48:11.618]                   sendCondition <- NULL
[17:48:11.618]                   function(frame = 1L) {
[17:48:11.618]                     if (is.function(sendCondition)) 
[17:48:11.618]                       return(sendCondition)
[17:48:11.618]                     ns <- getNamespace("parallel")
[17:48:11.618]                     if (exists("sendData", mode = "function", 
[17:48:11.618]                       envir = ns)) {
[17:48:11.618]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.618]                         envir = ns)
[17:48:11.618]                       envir <- sys.frame(frame)
[17:48:11.618]                       master <- NULL
[17:48:11.618]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.618]                         !identical(envir, emptyenv())) {
[17:48:11.618]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.618]                           inherits = FALSE)) {
[17:48:11.618]                           master <- get("master", mode = "list", 
[17:48:11.618]                             envir = envir, inherits = FALSE)
[17:48:11.618]                           if (inherits(master, c("SOCKnode", 
[17:48:11.618]                             "SOCK0node"))) {
[17:48:11.618]                             sendCondition <<- function(cond) {
[17:48:11.618]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.618]                                 success = TRUE)
[17:48:11.618]                               parallel_sendData(master, data)
[17:48:11.618]                             }
[17:48:11.618]                             return(sendCondition)
[17:48:11.618]                           }
[17:48:11.618]                         }
[17:48:11.618]                         frame <- frame + 1L
[17:48:11.618]                         envir <- sys.frame(frame)
[17:48:11.618]                       }
[17:48:11.618]                     }
[17:48:11.618]                     sendCondition <<- function(cond) NULL
[17:48:11.618]                   }
[17:48:11.618]                 })
[17:48:11.618]                 withCallingHandlers({
[17:48:11.618]                   {
[17:48:11.618]                     1
[17:48:11.618]                   }
[17:48:11.618]                 }, immediateCondition = function(cond) {
[17:48:11.618]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.618]                   sendCondition(cond)
[17:48:11.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.618]                   {
[17:48:11.618]                     inherits <- base::inherits
[17:48:11.618]                     invokeRestart <- base::invokeRestart
[17:48:11.618]                     is.null <- base::is.null
[17:48:11.618]                     muffled <- FALSE
[17:48:11.618]                     if (inherits(cond, "message")) {
[17:48:11.618]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.618]                       if (muffled) 
[17:48:11.618]                         invokeRestart("muffleMessage")
[17:48:11.618]                     }
[17:48:11.618]                     else if (inherits(cond, "warning")) {
[17:48:11.618]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.618]                       if (muffled) 
[17:48:11.618]                         invokeRestart("muffleWarning")
[17:48:11.618]                     }
[17:48:11.618]                     else if (inherits(cond, "condition")) {
[17:48:11.618]                       if (!is.null(pattern)) {
[17:48:11.618]                         computeRestarts <- base::computeRestarts
[17:48:11.618]                         grepl <- base::grepl
[17:48:11.618]                         restarts <- computeRestarts(cond)
[17:48:11.618]                         for (restart in restarts) {
[17:48:11.618]                           name <- restart$name
[17:48:11.618]                           if (is.null(name)) 
[17:48:11.618]                             next
[17:48:11.618]                           if (!grepl(pattern, name)) 
[17:48:11.618]                             next
[17:48:11.618]                           invokeRestart(restart)
[17:48:11.618]                           muffled <- TRUE
[17:48:11.618]                           break
[17:48:11.618]                         }
[17:48:11.618]                       }
[17:48:11.618]                     }
[17:48:11.618]                     invisible(muffled)
[17:48:11.618]                   }
[17:48:11.618]                   muffleCondition(cond)
[17:48:11.618]                 })
[17:48:11.618]             }))
[17:48:11.618]             future::FutureResult(value = ...future.value$value, 
[17:48:11.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.618]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.618]                     ...future.globalenv.names))
[17:48:11.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.618]         }, condition = base::local({
[17:48:11.618]             c <- base::c
[17:48:11.618]             inherits <- base::inherits
[17:48:11.618]             invokeRestart <- base::invokeRestart
[17:48:11.618]             length <- base::length
[17:48:11.618]             list <- base::list
[17:48:11.618]             seq.int <- base::seq.int
[17:48:11.618]             signalCondition <- base::signalCondition
[17:48:11.618]             sys.calls <- base::sys.calls
[17:48:11.618]             `[[` <- base::`[[`
[17:48:11.618]             `+` <- base::`+`
[17:48:11.618]             `<<-` <- base::`<<-`
[17:48:11.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.618]                   3L)]
[17:48:11.618]             }
[17:48:11.618]             function(cond) {
[17:48:11.618]                 is_error <- inherits(cond, "error")
[17:48:11.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.618]                   NULL)
[17:48:11.618]                 if (is_error) {
[17:48:11.618]                   sessionInformation <- function() {
[17:48:11.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.618]                       search = base::search(), system = base::Sys.info())
[17:48:11.618]                   }
[17:48:11.618]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.618]                     cond$call), session = sessionInformation(), 
[17:48:11.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.618]                   signalCondition(cond)
[17:48:11.618]                 }
[17:48:11.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.618]                 "immediateCondition"))) {
[17:48:11.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.618]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.618]                   if (TRUE && !signal) {
[17:48:11.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.618]                     {
[17:48:11.618]                       inherits <- base::inherits
[17:48:11.618]                       invokeRestart <- base::invokeRestart
[17:48:11.618]                       is.null <- base::is.null
[17:48:11.618]                       muffled <- FALSE
[17:48:11.618]                       if (inherits(cond, "message")) {
[17:48:11.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.618]                         if (muffled) 
[17:48:11.618]                           invokeRestart("muffleMessage")
[17:48:11.618]                       }
[17:48:11.618]                       else if (inherits(cond, "warning")) {
[17:48:11.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.618]                         if (muffled) 
[17:48:11.618]                           invokeRestart("muffleWarning")
[17:48:11.618]                       }
[17:48:11.618]                       else if (inherits(cond, "condition")) {
[17:48:11.618]                         if (!is.null(pattern)) {
[17:48:11.618]                           computeRestarts <- base::computeRestarts
[17:48:11.618]                           grepl <- base::grepl
[17:48:11.618]                           restarts <- computeRestarts(cond)
[17:48:11.618]                           for (restart in restarts) {
[17:48:11.618]                             name <- restart$name
[17:48:11.618]                             if (is.null(name)) 
[17:48:11.618]                               next
[17:48:11.618]                             if (!grepl(pattern, name)) 
[17:48:11.618]                               next
[17:48:11.618]                             invokeRestart(restart)
[17:48:11.618]                             muffled <- TRUE
[17:48:11.618]                             break
[17:48:11.618]                           }
[17:48:11.618]                         }
[17:48:11.618]                       }
[17:48:11.618]                       invisible(muffled)
[17:48:11.618]                     }
[17:48:11.618]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.618]                   }
[17:48:11.618]                 }
[17:48:11.618]                 else {
[17:48:11.618]                   if (TRUE) {
[17:48:11.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.618]                     {
[17:48:11.618]                       inherits <- base::inherits
[17:48:11.618]                       invokeRestart <- base::invokeRestart
[17:48:11.618]                       is.null <- base::is.null
[17:48:11.618]                       muffled <- FALSE
[17:48:11.618]                       if (inherits(cond, "message")) {
[17:48:11.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.618]                         if (muffled) 
[17:48:11.618]                           invokeRestart("muffleMessage")
[17:48:11.618]                       }
[17:48:11.618]                       else if (inherits(cond, "warning")) {
[17:48:11.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.618]                         if (muffled) 
[17:48:11.618]                           invokeRestart("muffleWarning")
[17:48:11.618]                       }
[17:48:11.618]                       else if (inherits(cond, "condition")) {
[17:48:11.618]                         if (!is.null(pattern)) {
[17:48:11.618]                           computeRestarts <- base::computeRestarts
[17:48:11.618]                           grepl <- base::grepl
[17:48:11.618]                           restarts <- computeRestarts(cond)
[17:48:11.618]                           for (restart in restarts) {
[17:48:11.618]                             name <- restart$name
[17:48:11.618]                             if (is.null(name)) 
[17:48:11.618]                               next
[17:48:11.618]                             if (!grepl(pattern, name)) 
[17:48:11.618]                               next
[17:48:11.618]                             invokeRestart(restart)
[17:48:11.618]                             muffled <- TRUE
[17:48:11.618]                             break
[17:48:11.618]                           }
[17:48:11.618]                         }
[17:48:11.618]                       }
[17:48:11.618]                       invisible(muffled)
[17:48:11.618]                     }
[17:48:11.618]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.618]                   }
[17:48:11.618]                 }
[17:48:11.618]             }
[17:48:11.618]         }))
[17:48:11.618]     }, error = function(ex) {
[17:48:11.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.618]                 ...future.rng), started = ...future.startTime, 
[17:48:11.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.618]             version = "1.8"), class = "FutureResult")
[17:48:11.618]     }, finally = {
[17:48:11.618]         if (!identical(...future.workdir, getwd())) 
[17:48:11.618]             setwd(...future.workdir)
[17:48:11.618]         {
[17:48:11.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.618]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.618]             }
[17:48:11.618]             base::options(...future.oldOptions)
[17:48:11.618]             if (.Platform$OS.type == "windows") {
[17:48:11.618]                 old_names <- names(...future.oldEnvVars)
[17:48:11.618]                 envs <- base::Sys.getenv()
[17:48:11.618]                 names <- names(envs)
[17:48:11.618]                 common <- intersect(names, old_names)
[17:48:11.618]                 added <- setdiff(names, old_names)
[17:48:11.618]                 removed <- setdiff(old_names, names)
[17:48:11.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.618]                   envs[common]]
[17:48:11.618]                 NAMES <- toupper(changed)
[17:48:11.618]                 args <- list()
[17:48:11.618]                 for (kk in seq_along(NAMES)) {
[17:48:11.618]                   name <- changed[[kk]]
[17:48:11.618]                   NAME <- NAMES[[kk]]
[17:48:11.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.618]                     next
[17:48:11.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.618]                 }
[17:48:11.618]                 NAMES <- toupper(added)
[17:48:11.618]                 for (kk in seq_along(NAMES)) {
[17:48:11.618]                   name <- added[[kk]]
[17:48:11.618]                   NAME <- NAMES[[kk]]
[17:48:11.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.618]                     next
[17:48:11.618]                   args[[name]] <- ""
[17:48:11.618]                 }
[17:48:11.618]                 NAMES <- toupper(removed)
[17:48:11.618]                 for (kk in seq_along(NAMES)) {
[17:48:11.618]                   name <- removed[[kk]]
[17:48:11.618]                   NAME <- NAMES[[kk]]
[17:48:11.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.618]                     next
[17:48:11.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.618]                 }
[17:48:11.618]                 if (length(args) > 0) 
[17:48:11.618]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.618]             }
[17:48:11.618]             else {
[17:48:11.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.618]             }
[17:48:11.618]             {
[17:48:11.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.618]                   0L) {
[17:48:11.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.618]                   base::options(opts)
[17:48:11.618]                 }
[17:48:11.618]                 {
[17:48:11.618]                   {
[17:48:11.618]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.618]                     NULL
[17:48:11.618]                   }
[17:48:11.618]                   options(future.plan = NULL)
[17:48:11.618]                   if (is.na(NA_character_)) 
[17:48:11.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.618]                     .init = FALSE)
[17:48:11.618]                 }
[17:48:11.618]             }
[17:48:11.618]         }
[17:48:11.618]     })
[17:48:11.618]     if (TRUE) {
[17:48:11.618]         base::sink(type = "output", split = FALSE)
[17:48:11.618]         if (TRUE) {
[17:48:11.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.618]         }
[17:48:11.618]         else {
[17:48:11.618]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.618]         }
[17:48:11.618]         base::close(...future.stdout)
[17:48:11.618]         ...future.stdout <- NULL
[17:48:11.618]     }
[17:48:11.618]     ...future.result$conditions <- ...future.conditions
[17:48:11.618]     ...future.result$finished <- base::Sys.time()
[17:48:11.618]     ...future.result
[17:48:11.618] }
[17:48:11.621] MultisessionFuture started
[17:48:11.621] - Launch lazy future ... done
[17:48:11.621] run() for ‘MultisessionFuture’ ... done
[17:48:11.621] getGlobalsAndPackages() ...
[17:48:11.621] Searching for globals...
[17:48:11.622] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:48:11.622] Searching for globals ... DONE
[17:48:11.622] Resolving globals: FALSE
[17:48:11.623] 
[17:48:11.623] 
[17:48:11.623] getGlobalsAndPackages() ... DONE
[17:48:11.623] run() for ‘Future’ ...
[17:48:11.623] - state: ‘created’
[17:48:11.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.637] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.637]   - Field: ‘node’
[17:48:11.637]   - Field: ‘label’
[17:48:11.637]   - Field: ‘local’
[17:48:11.637]   - Field: ‘owner’
[17:48:11.638]   - Field: ‘envir’
[17:48:11.638]   - Field: ‘workers’
[17:48:11.638]   - Field: ‘packages’
[17:48:11.638]   - Field: ‘gc’
[17:48:11.638]   - Field: ‘conditions’
[17:48:11.638]   - Field: ‘persistent’
[17:48:11.638]   - Field: ‘expr’
[17:48:11.638]   - Field: ‘uuid’
[17:48:11.638]   - Field: ‘seed’
[17:48:11.638]   - Field: ‘version’
[17:48:11.638]   - Field: ‘result’
[17:48:11.639]   - Field: ‘asynchronous’
[17:48:11.639]   - Field: ‘calls’
[17:48:11.639]   - Field: ‘globals’
[17:48:11.639]   - Field: ‘stdout’
[17:48:11.639]   - Field: ‘earlySignal’
[17:48:11.639]   - Field: ‘lazy’
[17:48:11.639]   - Field: ‘state’
[17:48:11.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.639] - Launch lazy future ...
[17:48:11.640] Packages needed by the future expression (n = 0): <none>
[17:48:11.640] Packages needed by future strategies (n = 0): <none>
[17:48:11.640] {
[17:48:11.640]     {
[17:48:11.640]         {
[17:48:11.640]             ...future.startTime <- base::Sys.time()
[17:48:11.640]             {
[17:48:11.640]                 {
[17:48:11.640]                   {
[17:48:11.640]                     {
[17:48:11.640]                       base::local({
[17:48:11.640]                         has_future <- base::requireNamespace("future", 
[17:48:11.640]                           quietly = TRUE)
[17:48:11.640]                         if (has_future) {
[17:48:11.640]                           ns <- base::getNamespace("future")
[17:48:11.640]                           version <- ns[[".package"]][["version"]]
[17:48:11.640]                           if (is.null(version)) 
[17:48:11.640]                             version <- utils::packageVersion("future")
[17:48:11.640]                         }
[17:48:11.640]                         else {
[17:48:11.640]                           version <- NULL
[17:48:11.640]                         }
[17:48:11.640]                         if (!has_future || version < "1.8.0") {
[17:48:11.640]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.640]                             "", base::R.version$version.string), 
[17:48:11.640]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.640]                               "release", "version")], collapse = " "), 
[17:48:11.640]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.640]                             info)
[17:48:11.640]                           info <- base::paste(info, collapse = "; ")
[17:48:11.640]                           if (!has_future) {
[17:48:11.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.640]                               info)
[17:48:11.640]                           }
[17:48:11.640]                           else {
[17:48:11.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.640]                               info, version)
[17:48:11.640]                           }
[17:48:11.640]                           base::stop(msg)
[17:48:11.640]                         }
[17:48:11.640]                       })
[17:48:11.640]                     }
[17:48:11.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.640]                     base::options(mc.cores = 1L)
[17:48:11.640]                   }
[17:48:11.640]                   ...future.strategy.old <- future::plan("list")
[17:48:11.640]                   options(future.plan = NULL)
[17:48:11.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.640]                 }
[17:48:11.640]                 ...future.workdir <- getwd()
[17:48:11.640]             }
[17:48:11.640]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.640]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.640]         }
[17:48:11.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.640]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.640]             base::names(...future.oldOptions))
[17:48:11.640]     }
[17:48:11.640]     if (FALSE) {
[17:48:11.640]     }
[17:48:11.640]     else {
[17:48:11.640]         if (TRUE) {
[17:48:11.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.640]                 open = "w")
[17:48:11.640]         }
[17:48:11.640]         else {
[17:48:11.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.640]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.640]         }
[17:48:11.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.640]             base::sink(type = "output", split = FALSE)
[17:48:11.640]             base::close(...future.stdout)
[17:48:11.640]         }, add = TRUE)
[17:48:11.640]     }
[17:48:11.640]     ...future.frame <- base::sys.nframe()
[17:48:11.640]     ...future.conditions <- base::list()
[17:48:11.640]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.640]     if (FALSE) {
[17:48:11.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.640]     }
[17:48:11.640]     ...future.result <- base::tryCatch({
[17:48:11.640]         base::withCallingHandlers({
[17:48:11.640]             ...future.value <- base::withVisible(base::local({
[17:48:11.640]                 ...future.makeSendCondition <- base::local({
[17:48:11.640]                   sendCondition <- NULL
[17:48:11.640]                   function(frame = 1L) {
[17:48:11.640]                     if (is.function(sendCondition)) 
[17:48:11.640]                       return(sendCondition)
[17:48:11.640]                     ns <- getNamespace("parallel")
[17:48:11.640]                     if (exists("sendData", mode = "function", 
[17:48:11.640]                       envir = ns)) {
[17:48:11.640]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.640]                         envir = ns)
[17:48:11.640]                       envir <- sys.frame(frame)
[17:48:11.640]                       master <- NULL
[17:48:11.640]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.640]                         !identical(envir, emptyenv())) {
[17:48:11.640]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.640]                           inherits = FALSE)) {
[17:48:11.640]                           master <- get("master", mode = "list", 
[17:48:11.640]                             envir = envir, inherits = FALSE)
[17:48:11.640]                           if (inherits(master, c("SOCKnode", 
[17:48:11.640]                             "SOCK0node"))) {
[17:48:11.640]                             sendCondition <<- function(cond) {
[17:48:11.640]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.640]                                 success = TRUE)
[17:48:11.640]                               parallel_sendData(master, data)
[17:48:11.640]                             }
[17:48:11.640]                             return(sendCondition)
[17:48:11.640]                           }
[17:48:11.640]                         }
[17:48:11.640]                         frame <- frame + 1L
[17:48:11.640]                         envir <- sys.frame(frame)
[17:48:11.640]                       }
[17:48:11.640]                     }
[17:48:11.640]                     sendCondition <<- function(cond) NULL
[17:48:11.640]                   }
[17:48:11.640]                 })
[17:48:11.640]                 withCallingHandlers({
[17:48:11.640]                   {
[17:48:11.640]                     Sys.sleep(0.5)
[17:48:11.640]                     2
[17:48:11.640]                   }
[17:48:11.640]                 }, immediateCondition = function(cond) {
[17:48:11.640]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.640]                   sendCondition(cond)
[17:48:11.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.640]                   {
[17:48:11.640]                     inherits <- base::inherits
[17:48:11.640]                     invokeRestart <- base::invokeRestart
[17:48:11.640]                     is.null <- base::is.null
[17:48:11.640]                     muffled <- FALSE
[17:48:11.640]                     if (inherits(cond, "message")) {
[17:48:11.640]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.640]                       if (muffled) 
[17:48:11.640]                         invokeRestart("muffleMessage")
[17:48:11.640]                     }
[17:48:11.640]                     else if (inherits(cond, "warning")) {
[17:48:11.640]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.640]                       if (muffled) 
[17:48:11.640]                         invokeRestart("muffleWarning")
[17:48:11.640]                     }
[17:48:11.640]                     else if (inherits(cond, "condition")) {
[17:48:11.640]                       if (!is.null(pattern)) {
[17:48:11.640]                         computeRestarts <- base::computeRestarts
[17:48:11.640]                         grepl <- base::grepl
[17:48:11.640]                         restarts <- computeRestarts(cond)
[17:48:11.640]                         for (restart in restarts) {
[17:48:11.640]                           name <- restart$name
[17:48:11.640]                           if (is.null(name)) 
[17:48:11.640]                             next
[17:48:11.640]                           if (!grepl(pattern, name)) 
[17:48:11.640]                             next
[17:48:11.640]                           invokeRestart(restart)
[17:48:11.640]                           muffled <- TRUE
[17:48:11.640]                           break
[17:48:11.640]                         }
[17:48:11.640]                       }
[17:48:11.640]                     }
[17:48:11.640]                     invisible(muffled)
[17:48:11.640]                   }
[17:48:11.640]                   muffleCondition(cond)
[17:48:11.640]                 })
[17:48:11.640]             }))
[17:48:11.640]             future::FutureResult(value = ...future.value$value, 
[17:48:11.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.640]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.640]                     ...future.globalenv.names))
[17:48:11.640]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.640]         }, condition = base::local({
[17:48:11.640]             c <- base::c
[17:48:11.640]             inherits <- base::inherits
[17:48:11.640]             invokeRestart <- base::invokeRestart
[17:48:11.640]             length <- base::length
[17:48:11.640]             list <- base::list
[17:48:11.640]             seq.int <- base::seq.int
[17:48:11.640]             signalCondition <- base::signalCondition
[17:48:11.640]             sys.calls <- base::sys.calls
[17:48:11.640]             `[[` <- base::`[[`
[17:48:11.640]             `+` <- base::`+`
[17:48:11.640]             `<<-` <- base::`<<-`
[17:48:11.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.640]                   3L)]
[17:48:11.640]             }
[17:48:11.640]             function(cond) {
[17:48:11.640]                 is_error <- inherits(cond, "error")
[17:48:11.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.640]                   NULL)
[17:48:11.640]                 if (is_error) {
[17:48:11.640]                   sessionInformation <- function() {
[17:48:11.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.640]                       search = base::search(), system = base::Sys.info())
[17:48:11.640]                   }
[17:48:11.640]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.640]                     cond$call), session = sessionInformation(), 
[17:48:11.640]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.640]                   signalCondition(cond)
[17:48:11.640]                 }
[17:48:11.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.640]                 "immediateCondition"))) {
[17:48:11.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.640]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.640]                   if (TRUE && !signal) {
[17:48:11.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.640]                     {
[17:48:11.640]                       inherits <- base::inherits
[17:48:11.640]                       invokeRestart <- base::invokeRestart
[17:48:11.640]                       is.null <- base::is.null
[17:48:11.640]                       muffled <- FALSE
[17:48:11.640]                       if (inherits(cond, "message")) {
[17:48:11.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.640]                         if (muffled) 
[17:48:11.640]                           invokeRestart("muffleMessage")
[17:48:11.640]                       }
[17:48:11.640]                       else if (inherits(cond, "warning")) {
[17:48:11.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.640]                         if (muffled) 
[17:48:11.640]                           invokeRestart("muffleWarning")
[17:48:11.640]                       }
[17:48:11.640]                       else if (inherits(cond, "condition")) {
[17:48:11.640]                         if (!is.null(pattern)) {
[17:48:11.640]                           computeRestarts <- base::computeRestarts
[17:48:11.640]                           grepl <- base::grepl
[17:48:11.640]                           restarts <- computeRestarts(cond)
[17:48:11.640]                           for (restart in restarts) {
[17:48:11.640]                             name <- restart$name
[17:48:11.640]                             if (is.null(name)) 
[17:48:11.640]                               next
[17:48:11.640]                             if (!grepl(pattern, name)) 
[17:48:11.640]                               next
[17:48:11.640]                             invokeRestart(restart)
[17:48:11.640]                             muffled <- TRUE
[17:48:11.640]                             break
[17:48:11.640]                           }
[17:48:11.640]                         }
[17:48:11.640]                       }
[17:48:11.640]                       invisible(muffled)
[17:48:11.640]                     }
[17:48:11.640]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.640]                   }
[17:48:11.640]                 }
[17:48:11.640]                 else {
[17:48:11.640]                   if (TRUE) {
[17:48:11.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.640]                     {
[17:48:11.640]                       inherits <- base::inherits
[17:48:11.640]                       invokeRestart <- base::invokeRestart
[17:48:11.640]                       is.null <- base::is.null
[17:48:11.640]                       muffled <- FALSE
[17:48:11.640]                       if (inherits(cond, "message")) {
[17:48:11.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.640]                         if (muffled) 
[17:48:11.640]                           invokeRestart("muffleMessage")
[17:48:11.640]                       }
[17:48:11.640]                       else if (inherits(cond, "warning")) {
[17:48:11.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.640]                         if (muffled) 
[17:48:11.640]                           invokeRestart("muffleWarning")
[17:48:11.640]                       }
[17:48:11.640]                       else if (inherits(cond, "condition")) {
[17:48:11.640]                         if (!is.null(pattern)) {
[17:48:11.640]                           computeRestarts <- base::computeRestarts
[17:48:11.640]                           grepl <- base::grepl
[17:48:11.640]                           restarts <- computeRestarts(cond)
[17:48:11.640]                           for (restart in restarts) {
[17:48:11.640]                             name <- restart$name
[17:48:11.640]                             if (is.null(name)) 
[17:48:11.640]                               next
[17:48:11.640]                             if (!grepl(pattern, name)) 
[17:48:11.640]                               next
[17:48:11.640]                             invokeRestart(restart)
[17:48:11.640]                             muffled <- TRUE
[17:48:11.640]                             break
[17:48:11.640]                           }
[17:48:11.640]                         }
[17:48:11.640]                       }
[17:48:11.640]                       invisible(muffled)
[17:48:11.640]                     }
[17:48:11.640]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.640]                   }
[17:48:11.640]                 }
[17:48:11.640]             }
[17:48:11.640]         }))
[17:48:11.640]     }, error = function(ex) {
[17:48:11.640]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.640]                 ...future.rng), started = ...future.startTime, 
[17:48:11.640]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.640]             version = "1.8"), class = "FutureResult")
[17:48:11.640]     }, finally = {
[17:48:11.640]         if (!identical(...future.workdir, getwd())) 
[17:48:11.640]             setwd(...future.workdir)
[17:48:11.640]         {
[17:48:11.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.640]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.640]             }
[17:48:11.640]             base::options(...future.oldOptions)
[17:48:11.640]             if (.Platform$OS.type == "windows") {
[17:48:11.640]                 old_names <- names(...future.oldEnvVars)
[17:48:11.640]                 envs <- base::Sys.getenv()
[17:48:11.640]                 names <- names(envs)
[17:48:11.640]                 common <- intersect(names, old_names)
[17:48:11.640]                 added <- setdiff(names, old_names)
[17:48:11.640]                 removed <- setdiff(old_names, names)
[17:48:11.640]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.640]                   envs[common]]
[17:48:11.640]                 NAMES <- toupper(changed)
[17:48:11.640]                 args <- list()
[17:48:11.640]                 for (kk in seq_along(NAMES)) {
[17:48:11.640]                   name <- changed[[kk]]
[17:48:11.640]                   NAME <- NAMES[[kk]]
[17:48:11.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.640]                     next
[17:48:11.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.640]                 }
[17:48:11.640]                 NAMES <- toupper(added)
[17:48:11.640]                 for (kk in seq_along(NAMES)) {
[17:48:11.640]                   name <- added[[kk]]
[17:48:11.640]                   NAME <- NAMES[[kk]]
[17:48:11.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.640]                     next
[17:48:11.640]                   args[[name]] <- ""
[17:48:11.640]                 }
[17:48:11.640]                 NAMES <- toupper(removed)
[17:48:11.640]                 for (kk in seq_along(NAMES)) {
[17:48:11.640]                   name <- removed[[kk]]
[17:48:11.640]                   NAME <- NAMES[[kk]]
[17:48:11.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.640]                     next
[17:48:11.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.640]                 }
[17:48:11.640]                 if (length(args) > 0) 
[17:48:11.640]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.640]             }
[17:48:11.640]             else {
[17:48:11.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.640]             }
[17:48:11.640]             {
[17:48:11.640]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.640]                   0L) {
[17:48:11.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.640]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.640]                   base::options(opts)
[17:48:11.640]                 }
[17:48:11.640]                 {
[17:48:11.640]                   {
[17:48:11.640]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.640]                     NULL
[17:48:11.640]                   }
[17:48:11.640]                   options(future.plan = NULL)
[17:48:11.640]                   if (is.na(NA_character_)) 
[17:48:11.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.640]                     .init = FALSE)
[17:48:11.640]                 }
[17:48:11.640]             }
[17:48:11.640]         }
[17:48:11.640]     })
[17:48:11.640]     if (TRUE) {
[17:48:11.640]         base::sink(type = "output", split = FALSE)
[17:48:11.640]         if (TRUE) {
[17:48:11.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.640]         }
[17:48:11.640]         else {
[17:48:11.640]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.640]         }
[17:48:11.640]         base::close(...future.stdout)
[17:48:11.640]         ...future.stdout <- NULL
[17:48:11.640]     }
[17:48:11.640]     ...future.result$conditions <- ...future.conditions
[17:48:11.640]     ...future.result$finished <- base::Sys.time()
[17:48:11.640]     ...future.result
[17:48:11.640] }
[17:48:11.643] MultisessionFuture started
[17:48:11.643] - Launch lazy future ... done
[17:48:11.643] run() for ‘MultisessionFuture’ ... done
[17:48:11.643] getGlobalsAndPackages() ...
[17:48:11.644] Searching for globals...
[17:48:11.644] - globals found: [1] ‘{’
[17:48:11.644] Searching for globals ... DONE
[17:48:11.644] Resolving globals: FALSE
[17:48:11.645] 
[17:48:11.645] 
[17:48:11.645] getGlobalsAndPackages() ... DONE
[17:48:11.645] run() for ‘Future’ ...
[17:48:11.645] - state: ‘created’
[17:48:11.645] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:48:11.659] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:48:11.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:48:11.659]   - Field: ‘node’
[17:48:11.659]   - Field: ‘label’
[17:48:11.659]   - Field: ‘local’
[17:48:11.659]   - Field: ‘owner’
[17:48:11.659]   - Field: ‘envir’
[17:48:11.659]   - Field: ‘workers’
[17:48:11.660]   - Field: ‘packages’
[17:48:11.660]   - Field: ‘gc’
[17:48:11.660]   - Field: ‘conditions’
[17:48:11.660]   - Field: ‘persistent’
[17:48:11.660]   - Field: ‘expr’
[17:48:11.660]   - Field: ‘uuid’
[17:48:11.660]   - Field: ‘seed’
[17:48:11.660]   - Field: ‘version’
[17:48:11.660]   - Field: ‘result’
[17:48:11.660]   - Field: ‘asynchronous’
[17:48:11.660]   - Field: ‘calls’
[17:48:11.661]   - Field: ‘globals’
[17:48:11.661]   - Field: ‘stdout’
[17:48:11.661]   - Field: ‘earlySignal’
[17:48:11.661]   - Field: ‘lazy’
[17:48:11.661]   - Field: ‘state’
[17:48:11.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:48:11.661] - Launch lazy future ...
[17:48:11.661] Packages needed by the future expression (n = 0): <none>
[17:48:11.661] Packages needed by future strategies (n = 0): <none>
[17:48:11.662] {
[17:48:11.662]     {
[17:48:11.662]         {
[17:48:11.662]             ...future.startTime <- base::Sys.time()
[17:48:11.662]             {
[17:48:11.662]                 {
[17:48:11.662]                   {
[17:48:11.662]                     {
[17:48:11.662]                       base::local({
[17:48:11.662]                         has_future <- base::requireNamespace("future", 
[17:48:11.662]                           quietly = TRUE)
[17:48:11.662]                         if (has_future) {
[17:48:11.662]                           ns <- base::getNamespace("future")
[17:48:11.662]                           version <- ns[[".package"]][["version"]]
[17:48:11.662]                           if (is.null(version)) 
[17:48:11.662]                             version <- utils::packageVersion("future")
[17:48:11.662]                         }
[17:48:11.662]                         else {
[17:48:11.662]                           version <- NULL
[17:48:11.662]                         }
[17:48:11.662]                         if (!has_future || version < "1.8.0") {
[17:48:11.662]                           info <- base::c(r_version = base::gsub("R version ", 
[17:48:11.662]                             "", base::R.version$version.string), 
[17:48:11.662]                             platform = base::sprintf("%s (%s-bit)", 
[17:48:11.662]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:48:11.662]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:48:11.662]                               "release", "version")], collapse = " "), 
[17:48:11.662]                             hostname = base::Sys.info()[["nodename"]])
[17:48:11.662]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:48:11.662]                             info)
[17:48:11.662]                           info <- base::paste(info, collapse = "; ")
[17:48:11.662]                           if (!has_future) {
[17:48:11.662]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:48:11.662]                               info)
[17:48:11.662]                           }
[17:48:11.662]                           else {
[17:48:11.662]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:48:11.662]                               info, version)
[17:48:11.662]                           }
[17:48:11.662]                           base::stop(msg)
[17:48:11.662]                         }
[17:48:11.662]                       })
[17:48:11.662]                     }
[17:48:11.662]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:48:11.662]                     base::options(mc.cores = 1L)
[17:48:11.662]                   }
[17:48:11.662]                   ...future.strategy.old <- future::plan("list")
[17:48:11.662]                   options(future.plan = NULL)
[17:48:11.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:48:11.662]                 }
[17:48:11.662]                 ...future.workdir <- getwd()
[17:48:11.662]             }
[17:48:11.662]             ...future.oldOptions <- base::as.list(base::.Options)
[17:48:11.662]             ...future.oldEnvVars <- base::Sys.getenv()
[17:48:11.662]         }
[17:48:11.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:48:11.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:48:11.662]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:48:11.662]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:48:11.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:48:11.662]             future.stdout.windows.reencode = NULL, width = 80L)
[17:48:11.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:48:11.662]             base::names(...future.oldOptions))
[17:48:11.662]     }
[17:48:11.662]     if (FALSE) {
[17:48:11.662]     }
[17:48:11.662]     else {
[17:48:11.662]         if (TRUE) {
[17:48:11.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:48:11.662]                 open = "w")
[17:48:11.662]         }
[17:48:11.662]         else {
[17:48:11.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:48:11.662]                 windows = "NUL", "/dev/null"), open = "w")
[17:48:11.662]         }
[17:48:11.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:48:11.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:48:11.662]             base::sink(type = "output", split = FALSE)
[17:48:11.662]             base::close(...future.stdout)
[17:48:11.662]         }, add = TRUE)
[17:48:11.662]     }
[17:48:11.662]     ...future.frame <- base::sys.nframe()
[17:48:11.662]     ...future.conditions <- base::list()
[17:48:11.662]     ...future.rng <- base::globalenv()$.Random.seed
[17:48:11.662]     if (FALSE) {
[17:48:11.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:48:11.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:48:11.662]     }
[17:48:11.662]     ...future.result <- base::tryCatch({
[17:48:11.662]         base::withCallingHandlers({
[17:48:11.662]             ...future.value <- base::withVisible(base::local({
[17:48:11.662]                 ...future.makeSendCondition <- base::local({
[17:48:11.662]                   sendCondition <- NULL
[17:48:11.662]                   function(frame = 1L) {
[17:48:11.662]                     if (is.function(sendCondition)) 
[17:48:11.662]                       return(sendCondition)
[17:48:11.662]                     ns <- getNamespace("parallel")
[17:48:11.662]                     if (exists("sendData", mode = "function", 
[17:48:11.662]                       envir = ns)) {
[17:48:11.662]                       parallel_sendData <- get("sendData", mode = "function", 
[17:48:11.662]                         envir = ns)
[17:48:11.662]                       envir <- sys.frame(frame)
[17:48:11.662]                       master <- NULL
[17:48:11.662]                       while (!identical(envir, .GlobalEnv) && 
[17:48:11.662]                         !identical(envir, emptyenv())) {
[17:48:11.662]                         if (exists("master", mode = "list", envir = envir, 
[17:48:11.662]                           inherits = FALSE)) {
[17:48:11.662]                           master <- get("master", mode = "list", 
[17:48:11.662]                             envir = envir, inherits = FALSE)
[17:48:11.662]                           if (inherits(master, c("SOCKnode", 
[17:48:11.662]                             "SOCK0node"))) {
[17:48:11.662]                             sendCondition <<- function(cond) {
[17:48:11.662]                               data <- list(type = "VALUE", value = cond, 
[17:48:11.662]                                 success = TRUE)
[17:48:11.662]                               parallel_sendData(master, data)
[17:48:11.662]                             }
[17:48:11.662]                             return(sendCondition)
[17:48:11.662]                           }
[17:48:11.662]                         }
[17:48:11.662]                         frame <- frame + 1L
[17:48:11.662]                         envir <- sys.frame(frame)
[17:48:11.662]                       }
[17:48:11.662]                     }
[17:48:11.662]                     sendCondition <<- function(cond) NULL
[17:48:11.662]                   }
[17:48:11.662]                 })
[17:48:11.662]                 withCallingHandlers({
[17:48:11.662]                   {
[17:48:11.662]                     3
[17:48:11.662]                   }
[17:48:11.662]                 }, immediateCondition = function(cond) {
[17:48:11.662]                   sendCondition <- ...future.makeSendCondition()
[17:48:11.662]                   sendCondition(cond)
[17:48:11.662]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.662]                   {
[17:48:11.662]                     inherits <- base::inherits
[17:48:11.662]                     invokeRestart <- base::invokeRestart
[17:48:11.662]                     is.null <- base::is.null
[17:48:11.662]                     muffled <- FALSE
[17:48:11.662]                     if (inherits(cond, "message")) {
[17:48:11.662]                       muffled <- grepl(pattern, "muffleMessage")
[17:48:11.662]                       if (muffled) 
[17:48:11.662]                         invokeRestart("muffleMessage")
[17:48:11.662]                     }
[17:48:11.662]                     else if (inherits(cond, "warning")) {
[17:48:11.662]                       muffled <- grepl(pattern, "muffleWarning")
[17:48:11.662]                       if (muffled) 
[17:48:11.662]                         invokeRestart("muffleWarning")
[17:48:11.662]                     }
[17:48:11.662]                     else if (inherits(cond, "condition")) {
[17:48:11.662]                       if (!is.null(pattern)) {
[17:48:11.662]                         computeRestarts <- base::computeRestarts
[17:48:11.662]                         grepl <- base::grepl
[17:48:11.662]                         restarts <- computeRestarts(cond)
[17:48:11.662]                         for (restart in restarts) {
[17:48:11.662]                           name <- restart$name
[17:48:11.662]                           if (is.null(name)) 
[17:48:11.662]                             next
[17:48:11.662]                           if (!grepl(pattern, name)) 
[17:48:11.662]                             next
[17:48:11.662]                           invokeRestart(restart)
[17:48:11.662]                           muffled <- TRUE
[17:48:11.662]                           break
[17:48:11.662]                         }
[17:48:11.662]                       }
[17:48:11.662]                     }
[17:48:11.662]                     invisible(muffled)
[17:48:11.662]                   }
[17:48:11.662]                   muffleCondition(cond)
[17:48:11.662]                 })
[17:48:11.662]             }))
[17:48:11.662]             future::FutureResult(value = ...future.value$value, 
[17:48:11.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.662]                   ...future.rng), globalenv = if (FALSE) 
[17:48:11.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:48:11.662]                     ...future.globalenv.names))
[17:48:11.662]                 else NULL, started = ...future.startTime, version = "1.8")
[17:48:11.662]         }, condition = base::local({
[17:48:11.662]             c <- base::c
[17:48:11.662]             inherits <- base::inherits
[17:48:11.662]             invokeRestart <- base::invokeRestart
[17:48:11.662]             length <- base::length
[17:48:11.662]             list <- base::list
[17:48:11.662]             seq.int <- base::seq.int
[17:48:11.662]             signalCondition <- base::signalCondition
[17:48:11.662]             sys.calls <- base::sys.calls
[17:48:11.662]             `[[` <- base::`[[`
[17:48:11.662]             `+` <- base::`+`
[17:48:11.662]             `<<-` <- base::`<<-`
[17:48:11.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:48:11.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:48:11.662]                   3L)]
[17:48:11.662]             }
[17:48:11.662]             function(cond) {
[17:48:11.662]                 is_error <- inherits(cond, "error")
[17:48:11.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:48:11.662]                   NULL)
[17:48:11.662]                 if (is_error) {
[17:48:11.662]                   sessionInformation <- function() {
[17:48:11.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:48:11.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:48:11.662]                       search = base::search(), system = base::Sys.info())
[17:48:11.662]                   }
[17:48:11.662]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:48:11.662]                     cond$call), session = sessionInformation(), 
[17:48:11.662]                     timestamp = base::Sys.time(), signaled = 0L)
[17:48:11.662]                   signalCondition(cond)
[17:48:11.662]                 }
[17:48:11.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:48:11.662]                 "immediateCondition"))) {
[17:48:11.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:48:11.662]                   ...future.conditions[[length(...future.conditions) + 
[17:48:11.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:48:11.662]                   if (TRUE && !signal) {
[17:48:11.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.662]                     {
[17:48:11.662]                       inherits <- base::inherits
[17:48:11.662]                       invokeRestart <- base::invokeRestart
[17:48:11.662]                       is.null <- base::is.null
[17:48:11.662]                       muffled <- FALSE
[17:48:11.662]                       if (inherits(cond, "message")) {
[17:48:11.662]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.662]                         if (muffled) 
[17:48:11.662]                           invokeRestart("muffleMessage")
[17:48:11.662]                       }
[17:48:11.662]                       else if (inherits(cond, "warning")) {
[17:48:11.662]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.662]                         if (muffled) 
[17:48:11.662]                           invokeRestart("muffleWarning")
[17:48:11.662]                       }
[17:48:11.662]                       else if (inherits(cond, "condition")) {
[17:48:11.662]                         if (!is.null(pattern)) {
[17:48:11.662]                           computeRestarts <- base::computeRestarts
[17:48:11.662]                           grepl <- base::grepl
[17:48:11.662]                           restarts <- computeRestarts(cond)
[17:48:11.662]                           for (restart in restarts) {
[17:48:11.662]                             name <- restart$name
[17:48:11.662]                             if (is.null(name)) 
[17:48:11.662]                               next
[17:48:11.662]                             if (!grepl(pattern, name)) 
[17:48:11.662]                               next
[17:48:11.662]                             invokeRestart(restart)
[17:48:11.662]                             muffled <- TRUE
[17:48:11.662]                             break
[17:48:11.662]                           }
[17:48:11.662]                         }
[17:48:11.662]                       }
[17:48:11.662]                       invisible(muffled)
[17:48:11.662]                     }
[17:48:11.662]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.662]                   }
[17:48:11.662]                 }
[17:48:11.662]                 else {
[17:48:11.662]                   if (TRUE) {
[17:48:11.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:48:11.662]                     {
[17:48:11.662]                       inherits <- base::inherits
[17:48:11.662]                       invokeRestart <- base::invokeRestart
[17:48:11.662]                       is.null <- base::is.null
[17:48:11.662]                       muffled <- FALSE
[17:48:11.662]                       if (inherits(cond, "message")) {
[17:48:11.662]                         muffled <- grepl(pattern, "muffleMessage")
[17:48:11.662]                         if (muffled) 
[17:48:11.662]                           invokeRestart("muffleMessage")
[17:48:11.662]                       }
[17:48:11.662]                       else if (inherits(cond, "warning")) {
[17:48:11.662]                         muffled <- grepl(pattern, "muffleWarning")
[17:48:11.662]                         if (muffled) 
[17:48:11.662]                           invokeRestart("muffleWarning")
[17:48:11.662]                       }
[17:48:11.662]                       else if (inherits(cond, "condition")) {
[17:48:11.662]                         if (!is.null(pattern)) {
[17:48:11.662]                           computeRestarts <- base::computeRestarts
[17:48:11.662]                           grepl <- base::grepl
[17:48:11.662]                           restarts <- computeRestarts(cond)
[17:48:11.662]                           for (restart in restarts) {
[17:48:11.662]                             name <- restart$name
[17:48:11.662]                             if (is.null(name)) 
[17:48:11.662]                               next
[17:48:11.662]                             if (!grepl(pattern, name)) 
[17:48:11.662]                               next
[17:48:11.662]                             invokeRestart(restart)
[17:48:11.662]                             muffled <- TRUE
[17:48:11.662]                             break
[17:48:11.662]                           }
[17:48:11.662]                         }
[17:48:11.662]                       }
[17:48:11.662]                       invisible(muffled)
[17:48:11.662]                     }
[17:48:11.662]                     muffleCondition(cond, pattern = "^muffle")
[17:48:11.662]                   }
[17:48:11.662]                 }
[17:48:11.662]             }
[17:48:11.662]         }))
[17:48:11.662]     }, error = function(ex) {
[17:48:11.662]         base::structure(base::list(value = NULL, visible = NULL, 
[17:48:11.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:48:11.662]                 ...future.rng), started = ...future.startTime, 
[17:48:11.662]             finished = Sys.time(), session_uuid = NA_character_, 
[17:48:11.662]             version = "1.8"), class = "FutureResult")
[17:48:11.662]     }, finally = {
[17:48:11.662]         if (!identical(...future.workdir, getwd())) 
[17:48:11.662]             setwd(...future.workdir)
[17:48:11.662]         {
[17:48:11.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:48:11.662]                 ...future.oldOptions$nwarnings <- NULL
[17:48:11.662]             }
[17:48:11.662]             base::options(...future.oldOptions)
[17:48:11.662]             if (.Platform$OS.type == "windows") {
[17:48:11.662]                 old_names <- names(...future.oldEnvVars)
[17:48:11.662]                 envs <- base::Sys.getenv()
[17:48:11.662]                 names <- names(envs)
[17:48:11.662]                 common <- intersect(names, old_names)
[17:48:11.662]                 added <- setdiff(names, old_names)
[17:48:11.662]                 removed <- setdiff(old_names, names)
[17:48:11.662]                 changed <- common[...future.oldEnvVars[common] != 
[17:48:11.662]                   envs[common]]
[17:48:11.662]                 NAMES <- toupper(changed)
[17:48:11.662]                 args <- list()
[17:48:11.662]                 for (kk in seq_along(NAMES)) {
[17:48:11.662]                   name <- changed[[kk]]
[17:48:11.662]                   NAME <- NAMES[[kk]]
[17:48:11.662]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.662]                     next
[17:48:11.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.662]                 }
[17:48:11.662]                 NAMES <- toupper(added)
[17:48:11.662]                 for (kk in seq_along(NAMES)) {
[17:48:11.662]                   name <- added[[kk]]
[17:48:11.662]                   NAME <- NAMES[[kk]]
[17:48:11.662]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.662]                     next
[17:48:11.662]                   args[[name]] <- ""
[17:48:11.662]                 }
[17:48:11.662]                 NAMES <- toupper(removed)
[17:48:11.662]                 for (kk in seq_along(NAMES)) {
[17:48:11.662]                   name <- removed[[kk]]
[17:48:11.662]                   NAME <- NAMES[[kk]]
[17:48:11.662]                   if (name != NAME && is.element(NAME, old_names)) 
[17:48:11.662]                     next
[17:48:11.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:48:11.662]                 }
[17:48:11.662]                 if (length(args) > 0) 
[17:48:11.662]                   base::do.call(base::Sys.setenv, args = args)
[17:48:11.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:48:11.662]             }
[17:48:11.662]             else {
[17:48:11.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:48:11.662]             }
[17:48:11.662]             {
[17:48:11.662]                 if (base::length(...future.futureOptionsAdded) > 
[17:48:11.662]                   0L) {
[17:48:11.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:48:11.662]                   base::names(opts) <- ...future.futureOptionsAdded
[17:48:11.662]                   base::options(opts)
[17:48:11.662]                 }
[17:48:11.662]                 {
[17:48:11.662]                   {
[17:48:11.662]                     base::options(mc.cores = ...future.mc.cores.old)
[17:48:11.662]                     NULL
[17:48:11.662]                   }
[17:48:11.662]                   options(future.plan = NULL)
[17:48:11.662]                   if (is.na(NA_character_)) 
[17:48:11.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:48:11.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:48:11.662]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:48:11.662]                     .init = FALSE)
[17:48:11.662]                 }
[17:48:11.662]             }
[17:48:11.662]         }
[17:48:11.662]     })
[17:48:11.662]     if (TRUE) {
[17:48:11.662]         base::sink(type = "output", split = FALSE)
[17:48:11.662]         if (TRUE) {
[17:48:11.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:48:11.662]         }
[17:48:11.662]         else {
[17:48:11.662]             ...future.result["stdout"] <- base::list(NULL)
[17:48:11.662]         }
[17:48:11.662]         base::close(...future.stdout)
[17:48:11.662]         ...future.stdout <- NULL
[17:48:11.662]     }
[17:48:11.662]     ...future.result$conditions <- ...future.conditions
[17:48:11.662]     ...future.result$finished <- base::Sys.time()
[17:48:11.662]     ...future.result
[17:48:11.662] }
[17:48:11.664] Poll #1 (0): usedNodes() = 2, workers = 2
[17:48:11.675] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.675] - Validating connection of MultisessionFuture
[17:48:11.675] - received message: FutureResult
[17:48:11.675] - Received FutureResult
[17:48:11.675] - Erased future from FutureRegistry
[17:48:11.675] result() for ClusterFuture ...
[17:48:11.675] - result already collected: FutureResult
[17:48:11.676] result() for ClusterFuture ... done
[17:48:11.676] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.676] result() for ClusterFuture ...
[17:48:11.676] - result already collected: FutureResult
[17:48:11.676] result() for ClusterFuture ... done
[17:48:11.676] result() for ClusterFuture ...
[17:48:11.676] - result already collected: FutureResult
[17:48:11.676] result() for ClusterFuture ... done
[17:48:11.677] MultisessionFuture started
[17:48:11.677] - Launch lazy future ... done
[17:48:11.677] run() for ‘MultisessionFuture’ ... done
[17:48:11.678] resolve() on list environment ...
[17:48:11.678]  recursive: 0
[17:48:11.679]  length: 4
[17:48:11.679]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:48:11.679] Future #1
[17:48:11.679]  length: 3 (resolved future 1)
[17:48:11.690] receiveMessageFromWorker() for ClusterFuture ...
[17:48:11.690] - Validating connection of MultisessionFuture
[17:48:11.690] - received message: FutureResult
[17:48:11.691] - Received FutureResult
[17:48:11.691] - Erased future from FutureRegistry
[17:48:11.691] result() for ClusterFuture ...
[17:48:11.691] - result already collected: FutureResult
[17:48:11.691] result() for ClusterFuture ... done
[17:48:11.691] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:11.691] Future #3
[17:48:11.691]  length: 2 (resolved future 3)
[17:48:11.691]  length: 1 (resolved future 4)
[17:48:12.155] receiveMessageFromWorker() for ClusterFuture ...
[17:48:12.156] - Validating connection of MultisessionFuture
[17:48:12.156] - received message: FutureResult
[17:48:12.156] - Received FutureResult
[17:48:12.156] - Erased future from FutureRegistry
[17:48:12.156] result() for ClusterFuture ...
[17:48:12.156] - result already collected: FutureResult
[17:48:12.156] result() for ClusterFuture ... done
[17:48:12.156] receiveMessageFromWorker() for ClusterFuture ... done
[17:48:12.157] Future #2
[17:48:12.157]  length: 0 (resolved future 2)
[17:48:12.157] resolve() on list environment ... DONE
[17:48:12.157] resolve() on list environment ...
[17:48:12.157]  recursive: 0
[17:48:12.158]  length: 4
[17:48:12.158]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:48:12.158] Future #1
[17:48:12.158]  length: 3 (resolved future 1)
[17:48:12.158] Future #2
[17:48:12.158]  length: 2 (resolved future 2)
[17:48:12.159] Future #3
[17:48:12.159]  length: 1 (resolved future 3)
[17:48:12.159]  length: 0 (resolved future 4)
[17:48:12.159] resolve() on list environment ... DONE
[17:48:12.159] resolve() on list environment ...
[17:48:12.160]  recursive: 0
[17:48:12.160]  length: 4
[17:48:12.160]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:48:12.160] Future #1
[17:48:12.160]  length: 3 (resolved future 1)
[17:48:12.161] Future #2
[17:48:12.161]  length: 2 (resolved future 2)
[17:48:12.161] Future #3
[17:48:12.161]  length: 1 (resolved future 3)
[17:48:12.161]  length: 0 (resolved future 4)
[17:48:12.161] resolve() on list environment ... DONE
[17:48:12.161] resolve() on list environment ...
[17:48:12.162]  recursive: 0
[17:48:12.162]  length: 4
[17:48:12.162]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:48:12.162] Future #1
[17:48:12.162]  length: 3 (resolved future 1)
[17:48:12.163] Future #2
[17:48:12.163]  length: 2 (resolved future 2)
[17:48:12.163] Future #3
[17:48:12.163]  length: 1 (resolved future 3)
[17:48:12.163]  length: 0 (resolved future 4)
[17:48:12.163] resolve() on list environment ... DONE
[17:48:12.163] resolve() on list environment ...
[17:48:12.164]  recursive: 0
[17:48:12.164]  length: 4
[17:48:12.164]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:48:12.164] Future #1
[17:48:12.164] result() for ClusterFuture ...
[17:48:12.165] - result already collected: FutureResult
[17:48:12.165] result() for ClusterFuture ... done
[17:48:12.165] result() for ClusterFuture ...
[17:48:12.165] - result already collected: FutureResult
[17:48:12.165] result() for ClusterFuture ... done
[17:48:12.165]  length: 3 (resolved future 1)
[17:48:12.165] Future #2
[17:48:12.165] result() for ClusterFuture ...
[17:48:12.165] - result already collected: FutureResult
[17:48:12.165] result() for ClusterFuture ... done
[17:48:12.165] result() for ClusterFuture ...
[17:48:12.166] - result already collected: FutureResult
[17:48:12.166] result() for ClusterFuture ... done
[17:48:12.166]  length: 2 (resolved future 2)
[17:48:12.166] Future #3
[17:48:12.166] result() for ClusterFuture ...
[17:48:12.166] - result already collected: FutureResult
[17:48:12.166] result() for ClusterFuture ... done
[17:48:12.166] result() for ClusterFuture ...
[17:48:12.166] - result already collected: FutureResult
[17:48:12.166] result() for ClusterFuture ... done
[17:48:12.167]  length: 1 (resolved future 3)
[17:48:12.167]  length: 0 (resolved future 4)
[17:48:12.167] resolve() on list environment ... DONE
[17:48:12.170] resolve() on list environment ...
[17:48:12.170]  recursive: 99
[17:48:12.171]  length: 4
[17:48:12.171]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:48:12.171] Future #1
[17:48:12.171] result() for ClusterFuture ...
[17:48:12.172] - result already collected: FutureResult
[17:48:12.172] result() for ClusterFuture ... done
[17:48:12.172] result() for ClusterFuture ...
[17:48:12.172] - result already collected: FutureResult
[17:48:12.172] result() for ClusterFuture ... done
[17:48:12.172] A MultisessionFuture was resolved
[17:48:12.172]  length: 3 (resolved future 1)
[17:48:12.172] Future #2
[17:48:12.172] result() for ClusterFuture ...
[17:48:12.172] - result already collected: FutureResult
[17:48:12.172] result() for ClusterFuture ... done
[17:48:12.173] result() for ClusterFuture ...
[17:48:12.173] - result already collected: FutureResult
[17:48:12.173] result() for ClusterFuture ... done
[17:48:12.173] A MultisessionFuture was resolved
[17:48:12.173]  length: 2 (resolved future 2)
[17:48:12.173] Future #3
[17:48:12.173] result() for ClusterFuture ...
[17:48:12.173] - result already collected: FutureResult
[17:48:12.173] result() for ClusterFuture ... done
[17:48:12.173] result() for ClusterFuture ...
[17:48:12.173] - result already collected: FutureResult
[17:48:12.174] result() for ClusterFuture ... done
[17:48:12.174] A MultisessionFuture was resolved
[17:48:12.174]  length: 1 (resolved future 3)
[17:48:12.174]  length: 0 (resolved future 4)
[17:48:12.174] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[17:48:12.177] resolve() on list ...
[17:48:12.177]  recursive: 0
[17:48:12.177]  length: 3
[17:48:12.178] 
[17:48:12.178]  length: 2 (resolved future 1)
[17:48:12.178]  length: 1 (resolved future 2)
[17:48:12.178]  length: 0 (resolved future 3)
[17:48:12.178] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[17:48:12.179] plan(): Setting new future strategy stack:
[17:48:12.179] List of future strategies:
[17:48:12.179] 1. FutureStrategy:
[17:48:12.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:48:12.179]    - tweaked: FALSE
[17:48:12.179]    - call: future::plan(oplan)
[17:48:12.180] plan(): nbrOfWorkers() = 1
> 
